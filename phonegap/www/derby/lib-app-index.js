require=(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module '"+n+"'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({"racer":[function(require,module,exports){
module.exports=require('eS5xJL');
},{}],"eS5xJL":[function(require,module,exports){
var Racer = require('./Racer');
module.exports = new Racer;

},{"./Racer":1}],"derby":[function(require,module,exports){
module.exports=require('dhy1vc');
},{}],"dhy1vc":[function(require,module,exports){
(function(__dirname){var racer = require('racer');
var derby = module.exports = Object.create(racer);

var derbyPlugin = (racer.util.isServer) ?
  __dirname + '/derby.server' :
  require('./derby.browser');

// TODO: Remove or implement
derby.get = function() {}

derby
  // Server-side or browser-side methods
  .use(derbyPlugin);

})("/node_modules/derby/lib")
},{"racer":"eS5xJL","./derby.browser":2}],3:[function(require,module,exports){
module.exports = function (app) {
  app.fn('user', {
    changeEmail: function (e) {
      var origin = this.model.get('$config.origin');
      $.post(origin + '/user/changeEmail', e.at().get());
    },
    changePassword: function (e) {
      var origin = this.model.get('$config.origin');
      $.post(origin + '/user/changePassword', e.at().get(), function () {
        e.at().del();
      });
    },
    changeUsername: function (e) {
      var origin = this.model.get('$config.origin');
      $.post(origin + '/user/changeUsername', e.at().get());
    },
    connect: {
      facebook: function (e) {
        var origin = this.model.get('$config.origin');
        $.popupWindow(origin + '/user/auth/facebook');
      },
      google: function (e) {
        var origin = this.model.get('$config.origin');
        $.popupWindow(origin + '/user/auth/google');
      },
      twitter: function (e) {
        var origin = this.model.get('$config.origin');
        $.popupWindow(origin + '/user/auth/twitter');
      }
    },
    forgotPassword: function (e) {
      var origin = this.model.get('$config.origin');
      $.post(origin + '/user/forgotPassword', e.at().get(), function () {
        e.at().del();
        e.at().set('success', true);
      });
    },
    resetPassword: function (e) {
      var self = this, origin = this.model.get('$config.origin');
      $.post(origin + '/user/resetPassword', e.at().get(), function (data) {
        self.model.set('_session.user.id', e.at().get('userId'));
        self.model.set('_session.user.isRegistered', true);
      });
    },
    signin: function (e) {
      var self = this, origin = this.model.get('$config.origin');
      $.post(origin + '/user/signin', e.at().get(), function (data) {
        self.model.set('_session.user.id', data.user.id);
        self.model.set('_session.user.isRegistered', true);
      });
    },
    signout: function (e) {
      var self = this, origin = this.model.get('$config.origin');
      $.post(origin + '/user/signout', function (data) {
        self.model.set('_session.user.id', data.user.id);
        self.model.set('_session.user.isRegistered', false);
      });
    },
    signup: function (e) {
      var self = this, origin = this.model.get('$config.origin');
      $.post(origin + '/user/signup', e.at().get(), function () {
        self.model.set('_session.user.isRegistered', true);
      });
    },
    verifyEmail: function (e) {
      var self = this, origin = this.model.get('$config.origin');
      $.post(origin + '/user/verifyEmail', e.at().get());
    }
  });
};
},{}],4:[function(require,module,exports){
module.exports = function (app) {
  app.ready(function (model) {
    model.on('change', '$connection.state', function (state) {
      if (state !== 'connected') return;
      if (model.get('_session.user.id')) return;
      var origin = model.get('$config.origin');
      $.ajax({type: 'POST', url: origin + '/user/sessionize'}).done(function (data) {
        model.set('_session.user.id', data.user.id);
        model.set('_session.user.registered', data.user.registered);
      });
    });

    model.on('change', '_session.user.id', function (userId) {
      if (!userId) return;
      var $private = model.at('usersPrivate.' + userId);
      var $public = model.at('usersPublic.' + userId);
      model.subscribe($private, $public, function (err) {
        if (err) return console.error(err);
        model.ref('_page.user.private', $private);
        model.ref('_page.user.public', $public);
        var isRegistered = $public.get('isRegistered');
        if (model.get('_page.private') && !isRegistered) return app.history.push('/');
        if (model.get('_page.public') && isRegistered) app.history.push('/settings');
      });
    });

    model.on('change', '_session.user.isRegistered', function (isRegistered) {
      if (model.get('_page.private') && !isRegistered) return app.history.push('/');
      if (model.get('_page.public') && isRegistered) app.history.push('/settings');
    });
  });
};
},{}],5:[function(require,module,exports){
module.exports = function (app) {
  app.get('*', function (page, model, params, next) {
    var userId = model.get('_session.user.id');
    if (!userId) return next();
    var $private = model.at('usersPrivate.' + userId);
    var $public = model.at('usersPublic.' + userId);
    model.subscribe($private, $public, function (err) {
      if (err) return next(err);
      model.ref('_page.user.private', $private);
      model.ref('_page.user.public', $public);
      next();
    });
  });
};
},{}],6:[function(require,module,exports){
module.exports = function (app) {
  app.get('/', function (page) {
    page.render('home');
  });

  app.get('/403', function (page) {
    page.render('403');
  });

  app.get('/404', function (page) {
    page.render('404');
  });

  app.get('/404', function (page) {
    page.render('404');
  });

  app.get('/500', function (page) {
    page.render('500');
  });

  app.get('/forgot', function (page, model) {
    model.set('_page.public', true);
    page.render('forgot');
  });

  app.get('/reset/:userId/:token', function (page, model) {
    model.set('_page.form.token', page.params.token);
    model.set('_page.form.userId', page.params.userId);
    model.set('_page.public', true);
    page.render('reset');
  });

  app.get('/settings', function (page, model) {
    model.setNull('_page.form.username.username', model.get('_page.user.public.local.username'));
    model.setNull('_page.form.email.email', model.get('_page.user.private.local.emails.0.value'));
    model.set('_page.private', true);
    page.render('settings');
  });

  app.get('/signin', function (page, model) {
    model.set('_page.public', true);
    page.render('signin');
  });

  app.get('/signup', function (page, model) {
    model.set('_page.public', true);
    page.render('signup');
  });

  app.get('/user/auth/:provider/done', function (page, model) {
    page.render('home');
  });

  app.enter('/user/auth/:provider/done', function (model) {
    if (!window.opener) return;
    var userId = model.get('_session.user.id');
    window.opener.DERBY.app.model.set('_session.user.id', userId);
    window.opener.DERBY.app.model.set('_session.user.registered', true);
    window.close();
  });
};
},{}],7:[function(require,module,exports){
module.exports = function (app) {
  app.view.fn('user.displayName', function (public) {
    if (public.local) return public.local.username;
    if (public.facebook) return public.facebook.displayName;
    if (public.google) return public.google.displayName;
    if (public.twitter) return public.twitter.displayName;
  });

  app.view.fn('user.photoUrl', function (public) {
    if (public.facebook) return 'https://graph.facebook.com/' + public.facebook.username + '/picture';
    if (public.google && public.google.photos && public.google.photos[0]) return public.google.photos[0].value;
    if (public.twitter && public.twitter.photos && public.twitter.photos[0]) return public.twitter.photos[0].value;
    if (public.gravatar && public.gravatar.thumbnailUrl) return public.gravatar.thumbnailUrl;
  });
};
},{}],8:[function(require,module,exports){
var racer = require('racer');
var BCSocket = require('browserchannel/dist/bcsocket-uncompressed').BCSocket;

racer.Model.prototype._createSocket = function(bundle) {
  var options = bundle.racerBrowserChannel;
  var base = options.base || 'http://localhost:3000/channel';
  if (bundle.mount) base = bundle.mount + base;
  return new BCSocket(base, options);
};

},{"racer":"eS5xJL","browserchannel/dist/bcsocket-uncompressed":9}],10:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],1:[function(require,module,exports){
(function(process,__dirname){var EventEmitter = require('events').EventEmitter;
var Model = require('./Model');
var util = require('./util');

module.exports = Racer;

function Racer() {
  EventEmitter.call(this);
}

util.mergeInto(Racer.prototype, EventEmitter.prototype);

// Make classes accessible for use by plugins and tests
Racer.prototype.Model = Model;
Racer.prototype.util = util;

// Support plugins on racer instances
Racer.prototype.use = util.use;

Racer.prototype.init = function(data) {
  var racer = this;

  process.env.NODE_ENV = data.nodeEnv;

  // Init is executed async so that plugins can extend Racer even if they are
  // included after the main entry point in the bundle
  process.nextTick(function() {
    var model = new Model;

    model._createConnection(data);

    racer.emit('model', model);

    // Re-create documents for all model data
    for (var collectionName in data.collections) {
      var collection = data.collections[collectionName];
      for (var id in collection) {
        var doc = model.getOrCreateDoc(collectionName, id, collection[id]);
        if (doc.shareDoc) {
          model._loadVersions[collectionName + '.' + id] = doc.shareDoc.version;
        }
      }
    }

    // TODO: Support re-init when there are contexts other than root
    var context = data.contexts.root;
    // Re-subscribe to document subscriptions
    for (var path in context.subscribedDocs) {
      var segments = path.split('.');
      model.subscribeDoc(segments[0], segments[1]);
      model._subscribedDocs[path] = context.subscribedDocs[path];
    }
    // Init fetchedDocs counts
    for (var path in context.fetchedDocs) {
      model._fetchedDocs[path] = context.fetchedDocs[path];
    }

    var silentModel = model.silent();
    // Re-create refs
    for (var i = 0; i < data.refs.length; i++) {
      var item = data.refs[i];
      silentModel.ref(item[0], item[1]);
    }
    // Re-create refLists
    for (var i = 0; i < data.refLists.length; i++) {
      var item = data.refLists[i];
      silentModel.refList(item[0], item[1], item[2], item[3]);
    }
    // Re-create fns
    for (var i = 0; i < data.fns.length; i++) {
      var item = data.fns[i];
      silentModel.start.apply(silentModel, item);
    }
    // Re-create filters
    for (var i = 0; i < data.filters.length; i++) {
      var item = data.filters[i];
      var filter = model._filters.add(item[0], item[1], item[2]);
      filter.ref(item[3]);
    }
    // Init and re-subscribe queries as appropriate
    model._initQueries(data.queries);

    racer._model = model;
    racer.emit('ready', model);
  });
  return this;
};

Racer.prototype.ready = function(cb) {
  if (this._model) {
    // Callback async in case the code depends on scripts included after in
    // the bundle and is gated by a ready
    process.nextTick(function() {
      cb(this._model);
    });
    return;
  }
  this.once('ready', cb);
};

util.serverRequire(__dirname + '/Racer.server.js');

})(require("__browserify_process"),"/node_modules/derby/node_modules/racer/lib")
},{"events":11,"./util":12,"./Model":13,"__browserify_process":10}],11:[function(require,module,exports){
(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};

var EventEmitter = exports.EventEmitter = process.EventEmitter;
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]'
    }
;
function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (x === xs[i]) return i;
    }
    return -1;
}

// By default EventEmitters will print a warning if more than
// 10 listeners are added to it. This is a useful default which
// helps finding memory leaks.
//
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!this._events) this._events = {};
  this._events.maxListeners = n;
};


EventEmitter.prototype.emit = function(type) {
  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events || !this._events.error ||
        (isArray(this._events.error) && !this._events.error.length))
    {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }
  }

  if (!this._events) return false;
  var handler = this._events[type];
  if (!handler) return false;

  if (typeof handler == 'function') {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        var args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
    return true;

  } else if (isArray(handler)) {
    var args = Array.prototype.slice.call(arguments, 1);

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i].apply(this, args);
    }
    return true;

  } else {
    return false;
  }
};

// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('addListener only takes instances of Function');
  }

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  } else if (isArray(this._events[type])) {

    // Check for listener leak
    if (!this._events[type].warned) {
      var m;
      if (this._events.maxListeners !== undefined) {
        m = this._events.maxListeners;
      } else {
        m = defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }

    // If we've already got an array, just append.
    this._events[type].push(listener);
  } else {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  var self = this;
  self.on(type, function g() {
    self.removeListener(type, g);
    listener.apply(this, arguments);
  });

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('removeListener only takes instances of Function');
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (!this._events || !this._events[type]) return this;

  var list = this._events[type];

  if (isArray(list)) {
    var i = indexOf(list, listener);
    if (i < 0) return this;
    list.splice(i, 1);
    if (list.length == 0)
      delete this._events[type];
  } else if (this._events[type] === listener) {
    delete this._events[type];
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  if (arguments.length === 0) {
    this._events = {};
    return this;
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (type && this._events && this._events[type]) this._events[type] = null;
  return this;
};

EventEmitter.prototype.listeners = function(type) {
  if (!this._events) this._events = {};
  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
};

})(require("__browserify_process"))
},{"__browserify_process":10}],14:[function(require,module,exports){
var app = require('derby')
  .createApp(module)
  .use(require('../../ui'))
  .use(require('derby-ui-github-buttons'));

require('./controllerFns')(app);
require('./events')(app);
require('./user')(app);
require('./routes')(app);
require('./viewFns')(app);
},{"derby":"dhy1vc","./controllerFns":3,"./events":4,"./user":5,"./routes":6,"./viewFns":7,"../../ui":15,"derby-ui-github-buttons":16}],15:[function(require,module,exports){
(function(__filename){var config = {
  filename: __filename,
  scripts: {
    connectionAlert: require('./connectionAlert')
  }
};

module.exports = function (app, options) {
  app.createLibrary(config, options);
};
})("/ui/index.js")
},{"./connectionAlert":17}],9:[function(require,module,exports){
(function(){
function e() {
  return function() {
  }
}
function m(a) {
  return function(b) {
    this[a] = b
  }
}
function aa(a) {
  return function() {
    return this[a]
  }
}
function ba(a) {
  return function() {
    return a
  }
}
var p, ca = ca || {}, q = this;
function da(a) {
  a = a.split(".");
  for(var b = q, c;c = a.shift();) {
    if(null != b[c]) {
      b = b[c]
    }else {
      return null
    }
  }
  return b
}
function ea() {
}
function fa(a) {
  var b = typeof a;
  if("object" == b) {
    if(a) {
      if(a instanceof Array) {
        return"array"
      }
      if(a instanceof Object) {
        return b
      }
      var c = Object.prototype.toString.call(a);
      if("[object Window]" == c) {
        return"object"
      }
      if("[object Array]" == c || "number" == typeof a.length && "undefined" != typeof a.splice && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("splice")) {
        return"array"
      }
      if("[object Function]" == c || "undefined" != typeof a.call && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("call")) {
        return"function"
      }
    }else {
      return"null"
    }
  }else {
    if("function" == b && "undefined" == typeof a.call) {
      return"object"
    }
  }
  return b
}
function s(a) {
  return"array" == fa(a)
}
function ga(a) {
  var b = fa(a);
  return"array" == b || "object" == b && "number" == typeof a.length
}
function u(a) {
  return"string" == typeof a
}
function ha(a) {
  return"function" == fa(a)
}
function v(a) {
  return a[ia] || (a[ia] = ++ja)
}
var ia = "closure_uid_" + (1E9 * Math.random() >>> 0), ja = 0;
function ka(a, b, c) {
  return a.call.apply(a.bind, arguments)
}
function la(a, b, c) {
  if(!a) {
    throw Error();
  }
  if(2 < arguments.length) {
    var d = Array.prototype.slice.call(arguments, 2);
    return function() {
      var c = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(c, d);
      return a.apply(b, c)
    }
  }
  return function() {
    return a.apply(b, arguments)
  }
}
function w(a, b, c) {
  w = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? ka : la;
  return w.apply(null, arguments)
}
var x = Date.now || function() {
  return+new Date
};
function y(a, b) {
  function c() {
  }
  c.prototype = b.prototype;
  a.ra = b.prototype;
  a.prototype = new c
}
;function ma(a, b) {
  for(var c = 1;c < arguments.length;c++) {
    var d = String(arguments[c]).replace(/\$/g, "$$$$");
    a = a.replace(/\%s/, d)
  }
  return a
}
function na(a) {
  if(!oa.test(a)) {
    return a
  }
  -1 != a.indexOf("&") && (a = a.replace(pa, "&amp;"));
  -1 != a.indexOf("<") && (a = a.replace(qa, "&lt;"));
  -1 != a.indexOf(">") && (a = a.replace(ra, "&gt;"));
  -1 != a.indexOf('"') && (a = a.replace(sa, "&quot;"));
  return a
}
var pa = /&/g, qa = /</g, ra = />/g, sa = /\"/g, oa = /[&<>\"]/;
var z, ta, ua, va;
function wa() {
  return q.navigator ? q.navigator.userAgent : null
}
va = ua = ta = z = !1;
var xa;
if(xa = wa()) {
  var ya = q.navigator;
  z = 0 == xa.indexOf("Opera");
  ta = !z && -1 != xa.indexOf("MSIE");
  ua = !z && -1 != xa.indexOf("WebKit");
  va = !z && !ua && "Gecko" == ya.product
}
var za = z, A = ta, Aa = va, B = ua, Ba = q.navigator, Ca = -1 != (Ba && Ba.platform || "").indexOf("Mac");
function Da() {
  var a = q.document;
  return a ? a.documentMode : void 0
}
var Ea;
a: {
  var Fa = "", Ga;
  if(za && q.opera) {
    var Ha = q.opera.version, Fa = "function" == typeof Ha ? Ha() : Ha
  }else {
    if(Aa ? Ga = /rv\:([^\);]+)(\)|;)/ : A ? Ga = /MSIE\s+([^\);]+)(\)|;)/ : B && (Ga = /WebKit\/(\S+)/), Ga) {
      var Ia = Ga.exec(wa()), Fa = Ia ? Ia[1] : ""
    }
  }
  if(A) {
    var Ja = Da();
    if(Ja > parseFloat(Fa)) {
      Ea = String(Ja);
      break a
    }
  }
  Ea = Fa
}
var Ka = {};
function C(a) {
  var b;
  if(!(b = Ka[a])) {
    b = 0;
    for(var c = String(Ea).replace(/^[\s\xa0]+|[\s\xa0]+$/g, "").split("."), d = String(a).replace(/^[\s\xa0]+|[\s\xa0]+$/g, "").split("."), f = Math.max(c.length, d.length), g = 0;0 == b && g < f;g++) {
      var h = c[g] || "", n = d[g] || "", k = RegExp("(\\d*)(\\D*)", "g"), t = RegExp("(\\d*)(\\D*)", "g");
      do {
        var l = k.exec(h) || ["", "", ""], r = t.exec(n) || ["", "", ""];
        if(0 == l[0].length && 0 == r[0].length) {
          break
        }
        b = ((0 == l[1].length ? 0 : parseInt(l[1], 10)) < (0 == r[1].length ? 0 : parseInt(r[1], 10)) ? -1 : (0 == l[1].length ? 0 : parseInt(l[1], 10)) > (0 == r[1].length ? 0 : parseInt(r[1], 10)) ? 1 : 0) || ((0 == l[2].length) < (0 == r[2].length) ? -1 : (0 == l[2].length) > (0 == r[2].length) ? 1 : 0) || (l[2] < r[2] ? -1 : l[2] > r[2] ? 1 : 0)
      }while(0 == b)
    }
    b = Ka[a] = 0 <= b
  }
  return b
}
var La = q.document, Ma = La && A ? Da() || ("CSS1Compat" == La.compatMode ? parseInt(Ea, 10) : 5) : void 0;
function Na(a) {
  Error.captureStackTrace ? Error.captureStackTrace(this, Na) : this.stack = Error().stack || "";
  a && (this.message = String(a))
}
y(Na, Error);
Na.prototype.name = "CustomError";
function Oa(a, b) {
  b.unshift(a);
  Na.call(this, ma.apply(null, b));
  b.shift();
  this.Jc = a
}
y(Oa, Na);
Oa.prototype.name = "AssertionError";
function Pa(a, b) {
  throw new Oa("Failure" + (a ? ": " + a : ""), Array.prototype.slice.call(arguments, 1));
}
;var Qa = RegExp("^(?:([^:/?#.]+):)?(?://(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#(.*))?$");
function Ra(a) {
  var b = Sa, c;
  for(c in b) {
    a.call(void 0, b[c], c, b)
  }
}
function Ta(a) {
  var b = [], c = 0, d;
  for(d in a) {
    b[c++] = a[d]
  }
  return b
}
function Ua(a) {
  var b = [], c = 0, d;
  for(d in a) {
    b[c++] = d
  }
  return b
}
var Va = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
function Wa(a, b) {
  for(var c, d, f = 1;f < arguments.length;f++) {
    d = arguments[f];
    for(c in d) {
      a[c] = d[c]
    }
    for(var g = 0;g < Va.length;g++) {
      c = Va[g], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c])
    }
  }
}
;var D = Array.prototype, Xa = D.indexOf ? function(a, b, c) {
  return D.indexOf.call(a, b, c)
} : function(a, b, c) {
  c = null == c ? 0 : 0 > c ? Math.max(0, a.length + c) : c;
  if(u(a)) {
    return u(b) && 1 == b.length ? a.indexOf(b, c) : -1
  }
  for(;c < a.length;c++) {
    if(c in a && a[c] === b) {
      return c
    }
  }
  return-1
}, Ya = D.forEach ? function(a, b, c) {
  D.forEach.call(a, b, c)
} : function(a, b, c) {
  for(var d = a.length, f = u(a) ? a.split("") : a, g = 0;g < d;g++) {
    g in f && b.call(c, f[g], g, a)
  }
};
function Za(a) {
  return D.concat.apply(D, arguments)
}
function $a(a) {
  var b = a.length;
  if(0 < b) {
    for(var c = Array(b), d = 0;d < b;d++) {
      c[d] = a[d]
    }
    return c
  }
  return[]
}
;function ab(a) {
  if("function" == typeof a.N) {
    return a.N()
  }
  if(u(a)) {
    return a.split("")
  }
  if(ga(a)) {
    for(var b = [], c = a.length, d = 0;d < c;d++) {
      b.push(a[d])
    }
    return b
  }
  return Ta(a)
}
function E(a, b, c) {
  if("function" == typeof a.forEach) {
    a.forEach(b, c)
  }else {
    if(ga(a) || u(a)) {
      Ya(a, b, c)
    }else {
      var d;
      if("function" == typeof a.ka) {
        d = a.ka()
      }else {
        if("function" != typeof a.N) {
          if(ga(a) || u(a)) {
            d = [];
            for(var f = a.length, g = 0;g < f;g++) {
              d.push(g)
            }
          }else {
            d = Ua(a)
          }
        }else {
          d = void 0
        }
      }
      for(var f = ab(a), g = f.length, h = 0;h < g;h++) {
        b.call(c, f[h], d && d[h], a)
      }
    }
  }
}
;function bb(a, b) {
  this.O = {};
  this.j = [];
  var c = arguments.length;
  if(1 < c) {
    if(c % 2) {
      throw Error("Uneven number of arguments");
    }
    for(var d = 0;d < c;d += 2) {
      this.set(arguments[d], arguments[d + 1])
    }
  }else {
    if(a) {
      a instanceof bb ? (c = a.ka(), d = a.N()) : (c = Ua(a), d = Ta(a));
      for(var f = 0;f < c.length;f++) {
        this.set(c[f], d[f])
      }
    }
  }
}
p = bb.prototype;
p.f = 0;
p.bc = 0;
p.N = function() {
  cb(this);
  for(var a = [], b = 0;b < this.j.length;b++) {
    a.push(this.O[this.j[b]])
  }
  return a
};
p.ka = function() {
  cb(this);
  return this.j.concat()
};
p.ia = function(a) {
  return db(this.O, a)
};
p.remove = function(a) {
  return db(this.O, a) ? (delete this.O[a], this.f--, this.bc++, this.j.length > 2 * this.f && cb(this), !0) : !1
};
function cb(a) {
  if(a.f != a.j.length) {
    for(var b = 0, c = 0;b < a.j.length;) {
      var d = a.j[b];
      db(a.O, d) && (a.j[c++] = d);
      b++
    }
    a.j.length = c
  }
  if(a.f != a.j.length) {
    for(var f = {}, c = b = 0;b < a.j.length;) {
      d = a.j[b], db(f, d) || (a.j[c++] = d, f[d] = 1), b++
    }
    a.j.length = c
  }
}
p.get = function(a, b) {
  return db(this.O, a) ? this.O[a] : b
};
p.set = function(a, b) {
  db(this.O, a) || (this.f++, this.j.push(a), this.bc++);
  this.O[a] = b
};
p.n = function() {
  return new bb(this)
};
function db(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b)
}
;function F(a, b) {
  var c;
  if(a instanceof F) {
    this.D = void 0 !== b ? b : a.D, eb(this, a.qa), c = a.ab, H(this), this.ab = c, fb(this, a.ja), gb(this, a.Ba), hb(this, a.H), ib(this, a.R.n()), c = a.Ma, H(this), this.Ma = c
  }else {
    if(a && (c = String(a).match(Qa))) {
      this.D = !!b;
      eb(this, c[1] || "", !0);
      var d = c[2] || "";
      H(this);
      this.ab = d ? decodeURIComponent(d) : "";
      fb(this, c[3] || "", !0);
      gb(this, c[4]);
      hb(this, c[5] || "", !0);
      ib(this, c[6] || "", !0);
      c = c[7] || "";
      H(this);
      this.Ma = c ? decodeURIComponent(c) : ""
    }else {
      this.D = !!b, this.R = new jb(null, 0, this.D)
    }
  }
}
p = F.prototype;
p.qa = "";
p.ab = "";
p.ja = "";
p.Ba = null;
p.H = "";
p.Ma = "";
p.mc = !1;
p.D = !1;
p.toString = function() {
  var a = [], b = this.qa;
  b && a.push(kb(b, lb), ":");
  if(b = this.ja) {
    a.push("//");
    var c = this.ab;
    c && a.push(kb(c, lb), "@");
    a.push(encodeURIComponent(String(b)));
    b = this.Ba;
    null != b && a.push(":", String(b))
  }
  if(b = this.H) {
    this.ja && "/" != b.charAt(0) && a.push("/"), a.push(kb(b, "/" == b.charAt(0) ? mb : nb))
  }
  (b = this.R.toString()) && a.push("?", b);
  (b = this.Ma) && a.push("#", kb(b, ob));
  return a.join("")
};
p.n = function() {
  return new F(this)
};
function eb(a, b, c) {
  H(a);
  a.qa = c ? b ? decodeURIComponent(b) : "" : b;
  a.qa && (a.qa = a.qa.replace(/:$/, ""))
}
function fb(a, b, c) {
  H(a);
  a.ja = c ? b ? decodeURIComponent(b) : "" : b
}
function gb(a, b) {
  H(a);
  if(b) {
    b = Number(b);
    if(isNaN(b) || 0 > b) {
      throw Error("Bad port number " + b);
    }
    a.Ba = b
  }else {
    a.Ba = null
  }
}
function hb(a, b, c) {
  H(a);
  a.H = c ? b ? decodeURIComponent(b) : "" : b
}
function ib(a, b, c) {
  H(a);
  b instanceof jb ? (a.R = b, a.R.qb(a.D)) : (c || (b = kb(b, pb)), a.R = new jb(b, 0, a.D))
}
function I(a, b, c) {
  H(a);
  a.R.set(b, c)
}
function qb(a, b, c) {
  H(a);
  s(c) || (c = [String(c)]);
  rb(a.R, b, c)
}
function J(a) {
  H(a);
  I(a, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ x()).toString(36));
  return a
}
function H(a) {
  if(a.mc) {
    throw Error("Tried to modify a read-only Uri");
  }
}
p.qb = function(a) {
  this.D = a;
  this.R && this.R.qb(a);
  return this
};
function sb(a, b, c, d) {
  var f = new F(null, void 0);
  a && eb(f, a);
  b && fb(f, b);
  c && gb(f, c);
  d && hb(f, d);
  return f
}
function kb(a, b) {
  return u(a) ? encodeURI(a).replace(b, tb) : null
}
function tb(a) {
  a = a.charCodeAt(0);
  return"%" + (a >> 4 & 15).toString(16) + (a & 15).toString(16)
}
var lb = /[#\/\?@]/g, nb = /[\#\?:]/g, mb = /[\#\?]/g, pb = /[\#\?@]/g, ob = /#/g;
function jb(a, b, c) {
  this.C = a || null;
  this.D = !!c
}
function K(a) {
  if(!a.i && (a.i = new bb, a.f = 0, a.C)) {
    for(var b = a.C.split("&"), c = 0;c < b.length;c++) {
      var d = b[c].indexOf("="), f = null, g = null;
      0 <= d ? (f = b[c].substring(0, d), g = b[c].substring(d + 1)) : f = b[c];
      f = decodeURIComponent(f.replace(/\+/g, " "));
      f = L(a, f);
      a.add(f, g ? decodeURIComponent(g.replace(/\+/g, " ")) : "")
    }
  }
}
p = jb.prototype;
p.i = null;
p.f = null;
p.add = function(a, b) {
  K(this);
  this.C = null;
  a = L(this, a);
  var c = this.i.get(a);
  c || this.i.set(a, c = []);
  c.push(b);
  this.f++;
  return this
};
p.remove = function(a) {
  K(this);
  a = L(this, a);
  return this.i.ia(a) ? (this.C = null, this.f -= this.i.get(a).length, this.i.remove(a)) : !1
};
p.ia = function(a) {
  K(this);
  a = L(this, a);
  return this.i.ia(a)
};
p.ka = function() {
  K(this);
  for(var a = this.i.N(), b = this.i.ka(), c = [], d = 0;d < b.length;d++) {
    for(var f = a[d], g = 0;g < f.length;g++) {
      c.push(b[d])
    }
  }
  return c
};
p.N = function(a) {
  K(this);
  var b = [];
  if(a) {
    this.ia(a) && (b = Za(b, this.i.get(L(this, a))))
  }else {
    a = this.i.N();
    for(var c = 0;c < a.length;c++) {
      b = Za(b, a[c])
    }
  }
  return b
};
p.set = function(a, b) {
  K(this);
  this.C = null;
  a = L(this, a);
  this.ia(a) && (this.f -= this.i.get(a).length);
  this.i.set(a, [b]);
  this.f++;
  return this
};
p.get = function(a, b) {
  var c = a ? this.N(a) : [];
  return 0 < c.length ? String(c[0]) : b
};
function rb(a, b, c) {
  a.remove(b);
  0 < c.length && (a.C = null, a.i.set(L(a, b), $a(c)), a.f += c.length)
}
p.toString = function() {
  if(this.C) {
    return this.C
  }
  if(!this.i) {
    return""
  }
  for(var a = [], b = this.i.ka(), c = 0;c < b.length;c++) {
    for(var d = b[c], f = encodeURIComponent(String(d)), d = this.N(d), g = 0;g < d.length;g++) {
      var h = f;
      "" !== d[g] && (h += "=" + encodeURIComponent(String(d[g])));
      a.push(h)
    }
  }
  return this.C = a.join("&")
};
p.n = function() {
  var a = new jb;
  a.C = this.C;
  this.i && (a.i = this.i.n(), a.f = this.f);
  return a
};
function L(a, b) {
  var c = String(b);
  a.D && (c = c.toLowerCase());
  return c
}
p.qb = function(a) {
  a && !this.D && (K(this), this.C = null, E(this.i, function(a, c) {
    var d = c.toLowerCase();
    c != d && (this.remove(c), rb(this, d, a))
  }, this));
  this.D = a
};
function ub() {
}
ub.prototype.Ga = null;
var vb;
function wb() {
}
y(wb, ub);
function xb(a) {
  return(a = yb(a)) ? new ActiveXObject(a) : new XMLHttpRequest
}
function zb(a) {
  var b = {};
  yb(a) && (b[0] = !0, b[1] = !0);
  return b
}
function yb(a) {
  if(!a.Gb && "undefined" == typeof XMLHttpRequest && "undefined" != typeof ActiveXObject) {
    for(var b = ["MSXML2.XMLHTTP.6.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP"], c = 0;c < b.length;c++) {
      var d = b[c];
      try {
        return new ActiveXObject(d), a.Gb = d
      }catch(f) {
      }
    }
    throw Error("Could not create ActiveXObject. ActiveX might be disabled, or MSXML might not be installed");
  }
  return a.Gb
}
vb = new wb;
function M() {
  0 != Ab && (this.Gc = Error().stack, Bb[v(this)] = this)
}
var Ab = 0, Bb = {};
M.prototype.yb = !1;
M.prototype.Ia = function() {
  if(!this.yb && (this.yb = !0, this.u(), 0 != Ab)) {
    var a = v(this);
    delete Bb[a]
  }
};
M.prototype.u = function() {
  if(this.Nb) {
    for(;this.Nb.length;) {
      this.Nb.shift()()
    }
  }
};
function N(a, b) {
  this.type = a;
  this.currentTarget = this.target = b
}
p = N.prototype;
p.u = e();
p.Ia = e();
p.na = !1;
p.defaultPrevented = !1;
p.Wa = !0;
p.preventDefault = function() {
  this.defaultPrevented = !0;
  this.Wa = !1
};
var Cb = 0;
function Db() {
}
p = Db.prototype;
p.key = 0;
p.ea = !1;
p.Ha = !1;
p.Oa = function(a, b, c, d, f, g) {
  if(ha(a)) {
    this.Ib = !0
  }else {
    if(a && a.handleEvent && ha(a.handleEvent)) {
      this.Ib = !1
    }else {
      throw Error("Invalid listener argument");
    }
  }
  this.W = a;
  this.Ub = b;
  this.src = c;
  this.type = d;
  this.capture = !!f;
  this.lb = g;
  this.Ha = !1;
  this.key = ++Cb;
  this.ea = !1
};
p.handleEvent = function(a) {
  return this.Ib ? this.W.call(this.lb || this.src, a) : this.W.handleEvent.call(this.W, a)
};
var Eb = !A || A && 9 <= Ma, Fb = A && !C("9");
!B || C("528");
Aa && C("1.9b") || A && C("8") || za && C("9.5") || B && C("528");
Aa && !C("8") || A && C("9");
function Gb(a) {
  Gb[" "](a);
  return a
}
Gb[" "] = ea;
function Hb(a, b) {
  a && this.Oa(a, b)
}
y(Hb, N);
p = Hb.prototype;
p.target = null;
p.relatedTarget = null;
p.offsetX = 0;
p.offsetY = 0;
p.clientX = 0;
p.clientY = 0;
p.screenX = 0;
p.screenY = 0;
p.button = 0;
p.keyCode = 0;
p.charCode = 0;
p.ctrlKey = !1;
p.altKey = !1;
p.shiftKey = !1;
p.metaKey = !1;
p.yc = !1;
p.zb = null;
p.Oa = function(a, b) {
  var c = this.type = a.type;
  N.call(this, c);
  this.target = a.target || a.srcElement;
  this.currentTarget = b;
  var d = a.relatedTarget;
  if(d) {
    if(Aa) {
      var f;
      a: {
        try {
          Gb(d.nodeName);
          f = !0;
          break a
        }catch(g) {
        }
        f = !1
      }
      f || (d = null)
    }
  }else {
    "mouseover" == c ? d = a.fromElement : "mouseout" == c && (d = a.toElement)
  }
  this.relatedTarget = d;
  this.offsetX = B || void 0 !== a.offsetX ? a.offsetX : a.layerX;
  this.offsetY = B || void 0 !== a.offsetY ? a.offsetY : a.layerY;
  this.clientX = void 0 !== a.clientX ? a.clientX : a.pageX;
  this.clientY = void 0 !== a.clientY ? a.clientY : a.pageY;
  this.screenX = a.screenX || 0;
  this.screenY = a.screenY || 0;
  this.button = a.button;
  this.keyCode = a.keyCode || 0;
  this.charCode = a.charCode || ("keypress" == c ? a.keyCode : 0);
  this.ctrlKey = a.ctrlKey;
  this.altKey = a.altKey;
  this.shiftKey = a.shiftKey;
  this.metaKey = a.metaKey;
  this.yc = Ca ? a.metaKey : a.ctrlKey;
  this.state = a.state;
  this.zb = a;
  a.defaultPrevented && this.preventDefault();
  delete this.na
};
p.preventDefault = function() {
  Hb.ra.preventDefault.call(this);
  var a = this.zb;
  if(a.preventDefault) {
    a.preventDefault()
  }else {
    if(a.returnValue = !1, Fb) {
      try {
        if(a.ctrlKey || 112 <= a.keyCode && 123 >= a.keyCode) {
          a.keyCode = -1
        }
      }catch(b) {
      }
    }
  }
};
p.u = e();
var Sa = {}, O = {}, P = {}, Ib = {};
function Jb(a, b, c, d, f) {
  if(s(b)) {
    for(var g = 0;g < b.length;g++) {
      Jb(a, b[g], c, d, f)
    }
    return null
  }
  a: {
    if(!b) {
      throw Error("Invalid event type");
    }
    d = !!d;
    var h = O;
    b in h || (h[b] = {f:0, t:0});
    h = h[b];
    d in h || (h[d] = {f:0, t:0}, h.f++);
    var h = h[d], g = v(a), n;
    h.t++;
    if(h[g]) {
      n = h[g];
      for(var k = 0;k < n.length;k++) {
        if(h = n[k], h.W == c && h.lb == f) {
          if(h.ea) {
            break
          }
          n[k].Ha = !1;
          a = n[k];
          break a
        }
      }
    }else {
      n = h[g] = [], h.f++
    }
    k = Kb();
    h = new Db;
    h.Oa(c, k, a, b, d, f);
    h.Ha = !1;
    k.src = a;
    k.W = h;
    n.push(h);
    P[g] || (P[g] = []);
    P[g].push(h);
    a.addEventListener ? a != q && a.wb || a.addEventListener(b, k, d) : a.attachEvent(b in Ib ? Ib[b] : Ib[b] = "on" + b, k);
    a = h
  }
  b = a.key;
  Sa[b] = a;
  return b
}
function Kb() {
  var a = Lb, b = Eb ? function(c) {
    return a.call(b.src, b.W, c)
  } : function(c) {
    c = a.call(b.src, b.W, c);
    if(!c) {
      return c
    }
  };
  return b
}
function Mb(a, b, c, d, f) {
  if(s(b)) {
    for(var g = 0;g < b.length;g++) {
      Mb(a, b[g], c, d, f)
    }
  }else {
    d = !!d;
    a: {
      g = O;
      if(b in g && (g = g[b], d in g && (g = g[d], a = v(a), g[a]))) {
        a = g[a];
        break a
      }
      a = null
    }
    if(a) {
      for(g = 0;g < a.length;g++) {
        if(a[g].W == c && a[g].capture == d && a[g].lb == f) {
          Nb(a[g].key);
          break
        }
      }
    }
  }
}
function Nb(a) {
  var b = Sa[a];
  if(!b || b.ea) {
    return!1
  }
  var c = b.src, d = b.type, f = b.Ub, g = b.capture;
  c.removeEventListener ? c != q && c.wb || c.removeEventListener(d, f, g) : c.detachEvent && c.detachEvent(d in Ib ? Ib[d] : Ib[d] = "on" + d, f);
  c = v(c);
  if(P[c]) {
    var f = P[c], h = Xa(f, b);
    0 <= h && D.splice.call(f, h, 1);
    0 == f.length && delete P[c]
  }
  b.ea = !0;
  if(b = O[d][g][c]) {
    b.Mb = !0, Ob(d, g, c, b)
  }
  delete Sa[a];
  return!0
}
function Ob(a, b, c, d) {
  if(!d.Qa && d.Mb) {
    for(var f = 0, g = 0;f < d.length;f++) {
      d[f].ea ? d[f].Ub.src = null : (f != g && (d[g] = d[f]), g++)
    }
    d.length = g;
    d.Mb = !1;
    0 == g && (delete O[a][b][c], O[a][b].f--, 0 == O[a][b].f && (delete O[a][b], O[a].f--), 0 == O[a].f && delete O[a])
  }
}
function Pb(a) {
  var b = 0;
  if(null != a) {
    if(a = v(a), P[a]) {
      a = P[a];
      for(var c = a.length - 1;0 <= c;c--) {
        Nb(a[c].key), b++
      }
    }
  }else {
    Ra(function(a, c) {
      Nb(c);
      b++
    })
  }
}
function Qb(a, b, c, d, f) {
  var g = 1;
  b = v(b);
  if(a[b]) {
    var h = --a.t, n = a[b];
    n.Qa ? n.Qa++ : n.Qa = 1;
    try {
      for(var k = n.length, t = 0;t < k;t++) {
        var l = n[t];
        l && !l.ea && (g &= !1 !== Rb(l, f))
      }
    }finally {
      a.t = Math.max(h, a.t), n.Qa--, Ob(c, d, b, n)
    }
  }
  return Boolean(g)
}
function Rb(a, b) {
  a.Ha && Nb(a.key);
  return a.handleEvent(b)
}
function Lb(a, b) {
  if(a.ea) {
    return!0
  }
  var c = a.type, d = O;
  if(!(c in d)) {
    return!0
  }
  var d = d[c], f, g;
  if(!Eb) {
    f = b || da("window.event");
    var h = !0 in d, n = !1 in d;
    if(h) {
      if(0 > f.keyCode || void 0 != f.returnValue) {
        return!0
      }
      a: {
        var k = !1;
        if(0 == f.keyCode) {
          try {
            f.keyCode = -1;
            break a
          }catch(t) {
            k = !0
          }
        }
        if(k || void 0 == f.returnValue) {
          f.returnValue = !0
        }
      }
    }
    k = new Hb;
    k.Oa(f, this);
    f = !0;
    try {
      if(h) {
        for(var l = [], r = k.currentTarget;r;r = r.parentNode) {
          l.push(r)
        }
        g = d[!0];
        g.t = g.f;
        for(var G = l.length - 1;!k.na && 0 <= G && g.t;G--) {
          k.currentTarget = l[G], f &= Qb(g, l[G], c, !0, k)
        }
        if(n) {
          for(g = d[!1], g.t = g.f, G = 0;!k.na && G < l.length && g.t;G++) {
            k.currentTarget = l[G], f &= Qb(g, l[G], c, !1, k)
          }
        }
      }else {
        f = Rb(a, k)
      }
    }finally {
      l && (l.length = 0)
    }
    return f
  }
  c = new Hb(b, this);
  return f = Rb(a, c)
}
;function Sb() {
  M.call(this)
}
y(Sb, M);
p = Sb.prototype;
p.wb = !0;
p.pb = null;
p.addEventListener = function(a, b, c, d) {
  Jb(this, a, b, c, d)
};
p.removeEventListener = function(a, b, c, d) {
  Mb(this, a, b, c, d)
};
p.dispatchEvent = function(a) {
  var b = a.type || a, c = O;
  if(b in c) {
    if(u(a)) {
      a = new N(a, this)
    }else {
      if(a instanceof N) {
        a.target = a.target || this
      }else {
        var d = a;
        a = new N(b, this);
        Wa(a, d)
      }
    }
    var d = 1, f, c = c[b], b = !0 in c, g;
    if(b) {
      f = [];
      for(g = this;g;g = g.pb) {
        f.push(g)
      }
      g = c[!0];
      g.t = g.f;
      for(var h = f.length - 1;!a.na && 0 <= h && g.t;h--) {
        a.currentTarget = f[h], d &= Qb(g, f[h], a.type, !0, a) && !1 != a.Wa
      }
    }
    if(!1 in c) {
      if(g = c[!1], g.t = g.f, b) {
        for(h = 0;!a.na && h < f.length && g.t;h++) {
          a.currentTarget = f[h], d &= Qb(g, f[h], a.type, !1, a) && !1 != a.Wa
        }
      }else {
        for(f = this;!a.na && f && g.t;f = f.pb) {
          a.currentTarget = f, d &= Qb(g, f, a.type, !1, a) && !1 != a.Wa
        }
      }
    }
    a = Boolean(d)
  }else {
    a = !0
  }
  return a
};
p.u = function() {
  Sb.ra.u.call(this);
  Pb(this);
  this.pb = null
};
function Tb(a, b) {
  M.call(this);
  this.da = a || 1;
  this.Ea = b || q;
  this.eb = w(this.Ec, this);
  this.ob = x()
}
y(Tb, Sb);
p = Tb.prototype;
p.enabled = !1;
p.r = null;
p.setInterval = function(a) {
  this.da = a;
  this.r && this.enabled ? (this.stop(), this.start()) : this.r && this.stop()
};
p.Ec = function() {
  if(this.enabled) {
    var a = x() - this.ob;
    0 < a && a < 0.8 * this.da ? this.r = this.Ea.setTimeout(this.eb, this.da - a) : (this.dispatchEvent(Ub), this.enabled && (this.r = this.Ea.setTimeout(this.eb, this.da), this.ob = x()))
  }
};
p.start = function() {
  this.enabled = !0;
  this.r || (this.r = this.Ea.setTimeout(this.eb, this.da), this.ob = x())
};
p.stop = function() {
  this.enabled = !1;
  this.r && (this.Ea.clearTimeout(this.r), this.r = null)
};
p.u = function() {
  Tb.ra.u.call(this);
  this.stop();
  delete this.Ea
};
var Ub = "tick";
function Vb(a) {
  M.call(this);
  this.e = a;
  this.j = []
}
y(Vb, M);
var Wb = [];
function Xb(a, b, c, d) {
  s(c) || (Wb[0] = c, c = Wb);
  for(var f = 0;f < c.length;f++) {
    var g = Jb(b, c[f], d || a, !1, a.e || a);
    a.j.push(g)
  }
}
Vb.prototype.u = function() {
  Vb.ra.u.call(this);
  Ya(this.j, Nb);
  this.j.length = 0
};
Vb.prototype.handleEvent = function() {
  throw Error("EventHandler.handleEvent not implemented");
};
function Yb(a, b, c) {
  M.call(this);
  this.nc = a;
  this.da = b;
  this.e = c;
  this.hc = w(this.tc, this)
}
y(Yb, M);
p = Yb.prototype;
p.Xa = !1;
p.Tb = 0;
p.r = null;
p.stop = function() {
  this.r && (q.clearTimeout(this.r), this.r = null, this.Xa = !1)
};
p.u = function() {
  Yb.ra.u.call(this);
  this.stop()
};
p.tc = function() {
  this.r = null;
  this.Xa && !this.Tb && (this.Xa = !1, Zb(this))
};
function Zb(a) {
  var b;
  b = a.hc;
  var c = a.da;
  if(!ha(b)) {
    if(b && "function" == typeof b.handleEvent) {
      b = w(b.handleEvent, b)
    }else {
      throw Error("Invalid listener argument");
    }
  }
  b = 2147483647 < c ? -1 : q.setTimeout(b, c || 0);
  a.r = b;
  a.nc.call(a.e)
}
;function Q(a, b, c, d, f) {
  this.b = a;
  this.a = b;
  this.Z = c;
  this.B = d;
  this.Ca = f || 1;
  this.Da = $b;
  this.jb = new Vb(this);
  this.Sa = new Tb;
  this.Sa.setInterval(ac)
}
p = Q.prototype;
p.v = null;
p.J = !1;
p.ua = null;
p.sb = null;
p.pa = null;
p.sa = null;
p.T = null;
p.w = null;
p.X = null;
p.l = null;
p.Fa = 0;
p.K = null;
p.ta = null;
p.p = null;
p.h = -1;
p.Xb = !0;
p.aa = !1;
p.oa = 0;
p.Ta = null;
var $b = 45E3, ac = 250;
function bc(a, b) {
  switch(a) {
    case 0:
      return"Non-200 return code (" + b + ")";
    case 1:
      return"XMLHTTP failure (no data)";
    case 2:
      return"HttpConnection timeout";
    default:
      return"Unknown error"
  }
}
var cc = {}, dc = {};
function ec() {
  return!A || A && 10 <= Ma
}
p = Q.prototype;
p.Y = m("v");
p.setTimeout = m("Da");
p.$b = m("oa");
function fc(a, b, c) {
  a.sa = 1;
  a.T = J(b.n());
  a.X = c;
  a.xb = !0;
  gc(a, null)
}
function hc(a, b, c, d, f) {
  a.sa = 1;
  a.T = J(b.n());
  a.X = null;
  a.xb = c;
  f && (a.Xb = !1);
  gc(a, d)
}
function gc(a, b) {
  a.pa = x();
  ic(a);
  a.w = a.T.n();
  qb(a.w, "t", a.Ca);
  a.Fa = 0;
  a.l = a.b.hb(a.b.Ya() ? b : null);
  0 < a.oa && (a.Ta = new Yb(w(a.dc, a, a.l), a.oa));
  Xb(a.jb, a.l, "readystatechange", a.Ac);
  var c;
  if(a.v) {
    c = a.v;
    var d = {}, f;
    for(f in c) {
      d[f] = c[f]
    }
    c = d
  }else {
    c = {}
  }
  a.X ? (a.ta = "POST", c["Content-Type"] = "application/x-www-form-urlencoded", a.l.send(a.w, a.ta, a.X, c)) : (a.ta = "GET", a.Xb && !B && (c.Connection = "close"), a.l.send(a.w, a.ta, null, c));
  a.b.G(jc);
  if(d = a.X) {
    for(c = "", d = d.split("&"), f = 0;f < d.length;f++) {
      var g = d[f].split("=");
      if(1 < g.length) {
        var h = g[0], g = g[1], n = h.split("_");
        c = 2 <= n.length && "type" == n[1] ? c + (h + "=" + g + "&") : c + (h + "=redacted&")
      }
    }
  }else {
    c = null
  }
  a.a.info("XMLHTTP REQ (" + a.B + ") [attempt " + a.Ca + "]: " + a.ta + "\n" + a.w + "\n" + c)
}
p.Ac = function(a) {
  a = a.target;
  var b = this.Ta;
  b && 3 == R(a) ? (this.a.debug("Throttling readystatechange."), b.r || b.Tb ? b.Xa = !0 : Zb(b)) : this.dc(a)
};
p.dc = function(a) {
  try {
    if(a == this.l) {
      a: {
        var b = R(this.l), c = this.l.la, d = kc(this.l);
        if(!ec() || B && !C("420+")) {
          if(4 > b) {
            break a
          }
        }else {
          if(3 > b || 3 == b && !za && !lc(this.l)) {
            break a
          }
        }
        this.aa || (4 != b || c == mc) || (c == nc || 0 >= d ? this.b.G(oc) : this.b.G(pc));
        qc(this);
        var f = kc(this.l);
        this.h = f;
        var g = lc(this.l);
        g || this.a.debug("No response text for uri " + this.w + " status " + f);
        this.J = 200 == f;
        this.a.info("XMLHTTP RESP (" + this.B + ") [ attempt " + this.Ca + "]: " + this.ta + "\n" + this.w + "\n" + b + " " + f);
        this.J ? (4 == b && S(this), this.xb ? (rc(this, b, g), za && 3 == b && (Xb(this.jb, this.Sa, Ub, this.zc), this.Sa.start())) : (sc(this.a, this.B, g, null), tc(this, g)), this.J && !this.aa && (4 == b ? this.b.ma(this) : (this.J = !1, ic(this)))) : (400 == f && 0 < g.indexOf("Unknown SID") ? (this.p = 3, T(uc), this.a.$("XMLHTTP Unknown SID (" + this.B + ")")) : (this.p = 0, T(vc), this.a.$("XMLHTTP Bad status " + f + " (" + this.B + ")")), S(this), wc(this))
      }
    }else {
      this.a.$("Called back with an unexpected xmlhttp")
    }
  }catch(h) {
    this.a.debug("Failed call to OnXmlHttpReadyStateChanged_"), this.l && lc(this.l) ? xc(this.a, h, "ResponseText: " + lc(this.l)) : xc(this.a, h, "No response text")
  }finally {
  }
};
function rc(a, b, c) {
  for(var d = !0;!a.aa && a.Fa < c.length;) {
    var f = yc(a, c);
    if(f == dc) {
      4 == b && (a.p = 4, T(zc), d = !1);
      sc(a.a, a.B, null, "[Incomplete Response]");
      break
    }else {
      if(f == cc) {
        a.p = 4;
        T(Ac);
        sc(a.a, a.B, c, "[Invalid Chunk]");
        d = !1;
        break
      }else {
        sc(a.a, a.B, f, null), tc(a, f)
      }
    }
  }
  4 == b && 0 == c.length && (a.p = 1, T(Bc), d = !1);
  a.J = a.J && d;
  d || (sc(a.a, a.B, c, "[Invalid Chunked Response]"), S(a), wc(a))
}
p.zc = function() {
  var a = R(this.l), b = lc(this.l);
  this.Fa < b.length && (qc(this), rc(this, a, b), this.J && 4 != a && ic(this))
};
function yc(a, b) {
  var c = a.Fa, d = b.indexOf("\n", c);
  if(-1 == d) {
    return dc
  }
  c = Number(b.substring(c, d));
  if(isNaN(c)) {
    return cc
  }
  d += 1;
  if(d + c > b.length) {
    return dc
  }
  var f = b.substr(d, c);
  a.Fa = d + c;
  return f
}
function Cc(a, b) {
  a.pa = x();
  ic(a);
  var c = b ? window.location.hostname : "";
  a.w = a.T.n();
  I(a.w, "DOMAIN", c);
  I(a.w, "t", a.Ca);
  try {
    a.K = new ActiveXObject("htmlfile")
  }catch(d) {
    a.a.I("ActiveX blocked");
    S(a);
    a.p = 7;
    T(Dc);
    wc(a);
    return
  }
  var f = "<html><body>";
  b && (f += '<script>document.domain="' + c + '"\x3c/script>');
  f += "</body></html>";
  a.K.open();
  a.K.write(f);
  a.K.close();
  a.K.parentWindow.m = w(a.wc, a);
  a.K.parentWindow.d = w(a.Sb, a, !0);
  a.K.parentWindow.rpcClose = w(a.Sb, a, !1);
  c = a.K.createElement("div");
  a.K.parentWindow.document.body.appendChild(c);
  c.innerHTML = '<iframe src="' + a.w + '"></iframe>';
  a.a.info("TRIDENT REQ (" + a.B + ") [ attempt " + a.Ca + "]: GET\n" + a.w);
  a.b.G(jc)
}
p.wc = function(a) {
  U(w(this.vc, this, a), 0)
};
p.vc = function(a) {
  if(!this.aa) {
    var b = this.a;
    b.info("TRIDENT TEXT (" + this.B + "): " + Ec(b, a));
    qc(this);
    tc(this, a);
    ic(this)
  }
};
p.Sb = function(a) {
  U(w(this.uc, this, a), 0)
};
p.uc = function(a) {
  this.aa || (this.a.info("TRIDENT TEXT (" + this.B + "): " + a ? "success" : "failure"), S(this), this.J = a, this.b.ma(this), this.b.G(Fc))
};
p.lc = function() {
  qc(this);
  this.b.ma(this)
};
p.cancel = function() {
  this.aa = !0;
  S(this)
};
function ic(a) {
  a.sb = x() + a.Da;
  Gc(a, a.Da)
}
function Gc(a, b) {
  if(null != a.ua) {
    throw Error("WatchDog timer not null");
  }
  a.ua = U(w(a.xc, a), b)
}
function qc(a) {
  a.ua && (q.clearTimeout(a.ua), a.ua = null)
}
p.xc = function() {
  this.ua = null;
  var a = x();
  0 <= a - this.sb ? (this.J && this.a.I("Received watchdog timeout even though request loaded successfully"), this.a.info("TIMEOUT: " + this.w), 2 != this.sa && this.b.G(oc), S(this), this.p = 2, T(Hc), wc(this)) : (this.a.$("WatchDog timer called too early"), Gc(this, this.sb - a))
};
function wc(a) {
  a.b.Hb() || a.aa || a.b.ma(a)
}
function S(a) {
  qc(a);
  var b = a.Ta;
  b && "function" == typeof b.Ia && b.Ia();
  a.Ta = null;
  a.Sa.stop();
  b = a.jb;
  Ya(b.j, Nb);
  b.j.length = 0;
  a.l && (b = a.l, a.l = null, b.abort(), b.Ia());
  a.K && (a.K = null)
}
p.Eb = aa("p");
function tc(a, b) {
  try {
    a.b.Pb(a, b), a.b.G(Fc)
  }catch(c) {
    xc(a.a, c, "Error in httprequest callback")
  }
}
;function Ic(a) {
  a = String(a);
  if(/^\s*$/.test(a) ? 0 : /^[\],:{}\s\u2028\u2029]*$/.test(a.replace(/\\["\\\/bfnrtu]/g, "@").replace(/"[^"\\\n\r\u2028\u2029\x00-\x08\x0a-\x1f]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:[\s\u2028\u2029]*\[)+/g, ""))) {
    try {
      return eval("(" + a + ")")
    }catch(b) {
    }
  }
  throw Error("Invalid JSON string: " + a);
}
function Jc(a) {
  return eval("(" + a + ")")
}
function Kc(a) {
  var b = [];
  Lc(new Mc(void 0), a, b);
  return b.join("")
}
function Mc(a) {
  this.Va = a
}
function Lc(a, b, c) {
  switch(typeof b) {
    case "string":
      Nc(b, c);
      break;
    case "number":
      c.push(isFinite(b) && !isNaN(b) ? b : "null");
      break;
    case "boolean":
      c.push(b);
      break;
    case "undefined":
      c.push("null");
      break;
    case "object":
      if(null == b) {
        c.push("null");
        break
      }
      if(s(b)) {
        var d = b.length;
        c.push("[");
        for(var f = "", g = 0;g < d;g++) {
          c.push(f), f = b[g], Lc(a, a.Va ? a.Va.call(b, String(g), f) : f, c), f = ","
        }
        c.push("]");
        break
      }
      c.push("{");
      d = "";
      for(g in b) {
        Object.prototype.hasOwnProperty.call(b, g) && (f = b[g], "function" != typeof f && (c.push(d), Nc(g, c), c.push(":"), Lc(a, a.Va ? a.Va.call(b, g, f) : f, c), d = ","))
      }
      c.push("}");
      break;
    case "function":
      break;
    default:
      throw Error("Unknown type: " + typeof b);
  }
}
var Oc = {'"':'\\"', "\\":"\\\\", "/":"\\/", "\b":"\\b", "\f":"\\f", "\n":"\\n", "\r":"\\r", "\t":"\\t", "\x0B":"\\u000b"}, Pc = /\uffff/.test("\uffff") ? /[\\\"\x00-\x1f\x7f-\uffff]/g : /[\\\"\x00-\x1f\x7f-\xff]/g;
function Nc(a, b) {
  b.push('"', a.replace(Pc, function(a) {
    if(a in Oc) {
      return Oc[a]
    }
    var b = a.charCodeAt(0), f = "\\u";
    16 > b ? f += "000" : 256 > b ? f += "00" : 4096 > b && (f += "0");
    return Oc[a] = f + b.toString(16)
  }), '"')
}
;function Qc(a) {
  return Rc(a || arguments.callee.caller, [])
}
function Rc(a, b) {
  var c = [];
  if(0 <= Xa(b, a)) {
    c.push("[...circular reference...]")
  }else {
    if(a && 50 > b.length) {
      c.push(Sc(a) + "(");
      for(var d = a.arguments, f = 0;f < d.length;f++) {
        0 < f && c.push(", ");
        var g;
        g = d[f];
        switch(typeof g) {
          case "object":
            g = g ? "object" : "null";
            break;
          case "string":
            break;
          case "number":
            g = String(g);
            break;
          case "boolean":
            g = g ? "true" : "false";
            break;
          case "function":
            g = (g = Sc(g)) ? g : "[fn]";
            break;
          default:
            g = typeof g
        }
        40 < g.length && (g = g.substr(0, 40) + "...");
        c.push(g)
      }
      b.push(a);
      c.push(")\n");
      try {
        c.push(Rc(a.caller, b))
      }catch(h) {
        c.push("[exception trying to get caller]\n")
      }
    }else {
      a ? c.push("[...long stack...]") : c.push("[end]")
    }
  }
  return c.join("")
}
function Sc(a) {
  if(Tc[a]) {
    return Tc[a]
  }
  a = String(a);
  if(!Tc[a]) {
    var b = /function ([^\(]+)/.exec(a);
    Tc[a] = b ? b[1] : "[Anonymous]"
  }
  return Tc[a]
}
var Tc = {};
function Uc(a, b, c, d, f) {
  this.reset(a, b, c, d, f)
}
Uc.prototype.Cc = 0;
Uc.prototype.Bb = null;
Uc.prototype.Ab = null;
var Vc = 0;
Uc.prototype.reset = function(a, b, c, d, f) {
  this.Cc = "number" == typeof f ? f : Vc++;
  this.Qc = d || x();
  this.za = a;
  this.oc = b;
  this.Ic = c;
  delete this.Bb;
  delete this.Ab
};
Uc.prototype.Yb = m("za");
function V(a) {
  this.pc = a
}
V.prototype.Ra = null;
V.prototype.za = null;
V.prototype.fb = null;
V.prototype.Fb = null;
function Wc(a, b) {
  this.name = a;
  this.value = b
}
Wc.prototype.toString = aa("name");
var Xc = new Wc("SEVERE", 1E3), Yc = new Wc("WARNING", 900), Zc = new Wc("INFO", 800), $c = new Wc("CONFIG", 700), ad = new Wc("FINE", 500);
p = V.prototype;
p.getParent = aa("Ra");
p.Yb = m("za");
function bd(a) {
  if(a.za) {
    return a.za
  }
  if(a.Ra) {
    return bd(a.Ra)
  }
  Pa("Root logger has no level set.");
  return null
}
p.log = function(a, b, c) {
  if(a.value >= bd(this).value) {
    for(a = this.kc(a, b, c), b = "log:" + a.oc, q.console && (q.console.timeStamp ? q.console.timeStamp(b) : q.console.markTimeline && q.console.markTimeline(b)), q.msWriteProfilerMark && q.msWriteProfilerMark(b), b = this;b;) {
      c = b;
      var d = a;
      if(c.Fb) {
        for(var f = 0, g = void 0;g = c.Fb[f];f++) {
          g(d)
        }
      }
      b = b.getParent()
    }
  }
};
p.kc = function(a, b, c) {
  var d = new Uc(a, String(b), this.pc);
  if(c) {
    d.Bb = c;
    var f;
    var g = arguments.callee.caller;
    try {
      var h;
      var n = da("window.location.href");
      if(u(c)) {
        h = {message:c, name:"Unknown error", lineNumber:"Not available", fileName:n, stack:"Not available"}
      }else {
        var k, t, l = !1;
        try {
          k = c.lineNumber || c.Hc || "Not available"
        }catch(r) {
          k = "Not available", l = !0
        }
        try {
          t = c.fileName || c.filename || c.sourceURL || q.$googDebugFname || n
        }catch(G) {
          t = "Not available", l = !0
        }
        h = !l && c.lineNumber && c.fileName && c.stack ? c : {message:c.message, name:c.name, lineNumber:k, fileName:t, stack:c.stack || "Not available"}
      }
      f = "Message: " + na(h.message) + '\nUrl: <a href="view-source:' + h.fileName + '" target="_new">' + h.fileName + "</a>\nLine: " + h.lineNumber + "\n\nBrowser stack:\n" + na(h.stack + "-> ") + "[end]\n\nJS stack traversal:\n" + na(Qc(g) + "-> ")
    }catch(Sd) {
      f = "Exception trying to expose exception! You win, we lose. " + Sd
    }
    d.Ab = f
  }
  return d
};
p.I = function(a, b) {
  this.log(Xc, a, b)
};
p.$ = function(a, b) {
  this.log(Yc, a, b)
};
p.info = function(a, b) {
  this.log(Zc, a, b)
};
function W(a, b) {
  a.log(ad, b, void 0)
}
var cd = {}, dd = null;
function ed(a) {
  dd || (dd = new V(""), cd[""] = dd, dd.Yb($c));
  var b;
  if(!(b = cd[a])) {
    b = new V(a);
    var c = a.lastIndexOf("."), d = a.substr(c + 1), c = ed(a.substr(0, c));
    c.fb || (c.fb = {});
    c.fb[d] = b;
    b.Ra = c;
    cd[a] = b
  }
  return b
}
;function X() {
  this.q = ed("goog.net.BrowserChannel")
}
function sc(a, b, c, d) {
  a.info("XMLHTTP TEXT (" + b + "): " + Ec(a, c) + (d ? " " + d : ""))
}
X.prototype.debug = function(a) {
  this.info(a)
};
function xc(a, b, c) {
  a.I((c || "Exception") + b)
}
X.prototype.info = function(a) {
  this.q.info(a)
};
X.prototype.$ = function(a) {
  this.q.$(a)
};
X.prototype.I = function(a) {
  this.q.I(a)
};
function Ec(a, b) {
  if(!b || b == fd) {
    return b
  }
  try {
    var c = Jc(b);
    if(c) {
      for(var d = 0;d < c.length;d++) {
        if(s(c[d])) {
          var f = c[d];
          if(!(2 > f.length)) {
            var g = f[1];
            if(s(g) && !(1 > g.length)) {
              var h = g[0];
              if("noop" != h && "stop" != h) {
                for(var n = 1;n < g.length;n++) {
                  g[n] = ""
                }
              }
            }
          }
        }
      }
    }
    return Kc(c)
  }catch(k) {
    return a.debug("Exception parsing expected JS array - probably was not JS"), b
  }
}
;function gd(a, b) {
  this.Oc = new Mc(a);
  this.P = b ? Jc : Ic
}
gd.prototype.parse = function(a) {
  return this.P(a)
};
var mc = 7, nc = 8;
function hd(a) {
  M.call(this);
  this.headers = new bb;
  this.va = a || null
}
y(hd, Sb);
hd.prototype.q = ed("goog.net.XhrIo");
var id = /^https?$/i;
p = hd.prototype;
p.S = !1;
p.g = null;
p.bb = null;
p.Pa = "";
p.Jb = "";
p.la = 0;
p.p = "";
p.ib = !1;
p.Na = !1;
p.mb = !1;
p.ca = !1;
p.$a = 0;
p.fa = null;
p.Wb = "";
p.cc = !1;
p.send = function(a, b, c, d) {
  if(this.g) {
    throw Error("[goog.net.XhrIo] Object is active with another request=" + this.Pa + "; newUri=" + a);
  }
  b = b ? b.toUpperCase() : "GET";
  this.Pa = a;
  this.p = "";
  this.la = 0;
  this.Jb = b;
  this.ib = !1;
  this.S = !0;
  this.g = this.va ? xb(this.va) : xb(vb);
  this.bb = this.va ? this.va.Ga || (this.va.Ga = zb(this.va)) : vb.Ga || (vb.Ga = zb(vb));
  this.g.onreadystatechange = w(this.Ob, this);
  try {
    W(this.q, Y(this, "Opening Xhr")), this.mb = !0, this.g.open(b, a, !0), this.mb = !1
  }catch(f) {
    W(this.q, Y(this, "Error opening Xhr: " + f.message));
    jd(this, f);
    return
  }
  a = c || "";
  var g = this.headers.n();
  d && E(d, function(a, b) {
    g.set(b, a)
  });
  d = q.FormData && a instanceof q.FormData;
  "POST" != b || (g.ia("Content-Type") || d) || g.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
  E(g, function(a, b) {
    this.g.setRequestHeader(b, a)
  }, this);
  this.Wb && (this.g.responseType = this.Wb);
  "withCredentials" in this.g && (this.g.withCredentials = this.cc);
  try {
    this.fa && (q.clearTimeout(this.fa), this.fa = null), 0 < this.$a && (W(this.q, Y(this, "Will abort after " + this.$a + "ms if incomplete")), this.fa = q.setTimeout(w(this.Da, this), this.$a)), W(this.q, Y(this, "Sending request")), this.Na = !0, this.g.send(a), this.Na = !1
  }catch(h) {
    W(this.q, Y(this, "Send error: " + h.message)), jd(this, h)
  }
};
p.Da = function() {
  "undefined" != typeof ca && this.g && (this.p = "Timed out after " + this.$a + "ms, aborting", this.la = nc, W(this.q, Y(this, this.p)), this.dispatchEvent("timeout"), this.abort(nc))
};
function jd(a, b) {
  a.S = !1;
  a.g && (a.ca = !0, a.g.abort(), a.ca = !1);
  a.p = b;
  a.la = 5;
  kd(a);
  ld(a)
}
function kd(a) {
  a.ib || (a.ib = !0, a.dispatchEvent("complete"), a.dispatchEvent("error"))
}
p.abort = function(a) {
  this.g && this.S && (W(this.q, Y(this, "Aborting")), this.S = !1, this.ca = !0, this.g.abort(), this.ca = !1, this.la = a || mc, this.dispatchEvent("complete"), this.dispatchEvent("abort"), ld(this))
};
p.u = function() {
  this.g && (this.S && (this.S = !1, this.ca = !0, this.g.abort(), this.ca = !1), ld(this, !0));
  hd.ra.u.call(this)
};
p.Ob = function() {
  this.mb || this.Na || this.ca ? md(this) : this.sc()
};
p.sc = function() {
  md(this)
};
function md(a) {
  if(a.S && "undefined" != typeof ca) {
    if(a.bb[1] && 4 == R(a) && 2 == kc(a)) {
      W(a.q, Y(a, "Local request error detected and ignored"))
    }else {
      if(a.Na && 4 == R(a)) {
        q.setTimeout(w(a.Ob, a), 0)
      }else {
        if(a.dispatchEvent("readystatechange"), 4 == R(a)) {
          W(a.q, Y(a, "Request complete"));
          a.S = !1;
          try {
            var b = kc(a), c, d;
            a: {
              switch(b) {
                case 200:
                ;
                case 201:
                ;
                case 202:
                ;
                case 204:
                ;
                case 206:
                ;
                case 304:
                ;
                case 1223:
                  d = !0;
                  break a;
                default:
                  d = !1
              }
            }
            if(!(c = d)) {
              var f;
              if(f = 0 === b) {
                var g = String(a.Pa).match(Qa)[1] || null;
                if(!g && self.location) {
                  var h = self.location.protocol, g = h.substr(0, h.length - 1)
                }
                f = !id.test(g ? g.toLowerCase() : "")
              }
              c = f
            }
            if(c) {
              a.dispatchEvent("complete"), a.dispatchEvent("success")
            }else {
              a.la = 6;
              var n;
              try {
                n = 2 < R(a) ? a.g.statusText : ""
              }catch(k) {
                W(a.q, "Can not get status: " + k.message), n = ""
              }
              a.p = n + " [" + kc(a) + "]";
              kd(a)
            }
          }finally {
            ld(a)
          }
        }
      }
    }
  }
}
function ld(a, b) {
  if(a.g) {
    var c = a.g, d = a.bb[0] ? ea : null;
    a.g = null;
    a.bb = null;
    a.fa && (q.clearTimeout(a.fa), a.fa = null);
    b || a.dispatchEvent("ready");
    try {
      c.onreadystatechange = d
    }catch(f) {
      a.q.I("Problem encountered resetting onreadystatechange: " + f.message)
    }
  }
}
p.isActive = function() {
  return!!this.g
};
function R(a) {
  return a.g ? a.g.readyState : 0
}
function kc(a) {
  try {
    return 2 < R(a) ? a.g.status : -1
  }catch(b) {
    return a.q.$("Can not get status: " + b.message), -1
  }
}
function lc(a) {
  try {
    return a.g ? a.g.responseText : ""
  }catch(b) {
    return W(a.q, "Can not get responseText: " + b.message), ""
  }
}
p.Eb = function() {
  return u(this.p) ? this.p : String(this.p)
};
function Y(a, b) {
  return b + " [" + a.Jb + " " + a.Pa + " " + kc(a) + "]"
}
;function nd() {
  this.Vb = x()
}
new nd;
nd.prototype.set = m("Vb");
nd.prototype.reset = function() {
  this.set(x())
};
nd.prototype.get = aa("Vb");
function od(a, b, c, d, f) {
  (new X).debug("TestLoadImageWithRetries: " + f);
  if(0 == d) {
    c(!1)
  }else {
    var g = f || 0;
    d--;
    pd(a, b, function(f) {
      f ? c(!0) : q.setTimeout(function() {
        od(a, b, c, d, g)
      }, g)
    })
  }
}
function pd(a, b, c) {
  function d(a, b) {
    return function() {
      try {
        f.debug("TestLoadImage: " + b), g.onload = null, g.onerror = null, g.onabort = null, g.ontimeout = null, q.clearTimeout(h), c(a)
      }catch(d) {
        xc(f, d)
      }
    }
  }
  var f = new X;
  f.debug("TestLoadImage: loading " + a);
  var g = new Image, h = null;
  g.onload = d(!0, "loaded");
  g.onerror = d(!1, "error");
  g.onabort = d(!1, "abort");
  g.ontimeout = d(!1, "timeout");
  h = q.setTimeout(function() {
    if(g.ontimeout) {
      g.ontimeout()
    }
  }, b);
  g.src = a
}
;function qd(a, b) {
  this.b = a;
  this.a = b;
  this.P = new gd(null, !0)
}
p = qd.prototype;
p.v = null;
p.A = null;
p.Ua = !1;
p.ac = null;
p.Ka = null;
p.nb = null;
p.H = null;
p.c = null;
p.h = -1;
p.L = null;
p.wa = null;
p.Y = m("v");
p.Zb = m("P");
p.gb = function(a) {
  this.H = a;
  a = rd(this.b, this.H);
  T(sd);
  this.ac = x();
  var b = this.b.Cb;
  null != b ? (this.L = this.b.correctHostPrefix(b[0]), (this.wa = b[1]) ? (this.c = 1, td(this)) : (this.c = 2, ud(this))) : (qb(a, "MODE", "init"), this.A = new Q(this, this.a, void 0, void 0, void 0), this.A.Y(this.v), hc(this.A, a, !1, null, !0), this.c = 0)
};
function td(a) {
  var b = vd(a.b, a.wa, "/mail/images/cleardot.gif");
  J(b);
  od(b.toString(), 5E3, w(a.ic, a), 3, 2E3);
  a.G(jc)
}
p.ic = function(a) {
  if(a) {
    this.c = 2, ud(this)
  }else {
    T(wd);
    var b = this.b;
    b.a.debug("Test Connection Blocked");
    b.h = b.U.h;
    Z(b, 9)
  }
  a && this.G(pc)
};
function ud(a) {
  a.a.debug("TestConnection: starting stage 2");
  a.A = new Q(a, a.a, void 0, void 0, void 0);
  a.A.Y(a.v);
  var b = xd(a.b, a.L, a.H);
  T(yd);
  if(ec()) {
    qb(b, "TYPE", "xmlhttp"), hc(a.A, b, !1, a.L, !1)
  }else {
    qb(b, "TYPE", "html");
    var c = a.A;
    a = Boolean(a.L);
    c.sa = 3;
    c.T = J(b.n());
    Cc(c, a)
  }
}
p.hb = function(a) {
  return this.b.hb(a)
};
p.abort = function() {
  this.A && (this.A.cancel(), this.A = null);
  this.h = -1
};
p.Hb = ba(!1);
p.Pb = function(a, b) {
  this.h = a.h;
  if(0 == this.c) {
    if(this.a.debug("TestConnection: Got data for stage 1"), b) {
      try {
        var c = this.P.parse(b)
      }catch(d) {
        xc(this.a, d);
        zd(this.b, this);
        return
      }
      this.L = this.b.correctHostPrefix(c[0]);
      this.wa = c[1]
    }else {
      this.a.debug("TestConnection: Null responseText"), zd(this.b, this)
    }
  }else {
    if(2 == this.c) {
      if(this.Ua) {
        T(Ad), this.nb = x()
      }else {
        if("11111" == b) {
          if(T(Bd), this.Ua = !0, this.Ka = x(), c = this.Ka - this.ac, ec() || 500 > c) {
            this.h = 200, this.A.cancel(), this.a.debug("Test connection succeeded; using streaming connection"), T(Cd), Dd(this.b, this, !0)
          }
        }else {
          T(Ed), this.Ka = this.nb = x(), this.Ua = !1
        }
      }
    }
  }
};
p.ma = function() {
  this.h = this.A.h;
  if(!this.A.J) {
    this.a.debug("TestConnection: request failed, in state " + this.c), 0 == this.c ? T(Fd) : 2 == this.c && T(Gd), zd(this.b, this)
  }else {
    if(0 == this.c) {
      this.a.debug("TestConnection: request complete for initial check"), this.wa ? (this.c = 1, td(this)) : (this.c = 2, ud(this))
    }else {
      if(2 == this.c) {
        this.a.debug("TestConnection: request complete for stage 2");
        var a = !1;
        (a = ec() ? this.Ua : 200 > this.nb - this.Ka ? !1 : !0) ? (this.a.debug("Test connection succeeded; using streaming connection"), T(Cd), Dd(this.b, this, !0)) : (this.a.debug("Test connection failed; not using streaming"), T(Hd), Dd(this.b, this, !1))
      }
    }
  }
};
p.Ya = function() {
  return this.b.Ya()
};
p.isActive = function() {
  return this.b.isActive()
};
p.G = function(a) {
  this.b.G(a)
};
function Id(a, b) {
  this.vb = a || null;
  this.c = Jd;
  this.s = [];
  this.Q = [];
  this.a = new X;
  this.P = new gd(null, !0);
  this.Cb = b || null
}
function Kd(a, b) {
  this.Lb = a;
  this.map = b;
  this.Fc = null
}
p = Id.prototype;
p.v = null;
p.xa = null;
p.o = null;
p.k = null;
p.H = null;
p.La = null;
p.ub = null;
p.L = null;
p.fc = !0;
p.Aa = 0;
p.qc = 0;
p.Ja = !1;
p.e = null;
p.F = null;
p.M = null;
p.ba = null;
p.U = null;
p.rb = null;
p.ec = !0;
p.ya = -1;
p.Kb = -1;
p.h = -1;
p.V = 0;
p.ga = 0;
p.gc = 5E3;
p.Bc = 1E4;
p.kb = 2;
p.Db = 2E4;
p.oa = 0;
p.Za = !1;
p.ha = 8;
var Jd = 1, Ld = new Sb;
function Md(a, b) {
  N.call(this, "statevent", a);
  this.Pc = b
}
y(Md, N);
function Nd(a, b, c, d) {
  N.call(this, "timingevent", a);
  this.size = b;
  this.Nc = c;
  this.Mc = d
}
y(Nd, N);
var jc = 1, pc = 2, oc = 3, Fc = 4;
function Od(a, b) {
  N.call(this, "serverreachability", a);
  this.Lc = b
}
y(Od, N);
var sd = 3, wd = 4, yd = 5, Bd = 6, Ad = 7, Ed = 8, Fd = 9, Gd = 10, Hd = 11, Cd = 12, uc = 13, vc = 14, zc = 15, Ac = 16, Bc = 17, Hc = 18, Dc = 22, fd = "y2f%";
p = Id.prototype;
p.gb = function(a, b, c, d, f) {
  this.a.debug("connect()");
  T(0);
  this.H = b;
  this.xa = c || {};
  d && void 0 !== f && (this.xa.OSID = d, this.xa.OAID = f);
  this.a.debug("connectTest_()");
  Pd(this) && (this.U = new qd(this, this.a), this.U.Y(this.v), this.U.Zb(this.P), this.U.gb(a))
};
p.disconnect = function() {
  this.a.debug("disconnect()");
  Qd(this);
  if(3 == this.c) {
    var a = this.Aa++, b = this.La.n();
    I(b, "SID", this.Z);
    I(b, "RID", a);
    I(b, "TYPE", "terminate");
    Rd(this, b);
    a = new Q(this, this.a, this.Z, a, void 0);
    a.sa = 2;
    a.T = J(b.n());
    b = new Image;
    b.src = a.T;
    b.onload = b.onerror = w(a.lc, a);
    a.pa = x();
    ic(a)
  }
  Td(this)
};
function Qd(a) {
  a.U && (a.U.abort(), a.U = null);
  a.k && (a.k.cancel(), a.k = null);
  a.M && (q.clearTimeout(a.M), a.M = null);
  Ud(a);
  a.o && (a.o.cancel(), a.o = null);
  a.F && (q.clearTimeout(a.F), a.F = null)
}
p.Y = m("v");
p.$b = m("oa");
p.Hb = function() {
  return 0 == this.c
};
p.Zb = m("P");
function Vd(a) {
  a.o || a.F || (a.F = U(w(a.Rb, a), 0), a.V = 0)
}
p.Rb = function(a) {
  this.F = null;
  this.a.debug("startForwardChannel_");
  if(Pd(this)) {
    if(this.c == Jd) {
      if(a) {
        this.a.I("Not supposed to retry the open")
      }else {
        this.a.debug("open_()");
        this.Aa = Math.floor(1E5 * Math.random());
        a = this.Aa++;
        var b = new Q(this, this.a, "", a, void 0);
        b.Y(this.v);
        var c = Wd(this), d = this.La.n();
        I(d, "RID", a);
        this.vb && I(d, "CVER", this.vb);
        Rd(this, d);
        fc(b, d, c);
        this.o = b;
        this.c = 2
      }
    }else {
      3 == this.c && (a ? Xd(this, a) : 0 == this.s.length ? this.a.debug("startForwardChannel_ returned: nothing to send") : this.o ? this.a.I("startForwardChannel_ returned: connection already in progress") : (Xd(this), this.a.debug("startForwardChannel_ finished, sent request")))
    }
  }
};
function Xd(a, b) {
  var c, d;
  b ? 6 < a.ha ? (a.s = a.Q.concat(a.s), a.Q.length = 0, c = a.Aa - 1, d = Wd(a)) : (c = b.B, d = b.X) : (c = a.Aa++, d = Wd(a));
  var f = a.La.n();
  I(f, "SID", a.Z);
  I(f, "RID", c);
  I(f, "AID", a.ya);
  Rd(a, f);
  c = new Q(a, a.a, a.Z, c, a.V + 1);
  c.Y(a.v);
  c.setTimeout(Math.round(0.5 * a.Db) + Math.round(0.5 * a.Db * Math.random()));
  a.o = c;
  fc(c, f, d)
}
function Rd(a, b) {
  if(a.e) {
    var c = a.e.getAdditionalParams(a);
    c && E(c, function(a, c) {
      I(b, c, a)
    })
  }
}
function Wd(a) {
  var b = Math.min(a.s.length, 1E3), c = ["count=" + b], d;
  6 < a.ha && 0 < b ? (d = a.s[0].Lb, c.push("ofs=" + d)) : d = 0;
  for(var f = 0;f < b;f++) {
    var g = a.s[f].Lb, h = a.s[f].map, g = 6 >= a.ha ? f : g - d;
    try {
      E(h, function(a, b) {
        c.push("req" + g + "_" + b + "=" + encodeURIComponent(a))
      })
    }catch(n) {
      c.push("req" + g + "_type=" + encodeURIComponent("_badmap")), a.e && a.e.badMapError(a, h)
    }
  }
  a.Q = a.Q.concat(a.s.splice(0, b));
  return c.join("&")
}
function Yd(a) {
  a.k || a.M || (a.tb = 1, a.M = U(w(a.Qb, a), 0), a.ga = 0)
}
function Zd(a) {
  if(a.k || a.M) {
    return a.a.I("Request already in progress"), !1
  }
  if(3 <= a.ga) {
    return!1
  }
  a.a.debug("Going to retry GET");
  a.tb++;
  a.M = U(w(a.Qb, a), $d(a, a.ga));
  a.ga++;
  return!0
}
p.Qb = function() {
  this.M = null;
  if(Pd(this)) {
    this.a.debug("Creating new HttpRequest");
    this.k = new Q(this, this.a, this.Z, "rpc", this.tb);
    this.k.Y(this.v);
    this.k.$b(this.oa);
    var a = this.ub.n();
    I(a, "RID", "rpc");
    I(a, "SID", this.Z);
    I(a, "CI", this.rb ? "0" : "1");
    I(a, "AID", this.ya);
    Rd(this, a);
    if(ec()) {
      I(a, "TYPE", "xmlhttp"), hc(this.k, a, !0, this.L, !1)
    }else {
      I(a, "TYPE", "html");
      var b = this.k, c = Boolean(this.L);
      b.sa = 3;
      b.T = J(a.n());
      Cc(b, c)
    }
    this.a.debug("New Request created")
  }
};
function Pd(a) {
  if(a.e) {
    var b = a.e.okToMakeRequest(a);
    if(0 != b) {
      return a.a.debug("Handler returned error code from okToMakeRequest"), Z(a, b), !1
    }
  }
  return!0
}
function Dd(a, b, c) {
  a.a.debug("Test Connection Finished");
  a.rb = a.ec && c;
  a.h = b.h;
  a.a.debug("connectChannel_()");
  a.jc(Jd, 0);
  a.La = rd(a, a.H);
  Vd(a)
}
function zd(a, b) {
  a.a.debug("Test Connection Failed");
  a.h = b.h;
  Z(a, 2)
}
p.Pb = function(a, b) {
  if(0 != this.c && (this.k == a || this.o == a)) {
    if(this.h = a.h, this.o == a && 3 == this.c) {
      if(7 < this.ha) {
        var c;
        try {
          c = this.P.parse(b)
        }catch(d) {
          c = null
        }
        if(s(c) && 3 == c.length) {
          var f = c;
          if(0 == f[0]) {
            a: {
              if(this.a.debug("Server claims our backchannel is missing."), this.M) {
                this.a.debug("But we are currently starting the request.")
              }else {
                if(this.k) {
                  if(this.k.pa + 3E3 < this.o.pa) {
                    Ud(this), this.k.cancel(), this.k = null
                  }else {
                    break a
                  }
                }else {
                  this.a.$("We do not have a BackChannel established")
                }
                Zd(this);
                T(19)
              }
            }
          }else {
            this.Kb = f[1], c = this.Kb - this.ya, 0 < c && (f = f[2], this.a.debug(f + " bytes (in " + c + " arrays) are outstanding on the BackChannel"), 37500 > f && (this.rb && 0 == this.ga) && !this.ba && (this.ba = U(w(this.rc, this), 6E3)))
          }
        }else {
          this.a.debug("Bad POST response data returned"), Z(this, 11)
        }
      }else {
        b != fd && (this.a.debug("Bad data returned - missing/invald magic cookie"), Z(this, 11))
      }
    }else {
      if(this.k == a && Ud(this), !/^[\s\xa0]*$/.test(b)) {
        c = this.P.parse(b);
        for(var f = this.e && this.e.channelHandleMultipleArrays ? [] : null, g = 0;g < c.length;g++) {
          var h = c[g];
          this.ya = h[0];
          h = h[1];
          2 == this.c ? "c" == h[0] ? (this.Z = h[1], this.L = this.correctHostPrefix(h[2]), h = h[3], this.ha = null != h ? h : 6, this.c = 3, this.e && this.e.channelOpened(this), this.ub = xd(this, this.L, this.H), Yd(this)) : "stop" == h[0] && Z(this, 7) : 3 == this.c && ("stop" == h[0] ? (f && f.length && (this.e.channelHandleMultipleArrays(this, f), f.length = 0), Z(this, 7)) : "noop" != h[0] && (f ? f.push(h) : this.e && this.e.channelHandleArray(this, h)), this.ga = 0)
        }
        f && f.length && this.e.channelHandleMultipleArrays(this, f)
      }
    }
  }
};
p.correctHostPrefix = function(a) {
  return this.fc ? this.e ? this.e.correctHostPrefix(a) : a : null
};
p.rc = function() {
  null != this.ba && (this.ba = null, this.k.cancel(), this.k = null, Zd(this), T(20))
};
function Ud(a) {
  null != a.ba && (q.clearTimeout(a.ba), a.ba = null)
}
p.ma = function(a) {
  this.a.debug("Request complete");
  var b;
  if(this.k == a) {
    Ud(this), this.k = null, b = 2
  }else {
    if(this.o == a) {
      this.o = null, b = 1
    }else {
      return
    }
  }
  this.h = a.h;
  if(0 != this.c) {
    if(a.J) {
      1 == b ? (b = x() - a.pa, Ld.dispatchEvent(new Nd(Ld, a.X ? a.X.length : 0, b, this.V)), Vd(this), this.Q.length = 0) : Yd(this)
    }else {
      var c = a.Eb();
      if(3 == c || 7 == c || 0 == c && 0 < this.h) {
        this.a.debug("Not retrying due to error type")
      }else {
        this.a.debug("Maybe retrying, last error: " + bc(c, this.h));
        var d;
        if(d = 1 == b) {
          this.o || this.F ? (this.a.I("Request already in progress"), d = !1) : this.c == Jd || this.V >= (this.Ja ? 0 : this.kb) ? d = !1 : (this.a.debug("Going to retry POST"), this.F = U(w(this.Rb, this, a), $d(this, this.V)), this.V++, d = !0)
        }
        if(d || 2 == b && Zd(this)) {
          return
        }
        this.a.debug("Exceeded max number of retries")
      }
      this.a.debug("Error: HTTP request failed");
      switch(c) {
        case 1:
          Z(this, 5);
          break;
        case 4:
          Z(this, 10);
          break;
        case 3:
          Z(this, 6);
          break;
        case 7:
          Z(this, 12);
          break;
        default:
          Z(this, 2)
      }
    }
  }
};
function $d(a, b) {
  var c = a.gc + Math.floor(Math.random() * a.Bc);
  a.isActive() || (a.a.debug("Inactive channel"), c *= 2);
  return c * b
}
p.jc = function(a) {
  if(!(0 <= Xa(arguments, this.c))) {
    throw Error("Unexpected channel state: " + this.c);
  }
};
function Z(a, b) {
  a.a.info("Error code " + b);
  if(2 == b || 9 == b) {
    var c = null;
    a.e && (c = a.e.getNetworkTestImageUri(a));
    var d = w(a.Dc, a);
    c || (c = new F("http://www.google.com/images/cleardot.gif"), J(c));
    pd(c.toString(), 1E4, d)
  }else {
    T(2)
  }
  ae(a, b)
}
p.Dc = function(a) {
  a ? (this.a.info("Successfully pinged google.com"), T(2)) : (this.a.info("Failed to ping google.com"), T(1), ae(this, 8))
};
function ae(a, b) {
  a.a.debug("HttpChannel: error - " + b);
  a.c = 0;
  a.e && a.e.channelError(a, b);
  Td(a);
  Qd(a)
}
function Td(a) {
  a.c = 0;
  a.h = -1;
  if(a.e) {
    if(0 == a.Q.length && 0 == a.s.length) {
      a.e.channelClosed(a)
    }else {
      a.a.debug("Number of undelivered maps, pending: " + a.Q.length + ", outgoing: " + a.s.length);
      var b = $a(a.Q), c = $a(a.s);
      a.Q.length = 0;
      a.s.length = 0;
      a.e.channelClosed(a, b, c)
    }
  }
}
function rd(a, b) {
  var c = vd(a, null, b);
  a.a.debug("GetForwardChannelUri: " + c);
  return c
}
function xd(a, b, c) {
  b = vd(a, a.Ya() ? b : null, c);
  a.a.debug("GetBackChannelUri: " + b);
  return b
}
function vd(a, b, c) {
  var d = c instanceof F ? c.n() : new F(c, void 0);
  if("" != d.ja) {
    b && fb(d, b + "." + d.ja), gb(d, d.Ba)
  }else {
    var f = window.location, d = sb(f.protocol, b ? b + "." + f.hostname : f.hostname, f.port, c)
  }
  a.xa && E(a.xa, function(a, b) {
    I(d, b, a)
  });
  I(d, "VER", a.ha);
  Rd(a, d);
  return d
}
p.hb = function(a) {
  if(a && !this.Za) {
    throw Error("Can't create secondary domain capable XhrIo object.");
  }
  a = new hd;
  a.cc = this.Za;
  return a
};
p.isActive = function() {
  return!!this.e && this.e.isActive(this)
};
function U(a, b) {
  if(!ha(a)) {
    throw Error("Fn must not be null and must be a function");
  }
  return q.setTimeout(function() {
    a()
  }, b)
}
p.G = function(a) {
  Ld.dispatchEvent(new Od(Ld, a))
};
function T(a) {
  Ld.dispatchEvent(new Md(Ld, a))
}
p.Ya = function() {
  return this.Za || !ec()
};
function be() {
}
p = be.prototype;
p.channelHandleMultipleArrays = null;
p.okToMakeRequest = ba(0);
p.channelOpened = e();
p.channelHandleArray = e();
p.channelError = e();
p.channelClosed = e();
p.getAdditionalParams = function() {
  return{}
};
p.getNetworkTestImageUri = ba(null);
p.isActive = ba(!0);
p.badMapError = e();
p.correctHostPrefix = function(a) {
  return a
};
var $, ce, de = [].slice;
ce = {0:"Ok", 4:"User is logging out", 6:"Unknown session ID", 7:"Stopped by server", 8:"General network error", 2:"Request failed", 9:"Blocked by a network administrator", 5:"No data from server", 10:"Got bad data from the server", 11:"Got a bad response from the server"};
$ = function(a, b) {
  var c, d, f, g, h, n, k, t, l, r;
  t = this;
  a || (a = "channel");
  a.match(/:\/\//) && a.replace(/^ws/, "http");
  b || (b = {});
  s(b || "string" === typeof b) && (b = {});
  n = b.reconnectTime || 3E3;
  r = function(a) {
    t.readyState = t.readyState = a
  };
  r(this.CLOSED);
  l = null;
  g = b.Kc;
  c = function() {
    var a, b;
    b = arguments[0];
    a = 2 <= arguments.length ? de.call(arguments, 1) : [];
    try {
      return"function" === typeof t[b] ? t[b].apply(t, a) : void 0
    }catch(c) {
      throw a = c, "undefined" !== typeof console && null !== console && console.error(a.stack), a;
    }
  };
  d = new be;
  d.channelOpened = function() {
    g = l;
    r($.OPEN);
    return c("onopen")
  };
  f = null;
  d.channelError = function(a, b) {
    var d;
    d = ce[b];
    f = b;
    r($.cb);
    try {
      return c("onerror", d, b)
    }catch(g) {
    }
  };
  k = null;
  d.channelClosed = function(a, d, g) {
    if(t.readyState !== $.CLOSED) {
      l = null;
      a = f ? ce[f] : "Closed";
      r($.CLOSED);
      try {
        c("onclose", a, d, g)
      }catch(ee) {
      }
      b.reconnect && (7 !== f && 0 !== f) && (d = 6 === f ? 0 : n, clearTimeout(k), k = setTimeout(h, d));
      return f = null
    }
  };
  d.channelHandleArray = function(a, b) {
    return c("onmessage", b)
  };
  h = function() {
    if(l) {
      throw Error("Reconnect() called from invalid state");
    }
    r($.CONNECTING);
    c("onconnecting");
    clearTimeout(k);
    l = new Id(b.appVersion, null != g ? g.Cb : void 0);
    b.crossDomainXhr && (l.Za = !0);
    l.e = d;
    f = null;
    if(b.failFast) {
      var h = l;
      h.Ja = !0;
      h.a.info("setFailFast: true");
      (h.o || h.F) && h.V > (h.Ja ? 0 : h.kb) && (h.a.info("Retry count " + h.V + " > new maxRetries " + (h.Ja ? 0 : h.kb) + ". Fail immediately!"), h.o ? (h.o.cancel(), h.ma(h.o)) : (q.clearTimeout(h.F), h.F = null, Z(h, 2)))
    }
    return l.gb("" + a + "/test", "" + a + "/bind", b.extraParams, null != g ? g.Z : void 0, null != g ? g.ya : void 0)
  };
  this.open = function() {
    if(t.readyState !== t.CLOSED) {
      throw Error("Already open");
    }
    return h()
  };
  this.close = function() {
    clearTimeout(k);
    f = 0;
    if(t.readyState !== $.CLOSED) {
      return r($.cb), l.disconnect()
    }
  };
  this.sendMap = function(a) {
    var b;
    if((b = t.readyState) === $.cb || b === $.CLOSED) {
      throw Error("Cannot send to a closed connection");
    }
    b = l;
    if(0 == b.c) {
      throw Error("Invalid operation: sending map when state is closed");
    }
    1E3 == b.s.length && b.a.I("Already have 1000 queued maps upon queueing " + Kc(a));
    b.s.push(new Kd(b.qc++, a));
    2 != b.c && 3 != b.c || Vd(b)
  };
  this.send = function(a) {
    return this.sendMap({JSON:Kc(a)})
  };
  h();
  return this
};
$.prototype.CONNECTING = $.CONNECTING = $.CONNECTING = 0;
$.prototype.OPEN = $.OPEN = $.OPEN = 1;
$.prototype.CLOSING = $.CLOSING = $.cb = 2;
$.prototype.CLOSED = $.CLOSED = $.CLOSED = 3;
("undefined" !== typeof exports && null !== exports ? exports : window).BCSocket = $;

})();

},{}],17:[function(require,module,exports){
exports.setup = function(library) {
  library.view.fn('sentenceCase', function(text) {
    return text && (text.charAt(0).toUpperCase() + text.slice(1));
  });
};

exports.reconnect = function() {
  var model = this.model;
  model.set('hideReconnect', true);
  setTimeout(function() {
    model.set('hideReconnect', false);
  }, 1000);
  model.reconnect();
};

exports.reload = function() {
  window.location.reload();
};
},{}],2:[function(require,module,exports){
(function(global){var racer = require('racer')
  , tracks = require('tracks')
  , sharedCreateApp = require('./app').create
  , derbyModel = require('./derby.Model')
  , Dom = require('./Dom')
  , viewModel = require('./viewModel')
  , refresh = require('./refresh')

module.exports = derbyBrowser;

function derbyBrowser(derby) {
  // This assumes that only a single instance of this module can run at a time,
  // which is reasonable in the browser. This is written like this so that
  // the DERBY global can be used to initialize templates and data.
  global.DERBY = derby;
  derby.createApp = createApp;
  derby.init = init;
}

function createApp(appModule) {
  if (derbyBrowser.created) {
    throw new Error('derby.createApp() called multiple times in the browser');
  } else {
    derbyBrowser.created = true;
  }

  var app = sharedCreateApp(this, appModule)
  global.DERBY.app = app;

  racer.once('model', function(model) {
    app.emit('model', model);
  });

  // Adds get, post, put, del, enter, and exit methods
  // as well as history to app
  tracks.setup(app, createPage, onRoute);

  onRenderError = function(err, url) {
    setTimeout(function() {
      window.location = url;
    }, 0);
    throw err;
  }

  function Page(app) {
    this.app = app;
    this.model = app.model;
    this.dom = app.dom;
    this.history = app.history;
    this._viewModels = [];
    this._routing = false;
  }
  Page.prototype.render = function(ns, ctx) {
    try {
      if (typeof ns === 'object') {
        ctx = ns;
        ns = '';
      }
      ctx || (ctx = {});
      ctx.$url = this.params.url;
      app.view.render(this.model, ns, ctx);
      this._routing = false;
      tracks.render(this, {
        url: this.params.url
      , previous: this.params.previous
      , method: 'enter'
      , noNavigate: true
      });
    } catch (err) {
      onRenderError(err, this.params.url);
    }
  };
  Page.prototype.init = viewModel.pageInit;

  function createPage() {
    return new Page(app);
  }
  function onRoute(callback, page, params, next, isTransitional, done) {
    if (!app._initialized) return;
    try {
      if (isTransitional) {
        if (callback.length === 4) {
          callback(page.model, params, next, done);
          return true;
        } else {
          callback(page.model, params, next);
          return;
        }
      }

      if (params.method === 'enter' || params.method === 'exit') {
        callback.call(app, page.model, params);
        next();
        return;
      }

      if (!page._routing) {
        tracks.render(page, {
          url: page.params.previous
        , method: 'exit'
        , noNavigate: true
        });
        app.view._beforeRoute();
      }
      page._routing = true;
      callback(page, page.model, params, next);
    } catch (err) {
      onRenderError(err, page.params.url);
    }
  }

  app.ready = function(fn) {
    if (app._initialized) return fn.call(app.page, app.model);
    app.once('ready', function() {
      fn.call(app.page, app.model);
    });
  };
  return app;
}

function init(modelBundle, ctx) {
  var app = global.DERBY.app
    , ns = ctx.$ns
    , renderHash = ctx.$renderHash
    , derby = this

  // The ready event is fired after the model data is initialized
  racer.ready(function(model) {
    var dom = new Dom(model);

    app.model = model;
    app.dom = dom;

    // Calling history.page() creates the initial page, which is only
    // created one time on the client
    // TODO: This is a rather obtuse mechanism
    var page = app.history.page();
    app.page = page;
    page.model = model;
    page.dom = dom;

    // Reinitialize any viewModels which were already initialized
    // during rendering on the server
    if (ctx.$viewModels) {
      for (var i = 0; i < ctx.$viewModels.length; i++) {
        var item = ctx.$viewModels[i];
        var viewModel = app._viewModels[item[0]];
        item[1].unshift(page);
        viewModel.init.apply(viewModel, item[1]);
      }
    }

    derbyModel.init(derby, app);
    // Catch errors thrown when rendering and then throw from a setTimeout.
    // This way, the remaining init code can run and the app still connects
    try {
      // Render immediately upon initialization so that the page is in
      // EXACTLY the same state it was when rendered on the server
      app.view.render(model, ns, ctx, renderHash);
    } catch (err) {
      setTimeout(function() {
        throw err;
      }, 0);
    }
    app._initialized = true;

    app.emit('ready');

    tracks.render(app.history.page(), {
      url: (window.location.pathname.slice(window.location.pathname.indexOf('index.html') + 10) + '/') + window.location.search
    , method: 'enter'
    , noNavigate: true
    });

    // Delaying here to make sure that all ready callbacks are called before
    // the create functions run on various components
    setTimeout(function() {
      app.view._afterRender(ns, ctx);
    }, 0);

    if (ctx.$scriptPath) {
      model.channel.send('derby:app', ctx.$scriptPath);
      refresh.autoRefresh(app.view, model);
    }
  });
  racer.init(modelBundle);
}

})(window)
},{"racer":"eS5xJL","./app":18,"./derby.Model":19,"./Dom":20,"./viewModel":21,"./refresh":22,"tracks":23}],18:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var racer = require('racer');
var component = require('./component');
var View = require('./View');
var viewModel = require('./viewModel');
var isServer = racer.util.isServer;
var paths = require('./paths');

exports.create = createApp;

function createApp(derby, appModule) {
  var app = racer.util.mergeInto(appModule.exports, EventEmitter.prototype)

  app.use = racer.util.use;
  component(app);
  app.filename = appModule.filename;
  app.view = new View(app._libraries, app, appModule.filename);
  app.fn = appFn;

  function appFn(value, fn) {
    if (typeof value === 'string') {
      // Don't bind the function on the server, since each
      // render gets passed a new model as part of the app
      paths.pathMerge(app, value, fn, bindPage);
    } else {
      paths.treeMerge(app, value, bindPage);
    }
    return app;
  }

  if (!isServer) {
    var bindPage = function(fn) {
      return function() {
        return fn.apply(app.page, arguments);
      };
    };
  }

  app._viewModels = {};
  app.viewModel = viewModel.construct.bind(app);

  return app;
}

},{"events":11,"racer":"eS5xJL","./component":24,"./View":25,"./viewModel":21,"./paths":26}],21:[function(require,module,exports){
var paths = require('./paths');

module.exports = {
  construct: construct
};

function ViewModel(name, proto) {
  this.name = name;
  this.proto = proto;
}
ViewModel.prototype.init = function(page) {
  var args = Array.prototype.slice.call(arguments, 1);
  // ViewModels are actually just scoped models for now
  var _super = page.model.at(this.name);
  var viewModel = _super._child();

  // Mixin viewModel specific methods
  viewModel._super = _super;
  viewModel.page = page;
  viewModel.model = page.model;
  for (key in this.proto) {
    if (key === 'init') continue;
    viewModel[key] = this.proto[key].bind(viewModel);
  }
  if (this.proto.init) {
    // Keep track of viewModels that were created so that
    // they can be recreated on the client if first rendered
    // on the server
    page._viewModels.push([this.name, args]);
    this.proto.init.apply(viewModel, args);
  }

  // Make viewModel available on the page for use in
  // event callbacks and other functions
  var segments = this.name.split('.');
  var last = segments.pop();
  var node = paths.traverseNode(page, segments);
  node[last] = viewModel;

  return viewModel;
}

function construct(name, proto) {
  // Keep a map of defined viewModels so that they can
  // be reinitialized from their name on the client
  var viewModel = this._viewModels[name] = new ViewModel(name, proto);
  return viewModel;
}

},{"./paths":26}],19:[function(require,module,exports){
(function(){var EventDispatcher = require('./EventDispatcher')
var PathMap = require('./PathMap')
var Model = require('racer').Model
var valueBinding = require('./View').valueBinding
var arraySlice = [].slice;

exports.init = init;

// Add support for creating a model alias from a DOM node or jQuery object
Model.prototype.__at = Model.prototype.at;
Model.prototype.at = function(node) {
  var isNode = node && (node.parentNode || node.jquery && (node = node[0]));
  if (!isNode) return this.__at(node);

  updateMarkers();

  var blockPaths = this.root.__blockPaths
    , pathMap = this.root.__pathMap
    , child, i, id, last, path, blockPath, children, len;
  while (node) {
    if (node.$derbyMarkerParent && last) {
      node = last;
      while (node = node.previousSibling) {
        if (!(id = node.$derbyMarkerId)) continue;
        blockPath = blockPaths[id];
        if (node.$derbyMarkerEnd || !blockPath) break;

        path = pathMap.paths[blockPath.id];
        if ((blockPath.type === 'each') && last) {
          i = 0;
          while (node = node.nextSibling) {
            if (node === last) {
              path = path + '.' + i;
              break;
            }
            i++;
          }
        }
        return this.scope(path);
      }
      last = last.parentNode;
      node = last.parentNode;
      continue;
    }
    if ((id = node.id) && (blockPath = blockPaths[id])) {
      path = pathMap.paths[blockPath.id];
      if ((blockPath.type === 'each') && last) {
        children = node.childNodes;
        for (i = 0, len = children.length; i < len; i++) {
          child = children[i];
          if (child === last) {
            path = path + '.' + i;
            break;
          }
        }
      }
      return this.scope(path);
    }
    last = node;
    node = node.parentNode;
  }

  // Just return the root scope if a path can't be found
  return this.scope();
}

function updateMarkers() {
  // NodeFilter.SHOW_COMMENT == 128
  var commentIterator = document.createTreeWalker(document.body, 128, null, false)
    , comment, id;
  while (comment = commentIterator.nextNode()) {
    if (comment.$derbyChecked) continue;
    comment.$derbyChecked = true;
    id = comment.data;
    if (id.charAt(0) !== '$') continue;
    if (id.charAt(1) === '$') {
      comment.$derbyMarkerEnd = true;
      id = id.slice(1);
    }
    comment.$derbyMarkerId = id;
    comment.parentNode.$derbyMarkerParent = true;
  }
}

function init(derby, app) {
  var model = app.model;
  var dom = app.dom;
  var pathMap = model.__pathMap = new PathMap;
  var events = model.__events = new EventDispatcher({
    onTrigger: derbyModelTrigger
  , onCleanup: derbyModelEventsCleanup
  });

  function derbyModelEventsCleanup(pathId, listener) {
    var id = listener[0];
    return !dom.item(id);
  }

  function derbyModelTrigger(pathId, listener, type, pass, value, index, arg) {
    var id = listener[0]
      , el = dom.item(id);

    // Ignore if the element can't be found, and cleanup after some delay
    if (!el) return events.delayedCleanup(pathId);

    var method = listener[1]
      , property = listener[2]
      , partial = listener.partial
      , path = pathMap.paths[pathId]
      , triggerId;

    // Handle text OT events
    if (type === 'stringInsert' || type === 'stringRemove') {
      if (method !== 'propOt' || el === pass.$el) return;
      method = type;
    }
    // Ignore side-effect change events that were already handled
    if (method === 'propOt' && (pass.$original === 'stringInsert' || pass.$original === 'stringRemove')) return;

    if (partial) {
      triggerId = id;
      if (method === 'html' && type) {
        if (partial.type === 'each') {
          // Handle array updates
          method = type;
          if (type === 'insert') {
            triggerId = null;
          } else if (type === 'remove') {
            partial = null;
          } else if (type === 'move') {
            partial = null;
          }
        } else {
          value = model.get(path);
        }
      }
    }
    if (listener.getValue) {
      value = listener.getValue(model, path);
    }
    if (partial) {
      // TODO Get rid of model.__fnCtx cache
      // Was causing issues with not emitting "init:child" or "create:child"
      // when dynamically rendering a component inside a parent component
      // within an each block.
      delete model.__fnCtx;

      if (method === 'insert') {
        var values = value;
        value = '';
        for (var i = 0, len = values.length; i < len; i++) {
          value += partial(listener.ctx, model, triggerId, values[i], index + i, listener) || '<!--empty-->';
        }
      } else {
        value = partial(listener.ctx, model, triggerId, value, index, listener);
      }
    }
    value = valueBinding(value);
    dom.update(el, method, pass.ignore, value, property, index, arg);
    // HACK: Use of global
    DERBY.app.view._flushUncreated();
  }

  var types = Object.keys(Model.MUTATOR_EVENTS);
  types.push('all');
  types.forEach(function(type) {
    var beforeType = 'beforeBinding:' + type;
    model.on(type, function(segments, eventArgs) {
      model.emit(beforeType, segments, eventArgs);
    });
  });

  model.on('change', '**', function derbyOnChange(path, value, previous, pass) {
    // For set operations on array items, also emit a remove and insert in case the
    // array is bound
    if (/\.\d+$/.test(path)) {
      var i = path.lastIndexOf('.');
      var arrayPath = path.slice(0, i);
      var index = +path.slice(i + 1);
      triggerEach(arrayPath, 'remove', pass, index);
      triggerEach(arrayPath, 'insert', pass, [value], index);
    }
    triggerEach(path, 'html', pass, value);
  });

  model.on('load', '**', function derbyOnLoad(path, value, pass) {
    triggerEach(path, 'html', pass, value);
  });

  model.on('unload', '**', function derbyOnLoad(path, previous, pass) {
    triggerEach(path, 'html', pass, void 0);
  });

  model.on('insert', '**', function derbyOnInsert(path, index, values, pass) {
    pathMap.onInsert(path, index, values.length);
    triggerEach(path, 'insert', pass, values, index);
  });

  model.on('remove', '**', function derbyOnRemove(path, index, removed, pass) {
    var howMany = removed.length;
    var end = index + howMany;
    pathMap.onRemove(path, index, howMany);

    for (var i = index; i < end; i++) {
      var id = pathMap.ids[path];
      if (id) events.trigger(id, 'remove', pass, index);
    }
    triggerParents(path, pass);
  });

  model.on('move', '**', function derbyOnMove(path, from, to, howMany, pass) {
    pathMap.onMove(path, from, to, howMany);
    triggerEach(path, 'move', pass, from, to, howMany);
  });

  model.on('stringInsert', '**', function derbyOnStringInsert(path, index, inserted, pass) {
    var value = model.get(path);
    var id = pathMap.ids[path];
    events.trigger(id, 'stringInsert', pass, value, index, inserted);
  });

  model.on('stringRemove', '**', function derbyOnStringRemove(path, index, howMany, pass) {
    var value = model.get(path);
    var id = pathMap.ids[path];
    events.trigger(id, 'stringRemove', pass, value, index, howMany);
  });

  function triggerEach(path, type, pass, arg0, arg1, arg2) {
    // Trigger an event on the path if it has a pathMap ID
    var id = pathMap.ids[path];
    if (id) events.trigger(id, type, pass, arg0, arg1, arg2);
    // Trigger a pattern event for the path and each of its parent paths
    // This is used by view helper functions to match updates on a path
    // or any of its child segments
    triggerParents(path, pass);
  }

  function triggerParents(path, pass) {
    var segments = path.split('.');
    for (var i = 1, len = segments.length; i <= len; i++) {
      var pattern = segments.slice(0, i).join('.') + '*';
      var id = pathMap.ids[pattern];
      if (id) events.trigger(id, null, pass);
    }
  }

  return model;
}

})()
},{"racer":"eS5xJL","./EventDispatcher":27,"./PathMap":28,"./View":25}],13:[function(require,module,exports){
(function(__dirname){module.exports = require('./Model');
var util = require('../util');

// Extend model on both server and client //
require('./events');
require('./paths');
require('./collections');
require('./mutators');
require('./setDiff');

require('./connection');
require('./subscriptions');
require('./Query');
require('./contexts');

require('./fn');
require('./filter');
require('./refList');
require('./ref');

// Extend model for server //
util.serverRequire(__dirname + '/bundle');
util.serverRequire(__dirname + '/connection.server');

})("/node_modules/derby/node_modules/racer/lib/Model")
},{"./Model":29,"../util":12,"./events":30,"./paths":31,"./collections":32,"./mutators":33,"./setDiff":34,"./connection":35,"./subscriptions":36,"./Query":37,"./contexts":38,"./fn":39,"./filter":40,"./refList":41,"./ref":42}],26:[function(require,module,exports){
module.exports = {
  traverseNode: traverseNode
, pathMerge: pathMerge
, treeMerge: treeMerge
};

function traverseNode(node, segments) {
  var i, len, segment
  for (i = 0, len = segments.length; i < len; i++) {
    segment = segments[i];
    node = node[segment] || (node[segment] = {});
  }
  return node;
}

// Recursively set nested objects based on a path
function pathMerge(node, path, value, nodeFn) {
  var segments = path.split('.')
    , last, i, len, segment
  if (typeof value === 'object') {
    node = traverseNode(node, segments);
    treeMerge(node, value, nodeFn);
    return;
  }
  last = segments.pop();
  node = traverseNode(node, segments);
  node[last] = (nodeFn) ? nodeFn(value) : value;
}

// Recursively set objects such that the non-objects are
// merged with the corresponding structure of the base node
function treeMerge(node, tree, nodeFn) {
  var key, child, value
  for (key in tree) {
    value = tree[key];
    if (typeof value === 'object') {
      child = node[key] || (node[key] = {});
      treeMerge(child, value, nodeFn);
      continue;
    }
    node[key] = (nodeFn) ? nodeFn(value) : value;
  }
}

},{}],27:[function(require,module,exports){
function empty() {}
function EventDispatcherNames() {}
function EventDispatcherListeners() {}
function CleanupPendingMap() {}

module.exports = EventDispatcher;

function EventDispatcher(options) {
  this._onTrigger = options && options.onTrigger || empty;
  this._onBind = options && options.onBind || empty;
  this._onCleanup = options && options.onCleanup;
  this._cleanupPending = new CleanupPendingMap();
  this.clear();
}

EventDispatcher.prototype.clear = function() {
  this.names = new EventDispatcherNames();
};

EventDispatcher.prototype.bind = function(name, listener, arg0) {
  this._onBind(name, listener, arg0);
  var obj = this.names[name] || (this.names[name] = new EventDispatcherListeners());
  obj[JSON.stringify(listener)] = listener;
  return obj;
};

EventDispatcher.prototype.trigger = function(name, value, arg0, arg1, arg2, arg3, arg4, arg5) {
  if (!name) return;
  var listeners = this.names[name];
  var onTrigger = this._onTrigger;
  var count = 0;
  var key, listener;
  for (key in listeners) {
    listener = listeners[key];
    count++;
    if (false !== onTrigger(name, listener, value, arg0, arg1, arg2, arg3, arg4, arg5)) {
      continue;
    }
    delete listeners[key];
    count--;
  }
  if (!count) delete this.names[name];
  return count;
};

EventDispatcher.prototype.delayedCleanup = function(name) {
  if (this._cleanupPending[name]) return;
  this._cleanupPending[name] = true;
  var eventDispatcher = this;
  setTimeout(function() {
    delete eventDispatcher._cleanupPending[name];
    eventDispatcher.cleanup(name);
  }, 0);
};

EventDispatcher.prototype.cleanup = function(name) {
  var listeners = this.names[name];
  var hasKeys = false;
  var key, remove;
  for (key in listeners) {
    remove = this._onCleanup(name, listeners[key]);
    if (remove) {
      delete listeners[key];
    } else {
      hasKeys = true;
    }
  }
  if (!hasKeys) delete this.names[name];
};

},{}],16:[function(require,module,exports){
(function(__filename){var config = {
  filename: __filename,
  ns: 'ghbtns',
  scripts: {
    button: require('./button')
  }
};

module.exports = function(app, options) {
  app.createLibrary(config, options);
}
})("/node_modules/derby-ui-github-buttons/index.js")
},{"./button":43}],28:[function(require,module,exports){
module.exports = PathMap;

function PathMap() {
  this.clear();
  this.count = 0;
}

PathMap.prototype.clear = function() {
  this.ids = {};
  this.paths = {};
  this.arrays = {};
};

PathMap.prototype.id = function(path) {
  // Return the path for an id, or create a new id and index it
  var id = this.ids[path];
  if (id) return id;
  id = (++this.count).toString();
  this.paths[id] = path;
  this._indexArray(path, id);
  this.ids[path] = id;
  return id;
};

PathMap.prototype._indexArray = function(path, id) {
  var arr, index, match, nested, remainder, set, setArrays;
  while (match = /^(.+)\.(\d+)(\*?(?:\..+|$))/.exec(path)) {
    path = match[1];
    index = +match[2];
    remainder = match[3];
    arr = this.arrays[path] || (this.arrays[path] = []);
    set = arr[index] || (arr[index] = {});
    if (nested) {
      setArrays = set.arrays || (set.arrays = {});
      setArrays[remainder] = true;
    } else {
      set[id] = remainder;
    }
    nested = true;
  }
};

PathMap.prototype._incrItems = function(path, map, start, end, byNum, oldArrays, oldPath) {
  var arrayMap, arrayPath, arrayPathTo, i, id, ids, itemPath, remainder;
  if (oldArrays == null) oldArrays = {};

  for (i = start; i < end; i++) {
    ids = map[i];
    if (!ids) continue;

    for (id in ids) {
      remainder = ids[id];
      if (id === 'arrays') {
        for (remainder in ids[id]) {
          arrayPath = (oldPath || path) + '.' + i + remainder;
          arrayMap = oldArrays[arrayPath] || this.arrays[arrayPath];
          if (arrayMap) {
            arrayPathTo = path + '.' + (i + byNum) + remainder;
            this.arrays[arrayPathTo] = arrayMap;
            this._incrItems(arrayPathTo, arrayMap, 0, arrayMap.length, 0, oldArrays, arrayPath);
          }
        }
        continue;
      }

      itemPath = path + '.' + (i + byNum) + remainder;
      this.paths[id] = itemPath;
      this.ids[itemPath] = +id;
    }
  }
};

PathMap.prototype._delItems = function(path, map, start, end, len, oldArrays) {
  var arrayLen, arrayMap, arrayPath, i, id, ids, itemPath, remainder;
  if (oldArrays == null) oldArrays = {};

  for (i = start; i < len; i++) {
    ids = map[i];
    if (!ids) continue;

    for (id in ids) {
      if (id === 'arrays') {
        for (remainder in ids[id]) {
          arrayPath = path + '.' + i + remainder;
          if (arrayMap = this.arrays[arrayPath]) {
            arrayLen = arrayMap.length;
            this._delItems(arrayPath, arrayMap, 0, arrayLen, arrayLen, oldArrays);
            oldArrays[arrayPath] = arrayMap;
            delete this.arrays[arrayPath];
          }
        }
        continue;
      }

      itemPath = this.paths[id];
      delete this.ids[itemPath];
      if (i > end) continue;
      delete this.paths[id];
    }
  }

  return oldArrays;
};

PathMap.prototype.onRemove = function(path, start, howMany) {
  var map = this.arrays[path]
    , end, len, oldArrays;
  if (!map) return;
  end = start + howMany;
  len = map.length;
  // Delete indicies for removed items
  oldArrays = this._delItems(path, map, start, end + 1, len);
  // Decrement indicies of later items
  this._incrItems(path, map, end, len, -howMany, oldArrays);
  map.splice(start, howMany);
};

PathMap.prototype.onInsert = function(path, start, howMany) {
  var map = this.arrays[path]
    , end, len, oldArrays;
  if (!map) return;
  end = start + howMany;
  len = map.length;
  // Delete indicies for items in inserted positions
  oldArrays = this._delItems(path, map, start, end + 1, len);
  // Increment indicies of later items
  this._incrItems(path, map, start, len, howMany, oldArrays);
  while (howMany--) {
    map.splice(start, 0, {});
  }
};

PathMap.prototype.onMove = function(path, from, to, howMany) {
  var map = this.arrays[path]
    , afterFrom, afterTo, items, oldArrays;
  if (!map) return;
  afterFrom = from + howMany;
  afterTo = to + howMany;
  // Adjust paths for items between from and to
  if (from > to) {
    oldArrays = this._delItems(path, map, to, afterFrom, afterFrom);
    this._incrItems(path, map, to, from, howMany, oldArrays);
  } else {
    oldArrays = this._delItems(path, map, from, afterTo, afterTo);
    this._incrItems(path, map, afterFrom, afterTo, -howMany, oldArrays);
  }
  // Adjust paths for the moved item(s)
  this._incrItems(path, map, from, afterFrom, to - from, oldArrays);
  // Fix the array index
  items = map.splice(from, howMany);
  map.splice.apply(map, [to, 0].concat(items));
};

},{}],44:[function(require,module,exports){
module.exports = {
  onStringInsert: onStringInsert
, onStringRemove: onStringRemove
, onTextInput: onTextInput
};

function onStringInsert(el, previous, index, text) {
  function transformCursor(cursor) {
    return (index < cursor) ? cursor + text.length : cursor;
  }
  var newText = previous.slice(0, index) + text + previous.slice(index);
  replaceText(el, newText, transformCursor);
}

function onStringRemove(el, previous, index, howMany) {
  function transformCursor(cursor) {
    return (index < cursor) ? cursor - Math.min(howMany, cursor - index) : cursor;
  }
  var newText = previous.slice(0, index) + previous.slice(index + howMany);
  replaceText(el, newText, transformCursor);
}

function replaceText(el, newText, transformCursor) {
  var selectionStart = transformCursor(el.selectionStart);
  var selectionEnd = transformCursor(el.selectionEnd);

  var scrollTop = el.scrollTop;
  el.value = newText;
  if (el.scrollTop !== scrollTop) {
    el.scrollTop = scrollTop;
  }
  if (document.activeElement === el) {
    el.selectionStart = selectionStart;
    el.selectionEnd = selectionEnd;
  }
}

function onTextInput(model, path, value) {
  var previous = model.get(path) || '';
  if (previous === value) return;
  var start = 0;
  while (previous.charAt(start) == value.charAt(start)) {
    start++;
  }
  var end = 0;
  while (
    previous.charAt(previous.length - 1 - end) === value.charAt(value.length - 1 - end) &&
    end + start < previous.length &&
    end + start < value.length
  ) {
    end++;
  }

  if (previous.length !== start + end) {
    var howMany = previous.length - start - end;
    model.stringRemove(path, start, howMany);
  }
  if (value.length !== start + end) {
    var inserted = value.slice(start, value.length - end);
    model.stringInsert(path, start, inserted);
  }
}

},{}],45:[function(require,module,exports){
(function(process){function filter (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (fn(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length; i >= 0; i--) {
    var last = parts[i];
    if (last == '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Regex to split a filename into [*, dir, basename, ext]
// posix version
var splitPathRe = /^(.+\/(?!$)|\/)?((?:.+?)?(\.[^.]*)?)$/;

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
var resolvedPath = '',
    resolvedAbsolute = false;

for (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {
  var path = (i >= 0)
      ? arguments[i]
      : process.cwd();

  // Skip empty and invalid entries
  if (typeof path !== 'string' || !path) {
    continue;
  }

  resolvedPath = path + '/' + resolvedPath;
  resolvedAbsolute = path.charAt(0) === '/';
}

// At this point the path should be resolved to a full absolute path, but
// handle relative paths to be safe (might happen when process.cwd() fails)

// Normalize the path
resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
var isAbsolute = path.charAt(0) === '/',
    trailingSlash = path.slice(-1) === '/';

// Normalize the path
path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }
  
  return (isAbsolute ? '/' : '') + path;
};


// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    return p && typeof p === 'string';
  }).join('/'));
};


exports.dirname = function(path) {
  var dir = splitPathRe.exec(path)[1] || '';
  var isWindows = false;
  if (!dir) {
    // No dirname
    return '.';
  } else if (dir.length === 1 ||
      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {
    // It is just a slash or a drive letter with a slash
    return dir;
  } else {
    // It is a full dirname, strip trailing slash
    return dir.substring(0, dir.length - 1);
  }
};


exports.basename = function(path, ext) {
  var f = splitPathRe.exec(path)[2] || '';
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPathRe.exec(path)[3] || '';
};

exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

})(require("__browserify_process"))
},{"__browserify_process":10}],12:[function(require,module,exports){
(function(process){var deepIs = require('deep-is');

var isServer = process.title !== 'browser';
var isProduction = process.env.NODE_ENV === 'production';

module.exports = {
  isServer: isServer
, isProduction: isProduction

, asyncGroup: asyncGroup
, contains: contains
, copyObject: copyObject
, deepCopy: deepCopy
, deepEqual: deepIs
, equal: equal
, equalsNaN: equalsNaN
, lookup: lookup
, mergeInto: mergeInto
, mayImpact: mayImpact
, mayImpactAny: mayImpactAny
, serverRequire: serverRequire
, use: use
};

function asyncGroup(cb) {
  var group = new AsyncGroup(cb);
  return function asyncGroupAdd() {
    return group.add();
  };
}

/**
 * @constructor
 * @param {Function} cb(err)
 */
function AsyncGroup(cb) {
  this.cb = cb;
  this.isDone = false;
  this.count = 0;
}
AsyncGroup.prototype.add = function() {
  this.count++;
  var self = this;
  return function(err) {
    self.count--;
    if (self.isDone) return;
    if (err) {
      self.isDone = true;
      self.cb(err);
      return;
    }
    if (self.count > 0) return;
    self.isDone = true;
    self.cb();
  };
};

function contains(segments, testSegments) {
  for (var i = 0; i < segments.length; i++) {
    if (segments[i] !== testSegments[i]) return false;
  }
  return true;
}

function copyObject(object) {
  var out = new object.constructor;
  for (var key in object) {
    if (object.hasOwnProperty(key)) {
      out[key] = object[key];
    }
  }
  return out;
}

function deepCopy(value) {
  if (value instanceof Date) return new Date(value);
  if (typeof value === 'object') {
    if (value === null) return null;
    var copy;
    if (Array.isArray(value)) {
      copy = [];
      for (var i = value.length; i--;) {
        copy[i] = deepCopy(value[i]);
      }
      return copy;
    }
    copy = new value.constructor;
    for (var key in value) {
      if (value.hasOwnProperty(key)) {
        copy[key] = deepCopy(value[key]);
      }
    }
    return copy;
  }
  return value;
}

function equal(a, b) {
  return (a === b) || (equalsNaN(a) && equalsNaN(b));
}

function equalsNaN(x) {
  return x !== x;
}

function lookup(segments, value) {
  if (!segments) return value;

  for (var i = 0, len = segments.length; i < len; i++) {
    if (value == null) return value;
    value = value[segments[i]];
  }
  return value;
}

function mayImpactAny(segmentsList, testSegments) {
  for (var i = 0, len = segmentsList.length; i < len; i++) {
    if (mayImpact(segmentsList[i], testSegments)) return true;
  }
  return false;
}

function mayImpact(segments, testSegments) {
  var len = Math.min(segments.length, testSegments.length);
  for (var i = 0; i < len; i++) {
    if (segments[i] !== testSegments[i]) return false;
  }
  return true;
}

function mergeInto(to, from) {
  for (var key in from) {
    to[key] = from[key];
  }
  return to;
}

function serverRequire(name) {
  if (!isServer) return;
  // Tricks Browserify into not logging a warning
  var _require = require;
  return _require(name);
}

function use(plugin, options) {
  // Server-side plugins may be included via filename
  if (typeof plugin === 'string') {
    if (!isServer) return this;
    plugin = serverRequire(plugin);
  }

  // Don't include a plugin more than once
  var plugins = this._plugins || (this._plugins = []);
  if (plugins.indexOf(plugin) === -1) {
    plugins.push(plugin);
    plugin(this, options);
  }
  return this;
}

})(require("__browserify_process"))
},{"deep-is":46,"__browserify_process":10}],43:[function(require,module,exports){
var url = require('url');

exports.init = function (model) {
  var filename = model.get('filename') || 'github-btn.html'
    , fileurl = model.get('fileurl')
    , domain = model.get('domain') || 'ghbtns.com'
    , giturl = model.get('giturl')
    , height = model.get('height')
    , protocol = model.get('secure') ? 'https' : 'http'
    , repo = model.get('repo')
    , size = model.get('size')
    , type = model.get('type')
    , user = model.get('user');

  if (!giturl && (!user || !repo)) {
    return console.error('ghbtns:button: giturl or user/repo required');
  }

  if (!type) {
    return console.error('ghbtns:button: type required');
  }

  if (!fileurl) {
    model.set('fileurl', protocol + '://' + domain + '/' + filename);
  }

  if (giturl) {
    var gitpath = url.parse(giturl).path.split('/');
    model.set('repo', gitpath[2].slice(0, -4));
    model.set('user', gitpath[1]);
  }

  if (!height) {
    model.set('height', size === 'large' ? '30' : '20');
  }

  model.set('show', true);
};
},{"url":47}],24:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter
  , path = require('path')
  , util = require('racer').util
  , View = require('./View')
  , arraySlice = Array.prototype.slice

module.exports = componentPlugin;

function componentPlugin(app) {
  app._libraries = [];
  app._libraries.map = {};
  app.createLibrary = createLibrary;
}

function ComponentProto() {}
util.mergeInto(ComponentProto.prototype, EventEmitter.prototype);

ComponentProto.prototype.emitCancellable = function() {
  var cancelled = false
    , args = arraySlice.call(arguments)

  function cancel() {
    cancelled = true;
  }

  args.push(cancel);
  this.emit.apply(this, args);
  return cancelled;
};

ComponentProto.prototype.emitDelayable = function() {
  var delayed = false
    , args = arraySlice.call(arguments, 0, -1)
    , callback = arguments[arguments.length - 1]

  function delay() {
    delayed = true;
  }

  args.push(delay, callback);
  this.emit.apply(this, args);
  if (!delayed) callback();
  return delayed;
};

function createLibrary(config, options) {
  if (!config || !config.filename) {
    throw new Error ('Configuration argument with a filename is required');
  }
  if (!options) options = {};
  var root = path.dirname(config.filename);
  var ns = options.ns || config.ns || path.basename(root);
  var scripts = config.scripts || {};
  var view = new View;
  var constructors = {};
  var library = {
    ns: ns
  , root: root
  , view: view
  , constructors: constructors
  , styles: config.styles
  };

  view.parent = this;
  view._selfNs = 'lib';
  view._selfLibrary = library;

  for (var name in scripts) {
    var script = scripts[name];
    script.setup && script.setup(library);

    var Component = function(model, scope) {
      this.view = view;
      this.model = model;
      this.scope = scope;
      this.history = null;
      this.dom = null;

      // Don't limit the number of listeners
      this.setMaxListeners(0);

      var component = this;
      model.__on = model._on;
      model._on = function(name, listener) {
        component.on('destroy', function() {
          model.removeListener(name, listener);
        })
        return model.__on(name, listener);
      };
      component.on('destroy', function() {
        model.silent().del();
      });
    }
    var proto = Component.prototype = new ComponentProto();
    util.mergeInto(proto, script);

    Component.view = view;
    Component.ns = Component.prototype.ns = ns;
    Component.name = Component.prototype.name = name;

    // Note that component names are all lowercased
    constructors[name.toLowerCase()] = Component;
  }

  var replaced = false;
  for (var i = this._libraries.length; i--;) {
    if (this._libraries[i].ns === ns) {
      this._libraries[i] = library;
      replaced = true;
    }
  }
  if (!replaced) {
    this._libraries.push(library);
  }
  this._libraries.map[ns] = library;
  return library;
}

},{"events":11,"path":45,"racer":"eS5xJL","./View":25}],22:[function(require,module,exports){
var escapeHtml = require('html-util').escapeHtml
  , errors = {};

exports.errorHtml = errorHtml;
exports.autoRefresh = autoRefresh;

function errorHtml(errors) {
  var text = ''
    , type, err;
  for (type in errors) {
    err = errors[type];
    text += '<h3>' + escapeHtml(type) + ' Error</h3><pre>' + escapeHtml(err) + '</pre>';
  }
  if (!text) return;
  return '<div id=$_derbyError style="position:absolute;background:rgba(0,0,0,.7);top:0;left:0;right:0;bottom:0;text-align:center">' +
    '<div style="background:#fff;padding:20px 40px;margin:60px;display:inline-block;text-align:left">' +
    text + '</div></div>';
}

function autoRefresh(view, model) {

  model.channel.on('derby:reload', reloadOnReady);
  // Wait to reload until the server is responsive again after restarting
  function reloadOnReady() {
    xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function() {
      if (xhr.readyState !== 4) return;
      if (xhr.status === 200) {
        return window.location.reload(true);
      }
      reloadOnReady();
    };
    xhr.open('GET', window.location.href);
    xhr.send();
  }

  model.channel.on('derby:refreshCss', function(data) {
    var el = document.getElementById('$_css');
    if (el) el.innerHTML = data.css;
    updateError('CSS', data.errText);
  });

  model.channel.on('derby:refreshHtml', function(data) {
    view._makeAll(data.templates, data.instances);
    view._makeComponents(data.libraryData);
    var errText = data.errText;
    try {
      view.app.history.refresh();
    } catch (err) {
      errText || (errText = err.stack);
    }
    updateError('Template', data.errText);
  });
}

function updateError(type, err) {
  if (err) {
    errors[type] = err;
  } else {
    delete errors[type];
  }
  var el = document.getElementById('$_derbyError')
    , html = errorHtml(errors)
    , fragment, range;
  if (html) {
    if (el) {
      el.outerHTML = html;
    } else {
      range = document.createRange();
      range.selectNode(document.body);
      fragment = range.createContextualFragment(html);
      document.body.appendChild(fragment);
    }
  } else {
    if (el) el.parentNode.removeChild(el);
  }
}

},{"html-util":48}],23:[function(require,module,exports){
var Route = require('../vendor/express/router/route')
var History = require('./History')
var router = module.exports = require('./router')
var compose = require('./compose')

router.setup = setup

function setup(app, createPage, onRoute) {
  var routes = {
    queue: {}
  , transitional: {}
  , onRoute: onRoute
  }
  app.history = new History(createPage, routes)

  ;['get', 'post', 'put', 'del', 'enter', 'exit'].forEach(function(method) {
    var queue = routes.queue[method] = []
    var transitional = routes.transitional[method] = []
    var transitionalCalls = []

    app[method] = function(pattern, callback) {
      if (Array.isArray(pattern)) {
        pattern.forEach(function(item) {
          app[method](item, callback)
        })
        return app
      }

      if (router.isTransitional(pattern)) {
        var from = pattern.from
        var to = pattern.to
        var forward = pattern.forward || (callback && callback.forward) || callback
        var back = pattern.back || (callback && callback.back)
        transitionalCalls.push({
          from: from
        , to: to
        , forward: forward
        , back: back
        })

        var fromRoute = new Route(method, from, back)
        var toRoute = new Route(method, to, forward)
        fromRoute.isTransitional = true
        toRoute.isTransitional = true
        transitional.push({
          from: fromRoute
        , to: toRoute
        })
        if (back) transitional.push({
          from: toRoute
        , to: fromRoute
        })

        compose.transition(app[method], transitionalCalls, from, to, forward, back)
        return app
      }

      queue.push(new Route(method, pattern, callback))
      return app
    }
  })
}

},{"../vendor/express/router/route":49,"./History":50,"./router":51,"./compose":52}],46:[function(require,module,exports){
var pSlice = Array.prototype.slice;
var Object_keys = typeof Object.keys === 'function'
    ? Object.keys
    : function (obj) {
        var keys = [];
        for (var key in obj) keys.push(key);
        return keys;
    }
;

var deepEqual = module.exports = function (actual, expected) {
  // enforce Object.is +0 !== -0
  if (actual === 0 && expected === 0) {
    return areZerosEqual(actual, expected);

  // 7.1. All identical values are equivalent, as determined by ===.
  } else if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  } else if (isNumberNaN(actual)) {
    return isNumberNaN(expected);

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (typeof actual != 'object' && typeof expected != 'object') {
    return actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
};

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function isNumberNaN(value) {
  // NaN === NaN -> false
  return typeof value == 'number' && value !== value;
}

function areZerosEqual(zeroA, zeroB) {
  // (1 / +0|0) -> Infinity, but (1 / -0) -> -Infinity and (Infinity !== -Infinity)
  return (1 / zeroA) === (1 / zeroB);
}

function objEquiv(a, b) {
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;

  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b);
  }
  try {
    var ka = Object_keys(a),
        kb = Object_keys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key])) return false;
  }
  return true;
}

},{}],30:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var util = require('../util');
var Model = require('./Model');

// This map determines which events get re-emitted as an 'all' event
Model.MUTATOR_EVENTS = {
  change: true
, insert: true
, remove: true
, move: true
, stringInsert: true
, stringRemove: true
, load: true
, unload: true
};

Model.INITS.push(function(model) {
  EventEmitter.call(this);

  // Set max listeners to unlimited
  model.setMaxListeners(0);

  // Used in async methods to emit an error event if a callback is not supplied.
  // This will throw if there is no handler for model.on('error')
  model.root._defaultCallback = defaultCallback;
  function defaultCallback(err) {
    if (typeof err === 'string') err = new Error(err);
    if (err) model.emit('error', err);
  }

  model.root._mutatorEventQueue = null;
  model._pass = new Passed({}, {});
});

util.mergeInto(Model.prototype, EventEmitter.prototype);

// EventEmitter.prototype.on, EventEmitter.prototype.addListener, and
// EventEmitter.prototype.once return `this`. The Model equivalents return
// the listener instead, since it is made internally for method subscriptions
// and may need to be passed to removeListener.

Model.prototype._emit = EventEmitter.prototype.emit;
Model.prototype.emit = function(type) {
  if (Model.MUTATOR_EVENTS[type]) {
    if (this._silent) return this;
    var segments = arguments[1];
    var eventArgs = arguments[2];
    if (this.root._mutatorEventQueue) {
      this.root._mutatorEventQueue.push([type, segments, eventArgs]);
      return this;
    }
    this.root._mutatorEventQueue = [];
    this._emit(type, segments, eventArgs);
    this._emit('all', segments, [type].concat(eventArgs));
    while (this.root._mutatorEventQueue.length) {
      var queued = this.root._mutatorEventQueue.shift();
      type = queued[0];
      segments = queued[1];
      eventArgs = queued[2];
      this._emit(type, segments, eventArgs);
      this._emit('all', segments, [type].concat(eventArgs));
    }
    this.root._mutatorEventQueue = null;
    return this;
  }
  return this._emit.apply(this, arguments);
};

Model.prototype._on = EventEmitter.prototype.on;
Model.prototype.addListener =
Model.prototype.on = function(type, pattern, cb) {
  var listener = eventListener(this, pattern, cb);
  this._on(type, listener);
  return listener;
};

Model.prototype.once = function(type, pattern, cb) {
  var listener = eventListener(this, pattern, cb);
  function g() {
    var matches = listener.apply(null, arguments);
    if (matches) this.removeListener(type, g);
  }
  this._on(type, g);
  return g;
};

Model.prototype._removeAllListeners = EventEmitter.prototype.removeAllListeners;
Model.prototype.removeAllListeners = function(type, subpattern) {
  if (!this._events) return this;

  // If a pattern is specified without an event type, remove all model event
  // listeners under that pattern for all events
  if (!type) {
    for (var key in this._events) {
      this.removeAllListeners(key, subpattern);
    }
    return this;
  }

  var pattern = this.path(subpattern);
  // If no pattern is specified, remove all listeners like normal
  if (!pattern) {
    if (arguments.length === 0) {
      return this._removeAllListeners();
    } else {
      return this._removeAllListeners(type);
    }
  }

  // Remove all listeners for an event under a pattern
  var listeners = this.listeners(type);
  var segments = pattern.split('.');
  // Make sure to iterate in reverse, since the array might be
  // mutated as listeners are removed
  for (var i = listeners.length; i--;) {
    var listener = listeners[i];
    if (patternContained(pattern, segments, listener)) {
      this.removeListener(type, listener);
    }
  }
};

function patternContained(pattern, segments, listener) {
  var listenerSegments = listener.patternSegments;
  if (!listenerSegments) return false;
  if (pattern === listener.pattern || pattern === '**') return true;
  var len = segments.length;
  if (len > listenerSegments.length) return false;
  for (var i = 0; i < len; i++) {
    if (segments[i] !== listenerSegments[i]) return false;
  }
  return true;
}

Model.prototype.pass = function(object, invert) {
  var model = this._child();
  model._pass = (invert) ?
    new Passed(object, this._pass) :
    new Passed(this._pass, object);
  return model;
};

function Passed(previous, value) {
  for (var key in previous) {
    this[key] = previous[key];
  }
  for (var key in value) {
    this[key] = value[key];
  }
}

/**
 * The returned Model will or won't trigger event handlers when the model emits
 * events, depending on `value`
 * @param {Boolean|Null} value defaults to true
 * @return {Model}
 */
Model.prototype.silent = function(value) {
  var model = this._child();
  model._silent = (value == null) ? true : value;
  return model;
};

function eventListener(model, subpattern, cb) {
  if (cb) {
    // For signatures:
    // model.on('change', 'example.subpath', callback)
    // model.at('example').on('change', 'subpath', callback)
    var pattern = model.path(subpattern);
    return modelEventListener(pattern, cb);
  }
  var path = model.path();
  cb = arguments[1];
  // For signature:
  // model.at('example').on('change', callback)
  if (path) return modelEventListener(path, cb);
  // For signature:
  // model.on('normalEvent', callback)
  return cb;
}

function modelEventListener(pattern, cb) {
  var patternSegments = pattern.split('.');
  var testFn = testPatternFn(pattern, patternSegments);

  function modelListener(segments, eventArgs) {
    var captures = testFn(segments);
    if (!captures) return;

    var args = (captures.length) ? captures.concat(eventArgs) : eventArgs;
    cb.apply(null, args);
    return true;
  }

  // Used in Model#removeAllListeners
  modelListener.pattern = pattern;
  modelListener.patternSegments = patternSegments;

  return modelListener;
}

function testPatternFn(pattern, patternSegments) {
  if (pattern === '**') {
    return function testPattern(segments) {
      return [segments.join('.')];
    };
  }

  var endingRest = stripRestWildcard(patternSegments);

  return function testPattern(segments) {
    // Any pattern with more segments does not match
    var patternLen = patternSegments.length;
    if (patternLen > segments.length) return;

    // A pattern with the same number of segments matches if each
    // of the segments are wildcards or equal. A shorter pattern matches
    // if it ends in a rest wildcard and each of the corresponding
    // segments are wildcards or equal.
    if (patternLen === segments.length || endingRest) {
      var captures = [];
      for (var i = 0; i < patternLen; i++) {
        var patternSegment = patternSegments[i];
        var segment = segments[i];
        if (patternSegment === '*' || patternSegment === '**') {
          captures.push(segment);
          continue;
        }
        if (patternSegment !== segment) return;
      }
      if (endingRest) {
        var remainder = segments.slice(i).join('.');
        captures.push(remainder);
      }
      return captures;
    }
  };
}

function stripRestWildcard(segments) {
  // ['example', '**'] -> ['example']; return true
  var lastIndex = segments.length - 1;
  if (segments[lastIndex] === '**') {
    segments.pop();
    return true;
  }
  // ['example', 'subpath**'] -> ['example', 'subpath']; return true
  var match = /^([^\*]+)\*\*$/.exec(segments[lastIndex]);
  if (!match) return false;
  segments[lastIndex] = match[1];
  return true;
}

},{"events":11,"../util":12,"./Model":29}],31:[function(require,module,exports){
var Model = require('./Model');

exports.mixin = {};

Model.prototype._splitPath = function(subpath) {
  var path = this.path(subpath);
  return (path && path.split('.')) || [];
};

/**
 * Returns the path equivalent to the path of the current scoped model plus
 * (optionally) a suffix subpath
 *
 * @optional @param {String} subpath
 * @return {String} absolute path
 * @api public
 */
Model.prototype.path = function(subpath) {
  if (subpath == null || subpath === '') return (this._at) ? this._at : '';
  if (typeof subpath === 'string' || typeof subpath === 'number') {
    return (this._at) ? this._at + '.' + subpath : '' + subpath;
  }
  if (typeof subpath.path === 'function') return subpath.path();
};

Model.prototype.isPath = function(subpath) {
  return this.path(subpath) != null;
};

Model.prototype.scope = function(path) {
  var model = this._child();
  model._at = path;
  return model;
};

/**
 * Create a model object scoped to a particular path.
 * Example:
 *     var user = model.at('users.1');
 *     user.set('username', 'brian');
 *     user.on('push', 'todos', function (todo) {
 *       // ...
 *     });
 *
 *  @param {String} segment
 *  @return {Model} a scoped model
 *  @api public
 */
Model.prototype.at = function(subpath) {
  var path = this.path(subpath);
  return this.scope(path);
};

/**
 * Returns a model scope that is a number of levels above the current scoped
 * path. Number of levels defaults to 1, so this method called without
 * arguments returns the model scope's parent model scope.
 *
 * @optional @param {Number} levels
 * @return {Model} a scoped model
 */
Model.prototype.parent = function(levels) {
  if (levels == null) levels = 1;
  var segments = this._splitPath();
  var len = Math.max(0, segments.length - levels);
  var path = segments.slice(0, len).join('.');
  return this.scope(path);
};

/**
 * Returns the last property segment of the current model scope path
 *
 * @optional @param {String} path
 * @return {String}
 */
Model.prototype.leaf = function(path) {
  if (!path) path = this.path();
  var i = path.lastIndexOf('.');
  return path.slice(i + 1);
};

},{"./Model":29}],32:[function(require,module,exports){
var Model = require('./Model');
var LocalDoc = require('./LocalDoc');
var util = require('../util');

function CollectionMap() {}
function ModelData() {}
function DocMap() {}
function CollectionData() {}

Model.INITS.push(function(model) {
  model.root.collections = new CollectionMap;
  model.root.data = new ModelData;
});

Model.prototype.getCollection = function(collectionName) {
  return this.root.collections[collectionName];
};
Model.prototype.getDoc = function(collectionName, id) {
  var collection = this.root.collections[collectionName];
  return collection && collection.docs[id];
};
Model.prototype.get = function(subpath) {
  var segments = this._splitPath(subpath);
  return this._get(segments);
};
Model.prototype._get = function(segments) {
  return util.lookup(segments, this.root.data);
};
Model.prototype.getOrCreateCollection = function(name) {
  var collection = this.root.collections[name];
  if (collection) return collection;
  var Doc = this._getDocConstructor(name);
  collection = new Collection(this.root, name, Doc);
  this.root.collections[name] = collection;
  return collection;
};
Model.prototype._getDocConstructor = function() {
  // Only create local documents. This is overriden in ./connection.js, so that
  // the RemoteDoc behavior can be selectively included
  return LocalDoc;
};

/**
 * Returns an existing document with id in a collection. If the document does
 * not exist, then creates the document with id in a collection and returns the
 * new document.
 * @param {String} collectionName
 * @param {String} id
 * @param {Object} [data] data to create if doc with id does not exist in collection
 */
Model.prototype.getOrCreateDoc = function(collectionName, id, data) {
  var collection = this.getOrCreateCollection(collectionName);
  return collection.docs[id] || collection.add(id, data);
};

/**
 * @param {String} collectionName
 */
Model.prototype.destroy = function(collectionName) {
  // TODO: non-collections
  var collection = this.getCollection(collectionName);
  collection && collection.destroy();
  this.removeAllRefs(collectionName);
  this.stopAll(collectionName);
  this.removeAllFilters(collectionName);
  this.removeAllListeners(null, collectionName);
};

function Collection(model, name, Doc) {
  this.model = model;
  this.name = name;
  this.Doc = Doc;
  this.docs = new DocMap();
  this.data = model.data[name] = new CollectionData();
}

/**
 * Adds a document with `id` and `data` to `this` Collection.
 * @param {String} id
 * @param {Object} data
 * @return {LocalDoc|RemoteDoc} doc
 */
Collection.prototype.add = function(id, data) {
  var doc = new this.Doc(this.model, this.name, id, data);
  this.docs[id] = doc;
  return doc;
};
Collection.prototype.destroy = function() {
  delete this.model.collections[this.name];
  delete this.model.data[this.name];
};

/**
 * Removes the document with `id` from `this` Collection. If there are no more
 * documents in the Collection after the given document is removed, then this
 * also destroys the Collection.
 * @param {String} id
 */
Collection.prototype.remove = function(id) {
  delete this.docs[id];
  delete this.data[id];
  if (noKeys(this.docs)) this.destroy();
};

/**
 * Returns an object that maps doc ids to fully resolved documents.
 * @return {Object}
 */
Collection.prototype.get = function() {
  return this.data;
};

function noKeys(object) {
  for (var key in object) {
    return false;
  }
  return true;
}

},{"./Model":29,"./LocalDoc":53,"../util":12}],33:[function(require,module,exports){
var util = require('../util');
var Model = require('./Model');

Model.prototype._mutate = function(segments, fn, cb) {
  if (!cb) cb = this.root._defaultCallback;
  var collectionName = segments[0];
  var id = segments[1];
  if (!collectionName || !id) {
    var message = fn.name + ' must be performed under a collection ' +
      'and document id. Invalid path: ' + segments.join('.');
    return cb(new Error(message));
  }
  var doc = this.getOrCreateDoc(collectionName, id);
  var docSegments = segments.slice(2);
  return fn(doc, docSegments, cb);
};

Model.prototype.set = function() {
  var subpath, value, cb;
  if (arguments.length === 1) {
    value = arguments[0];
  } else if (arguments.length === 2) {
    subpath = arguments[0];
    value = arguments[1];
  } else {
    subpath = arguments[0];
    value = arguments[1];
    cb = arguments[2];
  }
  var segments = this._splitPath(subpath);
  return this._set(segments, value, cb);
};
Model.prototype._set = function(segments, value, cb) {
  segments = this._dereference(segments);
  var model = this;
  function set(doc, docSegments, fnCb) {
    var previous = doc.set(docSegments, value, fnCb);
    model.emit('change', segments, [value, previous, model._pass]);
    return previous;
  }
  return this._mutate(segments, set, cb);
};

Model.prototype.setEach = function() {
  var subpath, object, cb;
  if (arguments.length === 1) {
    object = arguments[0];
  } else if (arguments.length === 2) {
    subpath = arguments[0];
    object = arguments[1];
  } else {
    subpath = arguments[0];
    object = arguments[1];
    cb = arguments[2];
  }
  var segments = this._splitPath(subpath);
  return this._setEach(segments, object, cb);
};
Model.prototype._setEach = function(segments, object, cb) {
  segments = this._dereference(segments);
  var group = util.asyncGroup(cb || this.root._defaultCallback);
  for (var key in object) {
    var value = object[key];
    this._set(segments.concat(key), value, group());
  }
};

Model.prototype.add = function() {
  var subpath, value, cb;
  if (arguments.length === 1) {
    value = arguments[0];
  } else if (arguments.length === 2) {
    if (typeof arguments[1] === 'function') {
      value = arguments[0];
      cb = arguments[1];
    } else {
      subpath = arguments[0];
      value = arguments[1];
    }
  } else {
    subpath = arguments[0];
    value = arguments[1];
    cb = arguments[2];
  }
  var segments = this._splitPath(subpath);
  return this._add(segments, value, cb);
};
Model.prototype._add = function(segments, value, cb) {
  if (typeof value !== 'object') {
    var message = 'add requires an object value. Invalid value: ' + value;
    cb || (cb = this.root._defaultCallback);
    return cb(new Error(message));
  }
  var id = value.id || this.id();
  value.id = id;
  this._set(segments.concat(id), value, cb);
  return id;
};

Model.prototype.setNull = function() {
  var subpath, value, cb;
  if (arguments.length === 1) {
    value = arguments[0];
  } else if (arguments.length === 2) {
    subpath = arguments[0];
    value = arguments[1];
  } else {
    subpath = arguments[0];
    value = arguments[1];
    cb = arguments[2];
  }
  var segments = this._splitPath(subpath);
  return this._setNull(segments, value, cb);
};
Model.prototype._setNull = function(segments, value, cb) {
  segments = this._dereference(segments);
  var model = this;
  function setNull(doc, docSegments, fnCb) {
    var previous = doc.get(docSegments);
    if (previous != null) {
      fnCb();
      return previous;
    }
    doc.set(docSegments, value, fnCb);
    model.emit('change', segments, [value, previous, model._pass]);
    return value;
  }
  return this._mutate(segments, setNull, cb);
};

Model.prototype.del = function() {
  var subpath, cb;
  if (arguments.length === 1) {
    if (typeof arguments[0] === 'function') {
      cb = arguments[0];
    } else {
      subpath = arguments[0];
    }
  } else {
    subpath = arguments[0];
    cb = arguments[1];
  }
  var segments = this._splitPath(subpath);
  return this._del(segments, cb);
};
Model.prototype._del = function(segments, cb) {
  segments = this._dereference(segments);
  var model = this;
  function del(doc, docSegments, fnCb) {
    var previous = doc.del(docSegments, fnCb);
    // When deleting an entire document, also remove the reference to the
    // document object from its collection
    if (segments.length === 2) {
      var collectionName = segments[0];
      var id = segments[1];
      model.root.collections[collectionName].remove(id);
    }
    model.emit('change', segments, [void 0, previous, model._pass]);
    return previous;
  }
  return this._mutate(segments, del, cb);
};

Model.prototype.increment = function() {
  var subpath, byNumber, cb;
  if (arguments.length === 1) {
    if (typeof arguments[0] === 'function') {
      cb = arguments[0];
    } else if (typeof arguments[0] === 'number') {
      byNumber = arguments[0];
    } else {
      subpath = arguments[0];
    }
  } else if (arguments.length === 2) {
    if (typeof arguments[1] === 'function') {
      cb = arguments[1];
      if (typeof arguments[0] === 'number') {
        byNumber = arguments[0];
      } else {
        subpath = arguments[0];
      }
    } else {
      subpath = arguments[0];
      byNumber = arguments[1];
    }
  } else {
    subpath = arguments[0];
    byNumber = arguments[1];
    cb = arguments[2];
  }
  var segments = this._splitPath(subpath);
  return this._increment(segments, byNumber, cb);
};
Model.prototype._increment = function(segments, byNumber, cb) {
  segments = this._dereference(segments);
  if (byNumber == null) byNumber = 1;
  var model = this;
  function increment(doc, docSegments, fnCb) {
    var value = doc.increment(docSegments, byNumber, fnCb);
    var previous = value - byNumber;
    model.emit('change', segments, [value, previous, model._pass]);
    return value;
  }
  return this._mutate(segments, increment, cb);
};

Model.prototype.push = function() {
  var subpath, value, cb;
  if (arguments.length === 1) {
    value = arguments[0];
  } else if (arguments.length === 2) {
    subpath = arguments[0];
    value = arguments[1];
  } else {
    subpath = arguments[0];
    value = arguments[1];
    cb = arguments[2];
  }
  var segments = this._splitPath(subpath);
  return this._push(segments, value, cb);
};
Model.prototype._push = function(segments, value, cb) {
  var forArrayMutator = true;
  segments = this._dereference(segments, forArrayMutator);
  var model = this;
  function push(doc, docSegments, fnCb) {
    var length = doc.push(docSegments, value, fnCb);
    model.emit('insert', segments, [length - 1, [value], model._pass]);
    return length;
  }
  return this._mutate(segments, push, cb);
};

Model.prototype.unshift = function() {
  var subpath, value, cb;
  if (arguments.length === 1) {
    value = arguments[0];
  } else if (arguments.length === 2) {
    subpath = arguments[0];
    value = arguments[1];
  } else {
    subpath = arguments[0];
    value = arguments[1];
    cb = arguments[2];
  }
  var segments = this._splitPath(subpath);
  return this._unshift(segments, value, cb);
};
Model.prototype._unshift = function(segments, value, cb) {
  var forArrayMutator = true;
  segments = this._dereference(segments, forArrayMutator);
  var model = this;
  function unshift(doc, docSegments, fnCb) {
    var length = doc.unshift(docSegments, value, fnCb);
    model.emit('insert', segments, [0, [value], model._pass]);
    return length;
  }
  return this._mutate(segments, unshift, cb);
};

Model.prototype.insert = function() {
  var subpath, index, values, cb;
  if (arguments.length === 1) {
    this.emit('error', new Error('Not enough arguments for insert'));
  } else if (arguments.length === 2) {
    index = arguments[0];
    values = arguments[1];
  } else if (arguments.length === 3) {
    subpath = arguments[0];
    index = arguments[1];
    values = arguments[2];
  } else {
    subpath = arguments[0];
    index = arguments[1];
    values = arguments[2];
    cb = arguments[3];
  }
  var segments = this._splitPath(subpath);
  return this._insert(segments, +index, values, cb);
};
Model.prototype._insert = function(segments, index, values, cb) {
  var forArrayMutator = true;
  segments = this._dereference(segments, forArrayMutator);
  var model = this;
  function insert(doc, docSegments, fnCb) {
    var inserted = (Array.isArray(values)) ? values : [values];
    var length = doc.insert(docSegments, index, inserted, fnCb);
    model.emit('insert', segments, [index, inserted, model._pass]);
    return length;
  }
  return this._mutate(segments, insert, cb);
};

Model.prototype.pop = function() {
  var subpath, cb;
  if (arguments.length === 1) {
    if (typeof arguments[0] === 'function') {
      cb = arguments[0];
    } else {
      subpath = arguments[0];
    }
  } else {
    subpath = arguments[0];
    cb = arguments[1];
  }
  var segments = this._splitPath(subpath);
  return this._pop(segments, cb);
};
Model.prototype._pop = function(segments, cb) {
  var forArrayMutator = true;
  segments = this._dereference(segments, forArrayMutator);
  var model = this;
  function pop(doc, docSegments, fnCb) {
    var arr = doc.get(docSegments);
    var length = arr && arr.length;
    if (!length) {
      fnCb();
      return;
    }
    var value = doc.pop(docSegments, fnCb);
    model.emit('remove', segments, [length - 1, [value], model._pass]);
    return value;
  }
  return this._mutate(segments, pop, cb);
};

Model.prototype.shift = function() {
  var subpath, cb;
  if (arguments.length === 1) {
    if (typeof arguments[0] === 'function') {
      cb = arguments[0];
    } else {
      subpath = arguments[0];
    }
  } else {
    subpath = arguments[0];
    cb = arguments[1];
  }
  var segments = this._splitPath(subpath);
  return this._shift(segments, cb);
};
Model.prototype._shift = function(segments, cb) {
  var forArrayMutator = true;
  segments = this._dereference(segments, forArrayMutator);
  var model = this;
  function shift(doc, docSegments, fnCb) {
    var arr = doc.get(docSegments);
    var length = arr && arr.length;
    if (!length) {
      fnCb();
      return;
    }
    var value = doc.shift(docSegments, fnCb);
    model.emit('remove', segments, [0, [value], model._pass]);
    return value;
  }
  return this._mutate(segments, shift, cb);
};

Model.prototype.remove = function() {
  var subpath, index, howMany, cb;
  if (arguments.length === 1) {
    index = arguments[0];
  } else if (arguments.length === 2) {
    if (typeof arguments[1] === 'function') {
      cb = arguments[1];
      if (typeof arguments[0] === 'number') {
        index = arguments[0];
      } else {
        subpath = arguments[0];
      }
    } else {
      if (typeof arguments[0] === 'number') {
        index = arguments[0];
        howMany = arguments[1];
      } else {
        subpath = arguments[0];
        index = arguments[1];
      }
    }
  } else if (arguments.length === 3) {
    if (typeof arguments[2] === 'function') {
      cb = arguments[2];
      if (typeof arguments[0] === 'number') {
        index = arguments[0];
        howMany = arguments[1];
      } else {
        subpath = arguments[0];
        index = arguments[1];
      }
    } else {
      subpath = arguments[0];
      index = arguments[1];
      howMany = arguments[2];
    }
  } else {
    subpath = arguments[0];
    index = arguments[1];
    howMany = arguments[2];
    cb = arguments[3];
  }
  var segments = this._splitPath(subpath);
  if (index == null) index = segments.pop();
  return this._remove(segments, +index, howMany, cb);
};
Model.prototype._remove = function(segments, index, howMany, cb) {
  var forArrayMutator = true;
  segments = this._dereference(segments, forArrayMutator);
  if (howMany == null) howMany = 1;
  var model = this;
  function remove(doc, docSegments, fnCb) {
    var removed = doc.remove(docSegments, index, howMany, fnCb);
    model.emit('remove', segments, [index, removed, model._pass]);
    return removed;
  }
  return this._mutate(segments, remove, cb);
};

Model.prototype.move = function() {
  var subpath, from, to, howMany, cb;
  if (arguments.length === 1) {
    this.emit('error', new Error('Not enough arguments for move'));
  } else if (arguments.length === 2) {
    from = arguments[0];
    to = arguments[1];
  } else if (arguments.length === 3) {
    if (typeof arguments[2] === 'function') {
      from = arguments[0];
      to = arguments[1];
      cb = arguments[2];
    } else if (typeof arguments[0] === 'number') {
      from = arguments[0];
      to = arguments[1];
      howMany = arguments[2];
    } else {
      subpath = arguments[0];
      from = arguments[1];
      to = arguments[2];
    }
  } else if (arguments.length === 4) {
    if (typeof arguments[3] === 'function') {
      cb = arguments[3];
      if (typeof arguments[0] === 'number') {
        from = arguments[0];
        to = arguments[1];
        howMany = arguments[2];
      } else {
        subpath = arguments[0];
        from = arguments[1];
        to = arguments[2];
      }
    } else {
      subpath = arguments[0];
      from = arguments[1];
      to = arguments[2];
      howMany = arguments[3];
    }
  } else {
    subpath = arguments[0];
    from = arguments[1];
    to = arguments[2];
    howMany = arguments[3];
    cb = arguments[4];
  }
  var segments = this._splitPath(subpath);
  return this._move(segments, from, to, howMany, cb);
};
Model.prototype._move = function(segments, from, to, howMany, cb) {
  var forArrayMutator = true;
  segments = this._dereference(segments, forArrayMutator);
  if (howMany == null) howMany = 1;
  var model = this;
  function move(doc, docSegments, fnCb) {
    // Cast to numbers
    from = +from;
    to = +to;
    // Convert negative indices into positive
    if (from < 0 || to < 0) {
      var len = doc.get(docSegments).length;
      if (from < 0) from += len;
      if (to < 0) to += len;
    }
    var moved = doc.move(docSegments, from, to, howMany, fnCb);
    model.emit('move', segments, [from, to, moved.length, model._pass]);
    return moved;
  }
  return this._mutate(segments, move, cb);
};

Model.prototype.stringInsert = function() {
  var subpath, index, text, cb;
  if (arguments.length === 1) {
    this.emit('error', new Error('Not enough arguments for stringInsert'));
  } else if (arguments.length === 2) {
    index = arguments[0];
    text = arguments[1];
  } else if (arguments.length === 3) {
    if (typeof arguments[2] === 'function') {
      index = arguments[0];
      text = arguments[1];
      cb = arguments[2];
    } else {
      subpath = arguments[0];
      index = arguments[1];
      text = arguments[2];
    }
  } else {
    subpath = arguments[0];
    index = arguments[1];
    text = arguments[2];
    cb = arguments[3];
  }
  var segments = this._splitPath(subpath);
  return this._stringInsert(segments, index, text, cb);
};
Model.prototype._stringInsert = function(segments, index, text, cb) {
  segments = this._dereference(segments);
  var model = this;
  function stringInsert(doc, docSegments, fnCb) {
    var previous = doc.stringInsert(docSegments, index, text, fnCb);
    model.emit('stringInsert', segments, [index, text, model._pass]);
    var value = doc.get(docSegments);
    var pass = model.pass({$original: 'stringInsert'})._pass;
    model.emit('change', segments, [value, previous, pass]);
    return;
  }
  return this._mutate(segments, stringInsert, cb);
};

Model.prototype.stringRemove = function() {
  var subpath, index, howMany, cb;
  if (arguments.length === 1) {
    this.emit('error', new Error('Not enough arguments for stringRemove'));
  } else if (arguments.length === 2) {
    index = arguments[0];
    howMany = arguments[1];
  } else if (arguments.length === 3) {
    if (typeof arguments[2] === 'function') {
      index = arguments[0];
      howMany = arguments[1];
      cb = arguments[2];
    } else {
      subpath = arguments[0];
      index = arguments[1];
      howMany = arguments[2];
    }
  } else {
    subpath = arguments[0];
    index = arguments[1];
    howMany = arguments[2];
    cb = arguments[3];
  }
  var segments = this._splitPath(subpath);
  return this._stringRemove(segments, index, howMany, cb);
};
Model.prototype._stringRemove = function(segments, index, howMany, cb) {
  segments = this._dereference(segments);
  var model = this;
  function stringRemove(doc, docSegments, fnCb) {
    var previous = doc.stringRemove(docSegments, index, howMany, fnCb);
    model.emit('stringRemove', segments, [index, howMany, model._pass]);
    var value = doc.get(docSegments);
    var pass = model.pass({$original: 'stringRemove'})._pass;
    model.emit('change', segments, [value, previous, pass]);
    return;
  }
  return this._mutate(segments, stringRemove, cb);
};

},{"./Model":29,"../util":12}],36:[function(require,module,exports){
(function(process){var util = require('../util');
var Model = require('./Model');
var Query = require('./Query');

Model.INITS.push(function(model, options) {
  model.root.fetchOnly = options.fetchOnly;
  model.root.unloadDelay = options.unloadDelay || 1000;

  // Keeps track of the count of fetches (that haven't been undone by an
  // unfetch) per doc. Maps doc id to the fetch count.
  model.root._fetchedDocs = new FetchedDocs;

  // Keeps track of the count of subscribes (that haven't been undone by an
  // unsubscribe) per doc. Maps doc id to the subscribe count.
  model.root._subscribedDocs = new SubscribedDocs;

  // Maps doc path to doc version
  model.root._loadVersions = new LoadVersions;
});

function FetchedDocs() {}
function SubscribedDocs() {}
function LoadVersions() {}

Model.prototype.fetch = function() {
  this._forSubscribable(arguments, 'fetch');
  return this;
};
Model.prototype.unfetch = function() {
  this._forSubscribable(arguments, 'unfetch');
  return this;
};
Model.prototype.subscribe = function() {
  this._forSubscribable(arguments, 'subscribe');
  return this;
};
Model.prototype.unsubscribe = function() {
  this._forSubscribable(arguments, 'unsubscribe');
  return this;
};

/**
 * @private
 * @param {Arguments} argumentsObject can take 1 of two forms
 *   1. [[subscribableObjects...], cb]
 *   2. [subscribableObjects..., cb]
 * @param {String} method can be 'fetch', 'unfetch', 'subscribe', 'unsubscribe'
 */
Model.prototype._forSubscribable = function(argumentsObject, method) {
  if (Array.isArray(argumentsObject[0])) {
    var args = argumentsObject[0];
    var cb = argumentsObject[1] || this.root._defaultCallback;
  } else {
    var args = Array.prototype.slice.call(argumentsObject);
    var last = args[args.length - 1];
    var cb = (typeof last === 'function') ? args.pop() : this.root._defaultCallback;
  }
  // If no queries or paths are passed in, try to use this model's scope
  if (!args.length) args.push(null);
  var group = util.asyncGroup(cb);
  var docMethod = method + 'Doc';

  var finished = group();
  for (var i = 0; i < args.length; i++) {
    var item = args[i];
    if (item instanceof Query) {
      item[method](group());
    } else {
      var segments = this._dereference(this._splitPath(item));
      if (segments.length === 2) {
        // Do the appropriate method for a single document.
        this[docMethod](segments[0], segments[1], group());
      } else if (segments.length === 1) {
        // Make a query to an entire collection.
        var query = this.query(segments[0], {});
        query[method](group());
      } else if (segments.length === 0) {
        cb(new Error('No path specified for ' + method));
      } else {
        cb(new Error('Cannot ' + method + ' to a path within a document: ' +
            segments.join('.')));
      }
    }
  }
  finished();
};

/**
 * @param {String}
 * @param {String} id
 * @param {Function} cb(err)
 * @param {Boolean} alreadyLoaded
 */
Model.prototype.fetchDoc = function(collectionName, id, cb, alreadyLoaded) {
  if (!cb) cb = this.root._defaultCallback;

  // Maintain a count of fetches so that we can unload the document when
  // there are no remaining fetches or subscribes for that document
  var path = collectionName + '.' + id;
  this.emit('fetchDoc', path, this._context, this._pass);
  this.root._fetchedDocs[path] = (this.root._fetchedDocs[path] || 0) + 1;

  var model = this;
  var doc = this.getOrCreateDoc(collectionName, id);
  if (alreadyLoaded) {
    process.nextTick(fetchDocCallback);
  } else {
    doc.shareDoc.fetch(fetchDocCallback);
  }
  function fetchDocCallback(err) {
    if (err) return cb(err);
    if (doc.shareDoc.version !== model.root._loadVersions[path]) {
      model.root._loadVersions[path] = doc.shareDoc.version;
      doc._updateCollectionData();
      model.emit('load', [collectionName, id], [doc.get(), model._pass]);
    }
    cb();
  }
};

/**
 * @param {String} collectionName
 * @param {String} id of the document we want to subscribe to
 * @param {Function} cb(err)
 */
Model.prototype.subscribeDoc = function(collectionName, id, cb) {
  if (!cb) cb = this.root._defaultCallback;

  var path = collectionName + '.' + id;
  this.emit('subscribeDoc', path, this._context, this._pass);
  var count = this.root._subscribedDocs[path] = (this.root._subscribedDocs[path] || 0) + 1;
  // Already requested a subscribe, so just return
  if (count > 1) return cb();

  // Subscribe if currently unsubscribed
  var model = this;
  var doc = this.getOrCreateDoc(collectionName, id);
  if (this.root.fetchOnly) {
    // Only fetch if the document isn't already loaded
    if (doc.get() === void 0) {
      doc.shareDoc.fetch(subscribeDocCallback);
    } else {
      process.nextTick(subscribeDocCallback);
    }
  } else {
    doc.shareDoc.subscribe(subscribeDocCallback);
  }
  function subscribeDocCallback(err) {
    if (err) return cb(err);
    if (!doc.createdLocally && doc.shareDoc.version !== model.root._loadVersions[path]) {
      model.root._loadVersions[path] = doc.shareDoc.version;
      doc._updateCollectionData();
      model.emit('load', [collectionName, id], [doc.get(), model._pass]);
    }
    cb();
  }
};

Model.prototype.unfetchDoc = function(collectionName, id, cb) {
  if (!cb) cb = this.root._defaultCallback;
  var path = collectionName + '.' + id;
  this.emit('unfetchDoc', path, this._context, this._pass);
  var fetchedDocs = this.root._fetchedDocs;

  // No effect if the document has no fetch count
  if (!fetchedDocs[path]) return cb();

  var model = this;
  if (this.root.unloadDelay && !this._pass.$query) {
    setTimeout(finishUnfetchDoc, this.root.unloadDelay);
  } else {
    finishUnfetchDoc();
  }
  function finishUnfetchDoc() {
    var count = --fetchedDocs[path];
    if (count) return cb(null, count);
    delete fetchedDocs[path];
    model._maybeUnloadDoc(collectionName, id, path);
    cb(null, 0);
  }
};

Model.prototype.unsubscribeDoc = function(collectionName, id, cb) {
  if (!cb) cb = this.root._defaultCallback;
  var path = collectionName + '.' + id;
  this.emit('unsubscribeDoc', path, this._context, this._pass);
  var subscribedDocs = this.root._subscribedDocs;

  // No effect if the document is not currently subscribed
  if (!subscribedDocs[path]) return cb();

  var model = this;
  if (this.root.unloadDelay && !this._pass.$query) {
    setTimeout(finishUnsubscribeDoc, this.root.unloadDelay);
  } else {
    finishUnsubscribeDoc();
  }
  function finishUnsubscribeDoc() {
    var count = --subscribedDocs[path];
    // If there are more remaining subscriptions, only decrement the count
    // and callback with how many subscriptions are remaining
    if (count) return cb(null, count);

    // If there is only one remaining subscription, actually unsubscribe
    delete subscribedDocs[path];
    if (model.root.fetchOnly) {
      unsubscribeDocCallback();
    } else {
      var shareDoc = model.root.shareConnection.get(collectionName, id);
      if (!shareDoc) {
        return cb(new Error('Share document not found for: ' + path));
      }
      shareDoc.unsubscribe(unsubscribeDocCallback);
    }
  }
  function unsubscribeDocCallback(err) {
    model._maybeUnloadDoc(collectionName, id, path);
    if (err) return cb(err);
    cb(null, 0);
  }
};

/**
 * Removes the document from the local model if the model no longer has any
 * remaining fetches or subscribes on path.
 * Called from Model.prototype.unfetchDoc and Model.prototype.unsubscribeDoc as
 * part of attempted cleanup.
 * @param {String} collectionName
 * @param {String} id
 * @param {String} path
 */
Model.prototype._maybeUnloadDoc = function(collectionName, id, path) {
  var doc = this.getDoc(collectionName, id);
  if (!doc) return;
  // Remove the document from the local model if it no longer has any
  // remaining fetches or subscribes
  if (this.root._fetchedDocs[path] || this.root._subscribedDocs[path]) return;
  var previous = doc.get();
  this.root.collections[collectionName].remove(id);
  if (doc.shareDoc) doc.shareDoc.destroy();
  delete this.root._loadVersions[path];
  this.emit('unload', [collectionName, id], [previous, this._pass]);
};

})(require("__browserify_process"))
},{"../util":12,"./Model":29,"./Query":37,"__browserify_process":10}],38:[function(require,module,exports){
/**
 * Contexts are useful for keeping track of the origin of subscribes.
 */

var Model = require('./Model');
var Query = require('./Query');

Model.INITS.push(function(model) {
  model.root._contexts = new Contexts;
  model.setContext('root');
  [ 'fetchDoc', 'subscribeDoc', 'unfetchDoc', 'unsubscribeDoc'
  , 'fetchQuery', 'subscribeQuery', 'unfetchQuery', 'unsubscribeQuery'
  ].forEach(function(event) {
    model.on(event, function(item, context, pass) {
      context[event](item, pass);
    });
  });
});

Model.prototype.context = function(id) {
  var model = this._child();
  model.setContext(id);
  return model;
};

Model.prototype.setContext = function(id) {
  var context = this.root._contexts[id] || new Context(this, id);
  this._context = this.root._contexts[id] = context;
  return context;
};

Model.prototype.unload = function(id) {
  var context = (id) ? this.root._contexts[id] : this._context;
  context.unload();
};

function Contexts() {}

function FetchedDocs() {}
function SubscribedDocs() {}
function FetchedQueries() {}
function SubscribedQueries() {}

function Context(model, id) {
  this.model = model;
  this.id = id;
  this.fetchedDocs = new FetchedDocs;
  this.subscribedDocs = new SubscribedDocs;
  this.fetchedQueries = new FetchedQueries;
  this.subscribedQueries = new SubscribedQueries;
}

Context.prototype.toJSON = function() {
  return {
    fetchedDocs: this.fetchedDocs
  , subscribedDocs: this.subscribedDocs
  , fetchedQueries: this.fetchedQueries
  , subscribedQueries: this.subscribedQueries
  };
};

Context.prototype.fetchDoc = function(path, pass) {
  if (pass.$query) return;
  mapIncrement(this.fetchedDocs, path);
};
Context.prototype.subscribeDoc = function(path, pass) {
  if (pass.$query) return;
  mapIncrement(this.subscribedDocs, path);
};
Context.prototype.unfetchDoc = function(path, pass) {
  if (pass.$query) return;
  mapDecrement(this.fetchedDocs, path);
};
Context.prototype.unsubscribeDoc = function(path, pass) {
  if (pass.$query) return;
  mapDecrement(this.subscribedDocs, path);
};
Context.prototype.fetchQuery = function(query) {
  mapIncrement(this.fetchedQueries, query.hash);
};
Context.prototype.subscribeQuery = function(query) {
  mapIncrement(this.subscribedQueries, query.hash);
};
Context.prototype.unfetchQuery = function(query) {
  mapDecrement(this.fetchedQueries, query.hash);
};
Context.prototype.unsubscribeQuery = function(query) {
  mapDecrement(this.subscribedQueries, query.hash);
};
function mapIncrement(map, key) {
  map[key] = (map[key] || 0) + 1;
}
function mapDecrement(map, key) {
  map[key] && map[key]--;
  if (!map[key]) delete map[key];
}

Context.prototype.unload = function() {
  var model = this.model;
  for (var hash in this.fetchedQueries) {
    var query = model.root._queries.map[hash];
    if (!query) continue;
    var count = this.fetchedQueries[hash];
    while (count--) query.unfetch(null);
  }
  for (var hash in this.subscribedQueries) {
    var query = model.root._queries.map[hash];
    if (!query) continue;
    var count = this.subscribedQueries[hash];
    while (count--) query.unsubscribe(null);
  }
  for (var path in this.fetchedDocs) {
    var segments = path.split('.');
    var count = this.fetchedDocs[path];
    while (count--) model.unfetchDoc(segments[0], segments[1]);
  }
  for (var path in this.subscribedDocs) {
    var segments = path.split('.');
    var count = this.subscribedDocs[path];
    while (count--) model.unsubscribeDoc(segments[0], segments[1]);
  }
  model._context = model.root._contexts[this.id] = new Context(model, this.id);
};

},{"./Model":29,"./Query":37}],39:[function(require,module,exports){
var util = require('../util');
var Model = require('./Model');
var defaultFns = require('./defaultFns');

function NamedFns() {}

Model.INITS.push(function(model) {
  model.root._namedFns = new NamedFns();
  model.root._fns = new Fns(model);
  model.on('all', fnListener);
  function fnListener(segments, eventArgs) {
    var pass = eventArgs[eventArgs.length - 1];
    var map = model.root._fns.fromMap;
    for (var path in map) {
      var fn = map[path];
      if (pass.$fn === fn) continue;
      if (util.mayImpactAny(fn.inputsSegments, segments)) {
        // Mutation affecting input path
        fn.onInput(pass);
      } else if (util.mayImpact(fn.fromSegments, segments)) {
        // Mutation affecting output path
        fn.onOutput(pass);
      }
    }
  }
});

Model.prototype.fn = function(name, fns) {
  this.root._namedFns[name] = fns;
};

function parseStartArguments(model, args, hasPath) {
  if (typeof args[0] === 'function') {
    var fns = args[0];
  } else {
    var name = args[0];
  }
  if (hasPath) {
    var path = model.path(args[1]);
    var inputPaths = Array.prototype.slice.call(args, 2);
  } else {
    var inputPaths = Array.prototype.slice.call(args, 1);
  }
  var i = inputPaths.length - 1;
  if (model.isPath(inputPaths[i])) {
    inputPaths[i] = model.path(inputPaths[i]);
  } else {
    var options = inputPaths.pop();
  }
  while (i--) {
    inputPaths[i] = model.path(inputPaths[i]);
  }
  return {
    name: name
  , path: path
  , inputPaths: inputPaths
  , fns: fns
  , options: options
  };
}

Model.prototype.evaluate = function(name) {
  var args = parseStartArguments(this, arguments, false);
  return this.root._fns.get(args.name, args.inputPaths, args.fns, args.options);
};

Model.prototype.start = function(name, subpath) {
  var args = parseStartArguments(this, arguments, true);
  return this.root._fns.start(args.name, args.path, args.inputPaths, args.fns, args.options);
};

Model.prototype.stop = function(subpath) {
  var path = this.path(subpath);
  this.root._fns.stop(path);
};

Model.prototype.stopAll = function(subpath) {
  var segments = this._splitPath(subpath);
  var fns = this.root._fns.fromMap;
  for (var from in fns) {
    if (util.contains(segments, fns[from].fromSegments)) {
      this.stop(from);
    }
  }
};

function FromMap() {}
function Fns(model) {
  this.model = model;
  this.nameMap = model.root._namedFns;
  this.fromMap = new FromMap;
}

Fns.prototype.get = function(name, inputPaths, fns, options) {
  fns || (fns = this.nameMap[name] || defaultFns[name]);
  var fn = new Fn(this.model, name, null, inputPaths, fns, options);
  return fn.get();
};

Fns.prototype.start = function(name, path, inputPaths, fns, options) {
  fns || (fns = this.nameMap[name] || defaultFns[name]);
  var fn = new Fn(this.model, name, path, inputPaths, fns, options);
  this.fromMap[path] = fn;
  return fn.onInput();
};

Fns.prototype.stop = function(path) {
  var fn = this.fromMap[path];
  delete this.fromMap[path];
  return fn;
};

Fns.prototype.toJSON = function() {
  var out = [];
  for (var from in this.fromMap) {
    var fn = this.fromMap[from];
    // Don't try to bundle non-named functions that were started via
    // model.start directly instead of by name
    if (!fn.name) continue;
    out.push([fn.name, fn.from].concat(fn.inputPaths));
  }
  return out;
};

function Fn(model, name, from, inputPaths, fns, options) {
  this.model = model.pass({$fn: this});
  this.name = name;
  this.from = from;
  this.inputPaths = inputPaths;
  if (!fns) {
    var err = new TypeError('Model function not found: ' + name);
    model.emit('error', err);
  }
  this.getFn = fns.get || fns;
  this.setFn = fns.set;
  this.fromSegments = from && from.split('.');
  this.inputsSegments = [];
  for (var i = 0; i < this.inputPaths.length; i++) {
    var segments = this.inputPaths[i].split('.');
    this.inputsSegments.push(segments);
  }
  var copy = (options && options.copy) || 'output';
  this.copyInput = (copy === 'input' || copy === 'both');
  this.copyOutput = (copy === 'output' || copy === 'both');
}

Fn.prototype.apply = function(fn, inputs) {
  for (var i = 0, len = this.inputsSegments.length; i < len; i++) {
    var input = this.model._get(this.inputsSegments[i]);
    inputs.push(this.copyInput ? util.deepCopy(input) : input);
  }
  return fn.apply(this.model, inputs);
};

Fn.prototype.get = function() {
  return this.apply(this.getFn, []);
};

var diffOptions = {equal: util.deepEqual};
var eachDiffOptions = {each: true, equal: util.deepEqual};

Fn.prototype.set = function(value, pass) {
  if (!this.setFn) return;
  var out = this.apply(this.setFn, [value]);
  if (!out) return;
  var inputsSegments = this.inputsSegments;
  var model = this.model.pass(pass, true);
  for (var key in out) {
    if (key === 'each') {
      var each = out[key];
      for (key in each) {
        var value = (this.copyOutput) ? util.deepCopy(each[key]) : each[key];
        model._setDiff(inputsSegments[key], value, eachDiffOptions);
      }
      continue;
    }
    var value = (this.copyOutput) ? util.deepCopy(out[key]) : out[key];
    model._setDiff(inputsSegments[key], value, diffOptions);
  }
};

Fn.prototype.onInput = function(pass) {
  var value = (this.copyOutput) ? util.deepCopy(this.get()) : this.get();
  this.model.pass(pass, true)._setDiff(this.fromSegments, value, diffOptions);
  return value;
};

Fn.prototype.onOutput = function(pass) {
  var value = this.model._get(this.fromSegments);
  return this.set(value, pass);
};

},{"../util":12,"./Model":29,"./defaultFns":54}],40:[function(require,module,exports){
var util = require('../util');
var Model = require('./Model');
var defaultFns = require('./defaultFns');

Model.INITS.push(function(model) {
  model.root._filters = new Filters(model);
  model.on('all', filterListener);
  function filterListener(segments, eventArgs) {
    var pass = eventArgs[eventArgs.length - 1];
    var map = model.root._filters.fromMap;
    for (var path in map) {
      var filter = map[path];
      if (pass.$filter === filter) continue;
      if (util.mayImpact(filter.inputSegments, segments)) {
        filter.update(pass);
      }
    }
  }
});

Model.prototype.filter = function(input, fn) {
  var inputPath = this.path(input);
  return this.root._filters.add(inputPath, fn);
};

Model.prototype.sort = function(input, fn) {
  var inputPath = this.path(input);
  return this.root._filters.add(inputPath, null, fn || 'asc');
};

Model.prototype.removeAllFilters = function(subpath) {
  var segments = this._splitPath(subpath);
  var filters = this.root._filters.fromMap;
  for (var from in filters) {
    if (util.contains(segments, filters[from].fromSegments)) {
      filters[from].destroy();
    }
  }
};

function FromMap() {}
function Filters(model) {
  this.model = model;
  this.fromMap = new FromMap;
}

Filters.prototype.add = function(inputPath, filterFn, sortFn) {
  return new Filter(this, inputPath, filterFn, sortFn);
};

Filters.prototype.toJSON = function() {
  var out = [];
  for (var from in this.fromMap) {
    var filter = this.fromMap[from];
    // Don't try to bundle if functions were passed directly instead of by name
    if (!filter.bundle) continue;
    out.push([filter.inputPath, filter.filterName, filter.sortName, from]);
  }
  return out;
};

function Filter(filters, inputPath, filterFn, sortFn) {
  this.filters = filters;
  this.model = filters.model.pass({$filter: this});
  this.inputPath = inputPath;
  this.inputSegments = inputPath.split('.');
  this.filterName = null;
  this.sortName = null;
  this.bundle = true;
  this.filterFn = null;
  this.sortFn = null;
  if (filterFn) this.filter(filterFn);
  if (sortFn) this.sort(sortFn);
  this.idsSegments = null;
  this.from = null;
  this.fromSegments = null;
}

Filter.prototype.filter = function(fn) {
  if (typeof fn === 'function') {
    this.filterFn = fn;
    this.bundle = false;
    return this;
  }
  if (typeof fn === 'string') {
    this.filterName = fn;
    this.filterFn = this.model.root._namedFns[fn] || defaultFns[fn];
    if (!this.filterFn) {
      var err = new TypeError('Filter function not found: ' + fn);
      this.model.emit('error', err);
    }
  }
  return this;
};

Filter.prototype.sort = function(fn) {
  if (!fn) fn = 'asc';
  if (typeof fn === 'function') {
    this.sortFn = fn;
    this.bundle = false;
    return this;
  }
  if (typeof fn === 'string') {
    this.sortName = fn;
    this.sortFn = this.model.root._namedFns[fn] || defaultFns[fn];
    if (!this.sortFn) {
      var err = new TypeError('Sort function not found: ' + fn);
      this.model.emit('error', err);
    }
  }
  return this;
};

Filter.prototype.ids = function() {
  var items = this.model._get(this.inputSegments);
  var ids = [];
  if (!items) return ids;
  if (Array.isArray(items)) {
    if (this.filterFn) {
      for (var i = 0; i < items.length; i++) {
        if (this.filterFn.call(this.model, items[i], i, items)) {
          ids.push(i);
        }
      }
    } else {
      for (var i = 0; i < items.length; i++) ids.push(i);
    }
  } else {
    if (this.filterFn) {
      for (var key in items) {
        if (items.hasOwnProperty(key) &&
          this.filterFn.call(this.model, items[key], key, items)
        ) {
          ids.push(key);
        }
      }
    } else {
      ids = Object.keys(items);
    }
  }
  var sortFn = this.sortFn;
  if (sortFn) {
    ids.sort(function(a, b) {
      return sortFn(items[a], items[b]);
    });
  }
  return ids;
};

Filter.prototype.get = function() {
  var items = this.model._get(this.inputSegments);
  var results = [];
  if (Array.isArray(items)) {
    if (this.filterFn) {
      for (var i = 0; i < items.length; i++) {
        if (this.filterFn.call(this.model, items[i], i, items)) {
          results.push(items[i]);
        }
      }
    } else {
      results = items.slice();
    }
  } else {
    if (this.filterFn) {
      for (var key in items) {
        if (items.hasOwnProperty(key) &&
          this.filterFn.call(this.model, items[key], key, items)
        ) {
          results.push(items[key]);
        }
      }
    } else {
      for (var key in items) {
        if (items.hasOwnProperty(key)) {
          results.push(items[key]);
        }
      }
    }
  }
  if (this.sortFn) results.sort(this.sortFn);
  return results;
};

Filter.prototype.update = function(pass) {
  var ids = this.ids();
  this.model.pass(pass, true)._setDiff(this.idsSegments, ids);
};

Filter.prototype.ref = function(from) {
  from = this.model.path(from);
  this.from = from;
  this.fromSegments = from.split('.');
  this.filters.fromMap[from] = this;
  this.idsSegments = ['$filters', from.replace(/\./g, '|')];
  this.update();
  return this.model.refList(from, this.inputPath, this.idsSegments.join('.'));
};

Filter.prototype.destroy = function() {
  delete this.filters.fromMap[this.from];
  this.model.removeRefList(this.from);
  this.model._del(this.idsSegments);
};

},{"../util":12,"./Model":29,"./defaultFns":54}],41:[function(require,module,exports){
var util = require('../util');
var Model = require('./Model');

Model.INITS.push(function(model) {
  var root = model.root;
  root._refLists = new RefLists(root);
  for (var type in Model.MUTATOR_EVENTS) {
    addListener(root, type);
  }
});

function addListener(model, type) {
  model.on(type, refListListener);
  function refListListener(segments, eventArgs) {
    var pass = eventArgs[eventArgs.length - 1];
    // Check for updates on or underneath paths
    var fromMap = model._refLists.fromMap;
    for (var from in fromMap) {
      var refList = fromMap[from];
      if (pass.$refList === refList) continue;
      refList.onMutation(type, segments, eventArgs);
    }
  }
}

/**
 * @param {String} type
 * @param {Array} segments
 * @param {Array} eventArgs
 * @param {RefList} refList
 */
function patchFromEvent(type, segments, eventArgs, refList) {
  var fromLength = refList.fromSegments.length;
  var segmentsLength = segments.length;
  var pass = eventArgs[eventArgs.length - 1];
  var model = refList.model.pass(pass, true);

  // Mutation on the `from` output itself
  if (segmentsLength === fromLength) {
    if (type === 'insert') {
      var index = eventArgs[0];
      var values = eventArgs[1];
      var ids = setNewToValues(model, refList, values);
      model._insert(refList.idsSegments, index, ids);
      return;
    }

    if (type === 'remove') {
      var index = eventArgs[0];
      var howMany = eventArgs[1].length;
      var ids = model._remove(refList.idsSegments, index, howMany);
      // Delete the appropriate items underneath `to` if the `deleteRemoved`
      // option was set true
      if (refList.deleteRemoved) {
        for (var i = 0; i < ids.length; i++) {
          var item = refList.itemById(ids[i]);
          model._del(refList.toSegmentsByItem(item));
        }
      }
      return;
    }

    if (type === 'move') {
      var from = eventArgs[0];
      var to = eventArgs[1];
      var howMany = eventArgs[2];
      model._move(refList.idsSegments, from, to, howMany);
      return;
    }

    // Change of the entire output
    var values = (type === 'change') ?
      eventArgs[0] : model._get(refList.fromSegments);
    // Set ids to empty list if output is set to null
    if (!values) {
      model._set(refList.idsSegments, []);
      return;
    }
    // If the entire output is set, create a list of ids based on the output,
    // and update the corresponding items
    var ids = setNewToValues(model, refList, values);
    model._set(refList.idsSegments, ids);
    return;
  }

  // If mutation is on a parent of `from`, we might need to re-create the
  // entire refList output
  if (segmentsLength < fromLength) {
    model._setArrayDiff(refList.fromSegments, refList.get());
    return;
  }

  var index = segments[fromLength];
  var value = model._get(refList.fromSegments.concat(index));
  var toSegments = refList.toSegmentsByItem(value);

  // Mutation underneath a child of the `from` object.
  if (segmentsLength > fromLength + 1) {
    var message = 'Mutation on descendant of refList `from` should have been dereferenced: ' + segments.join('.');
    model.emit('error', new Error(message));
    return;
  }

  // Otherwise, mutation of a child of the `from` object

  // If changing the item itself, it will also have to be re-set on the
  // original object
  if (type === 'change') {
    model._set(toSegments, value);
    updateIdForValue(model, refList, index, value);
    return;
  }
  // The same goes for string mutations, since strings are immutable
  if (type === 'stringInsert') {
    var stringIndex = eventArgs[0];
    var stringValue = eventArgs[1];
    model._stringInsert(toSegments, stringIndex, stringValue);
    updateIdForValue(model, refList, index, value);
    return;
  }
  if (type === 'stringRemove') {
    var stringIndex = eventArgs[0];
    var howMany = eventArgs[1];
    model._stringRemove(toSegments, stringIndex, howMany);
    updateIdForValue(model, refList, index, value);
    return;
  }
  if (type === 'insert' || type === 'remove' || type === 'move') {
    var message = 'Array mutation on child of refList `from` should have been dereferenced: ' + segments.join('.');
    model.emit('error', new Error(message));
    return;
  }
}

/**
 * @private
 * @param {Model} model
 * @param {RefList} refList
 * @param {Array} values
 */
function setNewToValues(model, refList, values, fn) {
  var ids = [];
  for (var i = 0; i < values.length; i++) {
    var value = values[i];
    var id = refList.idByItem(value);
    if (id === void 0 && typeof value === 'object') {
      id = value.id = model.id();
    }
    var toSegments = refList.toSegmentsByItem(value);
    if (id === void 0 || toSegments === void 0) {
      var message = 'Unable to add item to refList: ' + value;
      return model.emit('error', new Error(message));
    }
    if (model._get(toSegments) !== value) {
      model._set(toSegments, value);
    }
    ids.push(id);
  }
  return ids;
}
function updateIdForValue(model, refList, index, value) {
  var id = refList.idByItem(value);
  var outSegments = refList.idsSegments.concat(index);
  model._set(outSegments, id);
}

function patchToEvent(type, segments, eventArgs, refList) {
  var toLength = refList.toSegments.length;
  var segmentsLength = segments.length;
  var pass = eventArgs[eventArgs.length - 1];
  var model = refList.model.pass(pass, true);

  // Mutation on the `to` object itself
  if (segmentsLength === toLength) {
    if (type === 'insert') {
      var insertIndex = eventArgs[0];
      var values = eventArgs[1];
      for (var i = 0; i < values.length; i++) {
        var value = values[i];
        var indices = refList.indicesByItem(value);
        if (!indices) continue;
        for (var j = 0; j < indices.length; j++) {
          var outSegments = refList.fromSegments.concat(indices[j]);
          model._set(outSegments, value);
        }
      }
      return;
    }

    if (type === 'remove') {
      var removeIndex = eventArgs[0];
      var values = eventArgs[1];
      var howMany = values.length;
      for (var i = removeIndex, len = removeIndex + howMany; i < len; i++) {
        var indices = refList.indicesByItem(values[i]);
        if (!indices) continue;
        for (var j = 0, indicesLen = indices.length; j < indicesLen; j++) {
          var outSegments = refList.fromSegments.concat(indices[j]);
          model._set(outSegments, void 0);
        }
      }
      return;
    }

    if (type === 'move') {
      // Moving items in the `to` object should have no effect on the output
      return;
    }
  }

  // Mutation on or above the `to` object
  if (segmentsLength <= toLength) {
    // If the entire `to` object is updated, we need to re-create the
    // entire refList output and apply what is different
    model._setArrayDiff(refList.fromSegments, refList.get());
    return;
  }

  // Mutation underneath a child of the `to` object. The item will already
  // be up to date, since it is under an object reference. Just re-emit
  if (segmentsLength > toLength + 1) {
    var value = model._get(segments.slice(0, toLength + 1));
    var indices = refList.indicesByItem(value);
    if (!indices) return;
    var remaining = segments.slice(toLength + 1);
    for (var i = 0; i < indices.length; i++) {
      var index = indices[i];
      var dereferenced = refList.fromSegments.concat(index, remaining);
      dereferenced = model._dereference(dereferenced, null, refList);
      eventArgs = eventArgs.slice();
      eventArgs[eventArgs.length - 1] = model._pass;
      model.emit(type, dereferenced, eventArgs);
    }
    return;
  }

  // Otherwise, mutation of a child of the `to` object

  // If changing the item itself, it will also have to be re-set on the
  // array created by the refList
  if (type === 'change' || type === 'load' || type === 'unload') {
    var value, previous;
    if (type === 'change') {
      value = eventArgs[0];
      previous = eventArgs[1];
    } else if (type === 'load') {
      value = eventArgs[0];
      previous = void 0;
    } else if (type === 'unload') {
      value = void 0;
      previous = eventArgs[0];
    }
    var newIndices = refList.indicesByItem(value);
    var oldIndices = refList.indicesByItem(previous);
    if (!newIndices && !oldIndices) return;
    if (oldIndices && !equivalentArrays(oldIndices, newIndices)) {
      // The changed item used to refer to some indices, but no longer does
      for (var i = 0; i < oldIndices.length; i++) {
        var outSegments = refList.fromSegments.concat(oldIndices[i]);
        model._set(outSegments, void 0);
      }
    }
    if (newIndices) {
      for (var i = 0; i < newIndices.length; i++) {
        var outSegments = refList.fromSegments.concat(newIndices[i]);
        model._set(outSegments, value);
      }
    }
    return;
  }

  var value = model._get(segments.slice(0, toLength + 1));
  var indices = refList.indicesByItem(value);
  if (!indices) return;

  // The same goes for string mutations, since strings are immutable
  if (type === 'stringInsert') {
    var stringIndex = eventArgs[0];
    var value = eventArgs[1];
    for (var i = 0; i < indices.length; i++) {
      var outSegments = refList.fromSegments(indices[i]);
      model._stringInsert(outSegments, stringIndex, value);
    }
    return;
  }
  if (type === 'stringRemove') {
    var stringIndex = eventArgs[0];
    var howMany = eventArgs[1];
    for (var i = 0; i < indices.length; i++) {
      var outSegments = refList.fromSegments(indices[i]);
      model._stringRemove(outSegments, stringIndex, howMany);
    }
    return;
  }
  if (type === 'insert' || type === 'remove' || type === 'move') {
    // Array mutations will have already been updated via an object
    // reference, so only re-emit
    for (var i = 0; i < indices.length; i++) {
      var dereferenced = refList.fromSegments.concat(indices[i]);
      dereferenced = model._dereference(dereferenced, null, refList);
      eventArgs = eventArgs.slice();
      eventArgs[eventArgs.length - 1] = model._pass;
      model.emit(type, dereferenced, eventArgs);
    }
  }
}
function equivalentArrays(a, b) {
  if (!a || !b) return false;
  if (a.length !== b.length) return false;
  for (var i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}

function patchIdsEvent(type, segments, eventArgs, refList) {
  var idsLength = refList.idsSegments.length;
  var segmentsLength = segments.length;
  var pass = eventArgs[eventArgs.length - 1];
  var model = refList.model.pass(pass, true);

  // An array mutation of the ids should be mirrored with a like change in
  // the output array
  if (segmentsLength === idsLength) {
    if (type === 'insert') {
      var index = eventArgs[0];
      var inserted = eventArgs[1];
      var values = [];
      for (var i = 0; i < inserted.length; i++) {
        var value = refList.itemById(inserted[i]);
        values.push(value);
      }
      model._insert(refList.fromSegments, index, values);
      return;
    }

    if (type === 'remove') {
      var index = eventArgs[0];
      var howMany = eventArgs[1].length;
      model._remove(refList.fromSegments, index, howMany);
      return;
    }

    if (type === 'move') {
      var from = eventArgs[0];
      var to = eventArgs[1];
      var howMany = eventArgs[2];
      model._move(refList.fromSegments, from, to, howMany);
      return;
    }
  }

  // Mutation on the `ids` list itself
  if (segmentsLength <= idsLength) {
    // If the entire `ids` array is updated, we need to re-create the
    // entire refList output and apply what is different
    model._setArrayDiff(refList.fromSegments, refList.get());
    return;
  }

  // Otherwise, direct mutation of a child in the `ids` object or mutation
  // underneath an item in the `ids` list. Update the item for the appropriate
  // id if it has changed
  var index = segments[idsLength];
  var id = refList.idByIndex(index);
  var item = refList.itemById(id);
  var itemSegments = refList.fromSegments.concat(index);
  if (model._get(itemSegments) !== item) {
    model._set(itemSegments, item);
  }
}

Model.prototype.refList = function() {
  var from, to, ids, options;
  if (arguments.length === 2) {
    to = arguments[0];
    ids = arguments[1];
  } else if (arguments.length === 3) {
    if (this.isPath(arguments[2])) {
      from = arguments[0];
      to = arguments[1];
      ids = arguments[2];
    } else {
      to = arguments[0];
      ids = arguments[1];
      options = arguments[2];
    }
  } else {
    from = arguments[0];
    to = arguments[1];
    ids = arguments[2];
    options = arguments[3];
  }
  var fromPath = this.path(from);
  if (Array.isArray(to)) {
    var toPath = [];
    for (var i = 0; i < to.length; i++) {
      toPath.push(this.path(to[i]));
    }
  } else {
    var toPath = this.path(to);
  }
  var idsPath = this.path(ids);
  var refList = this.root._refLists.add(fromPath, toPath, idsPath, options);
  this.pass({$refList: refList})._setArrayDiff(refList.fromSegments, refList.get());
  return this.scope(fromPath);
};

Model.prototype.removeRefList = function(from) {
  var fromPath = this.path(from);
  var refList = this.root._refLists.remove(fromPath);
  if (refList) this._del(refList.fromSegments);
};

function RefList(model, from, to, ids, options) {
  this.model = model && model.pass({$refList: this});
  this.from = from;
  this.to = to;
  this.ids = ids;
  this.fromSegments = from && from.split('.');
  this.toSegments = to && to.split('.');
  this.idsSegments = ids && ids.split('.');
  this.options = options;
  this.deleteRemoved = options && options.deleteRemoved;
}

// The default implementation assumes that the ids array is a flat list of
// keys on the to object. Ideally, this mapping could be customized via
// inheriting from RefList and overriding these methods without having to
// modify the above event handling code.
// 
// In the default refList implementation, `key` and `id` are equal.
// 
// Terms in the below methods:
//   `item`  - Object on the `to` path, which gets mirrored on the `from` path
//   `key`   - The property under `to` at which an item is located
//   `id`    - String or object in the array at the `ids` path
//   `index` - The index of an id, which corresponds to an index on `from`
RefList.prototype.get = function() {
  var ids = this.model._get(this.idsSegments);
  if (!ids) return [];
  var items = this.model._get(this.toSegments);
  var out = [];
  for (var i = 0; i < ids.length; i++) {
    var key = ids[i];
    out.push(items && items[key]);
  }
  return out;
};
RefList.prototype.dereference = function(segments, i) {
  var remaining = segments.slice(i + 1);
  var key = this.idByIndex(remaining[0]);
  if (key == null) return [];
  remaining[0] = key;
  return this.toSegments.concat(remaining);
};
RefList.prototype.toSegmentsByItem = function(item) {
  var key = this.idByItem(item);
  if (key === void 0) return;
  return this.toSegments.concat(key);
};
RefList.prototype.idByItem = function(item) {
  if (item && item.id) return item.id;
  var items = this.model._get(this.toSegments);
  for (var key in items) {
    if (item === items[key]) return key;
  }
};
RefList.prototype.indicesByItem = function(item) {
  var id = this.idByItem(item);
  var ids = this.model._get(this.idsSegments);
  if (!ids) return;
  var indices;
  var index = -1;
  while (true) {
    index = ids.indexOf(id, index + 1);
    if (index === -1) break;
    if (indices) {
      indices.push(index);
    } else {
      indices = [index];
    }
  }
  return indices;
};
RefList.prototype.itemById = function(id) {
  return this.model._get(this.toSegments.concat(id));
};
RefList.prototype.idByIndex = function(index) {
  return this.model._get(this.idsSegments.concat(index));
};
RefList.prototype.onMutation = function(type, segments, eventArgs) {
  if (util.mayImpact(this.toSegments, segments)) {
    patchToEvent(type, segments, eventArgs, this);
  } else if (util.mayImpact(this.idsSegments, segments)) {
    patchIdsEvent(type, segments, eventArgs, this);
  } else if (util.mayImpact(this.fromSegments, segments)) {
    patchFromEvent(type, segments, eventArgs, this);
  }
};

function FromMap() {}

function RefLists(model) {
  this.model = model;
  this.fromMap = new FromMap;
}

RefLists.prototype.add = function(from, to, ids, options) {
  var refList = new RefList(this.model, from, to, ids, options);
  this.fromMap[from] = refList;
  return refList;
};

RefLists.prototype.remove = function(from) {
  var refList = this.fromMap[from];
  delete this.fromMap[from];
  return refList;
};

RefLists.prototype.toJSON = function() {
  var out = [];
  for (var from in this.fromMap) {
    var refList = this.fromMap[from];
    out.push([refList.from, refList.to, refList.ids, refList.options]);
  }
  return out;
};

},{"../util":12,"./Model":29}],42:[function(require,module,exports){
var util = require('../util');
var Model = require('./Model');

Model.INITS.push(function(model) {
  var root = model.root;
  root._refs = new Refs(root);
  addIndexListeners(root);
  addListener(root, 'change', refChange);
  addListener(root, 'load', refLoad);
  addListener(root, 'unload', refUnload);
  addListener(root, 'insert', refInsert);
  addListener(root, 'remove', refRemove);
  addListener(root, 'move', refMove);
  addListener(root, 'stringInsert', refStringInsert);
  addListener(root, 'stringRemove', refStringRemove);
});

function addIndexListeners(model) {
  model.on('insert', function refInsertIndex(segments, eventArgs) {
    var index = eventArgs[0];
    var howMany = eventArgs[1].length;
    function patchInsert(refIndex) {
      return (index <= refIndex) ? refIndex + howMany : refIndex;
    }
    onIndexChange(segments, patchInsert);
  });
  model.on('remove', function refRemoveIndex(segments, eventArgs) {
    var index = eventArgs[0];
    var howMany = eventArgs[1].length;
    function patchRemove(refIndex) {
      return (index <= refIndex) ? refIndex - howMany : refIndex;
    }
    onIndexChange(segments, patchRemove);
  });
  model.on('move', function refMoveIndex(segments, eventArgs) {
    var from = eventArgs[0];
    var to = eventArgs[1];
    var howMany = eventArgs[2];
    function patchMove(refIndex) {
      // If the index was moved itself
      if (from <= refIndex && refIndex < from + howMany) {
        return refIndex + to - from;
      }
      // Remove part of a move
      if (from <= refIndex) refIndex -= howMany;
      // Insert part of a move
      if (to <= refIndex) refIndex += howMany;
      return refIndex;
    }
    onIndexChange(segments, patchMove);
  });
  function onIndexChange(segments, patch) {
    var fromMap = model._refs.fromMap;
    for (var from in fromMap) {
      var ref = fromMap[from];
      if (!(ref.updateIndices &&
        util.contains(segments, ref.toSegments) &&
        ref.toSegments.length > segments.length)) continue;
      var index = +ref.toSegments[segments.length];
      var patched = patch(index);
      if (index === patched) continue;
      model._refs.remove(from);
      ref.toSegments[segments.length] = '' + patched;
      ref.to = ref.toSegments.join('.');
      model._refs._add(ref);
    }
  }
}

function refChange(model, dereferenced, eventArgs) {
  var value = eventArgs[0];
  model._set(dereferenced, value);
}
function refLoad(model, dereferenced, eventArgs) {
  var value = eventArgs[0];
  model._set(dereferenced, value);
}
function refUnload(model, dereferenced, eventArgs) {
  model._del(dereferenced);
}
function refInsert(model, dereferenced, eventArgs) {
  var index = eventArgs[0];
  var values = eventArgs[1];
  model._insert(dereferenced, index, values);
}
function refRemove(model, dereferenced, eventArgs) {
  var index = eventArgs[0];
  var howMany = eventArgs[1].length;
  model._remove(dereferenced, index, howMany);
}
function refMove(model, dereferenced, eventArgs) {
  var from = eventArgs[0];
  var to = eventArgs[1];
  var howMany = eventArgs[2];
  model._move(dereferenced, from, to, howMany);
}
function refStringInsert(model, dereferenced, eventArgs) {
  var index = eventArgs[0];
  var text = eventArgs[1];
  model._stringInsert(dereferenced, index, text);
}
function refStringRemove(model, dereferenced, eventArgs) {
  var index = eventArgs[0];
  var howMany = eventArgs[1];
  model._stringRemove(dereferenced, index, howMany);
}

function addListener(model, type, fn) {
  model.on(type, refListener);
  function refListener(segments, eventArgs) {
    var pass = eventArgs[eventArgs.length - 1];
    // Find cases where an event is emitted on a path where a reference
    // is pointing. All original mutations happen on the fully dereferenced
    // location, so this detection only needs to happen in one direction
    var toMap = model._refs.toMap;
    for (var i = 0, len = segments.length; i < len; i++) {
      var subpath = (subpath) ? subpath + '.' + segments[i] : segments[i];
      // If a ref is found pointing to a matching subpath, re-emit on the
      // place where the reference is coming from as if the mutation also
      // occured at that path
      var refs = toMap[subpath];
      if (!refs) continue;
      var remaining = segments.slice(i + 1);
      for (var refIndex = 0, numRefs = refs.length; refIndex < numRefs; refIndex++) {
        var ref = refs[refIndex];
        var dereferenced = ref.fromSegments.concat(remaining);
        // The value may already be up to date via object reference. If so,
        // simply re-emit the event. Otherwise, perform the same mutation on
        // the ref's path
        if (pass.$original || model._get(dereferenced) === model._get(segments)) {
          model.emit(type, dereferenced, eventArgs);
        } else {
          var setterModel = ref.model.pass(pass, true);
          setterModel._dereference = noopDereference;
          fn(setterModel, dereferenced, eventArgs);
        }
      }
    }
    // If a ref points to a child of a matching subpath, get the value in
    // case it has changed and set if different
    var parentToMap = model._refs.parentToMap;
    var refs = parentToMap[subpath];
    if (!refs) return;
    for (var refIndex = 0, numRefs = refs.length; refIndex < numRefs; refIndex++) {
      var ref = refs[refIndex];
      var value = model._get(ref.toSegments);
      var previous = model._get(ref.fromSegments);
      if (previous !== value) {
        var setterModel = ref.model.pass(pass, true);
        setterModel._dereference = noopDereference;
        setterModel._set(ref.fromSegments, value);
      }
    }
  }
}

Model.prototype.ref = function() {
  var from, to, options;
  if (arguments.length === 1) {
    to = arguments[0];
  } else if (arguments.length === 2) {
    if (this.isPath(arguments[1])) {
      from = arguments[0];
      to = arguments[1];
    } else {
      to = arguments[0];
      options = arguments[1];
    }
  } else {
    from = arguments[0];
    to = arguments[1];
    options = arguments[2];
  }
  var fromPath = this.path(from);
  var toPath = this.path(to);
  var fromSegments = fromPath.split('.');
  if (fromSegments.length < 2) {
    var message = 'ref must be performed under a collection ' +
      'and document id. Invalid path: ' + fromPath;
    this.emit('error', new Error(message));
  }
  this.root._refs.remove(fromPath);
  var value = this.get(to);
  this._set(fromSegments, value);
  this.root._refs.add(fromPath, toPath, options);
  return this.scope(fromPath);
};

Model.prototype.removeRef = function(from) {
  var fromPath = this.path(from);
  this.root._refs.remove(fromPath);
  this.del(from);
};

Model.prototype.removeAllRefs = function(subpath) {
  var segments = this._splitPath(subpath);
  var refs = this.root._refs.fromMap;
  var refLists = this.root._refLists.fromMap;
  for (var from in refs) {
    if (util.contains(segments, refs[from].fromSegments)) {
      this.removeRef(from);
    }
  }
  for (var from in refLists) {
    if (util.contains(segments, refLists[from].fromSegments)) {
      this.removeRefList(from);
    }
  }
};

Model.prototype.dereference = function(subpath) {
  var segments = this._splitPath(subpath);
  return this._dereference(segments).join('.');
};

Model.prototype._dereference = function(segments, forArrayMutator, ignore) {
  if (segments.length === 0) return segments;
  var refs = this.root._refs.fromMap;
  var refLists = this.root._refLists.fromMap;
  do {
    var subpath = '';
    var doAgain = false;
    for (var i = 0, len = segments.length; i < len; i++) {
      subpath = (subpath) ? subpath + '.' + segments[i] : segments[i];

      var ref = refs[subpath];
      if (ref) {
        var remaining = segments.slice(i + 1);
        segments = ref.toSegments.concat(remaining);
        doAgain = true;
        break;
      }

      var refList = refLists[subpath];
      if (refList && refList !== ignore) {
        var belowDescendant = i + 2 < len;
        var belowChild = i + 1 < len;
        if (!(belowDescendant || forArrayMutator && belowChild)) continue;
        segments = refList.dereference(segments, i);
        doAgain = true;
        break;
      }
    }
  } while (doAgain);
  // If a dereference fails, return a path that will result in a null value
  // instead of a path to everything in the model
  if (segments.length === 0) return ['$null'];
  return segments;
};

function noopDereference(segments) {
  return segments;
}

function Ref(model, from, to, options) {
  this.model = model && model.pass({$ref: this});
  this.from = from;
  this.to = to;
  this.fromSegments = from.split('.');
  this.toSegments = to.split('.');
  this.parentTos = [];
  for (var i = 1, len = this.toSegments.length; i < len; i++) {
    var parentTo = this.toSegments.slice(0, i).join('.');
    this.parentTos.push(parentTo);
  }
  this.updateIndices = options && options.updateIndices;
}
function FromMap() {}
function ToMap() {}

function Refs(model) {
  this.model = model;
  this.fromMap = new FromMap;
  this.toMap = new ToMap;
  this.parentToMap = new ToMap;
}

Refs.prototype.add = function(from, to, options) {
  var ref = new Ref(this.model, from, to, options);
  return this._add(ref);
};

Refs.prototype._add = function(ref) {
  this.fromMap[ref.from] = ref;
  listMapAdd(this.toMap, ref.to, ref);
  for (var i = 0, len = ref.parentTos.length; i < len; i++) {
    listMapAdd(this.parentToMap, ref.parentTos[i], ref);
  }
  return ref;
};

Refs.prototype.remove = function(from) {
  var ref = this.fromMap[from];
  if (!ref) return;
  delete this.fromMap[from];
  listMapRemove(this.toMap, ref.to, ref);
  for (var i = 0, len = ref.parentTos.length; i < len; i++) {
    listMapRemove(this.parentToMap, ref.parentTos[i], ref);
  }
  return ref;
};

Refs.prototype.toJSON = function() {
  var out = [];
  for (var from in this.fromMap) {
    var ref = this.fromMap[from];
    out.push([ref.from, ref.to]);
  }
  return out;
};

function listMapAdd(map, name, item) {
  map[name] || (map[name] = []);
  map[name].push(item);
}

function listMapRemove(map, name, item) {
  var items = map[name];
  if (!items) return;
  var index = items.indexOf(item);
  if (index === -1) return;
  items.splice(index, 1);
  if (!items.length) delete map[name];
}

},{"../util":12,"./Model":29}],47:[function(require,module,exports){
var punycode = { encode : function (s) { return s } };

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

function arrayIndexOf(array, subject) {
    for (var i = 0, j = array.length; i < j; i++) {
        if(array[i] == subject) return i;
    }
    return -1;
}

var objectKeys = Object.keys || function objectKeys(object) {
    if (object !== Object(object)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in object) if (object.hasOwnProperty(key)) keys[keys.length] = key;
    return keys;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]+$/,
    // RFC 2396: characters reserved for delimiting URLs.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '~', '[', ']', '`'].concat(delims),
    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''],
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#']
      .concat(unwise).concat(autoEscape),
    nonAuthChars = ['/', '@', '?', '#'].concat(delims),
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-zA-Z0-9][a-z0-9A-Z_-]{0,62}$/,
    hostnamePartStart = /^([a-zA-Z0-9][a-z0-9A-Z_-]{0,62})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always have a path component.
    pathedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && typeof(url) === 'object' && url.href) return url;

  if (typeof url !== 'string') {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var out = {},
      rest = url;

  // cut off any delimiters.
  // This is to support parse stuff like "<http://foo.com>"
  for (var i = 0, l = rest.length; i < l; i++) {
    if (arrayIndexOf(delims, rest.charAt(i)) === -1) break;
  }
  if (i !== 0) rest = rest.substr(i);


  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    out.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      out.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {
    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    // don't enforce full RFC correctness, just be unstupid about it.

    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the first @ sign, unless some non-auth character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    var atSign = arrayIndexOf(rest, '@');
    if (atSign !== -1) {
      // there *may be* an auth
      var hasAuth = true;
      for (var i = 0, l = nonAuthChars.length; i < l; i++) {
        var index = arrayIndexOf(rest, nonAuthChars[i]);
        if (index !== -1 && index < atSign) {
          // not a valid auth.  Something like http://foo.com/bar@baz/
          hasAuth = false;
          break;
        }
      }
      if (hasAuth) {
        // pluck off the auth portion.
        out.auth = rest.substr(0, atSign);
        rest = rest.substr(atSign + 1);
      }
    }

    var firstNonHost = -1;
    for (var i = 0, l = nonHostChars.length; i < l; i++) {
      var index = arrayIndexOf(rest, nonHostChars[i]);
      if (index !== -1 &&
          (firstNonHost < 0 || index < firstNonHost)) firstNonHost = index;
    }

    if (firstNonHost !== -1) {
      out.host = rest.substr(0, firstNonHost);
      rest = rest.substr(firstNonHost);
    } else {
      out.host = rest;
      rest = '';
    }

    // pull out port.
    var p = parseHost(out.host);
    var keys = objectKeys(p);
    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      out[key] = p[key];
    }

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    out.hostname = out.hostname || '';

    // validate a little.
    if (out.hostname.length > hostnameMaxLen) {
      out.hostname = '';
    } else {
      var hostparts = out.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            out.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    // hostnames are always lower case.
    out.hostname = out.hostname.toLowerCase();

    // IDNA Support: Returns a puny coded representation of "domain".
    // It only converts the part of the domain name that
    // has non ASCII characters. I.e. it dosent matter if
    // you call it with a domain that already is in ASCII.
    var domainArray = out.hostname.split('.');
    var newOut = [];
    for (var i = 0; i < domainArray.length; ++i) {
      var s = domainArray[i];
      newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
          'xn--' + punycode.encode(s) : s);
    }
    out.hostname = newOut.join('.');

    out.host = (out.hostname || '') +
        ((out.port) ? ':' + out.port : '');
    out.href += out.host;
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }

    // Now make sure that delims never appear in a url.
    var chop = rest.length;
    for (var i = 0, l = delims.length; i < l; i++) {
      var c = arrayIndexOf(rest, delims[i]);
      if (c !== -1) {
        chop = Math.min(c, chop);
      }
    }
    rest = rest.substr(0, chop);
  }


  // chop off from the tail first.
  var hash = arrayIndexOf(rest, '#');
  if (hash !== -1) {
    // got a fragment string.
    out.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = arrayIndexOf(rest, '?');
  if (qm !== -1) {
    out.search = rest.substr(qm);
    out.query = rest.substr(qm + 1);
    if (parseQueryString) {
      out.query = querystring.parse(out.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    out.search = '';
    out.query = {};
  }
  if (rest) out.pathname = rest;
  if (slashedProtocol[proto] &&
      out.hostname && !out.pathname) {
    out.pathname = '/';
  }

  //to support http.request
  if (out.pathname || out.search) {
    out.path = (out.pathname ? out.pathname : '') +
               (out.search ? out.search : '');
  }

  // finally, reconstruct the href based on what has been validated.
  out.href = urlFormat(out);
  return out;
}

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (typeof(obj) === 'string') obj = urlParse(obj);

  var auth = obj.auth || '';
  if (auth) {
    auth = auth.split('@').join('%40');
    for (var i = 0, l = nonAuthChars.length; i < l; i++) {
      var nAC = nonAuthChars[i];
      auth = auth.split(nAC).join(encodeURIComponent(nAC));
    }
    auth += '@';
  }

  var protocol = obj.protocol || '',
      host = (obj.host !== undefined) ? auth + obj.host :
          obj.hostname !== undefined ? (
              auth + obj.hostname +
              (obj.port ? ':' + obj.port : '')
          ) :
          false,
      pathname = obj.pathname || '',
      query = obj.query &&
              ((typeof obj.query === 'object' &&
                objectKeys(obj.query).length) ?
                 querystring.stringify(obj.query) :
                 '') || '',
      search = obj.search || (query && ('?' + query)) || '',
      hash = obj.hash || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (obj.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  return protocol + host + pathname + search + hash;
}

function urlResolve(source, relative) {
  return urlFormat(urlResolveObject(source, relative));
}

function urlResolveObject(source, relative) {
  if (!source) return relative;

  source = urlParse(urlFormat(source), false, true);
  relative = urlParse(urlFormat(relative), false, true);

  // hash is always overridden, no matter what.
  source.hash = relative.hash;

  if (relative.href === '') {
    source.href = urlFormat(source);
    return source;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    relative.protocol = source.protocol;
    //urlParse appends trailing / to urls like http:http://www.example.com
    if (slashedProtocol[relative.protocol] &&
        relative.hostname && !relative.pathname) {
      relative.path = relative.pathname = '/';
    }
    relative.href = urlFormat(relative);
    return relative;
  }

  if (relative.protocol && relative.protocol !== source.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      relative.href = urlFormat(relative);
      return relative;
    }
    source.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      relative.pathname = relPath.join('/');
    }
    source.pathname = relative.pathname;
    source.search = relative.search;
    source.query = relative.query;
    source.host = relative.host || '';
    source.auth = relative.auth;
    source.hostname = relative.hostname || relative.host;
    source.port = relative.port;
    //to support http.request
    if (source.pathname !== undefined || source.search !== undefined) {
      source.path = (source.pathname ? source.pathname : '') +
                    (source.search ? source.search : '');
    }
    source.slashes = source.slashes || relative.slashes;
    source.href = urlFormat(source);
    return source;
  }

  var isSourceAbs = (source.pathname && source.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host !== undefined ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (source.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = source.pathname && source.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = source.protocol &&
          !slashedProtocol[source.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // source.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {

    delete source.hostname;
    delete source.port;
    if (source.host) {
      if (srcPath[0] === '') srcPath[0] = source.host;
      else srcPath.unshift(source.host);
    }
    delete source.host;
    if (relative.protocol) {
      delete relative.hostname;
      delete relative.port;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      delete relative.host;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    source.host = (relative.host || relative.host === '') ?
                      relative.host : source.host;
    source.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : source.hostname;
    source.search = relative.search;
    source.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    source.search = relative.search;
    source.query = relative.query;
  } else if ('search' in relative) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      source.hostname = source.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = source.host && arrayIndexOf(source.host, '@') > 0 ?
                       source.host.split('@') : false;
      if (authInHost) {
        source.auth = authInHost.shift();
        source.host = source.hostname = authInHost.shift();
      }
    }
    source.search = relative.search;
    source.query = relative.query;
    //to support http.request
    if (source.pathname !== undefined || source.search !== undefined) {
      source.path = (source.pathname ? source.pathname : '') +
                    (source.search ? source.search : '');
    }
    source.href = urlFormat(source);
    return source;
  }
  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    delete source.pathname;
    //to support http.request
    if (!source.search) {
      source.path = '/' + source.search;
    } else {
      delete source.path;
    }
    source.href = urlFormat(source);
    return source;
  }
  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (source.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    source.hostname = source.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = source.host && arrayIndexOf(source.host, '@') > 0 ?
                     source.host.split('@') : false;
    if (authInHost) {
      source.auth = authInHost.shift();
      source.host = source.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (source.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  source.pathname = srcPath.join('/');
  //to support request.http
  if (source.pathname !== undefined || source.search !== undefined) {
    source.path = (source.pathname ? source.pathname : '') +
                  (source.search ? source.search : '');
  }
  source.auth = relative.auth || source.auth;
  source.slashes = source.slashes || relative.slashes;
  source.href = urlFormat(source);
  return source;
}

function parseHost(host) {
  var out = {};
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    out.port = port.substr(1);
    host = host.substr(0, host.length - port.length);
  }
  if (host) out.hostname = host;
  return out;
}

},{"querystring":55}],20:[function(require,module,exports){
var racer = require('racer')
  , domShim = require('dom-shim')
  , EventDispatcher = require('./EventDispatcher')
  , viewPath = require('./viewPath')
  , escapeHtml = require('html-util').escapeHtml
  , textOt = require('./textOt')
  , merge = racer.util.merge
  , markers = {}
  , markersDirty = true
  , globalElements = {
      $_win: window
    , $_doc: document
    }
  , addListener, removeListener;

module.exports = Dom;

function Dom(model) {
  var dom = this
  var fns = this.fns

  // Map dom event name -> true
  var listenerAdded = {};
  var captureListenerAdded = {}

  // DOM listener capturing allows blur and focus to be delegated
  // http:http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
  var captureEvents = this._captureEvents = new EventDispatcher({
    onTrigger: onCaptureTrigger
  , onBind: onCaptureBind
  });
  function onCaptureTrigger(name, listener, e) {
    var id = listener.id
      , el = document.getElementById(id);

    // Remove listener if element isn't found
    if (!el) return false;

    if (el.tagName === 'HTML' || el.contains(e.target)) {
      onDomTrigger(name, listener, id, e, el);
    }
  }
  function onCaptureBind(name, listener) {
    if (captureListenerAdded[name]) return;
    addListener(document, name, captureTrigger, true);
    captureListenerAdded[name] = true;
  }

  var events = this._events = new EventDispatcher({
    onTrigger: onDomTrigger
  , onBind: onDomBind
  });
  function onDomTrigger(name, listener, id, e, el, next) {
    var delay = listener.delay
      , finish = listener.fn;

    e.path = function(name) {
      if (!name) return model.__pathMap.paths[listener.pathId];
      return viewPath.ctxPath(listener.view, listener.ctx, name);
    };
    e.get = function(name) {
      var path = e.path(name);
      return viewPath.dataValue(listener.view, listener.ctx, model, path);
    };
    e.at = function(name) {
      return model.at(e.path(name));
    };

    if (!finish) {
      // Update the model when the element's value changes
      finish = function() {
        var value = dom.getMethods[listener.method](el, listener.property)
          , setValue = listener.setValue;

        // Allow the listener to override the setting function
        if (setValue) {
          setValue(model, value);
          return;
        }

        // Remove this listener if its path id is no longer registered
        var path = model.__pathMap.paths[listener.pathId];
        if (!path) return false;

        // Set the value if changed
        if (model.get(path) === value) return;

        var setterModel = model.pass({$e: e, $el: el});
        if (listener.method === 'propOt') {
          return textOt.onTextInput(setterModel, path, value);
        }
        setterModel.set(path, value);
      }
    }

    if (delay != null) {
      setTimeout(finish, delay, e, el, next, dom);
    } else {
      finish(e, el, next, dom);
    }
  }
  function onDomBind(name, listener, eventName) {
    if (listenerAdded[eventName]) return;
    addListener(document, eventName, triggerDom, true);
    listenerAdded[eventName] = true;
  }

  function triggerDom(e, el, noBubble, continued) {
    if (!el) el = e.target;
    var prefix = e.type + ':'
      , id;

    // Next can be called from a listener to continue bubbling
    function next() {
      triggerDom(e, el.parentNode, false, true);
    }
    next.firstTrigger = !continued;
    if (noBubble && (id = el.id)) {
      return events.trigger(prefix + id, id, e, el, next);
    }
    while (true) {
      while (!(id = el.id)) {
        if (!(el = el.parentNode)) return;
      }
      // Stop bubbling once the event is handled
      if (events.trigger(prefix + id, id, e, el, next)) return;
      if (!(el = el.parentNode)) return;
    }
  }

  function captureTrigger(e) {
    captureEvents.trigger(e.type, e);
  }

  this.trigger = triggerDom;
  this.captureTrigger = captureTrigger;

  this._listeners = [];
  this._components = [];
  this._pendingUpdates = [];

  function componentCleanup() {
    var components = dom._components
      , map = getMarkers()
      , i, component
    for (i = components.length; i--;) {
      component = components[i];
      if (component && !getMarker(map, component.scope)) {
        component.emit('destroy');
      }
    }
  }
  // TODO This 'cleanup' event is never emitted; deal with later
  // This cleanup listeners is placed at the beginning so that component
  // scopes are cleared before any ref cleanups are checked
  model.listeners('cleanup').unshift(componentCleanup);
}

Dom.prototype = {
  clear: domClear
, bind: domBind
, item: domItem
, marker: domMarker
, update: domUpdate
, addListener: domAddListener
, removeListener: domRemoveListener
, addComponent: addComponent
, _setDirty: setDirty

, getMethods: {
    attr: getAttr
  , prop: getProp
  , propOt: getPropOt
  , stringInsert: getPropOt
  , stringRemove: getPropOt
  , html: getHtml
    // These methods return NaN, because it never equals anything else. Thus,
    // when compared against the new value, the new value will always be set
  , insert: getNaN
  , remove: getNaN
  , move: getNaN
  }

, setMethods: {
    attr: setAttr
  , prop: setProp
  , propOt: setPropOt
  , stringInsert: setStringInsert
  , stringRemove: setStringRemove
  , html: setHtml
  , insert: setInsert
  , remove: setRemove
  , move: setMove
  }

, fns: {
    $forChildren: forChildren
  , $forName: forName
  }
}

function domClear() {
  this._events.clear();
  this._captureEvents.clear();
  var components = this._components
    , listeners = this._listeners
    , i, component
  for (i = listeners.length; i--;) {
    removeListener.apply(null, listeners[i]);
  }
  this._listeners = [];
  for (i = components.length; i--;) {
    component = components[i];
    component && component.emit('destroy');
  }
  this._components = [];
  markers = {};
}

function domListenerHash() {
  var out = {}
    , key
  for (key in this) {
    if (key === 'view' || key === 'ctx' || key === 'pathId') continue;
    out[key] = this[key];
  }
  return out;
}

function domBind(eventName, id, listener) {
  listener.toJSON = domListenerHash;
  if (listener.capture) {
    listener.id = id;
    this._captureEvents.bind(eventName, listener);
  } else {
    this._events.bind("" + eventName + ":" + id, listener, eventName);
  }
}

function domItem(id) {
  return document.getElementById(id) || globalElements[id] || getRange(id);
}

// HACK: Crappy interface. Should refactor marker getting to be a prototype
// method and make dirty a property of dom instance
function setDirty(value) {
  markersDirty = value;
}

function domUpdate(el, method, ignore, value, property, index, arg) {
  // Wrapped in a try / catch so that errors thrown on DOM updates don't
  // stop subsequent code from running
  try {
    // Don't do anything if the element is already up to date
    if (value === this.getMethods[method](el, property)) return;
    this.setMethods[method](el, ignore, value, property, index, arg);
    markersDirty = true;
  } catch (err) {
    setTimeout(function() {
      throw err;
    }, 0);
  }
}

function domAddListener(el, name, callback, captures) {
  this._listeners.push([el, name, callback, captures]);
  addListener(el, name, callback, captures);
}
function domRemoveListener(el, name, callback, captures) {
  removeListener(el, name, callback, captures);
}

function addComponent(ctx, component) {
  var components = this._components
    , dom = component.dom = Object.create(this);

  components.push(component);
  component.on('destroy', function() {
    var index = components.indexOf(component);
    if (index === -1) return;
    // The components array gets replaced on a dom.clear, so we allow
    // it to get sparse as individual components are destroyed
    delete components[index];
  });

  dom.addListener = function(el, name, callback, captures) {
    component.on('destroy', function() {
      removeListener(el, name, callback, captures);
    });
    addListener(el, name, callback, captures);
  };

  dom.element = function(name) {
    var id = ctx.$elements[name];
    return document.getElementById(id);
  };

  return dom;
}


function getAttr(el, attr) {
  return el.getAttribute && el.getAttribute(attr);
}
function getProp(el, prop) {
  return el[prop];
}
function getPropOt(el, prop) {
  // IE and Opera replace \n with \r\n
  var value = el[prop];
  return value && value.replace && value.replace(/\r\n/g, '\n');
}
function getHtml(el) {
  return el.innerHTML;
}
function getNaN() {
  return NaN;
}

function setAttr(el, ignore, value, attr) {
  el.setAttribute && el.setAttribute(attr, value);
}
function setProp(el, ignore, value, prop) {
  el[prop] = value;
}
function setPropOt(el, ignore, value, prop) {
  el[prop] = value;
}
function setStringInsert(el, ignore, value, prop, index, text) {
  var previous = getPropOt(el, prop);
  textOt.onStringInsert(el, previous, index, text);
}
function setStringRemove(el, ignore, value, prop, index, howMany) {
  var previous = getPropOt(el, prop);
  textOt.onStringRemove(el, previous, index, howMany);
}

function makeSVGFragment(fragment, svgElement) {
  // TODO: Allow optional namespace declarations
  var pre = '<svg xmlns=http:http://www.w3.org/2000/svg xmlns:xlink=http:http://www.w3.org/1999/xlink>' 
    , post = '</svg>'
    , range = document.createRange()
  range.selectNode(svgElement);
  return range.createContextualFragment(pre + fragment + post);
}
function appendSVG(element, fragment, svgElement) {
  var frag = makeSVGFragment(fragment, svgElement)
    , children = frag.childNodes[0].childNodes
    , i
  for (i = children.length; i--;) {
    element.appendChild(children[0]);
  }
}
function insertBeforeSVG(element, fragment, svgElement) {
  var frag = makeSVGFragment(fragment, svgElement)
    , children = frag.childNodes[0].childNodes
    , parent = element.parentNode
    , i
  for (i = children.length; i--;) {
    parent.insertBefore(children[0], element);
  }
}
function removeChildren(element) {
  var children = element.childNodes
    , i
  for (i = children.length; i--;) {
    element.removeChild(children[0]);
  }
}

function isSVG(obj) {
  return !!obj.ownerSVGElement || obj.tagName === "svg";
}
function svgRoot(obj) {
  return obj.ownerSVGElement || obj;
}
function isRange(obj) {
  return !!obj.cloneRange;
}

function setHtml(obj, ignore, value, escape) {
  if (escape) value = escapeHtml(value);
  if(isRange(obj)) {
    if(isSVG(obj.startContainer)) {
      // SVG Element
      obj.deleteContents();
      var svgElement = svgRoot(obj.startContainer);
      obj.insertNode(makeSVGFragment(value, svgElement));
      return;
    } else {
      // Range
      obj.deleteContents();
      obj.insertNode(obj.createContextualFragment(value));
      return;
    }
  }
  if (isSVG(obj)) {
    // SVG Element
    var svgElement = svgRoot(obj);
    removeChildren(obj);
    appendSVG(obj, value, svgElement);
    return;
  }
  // HTML Element
  if (ignore && obj.id === ignore) return;
  obj.innerHTML = value;
}
function setInsert(obj, ignore, value, escape, index) {
  if (escape) value = escapeHtml(value);
  if (obj.nodeType) {
    // Element
    if (ref = obj.childNodes[index]) {
      if (isSVG(obj)) {
        var svgElement = obj.ownerSVGElement || obj;
        insertBeforeSVG(ref, value, svgElement);
        return;
      }
      var range = document.createRange();
      range.selectNodeContents(obj);
      obj.insertBefore(range.createContextualFragment(value), ref);
    } else {
      if (isSVG(obj)) {
        var svgElement = obj.ownerSVGElement || obj;
        appendSVG(obj, value, svgElement);
        return;
      }
      var range = document.createRange();
      range.selectNodeContents(obj);
      obj.appendChild(range.createContextualFragment(value));
    }
  } else {
    // Range
    if (isSVG(obj.startContainer)) {
      var el = obj.startContainer
      , ref = el.childNodes[obj.startOffset + index];
      var svgElement = svgRoot(ref);
      el.insertBefore(makeSVGFragment(value, svgElement), ref)
    } else {
      var el = obj.startContainer
        , ref = el.childNodes[obj.startOffset + index];
      el.insertBefore(obj.createContextualFragment(value), ref);
    }
  }
}
function setRemove(el, ignore, index) {
  if (!el.nodeType) {
    // Range
    index += el.startOffset;
    el = el.startContainer;
  }
  var child = el.childNodes[index];
  if (child) el.removeChild(child);
}
function setMove(el, ignore, from, property, to, howMany) {
  var child, fragment, nextChild, offset, ref, toEl;
  if (!el.nodeType) {
    offset = el.startOffset;
    from += offset;
    to += offset;
    el = el.startContainer;
  }
  child = el.childNodes[from];

  // Don't move if the item at the destination is passed as the ignore
  // option, since this indicates the intended item was already moved
  // Also don't move if the child to move matches the ignore option
  if (!child || ignore && (toEl = el.childNodes[to]) &&
      toEl.id === ignore || child.id === ignore) return;

  ref = el.childNodes[to > from ? to + howMany : to];
  if (howMany > 1) {
    fragment = document.createDocumentFragment();
    while (howMany--) {
      nextChild = child.nextSibling;
      fragment.appendChild(child);
      if (!(child = nextChild)) break;
    }
    el.insertBefore(fragment, ref);
    return;
  }
  el.insertBefore(child, ref);
}

function forChildren(e, el, next, dom) {
  // Prevent infinte emission
  if (!next.firstTrigger) return;

  // Re-trigger the event on all child elements
  var children = el.childNodes;
  for (var i = 0, len = children.length, child; i < len; i++) {
    child = children[i];
    if (child.nodeType !== 1) continue;  // Node.ELEMENT_NODE
    dom.trigger(e, child, true, true);
    forChildren(e, child, next, dom);
  }
}

function forName(e, el, next, dom) {
  // Prevent infinte emission
  if (!next.firstTrigger) return;

  var name = el.getAttribute('name');
  if (!name) return;

  // Re-trigger the event on all other elements with
  // the same 'name' attribute
  var elements = document.getElementsByName(name)
    , len = elements.length;
  if (!(len > 1)) return;
  for (var i = 0, element; i < len; i++) {
    element = elements[i];
    if (element === el) continue;
    dom.trigger(e, element, false, true);
  }
}

function getMarkers() {
  var map = {};
  // NodeFilter.SHOW_COMMENT == 128
  var commentIterator = document.createTreeWalker(document, 128, null, false);
  var comment;
  while (comment = commentIterator.nextNode()) {
    map[comment.data] = comment;
  }
  return map;
}

function getMarker(map, name) {
  var marker = map[name];
  if (!marker) return;

  // Comment nodes may continue to exist even if they have been removed from
  // the page. Thus, make sure they are still somewhere in the page body
  if (!document.contains(marker)) {
    delete map[name];
    return;
  }
  return marker;
}

function domMarker(name) {
  var marker = getMarker(markers, name);
  if (!marker && markersDirty) {
    markers = getMarkers();
    markersDirty = false;
    marker = getMarker(markers, name);
  }
  return marker;
}

function getRange(name) {
  var start = domMarker(name);
  if (!start) return;
  var end = domMarker('$' + name);
  if (!end) return;

  var range = document.createRange();
  range.setStartAfter(start);
  range.setEndBefore(end);
  return range;
}

if (document.addEventListener) {
  addListener = function(el, name, callback, captures) {
    el.addEventListener(name, callback, captures || false);
  };
  removeListener = function(el, name, callback, captures) {
    el.removeEventListener(name, callback, captures || false);
  };
}

},{"racer":"eS5xJL","./EventDispatcher":27,"./viewPath":56,"./textOt":44,"html-util":48,"dom-shim":57}],54:[function(require,module,exports){
var defaultFns = module.exports = new DefaultFns;

defaultFns.reverse = new FnPair(getReverse, setReverse);
defaultFns.asc = asc;
defaultFns.desc = desc;

function DefaultFns() {}
function FnPair(get, set) {
  this.get = get;
  this.set = set;
}

function getReverse(array) {
  return array && array.slice().reverse();
}
function setReverse(values) {
  return {0: getReverse(values)};
}

function asc(a, b) {
  if (a < b) return -1;
  if (a > b) return 1;
  return 0;
}
function desc(a, b) {
  if (a > b) return -1;
  if (a < b) return 1;
  return 0;
}

},{}],25:[function(require,module,exports){
(function(global){var htmlUtil = require('html-util')
var md5 = require('MD5')
var parseHtml = htmlUtil.parse
var trimText = htmlUtil.trimText
var unescapeEntities = htmlUtil.unescapeEntities
var escapeHtml = htmlUtil.escapeHtml
var escapeAttribute = htmlUtil.escapeAttribute
var isVoid = htmlUtil.isVoid
var conditionalComment = htmlUtil.conditionalComment
var markup = require('./markup')
var viewPath = require('./viewPath')
var wrapRemainder = viewPath.wrapRemainder
var ctxPath = viewPath.ctxPath
var extractPlaceholder = viewPath.extractPlaceholder
var dataValue = viewPath.dataValue
var pathFnArgs = viewPath.pathFnArgs
var isBound = viewPath.isBound
var eventBinding = require('./eventBinding')
var splitEvents = eventBinding.splitEvents
var fnListener = eventBinding.fnListener
var derby = require('./derby')

module.exports = View;

function empty() {
  return '';
}

var defaultCtx = {
  $aliases: {}
, $paths: []
, $indices: []
};

var CAMEL_REGEXP = /([a-z])([A-Z])/g;

var defaultGetFns = {
  equal: function getEqual(a, b) {
    return a === b;
  }
, not: function getNot(value) {
    return !value;
  }
, or: function getOr() {
    for (var i = 0; i < arguments.length; i++) {
      var arg = arguments[i];
      if (arg) return arg;
    };
    return arg;
  }
, and: function getAnd() {
    for (var i = 0; i < arguments.length; i++) {
      var arg = arguments[i];
      if (!arg) return arg;
    };
    return arg;
  }
, gt: function getGt(a, b) {
    return a > b;
  }
, lt: function getLt(a, b) {
    return a < b;
  }
, gte: function getGte(a, b) {
    return a >= b;
  }
, lte: function getLte(a, b) {
    return a <= b;
  }
, dash: function getDash(value) {
    return value && value
      .replace(/[:_\s]/g, '-')
      .replace(CAMEL_REGEXP, '$1-$2')
      .toLowerCase()
  }
, join: function getJoin(items, property, separator) {
    var list, i;
    if (!items) return;
    if (property) {
      list = [];
      for (i = items.length; i--;) {
        list[i] = items[i][property];
      }
    } else {
      list = items;
    }
    return list.join(separator || ', ');
  }
, log: function getLog() {
    console.log.apply(console, arguments);
  }
, trace: function getTrace() {
    console.trace();
  }
, debugger: function getDebugger() {
    debugger;
  }
, path: function getPath(name) {
    return ctxPath(this.view, this.ctx, name);
  }
, noop: function noop() {}
, lookup: viewPath.lookup
};

var defaultSetFns = {
  equal: function setEqual(value, a, b) {
    return value && [b];
  }
, not: function setNot(value) {
    return [!value];
  }
};

function View(libraries, app, appFilename) {
  this._libraries = libraries || [];
  this.app = app || {};
  this._appFilename = appFilename;
  this._inline = '';
  this.clear();
  this.getFns = derby.util.copyObject(defaultGetFns);
  this.setFns = derby.util.copyObject(defaultSetFns);
  if (this._init) this._init();
  this._idCount = 0;
  this._uncreated = [];
}
View.prototype = {
  defaultViews: {
    doctype: function() {
      return '<!DOCTYPE html>';
    }
  , root: empty
  , charset: function() {
      return '<meta charset=utf-8>';
    }
  , title$s: empty
  , head: empty
  , header: empty
  , body: empty
  , footer: empty
  , scripts: empty
  , tail: empty
  }

, _selfNs: 'app'

  // All automatically created ids start with a dollar sign
  // TODO: change this since it messes up query selectors unless escaped
, _uniqueId: uniqueId

, clear: clear
, _resetForRender: resetForRender
, make: make
, _makeAll: makeAll
, _makeComponents: makeComponents
, _findView: findView
, _find: find
, get: get
, fn: fn
, render: render
, componentsByName: componentsByName
, _componentConstructor: componentConstructor
, _flushUncreated: flushUncreated
, _beforeRender: beforeRender
, _afterRender: afterRender
, _beforeRoute: beforeRoute

, inline: empty

, escapeHtml: escapeHtml
, escapeAttribute: escapeAttribute
}

View.valueBinding = valueBinding;

function clear() {
  this._views = derby.util.copyObject(this.defaultViews);
  this._renders = {};
  this._resetForRender();
}

function resetForRender(model, componentInstances) {
  componentInstances || (componentInstances = {});
  if (model) this.model = model;
  this._componentInstances = componentInstances;
  var libraries = this._libraries
    , i
  for (i = libraries.length; i--;) {
    libraries[i].view._resetForRender(model, componentInstances);
  }
}

function componentsByName(name) {
  return this._componentInstances[name] || [];
}

function componentConstructor(name) {
  return this._selfLibrary && this._selfLibrary.constructors[name];
}

function uniqueId() {
  return '$' + (this._idCount++).toString(36);
}

function make(name, template, options, templatePath) {
  var view = this
    , isString = options && options.literal
    , noMinify = isString
    , onBind, renderer, render, matchTitle;

  if (templatePath && (render = this._renders[templatePath])) {
    this._views[name] = render;
    return
  }

  name = name.toLowerCase();
  matchTitle = /(?:^|\:)title(\$s)?$/.exec(name);
  if (matchTitle) {
    isString = !!matchTitle[1];
    if (isString) {
      onBind = function(events, name) {
        return bindEvents(events, name, render, ['$_doc', 'prop', 'title']);
      };
    } else {
      this.make(name + '$s', template, options, templatePath);
    }
  }

  render = function(ctx, model, triggerId) {
    if (!renderer) {
      renderer = parse(view, name, template, isString, onBind, noMinify);
    }
    return renderer(ctx, model, triggerId);
  }

  render.nonvoid = options && options.nonvoid;

  this._views[name] = render;
  if (templatePath) this._renders[templatePath] = render;
}

function makeAll(templates, instances) {
  var name, instance, options, templatePath;
  if (!instances) return;
  this.clear();
  for (name in instances) {
    instance = instances[name];
    templatePath = instance[0];
    options = instance[1];
    this.make(name, templates[templatePath], options, templatePath);
  }
}

function makeComponents(components) {
  var librariesMap = this._libraries.map
    , name, component, library;
  for (name in components) {
    component = components[name];
    library = librariesMap[name];
    library && library.view._makeAll(component.templates, component.instances);
  }
}

function findView(name, ns) {
  var items = this._views
    , item, i, segments, testNs;
  name = name.toLowerCase();
  if (ns) {
    ns = ns.toLowerCase();
    item = items[ns + ':' + name];
    if (item) return item;

    segments = ns.split(':');
    for (i = segments.length; i-- > 1;) {
      testNs = segments.slice(0, i).join(':');
      item = items[testNs + ':' + name];
      if (item) return item;
    }
  }
  return items[name];
}

function find(name, ns, optional) {
  var view = this._findView(name, ns);
  if (view) return view;
  if (optional) return empty;
  if (ns) name = ns + ':' + name;
  throw new Error("Can't find template: \n  " + name + '\n\n' +
    'Available templates: \n  ' + Object.keys(this._views).join('\n  ')
  );
}

function get(name, ns, ctx) {
  if (typeof ns === 'object') {
    ctx = ns;
    ns = '';
  }
  ctx = ctx ? extend(ctx, defaultCtx) : derby.util.copyObject(defaultCtx);
  this.app.model = this.model;
  ctx.$fnCtx = [this.app];
  ctx.$pathIds = {};
  return this._find(name, ns)(ctx);
}

function fn(name, value) {
  if (typeof name === 'object') {
    for (var k in name) {
      this.fn(k, name[k]);
    }
    return;
  }
  var get, set;
  if (typeof value === 'object') {
    get = value.get;
    set = value.set;
  } else {
    get = value;
  }
  this.getFns[name] = get;
  if (set) this.setFns[name] = set;
}

function emitRender(view, ns, ctx, name) {
  if (view.isServer) return;
  view.app.emit(name, ctx);
  if (ns) view.app.emit(name + ':' + ns, ctx);
}
function beforeRender(model, ns, ctx) {
  ctx = (ctx && Object.create(ctx)) || {};
  ctx.$ns = ns;
  emitRender(this, ns, ctx, 'pre:render');
  return ctx;
}
function afterRender(ns, ctx) {
  emitRender(this, ns, ctx, 'render');
}
function beforeRoute() {
  this.app.dom.clear();
  // Remove all data, refs, listeners, and reactive functions
  // for the previous page
  var silentModel = this.model.silent();
  silentModel.destroy('_page');
  silentModel.destroy('$components');
  // Unfetch and unsubscribe from all queries and documents
  silentModel.unload();
  var lastRender = this._lastRender;
  if (!lastRender) return;
  emitRender(this, lastRender.ns, lastRender.ctx, 'replace');
}

function render(model, ns, ctx, renderHash) {
  if (typeof ns === 'object') {
    renderHash = ctx;
    ctx = ns;
    ns = '';
  }
  this.model = model;

  if (!ctx.$isServer) ctx = this._beforeRender(model, ns, ctx);
  this._lastRender = {
    ns: ns
  , ctx: ctx
  };

  this._resetForRender();
  model.__pathMap.clear();
  model.__events.clear();
  model.__blockPaths = {};
  this.app.dom.clear();
  model.silent().destroy('$components');

  var title = this.get('title$s', ns, ctx)
    , headHtml = this.get('head', ns, ctx)
    , rootHtml = this.get('root', ns, ctx)
    , bodyHtml = this.get('header', ns, ctx) +
        this.get('body', ns, ctx) +
        this.get('footer', ns, ctx)
    , doc = window.document
    , err

  if (renderHash) {
    // Check hashes in development to help find rendering bugs
    if (renderHash === md5(bodyHtml)) {
      this._flushUncreated();
      return;
    }
    err = new Error('Server and client page renders do not match');
    setTimeout(function() {
      throw err;
    }, 0);
  } else if (ctx.$isServer) {
    // Don't finish rendering client side on the very first load, since
    // the page should already have the same HTML from the server
    this._flushUncreated();
    return;
  }

  var documentElement = doc.documentElement
    , attrs = documentElement.attributes
    , i, attr, fakeRoot, body;

  // Remove all current attributes on the documentElement and replace
  // them with the attributes in the rendered rootHtml
  for (i = attrs.length; i--;) {
    attr = attrs[i];
    documentElement.removeAttribute(attr.name);
  }
  // Using the DOM to get the attributes on an <html> tag would require
  // some sort of iframe hack until DOMParser has better browser support.
  // String parsing the html should be simpler and more efficient
  parseHtml(rootHtml, {
    start: function(tag, tagName, attrs) {
      if (tagName !== 'html') return;
      for (var attr in attrs) {
        documentElement.setAttribute(attr, attrs[attr]);
      }
    }
  });

  fakeRoot = doc.createElement('html');
  fakeRoot.innerHTML = bodyHtml;
  body = fakeRoot.getElementsByTagName('body')[0];
  documentElement.replaceChild(body, doc.body);
  doc.title = title;

  this.app.dom._setDirty(true);
  this._flushUncreated();
  this._afterRender(ns, ctx);
}


function extend(parent, obj) {
  var out = Object.create(parent)
    , key;
  if (typeof obj !== 'object' || Array.isArray(obj)) {
    return out;
  }
  for (key in obj) {
    out[key] = obj[key];
  }
  return out;
}

function modelListener(params, triggerId, blockPaths, pathId, partial, ctx, saveBlockPath) {
  var listener = typeof params === 'function'
    ? params(triggerId, blockPaths, saveBlockPath && pathId)
    : params;
  listener.partial = partial;
  listener.ctx = ctx.$stringCtx || ctx;
  return listener;
}

function bindPathEvent(events, bindName, getName, partial, params, saveBlockPath) {
  events.push(function(ctx, modelEvents, dom, pathMap, view, blockPaths, triggerId) {
    var path = ctxPath(view, ctx, bindName)
    if (!path) return;
    var pathId = pathMap.id(path);
    var listener = modelListener(params, triggerId, blockPaths, pathId, partial, ctx, saveBlockPath);
    if (bindName !== getName) {
      listener.getValue = function(model) {
        return dataValue(view, ctx, model, getName);
      };
    }
    modelEvents.bind(pathId, listener);
  });
}
function bindEachPathEvent(events, name, getName, partial, params) {
  var bracketIndex = name.indexOf('[');
  if (~bracketIndex) {
    // Bind to each of the items inside brackets
    var paths = viewPath.squareBracketsArgs(name);
    for (var i = paths.length; i--;) {
      bindEachPathEvent(events, paths[i], getName, partial, params);
    }
    // Bind to anything under the root. This ins't very efficent, but it
    // should cover various cases that would require updating the bindings
    // when the arguments inside of the brackets change, which I don't feel
    // like figuring out at the moment
    var before = name.slice(0, bracketIndex);
    if (before) bindEachPathEvent(events, before + '*', getName, partial, params);
    return;
  }
  var match = /(\.*)(.*)/.exec(name);
  var prefix = match[1] || '';
  var relativeName = match[2] || '';
  var segments = relativeName.split('.');
  // This loop stops before reaching zero
  var saveBlockPath = true;
  for (var i = segments.length; i; i--) {
    var bindName = prefix + segments.slice(0, i).join('.');
    bindPathEvent(events, bindName, getName, partial, params, saveBlockPath);
    saveBlockPath = false;
  }
}
function bindEvents(events, name, partial, params) {
  if (~name.indexOf('(')) {
    var args = pathFnArgs(name);
    for (var i = args.length; i--;) {
      bindEachPathEvent(events, args[i] + '*', name, partial, params);
    }
    return;
  }
  bindEachPathEvent(events, name, name, partial, params);
}

function bindEventsById(events, name, partial, attrs, method, prop, blockType) {
  function params(triggerId, blockPaths, pathId) {
    var id = attrs._id || attrs.id;
    if (blockType && pathId) {
      blockPaths[id] = {id: pathId, type: blockType};
    }
    return [id, method, prop];
  }
  bindEvents(events, name, partial, params);
}

function bindEventsByIdString(events, name, partial, attrs, method, prop) {
  function params(triggerId) {
    var id = triggerId || attrs._id || attrs.id;
    return [id, method, prop];
  }
  bindEvents(events, name, partial, params);
}

function addId(view, attrs) {
  if (attrs.id == null) {
    attrs.id = function() {
      return attrs._id = view._uniqueId();
    };
  }
}

function pushValue(html, i, value, isAttr) {
  if (typeof value === 'function') {
    i = html.push(value, '') - 1;
  } else {
    html[i] += isAttr ? escapeAttribute(value) : value;
  }
  return i;
}

function reduceStack(stack) {
  var html = ['']
    , i = 0
    , attrs, bool, item, key, value, j, len;

  for (j = 0, len = stack.length; j < len; j++) {
    item = stack[j];
    switch (item[0]) {
      case 'start':
        html[i] += '<' + item[1];
        attrs = item[2];
        // Make sure that the id attribute is rendered first
        if ('id' in attrs) {
          html[i] += ' id=';
          i = pushValue(html, i, attrs.id, true);
        }
        for (key in attrs) {
          if (key === 'id') continue;
          value = attrs[key];
          if (value != null) {
            if (bool = value.bool) {
              i = pushValue(html, i, bool);
              continue;
            }
            html[i] += ' ' + key + '=';
            i = pushValue(html, i, value, true);
          } else {
            html[i] += ' ' + key;
          }
        }
        html[i] += '>';
        break;
      case 'text':
        i = pushValue(html, i, item[1]);
        break;
      case 'end':
        html[i] += '</' + item[1] + '>';
        break;
      case 'marker':
        html[i] += '<!--' + item[1];
        i = pushValue(html, i, item[2].id);
        html[i] += '-->';
    }
  }
  return html;
}

function renderer(view, items, events, onRender) {
  return function(ctx, model, triggerId) {
    if (!model) model = view.model;  // Needed, since model parameter is optional

    if (onRender) ctx = onRender(ctx);

    var html = '';
    for (var i = 0, len = items.length; i < len; i++) {
      item = items[i];
      html += (typeof item === 'function') ? item(ctx, model) || '' : item;
    }
    if (view.isServer) return html;

    var pathMap = model.__pathMap;
    var modelEvents = model.__events;
    var blockPaths = model.__blockPaths;
    var dom = global.DERBY && global.DERBY.app.dom;
    // Note that the events array can grow during rendering
    var i = 0;
    var event;
    while (event = events[i++]) {
      event(ctx, modelEvents, dom, pathMap, view, blockPaths, triggerId);
    }
    return html;
  }
}

function bindComponentEvent(component, name, listener) {
  if (name === 'init' || name === 'create') {
    component.once(name, listener.fn);
  } else {
    // Extra indirection allows listener to overwrite itself after first run
    component.on(name, function() {
      listener.fn.apply(null, arguments);
    });
  }
}
function bindComponentEvents(ctx, component, events) {
  var view = events.$view
    , items = events.$events
    , listenerCtx = Object.create(ctx)
    , i, item, name, listener
  // The fnCtx will include this component, but we want to emit
  // on the parent component or app
  listenerCtx.$fnCtx = listenerCtx.$fnCtx.slice(0, -1);
  for (i = items.length; i--;) {
    item = items[i];
    name = item[0];
    listener = fnListener(view, listenerCtx, item[2]);
    bindComponentEvent(component, name, listener);
  }
}

function createComponent(view, model, Component, scope, ctx, macroCtx) {
  var scoped = model.scope(scope);
  var marker = '<!--' + scope + '-->';
  var prefix = scope + '.';
  var component = new Component(scoped, scope);
  var parentFnCtx = model.__fnCtx || ctx.$fnCtx;
  var silentCtx = Object.create(ctx);
  silentCtx.$silent = true;
  var silentModel = model.silent();
  var i, key, path, value, instanceName, instances;

  ctx.$fnCtx = model.__fnCtx = parentFnCtx.concat(component);

  // HACK: Ensure that scoped model has something set
  scoped.set('$null', null);

  for (key in macroCtx) {
    value = macroCtx[key];
    if (key === 'bind') {
      bindComponentEvents(ctx, component, value);
      continue;
    }
    if (value && value.$matchName) {
      path = ctxPath(view, ctx, value.$matchName);
      if (value.$bound) {
        silentModel.ref(prefix + key, path, {updateIndices: true});
        continue;
      }
      value = dataValue(view, ctx, model, path);
      silentModel.set(prefix + key, value);
      continue;
    }
    // TODO: Figure out how to get value of templatized attributes
    if (typeof value === 'function') continue;
    silentModel.set(prefix + key, value);
  }

  instanceName = scoped.get('name');
  if (instanceName) {
    instances = view._componentInstances[instanceName] ||
      (view._componentInstances[instanceName] = []);
    instances.push(component);
  }

  if (component.init) component.init(scoped);
  component.emit('init', component);

  if (view.isServer || ctx.$silent) return marker;

  var app = global.DERBY && global.DERBY.app
    , dom = app.dom
  component.dom = dom;
  component.history = app.history;

  var uncreated = new UncreatedComponent(component, scoped, dom, scope, ctx);
  view._uncreated.push(uncreated);

  return marker;
}

function UncreatedComponent(component, model, dom, scope, ctx) {
  this.component = component;
  this.model = model;
  this.dom = dom;
  this.scope = scope;
  this.ctx = ctx;
}
UncreatedComponent.prototype.create = function() {
  // TODO: Figure out underlying issue and remove
  // If for some reason, component's scoped model does not have any data,
  // do nothing. Not sure why it would get to this state, but it does.
  if (!this.model.get()) return;

  // Destroy in case component was created and replaced within rendering
  if (!this.dom.marker(this.scope)) {
    this.component.emit('destroy');
    return;
  }

  this.dom.addComponent(this.ctx, this.component);
  if (this.component.create) this.component.create(this.model, this.component.dom);
  this.component.emit('create', this.component);
};

function flushUncreated() {
  var uncreated;
  while (uncreated = this._uncreated.shift()) {
    uncreated.create();
  }
};

function extendCtx(view, ctx, value, name, alias, isEach) {
  var path = ctxPath(view, ctx, name)
    , aliases;
  ctx = extend(ctx, value);
  ctx['this'] = value;
  if (alias) {
    aliases = ctx.$aliases = Object.create(ctx.$aliases);
    aliases[alias] = ctx.$paths.length;
    if (isEach) aliases[alias]++;
  }
  if (path) {
    ctx.$paths = [path].concat(ctx.$paths);
  }
  ctx.$pathIds = Object.create(ctx.$pathIds);
  return ctx;
}

function partialValue(view, ctx, model, name, value, listener) {
  if (listener) return value;
  return name ? dataValue(view, ctx, model, name) : true;
}

function partialFn(view, name, type, alias, render, ns, macroCtx) {
  function partialBlock (ctx, model, triggerId, value, index, listener) {
    // Inherit & render attribute context values
    var renderMacroCtx = {}
      , parentMacroCtx = ctx.$macroCtx
      , mergedMacroCtx = macroCtx
      , key, val, matchName
    if (macroCtx.inherit) {
      mergedMacroCtx = {};
      derby.util.mergeInto(mergedMacroCtx, parentMacroCtx);
      derby.util.mergeInto(mergedMacroCtx, macroCtx);
      delete mergedMacroCtx.inherit;
    }
    for (key in mergedMacroCtx) {
      val = mergedMacroCtx[key];
      if (val && val.$matchName) {
        matchName = ctxPath(view, ctx, val.$matchName);
        if (matchName.charAt(0) === '@') {
          val = dataValue(view, ctx, model, matchName);
        } else {
          val = derby.util.copyObject(val);
          val.$matchName = matchName;
        }
      }
      renderMacroCtx[key] = val;
    }

    // Find the appropriate partial template
    var partialNs, partialName, partialOptional, arr;
    if (name === 'derby:view') {
      partialNs = mergedMacroCtx.ns || view._selfNs;
      partialName = mergedMacroCtx.view;
      partialOptional = mergedMacroCtx.optional;
      if (!partialName) throw new Error('<derby:view> tag without a "view" attribute')
      if (partialNs.$matchName) {
        partialNs = dataValue(view, ctx, model, partialNs.$matchName);
      }
      if (partialName.$matchName) {
        partialName = dataValue(view, ctx, model, partialName.$matchName);
      }
    } else {
      arr = splitPartial(name);
      partialNs = arr[0];
      partialName = arr[1];
    }
    // This can happen when using <derby:view view={{...}}>
    if (typeof partialName === 'function') {
      partialName = partialName(Object.create(ctx), model);
    }
    var partialView = nsView(view, partialNs)
      , render = partialView._find(partialName, ns, partialOptional)
      , Component = partialView._componentConstructor(partialName)
      , renderCtx, scope, out, marker

    // Prepare the context for rendering
    if (Component) {
      scope = '$components.' + view._uniqueId();
      renderCtx = extendCtx(view, ctx, null, scope, 'self');
      renderCtx.$elements = {};
      marker = createComponent(view, model, Component, scope, renderCtx, renderMacroCtx);
    } else {
      renderCtx = Object.create(ctx);
    }
    renderCtx.$macroCtx = renderMacroCtx;

    out = render(renderCtx, model);
    if (Component) {
      if (model.__fnCtx) {
        model.__fnCtx = model.__fnCtx.slice(0, -1);
      }
      out = marker + out;
    }
    return out;
  }

  function withBlock(ctx, model, triggerId, value, index, listener) {
    value = partialValue(view, ctx, model, name, value, listener);
    var renderCtx = extendCtx(view, ctx, value, name, alias);
    return render(renderCtx, model);
  }

  function ifBlock(ctx, model, triggerId, value, index, listener) {
    value = partialValue(view, ctx, model, name, value, listener);
    if (!(Array.isArray(value) ? value.length : value)) return;
    var renderCtx = extendCtx(view, ctx, value, name, alias);
    return render(renderCtx, model);
  }

  function unlessBlock(ctx, model, triggerId, value, index, listener) {
    value = partialValue(view, ctx, model, name, value, listener);
    if (Array.isArray(value) ? value.length : value) return;
    var renderCtx = extendCtx(view, ctx, value, name, alias);
    return render(renderCtx, model);
  }

  function eachBlock(ctx, model, triggerId, value, index, listener) {
    value = partialValue(view, ctx, model, name, value, listener);
    var isArray = Array.isArray(value);

    if (listener && !isArray) {
      if (value === void 0) return;
      var listCtx = extendCtx(view, ctx, null, name, alias, true);
      var itemPath = listCtx.$paths[0] + '.' + index;
      var item = partialValue(view, listCtx, model, itemPath, value, listener);
      renderCtx = extend(listCtx, item);
      renderCtx['this'] = item;
      renderCtx.$indices = [index].concat(renderCtx.$indices);
      renderCtx.$index = index;
      renderCtx.$paths = [itemPath].concat(renderCtx.$paths);
      return render(renderCtx, model);
    }

    if (!isArray || !value.length) return;

    var listCtx = extendCtx(view, ctx, null, name, alias, true);

    var out = '';
    var indices = listCtx.$indices;
    var paths = listCtx.$paths;
    var basePath = paths[0];
    for (var i = 0, len = value.length; i < len; i++) {
      var item = value[i];
      var renderCtx = extend(listCtx, item);
      renderCtx['this'] = item;
      renderCtx.$indices = [i].concat(indices);
      renderCtx.$index = i;
      renderCtx.$paths = [basePath + '.' + i].concat(paths);
      out += (item === void 0) ?
        '<!--empty-->' :
        render(renderCtx, model);
    }
    return out;
  }

  var block =
      (type === 'partial') ? partialBlock
    : (type === 'with' || type === 'else') ? withBlock
    : (type === 'if' || type === 'else if') ? ifBlock
    : (type === 'unless') ? unlessBlock
    : (type === 'each') ? eachBlock
    : null

  if (!block) throw new Error('Unknown block type: ' + type);
  block.type = type;
  return block;
}

var objectToString = Object.prototype.toString;
var arrayToString = Array.prototype.toString;

function valueBinding(value) {
  return value == null ? '' :
    (value.toString === objectToString || value.toString === arrayToString) ?
    JSON.stringify(value) : value;
}

function valueText(value) {
  return valueBinding(value).toString();
}

function textFn(view, name, escape, force) {
  var filter = escape ? function(value) {
    return escape(valueText(value));
  } : valueText;
  return function(ctx, model) {
    return dataValue(view, ctx, model, name, filter, force);
  }
}

function sectionFn(view, queue) {
  var render = renderer(view, reduceStack(queue.stack), queue.events);
  var block = queue.block;
  return partialFn(view, block.name, block.type, block.alias, render);
}

function blockFn(view, sections) {
  var len = sections.length;
  if (!len) return;
  if (len === 1) {
    return sectionFn(view, sections[0]);

  } else {
    var fns = []
      , i, out;
    for (i = 0; i < len; i++) {
      fns.push(sectionFn(view, sections[i]));
    }
    out = function(ctx, model, triggerId, value, index, listener) {
      var out;
      for (i = 0; i < len; i++) {
        out = fns[i](ctx, model, triggerId, value, index, listener);
        if (out != null) return out;
      }
    }
    return out;
  }
}

function parseMarkup(type, attr, tagName, events, attrs, value) {
  var parser = markup[type][attr]
    , anyOut, anyParser, elOut, elParser, out;
  if (!parser) return;
  if (anyParser = parser['*']) {
    anyOut = anyParser(events, attrs, value);
  }
  if (elParser = parser[tagName]) {
    elOut = elParser(events, attrs, value);
  }
  out = anyOut ? extend(anyOut, elOut) : elOut;
  if (out && out.del) delete attrs[attr];
  return out;
}

function pushText(stack, text) {
  if (text) stack.push(['text', text]);
}

function pushVarFn(view, stack, fn, name, escapeFn) {
  if (fn) {
    pushText(stack, fn);
  } else {
    pushText(stack, textFn(view, name, escapeFn));
  }
}

function isPartial(view, tagName) {
  if (tagName === 'derby:view') return true;
  var split = splitPartial(tagName);
  if (!split) return false;
  var tagNs = split[0];
  return (
    tagNs === 'app' ||
    tagNs === 'lib' ||
    !!libraryForNs(view, tagNs)
  );
}

function isPartialSection(tagName) {
  return tagName.charAt(0) === '@';
}

function partialSectionName(tagName) {
  return isPartialSection(tagName) ? tagName.slice(1) : null;
}

function libraryForNs(view, ns) {
  var library = view._libraries.map[ns];
  if (library) return library;
  if (view.parent) return view.parent.view._libraries.map[ns];
}

function nsView(view, ns) {
  if (ns === view._selfNs) return view;
  if (view.parent && ns === view.parent.view._selfNs) return view.parent.view;
  var library = libraryForNs(view, ns);
  if (!library) throw new Error('No library found with namespace ' + ns);
  var partialView = library.view;
  partialView._uniqueId = function() {
    return view._uniqueId();
  };
  partialView.model = view.model;
  partialView._uncreated = view._uncreated;
  return partialView;
}

function splitPartial(partial) {
  var i = partial.indexOf(':');
  if (i === -1) return;
  var partialNs = partial.slice(0, i);
  var partialName = partial.slice(i + 1);
  return [partialNs, partialName];
}

function findComponent(view, partial, ns) {
  var arr = splitPartial(partial)
    , partialNs = arr[0]
    , partialName = arr[1]
    , partialView = nsView(view, partialNs)
  return partialView._find(partialName, ns);
}

function isVoidComponent(view, partial, ns) {
  if (partial === 'derby:view') return true;
  return !findComponent(view, partial, ns).nonvoid;
}

function pushVar(view, ns, stack, events, remainder, match, fn) {
  var name = match.name
    , partial = match.partial
    , escapeFn = match.escaped && escapeHtml
    , attr, attrs, boundOut, last, tagName, wrap;

  if (partial) {
    fn = partialFn(view, partial, 'partial', null, null, ns, match.macroCtx);
  }

  else if (match.bound) {
    last = lastItem(stack);
    wrap = match.pre ||
      !last ||
      (last[0] !== 'start') ||
      isVoid(tagName = last[1]) ||
      wrapRemainder(tagName, remainder);

    if (wrap) {
      stack.push(['marker', '', attrs = {}]);
    } else {
      attrs = last[2];
      for (attr in attrs) {
        parseMarkup('boundParent', attr, tagName, events, attrs, match);
      }
      boundOut = parseMarkup('boundParent', '*', tagName, events, attrs, match);
      if (boundOut) {
        bindEventsById(events, name, null, attrs, boundOut.method, boundOut.property);
      }
    }
    addId(view, attrs);

    if (!boundOut) {
      bindEventsById(events, name, fn, attrs, 'html', !fn && escapeFn, match.type);
    }
  }

  pushVarFn(view, stack, fn, name, escapeFn);
  if (wrap) {
    stack.push([
      'marker'
    , '$'
    , { id: function() { return attrs._id } }
    ]);
  }
}

function pushVarString(view, ns, stack, events, remainder, match, fn) {
  var name = match.name
    , escapeFn = !match.escaped && unescapeEntities;
  function bindOnce(ctx) {
    ctx.$onBind(events, name);
    bindOnce = empty;
  }
  if (match.bound) {
    events.push(function(ctx) {
      bindOnce(ctx);
    });
  }
  pushVarFn(view, stack, fn, name, escapeFn);
}

function parseMatchError(text, message) {
  throw new Error(message + '\n\n' + text + '\n');
}

function onBlock(start, end, block, queues, callbacks) {
  var lastQueue, queue;
  if (end) {
    lastQueue = queues.pop();
    queue = lastItem(queues);
    queue.sections.push(lastQueue);
  } else {
    queue = lastItem(queues);
  }

  if (start) {
    queue = {
      stack: []
    , events: []
    , block: block
    , sections: []
    };
    queues.push(queue);
    callbacks.onStart(queue);
  } else {
    if (end) {
      callbacks.onStart(queue);
      callbacks.onEnd(queue.sections);
      queue.sections = [];
    } else {
      callbacks.onContent(block);
    }
  }
}

function parseMatch(text, match, queues, callbacks) {
  var hash = match.hash
    , type = match.type
    , name = match.name
    , block = lastItem(queues).block
    , blockType = block && block.type
    , startBlock, endBlock;

  if (type === 'if' || type === 'unless' || type === 'each' || type === 'with') {
    if (hash === '#') {
      startBlock = true;
    } else if (hash === '/') {
      endBlock = true;
    } else {
      parseMatchError(text, type + ' blocks must begin with a #');
    }

  } else if (type === 'else' || type === 'else if') {
    if (hash) {
      parseMatchError(text, type + ' blocks may not start with ' + hash);
    }
    if (blockType !== 'if' && blockType !== 'else if' &&
        blockType !== 'unless' && blockType !== 'each') {
      parseMatchError(text, type + ' may only follow `if`, `else if`, `unless`, or `each`');
    }
    startBlock = true;
    endBlock = true;

  } else if (hash === '/') {
    endBlock = true;

  } else if (hash === '#') {
    parseMatchError(text, '# must be followed by `if`, `unless`, `each`, or `with`');
  }

  if (endBlock && !block) {
    parseMatchError(text, 'Unmatched template end tag');
  }

  onBlock(startBlock, endBlock, match, queues, callbacks);
}

function parseAttr(view, viewName, events, tagName, attrs, attr) {
  var value = attrs[attr];
  if (typeof value === 'function') return;

  var attrOut = parseMarkup('attr', attr, tagName, events, attrs, value) || {}
    , boundOut, match, name, render, method, property;
  if (attrOut.addId) addId(view, attrs);

  if (match = extractPlaceholder(value)) {
    name = match.name;

    if (match.pre || match.post) {
      // Attributes must be a single string, so create a string partial
      addId(view, attrs);
      render = parse(view, viewName, value, true, function(events, name) {
        bindEventsByIdString(events, name, render, attrs, 'attr', attr);
      });

      attrs[attr] = attr === 'id' ? function(ctx, model) {
        return attrs._id = escapeAttribute(render(ctx, model));
      } : function(ctx, model) {
        return escapeAttribute(render(ctx, model));
      }
      return;
    }

    if (match.bound) {
      boundOut = parseMarkup('bound', attr, tagName, events, attrs, match) || {};
      addId(view, attrs);
      method = boundOut.method || 'attr';
      property = boundOut.property || attr;
      bindEventsById(events, name, null, attrs, method, property);
    }

    if (!attrOut.del) {
      attrs[attr] = attrOut.bool ? {
        bool: function(ctx, model) {
          return (dataValue(view, ctx, model, name)) ? ' ' + attr : '';
        }
      } : textFn(view, name, escapeAttribute, true);
    }
  }
}

function parsePartialAttr(view, viewName, events, attrs, attr) {
  var value = attrs[attr]
    , match;

  if (!value) {
    // A true boolean attribute will have a value of null
    if (value === null) attrs[attr] = true;
    return;
  }

  if (attr === 'bind') {
    attrs[attr] = {$events: splitEvents(value), $view: view};
    return;
  }

  if (match = extractPlaceholder(value)) {
    // This attribute needs to be treated as a section
    if (match.pre || match.post) return true;

    attrs[attr] = {$matchName: match.name, $bound: match.bound};

  } else if (value === 'true') {
    attrs[attr] = true;
  } else if (value === 'false') {
    attrs[attr] = false;
  } else if (value === 'null') {
    attrs[attr] = null;
  } else if (!isNaN(value)) {
    attrs[attr] = +value;
  } else if (/^[{[]/.test(value)) {
    try {
      attrs[attr] = JSON.parse(value)
    } catch (err) {}
  }
}

function lastItem(arr) {
  return arr[arr.length - 1];
}

function parse(view, viewName, template, isString, onBind, noMinify) {
  var queues, stack, events, onRender, push;

  queues = [{
    stack: stack = []
  , events: events = []
  , sections: []
  }];

  function onStart(queue) {
    stack = queue.stack;
    events = queue.events;
  }

  if (isString) {
    push = pushVarString;
    onRender = function(ctx) {
      if (ctx.$stringCtx) return ctx;
      ctx = Object.create(ctx);
      ctx.$onBind = onBind;
      ctx.$stringCtx = ctx;
      return ctx;
    }
  } else {
    push = pushVar;
  }

  var index = viewName.lastIndexOf(':')
    , ns = ~index ? viewName.slice(0, index) : ''

  function parseStart(tag, tagName, attrs) {
    var attr, block, out, parser, isSection, attrBlock
    if ('x-no-minify' in attrs) {
      delete attrs['x-no-minify'];
      noMinify = true;
    }

    if (isPartial(view, tagName)) {
      block = {
        partial: tagName
      , macroCtx: attrs
      };
      onBlock(true, false, block, queues, {onStart: onStart});

      for (attr in attrs) {
        isSection = parsePartialAttr(view, viewName, events, attrs, attr);
        if (!isSection) continue;
        attrBlock = {
          partial: '@' + attr
        , macroCtx: lastItem(queues).block.macroCtx
        };
        onBlock(true, false, attrBlock, queues, {onStart: onStart});
        parseText(attrs[attr]);
        parseEnd(tag, '@' + attr);
      }

      if (isVoidComponent(view, tagName, ns)) {
        onBlock(false, true, null, queues, {
          onStart: onStart
        , onEnd: function(queues) {
            push(view, ns, stack, events, '', block);
          }
        })
      }
      return;
    }

    if (isPartialSection(tagName)) {
      block = {
        partial: tagName
      , macroCtx: lastItem(queues).block.macroCtx
      };
      onBlock(true, false, block, queues, {onStart: onStart});
      return;
    }

    if (parser = markup.element[tagName]) {
      out = parser(events, attrs);
      if (out != null ? out.addId : void 0) {
        addId(view, attrs);
      }
    }

    for (attr in attrs) {
      parseAttr(view, viewName, events, tagName, attrs, attr);
    }
    stack.push(['start', tagName, attrs]);
  }

  function parseText(text, isRawText, remainder) {
    var match = extractPlaceholder(text)
      , post, pre;
    if (!match || isRawText) {
      if (!noMinify) {
        text = isString ? unescapeEntities(trimText(text)) : trimText(text);
      }
      pushText(stack, text);
      return;
    }

    pre = match.pre;
    post = match.post;
    if (isString) pre = unescapeEntities(pre);
    pushText(stack, pre);
    remainder = post || remainder;

    parseMatch(text, match, queues, {
      onStart: onStart
    , onEnd: function(sections) {
        var fn = blockFn(view, sections);
        push(view, ns, stack, events, remainder, sections[0].block, fn);
      }
    , onContent: function(match) {
        push(view, ns, stack, events, remainder, match);
      }
    });

    if (post) return parseText(post);
  }

  function parseEnd(tag, tagName) {
    var sectionName = partialSectionName(tagName)
      , endsPartial = isPartial(view, tagName)
    if (endsPartial && isVoidComponent(view, tagName, ns)) {
      throw new Error('End tag "' + tag + '" is not allowed for void component')
    }
    if (sectionName || endsPartial) {
      onBlock(false, true, null, queues, {
        onStart: onStart
      , onEnd: function(queues) {
          var queue = queues[0]
            , block = queue.block
            , fn = renderer(view, reduceStack(queue.stack), queue.events)
          fn.unescaped = true;
          if (sectionName) {
            block.macroCtx[sectionName] = fn;
            return;
          }
          // Put the remaining content not in a section in the default "content" section,
          // unless "inherit" is specified and there is no content, so that the parent
          // content can be inherited
          if (queue.stack.length || !block.macroCtx.inherit) {
            block.macroCtx.content = fn;
          }
          push(view, ns, stack, events, '', block);
        }
      })
      return;
    }
    stack.push(['end', tagName]);
  }

  if (isString) {
    parseText(template);
  } else {
    parseHtml(template, {
      start: parseStart
    , text: parseText
    , end: parseEnd
    , comment: function(tag) {
        if (conditionalComment(tag)) pushText(stack, tag);
      }
    , other: function(tag) {
        pushText(stack, tag);
      }
    });
  }
  return renderer(view, reduceStack(stack), events, onRender);
}

})(window)
},{"./markup":58,"./viewPath":56,"./eventBinding":59,"./derby":"dhy1vc","html-util":48,"MD5":60}],58:[function(require,module,exports){
var eventBinding = require('./eventBinding')
  , splitEvents = eventBinding.splitEvents
  , containsEvent = eventBinding.containsEvent
  , addDomEvent = eventBinding.addDomEvent
  , TEXT_EVENTS = 'keyup,keydown/0,cut/0,paste/0,dragover/0,blur'
  , AUTOCOMPLETE_OFF = {
      checkbox: true
    , radio: true
    }
  , onBindA, onBindForm;

module.exports = {
  bound: {
    'value': {
      'input': function(events, attrs, match) {
        var type = attrs.type
          , eventNames, method;
        if (type === 'radio' || type === 'checkbox') return;
        if (type === 'range' || 'x-blur' in attrs) {
          // Only update after the element loses focus
          delete attrs['x-blur'];
          eventNames = 'change,blur';
        } else {
          // By default, update as the user types
          eventNames = TEXT_EVENTS;
        }
        if ('x-atomic' in attrs) {
          delete attrs['x-atomic'];
          method = 'prop';
        } else if (type === 'text' || !type) {
          method = 'propOt';
        } else {
          method = 'prop';
        }
        addDomEvent(events, attrs, eventNames, match, {
          method: method
        , property: 'value'
        });
        return {method: method};
      }
    }

  , 'checked': {
      '*': function(events, attrs, match) {
        addDomEvent(events, attrs, 'change', match, {
          method: 'prop'
        , property: 'checked'
        });
        return {method: 'prop'};
      }
    }

  , 'selected': {
      '*': function(events, attrs, match) {
        addDomEvent(events, attrs, 'change', match, {
          method: 'prop'
        , property: 'selected'
        });
        return {method: 'prop'};
      }
    }

  , 'disabled': {
      '*': function() {
        return {method: 'prop'};
      }
    }
  }

, boundParent: {
    'contenteditable': {
      '*': function(events, attrs, match) {
        addDomEvent(events, attrs, TEXT_EVENTS, match, {
          method: 'html'
        });
      }
    }

  , '*': {
      'textarea': function(events, attrs, match) {
        if ('x-atomic' in attrs) {
          delete attrs['x-atomic'];
          var method = 'prop';
        } else {
          var method = 'propOt';
        }
        addDomEvent(events, attrs, TEXT_EVENTS, match, {
          method: method
        , property: 'value'
        });
        return {method: method, property: 'value'};
      }
    }
  }

, element: {
    'select': function(events, attrs) {
      // Distribute change event to child nodes of select elements
      addDomEvent(events, attrs, 'change:$forChildren');
      return {addId: true};
    }

  , 'input': function(events, attrs) {
      if (AUTOCOMPLETE_OFF[attrs.type] && !('autocomplete' in attrs)) {
        attrs.autocomplete = 'off';
      }
      if (attrs.type === 'radio') {
        // Distribute change events to other elements with the same name
        addDomEvent(events, attrs, 'change:$forName');
      }
    }
  }

, attr: {
    'x-bind': {
      '*': function(events, attrs, eventNames) {
        addDomEvent(events, attrs, eventNames);
        return {addId: true, del: true};
      }

    , 'a': onBindA = function(events, attrs, eventNames) {
        if (containsEvent(eventNames, ['click', 'focus']) && !('href' in attrs)) {
          attrs.href = '#';
          if (!('onclick' in attrs)) {
            attrs.onclick = 'return false';
          }
        }
      }

    , 'form': onBindForm = function(events, attrs, eventNames) {
        if (containsEvent(eventNames, 'submit')) {
          if (!('onsubmit' in attrs)) {
            attrs.onsubmit = 'return false';
          }
        }
      }
    }

  , 'x-capture': {
      '*': function(events, attrs, eventNames) {
        addDomEvent(events, attrs, eventNames, null, {capture: true});
        return {addId: true, del: true};
      }
    , 'a': onBindA
    , 'form': onBindForm
    }

  , 'x-as': {
      '*': function(events, attrs, name) {
        events.push(function(ctx) {
          ctx.$elements[name] = attrs._id || attrs.id;
        });
        return {addId: true, del: true}
      }
  }

  , 'checked': {
      '*': function() {
        return {bool: true};
      }
    }

  , 'selected': {
      '*': function() {
        return {bool: true};
      }
    }

  , 'disabled': {
      '*': function() {
        return {bool: true};
      }
    }

  , 'autofocus': {
      '*': function() {
        return {bool: true};
      }
    }
  }

, TEXT_EVENTS: TEXT_EVENTS
, AUTOCOMPLETE_OFF: AUTOCOMPLETE_OFF
};

},{"./eventBinding":59}],59:[function(require,module,exports){
var util = require('racer').util
  , viewPath = require('./viewPath')
  , extractPlaceholder = viewPath.extractPlaceholder
  , dataValue = viewPath.dataValue
  , ctxPath = viewPath.ctxPath
  , pathFnArgs = viewPath.pathFnArgs
  , setBoundFn = viewPath.setBoundFn
  , arraySlice = [].slice

exports.splitEvents = splitEvents;
exports.fnListener = fnListener;
exports.containsEvent = containsEvent;
exports.addDomEvent = util.isServer ? empty : addDomEvent;

function splitEvents(eventNames) {
  var pairs = eventNames.split(',')
    , eventList = []
    , i, j, pair, segments, name, eventName, delay, fns, fn;
  for (i = pairs.length; i--;) {
    pair = pairs[i];
    segments = pair.split(':');
    name = segments[0].split('/');
    eventName = name[0].trim();
    delay = name[1];
    fns = (segments[1] || '').trim().split(/\s+/);
    for (j = fns.length; j--;) {
      fn = fns[j];
      fns[j] = extractPlaceholder(fn) || fn;
    }
    eventList.push([eventName, delay, fns]);
  }
  return eventList;
}

function containsEvent(eventNames, expected) {
  if (!Array.isArray(expected)) expected = [expected];
  var eventList = splitEvents(eventNames)
    , i, j, eventName
  for (i = eventList.length; i--;) {
    eventName = eventList[i][0];
    for (j = expected.length; j--;) {
      if (eventName === expected[j]) return true;
    }
  }
  return false;
}

function addDomEvent(events, attrs, eventNames, match, options) {
  var eventList = splitEvents(eventNames)
    , args, name;

  if (match) {
    name = match.name;

    if (~name.indexOf('(')) {
      args = pathFnArgs(name);
      if (!args.length) return;

      events.push(function(ctx, modelEvents, dom, pathMap, view) {
        var id = attrs._id || attrs.id
          , paths = []
          , arg, path, pathId, event, eventName, eventOptions, i, j;
        options.setValue = function(model, value) {
          return setBoundFn(view, ctx, model, name, value);
        }
        for (i = args.length; i--;) {
          arg = args[i];
          path = ctxPath(view, ctx, arg);
          paths.push(path);
          pathId = pathMap.id(path);
          for (j = eventList.length; j--;) {
            event = eventList[j];
            eventName = event[0];
            eventOptions = util.mergeInto({view: view, ctx: ctx, pathId: pathId, delay: event[1]}, options);
            dom.bind(eventName, id, eventOptions);
          }
        }
      });
      return;
    }

    events.push(function(ctx, modelEvents, dom, pathMap, view) {
      var id = attrs._id || attrs.id
        , pathId = pathMap.id(ctxPath(view, ctx, name))
        , event, eventName, eventOptions, i;
      for (i = eventList.length; i--;) {
        event = eventList[i];
        eventName = event[0];
        eventOptions = util.mergeInto({view: view, ctx: ctx, pathId: pathId, delay: event[1]}, options);
        dom.bind(eventName, id, eventOptions);
      }
    });
    return;
  }

  events.push(function(ctx, modelEvents, dom, pathMap, view) {
    var id = attrs._id || attrs.id
      , pathId = pathMap.id(ctxPath(view, ctx, '.'))
      , event, eventName, eventOptions, i;
    for (i = eventList.length; i--;) {
      event = eventList[i];
      eventName = event[0];
      eventOptions = fnListener(view, ctx, event[2], dom);
      eventOptions.delay = event[1];
      util.mergeInto(eventOptions, options);
      util.mergeInto(eventOptions, {view: view, ctx: ctx, pathId: pathId});
      dom.bind(eventName, id, eventOptions);
    }
  });
}

function eachFnListener(view, ctx, fnObj, dom) {
  var fnName, fn, fnCtxs, i, fnCtx;

  fnName = typeof fnObj === 'object'
    ? dataValue(view, ctx, view.model, fnObj.name)
    : fnName = fnObj;

  // If a placeholder for an event name does not have a value, do nothing
  if (!fnName) return empty;

  // See if it is a built-in function
  fn = dom && dom.fns[fnName];

  // Lookup the function name on the component script or app

  // TODO: This simply looks in the local scope for the function
  // and then goes up the scope if a function name is not found.
  // Better would be to actually figure out the scope of where the
  // function name is specfied, since there could easily be namespace
  // conflicts between functions in a component and functions in an
  // app using that component. How to implement this correctly is not
  // obvious at the moment.
  if (!fn) {
    fnCtxs = ctx.$fnCtx;
    for (i = fnCtxs.length; i--;) {
      fnCtx = fnCtxs[i];
      fn = fnCtx[fnName] || viewPath.lookup(fnName, fnCtx);
      if (fn) break;
    }
  }
  if (!fn) throw new Error('Bound function not found: ' + fnName);

  // Bind the listener to the app or component object on which it
  // was defined so that the `this` context will be the instance
  return fn.bind(fnCtx);
}

function fnListener(view, ctx, fnNames, dom) {
  var listener = {
    fn: function() {
      var len = fnNames.length
        , args = arraySlice.call(arguments)
        , i, fn, boundFns

      if (len === 0) {
        // Don't do anything if no handler functions were specified
        return listener.fn = empty;

      } else if (len === 1) {
        fn = eachFnListener(view, ctx, fnNames[0], dom);

      } else {
        boundFns = [];
        for (i = len; i--;) {
          boundFns.push(eachFnListener(view, ctx, fnNames[i], dom));
        }
        fn = function() {
          var args = arraySlice.call(arguments)
          for (var i = boundFns.length; i--;) {
            boundFns[i].apply(null, args);
          }
        }
      }

      listener.fn = fn;
      fn.apply(null, args);
    }
  };
  return listener;
}

function empty() {}

},{"racer":"eS5xJL","./viewPath":56}],48:[function(require,module,exports){
var entityCode = require('./entityCode')
  , parse = require('./parse')

module.exports = {
  parse: parse
, escapeHtml: escapeHtml
, escapeAttribute: escapeAttribute
, unescapeEntities: unescapeEntities
, isVoid: isVoid
, conditionalComment: conditionalComment
, trimLeading: trimLeading
, trimText: trimText
, trimTag: trimTag
, minify: minify
}

function escapeHtml(value) {
  if (value == null) return ''

  return value
    .toString()
    .replace(/&(?!\s)|</g, function(match) {
      return match === '&' ? '&amp;' : '&lt;'
    })
}

function escapeAttribute(value) {
  if (value == null || value === '') return '""'

  value = value
    .toString()
    .replace(/&(?!\s)|"/g, function(match) {
      return match === '&' ? '&amp;' : '&quot;'
    })
  return /[ =<>']/.test(value) ? '"' + value + '"' : value
}

// Based on:
// http://code.google.com/p/jslibs/wiki/JavascriptTips#Escape_and_unescape_HTML_entities
function unescapeEntities(html) {
  return html.replace(/&([^;]+);/g, function(match, entity) {
    var charCode = entity.charAt(0) === '#'
          ? entity.charAt(1) === 'x'
            ? entity.slice(2, 17)
            : entity.slice(1)
          : entityCode[entity]
    return String.fromCharCode(charCode)
  })
}

var voidElement = {
  area: 1
, base: 1
, br: 1
, col: 1
, command: 1
, embed: 1
, hr: 1
, img: 1
, input: 1
, keygen: 1
, link: 1
, meta: 1
, param: 1
, source: 1
, track: 1
, wbr: 1
}
function isVoid(name) {
  return name in voidElement
}

// Assume any HTML comment that starts with `<!--[` or ends with `]-->`
// is a conditional comment. This can also be used to keep comments in
// minified HTML, such as `<!--[ Copyright John Doe, MIT Licensed ]-->`
function conditionalComment(tag) {
  return /(?:^<!--\[)|(?:\]-->$)/.test(tag)
}

// Remove leading whitespace and newlines from a string. Whitespace at the end
// of a line will be maintained
function trimLeading(text) {
  return text ? text.replace(/\r?\n\s*/g, '') : ''
}

// Remove leading & trailing whitespace and newlines from a string
function trimText(text) {
  return text ? text.replace(/\s*\r?\n\s*/g, '') : ''
}

// Within a tag, remove leading & trailing whitespace. Keep a linebreak, since
// this could be the separator between attributes
function trimTag(tag) {
  return tag.replace(/(?:\s*\r?\n\s*)+/g, '\n')
}

// Remove linebreaks, leading & trailing space, and comments. Maintain a
// linebreak between HTML tag attributes and maintain conditional comments.
function minify(html) {
  var minified = ''
    , minifyContent = true

  parse(html, {
    start: function(tag, tagName, attrs) {
      minifyContent = !('x-no-minify' in attrs)
      minified += trimTag(tag)
    }
  , end: function(tag) {
      minified += trimTag(tag)
    }
  , text: function(text) {
      minified += minifyContent ? trimText(text) : text
    }
  , comment: function(tag) {
      if (conditionalComment(tag)) minified += tag
    }
  , other: function(tag) {
      minified += tag
    }
  })
  return minified
}

},{"./entityCode":61,"./parse":62}],52:[function(require,module,exports){
var router = module.exports = require('./router')

module.exports = {
  transition: transition
}

/**
 * @param {Function} add (e.g., app.get, app.post, etc.)
 * @param {Array} transitionCalls is an array of objects that look 
 *   like {from, to, forward, back}
 * @param {String} from
 * @param {String} to
 * @param {Function} forward
 * @param {Function} back
 */
function transition(add, calls, from, to, forward, back) {
  if (from === to) return
  for (var i = 0, len = calls.length; i < len; i++) {
    var call = calls[i]
    if (call.from === to) {
      if (hasTransition(calls, from, call.to)) continue
      var composedForward = composeCallbacks(forward, call.forward, to)
      if (back && call.back) {
        var composedBack = composeCallbacks(call.back, back, to)
      }
      add({
        from: from
      , to: call.to
      , forward: composedForward
      , back: composedBack
      })
    } else if (call.to === from) {
      if (hasTransition(calls, call.from, to)) continue
      var composedForward = composeCallbacks(call.forward, forward, from)
      if (back && call.back) {
        var composedBack = composeCallbacks(back, call.back, from)
      }
      add({
        from: call.from
      , to: to
      , forward: composedForward
      , back: composedBack
      })
    }
  }
}

function hasTransition(calls, from, to) {
  for (var i = calls.length; i--;) {
    var call = calls[i];
    if (call.from === from && call.to === to) return true
  }
  return false
}

// TODO: Async support
function composeCallbacks(first, second, intermediatePath) {
  function composed(self, model, params, next, done) {
    var intermediateUrl = router.mapRoute(intermediatePath, params)
    var url = params.url
    var skipped = false
    function wrapNext(err) {
      skipped = true
      next(err)
    }
    params.url = intermediateUrl
    if (first.length === 4) {
      first.call(self, model, params, wrapNext, doneFirst)
    } else {
      first.call(self, model, params, wrapNext)
      doneFirst()
    }
    function doneFirst() {
      if (skipped) return
      params.previous = intermediateUrl
      params.url = url
      if (second.length === 4) {
        second.call(self, model, params, next, done)
      } else {
        second.call(self, model, params, next)
        done && done()
      }
    }
  }
  // These need to be defined individually, since their
  // argument length will be checked
  function asyncComposedCallback(model, params, next, done) {
    composed(this, model, params, next, done);
  }
  function composedCallback(model, params, next) {
    composed(this, model, params, next);
  }
  return (first.length === 4 || second.length === 4) ?
    asyncComposedCallback : composedCallback;
}

},{"./router":51}],57:[function(require,module,exports){
var doc = document
  , elementProto = HTMLElement.prototype
  , nodeProto = Node.prototype

// Add support for Node.contains for Firefox < 9
if (!doc.contains) {
  nodeProto.contains = function(node) {
    return !!(this.compareDocumentPosition(node) & 16)
  }
}

// Add support for insertAdjacentHTML for Firefox < 8
// Based on insertAdjacentHTML.js by Eli Grey, http://eligrey.com
if (!doc.body.insertAdjacentHTML) {
  elementProto.insertAdjacentHTML = function(position, html) {
    var position = position.toLowerCase()
      , ref = this
      , parent = ref.parentNode
      , container = doc.createElement(parent.tagName)
      , firstChild, nextSibling, node

    container.innerHTML = html
    if (position === 'beforeend') {
      while (node = container.firstChild) {
        ref.appendChild(node)
      }
    } else if (position === 'beforebegin') {
      while (node = container.firstChild) {
        parent.insertBefore(node, ref)
      }
    } else if (position === 'afterend') {
      nextSibling = ref.nextSibling
      while (node = container.lastChild) {
        nextSibling = parent.insertBefore(node, nextSibling)
      }
    } else if (position === 'afterbegin') {
      firstChild = ref.firstChild
      while (node = container.lastChild) {
        firstChild = ref.insertBefore(node, firstChild)
      }
    }
  }
}

elementProto.matches =
  elementProto.webkitMatchesSelector ||
  elementProto.mozMatchesSelector ||
  elementProto.oMatchesSelector ||
  elementProto.msMatchesSelector

},{}],55:[function(require,module,exports){
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]'
    };

var objectKeys = Object.keys || function objectKeys(object) {
    if (object !== Object(object)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in object) if (object.hasOwnProperty(key)) keys[keys.length] = key;
    return keys;
}


/*!
 * querystring
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Library version.
 */

exports.version = '0.3.1';

/**
 * Object#toString() ref for stringify().
 */

var toString = Object.prototype.toString;

/**
 * Cache non-integer test regexp.
 */

var notint = /[^0-9]/;

/**
 * Parse the given query `str`, returning an object.
 *
 * @param {String} str
 * @return {Object}
 * @api public
 */

exports.parse = function(str){
  if (null == str || '' == str) return {};

  function promote(parent, key) {
    if (parent[key].length == 0) return parent[key] = {};
    var t = {};
    for (var i in parent[key]) t[i] = parent[key][i];
    parent[key] = t;
    return t;
  }

  return String(str)
    .split('&')
    .reduce(function(ret, pair){
      try{ 
        pair = decodeURIComponent(pair.replace(/\+/g, ' '));
      } catch(e) {
        // ignore
      }

      var eql = pair.indexOf('=')
        , brace = lastBraceInKey(pair)
        , key = pair.substr(0, brace || eql)
        , val = pair.substr(brace || eql, pair.length)
        , val = val.substr(val.indexOf('=') + 1, val.length)
        , parent = ret;

      // ?foo
      if ('' == key) key = pair, val = '';

      // nested
      if (~key.indexOf(']')) {
        var parts = key.split('[')
          , len = parts.length
          , last = len - 1;

        function parse(parts, parent, key) {
          var part = parts.shift();

          // end
          if (!part) {
            if (isArray(parent[key])) {
              parent[key].push(val);
            } else if ('object' == typeof parent[key]) {
              parent[key] = val;
            } else if ('undefined' == typeof parent[key]) {
              parent[key] = val;
            } else {
              parent[key] = [parent[key], val];
            }
          // array
          } else {
            obj = parent[key] = parent[key] || [];
            if (']' == part) {
              if (isArray(obj)) {
                if ('' != val) obj.push(val);
              } else if ('object' == typeof obj) {
                obj[objectKeys(obj).length] = val;
              } else {
                obj = parent[key] = [parent[key], val];
              }
            // prop
            } else if (~part.indexOf(']')) {
              part = part.substr(0, part.length - 1);
              if(notint.test(part) && isArray(obj)) obj = promote(parent, key);
              parse(parts, obj, part);
            // key
            } else {
              if(notint.test(part) && isArray(obj)) obj = promote(parent, key);
              parse(parts, obj, part);
            }
          }
        }

        parse(parts, parent, 'base');
      // optimize
      } else {
        if (notint.test(key) && isArray(parent.base)) {
          var t = {};
          for(var k in parent.base) t[k] = parent.base[k];
          parent.base = t;
        }
        set(parent.base, key, val);
      }

      return ret;
    }, {base: {}}).base;
};

/**
 * Turn the given `obj` into a query string
 *
 * @param {Object} obj
 * @return {String}
 * @api public
 */

var stringify = exports.stringify = function(obj, prefix) {
  if (isArray(obj)) {
    return stringifyArray(obj, prefix);
  } else if ('[object Object]' == toString.call(obj)) {
    return stringifyObject(obj, prefix);
  } else if ('string' == typeof obj) {
    return stringifyString(obj, prefix);
  } else {
    return prefix;
  }
};

/**
 * Stringify the given `str`.
 *
 * @param {String} str
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyString(str, prefix) {
  if (!prefix) throw new TypeError('stringify expects an object');
  return prefix + '=' + encodeURIComponent(str);
}

/**
 * Stringify the given `arr`.
 *
 * @param {Array} arr
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyArray(arr, prefix) {
  var ret = [];
  if (!prefix) throw new TypeError('stringify expects an object');
  for (var i = 0; i < arr.length; i++) {
    ret.push(stringify(arr[i], prefix + '[]'));
  }
  return ret.join('&');
}

/**
 * Stringify the given `obj`.
 *
 * @param {Object} obj
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyObject(obj, prefix) {
  var ret = []
    , keys = objectKeys(obj)
    , key;
  for (var i = 0, len = keys.length; i < len; ++i) {
    key = keys[i];
    ret.push(stringify(obj[key], prefix
      ? prefix + '[' + encodeURIComponent(key) + ']'
      : encodeURIComponent(key)));
  }
  return ret.join('&');
}

/**
 * Set `obj`'s `key` to `val` respecting
 * the weird and wonderful syntax of a qs,
 * where "foo=bar&foo=baz" becomes an array.
 *
 * @param {Object} obj
 * @param {String} key
 * @param {String} val
 * @api private
 */

function set(obj, key, val) {
  var v = obj[key];
  if (undefined === v) {
    obj[key] = val;
  } else if (isArray(v)) {
    v.push(val);
  } else {
    obj[key] = [v, val];
  }
}

/**
 * Locate last brace in `str` within the key.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function lastBraceInKey(str) {
  var len = str.length
    , brace
    , c;
  for (var i = 0; i < len; ++i) {
    c = str[i];
    if (']' == c) brace = false;
    if ('[' == c) brace = true;
    if ('=' == c && !brace) return i;
  }
}

},{}],56:[function(require,module,exports){
var trimLeading = require('html-util').trimLeading;

exports.wrapRemainder = wrapRemainder;
exports.extractPlaceholder = extractPlaceholder;
exports.pathFnArgs = pathFnArgs;
exports.squareBracketsArgs = squareBracketsArgs;
exports.ctxPath = ctxPath;
exports.getValue = getValue;
exports.dataValue = dataValue;
exports.setBoundFn = setBoundFn;
exports.lookup = lookup;
exports.replaceSquareBrackets = replaceSquareBrackets;

function wrapRemainder(tagName, remainder) {
  if (!remainder) return false;
  return !(new RegExp('^<\/' + tagName, 'i')).test(remainder);
}

var openPlaceholder = /^([\s\S]*?)(\{{1,3})\s*([\s\S]*)/
  , aliasContent = /^([\s\S]*)\s+as\s+:(\S+)\s*$/
  , blockContent = /^([\#\/]?)(else\sif|if|else|unless|each|with|unescaped)?\s*([\s\S]*?)\s*$/
  , closeMap = { 1: '}', 2: '}}' }
function extractPlaceholder(text) {
  var match = openPlaceholder.exec(text);
  if (!match) return;
  var pre = match[1]
    , open = match[2]
    , remainder = match[3]
    , openLen = open.length
    , bound = openLen === 1
    , end = matchBraces(remainder, openLen, 0, '{', '}')
    , endInner = end - openLen
    , inner = remainder.slice(0, endInner)
    , post = remainder.slice(end)
    , alias, hash, type, name, escaped;

  if (/["{[]/.test(inner)) {
    // Make sure that we didn't accidentally match a JSON literal
    try {
      JSON.parse(open + inner + closeMap[openLen]);
      return;
    } catch (e) {}
  }

  match = aliasContent.exec(inner);
  if (match) {
    inner = match[1];
    alias = match[2];
  }

  match = blockContent.exec(inner)
  if (!match) return;
  hash = match[1];
  type = match[2];
  name = match[3];

  escaped = true;
  if (type === 'unescaped') {
    escaped = false;
    type = '';
  }
  if (bound) name = name.replace(/\bthis\b/, '.');
  return {
    pre: pre
  , post: post
  , bound: bound
  , alias: alias
  , hash: hash
  , type: type
  , name: name
  , escaped: escaped
  , source: text
  };
}

function matchBraces(text, num, i, openChar, closeChar) {
  var close, hasClose, hasOpen, open;
  i++;
  while (num) {
    close = text.indexOf(closeChar, i);
    open = text.indexOf(openChar, i);
    hasClose = ~close;
    hasOpen = ~open;
    if (hasClose && (!hasOpen || (close < open))) {
      i = close + 1;
      num--;
      continue;
    } else if (hasOpen) {
      i = open + 1;
      num++;
      continue;
    } else {
      return -1;
    }
  }
  return i;
}

var fnCall = /^([^(]+)\s*\(\s*([\s\S]*?)\s*\)\s*$/
  , argSeparator = /\s*([,(])\s*/g
  , notSeparator = /[^,\s]/g
  , notPathArg = /(?:^['"\d\-[{])|(?:^null$)|(?:^true$)|(?:^false$)/;

function fnArgs(inner) {
  var args = []
    , lastIndex = 0
    , match, end, last;
  while (match = argSeparator.exec(inner)) {
    if (match[1] === '(') {
      end = matchBraces(inner, 1, argSeparator.lastIndex, '(', ')');
      args.push(inner.slice(lastIndex, end));
      notSeparator.lastIndex = end;
      lastIndex = argSeparator.lastIndex =
        notSeparator.test(inner) ? notSeparator.lastIndex - 1 : end;
      continue;
    }
    args.push(inner.slice(lastIndex, match.index));
    lastIndex = argSeparator.lastIndex;
  }
  last = inner.slice(lastIndex);
  if (last) args.push(last);
  return args;
}

function fnCallError(name) {
  throw new Error('malformed view function call: ' + name);
}

function fnArgValue(view, ctx, model, name, arg) {
  var literal = literalValue(arg);
  if (literal !== void 0) return literal;

  var pathMap = model.__pathMap;
  if (!pathMap) return dataValue(view, ctx, model, arg);

  var argIds = ctx.hasOwnProperty('$fnArgIds') ?
    ctx.$fnArgIds : (ctx.$fnArgIds = {});
  var pathId = argIds[arg];
  var path;
  if (pathId) {
    path = pathMap.paths[pathId];
  } else {
    path = ctxPath(view, ctx, arg);
    argIds[arg] = pathMap.id(path);
  }
  return dataValue(view, ctx, model, path);
}

function fnValue(view, ctx, model, name) {
  var match = fnCall.exec(name) || fnCallError(name)
    , fnName = match[1]
    , args = fnArgs(match[2])
    , fn, fnName, i;
  for (i = args.length; i--;) {
    args[i] = fnArgValue(view, ctx, model, name, args[i]);
  }
  if (!(fn = view.getFns[fnName])) {
    throw new Error('view function "' + fnName + '" not found for call: ' + name);
  }
  return fn.apply({view: view, ctx: ctx, model: model}, args);
}

function pathFnArgs(name, paths) {
  var match = fnCall.exec(name) || fnCallError(name)
    , args = fnArgs(match[2])
    , i, arg;
  if (paths == null) paths = [];
  for (i = args.length; i--;) {
    arg = args[i];
    if (notPathArg.test(arg)) continue;
    if (~arg.indexOf('(')) {
      pathFnArgs(arg, paths);
      continue;
    }
    paths.push(arg);
  }
  return paths;
}

function relativePath(view, ctx, i, remainder) {
  var name = ctx.$paths[i - 1] + remainder;

  // pathMap is only created in the browser
  var pathMap = view.model.__pathMap;
  if (!pathMap) return name;
  var pathId = ctx.$pathIds[name] || (ctx.$pathIds[name] = pathMap.id(name));
  return pathMap.paths[pathId];
}

function macroName(view, ctx, name) {
  if (name.charAt(0) !== '@') return;

  var segments = name.slice(1).split('.');
  var base = segments.shift().toLowerCase();
  var value = lookup(base, ctx.$macroCtx);
  var matchName = value && value.$matchName;
  var remainder = segments.join('.');

  if (matchName) {
    if (!remainder) return value;
    return {$matchName: matchName + '.' + remainder};
  }
  return (remainder) ? base + '.' + remainder : base;
}

function ctxPath(view, ctx, name) {
  var isWildcard = name.charAt(name.length - 1) === '*';
  if (isWildcard) name = name.slice(0, -1);

  var macroPath = macroName(view, ctx, name);
  if (macroPath && macroPath.$matchName) name = macroPath.$matchName;

  var firstChar = name.charAt(0)
    , i, aliasName, remainder

  // Resolve path aliases
  if (firstChar === ':') {
    if (~(i = name.search(/[.[]/))) {
      aliasName = name.slice(1, i);
      remainder = name.slice(i);
    } else {
      aliasName = name.slice(1);
      remainder = '';
    }
    aliasName = aliasName;
    i = ctx.$paths.length - ctx.$aliases[aliasName];
    if (i !== i) throw new Error('Cannot find alias: ' + name);

    name = relativePath(view, ctx, i, remainder);

  // Resolve relative paths
  } else if (firstChar === '.') {
    i = 0;
    while (name.charAt(i) === '.') {
      i++;
    }
    remainder = i === name.length ? '' : name.slice(i - 1);

    name = relativePath(view, ctx, i, remainder);
  }

  name = replaceSquareBrackets(view, ctx, name);
  if (isWildcard) name += '*';
  return name;
}

function replaceSquareBrackets(view, ctx, name) {
  if (!name) return '';
  var i = name.indexOf('[');
  if (i === -1) return name;

  var end = matchBraces(name, 1, i, '[', ']');
  // This shouldn't normally happen, but just in case return
  if (end === -1) return;
  var before = name.slice(0, i);
  var inside = name.slice(i + 1, end - 1);
  var after = name.slice(end);

  name = replaceSquareBrackets(view, ctx, inside);
  var value = getValue(view, ctx, view.model, name);
  name = (value == null) ? '$null' : value;
  var out = (before) ? before + '.' + name : name;

  while (after) {
    i = after.indexOf('[');
    if (i === -1) return out + after;

    name = after;
    end = matchBraces(name, 1, i, '[', ']');
    if (end === -1) return;
    before = name.slice(0, i);
    inside = name.slice(i + 1, end - 1);
    after = name.slice(end);

    if (before) out += before;

    name = replaceSquareBrackets(view, ctx, inside);
    value = getValue(view, ctx, view.model, name);
    value = (value == null) ? '$null' : value;
    out += '.' + value;
  }
  return out;
}

function squareBracketsArgs(name, paths) {
  paths || (paths = []);

  while (name) {
    i = name.indexOf('[');
    if (i === -1) return paths;

    end = matchBraces(name, 1, i, '[', ']');
    if (end === -1) return paths;
    inside = name.slice(i + 1, end - 1);
    name = name.slice(end);

    if (inside.indexOf('[') === -1) {
      paths.push(inside);
    } else {
      squareBracketsArgs(inside, paths);
    }
  }
  return paths;
}

function escapeValue(value, escape) {
  return escape ? escape(value) : value;
}

function literalValue(value) {
  if (value === 'null') return null;
  if (value === 'true') return true;
  if (value === 'false') return false;
  var firstChar = value.charAt(0)
    , match;
  if (firstChar === "'") {
    match = /^'(.*)'$/.exec(value) || fnCallError(value);
    return match[1];
  }
  if (firstChar === '"') {
    match = /^"(.*)"$/.exec(value) || fnCallError(value);
    return match[1];
  }
  if (/^[\d\-]/.test(firstChar) && !isNaN(value)) {
    return +value;
  }
  if (firstChar === '[' || firstChar === '{') {
    try {
      return JSON.parse(value);
    } catch (e) {}
  }
  return undefined;
}

function getValue(view, ctx, model, name, escape, forceEscape) {
  var literal = literalValue(name)
  if (literal === undefined) {
    return dataValue(view, ctx, model, name, escape, forceEscape);
  }
  return literal;
}

function dataValue(view, ctx, model, name, escape, forceEscape) {
  var macroPath, path, value;
  if (!name) return;
  if (~name.indexOf('(')) {
    value = fnValue(view, ctx, model, name);
    return escapeValue(value, escape);
  }
  path = ctxPath(view, ctx, name);
  macroPath = macroName(view, ctx, path);
  if (macroPath) {
    if (macroPath.$matchName) {
      path = macroPath.$matchName;
    } else {
      value = lookup(macroPath, ctx.$macroCtx);
      if (typeof value === 'function') {
        if (value.unescaped && !forceEscape) return value(ctx, model);
        value = value(ctx, model);
      }
      return escapeValue(value, escape);
    }
  }
  value = lookup(path, ctx);
  if (value === void 0) value = model.get(path)
  return escapeValue(value, escape);
}

function setBoundFn(view, ctx, model, name, value) {
  var match = fnCall.exec(name) || fnCallError(name)
    , fnName = match[1]
    , args = fnArgs(match[2])
    , get = view.getFns[fnName]
    , set = view.setFns[fnName]
    , numInputs = set && set.length - 1
    , arg, i, inputs, out, key, path, len;

  if (!(get && set)) {
    throw new Error('view function "' + fnName + '" setter not found for binding to: ' + name);
  }

  if (numInputs) {
    inputs = [value];
    i = 0;
    while (i < numInputs) {
      inputs.push(fnArgValue(view, ctx, model, name, args[i++]));
    }
    out = set.apply(null, inputs);
  } else {
    out = set(value);
  }
  if (!out) return;

  for (key in out) {
    value = out[key];
    arg = args[key];
    if (~arg.indexOf('(')) {
      setBoundFn(view, ctx, model, arg, value);
      continue;
    }
    if (value === void 0 || notPathArg.test(arg)) continue;
    path = ctxPath(view, ctx, arg);
    if (model.get(path) === value) continue;
    model.set(path, value);
  }
}

function lookup(path, obj) {
  if (!path || !obj) return;
  if (path.indexOf('.') === -1) return obj[path];

  var parts = path.split('.');
  for (var i = 0, l = parts.length; i < l; i++) {
    if (!obj) return obj;

    var prop = parts[i];
    obj = obj[prop];
  }
  return obj;
}

},{"html-util":48}],63:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var util = require('./util');

module.exports = Channel;

function Channel(socket) {
  EventEmitter.call(this);

  this.socket = socket;
  this.messages = new Messages;

  var channel = this;
  var onmessage = socket.onmessage;
  socket.onmessage = function(data) {
    if (data && data.racer) return channel._onMessage(data);
    onmessage && onmessage.call(socket, data);
  };
}

util.mergeInto(Channel.prototype, EventEmitter.prototype);

Channel.prototype.send = function(name, data, cb) {
  var message = this.messages.add(name, data, cb);
  // Proactively call the toJSON function, since the Google Closure JSON
  // serializer doesn't check for it
  this.socket.send(message.toJSON());
};

Channel.prototype._reply = function(id, name, data) {
  var message = new Message(id, true, name, data);
  this.socket.send(message.toJSON());
};

Channel.prototype._onMessage = function(data) {
  if (data.ack) {
    var message = this.messages.remove(data.id);
    if (message && message.cb) message.cb.apply(data.data);
    return;
  }
  var name = data.racer;
  if (data.cb) {
    var channel = this;
    var hasListeners = this.emit(name, data.data, function() {
      var args = Array.prototype.slice.call(arguments);
      channel._reply(data.id, name, args);
    });
    if (!hasListeners) this._reply(data.id, name);
  } else {
    this.emit(name, data.data);
    this._reply(data.id, name);
  }
};

function MessagesMap() {}

function Messages() {
  this.map = new MessagesMap();
  this.idCount = 0;
}
Messages.prototype.id = function() {
  return (++this.idCount).toString(36);
};
Messages.prototype.add = function(name, data, cb) {
  var message = new Message(this.id(), false, name, data, cb);
  this.map[message.id] = message;
  return message;
};
Messages.prototype.remove = function(id) {
  var message = this.map[id];
  delete this.map[id];
  return message;
};

function Message(id, ack, name, data, cb) {
  this.id = id;
  this.ack = ack;
  this.name = name;
  this.data = data;
  this.cb = cb;
}
Message.prototype.toJSON = function() {
  return {
    racer: this.name
  , id: this.id
  , data: this.data
  , ack: +this.ack
  , cb: (this.cb) ? 1 : 0
  };
};

},{"events":11,"./util":12}],49:[function(require,module,exports){

/**
 * Module dependencies.
 */

var utils = require('../utils');

/**
 * Expose `Route`.
 */

module.exports = Route;

/**
 * Initialize `Route` with the given HTTP `method`, `path`,
 * and an array of `callbacks` and `options`.
 *
 * Options:
 *
 *   - `sensitive`    enable case-sensitive routes
 *   - `strict`       enable strict matching for trailing slashes
 *
 * @param {String} method
 * @param {String} path
 * @param {Array} callbacks
 * @param {Object} options.
 * @api private
 */

function Route(method, path, callbacks, options) {
  options = options || {};
  this.path = path;
  this.method = method;
  this.callbacks = callbacks;
  this.regexp = utils.pathRegexp(path
    , this.keys = []
    , options.sensitive
    , options.strict);
}

/**
 * Check if this route matches `path`, if so
 * populate `.params`.
 *
 * @param {String} path
 * @return {Boolean}
 * @api private
 */

Route.prototype.match = function(path){
  var keys = this.keys
    , params = this.params = []
    , m = this.regexp.exec(path);

  if (!m) return false;

  for (var i = 1, len = m.length; i < len; ++i) {
    var key = keys[i - 1];

    var val = 'string' == typeof m[i]
      ? decodeURIComponent(m[i])
      : m[i];

    if (key) {
      params[key.name] = val;
    } else {
      params.push(val);
    }
  }

  return true;
};

},{"../utils":64}],61:[function(require,module,exports){
module.exports = {
  quot: 0x0022
, amp: 0x0026
, apos: 0x0027
, lpar: 0x0028
, rpar: 0x0029
, lt: 0x003C
, gt: 0x003E
, nbsp: 0x00A0
, iexcl: 0x00A1
, cent: 0x00A2
, pound: 0x00A3
, curren: 0x00A4
, yen: 0x00A5
, brvbar: 0x00A6
, sect: 0x00A7
, uml: 0x00A8
, copy: 0x00A9
, ordf: 0x00AA
, laquo: 0x00AB
, not: 0x00AC
, shy: 0x00AD
, reg: 0x00AE
, macr: 0x00AF
, deg: 0x00B0
, plusmn: 0x00B1
, sup2: 0x00B2
, sup3: 0x00B3
, acute: 0x00B4
, micro: 0x00B5
, para: 0x00B6
, middot: 0x00B7
, cedil: 0x00B8
, sup1: 0x00B9
, ordm: 0x00BA
, raquo: 0x00BB
, frac14: 0x00BC
, frac12: 0x00BD
, frac34: 0x00BE
, iquest: 0x00BF
, Agrave: 0x00C0
, Aacute: 0x00C1
, Acirc: 0x00C2
, Atilde: 0x00C3
, Auml: 0x00C4
, Aring: 0x00C5
, AElig: 0x00C6
, Ccedil: 0x00C7
, Egrave: 0x00C8
, Eacute: 0x00C9
, Ecirc: 0x00CA
, Euml: 0x00CB
, Igrave: 0x00CC
, Iacute: 0x00CD
, Icirc: 0x00CE
, Iuml: 0x00CF
, ETH: 0x00D0
, Ntilde: 0x00D1
, Ograve: 0x00D2
, Oacute: 0x00D3
, Ocirc: 0x00D4
, Otilde: 0x00D5
, Ouml: 0x00D6
, times: 0x00D7
, Oslash: 0x00D8
, Ugrave: 0x00D9
, Uacute: 0x00DA
, Ucirc: 0x00DB
, Uuml: 0x00DC
, Yacute: 0x00DD
, THORN: 0x00DE
, szlig: 0x00DF
, agrave: 0x00E0
, aacute: 0x00E1
, acirc: 0x00E2
, atilde: 0x00E3
, auml: 0x00E4
, aring: 0x00E5
, aelig: 0x00E6
, ccedil: 0x00E7
, egrave: 0x00E8
, eacute: 0x00E9
, ecirc: 0x00EA
, euml: 0x00EB
, igrave: 0x00EC
, iacute: 0x00ED
, icirc: 0x00EE
, iuml: 0x00EF
, eth: 0x00F0
, ntilde: 0x00F1
, ograve: 0x00F2
, oacute: 0x00F3
, ocirc: 0x00F4
, otilde: 0x00F5
, ouml: 0x00F6
, divide: 0x00F7
, oslash: 0x00F8
, ugrave: 0x00F9
, uacute: 0x00FA
, ucirc: 0x00FB
, uuml: 0x00FC
, yacute: 0x00FD
, thorn: 0x00FE
, yuml: 0x00FF
, OElig: 0x0152
, oelig: 0x0153
, Scaron: 0x0160
, scaron: 0x0161
, Yuml: 0x0178
, fnof: 0x0192
, circ: 0x02C6
, tilde: 0x02DC
, Alpha: 0x0391
, Beta: 0x0392
, Gamma: 0x0393
, Delta: 0x0394
, Epsilon: 0x0395
, Zeta: 0x0396
, Eta: 0x0397
, Theta: 0x0398
, Iota: 0x0399
, Kappa: 0x039A
, Lambda: 0x039B
, Mu: 0x039C
, Nu: 0x039D
, Xi: 0x039E
, Omicron: 0x039F
, Pi: 0x03A0
, Rho: 0x03A1
, Sigma: 0x03A3
, Tau: 0x03A4
, Upsilon: 0x03A5
, Phi: 0x03A6
, Chi: 0x03A7
, Psi: 0x03A8
, Omega: 0x03A9
, alpha: 0x03B1
, beta: 0x03B2
, gamma: 0x03B3
, delta: 0x03B4
, epsilon: 0x03B5
, zeta: 0x03B6
, eta: 0x03B7
, theta: 0x03B8
, iota: 0x03B9
, kappa: 0x03BA
, lambda: 0x03BB
, mu: 0x03BC
, nu: 0x03BD
, xi: 0x03BE
, omicron: 0x03BF
, pi: 0x03C0
, rho: 0x03C1
, sigmaf: 0x03C2
, sigma: 0x03C3
, tau: 0x03C4
, upsilon: 0x03C5
, phi: 0x03C6
, chi: 0x03C7
, psi: 0x03C8
, omega: 0x03C9
, thetasym: 0x03D1
, upsih: 0x03D2
, piv: 0x03D6
, ensp: 0x2002
, emsp: 0x2003
, thinsp: 0x2009
, zwnj: 0x200C
, zwj: 0x200D
, lrm: 0x200E
, rlm: 0x200F
, ndash: 0x2013
, mdash: 0x2014
, lsquo: 0x2018
, rsquo: 0x2019
, sbquo: 0x201A
, ldquo: 0x201C
, rdquo: 0x201D
, bdquo: 0x201E
, dagger: 0x2020
, Dagger: 0x2021
, bull: 0x2022
, hellip: 0x2026
, permil: 0x2030
, prime: 0x2032
, Prime: 0x2033
, lsaquo: 0x2039
, rsaquo: 0x203A
, oline: 0x203E
, frasl: 0x2044
, euro: 0x20AC
, image: 0x2111
, weierp: 0x2118
, real: 0x211C
, trade: 0x2122
, alefsym: 0x2135
, larr: 0x2190
, uarr: 0x2191
, rarr: 0x2192
, darr: 0x2193
, harr: 0x2194
, crarr: 0x21B5
, lArr: 0x21D0
, uArr: 0x21D1
, rArr: 0x21D2
, dArr: 0x21D3
, hArr: 0x21D4
, forall: 0x2200
, part: 0x2202
, exist: 0x2203
, empty: 0x2205
, nabla: 0x2207
, isin: 0x2208
, notin: 0x2209
, ni: 0x220B
, prod: 0x220F
, sum: 0x2211
, minus: 0x2212
, lowast: 0x2217
, radic: 0x221A
, prop: 0x221D
, infin: 0x221E
, ang: 0x2220
, and: 0x2227
, or: 0x2228
, cap: 0x2229
, cup: 0x222A
, int: 0x222B
, there4: 0x2234
, sim: 0x223C
, cong: 0x2245
, asymp: 0x2248
, ne: 0x2260
, equiv: 0x2261
, le: 0x2264
, ge: 0x2265
, sub: 0x2282
, sup: 0x2283
, nsub: 0x2284
, sube: 0x2286
, supe: 0x2287
, oplus: 0x2295
, otimes: 0x2297
, perp: 0x22A5
, sdot: 0x22C5
, lceil: 0x2308
, rceil: 0x2309
, lfloor: 0x230A
, rfloor: 0x230B
, lang: 0x2329
, rang: 0x232A
, loz: 0x25CA
, spades: 0x2660
, clubs: 0x2663
, hearts: 0x2665
, diams: 0x2666
}

},{}],62:[function(require,module,exports){
var startTag = /^<([^\s=\/!>]+)((?:\s+[^\s=\/>]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+)?)?)*)\s*(\/?)\s*>/
  , endTag = /^<\/([^\s=\/!>]+)[^>]*>/
  , comment = /^<!--([\s\S]*?)-->/
  , commentInside = /<!--[\s\S]*?-->/
  , other = /^<([\s\S]*?)>/
  , attr = /([^\s=]+)(?:\s*(=)\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|([^>\s]+))?)?/g
  , rawTagsDefault = /^(style|script)$/i

function empty() {}

function matchEndDefault(tagName) {
  return new RegExp('</' + tagName, 'i')
}

function onStartTag(html, match, handler) {
  var attrs = {}
    , tag = match[0]
    , tagName = match[1]
    , remainder = match[2]
  html = html.slice(tag.length)

  remainder.replace(attr, function(match, name, equals, attr0, attr1, attr2) {
    attrs[name.toLowerCase()] = attr0 || attr1 || attr2 || (equals ? '' : null)
  })
  handler(tag, tagName.toLowerCase(), attrs, html)

  return html
}

function onTag(html, match, handler) {
  var tag = match[0]
    , data = match[1]
  html = html.slice(tag.length)

  handler(tag, data, html)

  return html
}

function onText(html, index, isRawText, handler) {
  var text
  if (~index) {
    text = html.slice(0, index)
    html = html.slice(index)
  } else {
    text = html
    html = ''
  }

  if (text) handler(text, isRawText, html)

  return html
}

function rawEnd(html, ending, offset) {
  offset || (offset = 0)
  var index = html.search(ending)
    , commentMatch = html.match(commentInside)
    , commentEnd
  // Make sure that the ending condition isn't inside of an HTML comment
  if (commentMatch && commentMatch.index < index) {
    commentEnd = commentMatch.index + commentMatch[0].length
    offset += commentEnd
    html = html.slice(commentEnd)
    return rawEnd(html, ending, offset)
  }
  return index + offset
}

module.exports = function(html, options) {
  if (options == null) options = {}

  if (!html) return

  var startHandler = options.start || empty
    , endHandler = options.end || empty
    , textHandler = options.text || empty
    , commentHandler = options.comment || empty
    , otherHandler = options.other || empty
    , matchEnd = options.matchEnd || matchEndDefault
    , errorHandler = options.error
    , rawTags = options.rawTags || rawTagsDefault
    , index, last, match, tagName, err

  while (html) {
    if (html === last) {
      err = new Error('HTML parse error: ' + html)
      if (errorHandler) {
        errorHandler(err)
      } else {
        throw err
      }
    }
    last = html

    if (html[0] === '<') {
      if (match = html.match(startTag)) {
        html = onStartTag(html, match, startHandler)

        tagName = match[1]
        if (rawTags.test(tagName)) {
          index = rawEnd(html, matchEnd(tagName))
          html = onText(html, index, true, textHandler)
        }
        continue
      }

      if (match = html.match(endTag)) {
        match[1] = match[1].toLowerCase()  // tagName
        html = onTag(html, match, endHandler)
        continue
      }

      if (match = html.match(comment)) {
        html = onTag(html, match, commentHandler)
        continue
      }

      if (match = html.match(other)) {
        html = onTag(html, match, otherHandler)
        continue
      }
    }

    index = html.indexOf('<')
    html = onText(html, index, false, textHandler)
  }
}

},{}],53:[function(require,module,exports){
var Doc = require('./Doc');
var util = require('../util');

module.exports = LocalDoc;

function LocalDoc(model, collectionName, id, snapshot) {
  Doc.call(this, model, collectionName, id);
  this.snapshot = snapshot;
  this._updateCollectionData();
}

LocalDoc.prototype = new Doc;

LocalDoc.prototype._updateCollectionData = function() {
  this.collectionData[this.id] = this.snapshot;
};

LocalDoc.prototype.set = function(segments, value, cb) {
  function set(node, key) {
    var previous = node[key];
    node[key] = value;
    return previous;
  }
  return this._apply(segments, set, cb);
};

LocalDoc.prototype.del = function(segments, cb) {
  // Don't do anything if the value is already undefined, since
  // apply creates objects as it traverses, and the del method
  // should not create anything
  var previous = this.get(segments);
  if (previous === void 0) {
    cb();
    return;
  }
  function del(node, key) {
    delete node[key];
    return previous;
  }
  return this._apply(segments, del, cb);
};

LocalDoc.prototype.increment = function(segments, byNumber, cb) {
  var self = this;
  function validate(value) {
    if (typeof value === 'number' || value == null) return;
    return new TypeError(self._errorMessage(
      'increment on non-number', segments, value
    ));
  }
  function increment(node, key) {
    var value = (node[key] || 0) + byNumber;
    node[key] = value;
    return value;
  }
  return this._validatedApply(segments, validate, increment, cb);
};

LocalDoc.prototype.push = function(segments, value, cb) {
  function push(arr) {
    return arr.push(value);
  }
  return this._arrayApply(segments, push, cb);
};

LocalDoc.prototype.unshift = function(segments, value, cb) {
  function unshift(arr) {
    return arr.unshift(value);
  }
  return this._arrayApply(segments, unshift, cb);
};

LocalDoc.prototype.insert = function(segments, index, values, cb) {
  function insert(arr) {
    arr.splice.apply(arr, [index, 0].concat(values));
    return arr.length;
  }
  return this._arrayApply(segments, insert, cb);
};

LocalDoc.prototype.pop = function(segments, cb) {
  function pop(arr) {
    return arr.pop();
  }
  return this._arrayApply(segments, pop, cb);
};

LocalDoc.prototype.shift = function(segments, cb) {
  function shift(arr) {
    return arr.shift();
  }
  return this._arrayApply(segments, shift, cb);
};

LocalDoc.prototype.remove = function(segments, index, howMany, cb) {
  function remove(arr) {
    return arr.splice(index, howMany);
  }
  return this._arrayApply(segments, remove, cb);
};

LocalDoc.prototype.move = function(segments, from, to, howMany, cb) {
  function move(arr) {
    // Remove from old location
    var values = arr.splice(from, howMany);
    // Insert in new location
    arr.splice.apply(arr, [to, 0].concat(values));
    return values;
  }
  return this._arrayApply(segments, move, cb);
};

LocalDoc.prototype.stringInsert = function(segments, index, value, cb) {
  var self = this;
  function validate(value) {
    if (typeof value === 'string' || value == null) return;
    return new TypeError(self._errorMessage(
      'stringInsert on non-string', segments, value
    ));
  }
  function stringInsert(node, key) {
    var previous = node[key];
    if (previous == null) {
      node[key] = value;
      return previous;
    }
    node[key] = previous.slice(0, index) + value + previous.slice(index);
    return previous;
  }
  return this._validatedApply(segments, validate, stringInsert, cb);
};

LocalDoc.prototype.stringRemove = function(segments, index, howMany, cb) {
  var self = this;
  function validate(value) {
    if (typeof value === 'string' || value == null) return;
    return new TypeError(self._errorMessage(
      'stringRemove on non-string', segments, value
    ));
  }
  function stringRemove(node, key) {
    var previous = node[key];
    if (previous == null) return previous;
    if (index < 0) index += previous.length;
    node[key] = previous.slice(0, index) + previous.slice(index + howMany);
    return previous;
  }
  return this._validatedApply(segments, validate, stringRemove, cb);
};

LocalDoc.prototype.get = function(segments) {
  return util.lookup(segments, this.snapshot);
};

/**
 * @param {Array} segments is the array representing a path
 * @param {Function} fn(node, key) applies a mutation on node[key]
 * @return {Object} returns the return value of fn(node, key)
 */
LocalDoc.prototype._createImplied = function(segments, fn) {
  var node = this;
  var key = 'snapshot';
  var i = 0;
  var nextKey = segments[i++];
  while (nextKey != null) {
    // Get or create implied object or array
    node = node[key] || (node[key] = /^\d+$/.test(nextKey) ? [] : {});
    key = nextKey;
    nextKey = segments[i++];
  }
  return fn(node, key);
};

LocalDoc.prototype._apply = function(segments, fn, cb) {
  var out = this._createImplied(segments, fn);
  this._updateCollectionData();
  cb();
  return out;
};

LocalDoc.prototype._validatedApply = function(segments, validate, fn, cb) {
  var out = this._createImplied(segments, function(node, key) {
    var err = validate(node[key]);
    if (err) return cb(err);
    return fn(node, key);
  });
  this._updateCollectionData();
  cb();
  return out;
};

LocalDoc.prototype._arrayApply = function(segments, fn, cb) {
  // Lookup a pointer to the property or nested property &
  // return the current value or create a new array
  var arr = this._createImplied(segments, nodeCreateArray);

  if (!Array.isArray(arr)) {
    var message = this._errorMessage(fn.name + ' on non-array', segments, arr);
    var err = new TypeError(message);
    return cb(err);
  }
  var out = fn(arr);
  this._updateCollectionData();
  cb();
  return out;
};

function nodeCreateArray(node, key) {
  return node[key] || (node[key] = []);
}

},{"./Doc":65,"../util":12}],66:[function(require,module,exports){
/**
 * RemoteDoc adapts the ShareJS operation protocol to Racer's mutator
 * interface.
 *
 * 1. It maps Racer's mutator methods to outgoing ShareJS operations.
 * 2. It maps incoming ShareJS operations to Racer events.
 */

var Doc = require('./Doc');
var util = require('../util');

module.exports = RemoteDoc;

function RemoteDoc(model, collectionName, id, data) {
  Doc.call(this, model, collectionName, id);
  var shareDoc = this.shareDoc = model._getOrCreateShareDoc(collectionName, id, data);
  this.createdLocally = false;
  this.model = model = model.pass({$remote: true});
  this._passStringInsert = model.pass({$original: 'stringInsert'})._pass;
  this._passStringRemove = model.pass({$original: 'stringRemove'})._pass;
  this._updateCollectionData();

  var doc = this;
  shareDoc.on('op', function(op, isLocal) {
    // Don't emit on local operations, since they are emitted in the mutator
    if (isLocal) return;
    doc._updateCollectionData();
    doc._onOp(op);
  });
  shareDoc.on('del', function(isLocal, previous) {
    // Calling the shareDoc.del method does not emit an operation event,
    // so we create the appropriate event here.
    if (isLocal) return;
    doc._updateCollectionData();
    model.emit('change', [collectionName, id], [void 0, previous, model._pass]);
  });
  shareDoc.on('create', function(isLocal) {
    // Local creates should not emit an event, since they only happen
    // implicitly as a result of another mutation, and that operation will
    // emit the appropriate event. Remote creates can set the snapshot data
    // without emitting an operation event, so an event needs to be emitted
    // for them.
    if (isLocal) {
      // Track when a document was created by this client, so that we don't
      // emit a load event when subsequently subscribed
      doc.createdLocally = true;
      return;
    }
    doc._updateCollectionData();
    var value = shareDoc.snapshot;
    model.emit('change', [collectionName, id], [value, void 0, model._pass]);
  });
}

RemoteDoc.prototype = new Doc;

RemoteDoc.prototype._updateCollectionData = function() {
  this.collectionData[this.id] = this.shareDoc.snapshot;
};

RemoteDoc.prototype.set = function(segments, value, cb) {
  if (segments.length === 0 && !this.shareDoc.type) {
    this.shareDoc.create('json0', value, cb);
    this._updateCollectionData();
    return;
  }
  var previous = this._createImplied(segments);
  var lastSegment = segments[segments.length - 1];
  if (previous instanceof ImpliedOp) {
    previous.value[lastSegment] = value;
    this.shareDoc.submitOp(previous.op, cb);
    this._updateCollectionData();
    return;
  }
  var op = (isArrayIndex(lastSegment)) ?
    (previous == null) ?
      [new ListInsertOp(segments.slice(0, -1), lastSegment, value)] :
      [new ListReplaceOp(segments.slice(0, -1), lastSegment, previous, value)] :
    (previous == null) ?
      [new ObjectInsertOp(segments, value)] :
      [new ObjectReplaceOp(segments, previous, value)];
  this.shareDoc.submitOp(op, cb);
  this._updateCollectionData();
  return previous;
};

RemoteDoc.prototype.del = function(segments, cb) {
  if (segments.length === 0) {
    var previous = this.get();
    this.shareDoc.del(cb);
    this._updateCollectionData();
    return previous;
  }
  // Don't do anything if the value is already undefined, since
  // the del method should not create anything
  var previous = this.get(segments);
  if (previous === void 0) {
    cb();
    return;
  }
  var op = [new ObjectDeleteOp(segments, previous)];
  this.shareDoc.submitOp(op, cb);
  this._updateCollectionData();
  return previous;
};

RemoteDoc.prototype.increment = function(segments, byNumber, cb) {
  var previous = this._createImplied(segments);
  if (previous instanceof ImpliedOp) {
    var lastSegment = segments[segments.length - 1];
    previous.value[lastSegment] = byNumber;
    this.shareDoc.submitOp(previous.op, cb);
    this._updateCollectionData();
    return byNumber;
  }
  if (previous == null) {
    var lastSegment = segments[segments.length - 1];
    var op = (isArrayIndex(lastSegment)) ?
      [new ListInsertOp(segments.slice(0, -1), lastSegment, byNumber)] :
      [new ObjectInsertOp(segments, byNumber)];
    this.shareDoc.submitOp(op, cb);
    this._updateCollectionData();
    return byNumber;
  }
  var op = [new IncrementOp(segments, byNumber)];
  this.shareDoc.submitOp(op, cb);
  this._updateCollectionData();
  return previous + byNumber;
};

RemoteDoc.prototype.push = function(segments, value, cb) {
  var shareDoc = this.shareDoc;
  function push(arr, fnCb) {
    var op = [new ListInsertOp(segments, arr.length, value)];
    shareDoc.submitOp(op, fnCb);
    return arr.length;
  }
  return this._arrayApply(segments, push, cb);
};

RemoteDoc.prototype.unshift = function(segments, value, cb) {
  var shareDoc = this.shareDoc;
  function unshift(arr, fnCb) {
    var op = [new ListInsertOp(segments, 0, value)];
    shareDoc.submitOp(op, fnCb);
    return arr.length;
  }
  return this._arrayApply(segments, unshift, cb);
};

RemoteDoc.prototype.insert = function(segments, index, values, cb) {
  var shareDoc = this.shareDoc;
  function insert(arr, fnCb) {
    var op = createInsertOp(segments, index, values);
    shareDoc.submitOp(op, fnCb);
    return arr.length;
  }
  return this._arrayApply(segments, insert, cb);
};

function createInsertOp(segments, index, values) {
  if (!Array.isArray(values)) {
    return [new ListInsertOp(segments, index, values)];
  }
  var op = [];
  for (var i = 0, len = values.length; i < len; i++) {
    op.push(new ListInsertOp(segments, index++, values[i]));
  }
  return op;
}

RemoteDoc.prototype.pop = function(segments, cb) {
  var shareDoc = this.shareDoc;
  function pop(arr, fnCb) {
    var index = arr.length - 1;
    var value = arr[index];
    var op = [new ListRemoveOp(segments, index, value)];
    shareDoc.submitOp(op, fnCb);
    return value;
  }
  return this._arrayApply(segments, pop, cb);
};

RemoteDoc.prototype.shift = function(segments, cb) {
  var shareDoc = this.shareDoc;
  function shift(arr, fnCb) {
    var value = arr[0];
    var op = [new ListRemoveOp(segments, 0, value)];
    shareDoc.submitOp(op, fnCb);
    return value;
  }
  return this._arrayApply(segments, shift, cb);
};

RemoteDoc.prototype.remove = function(segments, index, howMany, cb) {
  var shareDoc = this.shareDoc;
  function remove(arr, fnCb) {
    var values = arr.slice(index, index + howMany);
    var op = [];
    for (var i = 0, len = values.length; i < len; i++) {
      op.push(new ListRemoveOp(segments, index, values[i]));
    }
    shareDoc.submitOp(op, fnCb);
    return values;
  }
  return this._arrayApply(segments, remove, cb);
};

RemoteDoc.prototype.move = function(segments, from, to, howMany, cb) {
  var shareDoc = this.shareDoc;
  function move(arr, fnCb) {
    // Get the return value
    var values = arr.slice(from, from + howMany);

    // Build an op that moves each item individually
    var op = [];
    for (var i = 0; i < howMany; i++) {
      op.push(new ListMoveOp(segments, (from < to) ? from : from + howMany - 1, (from < to) ? to + howMany - 1 : to));
    }
    shareDoc.submitOp(op, fnCb);

    return values;
  }
  return this._arrayApply(segments, move, cb);
};

RemoteDoc.prototype.stringInsert = function(segments, index, value, cb) {
  var previous = this._createImplied(segments);
  if (previous instanceof ImpliedOp) {
    var lastSegment = segments[segments.length - 1];
    previous.value[lastSegment] = value;
    this.shareDoc.submitOp(previous.op, cb);
    this._updateCollectionData();
    return;
  }
  if (previous == null) {
    var lastSegment = segments[segments.length - 1];
    var op = (isArrayIndex(lastSegment)) ?
      [new ListInsertOp(segments.slice(0, -1), lastSegment, value)] :
      [new ObjectInsertOp(segments, value)];
    this.shareDoc.submitOp(op, cb);
    this._updateCollectionData();
    return previous;
  }
  var op = [new StringInsertOp(segments, index, value)];
  this.shareDoc.submitOp(op, cb);
  this._updateCollectionData();
  return previous;
};

RemoteDoc.prototype.stringRemove = function(segments, index, howMany, cb) {
  var previous = this._createImplied(segments);
  if (previous instanceof ImpliedOp) return;
  if (previous == null) return previous;
  var removed = previous.slice(index, index + howMany);
  var op = [new StringRemoveOp(segments, index, removed)];
  this.shareDoc.submitOp(op, cb);
  this._updateCollectionData();
  return previous;
};

RemoteDoc.prototype.get = function(segments) {
  return util.lookup(segments, this.shareDoc.snapshot);
};

RemoteDoc.prototype._createImplied = function(segments) {
  if (!this.shareDoc.type) {
    this.shareDoc.create('json0');
  }
  var parent = this.shareDoc;
  var key = 'snapshot';
  var node = parent[key];
  var i = 0;
  var nextKey = segments[i++];
  var op, value;
  while (nextKey != null) {
    if (!node) {
      if (op) {
        value = value[key] = isArrayIndex(nextKey) ? [] : {};
      } else {
        value = isArrayIndex(nextKey) ? [] : {};
        op = (Array.isArray(parent)) ?
          new ListInsertOp(segments.slice(0, i - 2), key, value) :
          new ObjectInsertOp(segments.slice(0, i - 1), value);
      }
      node = value;
    }
    parent = node;
    key = nextKey;
    node = parent[key];
    nextKey = segments[i++];
  }
  if (op) return new ImpliedOp(op, value);
  return node;
};

function ImpliedOp(op, value) {
  this.op = op;
  this.value = value;
}

RemoteDoc.prototype._arrayApply = function(segments, fn, cb) {
  var arr = this._createImplied(segments);
  if (arr instanceof ImpliedOp) {
    this.shareDoc.submitOp(arr.op);
    arr = this.get(segments);
  } else if (arr == null) {
    var lastSegment = segments[segments.length - 1];
    var op = (isArrayIndex(lastSegment)) ?
      [new ListInsertOp(segments.slice(0, -1), lastSegment, [])] :
      [new ObjectInsertOp(segments, [])];
    this.shareDoc.submitOp(op);
    arr = this.get(segments);
  }

  if (!Array.isArray(arr)) {
    var message = this._errorMessage(fn.name + ' on non-array', segments, arr);
    var err = new TypeError(message);
    return cb(err);
  }
  var out = fn(arr, cb);
  this._updateCollectionData();
  return out;
};

RemoteDoc.prototype._onOp = function(op) {
  var item = op[0];
  var segments = [this.collectionName, this.id].concat(item.p);
  var model = this.model;

  // ObjectReplaceOp, ObjectInsertOp, or ObjectDeleteOp
  if (defined(item.oi) || defined(item.od)) {
    var value = item.oi;
    var previous = item.od;
    model.emit('change', segments, [value, previous, model._pass]);

  // ListReplaceOp
  } else if (defined(item.li) && defined(item.ld)) {
    var value = item.li;
    var previous = item.ld;
    model.emit('change', segments, [value, previous, model._pass]);

  // ListInsertOp
  } else if (defined(item.li)) {
    var index = segments[segments.length - 1];
    var values = [item.li];
    model.emit('insert', segments.slice(0, -1), [index, values, model._pass]);

  // ListRemoveOp
  } else if (defined(item.ld)) {
    var index = segments[segments.length - 1];
    var removed = [item.ld];
    model.emit('remove', segments.slice(0, -1), [index, removed, model._pass]);

  // ListMoveOp
  } else if (defined(item.lm)) {
    var from = segments[segments.length - 1];
    var to = item.lm - 1;
    var howMany = 1;
    model.emit('move', segments.slice(0, -1), [from, to, howMany, model._pass]);

  // StringInsertOp
  } else if (defined(item.si)) {
    var index = segments[segments.length - 1];
    var text = item.si;
    segments = segments.slice(0, -1);
    model.emit('stringInsert', segments, [index, text, model._pass]);
    var value = model._get(segments);
    var previous = value.slice(0, index) + value.slice(index + text.length);
    model.emit('change', segments, [value, previous, this._passStringInsert]);

  // StringRemoveOp
  } else if (defined(item.sd)) {
    var index = segments[segments.length - 1];
    var text = item.sd;
    var howMany = text.length;
    segments = segments.slice(0, -1);
    model.emit('stringRemove', segments, [index, howMany, model._pass]);
    var value = model._get(segments);
    var previous = value.slice(0, index) + text + value.slice(index);
    model.emit('change', segments, [value, previous, this._passStringRemove]);

  // IncrementOp
  } else if (defined(item.na)) {
    var value = this.get(item.p);
    var previous = value - item.na;
    model.emit('change', segments, [value, previous, model._pass]);
  }
};

function ObjectReplaceOp(segments, before, after) {
  this.p = castSegments(segments);
  this.od = before;
  this.oi = (after === void 0) ? null : after;
}
function ObjectInsertOp(segments, value) {
  this.p = castSegments(segments);
  this.oi = (value === void 0) ? null : value;
}
function ObjectDeleteOp(segments, value) {
  this.p = castSegments(segments);
  this.od = (value === void 0) ? null : value;
}
function ListReplaceOp(segments, index, before, after) {
  this.p = castSegments(segments.concat(index));
  this.ld = before;
  this.li = (after === void 0) ? null : after;
}
function ListInsertOp(segments, index, value) {
  this.p = castSegments(segments.concat(index));
  this.li = (value === void 0) ? null : value;
}
function ListRemoveOp(segments, index, value) {
  this.p = castSegments(segments.concat(index));
  this.ld = (value === void 0) ? null : value;
}
function ListMoveOp(segments, from, to) {
  this.p = castSegments(segments.concat(from));
  this.lm = to;
}
function StringInsertOp(segments, index, value) {
  this.p = castSegments(segments.concat(index));
  this.si = value;
}
function StringRemoveOp(segments, index, value) {
  this.p = castSegments(segments.concat(index));
  this.sd = value;
}
function IncrementOp(segments, byNumber) {
  this.p = castSegments(segments);
  this.na = byNumber;
}

function defined(value) {
  return value !== void 0;
}

function castSegments(segments) {
  // Cast number path segments from strings to numbers
  for (var i = segments.length; i--;) {
    var segment = segments[i];
    if (typeof segment === 'string' && isArrayIndex(segment)) {
      segments[i] = +segment;
    }
  }
  return segments;
}

function isArrayIndex(segment) {
  return (/^[0-9]+$/).test(segment);
}

},{"./Doc":65,"../util":12}],35:[function(require,module,exports){
var share = require('share/lib/client');
var Channel = require('../Channel');
var Model = require('./Model');
var LocalDoc = require('./LocalDoc');
var RemoteDoc = require('./RemoteDoc');

Model.prototype._createConnection = function(bundle) {
  // Model::_createSocket should be defined by the socket plugin
  this.root.socket = this._createSocket(bundle);

  // The Share connection will bind to the socket by defining the onopen,
  // onmessage, etc. methods
  var shareConnection = this.root.shareConnection = new share.Connection(this.root.socket);
  var segments = ['$connection', 'state'];
  var states = ['connecting', 'connected', 'disconnected', 'stopped'];
  var model = this;
  states.forEach(function(state) {
    shareConnection.on(state, function() {
      model._set(segments, state);
    });
  });
  this._set(segments, 'connected');

  // Wrap the socket methods on top of Share's methods
  this._createChannel();
};

Model.prototype.connect = function() {
  this.root.socket.open();
};
Model.prototype.disconnect = function() {
  this.root.socket.close();
};
Model.prototype.reconnect = function() {
  this.disconnect();
  this.connect();
};

Model.prototype._createChannel = function() {
  this.root.channel = new Channel(this.root.socket);
};

Model.prototype._getOrCreateShareDoc = function(collectionName, id, data) {
  var shareDoc = this.root.shareConnection.get(collectionName, id, data);
  shareDoc.incremental = true;
  return shareDoc;
};

Model.prototype._getDocConstructor = function(name) {
  // Whether the collection is local or remote is determined by its name.
  // Collections starting with an underscore ('_') are for user-defined local
  // collections, those starting with a dollar sign ('$'') are for
  // framework-defined local collections, and all others are remote.
  var firstCharcter = name.charAt(0);
  var isLocal = (firstCharcter === '_' || firstCharcter === '$');
  return (isLocal) ? LocalDoc : RemoteDoc;
};

},{"../Channel":63,"./Model":29,"./LocalDoc":53,"./RemoteDoc":66,"share/lib/client":67}],64:[function(require,module,exports){
(function(){
/**
 * Module dependencies.
 */

/**
 * toString ref.
 */

var toString = {}.toString;

/**
 * Return ETag for `body`.
 *
 * @param {String|Buffer} body
 * @return {String}
 * @api private
 */

exports.etag = function(body){
  return '"' + crc32.signed(body) + '"';
};

/**
 * Make `locals()` bound to the given `obj`.
 *
 * This is used for `app.locals` and `res.locals`.
 *
 * @param {Object} obj
 * @return {Function}
 * @api private
 */

exports.locals = function(obj){
  function locals(obj){
    for (var key in obj) locals[key] = obj[key];
    return obj;
  };

  return locals;
};

/**
 * Check if `path` looks absolute.
 *
 * @param {String} path
 * @return {Boolean}
 * @api private
 */

exports.isAbsolute = function(path){
  if ('/' == path[0]) return true;
  if (':' == path[1] && '\\' == path[2]) return true;
};

/**
 * Flatten the given `arr`.
 *
 * @param {Array} arr
 * @return {Array}
 * @api private
 */

exports.flatten = function(arr, ret){
  var ret = ret || []
    , len = arr.length;
  for (var i = 0; i < len; ++i) {
    if (Array.isArray(arr[i])) {
      exports.flatten(arr[i], ret);
    } else {
      ret.push(arr[i]);
    }
  }
  return ret;
};

/**
 * Normalize the given `type`, for example "html" becomes "text/html".
 *
 * @param {String} type
 * @return {Object}
 * @api private
 */

exports.normalizeType = function(type){
  return ~type.indexOf('/')
    ? acceptParams(type)
    : { value: mime.lookup(type), params: {} };
};

/**
 * Normalize `types`, for example "html" becomes "text/html".
 *
 * @param {Array} types
 * @return {Array}
 * @api private
 */

exports.normalizeTypes = function(types){
  var ret = [];

  for (var i = 0; i < types.length; ++i) {
    ret.push(exports.normalizeType(types[i]));
  }

  return ret;
};

/**
 * Return the acceptable type in `types`, if any.
 *
 * @param {Array} types
 * @param {String} str
 * @return {String}
 * @api private
 */

exports.acceptsArray = function(types, str){
  // accept anything when Accept is not present
  if (!str) return types[0];

  // parse
  var accepted = exports.parseAccept(str)
    , normalized = exports.normalizeTypes(types)
    , len = accepted.length;

  for (var i = 0; i < len; ++i) {
    for (var j = 0, jlen = types.length; j < jlen; ++j) {
      if (exports.accept(normalized[j], accepted[i])) {
        return types[j];
      }
    }
  }
};

/**
 * Check if `type(s)` are acceptable based on
 * the given `str`.
 *
 * @param {String|Array} type(s)
 * @param {String} str
 * @return {Boolean|String}
 * @api private
 */

exports.accepts = function(type, str){
  if ('string' == typeof type) type = type.split(/ *, */);
  return exports.acceptsArray(type, str);
};

/**
 * Check if `type` array is acceptable for `other`.
 *
 * @param {Object} type
 * @param {Object} other
 * @return {Boolean}
 * @api private
 */

exports.accept = function(type, other){
  var t = type.value.split('/');
  return (t[0] == other.type || '*' == other.type)
    && (t[1] == other.subtype || '*' == other.subtype)
    && paramsEqual(type.params, other.params);
};

/**
 * Check if accept params are equal.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Boolean}
 * @api private
 */

function paramsEqual(a, b){
  return !Object.keys(a).some(function(k) {
    return a[k] != b[k];
  });
}

/**
 * Parse accept `str`, returning
 * an array objects containing
 * `.type` and `.subtype` along
 * with the values provided by
 * `parseQuality()`.
 *
 * @param {Type} name
 * @return {Type}
 * @api private
 */

exports.parseAccept = function(str){
  return exports
    .parseParams(str)
    .map(function(obj){
      var parts = obj.value.split('/');
      obj.type = parts[0];
      obj.subtype = parts[1];
      return obj;
    });
};

/**
 * Parse quality `str`, returning an
 * array of objects with `.value`,
 * `.quality` and optional `.params`
 *
 * @param {String} str
 * @return {Array}
 * @api private
 */

exports.parseParams = function(str){
  return str
    .split(/ *, */)
    .map(acceptParams)
    .filter(function(obj){
      return obj.quality;
    })
    .sort(function(a, b){
      if (a.quality === b.quality) {
        return a.originalIndex - b.originalIndex;
      } else {
        return b.quality - a.quality;
      }
    });
};

/**
 * Parse accept params `str` returning an
 * object with `.value`, `.quality` and `.params`.
 * also includes `.originalIndex` for stable sorting
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function acceptParams(str, index) {
  var parts = str.split(/ *; */);
  var ret = { value: parts[0], quality: 1, params: {}, originalIndex: index };

  for (var i = 1; i < parts.length; ++i) {
    var pms = parts[i].split(/ *= */);
    if ('q' == pms[0]) {
      ret.quality = parseFloat(pms[1]);
    } else {
      ret.params[pms[0]] = pms[1];
    }
  }

  return ret;
}

/**
 * Escape special characters in the given string of html.
 *
 * @param  {String} html
 * @return {String}
 * @api private
 */

exports.escape = function(html) {
  return String(html)
    .replace(/&/g, '&amp;')
    .replace(/"/g, '&quot;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
};

/**
 * Normalize the given path string,
 * returning a regular expression.
 *
 * An empty array should be passed,
 * which will contain the placeholder
 * key names. For example "/user/:id" will
 * then contain ["id"].
 *
 * @param  {String|RegExp|Array} path
 * @param  {Array} keys
 * @param  {Boolean} sensitive
 * @param  {Boolean} strict
 * @return {RegExp}
 * @api private
 */

exports.pathRegexp = function(path, keys, sensitive, strict) {
  if (toString.call(path) == '[object RegExp]') return path;
  if (Array.isArray(path)) path = '(' + path.join('|') + ')';
  path = path
    .concat(strict ? '' : '/?')
    .replace(/\/\(/g, '(?:/')
    .replace(/(\/)?(\.)?:(\w+)(?:(\(.*?\)))?(\?)?(\*)?/g, function(_, slash, format, key, capture, optional, star){
      keys.push({ name: key, optional: !! optional });
      slash = slash || '';
      return ''
        + (optional ? '' : slash)
        + '(?:'
        + (optional ? slash : '')
        + (format || '') + (capture || (format && '([^/.]+?)' || '([^/]+?)')) + ')'
        + (optional || '')
        + (star ? '(/*)?' : '');
    })
    .replace(/([\/.])/g, '\\$1')
    .replace(/\*/g, '(.*)');
  return new RegExp('^' + path + '$', sensitive ? '' : 'i');
}

})()
},{}],29:[function(require,module,exports){
var uuid = require('node-uuid');

Model.INITS = [];

module.exports = Model;

function Model(options) {
  this.root = this;

  var inits = Model.INITS;
  options || (options = {});
  for (var i = 0; i < inits.length; i++) {
    inits[i](this, options);
  }
}

Model.prototype.id = function() {
  return uuid.v4();
};

Model.prototype._child = function() {
  return new ChildModel(this);
};

function ChildModel(model) {
  // Shared properties should be accessed via the root. This makes inheritance
  // cheap and easily extensible
  this.root = model.root;

  // EventEmitter methods access these properties directly, so they must be
  // inherited manually instead of via the root
  this._events = model._events;
  this._maxListeners = model._maxListeners;

  // Properties specific to a child instance
  this._context = model._context;
  this._at = model._at;
  this._pass = model._pass;
  this._silent = model._silent;
}
ChildModel.prototype = new Model;

},{"node-uuid":68}],65:[function(require,module,exports){
module.exports = Doc;

function Doc(model, collectionName, id) {
  this.collectionName = collectionName;
  this.id = id;
  this.collectionData = model && model.data[collectionName];
}

Doc.prototype.path = function(segments) {
  return this.collectionName + '.' + this.id + '.' + segments.join('.');
};

Doc.prototype._errorMessage = function(description, segments, value) {
  return description + ' at ' + this.path(segments) + ': ' +
    JSON.stringify(value, null, 2);
};

},{}],34:[function(require,module,exports){
var util = require('../util');
var Model = require('./Model');
var arrayDiff = require('arraydiff');

Model.prototype.setDiff = function() {
  var subpath, value, options, cb;
  if (arguments.length === 1) {
    value = arguments[0];
  } else if (arguments.length === 2) {
    subpath = arguments[0];
    value = arguments[1];
  } else if (arguments.length === 3) {
    subpath = arguments[0];
    value = arguments[1];
    if (typeof arguments[2] === 'function') {
      cb = arguments[2];
    } else {
      options = arguments[2];
    }
  } else {
    subpath = arguments[0];
    value = arguments[1];
    options = arguments[2];
    cb = arguments[3];
  }
  var segments = this._splitPath(subpath);
  return this._setDiff(segments, value, options, cb);
};
Model.prototype._setDiff = function(segments, value, options, cb) {
  segments = this._dereference(segments);
  var equalFn = (options && options.equal) || util.equal;
  var isEach = options && options.each;
  var model = this;
  function setDiff(doc, docSegments, fnCb) {
    var before = doc.get(docSegments);
    if (equalFn(before, value)) return fnCb();
    var group = util.asyncGroup(fnCb);
    doDiff(model, doc, segments, before, value, equalFn, group, isEach);
  }
  return this._mutate(segments, setDiff, cb);
};
Model.prototype._setArrayDiff = function(segments, value, cb) {
  segments = this._dereference(segments);
  var model = this;
  function setArrayDiff(doc, docSegments, fnCb) {
    var before = doc.get(docSegments);
    if (before === value) return fnCb();
    if (!Array.isArray(before) || !Array.isArray(value)) {
      applySet(model, doc, segments, value, fnCb);
      return;
    }
    var diff = arrayDiff(before, value);
    if (!diff.length) return fnCb();
    var group = util.asyncGroup(fnCb);
    applyArrayDiff(model, doc, segments, diff, group);
  }
  return this._mutate(segments, setArrayDiff, cb);
};

/**
 * @param {Object} doc
 * @param {String} doc.collectionName
 * @param {String} doc.id
 * @param {Object} doc.snapshot
 * @param {Array} segments
 * @param {Object} before
 * @param {Object} after
 * @param {Function} group
 * @param {Boolean} isEach
 */
function doDiff(model, doc, segments, before, after, equalFn, group, isEach) {
  if (typeof before !== 'object' || !before ||
      typeof after !== 'object' || !after) {
    // Set the entire value if not diffable
    applySet(model, doc, segments, after, group());
    return;
  }
  if (Array.isArray(before) && Array.isArray(after)) {
    var diff = arrayDiff(before, after, equalFn);
    if (!diff.length) return group()();
    // If the only change is a single item replacement, diff the item instead
    if (
      diff.length === 2 &&
      diff[0].index === diff[1].index &&
      diff[0] instanceof arrayDiff.RemoveDiff &&
      diff[0].howMany === 1 &&
      diff[1] instanceof arrayDiff.InsertDiff &&
      diff[1].values.length === 1
    ) {
      var index = diff[0].index;
      var itemSegments = segments.concat(index);
      doDiff(model, doc, itemSegments, before[index], after[index], equalFn, group);
      return;
    }
    applyArrayDiff(model, doc, segments, diff, group);
    return;
  }
  if (!isEach) {
    // Delete keys that were in before but not after
    for (var key in before) {
      if (key in after) continue;
      var itemSegments = segments.concat(key);
      var docSegments = itemSegments.slice(2);
      var previous = doc.del(docSegments, group());
      model.emit('change', itemSegments, [void 0, previous, model._pass]);
    }
  }
  // Diff each property in after
  for (var key in after) {
    if (equalFn(before[key], after[key])) continue;
    var itemSegments = segments.concat(key);
    doDiff(model, doc, itemSegments, before[key], after[key], equalFn, group);
  }
}

function applySet(model, doc, segments, after, cb) {
  var docSegments = segments.slice(2);
  var previous = doc.set(docSegments, after, cb);
  model.emit('change', segments, [after, previous, model._pass]);
}

function applyArrayDiff(model, doc, segments, diff, group) {
  var docSegments = segments.slice(2);
  for (var i = 0, len = diff.length; i < len; i++) {
    var item = diff[i];
    if (item instanceof arrayDiff.InsertDiff) {
      // Insert
      doc.insert(docSegments, item.index, item.values, group());
      model.emit('insert', segments, [item.index, item.values, model._pass]);
    } else if (item instanceof arrayDiff.RemoveDiff) {
      // Remove
      var removed = doc.remove(docSegments, item.index, item.howMany, group());
      model.emit('remove', segments, [item.index, removed, model._pass]);
    } else if (item instanceof arrayDiff.MoveDiff) {
      // Move
      var moved = doc.move(docSegments, item.from, item.to, item.howMany, group());
      model.emit('move', segments, [item.from, item.to, moved.length, model._pass]);
    }
  }
}

},{"../util":12,"./Model":29,"arraydiff":69}],37:[function(require,module,exports){
(function(process){var util = require('../util');
var Model = require('./Model');
var arrayDiff = require('arraydiff');
var deepEquals = require('deep-is');

module.exports = Query;

Model.INITS.push(function(model) {
  model.root._queries = new Queries;
  if (model.root.fetchOnly) return;
  model.on('all', function(segments) {
    // Updated async, since this is likely the result of an operation that
    // includes creating the doc, and we would like that to happen before
    // sending the subscribe message
    process.nextTick(function() {
      var map = model.root._queries.map;
      for (var hash in map) {
        var query = map[hash];
        if (query.isPathQuery && query.shareQuery && util.mayImpact(query.expression, segments)) {
          var ids = pathIds(model, query.expression);
          var previousIds = model._get(query.idSegments);
          query._onChange(ids, previousIds);
        }
      }
    });
  });
});

/**
 * @param {String} collectionName
 * @param {Object} expression
 * @param {String} source
 * @return {Query}
 */
Model.prototype.query = function(collectionName, expression, source) {
  if (typeof expression.path === 'function' || typeof expression !== 'object') {
    expression = this._splitPath(expression);
  }
  var query = this.root._queries.get(collectionName, expression, source);
  if (query) return query;
  query = new Query(this, collectionName, expression, source);
  this.root._queries.add(query);
  return query;
};

/**
 * Called during initialization of the bundle on page load.
 * @param {Array} items
 * @param {Array} items[*]
 * @param {String} items[*][0] collectionName
 * @param {Object} items[*][1] expression
 * @param {String} items[*][2] source
 * @param {Number} items[*][3] subscribeCount
 * @param {Number} items[*][4] fetchCount
 * @param {Array}  items[*][5] fetchIds
 */
Model.prototype._initQueries = function(items) {
  for (var i = 0; i < items.length; i++) {
    var item = items[i];
    var query = new Query(this, item[0], item[1], item[2], item[3], item[4], item[5]);
    var count = query.fetchCount;
    while (count--) this.emit('fetchQuery', query, this._context);
    var count = query.subscribeCount;
    query.subscribeCount = 0;
    while (count--) query.subscribe();
  }
};

function QueriesMap() {}

function Queries() {
  this.map = new QueriesMap;
}
Queries.prototype.add = function(query) {
  this.map[query.hash] = query;
};
Queries.prototype.remove = function(query) {
  delete this.map[query.hash];
};
Queries.prototype.get = function(collectionName, expression, source) {
  var hash = queryHash(collectionName, expression, source);
  return this.map[hash];
};
Queries.prototype.toJSON = function() {
  var out = [];
  for (var hash in this.map) {
    var query = this.map[hash];
    if (query.subscribeCount || query.fetchCount) {
      out.push(query.serialize());
    }
  }
  return out;
};

/**
 * @private
 * @constructor
 * @param {Model} model
 * @param {Object} collectionName
 * @param {Object} expression
 * @param {String} source (e.g., 'solr')
 * @param {Number} subscribeCount
 * @param {Number} fetchCount
 * @param {Array<Array<String>>} fetchIds
 */
function Query(model, collectionName, expression, source, subscribeCount, fetchCount, fetchIds) {
  this.model = model.pass({$query: this});
  this.collectionName = collectionName;
  this.expression = expression;
  this.source = source;
  this.hash = queryHash(collectionName, expression, source);
  this.segments = ['$queries', this.hash];
  this.idSegments = ['$queries', this.hash, 'ids'];
  this.extraSegments = ['$queries', this.hash, 'extra'];
  this.isPathQuery = Array.isArray(expression);

  this._pendingSubscribeCallbacks = [];

  // These are used to help cleanup appropriately when calling unsubscribe and
  // unfetch. A query won't be fully cleaned up until unfetch and unsubscribe
  // are called the same number of times that fetch and subscribe were called.
  this.subscribeCount = subscribeCount || 0;
  this.fetchCount = fetchCount || 0;
  // The list of ids at the time of each fetch is pushed onto fetchIds, so
  // that unfetchDoc can be called the same number of times as fetchDoc
  this.fetchIds = fetchIds || [];

  this.created = false;
  this.shareQuery = null;
}

Query.prototype.create = function() {
  this.created = true;
  this.model.root._queries.add(this);
};

Query.prototype.destroy = function() {
  this.created = false;
  if (this.shareQuery) {
    this.shareQuery.destroy();
    this.shareQuery = null;
  }
  this.model.root._queries.remove(this);
  this.model._del(this.segments);
};

Query.prototype.sourceQuery = function() {
  if (this.isPathQuery) {
    var ids = pathIds(this.model, this.expression);
    return {_id: {$in: ids}};
  }
  return this.expression;
};

/**
 * @param {Function} [cb] cb(err)
 */
Query.prototype.fetch = function(cb) {
  if (!cb) cb = this.model.root._defaultCallback;
  this.model.emit('fetchQuery', this, this.model._context);

  this.fetchCount++;

  if (!this.created) this.create();
  var query = this;

  var model = this.model;
  var shareDocs = collectionShareDocs(this.model, this.collectionName);
  var options = {docMode: 'fetch', knownDocs: shareDocs};
  if (this.source) options.source = this.source;

  model.root.shareConnection.createFetchQuery(
    this.collectionName, this.sourceQuery(), options, fetchQueryCallback
  );
  function fetchQueryCallback(err, results, extra) {
    if (err) return cb(err);
    var ids = resultsIds(results);

    // Keep track of the ids at fetch time for use in unfetch
    query.fetchIds.push(ids.slice());
    // Update the results ids and extra
    model._setDiff(query.idSegments, ids);
    if (extra !== void 0) {
      model._setDiff(query.extraSegments, extra, {equal: deepEquals});
    }

    if (!ids.length) return cb();

    // Call fetchDoc for each document returned so that the proper load events
    // and internal counts are maintained. However, specify that we already
    // loaded the documents as part of the query, since we don't want to
    // actually fetch the documents again
    var alreadyLoaded = true;
    var group = util.asyncGroup(cb);
    for (var i = 0; i < ids.length; i++) {
      model.fetchDoc(query.collectionName, ids[i], group(), alreadyLoaded);
    }
  }
  return this;
};

/**
 * Sets up a subscription to `this` query.
 * @param {Function} cb(err)
 */
Query.prototype.subscribe = function(cb) {
  if (!cb) cb = this.model.root._defaultCallback;
  this.model.emit('subscribeQuery', this, this.model._context);

  var query = this;

  if (this.subscribeCount++) {
    process.nextTick(function () {
      var data = query.model._get(query.segments);
      if (data) cb();
      else query._pendingSubscribeCallbacks.push(cb);
    });
    return this;
  }

  if (!this.created) this.create();

  // When doing server-side rendering, we actually do a fetch the first time
  // that subscribe is called, but keep track of the state as if subscribe
  // were called for proper initialization in the client
  var shareDocs = collectionShareDocs(this.model, this.collectionName);
  var options = {docMode: 'sub', knownDocs: shareDocs};
  if (this.source) options.source = this.source;

  if (!this.model.root.fetchOnly) {
    this._shareSubscribe(options, cb);
    return this;
  }

  var model = this.model;
  options.docMode = 'fetch';
  model.root.shareConnection.createFetchQuery(
    this.collectionName, this.sourceQuery(), options, function(err, results, extra) {
      if (err) return cb(err);
      var ids = resultsIds(results);
      if (extra !== void 0) {
        model._setDiff(query.extraSegments, extra, {equal: deepEquals});
      }
      query._onChange(ids, null, cb);
      while (cb = query._pendingSubscribeCallbacks.shift()) {
        query._onChange(ids, null, cb);
      }
    }
  );
  return this;
};

/**
 * @private
 * @param {Object} options
 * @param {String} [options.source]
 * @param {Boolean} [options.poll]
 * @param {Boolean} [options.docMode = fetch or subscribe]
 * @param {Function} cb(err, results)
 */
Query.prototype._shareSubscribe = function(options, cb) {
  var query = this;
  var model = this.model;
  this.shareQuery = this.model.root.shareConnection.createSubscribeQuery(
    this.collectionName, this.sourceQuery(), options, function (err, results, extra) {
      if (err) return cb(err);
      if (extra !== void 0) {
        model._setDiff(query.extraSegments, extra, {equal: deepEquals});
      }
      // Results are not set in the callback, because the shareQuery should
      // emit a 'change' event before calling back
      cb();
    }
  );
  var query = this;
  this.shareQuery.on('insert', function(shareDocs, index) {
    query._onInsert(shareDocs, index);
  });
  this.shareQuery.on('remove', function(shareDocs, index) {
    query._onRemove(shareDocs, index);
  });
  this.shareQuery.on('move', function(shareDocs, from, to) {
    query._onMove(shareDocs, from, to);
  });
  this.shareQuery.on('change', function(results, previous) {
    // Get the new and previous list of ids when the entire results set changes
    var ids = resultsIds(results);
    var previousIds = previous && resultsIds(previous);
    query._onChange(ids, previousIds);
  });
  this.shareQuery.on('extra', function (extra) {
    model._setDiff(query.extraSegments, extra, {equal: deepEquals});
  });
};

/**
 * @public
 * @param {Function} cb(err, newFetchCount)
 */
Query.prototype.unfetch = function(cb) {
  if (!cb) cb = this.model.root._defaultCallback;
  this.model.emit('unfetchQuery', this, this.model._context);

  // No effect if the query is not currently fetched
  if (!this.fetchCount) {
    cb();
    return this;
  }

  var ids = this.fetchIds.shift() || [];
  for (var i = 0; i < ids.length; i++) {
    this.model.unfetchDoc(this.collectionName, ids[i]);
  }

  var query = this;
  if (this.model.root.unloadDelay) {
    setTimeout(finishUnfetchQuery, this.model.root.unloadDelay);
  } else {
    finishUnfetchQuery();
  }
  function finishUnfetchQuery() {
    var count = --query.fetchCount;
    if (count) return cb(null, count);
    // Cleanup when no fetches or subscribes remain
    if (!query.subscribeCount) query.destroy();
    cb(null, 0);
  }
  return this;
};

Query.prototype.unsubscribe = function(cb) {
  if (!cb) cb = this.model.root._defaultCallback;
  this.model.emit('unsubscribeQuery', this, this.model._context);

  // No effect if the query is not currently subscribed
  if (!this.subscribeCount) {
    cb();
    return this;
  }

  var query = this;
  if (this.model.root.unloadDelay) {
    setTimeout(finishUnsubscribeQuery, this.model.root.unloadDelay);
  } else {
    finishUnsubscribeQuery();
  }
  function finishUnsubscribeQuery() {
    var count = --query.subscribeCount;
    if (count) return cb(null, count);

    if (query.shareQuery) {
      var ids = resultsIds(query.shareQuery.results);
      query.shareQuery.destroy();
      query.shareQuery = null;
    }

    if (!query.model.root.fetchOnly && ids && ids.length) {
      // Unsubscribe all documents that this query currently has in results
      var group = util.asyncGroup(unsubscribeQueryCallback);
      for (var i = 0; i < ids.length; i++) {
        query.model.unsubscribeDoc(query.collectionName, ids[i], group());
      }
    }
    unsubscribeQueryCallback();
  }
  function unsubscribeQueryCallback(err) {
    if (err) return cb(err);
    // Cleanup when no fetches or subscribes remain
    if (!query.fetchCount) query.destroy();
    cb(null, 0);
  }
  return this;
};

Query.prototype._onInsert = function(shareDocs, index) {
  var ids = [];
  for (var i = 0; i < shareDocs.length; i++) {
    var id = shareDocs[i].name;
    ids.push(id);
    this.model.subscribeDoc(this.collectionName, id);
  }
  this.model._insert(this.idSegments, index, ids);
};
Query.prototype._onRemove = function(shareDocs, index) {
  this.model._remove(this.idSegments, index, shareDocs.length);
  for (var i = 0; i < shareDocs.length; i++) {
    this.model.unsubscribeDoc(this.collectionName, shareDocs[i].name);
  }
};
Query.prototype._onMove = function(shareDocs, from, to) {
  this.model._move(this.idSegments, from, to, shareDocs.length);
};

Query.prototype._onChange = function(ids, previousIds, cb) {
  // Diff the new and previous list of ids, subscribing to documents for
  // inserted ids and unsubscribing from documents for removed ids
  var diff = (previousIds) ?
    arrayDiff(previousIds, ids) :
    [new arrayDiff.InsertDiff(0, ids)];
  var previousCopy = previousIds && previousIds.slice();

  // The results are updated via a different diff, since they might already
  // have a value from a fetch or previous shareQuery instance
  this.model._setDiff(this.idSegments, ids);

  if (cb) {
    var group = util.asyncGroup(cb);
    var finished = group();
  }
  for (var i = 0; i < diff.length; i++) {
    var item = diff[i];
    if (item instanceof arrayDiff.InsertDiff) {
      // Subscribe to the document for each inserted id
      var values = item.values;
      for (var j = 0; j < values.length; j++) {
        this.model.subscribeDoc(this.collectionName, values[j], cb && group());
      }
    } else if (item instanceof arrayDiff.RemoveDiff) {
      var values = previousCopy.splice(item.index, item.howMany);
      // Unsubscribe from the document for each removed id
      for (var j = 0; j < values.length; j++) {
        this.model.unsubscribeDoc(this.collectionName, values[j], cb && group());
      }
    }
    // Moving doesn't change document subscriptions, so that is ignored.
  }
  // Make sure that the callback gets called if the diff is empty or it
  // contains no inserts or removes
  finished && finished();
};

Query.prototype.get = function() {
  var results = [];
  var data = this.model._get(this.segments);
  if (!data) {
    console.warn('You must fetch or subscribe to a query before getting its results.');
    return results;
  }
  var ids = data.ids;
  if (!ids) return results;

  var collection = this.model.getCollection(this.collectionName);
  for (var i = 0, l = ids.length; i < l; i++) {
    var id = ids[i];
    var doc = collection && collection.docs[id];
    results.push(doc && doc.get());
  }
  return (data.extra === void 0) ?
    results :
    {results: results, extra: data.extra};
};

/**
 * Lazily creates or gets a ref to our resultset's results.
 */
Query.prototype.ref = function(from) {
  var idsPath = this.idSegments.join('.');
  return this.model.refList(from, this.collectionName, idsPath);
};

/**
 * Lazily creates or gets a ref to our resultset's extra data.
 */
Query.prototype.extraRef = function(from, relPath) {
  var extraPath = this.extraSegments.join('.') + (relPath ? '.' + relPath : '');
  return this.model.ref(from, extraPath);
};

Query.prototype.serialize = function() {
  return [
    this.collectionName
  , this.expression
  , this.source
  , this.subscribeCount
  , this.fetchCount
  , this.fetchIds
  ];
};

function queryHash(collectionName, expression, source) {
  var args = [collectionName, expression, source];
  return JSON.stringify(args).replace(/\./g, '|');
}

function resultsIds(results) {
  var ids = [];
  for (var i = 0; i < results.length; i++) {
    var shareDoc = results[i];
    ids.push(shareDoc.name);
  }
  return ids;
}

function pathIds(model, segments) {
  var value = model._get(segments);
  return (typeof value === 'string') ? [value] :
    (Array.isArray(value)) ? value.slice() : [];
}

function collectionShareDocs(model, collectionName) {
  var collection = model.getCollection(collectionName);
  if (!collection) return;

  var results = [];
  for (var name in collection.docs) {
    results.push(collection.docs[name].shareDoc);
  }

  return results;
}


})(require("__browserify_process"))
},{"../util":12,"./Model":29,"arraydiff":69,"deep-is":46,"__browserify_process":10}],70:[function(require,module,exports){
require=(function(e,t,n,r){function i(r){if(!n[r]){if(!t[r]){if(e)return e(r);throw new Error("Cannot find module '"+r+"'")}var s=n[r]={exports:{}};t[r][0](function(e){var n=t[r][1][e];return i(n?n:e)},s,s.exports)}return n[r].exports}for(var s=0;s<r.length;s++)i(r[s]);return i})(typeof require!=="undefined"&&require,{1:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],2:[function(require,module,exports){
(function(){// UTILITY
var util = require('util');
var Buffer = require("buffer").Buffer;
var pSlice = Array.prototype.slice;

function objectKeys(object) {
  if (Object.keys) return Object.keys(object);
  var result = [];
  for (var name in object) {
    if (Object.prototype.hasOwnProperty.call(object, name)) {
      result.push(name);
    }
  }
  return result;
}

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.message = options.message;
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
};
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (value === undefined) {
    return '' + value;
  }
  if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (typeof value === 'function' || value instanceof RegExp) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (typeof s == 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

assert.AssertionError.prototype.toString = function() {
  if (this.message) {
    return [this.name + ':', this.message].join(' ');
  } else {
    return [
      this.name + ':',
      truncate(JSON.stringify(this.actual, replacer), 128),
      this.operator,
      truncate(JSON.stringify(this.expected, replacer), 128)
    ].join(' ');
  }
};

// assert.AssertionError instanceof Error

assert.AssertionError.__proto__ = Error.prototype;

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!!!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (typeof actual != 'object' && typeof expected != 'object') {
    return actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (expected instanceof RegExp) {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail('Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail('Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

})()
},{"util":3,"buffer":4}],"buffer-browserify":[function(require,module,exports){
module.exports=require('q9TxCC');
},{}],"q9TxCC":[function(require,module,exports){
(function(){function SlowBuffer (size) {
    this.length = size;
};

var assert = require('assert');

exports.INSPECT_MAX_BYTES = 50;


function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

SlowBuffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
    case 'binary':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

SlowBuffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

SlowBuffer.prototype.binaryWrite = SlowBuffer.prototype.asciiWrite;

SlowBuffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

SlowBuffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

SlowBuffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

SlowBuffer.prototype.binarySlice = SlowBuffer.prototype.asciiSlice;

SlowBuffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<SlowBuffer ' + out.join(' ') + '>';
};


SlowBuffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


SlowBuffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


SlowBuffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  SlowBuffer._charsWritten = i * 2;
  return i;
};


SlowBuffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};


// slice(start, end)
SlowBuffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;

  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  return new Buffer(this, end - start, +start);
};

SlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {
  var temp = [];
  for (var i=sourcestart; i<sourceend; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=targetstart; i<targetstart+temp.length; i++) {
    target[i] = temp[i-targetstart];
  }
};

SlowBuffer.prototype.fill = function(value, start, end) {
  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  for (var i = start; i < end; i++) {
    this[i] = value;
  }
}

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}


// Buffer

function Buffer(subject, encoding, offset) {
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    this.parent = subject;
    this.offset = offset;
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    if (this.length > Buffer.poolSize) {
      // Big buffer, just alloc one.
      this.parent = new SlowBuffer(this.length);
      this.offset = 0;

    } else {
      // Small buffer.
      if (!pool || pool.length - pool.used < this.length) allocPool();
      this.parent = pool;
      this.offset = pool.used;
      pool.used += this.length;
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        if (subject instanceof Buffer) {
          this.parent[i + this.offset] = subject.readUInt8(i);
        }
        else {
          this.parent[i + this.offset] = subject[i];
        }
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    }
  }

}

function isArrayIsh(subject) {
  return Array.isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

exports.SlowBuffer = SlowBuffer;
exports.Buffer = Buffer;

Buffer.poolSize = 8 * 1024;
var pool;

function allocPool() {
  pool = new SlowBuffer(Buffer.poolSize);
  pool.used = 0;
}


// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof SlowBuffer;
};

Buffer.concat = function (list, totalLength) {
  if (!Array.isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

// Inspect
Buffer.prototype.inspect = function inspect() {
  var out = [],
      len = this.length;

  for (var i = 0; i < len; i++) {
    out[i] = toHex(this.parent[i + this.offset]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }

  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i];
};


Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i] = v;
};


// write(string, offset = 0, length = buffer.length-offset, encoding = 'utf8')
Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  var ret;
  switch (encoding) {
    case 'hex':
      ret = this.parent.hexWrite(string, this.offset + offset, length);
      break;

    case 'utf8':
    case 'utf-8':
      ret = this.parent.utf8Write(string, this.offset + offset, length);
      break;

    case 'ascii':
      ret = this.parent.asciiWrite(string, this.offset + offset, length);
      break;

    case 'binary':
      ret = this.parent.binaryWrite(string, this.offset + offset, length);
      break;

    case 'base64':
      // Warning: maxLength not taken into account in base64Write
      ret = this.parent.base64Write(string, this.offset + offset, length);
      break;

    case 'ucs2':
    case 'ucs-2':
      ret = this.parent.ucs2Write(string, this.offset + offset, length);
      break;

    default:
      throw new Error('Unknown encoding');
  }

  Buffer._charsWritten = SlowBuffer._charsWritten;

  return ret;
};


// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();

  if (typeof start == 'undefined' || start < 0) {
    start = 0;
  } else if (start > this.length) {
    start = this.length;
  }

  if (typeof end == 'undefined' || end > this.length) {
    end = this.length;
  } else if (end < 0) {
    end = 0;
  }

  start = start + this.offset;
  end = end + this.offset;

  switch (encoding) {
    case 'hex':
      return this.parent.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.parent.utf8Slice(start, end);

    case 'ascii':
      return this.parent.asciiSlice(start, end);

    case 'binary':
      return this.parent.binarySlice(start, end);

    case 'base64':
      return this.parent.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.parent.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


// byteLength
Buffer.byteLength = SlowBuffer.byteLength;


// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  return this.parent.fill(value,
                          start + this.offset,
                          end + this.offset);
};


// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  end || (end = this.length);
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  return this.parent.copy(target.parent,
                          target_start + target.offset,
                          start + this.offset,
                          end + this.offset);
};


// slice(start, end)
Buffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;
  if (end > this.length) throw new Error('oob');
  if (start > end) throw new Error('oob');

  return new Buffer(this.parent, end - start, +start + this.offset);
};


// Legacy methods for backwards compatibility.

Buffer.prototype.utf8Slice = function(start, end) {
  return this.toString('utf8', start, end);
};

Buffer.prototype.binarySlice = function(start, end) {
  return this.toString('binary', start, end);
};

Buffer.prototype.asciiSlice = function(start, end) {
  return this.toString('ascii', start, end);
};

Buffer.prototype.utf8Write = function(string, offset) {
  return this.write(string, offset, 'utf8');
};

Buffer.prototype.binaryWrite = function(string, offset) {
  return this.write(string, offset, 'binary');
};

Buffer.prototype.asciiWrite = function(string, offset) {
  return this.write(string, offset, 'ascii');
};

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  return buffer.parent[buffer.offset + offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset] << 8;
    if (offset + 1 < buffer.length) {
      val |= buffer.parent[buffer.offset + offset + 1];
    }
  } else {
    val = buffer.parent[buffer.offset + offset];
    if (offset + 1 < buffer.length) {
      val |= buffer.parent[buffer.offset + offset + 1] << 8;
    }
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    if (offset + 1 < buffer.length)
      val = buffer.parent[buffer.offset + offset + 1] << 16;
    if (offset + 2 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 2] << 8;
    if (offset + 3 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 3];
    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);
  } else {
    if (offset + 2 < buffer.length)
      val = buffer.parent[buffer.offset + offset + 2] << 16;
    if (offset + 1 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 1] << 8;
    val |= buffer.parent[buffer.offset + offset];
    if (offset + 3 < buffer.length)
      val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  neg = buffer.parent[buffer.offset + offset] & 0x80;
  if (!neg) {
    return (buffer.parent[buffer.offset + offset]);
  }

  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  if (offset < buffer.length) {
    buffer.parent[buffer.offset + offset] = value;
  }
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
    buffer.parent[buffer.offset + offset + i] =
        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>
            (isBigEndian ? 1 - i : i) * 8;
  }

}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
    buffer.parent[buffer.offset + offset + i] =
        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

SlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;
SlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;
SlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;
SlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;
SlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;
SlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;
SlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;
SlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;
SlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;
SlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;
SlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;
SlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;
SlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;
SlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;
SlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;
SlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;
SlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;
SlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;
SlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;
SlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;
SlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;
SlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;
SlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;
SlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;
SlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;
SlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;
SlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;
SlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;

})()
},{"assert":2,"./buffer_ieee754":1,"base64-js":5}],3:[function(require,module,exports){
var events = require('events');

exports.isArray = isArray;
exports.isDate = function(obj){return Object.prototype.toString.call(obj) === '[object Date]'};
exports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === '[object RegExp]'};


exports.print = function () {};
exports.puts = function () {};
exports.debug = function() {};

exports.inspect = function(obj, showHidden, depth, colors) {
  var seen = [];

  var stylize = function(str, styleType) {
    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    var styles =
        { 'bold' : [1, 22],
          'italic' : [3, 23],
          'underline' : [4, 24],
          'inverse' : [7, 27],
          'white' : [37, 39],
          'grey' : [90, 39],
          'black' : [30, 39],
          'blue' : [34, 39],
          'cyan' : [36, 39],
          'green' : [32, 39],
          'magenta' : [35, 39],
          'red' : [31, 39],
          'yellow' : [33, 39] };

    var style =
        { 'special': 'cyan',
          'number': 'blue',
          'boolean': 'yellow',
          'undefined': 'grey',
          'null': 'bold',
          'string': 'green',
          'date': 'magenta',
          // "name": intentionally not styling
          'regexp': 'red' }[styleType];

    if (style) {
      return '\033[' + styles[style][0] + 'm' + str +
             '\033[' + styles[style][1] + 'm';
    } else {
      return str;
    }
  };
  if (! colors) {
    stylize = function(str, styleType) { return str; };
  }

  function format(value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (value && typeof value.inspect === 'function' &&
        // Filter out the util module, it's inspect function is special
        value !== exports &&
        // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
      return value.inspect(recurseTimes);
    }

    // Primitive types cannot have properties
    switch (typeof value) {
      case 'undefined':
        return stylize('undefined', 'undefined');

      case 'string':
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                 .replace(/'/g, "\\'")
                                                 .replace(/\\"/g, '"') + '\'';
        return stylize(simple, 'string');

      case 'number':
        return stylize('' + value, 'number');

      case 'boolean':
        return stylize('' + value, 'boolean');
    }
    // For some reason typeof null is "object", so special case here.
    if (value === null) {
      return stylize('null', 'null');
    }

    // Look up the keys of the object.
    var visible_keys = Object_keys(value);
    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;

    // Functions without properties can be shortcutted.
    if (typeof value === 'function' && keys.length === 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        var name = value.name ? ': ' + value.name : '';
        return stylize('[Function' + name + ']', 'special');
      }
    }

    // Dates without properties can be shortcutted
    if (isDate(value) && keys.length === 0) {
      return stylize(value.toUTCString(), 'date');
    }

    var base, type, braces;
    // Determine the object type
    if (isArray(value)) {
      type = 'Array';
      braces = ['[', ']'];
    } else {
      type = 'Object';
      braces = ['{', '}'];
    }

    // Make functions say that they are functions
    if (typeof value === 'function') {
      var n = value.name ? ': ' + value.name : '';
      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';
    } else {
      base = '';
    }

    // Make dates with properties first say the date
    if (isDate(value)) {
      base = ' ' + value.toUTCString();
    }

    if (keys.length === 0) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        return stylize('[Object]', 'special');
      }
    }

    seen.push(value);

    var output = keys.map(function(key) {
      var name, str;
      if (value.__lookupGetter__) {
        if (value.__lookupGetter__(key)) {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Getter/Setter]', 'special');
          } else {
            str = stylize('[Getter]', 'special');
          }
        } else {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Setter]', 'special');
          }
        }
      }
      if (visible_keys.indexOf(key) < 0) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (seen.indexOf(value[key]) < 0) {
          if (recurseTimes === null) {
            str = format(value[key]);
          } else {
            str = format(value[key], recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (isArray(value)) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = stylize('[Circular]', 'special');
        }
      }
      if (typeof name === 'undefined') {
        if (type === 'Array' && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    });

    seen.pop();

    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
      numLinesEst++;
      if (cur.indexOf('\n') >= 0) numLinesEst++;
      return prev + cur.length + 1;
    }, 0);

    if (length > 50) {
      output = braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];

    } else {
      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }

    return output;
  }
  return format(obj, (typeof depth === 'undefined' ? 2 : depth));
};


function isArray(ar) {
  return ar instanceof Array ||
         Array.isArray(ar) ||
         (ar && ar !== Object.prototype && isArray(ar.__proto__));
}


function isRegExp(re) {
  return re instanceof RegExp ||
    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');
}


function isDate(d) {
  if (d instanceof Date) return true;
  if (typeof d !== 'object') return false;
  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);
  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);
  return JSON.stringify(proto) === JSON.stringify(properties);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

exports.log = function (msg) {};

exports.pump = null;

var Object_keys = Object.keys || function (obj) {
    var res = [];
    for (var key in obj) res.push(key);
    return res;
};

var Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {
    var res = [];
    for (var key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) res.push(key);
    }
    return res;
};

var Object_create = Object.create || function (prototype, properties) {
    // from es5-shim
    var object;
    if (prototype === null) {
        object = { '__proto__' : null };
    }
    else {
        if (typeof prototype !== 'object') {
            throw new TypeError(
                'typeof prototype[' + (typeof prototype) + '] != \'object\''
            );
        }
        var Type = function () {};
        Type.prototype = prototype;
        object = new Type();
        object.__proto__ = prototype;
    }
    if (typeof properties !== 'undefined' && Object.defineProperties) {
        Object.defineProperties(object, properties);
    }
    return object;
};

exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object_create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (typeof f !== 'string') {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(exports.inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j': return JSON.stringify(args[i++]);
      default:
        return x;
    }
  });
  for(var x = args[i]; i < len; x = args[++i]){
    if (x === null || typeof x !== 'object') {
      str += ' ' + x;
    } else {
      str += ' ' + exports.inspect(x);
    }
  }
  return str;
};

},{"events":6}],5:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}],7:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],8:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],6:[function(require,module,exports){
(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};

var EventEmitter = exports.EventEmitter = process.EventEmitter;
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]'
    }
;
function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (x === xs[i]) return i;
    }
    return -1;
}

// By default EventEmitters will print a warning if more than
// 10 listeners are added to it. This is a useful default which
// helps finding memory leaks.
//
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!this._events) this._events = {};
  this._events.maxListeners = n;
};


EventEmitter.prototype.emit = function(type) {
  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events || !this._events.error ||
        (isArray(this._events.error) && !this._events.error.length))
    {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }
  }

  if (!this._events) return false;
  var handler = this._events[type];
  if (!handler) return false;

  if (typeof handler == 'function') {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        var args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
    return true;

  } else if (isArray(handler)) {
    var args = Array.prototype.slice.call(arguments, 1);

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i].apply(this, args);
    }
    return true;

  } else {
    return false;
  }
};

// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('addListener only takes instances of Function');
  }

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  } else if (isArray(this._events[type])) {

    // Check for listener leak
    if (!this._events[type].warned) {
      var m;
      if (this._events.maxListeners !== undefined) {
        m = this._events.maxListeners;
      } else {
        m = defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }

    // If we've already got an array, just append.
    this._events[type].push(listener);
  } else {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  var self = this;
  self.on(type, function g() {
    self.removeListener(type, g);
    listener.apply(this, arguments);
  });

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('removeListener only takes instances of Function');
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (!this._events || !this._events[type]) return this;

  var list = this._events[type];

  if (isArray(list)) {
    var i = indexOf(list, listener);
    if (i < 0) return this;
    list.splice(i, 1);
    if (list.length == 0)
      delete this._events[type];
  } else if (this._events[type] === listener) {
    delete this._events[type];
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  if (arguments.length === 0) {
    this._events = {};
    return this;
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (type && this._events && this._events[type]) this._events[type] = null;
  return this;
};

EventEmitter.prototype.listeners = function(type) {
  if (!this._events) this._events = {};
  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
};

})(require("__browserify_process"))
},{"__browserify_process":8}],4:[function(require,module,exports){
(function(){function SlowBuffer (size) {
    this.length = size;
};

var assert = require('assert');

exports.INSPECT_MAX_BYTES = 50;


function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

SlowBuffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

SlowBuffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

SlowBuffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

SlowBuffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

SlowBuffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<SlowBuffer ' + out.join(' ') + '>';
};


SlowBuffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


SlowBuffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


SlowBuffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  SlowBuffer._charsWritten = i * 2;
  return i;
};


SlowBuffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};


// slice(start, end)
SlowBuffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;

  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  return new Buffer(this, end - start, +start);
};

SlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {
  var temp = [];
  for (var i=sourcestart; i<sourceend; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=targetstart; i<targetstart+temp.length; i++) {
    target[i] = temp[i-targetstart];
  }
};

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}


// Buffer

function Buffer(subject, encoding, offset) {
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    this.parent = subject;
    this.offset = offset;
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    if (this.length > Buffer.poolSize) {
      // Big buffer, just alloc one.
      this.parent = new SlowBuffer(this.length);
      this.offset = 0;

    } else {
      // Small buffer.
      if (!pool || pool.length - pool.used < this.length) allocPool();
      this.parent = pool;
      this.offset = pool.used;
      pool.used += this.length;
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        this.parent[i + this.offset] = subject[i];
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    }
  }

}

function isArrayIsh(subject) {
  return Array.isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

exports.SlowBuffer = SlowBuffer;
exports.Buffer = Buffer;

Buffer.poolSize = 8 * 1024;
var pool;

function allocPool() {
  pool = new SlowBuffer(Buffer.poolSize);
  pool.used = 0;
}


// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof SlowBuffer;
};

Buffer.concat = function (list, totalLength) {
  if (!Array.isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

// Inspect
Buffer.prototype.inspect = function inspect() {
  var out = [],
      len = this.length;

  for (var i = 0; i < len; i++) {
    out[i] = toHex(this.parent[i + this.offset]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }

  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i];
};


Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i] = v;
};


// write(string, offset = 0, length = buffer.length-offset, encoding = 'utf8')
Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  var ret;
  switch (encoding) {
    case 'hex':
      ret = this.parent.hexWrite(string, this.offset + offset, length);
      break;

    case 'utf8':
    case 'utf-8':
      ret = this.parent.utf8Write(string, this.offset + offset, length);
      break;

    case 'ascii':
      ret = this.parent.asciiWrite(string, this.offset + offset, length);
      break;

    case 'binary':
      ret = this.parent.binaryWrite(string, this.offset + offset, length);
      break;

    case 'base64':
      // Warning: maxLength not taken into account in base64Write
      ret = this.parent.base64Write(string, this.offset + offset, length);
      break;

    case 'ucs2':
    case 'ucs-2':
      ret = this.parent.ucs2Write(string, this.offset + offset, length);
      break;

    default:
      throw new Error('Unknown encoding');
  }

  Buffer._charsWritten = SlowBuffer._charsWritten;

  return ret;
};


// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();

  if (typeof start == 'undefined' || start < 0) {
    start = 0;
  } else if (start > this.length) {
    start = this.length;
  }

  if (typeof end == 'undefined' || end > this.length) {
    end = this.length;
  } else if (end < 0) {
    end = 0;
  }

  start = start + this.offset;
  end = end + this.offset;

  switch (encoding) {
    case 'hex':
      return this.parent.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.parent.utf8Slice(start, end);

    case 'ascii':
      return this.parent.asciiSlice(start, end);

    case 'binary':
      return this.parent.binarySlice(start, end);

    case 'base64':
      return this.parent.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.parent.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


// byteLength
Buffer.byteLength = SlowBuffer.byteLength;


// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  return this.parent.fill(value,
                          start + this.offset,
                          end + this.offset);
};


// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  end || (end = this.length);
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  return this.parent.copy(target.parent,
                          target_start + target.offset,
                          start + this.offset,
                          end + this.offset);
};


// slice(start, end)
Buffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;
  if (end > this.length) throw new Error('oob');
  if (start > end) throw new Error('oob');

  return new Buffer(this.parent, end - start, +start + this.offset);
};


// Legacy methods for backwards compatibility.

Buffer.prototype.utf8Slice = function(start, end) {
  return this.toString('utf8', start, end);
};

Buffer.prototype.binarySlice = function(start, end) {
  return this.toString('binary', start, end);
};

Buffer.prototype.asciiSlice = function(start, end) {
  return this.toString('ascii', start, end);
};

Buffer.prototype.utf8Write = function(string, offset) {
  return this.write(string, offset, 'utf8');
};

Buffer.prototype.binaryWrite = function(string, offset) {
  return this.write(string, offset, 'binary');
};

Buffer.prototype.asciiWrite = function(string, offset) {
  return this.write(string, offset, 'ascii');
};

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  return buffer.parent[buffer.offset + offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset] << 8;
    val |= buffer.parent[buffer.offset + offset + 1];
  } else {
    val = buffer.parent[buffer.offset + offset];
    val |= buffer.parent[buffer.offset + offset + 1] << 8;
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset + 1] << 16;
    val |= buffer.parent[buffer.offset + offset + 2] << 8;
    val |= buffer.parent[buffer.offset + offset + 3];
    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);
  } else {
    val = buffer.parent[buffer.offset + offset + 2] << 16;
    val |= buffer.parent[buffer.offset + offset + 1] << 8;
    val |= buffer.parent[buffer.offset + offset];
    val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  neg = buffer.parent[buffer.offset + offset] & 0x80;
  if (!neg) {
    return (buffer.parent[buffer.offset + offset]);
  }

  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  buffer.parent[buffer.offset + offset] = value;
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  if (isBigEndian) {
    buffer.parent[buffer.offset + offset] = (value & 0xff00) >>> 8;
    buffer.parent[buffer.offset + offset + 1] = value & 0x00ff;
  } else {
    buffer.parent[buffer.offset + offset + 1] = (value & 0xff00) >>> 8;
    buffer.parent[buffer.offset + offset] = value & 0x00ff;
  }
}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  if (isBigEndian) {
    buffer.parent[buffer.offset + offset] = (value >>> 24) & 0xff;
    buffer.parent[buffer.offset + offset + 1] = (value >>> 16) & 0xff;
    buffer.parent[buffer.offset + offset + 2] = (value >>> 8) & 0xff;
    buffer.parent[buffer.offset + offset + 3] = value & 0xff;
  } else {
    buffer.parent[buffer.offset + offset + 3] = (value >>> 24) & 0xff;
    buffer.parent[buffer.offset + offset + 2] = (value >>> 16) & 0xff;
    buffer.parent[buffer.offset + offset + 1] = (value >>> 8) & 0xff;
    buffer.parent[buffer.offset + offset] = value & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

SlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;
SlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;
SlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;
SlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;
SlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;
SlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;
SlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;
SlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;
SlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;
SlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;
SlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;
SlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;
SlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;
SlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;
SlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;
SlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;
SlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;
SlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;
SlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;
SlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;
SlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;
SlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;
SlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;
SlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;
SlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;
SlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;
SlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;
SlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;

})()
},{"assert":2,"./buffer_ieee754":7,"base64-js":9}],9:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}]},{},[])
;;module.exports=require("buffer-browserify")

},{}],68:[function(require,module,exports){
(function(Buffer){//     uuid.js
//
//     Copyright (c) 2010-2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

(function() {
  var _global = this;

  // Unique ID creation requires a high quality random # generator.  We feature
  // detect to determine the best RNG source, normalizing to a function that
  // returns 128-bits of randomness, since that's what's usually required
  var _rng;

  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
  //
  // Moderately fast, high quality
  if (typeof(require) == 'function') {
    try {
      var _rb = require('crypto').randomBytes;
      _rng = _rb && function() {return _rb(16);};
    } catch(e) {}
  }

  if (!_rng && _global.crypto && crypto.getRandomValues) {
    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
    //
    // Moderately fast, high quality
    var _rnds8 = new Uint8Array(16);
    _rng = function whatwgRNG() {
      crypto.getRandomValues(_rnds8);
      return _rnds8;
    };
  }

  if (!_rng) {
    // Math.random()-based (RNG)
    //
    // If all else fails, use Math.random().  It's fast, but is of unspecified
    // quality.
    var  _rnds = new Array(16);
    _rng = function() {
      for (var i = 0, r; i < 16; i++) {
        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
      }

      return _rnds;
    };
  }

  // Buffer class to use
  var BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;

  // Maps for number <-> hex string conversion
  var _byteToHex = [];
  var _hexToByte = {};
  for (var i = 0; i < 256; i++) {
    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
    _hexToByte[_byteToHex[i]] = i;
  }

  // **`parse()` - Parse a UUID into it's component bytes**
  function parse(s, buf, offset) {
    var i = (buf && offset) || 0, ii = 0;

    buf = buf || [];
    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
      if (ii < 16) { // Don't overflow!
        buf[i + ii++] = _hexToByte[oct];
      }
    });

    // Zero out remaining bytes if string was short
    while (ii < 16) {
      buf[i + ii++] = 0;
    }

    return buf;
  }

  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
  function unparse(buf, offset) {
    var i = offset || 0, bth = _byteToHex;
    return  bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]];
  }

  // **`v1()` - Generate time-based UUID**
  //
  // Inspired by https://github.com/LiosK/UUID.js
  // and http://docs.python.org/library/uuid.html

  // random #'s we need to init node and clockseq
  var _seedBytes = _rng();

  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
  var _nodeId = [
    _seedBytes[0] | 0x01,
    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
  ];

  // Per 4.2.2, randomize (14 bit) clockseq
  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

  // Previous uuid creation time
  var _lastMSecs = 0, _lastNSecs = 0;

  // See https://github.com/broofa/node-uuid for API details
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];

    options = options || {};

    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;

    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    var msecs = options.msecs != null ? options.msecs : new Date().getTime();

    // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;

    // Time since last uuid creation (in msecs)
    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

    // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq == null) {
      clockseq = clockseq + 1 & 0x3fff;
    }

    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
      nsecs = 0;
    }

    // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) {
      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
    }

    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;

    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000;

    // `time_low`
    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff;

    // `time_mid`
    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff;

    // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff;

    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80;

    // `clock_seq_low`
    b[i++] = clockseq & 0xff;

    // `node`
    var node = options.node || _nodeId;
    for (var n = 0; n < 6; n++) {
      b[i + n] = node[n];
    }

    return buf ? buf : unparse(b);
  }

  // **`v4()` - Generate random UUID**

  // See https://github.com/broofa/node-uuid for API details
  function v4(options, buf, offset) {
    // Deprecated - 'format' argument, as supported in v1.2
    var i = buf && offset || 0;

    if (typeof(options) == 'string') {
      buf = options == 'binary' ? new BufferClass(16) : null;
      options = null;
    }
    options = options || {};

    var rnds = options.random || (options.rng || _rng)();

    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;

    // Copy bytes to buffer, if provided
    if (buf) {
      for (var ii = 0; ii < 16; ii++) {
        buf[i + ii] = rnds[ii];
      }
    }

    return buf || unparse(rnds);
  }

  // Export public API
  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  uuid.parse = parse;
  uuid.unparse = unparse;
  uuid.BufferClass = BufferClass;

  if (typeof define === 'function' && define.amd) {
    // Publish as AMD module
    define(function() {return uuid;});
  } else if (typeof(module) != 'undefined' && module.exports) {
    // Publish as node.js module
    module.exports = uuid;
  } else {
    // Publish as global (in browsers)
    var _previousRoot = _global.uuid;

    // **`noConflict()` - (browser only) to reset global 'uuid' var**
    uuid.noConflict = function() {
      _global.uuid = _previousRoot;
      return uuid;
    };

    _global.uuid = uuid;
  }
}).call(this);

})(require("__browserify_buffer").Buffer)
},{"crypto":71,"__browserify_buffer":70}],69:[function(require,module,exports){
module.exports = arrayDiff;

// Based on some rough benchmarking, this algorithm is about O(2n) worst case,
// and it can compute diffs on random arrays of length 1024 in about 34ms,
// though just a few changes on an array of length 1024 takes about 0.5ms

arrayDiff.InsertDiff = InsertDiff;
arrayDiff.RemoveDiff = RemoveDiff;
arrayDiff.MoveDiff = MoveDiff;

function InsertDiff(index, values) {
  this.index = index;
  this.values = values;
}
InsertDiff.prototype.type = 'insert';
InsertDiff.prototype.toJSON = function() {
  return {
    type: this.type
  , index: this.index
  , values: this.values
  };
};

function RemoveDiff(index, howMany) {
  this.index = index;
  this.howMany = howMany;
}
RemoveDiff.prototype.type = 'remove';
RemoveDiff.prototype.toJSON = function() {
  return {
    type: this.type
  , index: this.index
  , howMany: this.howMany
  };
};

function MoveDiff(from, to, howMany) {
  this.from = from;
  this.to = to;
  this.howMany = howMany;
}
MoveDiff.prototype.type = 'move';
MoveDiff.prototype.toJSON = function() {
  return {
    type: this.type
  , from: this.from
  , to: this.to
  , howMany: this.howMany
  };
};

function strictEqual(a, b) {
  return a === b;
}

function arrayDiff(before, after, equalFn) {
  if (!equalFn) equalFn = strictEqual;

  // Find all items in both the before and after array, and represent them
  // as moves. Many of these "moves" may end up being discarded in the last
  // pass if they are from an index to the same index, but we don't know this
  // up front, since we haven't yet offset the indices.
  // 
  // Also keep a map of all the indicies accounted for in the before and after
  // arrays. These maps are used next to create insert and remove diffs.
  var beforeLength = before.length;
  var afterLength = after.length;
  var moves = [];
  var beforeMarked = {};
  var afterMarked = {};
  for (var beforeIndex = 0; beforeIndex < beforeLength; beforeIndex++) {
    var beforeItem = before[beforeIndex];
    for (var afterIndex = 0; afterIndex < afterLength; afterIndex++) {
      if (afterMarked[afterIndex]) continue;
      if (!equalFn(beforeItem, after[afterIndex])) continue;
      var from = beforeIndex;
      var to = afterIndex;
      var howMany = 0;
      do {
        beforeMarked[beforeIndex++] = afterMarked[afterIndex++] = true;
        howMany++;
      } while (
        beforeIndex < beforeLength &&
        afterIndex < afterLength &&
        equalFn(before[beforeIndex], after[afterIndex]) &&
        !afterMarked[afterIndex]
      );
      moves.push(new MoveDiff(from, to, howMany));
      beforeIndex--;
      break;
    }
  }

  // Create a remove for all of the items in the before array that were
  // not marked as being matched in the after array as well
  var removes = [];
  for (beforeIndex = 0; beforeIndex < beforeLength;) {
    if (beforeMarked[beforeIndex]) {
      beforeIndex++;
      continue;
    }
    var index = beforeIndex;
    var howMany = 0;
    while (beforeIndex < beforeLength && !beforeMarked[beforeIndex++]) {
      howMany++;
    }
    removes.push(new RemoveDiff(index, howMany));
  }

  // Create an insert for all of the items in the after array that were
  // not marked as being matched in the before array as well
  var inserts = [];
  for (afterIndex = 0; afterIndex < afterLength;) {
    if (afterMarked[afterIndex]) {
      afterIndex++;
      continue;
    }
    var index = afterIndex;
    var howMany = 0;
    while (afterIndex < afterLength && !afterMarked[afterIndex++]) {
      howMany++;
    }
    var values = after.slice(index, index + howMany);
    inserts.push(new InsertDiff(index, values));
  }

  var insertsLength = inserts.length;
  var removesLength = removes.length;
  var movesLength = moves.length;
  var i, j;

  // Offset subsequent removes and moves by removes
  var count = 0;
  for (i = 0; i < removesLength; i++) {
    var remove = removes[i];
    remove.index -= count;
    count += remove.howMany;
    for (j = 0; j < movesLength; j++) {
      var move = moves[j];
      if (move.from >= remove.index) move.from -= remove.howMany;
    }
  }

  // Offset moves by inserts
  for (i = insertsLength; i--;) {
    var insert = inserts[i];
    var howMany = insert.values.length;
    for (j = movesLength; j--;) {
      var move = moves[j];
      if (move.to >= insert.index) move.to -= howMany;
    }
  }

  // Offset the to of moves by later moves
  for (i = movesLength; i-- > 1;) {
    var move = moves[i];
    if (move.to === move.from) continue;
    for (j = i; j--;) {
      var earlier = moves[j];
      if (earlier.to >= move.to) earlier.to -= move.howMany;
      if (earlier.to >= move.from) earlier.to += move.howMany;
    }
  }

  // Only output moves that end up having an effect after offsetting
  var outputMoves = [];

  // Offset the from of moves by earlier moves
  for (i = 0; i < movesLength; i++) {
    var move = moves[i];
    if (move.to === move.from) continue;
    outputMoves.push(move);
    for (j = i + 1; j < movesLength; j++) {
      var later = moves[j];
      if (later.from >= move.from) later.from -= move.howMany;
      if (later.from >= move.to) later.from += move.howMany;
    }
  }

  return removes.concat(outputMoves, inserts);
}

},{}],51:[function(require,module,exports){
var qs = require('qs')
var nodeUrl = require('url');

module.exports = {
  render: render
, isTransitional: isTransitional
, mapRoute: mapRoute
}

function isTransitional(pattern) {
  return pattern.hasOwnProperty('from') && pattern.hasOwnProperty('to')
}

function mapRoute(from, params) {
  var i = params.url.indexOf('?')
  var queryString = (~i) ? params.url.slice(i) : ''
  // If the route looks like /:a/:b?/:c/:d?
  // and :b and :d are missing, return /a/c
  // Thus, skip the / if the value is missing
  var i = 0
  var path = from.replace(/\/(?:(?:\:([^?\/:*]+))|\*)(\?)?/g, onMatch)
  function onMatch(match, key, optional) {
    var value = key ? params[key] : params[i++]
    return (optional && value === void 0) ? '' : '/' + value
  }
  return path + queryString
}

function render(page, options, e) {
  var req = new RenderReq(page, options, e)
  req.routeTransitional(0, function() {
    req.routeQueue(0, function() {
      req.routeAndTransition(0, function() {
        // Cancel rendering by this app if no routes match
        req.cancel()
      })
    })
  })
}

function RenderReq(page, options, e) {
  this.page = page
  this.options = options
  this.e = e
  this.setUrl(options.url.replace(/#.*/, ''))
  var queryString = nodeUrl.parse(this.url).query;
  this.query = queryString ? qs.parse(queryString) : {}
  this.method = options.method
  this.body = options.body || {}
  this.previous = options.previous
  var routes = page._routes
  this.transitional = routes.transitional[this.method]
  this.queue = routes.queue[this.method]
  this.onRoute = routes.onRoute
}

RenderReq.prototype.cancel = function() {
  var options = this.options
  // Don't do anything if this is the result of an event, since the
  // appropriate action will happen by default
  if (this.e || options.noNavigate) return
  // Otherwise, manually perform appropriate action
  if (options.form) {
    options.form.setAttribute('data-router-ignore', '')
    options.form.submit()
  } else if (options.link) {
    options.link.setAttribute('data-router-ignore', '')
    options.link.click()
  } else {
    window.location.assign(options.url)
  }
}

RenderReq.prototype.setUrl = function(url) {
  this.url = url
  this.path = this.url.replace(/\?.*/, '')
}

RenderReq.prototype.routeTransitional = function(i, next) {
  i || (i = 0)
  var item
  while (item = this.transitional[i++]) {
    if (!item.to.match(this.path) || !item.from.match(this.previous)) continue
    var req = this
    var otherParams = this.routeParams(item.from)
    var params = this.routeParams(item.to, otherParams)
    // Even though we don't need to do anything after a done, pass a
    // no op function, so that routes can expect it to be defined
    function done() {}
    this.onMatch(item.to, params, function(err) {
      if (err) return req.cancel()
      req.routeTransitional(i, next)
    }, done)
    return
  }
  next()
}

RenderReq.prototype.routeQueue = function(i, next) {
  i || (i = 0)
  var route
  while (route = this.queue[i++]) {
    if (!route.match(this.path)) continue
    var req = this
    var params = this.routeParams(route)
    this.onMatch(route, params, function(err) {
      if (err) return req.cancel()
      req.routeQueue(i, next)
    })
    return
  }
  next()
}

RenderReq.prototype.routeAndTransition = function(i, next) {
  i || (i = 0)
  var render = this.page.render
  var item
  while (item = this.transitional[i++]) {
    if (!item.to.match(this.path)) continue
    var url = this.url
    var params = this.routeParams(item.to)
    this.setUrl(mapRoute(item.from.path, params))
    var req = this
    var skipped = false
    function continueNext() {
      skipped = true
      req.setUrl(url)
      req.page.render = render
      req.routeAndTransition(i, next)
    }
    this.page.render = function() {
      var renderArguments = arguments
      function done() {
        if (skipped) return
        req.page.render = render
        render.apply(req.page, renderArguments)
      }
      req.setUrl(url)
      var isAsync = req.onMatch(item.to, params, continueNext, done)
      if (isAsync) return
      done()
    }
    this.routeQueue(0, continueNext)
    return
  }
  next()
}

RenderReq.prototype.onMatch = function(route, params, next, done) {
  // Stop the default browser action, such as clicking a link or submitting a form
  if (this.e) {
    this.e.preventDefault()
    this.e = null
  }
  this.page.params = params
  return this.onRoute(
    route.callbacks
  , this.page
  , this.page.params
  , next
  , route.isTransitional
  , done
  )
}

RenderReq.prototype.routeParams = function(route, otherParams) {
  var routeParams = route.params
  var params = routeParams.slice()
  if (otherParams) {
    for (var key in otherParams) {
      params[key] = otherParams[key]
    }
  }
  for (var key in routeParams) {
    params[key] = routeParams[key]
  }
  params.previous = this.previous
  params.url = this.url
  params.body = this.body
  params.query = this.query
  params.method = this.method
  return params
}

},{"url":47,"qs":72}],60:[function(require,module,exports){
(function(){
  var crypt = require('crypt'),
      utf8 = require('charenc').utf8,
      bin = require('charenc').bin,

  // The core
  md5 = function (message) {
    // Convert to byte array
    if (message.constructor == String)
      message = utf8.stringToBytes(message);
    else if (!Array.isArray(message))
      message = message.toString();
    // else, assume byte array already

    var m = crypt.bytesToWords(message),
        l = message.length * 8,
        a =  1732584193,
        b = -271733879,
        c = -1732584194,
        d =  271733878;

    // Swap endian
    for (var i = 0; i < m.length; i++) {
      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |
             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;
    }

    // Padding
    m[l >>> 5] |= 0x80 << (l % 32);
    m[(((l + 64) >>> 9) << 4) + 14] = l;

    // Method shortcuts
    var FF = md5._ff,
        GG = md5._gg,
        HH = md5._hh,
        II = md5._ii;

    for (var i = 0; i < m.length; i += 16) {

      var aa = a,
          bb = b,
          cc = c,
          dd = d;

      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);
      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);
      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);
      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);
      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);
      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);
      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);
      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);
      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);
      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);
      c = FF(c, d, a, b, m[i+10], 17, -42063);
      b = FF(b, c, d, a, m[i+11], 22, -1990404162);
      a = FF(a, b, c, d, m[i+12],  7,  1804603682);
      d = FF(d, a, b, c, m[i+13], 12, -40341101);
      c = FF(c, d, a, b, m[i+14], 17, -1502002290);
      b = FF(b, c, d, a, m[i+15], 22,  1236535329);

      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);
      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);
      c = GG(c, d, a, b, m[i+11], 14,  643717713);
      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);
      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);
      d = GG(d, a, b, c, m[i+10],  9,  38016083);
      c = GG(c, d, a, b, m[i+15], 14, -660478335);
      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);
      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);
      d = GG(d, a, b, c, m[i+14],  9, -1019803690);
      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);
      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);
      a = GG(a, b, c, d, m[i+13],  5, -1444681467);
      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);
      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);
      b = GG(b, c, d, a, m[i+12], 20, -1926607734);

      a = HH(a, b, c, d, m[i+ 5],  4, -378558);
      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);
      c = HH(c, d, a, b, m[i+11], 16,  1839030562);
      b = HH(b, c, d, a, m[i+14], 23, -35309556);
      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);
      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);
      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);
      b = HH(b, c, d, a, m[i+10], 23, -1094730640);
      a = HH(a, b, c, d, m[i+13],  4,  681279174);
      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);
      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);
      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);
      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);
      d = HH(d, a, b, c, m[i+12], 11, -421815835);
      c = HH(c, d, a, b, m[i+15], 16,  530742520);
      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);

      a = II(a, b, c, d, m[i+ 0],  6, -198630844);
      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);
      c = II(c, d, a, b, m[i+14], 15, -1416354905);
      b = II(b, c, d, a, m[i+ 5], 21, -57434055);
      a = II(a, b, c, d, m[i+12],  6,  1700485571);
      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);
      c = II(c, d, a, b, m[i+10], 15, -1051523);
      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);
      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);
      d = II(d, a, b, c, m[i+15], 10, -30611744);
      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);
      b = II(b, c, d, a, m[i+13], 21,  1309151649);
      a = II(a, b, c, d, m[i+ 4],  6, -145523070);
      d = II(d, a, b, c, m[i+11], 10, -1120210379);
      c = II(c, d, a, b, m[i+ 2], 15,  718787259);
      b = II(b, c, d, a, m[i+ 9], 21, -343485551);

      a = (a + aa) >>> 0;
      b = (b + bb) >>> 0;
      c = (c + cc) >>> 0;
      d = (d + dd) >>> 0;
    }

    return crypt.endian([a, b, c, d]);
  };

  // Auxiliary functions
  md5._ff  = function (a, b, c, d, x, s, t) {
    var n = a + (b & c | ~b & d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._gg  = function (a, b, c, d, x, s, t) {
    var n = a + (b & d | c & ~d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._hh  = function (a, b, c, d, x, s, t) {
    var n = a + (b ^ c ^ d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._ii  = function (a, b, c, d, x, s, t) {
    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };

  // Package private blocksize
  md5._blocksize = 16;
  md5._digestsize = 16;

  module.exports = function (message, options) {
    var digestbytes = crypt.wordsToBytes(md5(message));
    return options && options.asBytes ? digestbytes :
        options && options.asString ? bin.bytesToString(digestbytes) :
        crypt.bytesToHex(digestbytes);
  };

})();

},{"crypt":73,"charenc":74}],50:[function(require,module,exports){
var qs = require('qs')
var parseUrl = require('url').parse
var resolveUrl = require('url').resolve
var renderRoute = require('./router').render
var currentPath = (window.location.pathname.slice(window.location.pathname.indexOf('index.html') + 10) + '/') + window.location.search

// Replace the initial state with the current URL immediately,
// so that it will be rendered if the state is later popped
if (window.history.replaceState) {
  window.history.replaceState({
    $render: true,
    $method: 'get'
  }, null, window.location.href)
}

module.exports = History

function History(createPage, routes) {
  this._createPage = createPage
  this._routes = routes

  if (window.history.pushState) {
    addListeners(this)
    return
  }
  this.push = function(url) {
    window.location.assign(url)
  }
  this.replace = function(url) {
    window.location.replace(url)
  }
  this.refresh = function() {
    window.location.reload()
  }
}

History.prototype.push = function(url, render, state, e) {
  this._update('pushState', url, render, state, e)
}

History.prototype.replace = function(url, render, state, e) {
  this._update('replaceState', url, render, state, e)
}

// Rerender the current url locally
History.prototype.refresh = function() {
  var path = routePath(window.location.href)
  renderRoute(this.page(), {url: path, previous: path, method: 'get'})
}

History.prototype.back = function() {
  window.history.back()
}

History.prototype.forward = function() {
  window.history.forward()
}

History.prototype.go = function(i) {
  window.history.go(i)
}

History.prototype._update = function(historyMethod, relativeUrl, render, state, e) {
  var url = resolveUrl(window.location.href, relativeUrl)
  var path = routePath(url)

  // TODO: history.push should set the window.location with external urls
  if (!path) return
  if (render == null) render = true
  if (state == null) state = {}

  // Update the URL
  var options = renderOptions(e, path)
  state.$render = true
  state.$method = options.method
  window.history[historyMethod](state, null, options.url)
  currentPath = (window.location.pathname.slice(window.location.pathname.indexOf('index.html') + 10) + '/') + window.location.search
  if (render) renderRoute(this.page(), options, e)
}

History.prototype.page = function() {
  if (this._page) return this._page

  var page = this._page = this._createPage()
  var history = this

  function redirect(url) {
    if (url === 'back') return history.back()
    // TODO: Add support for `basepath` option like Express
    if (url === 'home') url = '\\'
    history.replace(url, true)
  }

  page.redirect = redirect
  page._routes = this._routes
  return page
}

// Get the pathname if it is on the same protocol and domain
function routePath(url) {
  var match = parseUrl(url)
  return match &&
    match.protocol === window.location.protocol &&
    match.host === window.location.host &&
    match.pathname + (match.search || '')
}

function renderOptions(e, path) {
  // If this is a form submission, extract the form data and
  // append it to the url for a get or params.body for a post
  if (e && e.type === 'submit') {
    var form = e.target
    var elements = form.elements
    var query = []
    for (var i = 0, len = elements.length, el; i < len; i++) {
      el = elements[i]
      var name = el.name
      if (!name) continue
      var value = el.value
      query.push(encodeURIComponent(name) + '=' + encodeURIComponent(value))
      if (name === '_method') {
        var override = value.toLowerCase()
        if (override === 'delete') override = 'del'
      }
    }
    query = query.join('&')
    if (form.method.toLowerCase() === 'post') {
      var method = override || 'post'
      var body = qs.parse(query)
    } else {
      method = 'get'
      path += '?' + query
    }
  } else {
    method = 'get'
  }
  return {
    method: method
  , url: path
  , previous: (window.location.pathname.slice(window.location.pathname.indexOf('index.html') + 10) + '/') + window.location.search
  , body: body
  , form: form
  , link: e && e._tracksLink
  }
}

function addListeners(history) {

  // Detect clicks on links
  function onClick(e) {
    var el = e.target

    // Ignore command click, control click, and non-left click
    if (e.metaKey || e.which !== 1) return

    // Ignore if already prevented
    if (e.defaultPrevented || e.returnValue === false) return

    // Also look up for parent links (<a><img></a>)
    while (el) {
      var url = el.href
      if (url) {

        // Ignore if created by Tracks
        if (el.hasAttribute && el.hasAttribute('data-router-ignore')) return

        // Ignore links meant to open in a different window or frame
        if (el.target && el.target !== '_self') return

        // Ignore hash links to the same page
        var hashIndex = url.indexOf('#')
        if (~hashIndex && url.slice(0, hashIndex) === window.location.href.replace(/#.*/, '')) {
          return
        }

        e._tracksLink = el
        history.push(url, true, null, e)
        return
      }

      el = el.parentNode
    }
  }

  function onSubmit(e) {
    var target = e.target

    // Ignore if already prevented
    if (e.defaultPrevented || e.returnValue === false) return

    // Only handle if emitted on a form element that isn't multipart
    if (target.tagName.toLowerCase() !== 'form') return
    if (target.enctype === 'multipart/form-data') return

    // Ignore if created by Tracks
    if (target.hasAttribute && target.hasAttribute('data-router-ignore')) return

    // Use the url from the form action, defaulting to the current url
    var url = target.action || window.location.href
    history.push(url, true, null, e)
  }

  function onPopState(e) {
    var previous = currentPath
    var state = e.state
    currentPath = (window.location.pathname.slice(window.location.pathname.indexOf('index.html') + 10) + '/') + window.location.search

    var options = {
      previous: previous
    , url: currentPath
    }

    if (state) {
      if (!state.$render) return
      options.method = state.$method
      // Note that the post body is only sent on the initial reqest
      // and it is empty if the state is later popped
      return renderRoute(history.page(), options)
    }

    // The state object will be null for states created by jump links.
    // window.location.hash cannot be used, because it returns nothing
    // if the url ends in just a hash character
    var url = window.location.href
      , hashIndex = url.indexOf('#')
      , el, id
    if (~hashIndex && currentPath !== previous) {
      options.method = 'get'
      renderRoute(history.page(), options)
      id = url.slice(hashIndex + 1)
      if (el = document.getElementById(id) || document.getElementsByName(id)[0]) {
        el.scrollIntoView()
      }
    }
  }

  document.addEventListener('click', onClick, false)
  document.addEventListener('submit', onSubmit, false)
  window.addEventListener('popstate', onPopState, false)
}

},{"url":47,"./router":51,"qs":72}],67:[function(require,module,exports){

exports.Connection = require('./connection').Connection;
exports.Doc = require('./doc').Doc;

},{"./connection":75,"./doc":76}],72:[function(require,module,exports){
/**
 * Object#toString() ref for stringify().
 */

var toString = Object.prototype.toString;

/**
 * Object#hasOwnProperty ref
 */

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Array#indexOf shim.
 */

var indexOf = typeof Array.prototype.indexOf === 'function'
  ? function(arr, el) { return arr.indexOf(el); }
  : function(arr, el) {
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] === el) return i;
      }
      return -1;
    };

/**
 * Array.isArray shim.
 */

var isArray = Array.isArray || function(arr) {
  return toString.call(arr) == '[object Array]';
};

/**
 * Object.keys shim.
 */

var objectKeys = Object.keys || function(obj) {
  var ret = [];
  for (var key in obj) ret.push(key);
  return ret;
};

/**
 * Array#forEach shim.
 */

var forEach = typeof Array.prototype.forEach === 'function'
  ? function(arr, fn) { return arr.forEach(fn); }
  : function(arr, fn) {
      for (var i = 0; i < arr.length; i++) fn(arr[i]);
    };

/**
 * Array#reduce shim.
 */

var reduce = function(arr, fn, initial) {
  if (typeof arr.reduce === 'function') return arr.reduce(fn, initial);
  var res = initial;
  for (var i = 0; i < arr.length; i++) res = fn(res, arr[i]);
  return res;
};

/**
 * Create a nullary object if possible
 */

function createObject() {
  return Object.create
    ? Object.create(null)
    : {};
}

/**
 * Cache non-integer test regexp.
 */

var isint = /^[0-9]+$/;

function promote(parent, key) {
  if (parent[key].length == 0) return parent[key] = createObject();
  var t = createObject();
  for (var i in parent[key]) {
    if (hasOwnProperty.call(parent[key], i)) {
      t[i] = parent[key][i];
    }
  }
  parent[key] = t;
  return t;
}

function parse(parts, parent, key, val) {
  var part = parts.shift();
  // end
  if (!part) {
    if (isArray(parent[key])) {
      parent[key].push(val);
    } else if ('object' == typeof parent[key]) {
      parent[key] = val;
    } else if ('undefined' == typeof parent[key]) {
      parent[key] = val;
    } else {
      parent[key] = [parent[key], val];
    }
    // array
  } else {
    var obj = parent[key] = parent[key] || [];
    if (']' == part) {
      if (isArray(obj)) {
        if ('' != val) obj.push(val);
      } else if ('object' == typeof obj) {
        obj[objectKeys(obj).length] = val;
      } else {
        obj = parent[key] = [parent[key], val];
      }
      // prop
    } else if (~indexOf(part, ']')) {
      part = part.substr(0, part.length - 1);
      if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
      parse(parts, obj, part, val);
      // key
    } else {
      if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
      parse(parts, obj, part, val);
    }
  }
}

/**
 * Merge parent key/val pair.
 */

function merge(parent, key, val){
  if (~indexOf(key, ']')) {
    var parts = key.split('[')
      , len = parts.length
      , last = len - 1;
    parse(parts, parent, 'base', val);
    // optimize
  } else {
    if (!isint.test(key) && isArray(parent.base)) {
      var t = createObject();
      for (var k in parent.base) t[k] = parent.base[k];
      parent.base = t;
    }
    set(parent.base, key, val);
  }

  return parent;
}

/**
 * Compact sparse arrays.
 */

function compact(obj) {
  if ('object' != typeof obj) return obj;

  if (isArray(obj)) {
    var ret = [];

    for (var i in obj) {
      if (hasOwnProperty.call(obj, i)) {
        ret.push(obj[i]);
      }
    }

    return ret;
  }

  for (var key in obj) {
    obj[key] = compact(obj[key]);
  }

  return obj;
}

/**
 * Restore Object.prototype.
 * see pull-request #58
 */

function restoreProto(obj) {
  if (!Object.create) return obj;
  if (isArray(obj)) return obj;
  if (obj && 'object' != typeof obj) return obj;

  for (var key in obj) {
    if (hasOwnProperty.call(obj, key)) {
      obj[key] = restoreProto(obj[key]);
    }
  }

  obj.__proto__ = Object.prototype;
  return obj;
}

/**
 * Parse the given obj.
 */

function parseObject(obj){
  var ret = { base: {} };

  forEach(objectKeys(obj), function(name){
    merge(ret, name, obj[name]);
  });

  return compact(ret.base);
}

/**
 * Parse the given str.
 */

function parseString(str){
  var ret = reduce(String(str).split('&'), function(ret, pair){
    var eql = indexOf(pair, '=')
      , brace = lastBraceInKey(pair)
      , key = pair.substr(0, brace || eql)
      , val = pair.substr(brace || eql, pair.length)
      , val = val.substr(indexOf(val, '=') + 1, val.length);

    // ?foo
    if ('' == key) key = pair, val = '';
    if ('' == key) return ret;

    return merge(ret, decode(key), decode(val));
  }, { base: createObject() }).base;

  return restoreProto(compact(ret));
}

/**
 * Parse the given query `str` or `obj`, returning an object.
 *
 * @param {String} str | {Object} obj
 * @return {Object}
 * @api public
 */

exports.parse = function(str){
  if (null == str || '' == str) return {};
  return 'object' == typeof str
    ? parseObject(str)
    : parseString(str);
};

/**
 * Turn the given `obj` into a query string
 *
 * @param {Object} obj
 * @return {String}
 * @api public
 */

var stringify = exports.stringify = function(obj, prefix) {
  if (isArray(obj)) {
    return stringifyArray(obj, prefix);
  } else if ('[object Object]' == toString.call(obj)) {
    return stringifyObject(obj, prefix);
  } else if ('string' == typeof obj) {
    return stringifyString(obj, prefix);
  } else {
    return prefix + '=' + encodeURIComponent(String(obj));
  }
};

/**
 * Stringify the given `str`.
 *
 * @param {String} str
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyString(str, prefix) {
  if (!prefix) throw new TypeError('stringify expects an object');
  return prefix + '=' + encodeURIComponent(str);
}

/**
 * Stringify the given `arr`.
 *
 * @param {Array} arr
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyArray(arr, prefix) {
  var ret = [];
  if (!prefix) throw new TypeError('stringify expects an object');
  for (var i = 0; i < arr.length; i++) {
    ret.push(stringify(arr[i], prefix + '[' + i + ']'));
  }
  return ret.join('&');
}

/**
 * Stringify the given `obj`.
 *
 * @param {Object} obj
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyObject(obj, prefix) {
  var ret = []
    , keys = objectKeys(obj)
    , key;

  for (var i = 0, len = keys.length; i < len; ++i) {
    key = keys[i];
    if ('' == key) continue;
    if (null == obj[key]) {
      ret.push(encodeURIComponent(key) + '=');
    } else {
      ret.push(stringify(obj[key], prefix
        ? prefix + '[' + encodeURIComponent(key) + ']'
        : encodeURIComponent(key)));
    }
  }

  return ret.join('&');
}

/**
 * Set `obj`'s `key` to `val` respecting
 * the weird and wonderful syntax of a qs,
 * where "foo=bar&foo=baz" becomes an array.
 *
 * @param {Object} obj
 * @param {String} key
 * @param {String} val
 * @api private
 */

function set(obj, key, val) {
  var v = obj[key];
  if (undefined === v) {
    obj[key] = val;
  } else if (isArray(v)) {
    v.push(val);
  } else {
    obj[key] = [v, val];
  }
}

/**
 * Locate last brace in `str` within the key.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function lastBraceInKey(str) {
  var len = str.length
    , brace
    , c;
  for (var i = 0; i < len; ++i) {
    c = str[i];
    if (']' == c) brace = false;
    if ('[' == c) brace = true;
    if ('=' == c && !brace) return i;
  }
}

/**
 * Decode `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function decode(str) {
  try {
    return decodeURIComponent(str.replace(/\+/g, ' '));
  } catch (err) {
    return str;
  }
}

},{}],73:[function(require,module,exports){
(function() {
  var base64map
      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',

  crypt = {
    // Bit-wise rotation left
    rotl: function(n, b) {
      return (n << b) | (n >>> (32 - b));
    },

    // Bit-wise rotation right
    rotr: function(n, b) {
      return (n << (32 - b)) | (n >>> b);
    },

    // Swap big-endian to little-endian and vice versa
    endian: function(n) {
      // If number given, swap endian
      if (n.constructor == Number) {
        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
      }

      // Else, assume array and swap all items
      for (var i = 0; i < n.length; i++)
        n[i] = crypt.endian(n[i]);
      return n;
    },

    // Generate an array of any length of random bytes
    randomBytes: function(n) {
      for (var bytes = []; n > 0; n--)
        bytes.push(Math.floor(Math.random() * 256));
      return bytes;
    },

    // Convert a byte array to big-endian 32-bit words
    bytesToWords: function(bytes) {
      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
        words[b >>> 5] |= bytes[i] << (24 - b % 32);
      return words;
    },

    // Convert big-endian 32-bit words to a byte array
    wordsToBytes: function(words) {
      for (var bytes = [], b = 0; b < words.length * 32; b += 8)
        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a hex string
    bytesToHex: function(bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 0xF).toString(16));
      }
      return hex.join('');
    },

    // Convert a hex string to a byte array
    hexToBytes: function(hex) {
      for (var bytes = [], c = 0; c < hex.length; c += 2)
        bytes.push(parseInt(hex.substr(c, 2), 16));
      return bytes;
    },

    // Convert a byte array to a base-64 string
    bytesToBase64: function(bytes) {
      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
        for (var j = 0; j < 4; j++)
          if (i * 8 + j * 6 <= bytes.length * 8)
            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
          else
            base64.push('=');
      }
      return base64.join('');
    },

    // Convert a base-64 string to a byte array
    base64ToBytes: function(base64) {
      // Remove non-base-64 characters
      base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;
          imod4 = ++i % 4) {
        if (imod4 == 0) continue;
        bytes.push(((base64map.indexOf(base64.charAt(i - 1))
            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))
            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
      }
      return bytes;
    }
  };

  module.exports = crypt;
})();

},{}],74:[function(require,module,exports){
var charenc = {
  // UTF-8 encoding
  utf8: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
    }
  },

  // Binary encoding
  bin: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      for (var bytes = [], i = 0; i < str.length; i++)
        bytes.push(str.charCodeAt(i) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      for (var str = [], i = 0; i < bytes.length; i++)
        str.push(String.fromCharCode(bytes[i]));
      return str.join('');
    }
  }
};

module.exports = charenc;

},{}],77:[function(require,module,exports){
// This is a simple rewrite of microevent.js. I've changed the
// function names to be consistent with node.js EventEmitter.
//
// microevent.js is copyright Jerome Etienne, and licensed under the MIT license:
// https://github.com/jeromeetienne/microevent.js

var MicroEvent = function() {};

MicroEvent.prototype.on = function(event, fn) {
  var events = this._events = this._events || {};
  (events[event] = events[event] || []).push(fn);
};

MicroEvent.prototype.removeListener = function(event, fn) {
  var events = this._events = this._events || {};
  var listeners = events[event] = events[event] || [];

  // Sadly, no IE8 support for indexOf.
  var i = 0;
  while (i < listeners.length) {
    if (listeners[i] === fn) {
      listeners[i] = undefined;
    }
    i++;
  }

  // Compact the list when no event handler is actually running.
  setTimeout(function() {
    events[event] = [];
    var fn;
    for (var i = 0; i < listeners.length; i++) {
      // Only add back event handlers which exist.
      if ((fn = listeners[i])) events[event].push(fn);
    }
  }, 0);
};

MicroEvent.prototype.emit = function(event) {
  var events = this._events;
  var args = Array.prototype.splice.call(arguments, 1);

  if (!events || !events[event]) {
    if (event == 'error') {
      if (console) {
        console.error.apply(console, args);
      }
    }
    return;
  }

  var listeners = events[event];
  for (var i = 0; i < listeners.length; i++) {
    if (listeners[i]) {
      listeners[i].apply(this, args);
    }
  }
};

MicroEvent.prototype.once = function(event, fn) {
  var listener, _this = this;
  this.on(event, listener = function() {
    _this.removeListener(event, listener);
    fn.apply(_this, arguments);
  });
};

MicroEvent.mixin = function(obj) {
  var proto = obj.prototype || obj;
  proto.on = MicroEvent.prototype.on;
  proto.removeListener = MicroEvent.prototype.removeListener;
  proto.emit = MicroEvent.prototype.emit;
  proto.once = MicroEvent.prototype.once;
  return obj;
};

if (typeof module !== "undefined") module.exports = MicroEvent;


},{}],78:[function(require,module,exports){
var Doc;
if (typeof require !== 'undefined') {
  Doc = require('./doc').Doc;
}

// Queries are live requests to the database for particular sets of fields.
//
// The server actively tells the client when there's new data that matches
// a set of conditions.
var Query = exports.Query = function(type, connection, id, collection, query, options, callback) {
  // 'fetch' or 'sub'
  this.type = type;

  this.connection = connection;
  this.id = id;
  this.collection = collection;

  // The query itself. For mongo, this should look something like {"data.x":5}
  this.query = query;

  // Resultant document action for the server. Fetch mode will automatically
  // fetch all results. Subscribe mode will automatically subscribe all
  // results. Results are never unsubscribed.
  this.docMode = options.docMode; // undefined, 'fetch' or 'sub'.
  if (this.docMode === 'subscribe') this.docMode = 'sub';

  // Do we repoll the entire query whenever anything changes? (As opposed to
  // just polling the changed item). This needs to be enabled to be able to use
  // ordered queries (sortby:) and paginated queries. Set to undefined, it will
  // be enabled / disabled automatically based on the query's properties.
  this.poll = options.poll;

  // The backend we actually hit. If this isn't defined, it hits the snapshot
  // database. Otherwise this can be used to hit another configured query
  // index.
  this.backend = options.backend || options.source;

  // A list of resulting documents. These are actual documents, complete with
  // data and all the rest. If fetch is false, these documents will not
  // have any data. You should manually call fetch() or subscribe() on them.
  //
  // Calling subscribe() might be a good idea anyway, as you won't be
  // subscribed to the documents by default.
  this.knownDocs = options.knownDocs || [];
  this.results = [];

  // Do we have some initial data?
  this.ready = false;

  this.callback = callback;
};
Query.prototype.action = 'qsub';

// Helper for subscribe & fetch, since they share the same message format.
//
// This function actually issues the query.
Query.prototype._execute = function() {
  if (!this.connection.canSend) return;

  if (this.docMode) {
    var collectionVersions = {};
    // Collect the version of all the documents in the current result set so we
    // don't need to be sent their snapshots again.
    for (var i = 0; i < this.knownDocs.length; i++) {
      var doc = this.knownDocs[i];
      var c = collectionVersions[doc.collection] = collectionVersions[doc.collection] || {};
      c[doc.name] = doc.version;
    }
  }

  var msg = {
    a: 'q' + this.type,
    id: this.id,
    c: this.collection,
    o: {},
    q: this.query,
  };

  if (this.docMode) {
    msg.o.m = this.docMode;
    // This should be omitted if empty, but whatever.
    msg.o.vs = collectionVersions;
  }
  if (this.backend != null) msg.o.b = this.backend;
  if (this.poll !== undefined) msg.o.p = this.poll;

  this.connection.send(msg);
};

// Make a list of documents from the list of server-returned data objects
Query.prototype._dataToDocs = function(data) {
  var results = [];
  var lastType;
  for (var i = 0; i < data.length; i++) {
    var docData = data[i];

    // Types are only put in for the first result in the set and every time the type changes in the list.
    if (docData.type) {
      lastType = docData.type;
    } else {
      docData.type = lastType;
    }

    var doc = this.connection.get(docData.c || this.collection, docData.d, docData);
    // Force the document to know its subscribed if we're in docmode:subscribe.
    if (this.docMode === 'sub') {
      doc.subscribed = true; // Set before setWantSubscribe() so flush doesn't send a subscribe request.
      doc._setWantSubscribe(true); // this will call any subscribe callbacks or whatever.
      doc.emit('subscribe');
      doc._finishSub(true); // this doesn't actually do anything here, but its more correct to have it.
    }
    results.push(doc);
  }
  return results;
};

// Destroy the query object. Any subsequent messages for the query will be
// ignored by the connection. You should unsubscribe from the query before
// destroying it.
Query.prototype.destroy = function() {
  if (this.connection.canSend && this.type === 'sub') {
    this.connection.send({a:'qunsub', id:this.id});
  }

  this.connection._destroyQuery(this);
};

Query.prototype._onConnectionStateChanged = function(state, reason) {
  if (this.connection.state === 'connecting') {
    this._execute();
  }
};

// Internal method called from connection to pass server messages to the query.
Query.prototype._onMessage = function(msg) {
  if ((msg.a === 'qfetch') !== (this.type === 'fetch')) {
    if (console) console.warn('Invalid message sent to query', msg, this);
    return;
  }

  if (msg.error) this.emit('error', msg.error);

  switch (msg.a) {
    case 'qfetch':
      var results = msg.data ? this._dataToDocs(msg.data) : undefined;
      if (this.callback) this.callback(msg.error, results, msg.extra);
      // Once a fetch query gets its data, it is destroyed.
      this.connection._destroyQuery(this);
      break;

    case 'q':
      // Query diff data (inserts and removes)
      if (msg.diff) {
        // We need to go through the list twice. First, we'll injest all the
        // new documents and set them as subscribed.  After that we'll emit
        // events and actually update our list. This avoids race conditions
        // around setting documents to be subscribed & unsubscribing documents
        // in event callbacks.
        for (var i = 0; i < msg.diff.length; i++) {
          var d = msg.diff[i];
          if (d.type === 'insert') d.values = this._dataToDocs(d.values);
        }

        for (var i = 0; i < msg.diff.length; i++) {
          var d = msg.diff[i];
          switch (d.type) {
            case 'insert':
              var newDocs = d.values;
              Array.prototype.splice.apply(this.results, [d.index, 0].concat(newDocs));
              this.emit('insert', newDocs, d.index);
              break;
            case 'remove':
              var howMany = d.howMany || 1;
              var removed = this.results.splice(d.index, howMany);
              this.emit('remove', removed, d.index);
              break;
            case 'move':
              var howMany = d.howMany || 1;
              var docs = this.results.splice(d.from, howMany);
              Array.prototype.splice.apply(this.results, [d.to, 0].concat(docs));
              this.emit('move', docs, d.from, d.to);
              break;
          }
        }
      }

      if (msg.extra) {
        this.emit('extra', msg.extra);
      }
      break;
    case 'qsub':
      // This message replaces the entire result set with the set passed.
      if (!msg.error) {
        var previous = this.results;

        // Then add everything in the new result set.
        this.results = this.knownDocs = this._dataToDocs(msg.data);
        this.extra = msg.extra;

        this.ready = true;
        this.emit('change', this.results, previous);
      }
      if (this.callback) {
        this.callback(msg.error, this.results, this.extra);
        delete this.callback;
      }
      break;
  }
};

// Change the thing we're searching for. This isn't fully supported on the
// backend (it destroys the old query and makes a new one) - but its
// programatically useful and I might add backend support at some point.
Query.prototype.setQuery = function(q) {
  if (this.type !== 'sub') throw new Error('cannot change a fetch query');

  this.query = q;
  if (this.connection.canSend) {
    // There's no 'change' message to send to the server. Just resubscribe.
    this.connection.send({a:'qunsub', id:this.id});
    this._execute();
  }
};

var MicroEvent;
if (typeof require !== 'undefined') {
  MicroEvent = require('./microevent');
}

MicroEvent.mixin(Query);


},{"./doc":76,"./microevent":77}],75:[function(require,module,exports){
// A Connection wraps a persistant BC connection to a sharejs server.
//
// This class implements the client side of the protocol defined here:
// https://github.com/josephg/ShareJS/wiki/Wire-Protocol
//
// The equivalent server code is in src/server/session.
//
// This file is a bit of a mess. I'm dreadfully sorry about that. It passes all the tests,
// so I have hope that its *correct* even if its not clean.
//
// To make a connection, use:
//  new sharejs.Connection(socket)
//
// The socket should look like a websocket connection. It should have the following properties:
//  send(msg): Send the given message. msg may be an object - if so, you might need to JSON.stringify it.
//  close(): Disconnect the session
//
//  onmessage = function(msg){}: Event handler which is called whenever a message is received. The message
//     passed in should already be an object. (It may need to be JSON.parsed)
//  onclose
//  onerror
//  onopen
//  onconnecting
//
// The socket should probably automatically reconnect. If so, it should emit the appropriate events as it
// disconnects & reconnects. (onclose(), onconnecting(), onopen()).

var types, Doc;
if (typeof require !== 'undefined') {
  types = require('ottypes');
  Doc = require('./doc').Doc;
  Query = require('./query').Query;
} else {
  types = window.ottypes;
  Doc = exports.Doc;
}

var Connection = exports.Connection = function (socket) {
  this.socket = socket;

  // Map of collection -> docName -> doc object for created documents.
  // (created documents MUST BE UNIQUE)
  this.collections = {};

  // Each query is created with an id that the server uses when it sends us
  // info about the query (updates, etc).
  //this.nextQueryId = (Math.random() * 1000) |0;
  this.nextQueryId = 1;

  // Map from query ID -> query object.
  this.queries = {};

  // Connection state.
  // 
  // States:
  // - 'connecting': The connection has been established, but we don't have our client ID yet
  // - 'connected': We have connected and recieved our client ID. Ready for data.
  // - 'disconnected': The connection is closed, but it will reconnect automatically.
  // - 'stopped': The connection is closed, and should not reconnect.
  this.state = (socket.readyState === 0 || socket.readyState === 1) ? 'connecting' : 'disconnected';

  // This is a helper variable the document uses to see whether we're currently
  // in a 'live' state. It is true if the state is 'connecting' or 'connected'.
  this.canSend = this.state === 'connecting';

  // Reset some more state variables.
  this.reset();

  this.debug = false;
  // I'll store the most recent 100 messages so when errors occur we can see what happened.
  this.messageBuffer = [];

  var connection = this;

  var handleMessage = function(msg) {
    // Switch on the message action. Most messages are for documents and are
    // handled in the doc class.
    switch (msg.a) {
      case 'init':
        // Client initialization packet. This bundle of joy contains our client
        // ID.
        if (msg.protocol !== 0) throw new Error('Invalid protocol version');
        if (typeof msg.id != 'string') throw new Error('Invalid client id');

        connection.id = msg.id;
        connection._setState('connected');
        break;

      case 'qfetch':
      case 'qsub':
      case 'q':
      case 'qunsub':
        // Query message. Pass this to the appropriate query object.
        var query = connection.queries[msg.id];
        if (query) query._onMessage(msg);
        break;

      case 'bs':
        // Bulk subscribe response. The responses for each document are contained within.
        var result = msg.s;
        for (var cName in result) {
          for (var docName in result[cName]) {
            var doc = connection.get(cName, docName);
            if (!doc) {
              if (console) console.error('Message for unknown doc. Ignoring.', msg);
              break;
            }

            var msg = result[cName][docName];
            if (typeof msg === 'object') {
              doc._handleSubscribe(msg.error, msg.data);
            } else {
              // The msg will be true if we simply resubscribed.
              doc._handleSubscribe(null, null);
            }
          }
        }
        break;

      default:
        // Document message. Pull out the referenced document and forward the
        // message.
        var collection, docName, doc;
        if (msg.d) {
          collection = connection._lastReceivedCollection = msg.c;
          docName = connection._lastReceivedDoc = msg.d;
        } else {
          collection = msg.c = connection._lastReceivedCollection;
          docName = msg.d = connection._lastReceivedDoc;
        }

        doc = connection.get(collection, docName);
        if (!doc) {
          if (console) console.error('Message for unknown doc. Ignoring.', msg);
          break;
        }
        doc._onMessage(msg);
    }
  };

  // Attach event handlers to the socket.
  socket.onmessage = function(msg) {
    if (connection.debug) console.log('RECV', JSON.stringify(msg));
    connection.messageBuffer.push({t:(new Date()).toTimeString(), recv:JSON.stringify(msg)});
    while (connection.messageBuffer.length > 100) {
      connection.messageBuffer.shift();
    }

    try {
      handleMessage(msg);
    } catch (e) {
      connection.emit('error', e);
      // We could also restart the connection here, although that might result
      // in infinite reconnection bugs.
    }
  }

  socket.onopen = function() {
    connection._setState('connecting');
  };

  socket.onerror = function(e) {
    // This isn't the same as a regular error, because it will happen normally
    // from time to time. Your connection should probably automatically
    // reconnect anyway, but that should be triggered off onclose not onerror.
    // (onclose happens when onerror gets called anyway).
    connection.emit('connection error', e);
  };

  socket.onclose = function(reason) {
    connection._setState('disconnected', reason);
    if (reason === 'Closed' || reason === 'Stopped by server') {
      connection._setState('stopped', reason);
    }
  };
}

/* Why does this function exist? Is it important?
Connection.prototype._error = function(e) {
  this._setState('stopped', e);
  return this.disconnect(e);
};
*/

Connection.prototype.reset = function() {
  this.id = this.lastError =
    this._lastReceivedCollection = this._lastReceivedDoc =
    this._lastSentCollection = this._lastSentDoc = null;

  this.seq = 1;
};

// Set the connection's state. The connection is basically a state machine.
Connection.prototype._setState = function(newState, data) {
  if (this.state === newState) return;

  // I made a state diagram. The only invalid transitions are getting to
  // 'connecting' from anywhere other than 'disconnected' and getting to
  // 'connected' from anywhere other than 'connecting'.
  if ((newState === 'connecting' && (this.state !== 'disconnected' && this.state !== 'stopped'))
      || (newState === 'connected' && this.state !== 'connecting')) {
    throw new Error("Cannot transition directly from " + this.state + " to " + newState);
  }

  this.state = newState;
  this.canSend = newState === 'connecting' || newState === 'connected';

  if (newState === 'disconnected') this.reset();

  this.emit(newState, data);

  // & Emit the event to all documents & queries. It might make sense for
  // documents to just register for this stuff using events, but that couples
  // connections and documents a bit much. Its not a big deal either way.
  this.opQueue = [];
  this.subscribeData = {};
  for (var c in this.collections) {
    var collection = this.collections[c];
    for (var docName in collection) {
      collection[docName]._onConnectionStateChanged(newState, data);
    }
  }


  // Its important that operations are resent in the same order that they were
  // originally sent. If we don't sort, an op with a high sequence number will
  // convince the server not to accept any ops with earlier sequence numbers.
  this.opQueue.sort(function(a, b) { return a.seq - b.seq; });
  for (var i = 0; i < this.opQueue.length; i++) {
    this.send(this.opQueue[i]);
  }

  // Only send bulk subscribe if not empty. Its weird using a for loop for
  // this, but it works pretty well.
  for (var __unused in this.subscribeData) { 
    this.send({a:'bs', s:this.subscribeData});
    break;
  }

  this.opQueue = null;
  this.subscribeData = null;
  
  // No bulk subscribe for queries yet.
  for (var id in this.queries) {
    this.queries[id]._onConnectionStateChanged(newState, data);
  }
};

// So, there's an awful error case where the client sends two requests (which
// fail), then reconnects. The documents could have _onConnectionStateChanged
// called in the wrong order and the operations then get sent with reversed
// sequence numbers. This causes the server to incorrectly reject the second
// sent op. So we need to queue the operations while we're reconnecting and
// resend them in the correct order.
Connection.prototype.sendOp = function(data) {
  if (this.opQueue) {
    this.opQueue.push(data);
  } else {
    this.send(data);
  }
};

// This is called by the document class when the document wants to subscribe.
// We could just send a subscribe message, but during reconnect that causes a
// bajillion messages over browserchannel. During reconnect we'll aggregate,
// similar to sendOp.
Connection.prototype.sendSubscribe = function(collection, name, v) {
  if (this.subscribeData) {
    var data = this.subscribeData;
    if (!data[collection]) data[collection] = {};

    data[collection][name] = v || null;
  } else {
    var msg = {a:'sub', c:collection, d:name};
    if (v != null) msg.v = v;
    this.send(msg);
  }
};

// Send a message to the connection.
Connection.prototype.send = function(msg) {
  if (this.debug) console.log("SEND", JSON.stringify(msg));
  this.messageBuffer.push({t:Date.now(), send:JSON.stringify(msg)});
  while (this.messageBuffer.length > 100) {
    this.messageBuffer.shift();
  }

  if (msg.d) { // The document the message refers to. Not set for queries.
    var collection = msg.c;
    var docName = msg.d;
    if (collection === this._lastSentCollection && docName === this._lastSentDoc) {
      delete msg.c;
      delete msg.d;
    } else {
      this._lastSentCollection = collection;
      this._lastSentDoc = docName;
    }
  }

  this.socket.send(msg);
};

Connection.prototype.disconnect = function() {
  // This will call @socket.onclose(), which in turn will emit the 'disconnected' event.
  this.socket.close();
};


// ***** Document management

Connection.prototype.getExisting = function(collection, name) {
  if (this.collections[collection]) return this.collections[collection][name];
};

Connection.prototype.getOrCreate = function(collection, name, data) {
  console.trace('getOrCreate is deprecated. Use get() instead');
  return this.get(collection, name, data);
};

// Create a document if it doesn't exist. Returns the document synchronously.
Connection.prototype.get = function(collection, name, data) {
  var doc = this.getExisting(collection, name);

  if (!doc) {
    // Create it.
    doc = new Doc(this, collection, name);

    var collectionObject = this.collections[collection] =
      (this.collections[collection] || {});
    collectionObject[name] = doc;
  }

  // Even if the document isn't new, its possible the document was created
  // manually and then tried to be re-created with data (suppose a query
  // returns with data for the document). We should hydrate the document
  // immediately if we can because the query callback will expect the document
  // to have data.
  if (data && data.data !== undefined && !doc.state) {
    doc.injestData(data);
  }

  return doc;
};

// Call doc.destroy()
Connection.prototype._destroyDoc = function(doc) {
  var collectionObject = this.collections[doc.collection];
  if (!collectionObject) return;

  delete collectionObject[doc.name];

  // Delete the collection container if its empty. This could be a source of
  // memory leaks if you slowly make a billion collections, which you probably
  // won't do anyway, but whatever.
  if (!hasKeys(collectionObject))
    delete this.collections[doc.collection];
};
 
function hasKeys(object) {
  for (var key in object) return true;
  return false;
};

// **** Queries.

// Helper for createFetchQuery and createSubscribeQuery, below.
Connection.prototype._createQuery = function(type, collection, q, options, callback) {
  if (type !== 'fetch' && type !== 'sub')
    throw new Error('Invalid query type: ' + type);

  if (!options) options = {};
  var id = this.nextQueryId++;
  var query = new Query(type, this, id, collection, q, options, callback);
  this.queries[id] = query;
  query._execute();
  return query;
};

// Internal function. Use query.destroy() to remove queries.
Connection.prototype._destroyQuery = function(query) {
  delete this.queries[query.id];
};

// The query options object can contain the following fields:
//
// docMode: What to do with documents that are in the result set. Can be
//   null/undefined (default), 'fetch' or 'subscribe'. Fetch mode indicates
//   that the server should send document snapshots to the client for all query
//   results. These will be hydrated into the document objects before the query
//   result callbacks are returned. Subscribe mode gets document snapshots and
//   automatically subscribes the client to all results. Note that the
//   documents *WILL NOT* be automatically unsubscribed when the query is
//   destroyed. (ShareJS doesn't have enough information to do that safely).
//   Beware of memory leaks when using this option.
//
// poll: Forcably enable or disable polling mode. Polling mode will reissue the query
//   every time anything in the collection changes (!!) so, its quite
//   expensive.  It is automatically enabled for paginated and sorted queries.
//   By default queries run with polling mode disabled; which will only check
//   changed documents to test if they now match the specified query.
//   Set to false to disable polling mode, or true to enable it. If you don't
//   specify a poll option, polling mode is enabled or disabled automatically
//   by the query's backend.
//
// backend: Set the backend source for the query. You can attach different
//   query backends to livedb and pick which one the query should hit using
//   this parameter.
//
// results: (experimental) Initial list of resultant documents. This is
//   useful for rehydrating queries when you're using autoFetch / autoSubscribe
//   so the server doesn't have to send over snapshots for documents the client
//   already knows about. This is experimental - the API may change in upcoming
//   versions.

// Create a fetch query. Fetch queries are only issued once, returning the
// results directly into the callback.
//
// The index is specific to the source, but if you're using mongodb it'll be
// the collection to which the query is made.
// The callback should have the signature function(error, results, extraData)
// where results is a list of Doc objects.
Connection.prototype.createFetchQuery = function(index, q, options, callback) {
  return this._createQuery('fetch', index, q, options, callback);
};

// Create a subscribe query. Subscribe queries return with the initial data
// through the callback, then update themselves whenever the query result set
// changes via their own event emitter.
//
// If present, the callback should have the signature function(error, results, extraData)
// where results is a list of Doc objects.
Connection.prototype.createSubscribeQuery = function(index, q, options, callback) {
  return this._createQuery('sub', index, q, options, callback);
};

if (typeof require !== 'undefined') {
  MicroEvent = require('./microevent');
}

MicroEvent.mixin(Connection);


},{"./doc":76,"./query":78,"./microevent":77,"ottypes":79}],76:[function(require,module,exports){
var types, MicroEvent;

if (typeof require !== "undefined") {
  types = require('ottypes');
  MicroEvent = require('./microevent');
} else {
  types = window.ottypes;
}

/*
 * A Doc is a client's view on a sharejs document.
 *
 * Documents should not be created directly. Create them by calling the
 * document getting functions in connection.
 *
 * Documents are event emitters. Use doc.on(eventname, fn) to subscribe.
 *
 * Documents currently get mixed in with their type's API methods. So, you can
 * .insert('foo', 0) into a text document and stuff like that.
 *
 * Events:
 * - before op (op, localSite): Fired before an operation is applied to the
 *   document.
 * - op (op, localSite): Fired right after an operation (or part of an
 *   operation) has been applied to the document. Submitting another op here is
 *   invalid - wait until 'after op' if you want to submit more operations.  -
 *   changed (op)
 * - after op (op, localSite): Fired after an operation has been applied. You
 *   can submit more ops here.
 * - subscribed (error): The document was subscribed
 * - unsubscribed (error): The document was unsubscribed
 * - created: The document was created. That means its type was set and it has
 *   some initial data.
 * - error
 */
var Doc = exports.Doc = function(connection, collection, name) {
  this.connection = connection;

  this.collection = collection;
  this.name = name;

  this.version = this.type = null;

  // **** State in document:
 
  // Action. This is either null, or one of the actions (subscribe,
  // unsubscribe, fetch, submit). Only one action can be happening at a time to
  // prevent me from going mad.
  //
  // Possible values:
  // - subscribe
  // - unsubscribe
  // - fetch
  // - submit
  this.action = null;
 
  // The data the document object stores can be in one of the following three states:
  //   - No data. (null) We honestly don't know whats going on.
  //   - Floating ('floating'): we have a locally created document that hasn't
  //     been created on the server yet)
  //   - Live ('ready') (we have data thats current on the server at some version).
  this.state = null;

  // Our subscription status. Either we're subscribed on the server, or we aren't.
  this.subscribed = false;
  // Either we want to be subscribed (true), we want a new snapshot from the
  // server ('fetch'), or we don't care (false).  This is also used when we
  // disconnect & reconnect to decide what to do.
  this.wantSubscribe = false;
  // This list is used for subscribe and unsubscribe, since we'll only want to
  // do one thing at a time.
  this._subscribeCallbacks = [];


  // *** end state stuff.

  // This doesn't provide any standard API access right now.
  this.provides = {};

  // The editing contexts. These are usually instances of the type API when the
  // document is ready for edits.
  this.editingContexts = [];
  
  // The op that is currently roundtripping to the server, or null.
  //
  // When the connection reconnects, the inflight op is resubmitted.
  //
  // This has the same format as an entry in pendingData, which is:
  // {[create:{...}], [del:true], [op:...], callbacks:[...], src:, seq:}
  this.inflightData = null;

  // All ops that are waiting for the server to acknowledge @inflightData
  // This used to just be a single operation, but creates & deletes can't be composed with
  // regular operations.
  //
  // This is a list of {[create:{...}], [del:true], [op:...], callbacks:[...]}
  this.pendingData = [];
};

MicroEvent.mixin(Doc);

Doc.prototype.destroy = function(callback) {
  var doc = this;
  this.unsubscribe(function() {
    // Don't care if there's an error unsubscribing.

    setTimeout(function() {
      // There'll probably be nothing here seeing as how we just unsubscribed.
      for (var i = 0; i < doc._subscribeCallbacks.length; i++) {
        doc._subscribeCallbacks[i]('Document destroyed');
      }
      doc._subscribeCallbacks.length = 0;
    }, 0);

    doc.connection._destroyDoc(doc);
    doc.removeContexts();
    if (callback) callback();
  });
};


// ****** Manipulating the document snapshot, version and type.

// Set the document's type, and associated properties. Most of the logic in
// this function exists to update the document based on any added & removed API
// methods.
Doc.prototype._setType = function(newType) {
  if (typeof newType === 'string') {
    if (!types[newType]) throw new Error("Missing type " + newType);
    newType = types[newType];
  }
  this.removeContexts();

  // Set the new type
  this.type = newType;

  // If we removed the type from the object, also remove its snapshot.
  if (!newType) {
    this.provides = {};
  } else if (newType.api) {
    // Register the new type's API.
    this.provides = newType.api.provides;
  }
};

// Injest snapshot data. This data must include a version, snapshot and type.
// This is used both to injest data that was exported with a webpage and data
// that was received from the server during a fetch.
Doc.prototype.injestData = function(data) {
  if (this.state) {
    if (typeof console !== "undefined") console.warn('Ignoring attempt to injest data in state', this.state);
    return;
  }
  if (typeof data.v !== 'number') throw new Error('Missing version in injested data');


  this.version = data.v;
  // data.data is what the server will actually send. data.snapshot is the old
  // field name - supported now for backwards compatibility.
  this.snapshot = data.data || data.snapshot;
  this._setType(data.type);

  this.state = 'ready';
  this.emit('ready');
};

// Get and return the current document snapshot.
Doc.prototype.getSnapshot = function() {
  return this.snapshot;
};

// The callback will be called at a time when the document has a snapshot and
// you can start applying operations. This may be immediately.
Doc.prototype.whenReady = function(fn) {
  if (this.state === 'ready') {
    fn();
  } else {
    this.on('ready', fn);
  }
};

Doc.prototype.hasPending = function() {
  return this.inflightData != null || !!this.pendingData.length;
};


// **** Helpers for network messages

// Send a message to the connection from this document.
Doc.prototype._send = function(message) {
  message.c = this.collection;
  message.d = this.name;
  this.connection.send(message);
};

// This function exists so connection can call it directly for bulk subscribes.
// It could just make a temporary object literal, thats pretty slow.
Doc.prototype._handleSubscribe = function(err, data) {
  if (err && err !== 'Already subscribed') {
    if (console) console.error("Could not subscribe: " + err);
    this.emit('error', err);
    // There's probably a reason we couldn't subscribe. Don't retry.
    this._setWantSubscribe(false, null, err)
  } else {
    if (data) this.injestData(data);
    this.subscribed = true;
    this.emit('subscribe');
    this._finishSub(true);
  }

  this._clearAction('subscribe');
};

// This is called by the connection when it receives a message for the document.
Doc.prototype._onMessage = function(msg) {
  if (!(msg.c === this.collection && msg.d === this.name)) {
    // This should never happen - its a sanity check for bugs in the connection code.
    throw new Error("Got message for wrong document.");
  }

  // msg.a = the action.
  switch (msg.a) {
    case 'fetch':
      // We're done fetching. This message has no other information.
      if (msg.data) this.injestData(msg.data);
      this._finishSub('fetch', msg.error);
      if (this.wantSubscribe === 'fetch') this.wantSubscribe = false;
      this._clearAction('fetch');
      break;

    case 'sub':
      // Subscribe reply.
      this._handleSubscribe(msg.error, msg.data);
      break;

    case 'unsub':
      // Unsubscribe reply
      this.subscribed = false;
      this.emit('unsubscribe');

      this._finishSub(false, msg.error);
      this._clearAction('unsubscribe');
      break;

    case 'ack':
      // Acknowledge a locally submitted operation.
      //
      // Usually we do nothing here - all the interesting logic happens when we
      // get sent our op back in the op stream (which happens even if we aren't
      // subscribed). However, if the op doesn't get accepted, we still need to
      // clear some state.
      //
      // If the message error is 'Op already submitted', that means we've
      // resent an op that the server already got. It will also be confirmed
      // normally.
      if (msg.error && msg.error !== 'Op already submitted') {
        // The server has rejected an op from the client for some reason.
        // We'll send the error message to the user and try to roll back the change.
        if (this.inflightData) {
          console.warn('Operation was rejected (' + msg.error + '). Trying to rollback change locally.');
          this._tryRollback(this.inflightData);
        } else {
          // I managed to get into this state once. I'm not sure how it happened.
          // The op was maybe double-acknowledged?
          if (console) console.warn('Second acknowledgement message (error) received', msg, this);
        }
          
        this._clearInflightOp(msg.error);
      }
      break;

    case 'op':
      if (this.inflightData &&
          msg.src === this.inflightData.src &&
          msg.seq === this.inflightData.seq) {
        // This one is mine. Accept it as acknowledged.
        this._opAcknowledged(msg);
        break;
      }

      if (msg.v !== this.version) {
        // This will happen naturally in the following (or similar) cases:
        //
        // Client is not subscribed to document.
        // -> client submits an operation (v=10)
        // -> client subscribes to a query which matches this document. Says we
        //    have v=10 of the doc.
        //
        // <- server acknowledges the operation (v=11). Server acknowledges the
        //    operation because the doc isn't subscribed
        // <- server processes the query, which says the client only has v=10.
        //    Server subscribes at v=10 not v=11, so we get another copy of the
        //    v=10 operation.
        //
        // In this case, we can safely ignore the old (duplicate) operation.
        break;
      }

      if (this.inflightData) xf(this.inflightData, msg);

      for (var i = 0; i < this.pendingData.length; i++) {
        xf(this.pendingData[i], msg);
      }

      this.version++;
      this._otApply(msg, false);
      this._afterOtApply(msg, false);
      //console.log('applied', JSON.stringify(msg));
      break;

    case 'meta':
      if (console) console.warn('Unhandled meta op:', msg);
      break;

    default:
      if (console) console.warn('Unhandled document message:', msg);
      break;
  }
};

// Called whenever (you guessed it!) the connection state changes. This will
// happen when we get disconnected & reconnect.
Doc.prototype._onConnectionStateChanged = function(state, reason) {
  if (state === 'connecting') {
    if (this.inflightData) {
      this._sendOpData();
    } else {
      this.flush();
    }
  } else if (state === 'connected') {
    // We go into the connected state once we have a sessionID. We can't send
    // new ops until then, so we need to flush again.
    this.flush();
  } else if (state === 'disconnected') {
    this.action = null;
    this.subscribed = false;
    if (this.subscribed) this.emit('unsubscribed');
  }
};




// ****** Dealing with actions

Doc.prototype._clearAction = function(expectedAction) {
  if (this.action !== expectedAction) {
    console.warn('Unexpected action ' + this.action + ' expected: ' + expectedAction);
  }
  this.action = null;
  this.flush();
};



// Send the next pending op to the server, if we can.
//
// Only one operation can be in-flight at a time. If an operation is already on
// its way, or we're not currently connected, this method does nothing.
Doc.prototype.flush = function() {
  if (!this.connection.canSend || this.action) return;

  var opData;
  // Pump and dump any no-ops from the front of the pending op list.
  while (this.pendingData.length && isNoOp(opData = this.pendingData[0])) {
    var callbacks = opData.callbacks;
    for (var i = 0; i < callbacks.length; i++) {
      callbacks[i](opData.error);
    }
    this.pendingData.shift();
  }

  // First consider changing state
  if (this.subscribed && !this.wantSubscribe) {
    this.action = 'unsubscribe';
    this._send({a:'unsub'});
  } else if (!this.subscribed && this.wantSubscribe === 'fetch') {
    this.action = 'fetch';
    this._send(this.state === 'ready' ? {a:'fetch', v:this.version} : {a:'fetch'});
  } else if (!this.subscribed && this.wantSubscribe) {
    this.action = 'subscribe';
    // Special send method needed for bulk subscribes on reconnect.
    this.connection.sendSubscribe(this.collection, this.name, this.state === 'ready' ? this.version : null);
  } else if (!this.paused && this.pendingData.length && this.connection.state === 'connected') {
    // Try and send any pending ops. We can't send ops while in 
    this.inflightData = this.pendingData.shift();

    // Delay for debugging.
    //var that = this;
    //setTimeout(function() { that._sendOpData(); }, 1000);

    // This also sets action to 'submit'.
    this._sendOpData();
  }
};


// ****** Subscribing, unsubscribing and fetching

// These functions iare copied into the query class as well, so be careful making
// changes here.

// Value is true, false or 'fetch'.
Doc.prototype._setWantSubscribe = function(value, callback, err) {
  if (this.subscribed === this.wantSubscribe &&
      (this.subscribed === value || value === 'fetch' && this.subscribed)) {
    if (callback) callback(err);
    return;
  }
  
  if (!this.wantSubscribe !== !value) {
    // Call all the current subscribe/unsubscribe callbacks.
    for (var i = 0; i < this._subscribeCallbacks.length; i++) {
      // Should I return an error here? What happened is the user unsubcribed
      // with a callback then resubscribed straight after. Does that mean the
      // unsubscribe failed?
      this._subscribeCallbacks[i](err);
    }
    this._subscribeCallbacks.length = 0;
  }

  // If we want to subscribe, don't weaken it to a fetch.
  if (value !== 'fetch' || this.wantSubscribe !== true)
    this.wantSubscribe = value;

  if (callback) this._subscribeCallbacks.push(callback);
  this.flush();
};

// Open the document. There is no callback and no error handling if you're
// already connected.
//
// Only call this once per document.
Doc.prototype.subscribe = function(callback) {
  this._setWantSubscribe(true, callback);
};

// Unsubscribe. The data will stay around in local memory, but we'll stop
// receiving updates.
Doc.prototype.unsubscribe = function(callback) {
  this._setWantSubscribe(false, callback);
};

// Call to request fresh data from the server.
Doc.prototype.fetch = function(callback) {
  this._setWantSubscribe('fetch', callback);
};

// Called when our subscribe, fetch or unsubscribe messages are acknowledged.
Doc.prototype._finishSub = function(value, error) {
  if (value === this.wantSubscribe) {
    for (var i = 0; i < this._subscribeCallbacks.length; i++) {
      this._subscribeCallbacks[i](error);
    }
    this._subscribeCallbacks.length = 0;
  }
};


// Operations


// ************ Dealing with operations.

// Helper function to set opData to contain a no-op.
var setNoOp = function(opData) {
  delete opData.op;
  delete opData.create;
  delete opData.del;
};

var isNoOp = function(opData) {
  return !opData.op && !opData.create && !opData.del;
}

// Try to compose data2 into data1. Returns truthy if it succeeds, otherwise falsy.
var tryCompose = function(type, data1, data2) {
  if (data1.create && data2.del) {
    setNoOp(data1);
  } else if (data1.create && data2.op) {
    // Compose the data into the create data.
    var data = (data1.create.data === undefined) ? type.create() : data1.create.data;
    data1.create.data = type.apply(data, data2.op);
  } else if (isNoOp(data1)) {
    data1.create = data2.create;
    data1.del = data2.del;
    data1.op = data2.op;
  } else if (data1.op && data2.op && type.compose) {
    data1.op = type.compose(data1.op, data2.op);
  } else {
    return false;
  }
  return true;
};

// Transform server op data by a client op, and vice versa. Ops are edited in place.
var xf = function(client, server) {
  // In this case, we're in for some fun. There are some local operations
  // which are totally invalid - either the client continued editing a
  // document that someone else deleted or a document was created both on the
  // client and on the server. In either case, the local document is way
  // invalid and the client's ops are useless.
  //
  // The client becomes a no-op, and we keep the server op entirely.
  if (server.create || server.del) return setNoOp(client);
  if (client.create) throw new Error('Invalid state. This is a bug.');

  // The client has deleted the document while the server edited it. Kill the
  // server's op.
  if (client.del) return setNoOp(server);

  // We only get here if either the server or client ops are no-op. Carry on,
  // nothing to see here.
  if (!server.op || !client.op) return;

  // They both edited the document. This is the normal case for this function -
  // as in, most of the time we'll end up down here.
  //
  // You should be wondering why I'm using client.type instead of this.type.
  // The reason is, if we get ops at an old version of the document, this.type
  // might be undefined or a totally different type. By pinning the type to the
  // op data, we make sure the right type has its transform function called.
  if (client.type.transformX) {
    var result = client.type.transformX(client.op, server.op);
    client.op = result[0];
    server.op = result[1];
  } else {
    //console.log('xf', JSON.stringify(client.op), JSON.stringify(server.op));
    var _c = client.type.transform(client.op, server.op, 'left');
    var _s = client.type.transform(server.op, client.op, 'right');
    client.op = _c; server.op = _s;
    //console.log('->', JSON.stringify(client.op), JSON.stringify(server.op));
  }
};

// Internal method to actually apply the given op data to our local model.
//
// _afterOtApply() should always be called synchronously afterwards.
Doc.prototype._otApply = function(opData, context) {
  // Lock the document. Nobody is allowed to call submitOp() until _afterOtApply is called.
  this.locked = true;

  if (opData.create) {
    // If the type is currently set, it means we tried creating the document
    // and someone else won. client create x server create = server create.
    var create = opData.create;
    this._setType(create.type);
    this.snapshot = this.type.create(create.data);

    // This is a bit heavyweight, but I want the created event to fire outside of the lock.
    this.once('unlock', function() {
      this.emit('create', context);
    });
  } else if (opData.del) {
    // The type should always exist in this case. del x _ = del
    var oldSnapshot = this.snapshot;
    this._setType(null);
    this.once('unlock', function() {
      this.emit('del', context, oldSnapshot);
    });
  } else if (opData.op) {
    if (!this.type) throw new Error('Document does not exist');

    var type = this.type;

    var op = opData.op;
    
    // The context needs to be told we're about to edit, just in case it needs
    // to store any extra data. (text-tp2 has this constraint.)
    for (var i = 0; i < this.editingContexts.length; i++) {
      var c = this.editingContexts[i];
      if (c != context && c._beforeOp) c._beforeOp(opData.op);
    }

    this.emit('before op', op, context);

    // This exists so clients can pull any necessary data out of the snapshot
    // before it gets changed.  Previously we kept the old snapshot object and
    // passed it to the op event handler. However, apply no longer guarantees
    // the old object is still valid.
    //
    // Because this could be totally unnecessary work, its behind a flag. set
    // doc.incremental to enable.
    if (this.incremental && type.incrementalApply) {
      var _this = this;
      type.incrementalApply(this.snapshot, op, function(o, snapshot) {
        _this.snapshot = snapshot;
        _this.emit('op', o, context);
      });
    } else {
      // This is the most common case, simply applying the operation to the local snapshot.
      this.snapshot = type.apply(this.snapshot, op);
      this.emit('op', op, context);
    }
  }
  // Its possible for none of the above cases to match, in which case the op is
  // a no-op. This will happen when a document has been deleted locally and
  // remote ops edit the document.
};

// This should be called right after _otApply.
Doc.prototype._afterOtApply = function(opData, context) {
  this.locked = false;
  this.emit('unlock');
  if (opData.op) {
    var contexts = this.editingContexts;
    // Notify all the contexts about the op (well, all the contexts except
    // the one which initiated the submit in the first place).
    for (var i = 0; i < contexts.length; i++) {
      var c = contexts[i];
      if (c != context && c._onOp) c._onOp(opData.op);
    }
    for (var i = 0; i < contexts.length; i++) {
      if (contexts.remove) contexts.splice(i--, 1);
    }

    return this.emit('after op', opData.op, context);
  }
};



// ***** Sending operations


// Actually send op data to the server.
Doc.prototype._sendOpData = function() {
  var d = this.inflightData;

  if (this.action) throw new Error('invalid state ' + this.action + ' for sendOpData');
  this.action = 'submit';

  var msg = {a:'op', v:this.version};
  if (d.src) {
    msg.src = d.src;
    msg.seq = d.seq;
  }

  // The server autodetects this.
  //if (this.state === 'unsubscribed') msg.f = true; // fetch intermediate ops

  if (d.op) msg.op = d.op;
  if (d.create) msg.create = d.create;
  if (d.del) msg.del = d.del;

  msg.c = this.collection;
  msg.d = this.name;

  this.connection.sendOp(msg);
   
  // The first time we send an op, its id and sequence number is implicit.
  if (!d.src) {
    d.src = this.connection.id;
    d.seq = this.connection.seq++;
  }
};


// Internal method called to do the actual work for submitOp(), create() and del().
//
// context is optional.
Doc.prototype._submitOpData = function(opData, context, callback) {
  //console.log('submit', JSON.stringify(opData), 'v=', this.version);

  if (typeof context === 'function') {
    callback = context;
    context = true; // The default context is true.
  }
  if (context == null) context = true;

  var error = function(err) {
    if (callback) callback(err);
    else if (console) console.warn('Failed attempt to submitOp:', err);
  };

  if (this.locked) {
    return error("Cannot call submitOp from inside an 'op' event handler");
  }

  // The opData contains either op, create, delete, or none of the above (a no-op).

  if (opData.op) {
    if (!this.type) return error('Document has not been created');

    // Try to normalize the op. This removes trailing skip:0's and things like that.
    if (this.type.normalize) opData.op = this.type.normalize(opData.op);
  }

  if (!this.state) {
    this.state = 'floating';
  }

  // Actually apply the operation locally.
  this._otApply(opData, context);

  // If the type supports composes, try to compose the operation onto the end
  // of the last pending operation.
  var entry = this.pendingData[this.pendingData.length - 1];

  if (this.pendingData.length &&
      (entry = this.pendingData[this.pendingData.length - 1],
       tryCompose(this.type, entry, opData))) {
  } else {
    entry = opData;
    opData.type = this.type;
    opData.callbacks = [];
    this.pendingData.push(opData);
  }

  if (callback) entry.callbacks.push(callback);

  this._afterOtApply(opData, context);

  // The call to flush is in a timeout so if submitOp() is called multiple
  // times in a closure all the ops are combined before being sent to the
  // server. It doesn't matter if flush is called a bunch of times.
  var _this = this;
  setTimeout((function() { _this.flush(); }), 0);
};


// *** Client OT entrypoints.

// Submit an operation to the document. The op must be valid given the current OT type.
Doc.prototype.submitOp = function(op, context, callback) {
  this._submitOpData({op: op}, context, callback);
};

// Create the document, which in ShareJS semantics means to set its type. Every
// object implicitly exists in the database but has no data and no type. Create
// sets the type of the object and can optionally set some initial data on the
// object, depending on the type.
Doc.prototype.create = function(type, data, context, callback) {
  if (typeof data === 'function') {
    // Setting the context to be the callback function in this case so _submitOpData
    // can handle the default value thing.
    context = data;
    data = undefined;
  }
  if (this.type) {
    if (callback) callback('Document already exists');
    return 
  }

  this._submitOpData({create: {type:type, data:data}}, context, callback);
};

// Delete the document. This creates and submits a delete operation to the
// server. Deleting resets the object's type to null and deletes its data. The
// document still exists, and still has the version it used to have before you
// deleted it (well, old version +1).
Doc.prototype.del = function(context, callback) {
  if (!this.type) {
    if (callback) callback('Document does not exist');
    return;
  }

  this._submitOpData({del: true}, context, callback);
};


// Pausing stops the document from sending any operations to the server.
Doc.prototype.pause = function() {
  this.paused = true;
};

Doc.prototype.resume = function() {
  this.paused = false;
  this.flush();
};


// *** Receiving operations


// This will be called when the server rejects our operations for some reason.
// There's not much we can do here if the OT type is noninvertable, but that
// shouldn't happen too much in real life because readonly documents should be
// flagged as such. (I should probably figure out a flag for that).
//
// This does NOT get called if our op fails to reach the server for some reason
// - we optimistically assume it'll make it there eventually.
Doc.prototype._tryRollback = function(opData) {
  // This is probably horribly broken.
  if (opData.create) {
    this._setType(null);

    // I don't think its possible to get here if we aren't in a floating state.
    if (this.state === 'floating')
      this.state = null;
    else
      console.warn('Rollback a create from state ' + this.state);

  } else if (opData.op && opData.type.invert) {
    opData.op = opData.type.invert(opData.op);

    // Transform the undo operation by any pending ops.
    for (var i = 0; i < this.pendingData.length; i++) {
      xf(this.pendingData[i], opData);
    }

    // ... and apply it locally, reverting the changes.
    // 
    // This operation is applied to look like it comes from a remote context.
    // I'm still not 100% sure about this functionality, because its really a
    // local op. Basically, the problem is that if the client's op is rejected
    // by the server, the editor window should update to reflect the undo.
    this._otApply(opData, false);
    this._afterOtApply(opData, false);
  } else if (opData.op || opData.del) {
    // This is where an undo stack would come in handy.
    this._setType(null);
    this.version = null;
    this.state = null;
    this.subscribed = false;
    this.emit('error', "Op apply failed and the operation could not be reverted");

    // Trigger a fetch. In our invalid state, we can't really do anything.
    this.fetch();
    this.flush();
  }
};

Doc.prototype._clearInflightOp = function(error) {
  var callbacks = this.inflightData.callbacks;
  for (var i = 0; i < callbacks.length; i++) {
    callbacks[i](error || this.inflightData.error);
  }

  this.inflightData = null;
  this._clearAction('submit');

  if (!this.pendingData.length) {
    // This isn't a very good name.
    this.emit('nothing pending');
  }
};

// This is called when the server acknowledges an operation from the client.
Doc.prototype._opAcknowledged = function(msg) {
  // Our inflight op has been acknowledged, so we can throw away the inflight data.
  // (We were only holding on to it incase we needed to resend the op.)
  if (!this.state) {
    throw new Error('opAcknowledged called from a null state. This should never happen.');
  } else if (this.state === 'floating') {
    if (!this.inflightData.create) throw new Error('Cannot acknowledge an op.');

    // Our create has been acknowledged. This is the same as injesting some data.
    this.version = msg.v;
    this.state = 'ready';
    var _this = this;
    setTimeout(function() { _this.emit('ready'); }, 0);
  } else {
    // We already have a snapshot. The snapshot should be at the acknowledged
    // version, because the server has sent us all the ops that have happened
    // before acknowledging our op.

    // This should never happen - something is out of order.
    if (msg.v !== this.version)
      throw new Error('Invalid version from server. This can happen when you submit ops in a submitOp callback.');
  }
  
  // The op was committed successfully. Increment the version number
  this.version++;

  this._clearInflightOp();
};


// API Contexts

// This creates and returns an editing context using the current OT type.
Doc.prototype.createContext = function() {
  var type = this.type;
  if (!type) throw new Error('Missing type');

  // I could use the prototype chain to do this instead, but Object.create
  // isn't defined on old browsers. This will be fine.
  var doc = this;
  var context = {
    getSnapshot: function() {
      return doc.snapshot;
    },
    submitOp: function(op, callback) {
      doc.submitOp(op, context, callback);
    },
    destroy: function() {
      if (this.detach) {
        this.detach();
        // Don't double-detach.
        delete this.detach;
      }
      // It will be removed from the actual editingContexts list next time
      // we receive an op on the document (and the list is iterated through).
      //
      // This is potentially dodgy, allowing a memory leak if you create &
      // destroy a whole bunch of contexts without receiving or sending any ops
      // to the document.
      delete this._onOp;
      this.remove = true;
    },

    // This is dangerous, but really really useful for debugging. I hope people
    // don't depend on it.
    _doc: this,
  };

  if (type.api) {
    // Copy everything else from the type's API into the editing context.
    for (var k in type.api) {
      context[k] = type.api[k];
    }
  } else {
    context.provides = {};
  }

  this.editingContexts.push(context);

  return context;
};

Doc.prototype.removeContexts = function() {
  for (var i = 0; i < this.editingContexts.length; i++) {
    this.editingContexts[i].destroy();
  }
  this.editingContexts.length = 0;
};


},{"./microevent":77,"ottypes":79}],71:[function(require,module,exports){
var sha = require('./sha')
var rng = require('./rng')
var md5 = require('./md5')

var algorithms = {
  sha1: {
    hex: sha.hex_sha1,
    binary: sha.b64_sha1,
    ascii: sha.str_sha1
  },
  md5: {
    hex: md5.hex_md5,
    binary: md5.b64_md5,
    ascii: md5.any_md5
  }
}

function error () {
  var m = [].slice.call(arguments).join(' ')
  throw new Error([
    m,
    'we accept pull requests',
    'http://github.com/dominictarr/crypto-browserify'
    ].join('\n'))
}

exports.createHash = function (alg) {
  alg = alg || 'sha1'
  if(!algorithms[alg])
    error('algorithm:', alg, 'is not yet supported')
  var s = ''
  var _alg = algorithms[alg]
  return {
    update: function (data) {
      s += data
      return this
    },
    digest: function (enc) {
      enc = enc || 'binary'
      var fn
      if(!(fn = _alg[enc]))
        error('encoding:', enc , 'is not yet supported for algorithm', alg)
      var r = fn(s)
      s = null //not meant to use the hash after you've called digest.
      return r
    }
  }
}

exports.randomBytes = function(size, callback) {
  if (callback && callback.call) {
    try {
      callback.call(this, undefined, rng(size));
    } catch (err) { callback(err); }
  } else {
    return rng(size);
  }
}

// the least I can do is make error messages for the rest of the node.js/crypto api.
;['createCredentials'
, 'createHmac'
, 'createCypher'
, 'createCypheriv'
, 'createDecipher'
, 'createDecipheriv'
, 'createSign'
, 'createVerify'
, 'createDeffieHellman'
, 'pbkdf2'].forEach(function (name) {
  exports[name] = function () {
    error('sorry,', name, 'is not implemented yet')
  }
})

},{"./sha":80,"./rng":81,"./md5":82}],79:[function(require,module,exports){

var register = function(type) {
  exports[type.name] = type;
  if (type.uri) {
    return exports[type.uri] = type;
  }
};

// Import all the built-in types. Requiring directly rather than in register()
// so browserify works.
register(require('./simple'));

register(require('./text'));
register(require('./text-tp2'));

register(require('./json0'));


},{"./simple":83,"./text":84,"./text-tp2":85,"./json0":86}],81:[function(require,module,exports){
// Original code adapted from Robert Kieffer.
// details at https://github.com/broofa/node-uuid
(function() {
  var _global = this;

  var mathRNG, whatwgRNG;

  // NOTE: Math.random() does not guarantee "cryptographic quality"
  mathRNG = function(size) {
    var bytes = new Array(size);
    var r;

    for (var i = 0, r; i < size; i++) {
      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;
      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return bytes;
  }

  // currently only available in webkit-based browsers.
  if (_global.crypto && crypto.getRandomValues) {
    var _rnds = new Uint32Array(4);
    whatwgRNG = function(size) {
      var bytes = new Array(size);
      crypto.getRandomValues(_rnds);

      for (var c = 0 ; c < size; c++) {
        bytes[c] = _rnds[c >> 2] >>> ((c & 0x03) * 8) & 0xff;
      }
      return bytes;
    }
  }

  module.exports = whatwgRNG || mathRNG;

}())
},{}],83:[function(require,module,exports){
// This is a really simple OT type. Its not compiled with the web client, but it could be.
//
// Its mostly included for demonstration purposes and its used in the meta unit tests.
//
// This defines a really simple text OT type which only allows inserts. (No deletes).
//
// Ops look like:
//   {position:#, text:"asdf"}
//
// Document snapshots look like:
//   {str:string}

module.exports = {
  // The name of the OT type. The type itself is exposed to ottypes[type.name] and ottypes[type.uri].
  // The name can be used instead of the actual type in all API methods in ShareJS.
  name: 'simple',

  // Canonical name.
  uri: 'http://sharejs.org/types/simple',

  // Create a new document snapshot. Initial data can be passed in.
  create: function(initial) {
    if (initial == null)
      initial = '';

    return {str: initial};
  },

  // Apply the given op to the document snapshot. Returns the new snapshot.
  apply: function(snapshot, op) {
    if (op.position < 0 || op.position > snapshot.str.length)
      throw new Error('Invalid position');

    var str = snapshot.str;
    str = str.slice(0, op.position) + op.text + str.slice(op.position);
    return {str: str};
  },

  // Transform op1 by op2. Returns transformed version of op1.
  // Sym describes the symmetry of the operation. Its either 'left' or 'right'
  // depending on whether the op being transformed comes from the client or the
  // server.
  transform: function(op1, op2, sym) {
    var pos = op1.position;

    if (op2.position < pos || (op2.position === pos && sym === 'left')) {
      pos += op2.text.length;
    }

    return {position: pos, text: op1.text};
  }
};


},{}],84:[function(require,module,exports){
/* Text OT!
 *
 * This is an OT implementation for text. It is the standard implementation of
 * text used by ShareJS.
 *
 * This type is composable but non-invertable. Its similar to ShareJS's old
 * text-composable type, but its not invertable and its very similar to the
 * text-tp2 implementation but it doesn't support tombstones or purging.
 *
 * Ops are lists of components which iterate over the document.
 * Components are either:
 *   A number N: Skip N characters in the original document
 *   "str"     : Insert "str" at the current position in the document
 *   {d:'str'} : Delete 'str', which appears at the current position in the document
 *
 * Eg: [3, 'hi', 5, {d:8}]
 *
 * The operation does not have to skip the last characters in the document.
 *
 * Snapshots are strings.
 *
 * Cursors are either a single number (which is the cursor position) or a pair of
 * [anchor, focus] (aka [start, end]). Be aware that end can be before start.
 */

/** @module text */

exports.name = 'text';
exports.uri = 'http://sharejs.org/types/textv1';

/** Create a new text snapshot.
 *
 * @param {string} initial - initial snapshot data. Optional. Defaults to ''.
 */
exports.create = function(initial) {
  if ((initial != null) && typeof initial !== 'string') {
    throw new Error('Initial data must be a string');
  }
  return initial || '';
};

var isArray = Array.isArray || function(obj) {
  return Object.prototype.toString.call(obj) === "[object Array]";
};

/** Check the operation is valid. Throws if not valid. */
var checkOp = function(op) {
  if (!isArray(op)) throw new Error('Op must be an array of components');

  var last = null;
  for (var i = 0; i < op.length; i++) {
    var c = op[i];
    switch (typeof c) {
      case 'object':
        // The only valid objects are {d:X} for +ive values of X.
        if (!(typeof c.d === 'number' && c.d > 0)) throw new Error('Object components must be deletes of size > 0');
        break;
      case 'string':
        // Strings are inserts.
        if (!(c.length > 0)) throw new Error('Inserts cannot be empty');
        break;
      case 'number':
        // Numbers must be skips. They have to be +ive numbers.
        if (!(c > 0)) throw new Error('Skip components must be >0');
        if (typeof last === 'number') throw new Error('Adjacent skip components should be combined');
        break;
    }
    last = c;
  }

  if (typeof last === 'number') throw new Error('Op has a trailing skip');
};

/** Make a function that appends to the given operation. */
var makeAppend = function(op) {
  return function(component) {
    if (!component || component.d === 0) {
      // The component is a no-op. Ignore!
 
    } else if (op.length === 0) {
      return op.push(component);

    } else if (typeof component === typeof op[op.length - 1]) {
      if (typeof component === 'object') {
        return op[op.length - 1].d += component.d;
      } else {
        return op[op.length - 1] += component;
      }
    } else {
      return op.push(component);
    }
  };
};

/** Makes and returns utility functions take and peek. */
var makeTake = function(op) {
  // The index of the next component to take
  var idx = 0;
  // The offset into the component
  var offset = 0;

  // Take up to length n from the front of op. If n is -1, take the entire next
  // op component. If indivisableField == 'd', delete components won't be separated.
  // If indivisableField == 'i', insert components won't be separated.
  var take = function(n, indivisableField) {
    // We're at the end of the operation. The op has skips, forever. Infinity
    // might make more sense than null here.
    if (idx === op.length)
      return n === -1 ? null : n;

    var part;
    var c = op[idx];
    if (typeof c === 'number') {
      // Skip
      if (n === -1 || c - offset <= n) {
        part = c - offset;
        ++idx;
        offset = 0;
        return part;
      } else {
        offset += n;
        return n;
      }
    } else if (typeof c === 'string') {
      // Insert
      if (n === -1 || indivisableField === 'i' || c.length - offset <= n) {
        part = c.slice(offset);
        ++idx;
        offset = 0;
        return part;
      } else {
        part = c.slice(offset, offset + n);
        offset += n;
        return part;
      }
    } else {
      // Delete
      if (n === -1 || indivisableField === 'd' || c.d - offset <= n) {
        part = {d: c.d - offset};
        ++idx;
        offset = 0;
        return part;
      } else {
        offset += n;
        return {d: n};
      }
    }
  };

  // Peek at the next op that will be returned.
  var peekType = function() { return op[idx]; };

  return [take, peekType];
};

/** Get the length of a component */
var componentLength = function(c) {
  // Uglify will compress this down into a ternary
  if (typeof c === 'number') {
    return c;
  } else {
    return c.length || c.d;
  }
};

/** Trim any excess skips from the end of an operation.
 *
 * There should only be at most one, because the operation was made with append.
 */
var trim = function(op) {
  if (op.length > 0 && typeof op[op.length - 1] === 'number') {
    op.pop();
  }
  return op;
};

exports.normalize = function(op) {
  var newOp = [];
  var append = makeAppend(newOp);
  for (var i = 0; i < op.length; i++) {
    append(op[i]);
  }
  return trim(newOp);
};

/** Apply an operation to a document snapshot */
exports.apply = function(str, op) {
  if (typeof str !== 'string') {
    throw new Error('Snapshot should be a string');
  }
  checkOp(op);

  // We'll gather the new document here and join at the end.
  var newDoc = [];

  for (var i = 0; i < op.length; i++) {
    var component = op[i];
    switch (typeof component) {
      case 'number':
        if (component > str.length) throw new Error('The op is too long for this document');

        newDoc.push(str.slice(0, component));
        // This might be slow for big strings. Consider storing the offset in
        // str instead of rewriting it each time.
        str = str.slice(component);
        break;
      case 'string':
        newDoc.push(component);
        break;
      case 'object':
        str = str.slice(component.d);
        break;
    }
  }

  return newDoc.join('') + str;
};

/** Transform op by otherOp.
 *
 * @param op - The operation to transform
 * @param otherOp - Operation to transform it by
 * @param side - Either 'left' or 'right'
 */
exports.transform = function(op, otherOp, side) {
  if (side != 'left' && side != 'right') throw new Error("side (" + side + ") must be 'left' or 'right'");

  checkOp(op);
  checkOp(otherOp);

  var newOp = [];
  var append = makeAppend(newOp);

  var _fns = makeTake(op);
  var take = _fns[0],
      peek = _fns[1];

  for (var i = 0; i < otherOp.length; i++) {
    var component = otherOp[i];

    var length, chunk;
    switch (typeof component) {
      case 'number': // Skip
        length = component;
        while (length > 0) {
          chunk = take(length, 'i');
          append(chunk);
          if (typeof chunk !== 'string') {
            length -= componentLength(chunk);
          }
        }
        break;

      case 'string': // Insert
        if (side === 'left') {
          // The left insert should go first.
          if (typeof peek() === 'string') {
            append(take(-1));
          }
        }

        // Otherwise skip the inserted text.
        append(component.length);
        break;

      case 'object': // Delete
        length = component.d;
        while (length > 0) {
          chunk = take(length, 'i');
          switch (typeof chunk) {
            case 'number':
              length -= chunk;
              break;
            case 'string':
              append(chunk);
              break;
            case 'object':
              // The delete is unnecessary now - the text has already been deleted.
              length -= chunk.d;
          }
        }
        break;
    }
  }
  
  // Append any extra data in op1.
  while ((component = take(-1)))
    append(component);
  
  return trim(newOp);
};

/** Compose op1 and op2 together and return the result */
exports.compose = function(op1, op2) {
  checkOp(op1);
  checkOp(op2);

  var result = [];
  var append = makeAppend(result);
  var take = makeTake(op1)[0];

  for (var i = 0; i < op2.length; i++) {
    var component = op2[i];
    var length, chunk;
    switch (typeof component) {
      case 'number': // Skip
        length = component;
        while (length > 0) {
          chunk = take(length, 'd');
          append(chunk);
          if (typeof chunk !== 'object') {
            length -= componentLength(chunk);
          }
        }
        break;

      case 'string': // Insert
        append(component);
        break;

      case 'object': // Delete
        length = component.d;

        while (length > 0) {
          chunk = take(length, 'd');

          switch (typeof chunk) {
            case 'number':
              append({d: chunk});
              length -= chunk;
              break;
            case 'string':
              length -= chunk.length;
              break;
            case 'object':
              append(chunk);
          }
        }
        break;
    }
  }

  while ((component = take(-1)))
    append(component);

  return trim(result);
};

var transformPosition = function(cursor, op) {
  var pos = 0;
  for (var i = 0; i < op.length; i++) {
    var c = op[i];
    if (cursor <= pos) break;

    // I could actually use the op_iter stuff above - but I think its simpler
    // like this.
    switch (typeof c) {
      case 'number':
        if (cursor <= pos + c)
          return cursor;
        pos += c;
        break;

      case 'string':
        pos += c.length;
        cursor += c.length;
        break;

      case 'object':
        cursor -= Math.min(c.d, cursor - pos);
        break;
    }
  }
  return cursor;
};

exports.transformCursor = function(cursor, op, isOwnOp) {
  var pos = 0;
  if (isOwnOp) {
    // Just track the position. We'll teleport the cursor to the end anyway.
    // This works because text ops don't have any trailing skips at the end - so the last
    // component is the last thing.
    for (var i = 0; i < op.length; i++) {
      var c = op[i];
      switch (typeof c) {
        case 'number':
          pos += c;
          break;
        case 'string':
          pos += c.length;
          break;
        // Just eat deletes.
      }
    }
    return [pos, pos];
  } else {
    return [transformPosition(cursor[0], op), transformPosition(cursor[1], op)];
  }
};

},{}],80:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

exports.hex_sha1 = hex_sha1;
exports.b64_sha1 = b64_sha1;
exports.str_sha1 = str_sha1;
exports.hex_hmac_sha1 = hex_hmac_sha1;
exports.b64_hmac_sha1 = b64_hmac_sha1;
exports.str_hmac_sha1 = str_hmac_sha1;

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = ""; /* base-64 pad character. "=" for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1("abc") == "a9993e364706816aba3e25717850c26c9cd0d89d";
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j < 80; j++)
    {
      if(j < 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t < 20) return (b & c) | ((~b) & d);
  if(t < 40) return b ^ c ^ d;
  if(t < 60) return (b & c) | (b & d) | (c & d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
         (t < 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length > 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters >255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < str.length * chrsz; i += chrsz)
    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = "";
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i>>5] >>> (32 - chrsz - i%32)) & mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +
           hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16)
                | (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 )
                |  ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);
    }
  }
  return str;
}


},{}],85:[function(require,module,exports){
(function(){// A TP2 implementation of text, following this spec:
// http://code.google.com/p/lightwave/source/browse/trunk/experimental/ot/README
//
// A document is made up of a string and a set of tombstones inserted throughout
// the string. For example, 'some ', (2 tombstones), 'string'.
//
// This is encoded in a document as: {s:'some string', t:[5, -2, 6]}
//
// Ops are lists of components which iterate over the whole document. (I might
// change this at some point, but a version thats less strict is backwards
// compatible.)
//
// Components are either:
//   N:         Skip N characters in the original document
//   {i:'str'}: Insert 'str' at the current position in the document
//   {i:N}:     Insert N tombstones at the current position in the document
//   {d:N}:     Delete (tombstone) N characters at the current position in the document
//
// Eg: [3, {i:'hi'}, 5, {d:8}]
//
// Snapshots are lists with characters and tombstones. Characters are stored in strings
// and adjacent tombstones are flattened into numbers.
//
// Eg, the document: 'Hello .....world' ('.' denotes tombstoned (deleted) characters)
// would be represented by a document snapshot of ['Hello ', 5, 'world']

//var append, appendDoc, componentLength, makeTake, takeDoc, transformer;

var type = module.exports = {
  name: 'text-tp2',
  tp2: true,
  uri: 'http://sharejs.org/types/text-tp2v1',
  create: function(initial) {
    if (initial == null) {
      initial = '';
    } else {
      if (typeof initial != 'string') throw new Error('Initial data must be a string');
    }

    return {
      charLength: initial.length,
      totalLength: initial.length,
      data: initial.length ? [initial] : []
    };
  },

  serialize: function(doc) {
    if (!doc.data) {
      throw new Error('invalid doc snapshot');
    }
    return doc.data;
  },

  deserialize: function(data) {
    var doc = type.create();
    doc.data = data;

    for (var i = 0; i < data.length; i++) {
      var component = data[i];

      if (typeof component === 'string') {
        doc.charLength += component.length;
        doc.totalLength += component.length;
      } else {
        doc.totalLength += component;
      }
    }

    return doc;
  }
};

var isArray = Array.isArray || function(obj) {
  return Object.prototype.toString.call(obj) == '[object Array]';
};

var checkOp = function(op) {
  if (!isArray(op)) throw new Error('Op must be an array of components');

  var last = null;
  for (var i = 0; i < op.length; i++) {
    var c = op[i];
    if (typeof c == 'object') {
      // The component is an insert or a delete.
      if (c.i !== undefined) { // Insert.
        if (!((typeof c.i === 'string' && c.i.length > 0) // String inserts
              || (typeof c.i === 'number' && c.i > 0))) // Tombstone inserts
          throw new Error('Inserts must insert a string or a +ive number');

      } else if (c.d !== undefined) { // Delete
        if (!(typeof c.d === 'number' && c.d > 0))
          throw new Error('Deletes must be a +ive number');

      } else throw new Error('Operation component must define .i or .d');

    } else {
      // The component must be a skip.
      if (typeof c != 'number') throw new Error('Op components must be objects or numbers');

      if (c <= 0) throw new Error('Skip components must be a positive number');
      if (typeof last === 'number') throw new Error('Adjacent skip components should be combined');
    }

    last = c;
  }
};

// Take the next part from the specified position in a document snapshot.
// position = {index, offset}. It will be updated.
var takeDoc = type._takeDoc = function(doc, position, maxlength, tombsIndivisible) {
  if (position.index >= doc.data.length)
    throw new Error('Operation goes past the end of the document');

  var part = doc.data[position.index];

  // This can be written as an ugly-arsed giant ternary statement, but its much
  // more readable like this. Uglify will convert it into said ternary anyway.
  var result;
  if (typeof part == 'string') {
    if (maxlength != null) {
      result = part.slice(position.offset, position.offset + maxlength);
    } else {
      result = part.slice(position.offset);
    }
  } else {
    if (maxlength == null || tombsIndivisible) {
      result = part - position.offset;
    } else {
      result = Math.min(maxlength, part - position.offset);
    }
  }

  var resultLen = result.length || result;

  if ((part.length || part) - position.offset > resultLen) {
    position.offset += resultLen;
  } else {
    position.index++;
    position.offset = 0;
  }

  return result;
};

// Append a part to the end of a document
var appendDoc = type._appendDoc = function(doc, p) {
  if (p === 0 || p === '') return;

  if (typeof p === 'string') {
    doc.charLength += p.length;
    doc.totalLength += p.length;
  } else {
    doc.totalLength += p;
  }

  var data = doc.data;
  if (data.length === 0) {
    data.push(p);
  } else if (typeof data[data.length - 1] === typeof p) {
    data[data.length - 1] += p;
  } else {
    data.push(p);
  }
};

// Apply the op to the document. The document is not modified in the process.
type.apply = function(doc, op) {
  if (doc.totalLength == null || doc.charLength == null || !isArray(doc.data)) {
    throw new Error('Snapshot is invalid');
  }
  checkOp(op);

  var newDoc = type.create();
  var position = {index: 0, offset: 0};

  for (var i = 0; i < op.length; i++) {
    var component = op[i];
    var remainder, part;

    if (typeof component == 'number') { // Skip
      remainder = component;
      while (remainder > 0) {
        part = takeDoc(doc, position, remainder);
        appendDoc(newDoc, part);
        remainder -= part.length || part;
      }

    } else if (component.i !== undefined) { // Insert
      appendDoc(newDoc, component.i);

    } else if (component.d !== undefined) { // Delete
      remainder = component.d;
      while (remainder > 0) {
        part = takeDoc(doc, position, remainder);
        remainder -= part.length || part;
      }
      appendDoc(newDoc, component.d);
    }
  }
  return newDoc;
};

// Append an op component to the end of the specified op.  Exported for the
// randomOpGenerator.
var append = type._append = function(op, component) {
  var last;

  if (component === 0 || component.i === '' || component.i === 0 || component.d === 0) {
    // Drop the new component.
  } else if (op.length === 0) {
    op.push(component);
  } else {
    last = op[op.length - 1];
    if (typeof component == 'number' && typeof last == 'number') {
      op[op.length - 1] += component;
    } else if (component.i != null && (last.i != null) && typeof last.i === typeof component.i) {
      last.i += component.i;
    } else if (component.d != null && (last.d != null)) {
      last.d += component.d;
    } else {
      op.push(component);
    }
  }
};

// Makes 2 functions for taking components from the start of an op, and for
// peeking at the next op that could be taken.
var makeTake = function(op) {
  // The index of the next component to take
  var index = 0;
  // The offset into the component
  var offset = 0;

  var take = function(maxlength, insertsIndivisible) {
    if (index === op.length) return null;
    var e = op[index];
    var current;
    var result;

    // if the current element is a skip, an insert of a number or a delete
    if (typeof (current = e) == 'number' || typeof (current = e.i) == 'number' || (current = e.d) != null) {
      var c;
      if ((maxlength == null) || current - offset <= maxlength || (insertsIndivisible && e.i != null)) {
        // Return the rest of the current element.
        c = current - offset;
        ++index;
        offset = 0;
      } else {
        offset += maxlength;
        c = maxlength;
      }

      // Package the component back up.
      if (e.i != null) {
        return {i: c};
      } else if (e.d != null) {
        return {d: c};
      } else {
        return c;
      }
    } else { // Insert of a string.
      if ((maxlength == null) || e.i.length - offset <= maxlength || insertsIndivisible) {
        result = {i: e.i.slice(offset)};
        ++index;
        offset = 0;
      } else {
        result = {i: e.i.slice(offset, offset + maxlength)};
        offset += maxlength;
      }
      return result;
    }
  };

  var peekType = function() {return op[index];};
  return [take, peekType];
};

// Find and return the length of an op component
var componentLength = function(component) {
  if (typeof component === 'number') {
    return component;
  } else if (typeof component.i === 'string') {
    return component.i.length;
  } else {
    return component.d || component.i;
  }
};

// Normalize an op, removing all empty skips and empty inserts / deletes.
// Concatenate adjacent inserts and deletes.
type.normalize = function(op) {
  var newOp = [];
  for (var i = 0; i < op.length; i++) {
    append(newOp, op[i]);
  }
  return newOp;
};

// This is a helper method to transform and prune. goForwards is true for transform, false for prune.
var transformer = function(op, otherOp, goForwards, side) {
  checkOp(op);
  checkOp(otherOp);

  var newOp = [];

  var fns = makeTake(op),
      take = fns[0],
      peek = fns[1];

  for (var i = 0; i < otherOp.length; i++) {
    var component = otherOp[i];
    var len = componentLength(component);
    var chunk;

    if (component.i != null) { // Insert text or tombs
      if (goForwards) { // Transform - insert skips over deleted parts.
        if (side === 'left') {
          // The left side insert should go first.
          var next;
          while ((next = peek()) && next.i != null) {
            append(newOp, take());
          }
        }
        // In any case, skip the inserted text.
        append(newOp, len);

      } else { // Prune. Remove skips for inserts.
        while (len > 0) {
          chunk = take(len, true);

          // The chunk will be null if we run out of components in the other op.
          if (chunk === null) throw new Error('The transformed op is invalid');
          if (chunk.d != null)
            throw new Error('The transformed op deletes locally inserted characters - it cannot be purged of the insert.');

          if (typeof chunk == 'number')
            len -= chunk;
          else
            append(newOp, chunk);
        }
      }
    } else { // Skips or deletes.
      while (len > 0) {
        chunk = take(len, true);
        if (chunk === null) throw new Error('The op traverses more elements than the document has');

        append(newOp, chunk);
        if (!chunk.i) len -= componentLength(chunk);
      }
    }
  }

  // Append extras from op1.
  var component;
  while ((component = take())) {
    if (component.i === undefined) {
      throw new Error("Remaining fragments in the op: " + component);
    }
    append(newOp, component);
  }
  return newOp;
};

// transform op1 by op2. Return transformed version of op1. op1 and op2 are
// unchanged by transform. Side should be 'left' or 'right', depending on if
// op1.id <> op2.id.
//
// 'left' == client op for ShareJS.
type.transform = function(op, otherOp, side) {
  if (side != 'left' && side != 'right')
    throw new Error("side (" + side + ") should be 'left' or 'right'");

  return transformer(op, otherOp, true, side);
};

type.prune = function(op, otherOp) {
  return transformer(op, otherOp, false);
};

type.compose = function(op1, op2) {
  //var chunk, chunkLength, component, length, result, take, _, _i, _len, _ref;
  if (op1 == null) return op2;

  checkOp(op1);
  checkOp(op2);

  var result = [];
  var take = makeTake(op1)[0];
  var component;

  for (var i = 0; i < op2.length; i++) {
    component = op2[i];
    var len, chunk;

    if (typeof component === 'number') { // Skip
      // Just copy from op1.
      len = component;
      while (len > 0) {
        chunk = take(len);
        if (chunk === null)
          throw new Error('The op traverses more elements than the document has');

        append(result, chunk);
        len -= componentLength(chunk);
      }

    } else if (component.i !== undefined) { // Insert
      append(result, {i: component.i});

    } else { // Delete
      len = component.d;
      while (len > 0) {
        chunk = take(len);
        if (chunk === null)
          throw new Error('The op traverses more elements than the document has');

        var chunkLength = componentLength(chunk);

        if (chunk.i !== undefined)
          append(result, {i: chunkLength});
        else
          append(result, {d: chunkLength});

        len -= chunkLength;
      }
    }
  }

  // Append extras from op1.
  while ((component = take())) {
    if (component.i === undefined) {
      throw new Error("Remaining fragments in op1: " + component);
    }
    append(result, component);
  }
  return result;
};


})()
},{}],82:[function(require,module,exports){
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;   /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = "";  /* base-64 pad character. "=" for strict RFC compliance   */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_md5(s)    { return rstr2hex(rstr_md5(str2rstr_utf8(s))); }
function b64_md5(s)    { return rstr2b64(rstr_md5(str2rstr_utf8(s))); }
function any_md5(s, e) { return rstr2any(rstr_md5(str2rstr_utf8(s)), e); }
function hex_hmac_md5(k, d)
  { return rstr2hex(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
function b64_hmac_md5(k, d)
  { return rstr2b64(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
function any_hmac_md5(k, d, e)
  { return rstr2any(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)), e); }

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test()
{
  return hex_md5("abc").toLowerCase() == "900150983cd24fb0d6963f7d28e17f72";
}

/*
 * Calculate the MD5 of a raw string
 */
function rstr_md5(s)
{
  return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
}

/*
 * Calculate the HMAC-MD5, of a key and some data (raw strings)
 */
function rstr_hmac_md5(key, data)
{
  var bkey = rstr2binl(key);
  if(bkey.length > 16) bkey = binl_md5(bkey, key.length * 8);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
  return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));
}

/*
 * Convert a raw string to a hex string
 */
function rstr2hex(input)
{
  try { hexcase } catch(e) { hexcase=0; }
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var output = "";
  var x;
  for(var i = 0; i < input.length; i++)
  {
    x = input.charCodeAt(i);
    output += hex_tab.charAt((x >>> 4) & 0x0F)
           +  hex_tab.charAt( x        & 0x0F);
  }
  return output;
}

/*
 * Convert a raw string to a base-64 string
 */
function rstr2b64(input)
{
  try { b64pad } catch(e) { b64pad=''; }
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var output = "";
  var len = input.length;
  for(var i = 0; i < len; i += 3)
  {
    var triplet = (input.charCodeAt(i) << 16)
                | (i + 1 < len ? input.charCodeAt(i+1) << 8 : 0)
                | (i + 2 < len ? input.charCodeAt(i+2)      : 0);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > input.length * 8) output += b64pad;
      else output += tab.charAt((triplet >>> 6*(3-j)) & 0x3F);
    }
  }
  return output;
}

/*
 * Convert a raw string to an arbitrary string encoding
 */
function rstr2any(input, encoding)
{
  var divisor = encoding.length;
  var i, j, q, x, quotient;

  /* Convert to an array of 16-bit big-endian values, forming the dividend */
  var dividend = Array(Math.ceil(input.length / 2));
  for(i = 0; i < dividend.length; i++)
  {
    dividend[i] = (input.charCodeAt(i * 2) << 8) | input.charCodeAt(i * 2 + 1);
  }

  /*
   * Repeatedly perform a long division. The binary array forms the dividend,
   * the length of the encoding is the divisor. Once computed, the quotient
   * forms the dividend for the next step. All remainders are stored for later
   * use.
   */
  var full_length = Math.ceil(input.length * 8 /
                                    (Math.log(encoding.length) / Math.log(2)));
  var remainders = Array(full_length);
  for(j = 0; j < full_length; j++)
  {
    quotient = Array();
    x = 0;
    for(i = 0; i < dividend.length; i++)
    {
      x = (x << 16) + dividend[i];
      q = Math.floor(x / divisor);
      x -= q * divisor;
      if(quotient.length > 0 || q > 0)
        quotient[quotient.length] = q;
    }
    remainders[j] = x;
    dividend = quotient;
  }

  /* Convert the remainders to the output string */
  var output = "";
  for(i = remainders.length - 1; i >= 0; i--)
    output += encoding.charAt(remainders[i]);

  return output;
}

/*
 * Encode a string as utf-8.
 * For efficiency, this assumes the input is valid utf-16.
 */
function str2rstr_utf8(input)
{
  var output = "";
  var i = -1;
  var x, y;

  while(++i < input.length)
  {
    /* Decode utf-16 surrogate pairs */
    x = input.charCodeAt(i);
    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
    if(0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)
    {
      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
      i++;
    }

    /* Encode output as utf-8 */
    if(x <= 0x7F)
      output += String.fromCharCode(x);
    else if(x <= 0x7FF)
      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0xFFFF)
      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0x1FFFFF)
      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),
                                    0x80 | ((x >>> 12) & 0x3F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
  }
  return output;
}

/*
 * Encode a string as utf-16
 */
function str2rstr_utf16le(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode( input.charCodeAt(i)        & 0xFF,
                                  (input.charCodeAt(i) >>> 8) & 0xFF);
  return output;
}

function str2rstr_utf16be(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode((input.charCodeAt(i) >>> 8) & 0xFF,
                                   input.charCodeAt(i)        & 0xFF);
  return output;
}

/*
 * Convert a raw string to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */
function rstr2binl(input)
{
  var output = Array(input.length >> 2);
  for(var i = 0; i < output.length; i++)
    output[i] = 0;
  for(var i = 0; i < input.length * 8; i += 8)
    output[i>>5] |= (input.charCodeAt(i / 8) & 0xFF) << (i%32);
  return output;
}

/*
 * Convert an array of little-endian words to a string
 */
function binl2rstr(input)
{
  var output = "";
  for(var i = 0; i < input.length * 32; i += 8)
    output += String.fromCharCode((input[i>>5] >>> (i % 32)) & 0xFF);
  return output;
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */
function binl_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);
}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}


exports.hex_md5 = hex_md5;
exports.b64_md5 = b64_md5;
exports.any_md5 = any_md5;

},{}],86:[function(require,module,exports){
/*
 This is the implementation of the JSON OT type.

 Spec is here: https://github.com/josephg/ShareJS/wiki/JSON-Operations

 Note: This is being made obsolete. It will soon be replaced by the JSON2 type.
*/

/**
 * UTILITY FUNCTIONS
 */

/**
 * Checks if the passed object is an Array instance. Can't use Array.isArray
 * yet because its not supported on IE8.
 *
 * @param obj
 * @returns {boolean}
 */
var isArray = function(obj) {
  return Object.prototype.toString.call(obj) == '[object Array]';
};

/**
 * Clones the passed object using JSON serialization (which is slow).
 *
 * hax, copied from test/types/json. Apparently this is still the fastest way
 * to deep clone an object, assuming we have browser support for JSON.  @see
 * http://jsperf.com/cloning-an-object/12
 */
var clone = function(o) {
  return JSON.parse(JSON.stringify(o));
};



/**
 * Reference to the Text OT type. This is used for the JSON String operations.
 * @type {*}
 */
var text = typeof require !== "undefined" ? require('./text-old') : window.ottypes.text;



/**
 * JSON OT Type
 * @type {*}
 */
var json = { 
  name: 'json0',
  uri: 'http://sharejs.org/types/JSONv0'
};

json.create = function(data) {
  // Null instead of undefined if you don't pass an argument.
  return data === undefined ? null : data;
};

json.invertComponent = function(c) {
  var c_ = {p: c.p};

  if (c.si !== void 0) c_.sd = c.si;
  if (c.sd !== void 0) c_.si = c.sd;
  if (c.oi !== void 0) c_.od = c.oi;
  if (c.od !== void 0) c_.oi = c.od;
  if (c.li !== void 0) c_.ld = c.li;
  if (c.ld !== void 0) c_.li = c.ld;
  if (c.na !== void 0) c_.na = -c.na;

  if (c.lm !== void 0) {
    c_.lm = c.p[c.p.length-1];
    c_.p = c.p.slice(0,c.p.length-1).concat([c.lm]);
  }

  return c_;
};

json.invert = function(op) {
  var op_ = op.slice().reverse();
  var iop = [];
  for (var i = 0; i < op_.length; i++) {
    iop.push(json.invertComponent(op_[i]));
  }
  return iop;
};

json.checkValidOp = function(op) {
  for (var i = 0; i < op.length; i++) {
  if (!isArray(op[i].p))
    throw new Error('Missing path');
  }
};

json.checkList = function(elem) {
  if (!isArray(elem))
    throw new Error('Referenced element not a list');
};

json.checkObj = function(elem) {
  if (elem.constructor !== Object) {
    throw new Error("Referenced element not an object (it was " + JSON.stringify(elem) + ")");
  }
};

json.apply = function(snapshot, op) {
  json.checkValidOp(op);

  op = clone(op);

  var container = {
    data: snapshot
  };

  for (var i = 0; i < op.length; i++) {
    var c = op[i];

    var parent = null;
    var parentKey = null;
    var elem = container;
    var key = 'data';

    for (var j = 0; j < c.p.length; j++) {
      var p = c.p[j];

      parent = elem;
      parentKey = key;
      elem = elem[key];
      key = p;

      if (parent == null)
        throw new Error('Path invalid');
    }

    // Number add
    if (c.na !== void 0) {
      if (typeof elem[key] != 'number')
        throw new Error('Referenced element not a number');

      elem[key] += c.na;
    }

    // String insert
    else if (c.si !== void 0) {
      if (typeof elem != 'string')
        throw new Error('Referenced element not a string (it was '+JSON.stringify(elem)+')');

      parent[parentKey] = elem.slice(0,key) + c.si + elem.slice(key);
    }

    // String delete
    else if (c.sd !== void 0) {
      if (typeof elem != 'string')
        throw new Error('Referenced element not a string');

      if (elem.slice(key,key + c.sd.length) !== c.sd)
        throw new Error('Deleted string does not match');

      parent[parentKey] = elem.slice(0,key) + elem.slice(key + c.sd.length);
    }

    // List replace
    else if (c.li !== void 0 && c.ld !== void 0) {
      json.checkList(elem);
      // Should check the list element matches c.ld
      elem[key] = c.li;
    }

    // List insert
    else if (c.li !== void 0) {
      json.checkList(elem);
      elem.splice(key,0, c.li);
    }

    // List delete
    else if (c.ld !== void 0) {
      json.checkList(elem);
      // Should check the list element matches c.ld here too.
      elem.splice(key,1);
    }

    // List move
    else if (c.lm !== void 0) {
      json.checkList(elem);
      if (c.lm != key) {
        var e = elem[key];
        // Remove it...
        elem.splice(key,1);
        // And insert it back.
        elem.splice(c.lm,0,e);
      }
    }

    // Object insert / replace
    else if (c.oi !== void 0) {
      json.checkObj(elem);

      // Should check that elem[key] == c.od
      elem[key] = c.oi;
    }

    // Object delete
    else if (c.od !== void 0) {
      json.checkObj(elem);

      // Should check that elem[key] == c.od
      delete elem[key];
    }

    else {
      throw new Error('invalid / missing instruction in op');
    }
  }

  return container.data;
};

// Helper for incrementally applying an operation to a snapshot. Calls yield
// after each op component has been applied.
json.incrementalApply = function(snapshot, op, _yield) {
  for (var i = 0; i < op.length; i++) {
    var smallOp = [op[i]];
    snapshot = json.apply(snapshot, smallOp);
    // I'd just call this yield, but thats a reserved keyword. Bah!
    _yield(smallOp, snapshot);
  }
  
  return snapshot;
};

// Checks if two paths, p1 and p2 match.
var pathMatches = json.pathMatches = function(p1, p2, ignoreLast) {
  if (p1.length != p2.length)
    return false;

  for (var i = 0; i < p1.length; i++) {
    if (p1[i] !== p2[i] && (!ignoreLast || i !== p1.length - 1))
      return false;
  }

  return true;
};

var _convertToTextComponent = function(component) {
  var newC = {p: component.p[component.p.length - 1]};
  if (component.si != null) {
    newC.i = component.si;
  } else {
    newC.d = component.sd;
  }
  return newC;
};

json.append = function(dest,c) {
  c = clone(c);

  var last;

  if (dest.length != 0 && pathMatches(c.p, (last = dest[dest.length - 1]).p)) {
    if (last.na != null && c.na != null) {
      dest[dest.length - 1] = {p: last.p, na: last.na + c.na};
    } else if (last.li !== undefined && c.li === undefined && c.ld === last.li) {
      // insert immediately followed by delete becomes a noop.
      if (last.ld !== undefined) {
        // leave the delete part of the replace
        delete last.li;
      } else {
        dest.pop();
      }
    } else if (last.od !== undefined && last.oi === undefined && c.oi !== undefined && c.od === undefined) {
      last.oi = c.oi;
    } else if (last.oi !== undefined && c.od !== undefined) {
      // The last path component inserted something that the new component deletes (or replaces).
      // Just merge them.
      if (c.oi !== undefined) {
        last.oi = c.oi;
      } else if (last.od !== undefined) {
        delete last.oi;
      } else {
        // An insert directly followed by a delete turns into a no-op and can be removed.
        dest.pop();
      }
    } else if (c.lm !== undefined && c.p[c.p.length - 1] === c.lm) {
      // don't do anything
    } else {
      dest.push(c);
    }
  } else if (dest.length != 0 && pathMatches(c.p, last.p, true)) {
    if ((c.si != null || c.sd != null) && (last.si != null || last.sd != null)) {
      // Try to compose the string ops together using text's equivalent methods
      var textOp = [_convertToTextComponent(last)];
      text._append(textOp, _convertToTextComponent(c));
      
      // Then convert back.
      if (textOp.length !== 1) {
        dest.push(c);
      } else {
        var textC = textOp[0];
        last.p[last.p.length - 1] = textC.p;
        if (textC.i != null)
          last.si = textC.i;
        else
          last.sd = textC.d;
      }
    } else {
      dest.push(c);
    }
  } else {
    dest.push(c);
  }
};

json.compose = function(op1,op2) {
  json.checkValidOp(op1);
  json.checkValidOp(op2);

  var newOp = clone(op1);

  for (var i = 0; i < op2.length; i++) {
    json.append(newOp,op2[i]);
  }

  return newOp;
};

json.normalize = function(op) {
  var newOp = [];

  op = isArray(op) ? op : [op];

  for (var i = 0; i < op.length; i++) {
    var c = op[i];
    if (c.p == null) c.p = [];

    json.append(newOp,c);
  }

  return newOp;
};

// Returns true if an op at otherPath may affect an op at path
json.canOpAffectOp = function(otherPath,path) {
  if (otherPath.length === 0) return true;
  if (path.length === 0) return false;

  path = path.slice(0,path.length - 1);
  otherPath = otherPath.slice(0,otherPath.length - 1);

  for (var i = 0; i < otherPath.length; i++) {
    var p = otherPath[i];
    if (i >= path.length || p != path[i]) return false;
  }

  // Same
  return true;
};

// transform c so it applies to a document with otherC applied.
json.transformComponent = function(dest, c, otherC, type) {
  c = clone(c);

  if (c.na !== void 0)
    c.p.push(0);

  if (otherC.na !== void 0)
    otherC.p.push(0);

  var common;
  if (json.canOpAffectOp(otherC.p, c.p))
    common = otherC.p.length - 1;

  var common2;
  if (json.canOpAffectOp(c.p,otherC.p))
    common2 = c.p.length - 1;

  var cplength = c.p.length;
  var otherCplength = otherC.p.length;

  if (c.na !== void 0) // hax
    c.p.pop();

  if (otherC.na !== void 0)
    otherC.p.pop();

  if (otherC.na) {
    if (common2 != null && otherCplength >= cplength && otherC.p[common2] == c.p[common2]) {
      if (c.ld !== void 0) {
        var oc = clone(otherC);
        oc.p = oc.p.slice(cplength);
        c.ld = json.apply(clone(c.ld),[oc]);
      } else if (c.od !== void 0) {
        var oc = clone(otherC);
        oc.p = oc.p.slice(cplength);
        c.od = json.apply(clone(c.od),[oc]);
      }
    }
    json.append(dest,c);
    return dest;
  }

  // if c is deleting something, and that thing is changed by otherC, we need to
  // update c to reflect that change for invertibility.
  // TODO this is probably not needed since we don't have invertibility
  if (common2 != null && otherCplength > cplength && c.p[common2] == otherC.p[common2]) {
    if (c.ld !== void 0) {
      var oc = clone(otherC);
      oc.p = oc.p.slice(cplength);
      c.ld = json.apply(clone(c.ld),[oc]);
    } else if (c.od !== void 0) {
      var oc = clone(otherC);
      oc.p = oc.p.slice(cplength);
      c.od = json.apply(clone(c.od),[oc]);
    }
  }

  if (common != null) {
    var commonOperand = cplength == otherCplength;

    // transform based on otherC
    if (otherC.na !== void 0) {
      // this case is handled above due to icky path hax
    } else if (otherC.si !== void 0 || otherC.sd !== void 0) {
      // String op vs string op - pass through to text type
      if (c.si !== void 0 || c.sd !== void 0) {
        if (!commonOperand) throw new Error('must be a string?');

        // Convert an op component to a text op component so we can use the
        // text type's transform function
        var tc1 = _convertToTextComponent(c);
        var tc2 = _convertToTextComponent(otherC);

        var res = [];

        // actually transform
        text._tc(res, tc1, tc2, type);
        
        // .... then convert the result back into a JSON op again.
        for (var i = 0; i < res.length; i++) {
          // Text component
          var tc = res[i];
          // JSON component
          var jc = {p: c.p.slice(0, common)};
          jc.p.push(tc.p);

          if (tc.i != null) jc.si = tc.i;
          if (tc.d != null) jc.sd = tc.d;
          json.append(dest, jc);
        }
        return dest;
      }
    } else if (otherC.li !== void 0 && otherC.ld !== void 0) {
      if (otherC.p[common] === c.p[common]) {
        // noop

        if (!commonOperand) {
          return dest;
        } else if (c.ld !== void 0) {
          // we're trying to delete the same element, -> noop
          if (c.li !== void 0 && type === 'left') {
            // we're both replacing one element with another. only one can survive
            c.ld = clone(otherC.li);
          } else {
            return dest;
          }
        }
      }
    } else if (otherC.li !== void 0) {
      if (c.li !== void 0 && c.ld === undefined && commonOperand && c.p[common] === otherC.p[common]) {
        // in li vs. li, left wins.
        if (type === 'right')
          c.p[common]++;
      } else if (otherC.p[common] <= c.p[common]) {
        c.p[common]++;
      }

      if (c.lm !== void 0) {
        if (commonOperand) {
          // otherC edits the same list we edit
          if (otherC.p[common] <= c.lm)
            c.lm++;
          // changing c.from is handled above.
        }
      }
    } else if (otherC.ld !== void 0) {
      if (c.lm !== void 0) {
        if (commonOperand) {
          if (otherC.p[common] === c.p[common]) {
            // they deleted the thing we're trying to move
            return dest;
          }
          // otherC edits the same list we edit
          var p = otherC.p[common];
          var from = c.p[common];
          var to = c.lm;
          if (p < to || (p === to && from < to))
            c.lm--;

        }
      }

      if (otherC.p[common] < c.p[common]) {
        c.p[common]--;
      } else if (otherC.p[common] === c.p[common]) {
        if (otherCplength < cplength) {
          // we're below the deleted element, so -> noop
          return dest;
        } else if (c.ld !== void 0) {
          if (c.li !== void 0) {
            // we're replacing, they're deleting. we become an insert.
            delete c.ld;
          } else {
            // we're trying to delete the same element, -> noop
            return dest;
          }
        }
      }

    } else if (otherC.lm !== void 0) {
      if (c.lm !== void 0 && cplength === otherCplength) {
        // lm vs lm, here we go!
        var from = c.p[common];
        var to = c.lm;
        var otherFrom = otherC.p[common];
        var otherTo = otherC.lm;
        if (otherFrom !== otherTo) {
          // if otherFrom == otherTo, we don't need to change our op.

          // where did my thing go?
          if (from === otherFrom) {
            // they moved it! tie break.
            if (type === 'left') {
              c.p[common] = otherTo;
              if (from === to) // ugh
                c.lm = otherTo;
            } else {
              return dest;
            }
          } else {
            // they moved around it
            if (from > otherFrom) c.p[common]--;
            if (from > otherTo) c.p[common]++;
            else if (from === otherTo) {
              if (otherFrom > otherTo) {
                c.p[common]++;
                if (from === to) // ugh, again
                  c.lm++;
              }
            }

            // step 2: where am i going to put it?
            if (to > otherFrom) {
              c.lm--;
            } else if (to === otherFrom) {
              if (to > from)
                c.lm--;
            }
            if (to > otherTo) {
              c.lm++;
            } else if (to === otherTo) {
              // if we're both moving in the same direction, tie break
              if ((otherTo > otherFrom && to > from) ||
                  (otherTo < otherFrom && to < from)) {
                if (type === 'right') c.lm++;
              } else {
                if (to > from) c.lm++;
                else if (to === otherFrom) c.lm--;
              }
            }
          }
        }
      } else if (c.li !== void 0 && c.ld === undefined && commonOperand) {
        // li
        var from = otherC.p[common];
        var to = otherC.lm;
        p = c.p[common];
        if (p > from) c.p[common]--;
        if (p > to) c.p[common]++;
      } else {
        // ld, ld+li, si, sd, na, oi, od, oi+od, any li on an element beneath
        // the lm
        //
        // i.e. things care about where their item is after the move.
        var from = otherC.p[common];
        var to = otherC.lm;
        p = c.p[common];
        if (p === from) {
          c.p[common] = to;
        } else {
          if (p > from) c.p[common]--;
          if (p > to) c.p[common]++;
          else if (p === to && from > to) c.p[common]++;
        }
      }
    }
    else if (otherC.oi !== void 0 && otherC.od !== void 0) {
      if (c.p[common] === otherC.p[common]) {
        if (c.oi !== void 0 && commonOperand) {
          // we inserted where someone else replaced
          if (type === 'right') {
            // left wins
            return dest;
          } else {
            // we win, make our op replace what they inserted
            c.od = otherC.oi;
          }
        } else {
          // -> noop if the other component is deleting the same object (or any parent)
          return dest;
        }
      }
    } else if (otherC.oi !== void 0) {
      if (c.oi !== void 0 && c.p[common] === otherC.p[common]) {
        // left wins if we try to insert at the same place
        if (type === 'left') {
          json.append(dest,{p: c.p, od:otherC.oi});
        } else {
          return dest;
        }
      }
    } else if (otherC.od !== void 0) {
      if (c.p[common] == otherC.p[common]) {
        if (!commonOperand)
          return dest;
        if (c.oi !== void 0) {
          delete c.od;
        } else {
          return dest;
        }
      }
    }
  }

  json.append(dest,c);
  return dest;
};

if (typeof require !== "undefined") {
  require('./helpers')._bootstrapTransform(json, json.transformComponent, json.checkValidOp, json.append);
} else {
  // This is kind of awful - come up with a better way to hook this helper code up.
  exports._bootstrapTransform(json, json.transformComponent, json.checkValidOp, json.append);
}

module.exports = json;

},{"./text-old":87,"./helpers":88}],88:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
exports._bootstrapTransform = function(type, transformComponent, checkValidOp, append) {
  var transformComponentX, transformX;

  transformComponentX = function(left, right, destLeft, destRight) {
    transformComponent(destLeft, left, right, 'left');
    return transformComponent(destRight, right, left, 'right');
  };
  type.transformX = type.transformX = transformX = function(leftOp, rightOp) {
    var k, l, l_, newLeftOp, newRightOp, nextC, r, r_, rightComponent, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1;

    checkValidOp(leftOp);
    checkValidOp(rightOp);
    newRightOp = [];
    for (_i = 0, _len = rightOp.length; _i < _len; _i++) {
      rightComponent = rightOp[_i];
      newLeftOp = [];
      k = 0;
      while (k < leftOp.length) {
        nextC = [];
        transformComponentX(leftOp[k], rightComponent, newLeftOp, nextC);
        k++;
        if (nextC.length === 1) {
          rightComponent = nextC[0];
        } else if (nextC.length === 0) {
          _ref = leftOp.slice(k);
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            l = _ref[_j];
            append(newLeftOp, l);
          }
          rightComponent = null;
          break;
        } else {
          _ref1 = transformX(leftOp.slice(k), nextC), l_ = _ref1[0], r_ = _ref1[1];
          for (_k = 0, _len2 = l_.length; _k < _len2; _k++) {
            l = l_[_k];
            append(newLeftOp, l);
          }
          for (_l = 0, _len3 = r_.length; _l < _len3; _l++) {
            r = r_[_l];
            append(newRightOp, r);
          }
          rightComponent = null;
          break;
        }
      }
      if (rightComponent != null) {
        append(newRightOp, rightComponent);
      }
      leftOp = newLeftOp;
    }
    return [leftOp, newRightOp];
  };
  return type.transform = type['transform'] = function(op, otherOp, type) {
    if (!(type === 'left' || type === 'right')) {
      throw new Error("type must be 'left' or 'right'");
    }
    if (otherOp.length === 0) {
      return op;
    }
    if (op.length === 1 && otherOp.length === 1) {
      return transformComponent([], op[0], otherOp[0], type);
    }
    if (type === 'left') {
      return transformX(op, otherOp)[0];
    } else {
      return transformX(otherOp, op)[1];
    }
  };
};

},{}],87:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var append, checkValidComponent, checkValidOp, invertComponent, strInject, text, transformComponent, transformPosition;

text = {
  name: 'text-old',
  uri: 'http://sharejs.org/types/textv0',
  create: function() {
    return '';
  }
};

strInject = function(s1, pos, s2) {
  return s1.slice(0, pos) + s2 + s1.slice(pos);
};

checkValidComponent = function(c) {
  var d_type, i_type;

  if (typeof c.p !== 'number') {
    throw new Error('component missing position field');
  }
  i_type = typeof c.i;
  d_type = typeof c.d;
  if (!((i_type === 'string') ^ (d_type === 'string'))) {
    throw new Error('component needs an i or d field');
  }
  if (!(c.p >= 0)) {
    throw new Error('position cannot be negative');
  }
};

checkValidOp = function(op) {
  var c, _i, _len;

  for (_i = 0, _len = op.length; _i < _len; _i++) {
    c = op[_i];
    checkValidComponent(c);
  }
  return true;
};

text.apply = function(snapshot, op) {
  var component, deleted, _i, _len;

  checkValidOp(op);
  for (_i = 0, _len = op.length; _i < _len; _i++) {
    component = op[_i];
    if (component.i != null) {
      snapshot = strInject(snapshot, component.p, component.i);
    } else {
      deleted = snapshot.slice(component.p, component.p + component.d.length);
      if (component.d !== deleted) {
        throw new Error("Delete component '" + component.d + "' does not match deleted text '" + deleted + "'");
      }
      snapshot = snapshot.slice(0, component.p) + snapshot.slice(component.p + component.d.length);
    }
  }
  return snapshot;
};

text._append = append = function(newOp, c) {
  var last, _ref, _ref1;

  if (c.i === '' || c.d === '') {
    return;
  }
  if (newOp.length === 0) {
    return newOp.push(c);
  } else {
    last = newOp[newOp.length - 1];
    if ((last.i != null) && (c.i != null) && (last.p <= (_ref = c.p) && _ref <= (last.p + last.i.length))) {
      return newOp[newOp.length - 1] = {
        i: strInject(last.i, c.p - last.p, c.i),
        p: last.p
      };
    } else if ((last.d != null) && (c.d != null) && (c.p <= (_ref1 = last.p) && _ref1 <= (c.p + c.d.length))) {
      return newOp[newOp.length - 1] = {
        d: strInject(c.d, last.p - c.p, last.d),
        p: c.p
      };
    } else {
      return newOp.push(c);
    }
  }
};

text.compose = function(op1, op2) {
  var c, newOp, _i, _len;

  checkValidOp(op1);
  checkValidOp(op2);
  newOp = op1.slice();
  for (_i = 0, _len = op2.length; _i < _len; _i++) {
    c = op2[_i];
    append(newOp, c);
  }
  return newOp;
};

text.compress = function(op) {
  return text.compose([], op);
};

text.normalize = function(op) {
  var c, newOp, _i, _len, _ref;

  newOp = [];
  if ((op.i != null) || (op.p != null)) {
    op = [op];
  }
  for (_i = 0, _len = op.length; _i < _len; _i++) {
    c = op[_i];
    if ((_ref = c.p) == null) {
      c.p = 0;
    }
    append(newOp, c);
  }
  return newOp;
};

transformPosition = function(pos, c, insertAfter) {
  if (c.i != null) {
    if (c.p < pos || (c.p === pos && insertAfter)) {
      return pos + c.i.length;
    } else {
      return pos;
    }
  } else {
    if (pos <= c.p) {
      return pos;
    } else if (pos <= c.p + c.d.length) {
      return c.p;
    } else {
      return pos - c.d.length;
    }
  }
};

text.transformCursor = function(position, op, side) {
  var c, insertAfter, _i, _len;

  insertAfter = side === 'right';
  for (_i = 0, _len = op.length; _i < _len; _i++) {
    c = op[_i];
    position = transformPosition(position, c, insertAfter);
  }
  return position;
};

text._tc = transformComponent = function(dest, c, otherC, side) {
  var cIntersect, intersectEnd, intersectStart, newC, otherIntersect, s;

  checkValidOp([c]);
  checkValidOp([otherC]);
  if (c.i != null) {
    append(dest, {
      i: c.i,
      p: transformPosition(c.p, otherC, side === 'right')
    });
  } else {
    if (otherC.i != null) {
      s = c.d;
      if (c.p < otherC.p) {
        append(dest, {
          d: s.slice(0, otherC.p - c.p),
          p: c.p
        });
        s = s.slice(otherC.p - c.p);
      }
      if (s !== '') {
        append(dest, {
          d: s,
          p: c.p + otherC.i.length
        });
      }
    } else {
      if (c.p >= otherC.p + otherC.d.length) {
        append(dest, {
          d: c.d,
          p: c.p - otherC.d.length
        });
      } else if (c.p + c.d.length <= otherC.p) {
        append(dest, c);
      } else {
        newC = {
          d: '',
          p: c.p
        };
        if (c.p < otherC.p) {
          newC.d = c.d.slice(0, otherC.p - c.p);
        }
        if (c.p + c.d.length > otherC.p + otherC.d.length) {
          newC.d += c.d.slice(otherC.p + otherC.d.length - c.p);
        }
        intersectStart = Math.max(c.p, otherC.p);
        intersectEnd = Math.min(c.p + c.d.length, otherC.p + otherC.d.length);
        cIntersect = c.d.slice(intersectStart - c.p, intersectEnd - c.p);
        otherIntersect = otherC.d.slice(intersectStart - otherC.p, intersectEnd - otherC.p);
        if (cIntersect !== otherIntersect) {
          throw new Error('Delete ops delete different text in the same region of the document');
        }
        if (newC.d !== '') {
          newC.p = transformPosition(newC.p, otherC);
          append(dest, newC);
        }
      }
    }
  }
  return dest;
};

invertComponent = function(c) {
  if (c.i != null) {
    return {
      d: c.i,
      p: c.p
    };
  } else {
    return {
      i: c.d,
      p: c.p
    };
  }
};

text.invert = function(op) {
  var c, _i, _len, _ref, _results;

  _ref = op.slice().reverse();
  _results = [];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    c = _ref[_i];
    _results.push(invertComponent(c));
  }
  return _results;
};

if (typeof require === 'undefined') {
  exports._bootstrapTransform(text, text.transformComponent, text.checkValidOp, text.append);
} else {
  require('./helpers')._bootstrapTransform(text, text.transformComponent, text.checkValidOp, text.append);
}

module.exports = text;

},{"./helpers":88}]},{},[14,8])
//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL2xpYi9pbmRleC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9saWIvZGVyYnkuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItZGVtby9saWIvYXBwL2NvbnRyb2xsZXJGbnMuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItZGVtby9saWIvYXBwL2V2ZW50cy5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL2xpYi9hcHAvdXNlci5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL2xpYi9hcHAvcm91dGVzLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLWRlbW8vbGliL2FwcC92aWV3Rm5zLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLWRlbW8vbm9kZV9tb2R1bGVzL3JhY2VyLWJyb3dzZXJjaGFubmVsL2xpYi9icm93c2VyLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL2xpYi9SYWNlci5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9idWlsdGluL2V2ZW50cy5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL2xpYi9hcHAvaW5kZXguanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItZGVtby91aS9pbmRleC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9yYWNlci1icm93c2VyY2hhbm5lbC9ub2RlX21vZHVsZXMvYnJvd3NlcmNoYW5uZWwvZGlzdC9iY3NvY2tldC11bmNvbXByZXNzZWQuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItZGVtby91aS9jb25uZWN0aW9uQWxlcnQvaW5kZXguanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbGliL2RlcmJ5LmJyb3dzZXIuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbGliL2FwcC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9saWIvdmlld01vZGVsLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L2xpYi9kZXJieS5Nb2RlbC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbGliL01vZGVsL2luZGV4LmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L2xpYi9wYXRocy5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9saWIvRXZlbnREaXNwYXRjaGVyLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5LXVpLWdpdGh1Yi1idXR0b25zL2luZGV4LmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L2xpYi9QYXRoTWFwLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L2xpYi90ZXh0T3QuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvYnVpbHRpbi9wYXRoLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9saWIvdXRpbC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS11aS1naXRodWItYnV0dG9ucy9idXR0b24vaW5kZXguanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbGliL2NvbXBvbmVudC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9saWIvcmVmcmVzaC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvdHJhY2tzL2xpYi9icm93c2VyLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvZGVlcC1pcy9pbmRleC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbGliL01vZGVsL2V2ZW50cy5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbGliL01vZGVsL3BhdGhzLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9saWIvTW9kZWwvY29sbGVjdGlvbnMuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL2xpYi9Nb2RlbC9tdXRhdG9ycy5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbGliL01vZGVsL3N1YnNjcmlwdGlvbnMuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL2xpYi9Nb2RlbC9jb250ZXh0cy5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbGliL01vZGVsL2ZuLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9saWIvTW9kZWwvZmlsdGVyLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9saWIvTW9kZWwvcmVmTGlzdC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbGliL01vZGVsL3JlZi5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9idWlsdGluL3VybC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9saWIvRG9tLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9saWIvTW9kZWwvZGVmYXVsdEZucy5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9saWIvVmlldy5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9saWIvbWFya3VwLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L2xpYi9ldmVudEJpbmRpbmcuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL2h0bWwtdXRpbC9saWIvaW5kZXguanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3RyYWNrcy9saWIvY29tcG9zZS5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvZG9tLXNoaW0vbGliL2luZGV4LmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2J1aWx0aW4vcXVlcnlzdHJpbmcuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbGliL3ZpZXdQYXRoLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9saWIvQ2hhbm5lbC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvdHJhY2tzL3ZlbmRvci9leHByZXNzL3JvdXRlci9yb3V0ZS5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvaHRtbC11dGlsL2xpYi9lbnRpdHlDb2RlLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9odG1sLXV0aWwvbGliL3BhcnNlLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9saWIvTW9kZWwvTG9jYWxEb2MuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL2xpYi9Nb2RlbC9SZW1vdGVEb2MuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL2xpYi9Nb2RlbC9jb25uZWN0aW9uLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy90cmFja3MvdmVuZG9yL2V4cHJlc3MvdXRpbHMuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL2xpYi9Nb2RlbC9Nb2RlbC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbGliL01vZGVsL0RvYy5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbGliL01vZGVsL3NldERpZmYuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL2xpYi9Nb2RlbC9RdWVyeS5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9idWZmZXIuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL25vZGVfbW9kdWxlcy9ub2RlLXV1aWQvdXVpZC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbm9kZV9tb2R1bGVzL2FycmF5ZGlmZi9pbmRleC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvdHJhY2tzL2xpYi9yb3V0ZXIuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL01ENS9tZDUuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3RyYWNrcy9saWIvSGlzdG9yeS5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbm9kZV9tb2R1bGVzL3NoYXJlL2xpYi9jbGllbnQvaW5kZXguanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3RyYWNrcy9ub2RlX21vZHVsZXMvcXMvaW5kZXguanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL01ENS9ub2RlX21vZHVsZXMvY3J5cHQvY3J5cHQuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL01ENS9ub2RlX21vZHVsZXMvY2hhcmVuYy9jaGFyZW5jLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvc2hhcmUvbGliL2NsaWVudC9taWNyb2V2ZW50LmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvc2hhcmUvbGliL2NsaWVudC9xdWVyeS5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbm9kZV9tb2R1bGVzL3NoYXJlL2xpYi9jbGllbnQvY29ubmVjdGlvbi5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbm9kZV9tb2R1bGVzL3NoYXJlL2xpYi9jbGllbnQvZG9jLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9pbmRleC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbm9kZV9tb2R1bGVzL3NoYXJlL25vZGVfbW9kdWxlcy9vdHR5cGVzL2xpYi9pbmRleC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvcm5nLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvc2hhcmUvbm9kZV9tb2R1bGVzL290dHlwZXMvbGliL3NpbXBsZS5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbm9kZV9tb2R1bGVzL3NoYXJlL25vZGVfbW9kdWxlcy9vdHR5cGVzL2xpYi90ZXh0LmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9zaGEuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL25vZGVfbW9kdWxlcy9zaGFyZS9ub2RlX21vZHVsZXMvb3R0eXBlcy9saWIvdGV4dC10cDIuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L21kNS5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbm9kZV9tb2R1bGVzL3NoYXJlL25vZGVfbW9kdWxlcy9vdHR5cGVzL2xpYi9qc29uMC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbm9kZV9tb2R1bGVzL3NoYXJlL25vZGVfbW9kdWxlcy9vdHR5cGVzL2xpYi9oZWxwZXJzLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvc2hhcmUvbm9kZV9tb2R1bGVzL290dHlwZXMvbGliL3RleHQtb2xkLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFDQTs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeGpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdjVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdnhIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFBBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25ZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3piQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2g2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9ZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbm9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsidmFyIFJhY2VyID0gcmVxdWlyZSgnLi9SYWNlcicpO1xubW9kdWxlLmV4cG9ydHMgPSBuZXcgUmFjZXI7XG4iLCIoZnVuY3Rpb24oX19kaXJuYW1lKXt2YXIgcmFjZXIgPSByZXF1aXJlKCdyYWNlcicpO1xudmFyIGRlcmJ5ID0gbW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlKHJhY2VyKTtcblxudmFyIGRlcmJ5UGx1Z2luID0gKHJhY2VyLnV0aWwuaXNTZXJ2ZXIpID9cbiAgX19kaXJuYW1lICsgJy9kZXJieS5zZXJ2ZXInIDpcbiAgcmVxdWlyZSgnLi9kZXJieS5icm93c2VyJyk7XG5cbi8vIFRPRE86IFJlbW92ZSBvciBpbXBsZW1lbnRcbmRlcmJ5LmdldCA9IGZ1bmN0aW9uKCkge31cblxuZGVyYnlcbiAgLy8gU2VydmVyLXNpZGUgb3IgYnJvd3Nlci1zaWRlIG1ldGhvZHNcbiAgLnVzZShkZXJieVBsdWdpbik7XG5cbn0pKFwiL25vZGVfbW9kdWxlcy9kZXJieS9saWJcIikiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcHApIHtcbiAgYXBwLmZuKCd1c2VyJywge1xuICAgIGNoYW5nZUVtYWlsOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIG9yaWdpbiA9IHRoaXMubW9kZWwuZ2V0KCckY29uZmlnLm9yaWdpbicpO1xuICAgICAgJC5wb3N0KG9yaWdpbiArICcvdXNlci9jaGFuZ2VFbWFpbCcsIGUuYXQoKS5nZXQoKSk7XG4gICAgfSxcbiAgICBjaGFuZ2VQYXNzd29yZDogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBvcmlnaW4gPSB0aGlzLm1vZGVsLmdldCgnJGNvbmZpZy5vcmlnaW4nKTtcbiAgICAgICQucG9zdChvcmlnaW4gKyAnL3VzZXIvY2hhbmdlUGFzc3dvcmQnLCBlLmF0KCkuZ2V0KCksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZS5hdCgpLmRlbCgpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBjaGFuZ2VVc2VybmFtZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBvcmlnaW4gPSB0aGlzLm1vZGVsLmdldCgnJGNvbmZpZy5vcmlnaW4nKTtcbiAgICAgICQucG9zdChvcmlnaW4gKyAnL3VzZXIvY2hhbmdlVXNlcm5hbWUnLCBlLmF0KCkuZ2V0KCkpO1xuICAgIH0sXG4gICAgY29ubmVjdDoge1xuICAgICAgZmFjZWJvb2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBvcmlnaW4gPSB0aGlzLm1vZGVsLmdldCgnJGNvbmZpZy5vcmlnaW4nKTtcbiAgICAgICAgJC5wb3B1cFdpbmRvdyhvcmlnaW4gKyAnL3VzZXIvYXV0aC9mYWNlYm9vaycpO1xuICAgICAgfSxcbiAgICAgIGdvb2dsZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIG9yaWdpbiA9IHRoaXMubW9kZWwuZ2V0KCckY29uZmlnLm9yaWdpbicpO1xuICAgICAgICAkLnBvcHVwV2luZG93KG9yaWdpbiArICcvdXNlci9hdXRoL2dvb2dsZScpO1xuICAgICAgfSxcbiAgICAgIHR3aXR0ZXI6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBvcmlnaW4gPSB0aGlzLm1vZGVsLmdldCgnJGNvbmZpZy5vcmlnaW4nKTtcbiAgICAgICAgJC5wb3B1cFdpbmRvdyhvcmlnaW4gKyAnL3VzZXIvYXV0aC90d2l0dGVyJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBmb3Jnb3RQYXNzd29yZDogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBvcmlnaW4gPSB0aGlzLm1vZGVsLmdldCgnJGNvbmZpZy5vcmlnaW4nKTtcbiAgICAgICQucG9zdChvcmlnaW4gKyAnL3VzZXIvZm9yZ290UGFzc3dvcmQnLCBlLmF0KCkuZ2V0KCksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZS5hdCgpLmRlbCgpO1xuICAgICAgICBlLmF0KCkuc2V0KCdzdWNjZXNzJywgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHJlc2V0UGFzc3dvcmQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMsIG9yaWdpbiA9IHRoaXMubW9kZWwuZ2V0KCckY29uZmlnLm9yaWdpbicpO1xuICAgICAgJC5wb3N0KG9yaWdpbiArICcvdXNlci9yZXNldFBhc3N3b3JkJywgZS5hdCgpLmdldCgpLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBzZWxmLm1vZGVsLnNldCgnX3Nlc3Npb24udXNlci5pZCcsIGUuYXQoKS5nZXQoJ3VzZXJJZCcpKTtcbiAgICAgICAgc2VsZi5tb2RlbC5zZXQoJ19zZXNzaW9uLnVzZXIuaXNSZWdpc3RlcmVkJywgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNpZ25pbjogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcywgb3JpZ2luID0gdGhpcy5tb2RlbC5nZXQoJyRjb25maWcub3JpZ2luJyk7XG4gICAgICAkLnBvc3Qob3JpZ2luICsgJy91c2VyL3NpZ25pbicsIGUuYXQoKS5nZXQoKSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgc2VsZi5tb2RlbC5zZXQoJ19zZXNzaW9uLnVzZXIuaWQnLCBkYXRhLnVzZXIuaWQpO1xuICAgICAgICBzZWxmLm1vZGVsLnNldCgnX3Nlc3Npb24udXNlci5pc1JlZ2lzdGVyZWQnLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2lnbm91dDogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcywgb3JpZ2luID0gdGhpcy5tb2RlbC5nZXQoJyRjb25maWcub3JpZ2luJyk7XG4gICAgICAkLnBvc3Qob3JpZ2luICsgJy91c2VyL3NpZ25vdXQnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBzZWxmLm1vZGVsLnNldCgnX3Nlc3Npb24udXNlci5pZCcsIGRhdGEudXNlci5pZCk7XG4gICAgICAgIHNlbGYubW9kZWwuc2V0KCdfc2Vzc2lvbi51c2VyLmlzUmVnaXN0ZXJlZCcsIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2lnbnVwOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzLCBvcmlnaW4gPSB0aGlzLm1vZGVsLmdldCgnJGNvbmZpZy5vcmlnaW4nKTtcbiAgICAgICQucG9zdChvcmlnaW4gKyAnL3VzZXIvc2lnbnVwJywgZS5hdCgpLmdldCgpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYubW9kZWwuc2V0KCdfc2Vzc2lvbi51c2VyLmlzUmVnaXN0ZXJlZCcsIHRydWUpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICB2ZXJpZnlFbWFpbDogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcywgb3JpZ2luID0gdGhpcy5tb2RlbC5nZXQoJyRjb25maWcub3JpZ2luJyk7XG4gICAgICAkLnBvc3Qob3JpZ2luICsgJy91c2VyL3ZlcmlmeUVtYWlsJywgZS5hdCgpLmdldCgpKTtcbiAgICB9XG4gIH0pO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcHApIHtcbiAgYXBwLnJlYWR5KGZ1bmN0aW9uIChtb2RlbCkge1xuICAgIG1vZGVsLm9uKCdjaGFuZ2UnLCAnJGNvbm5lY3Rpb24uc3RhdGUnLCBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIGlmIChzdGF0ZSAhPT0gJ2Nvbm5lY3RlZCcpIHJldHVybjtcbiAgICAgIGlmIChtb2RlbC5nZXQoJ19zZXNzaW9uLnVzZXIuaWQnKSkgcmV0dXJuO1xuICAgICAgdmFyIG9yaWdpbiA9IG1vZGVsLmdldCgnJGNvbmZpZy5vcmlnaW4nKTtcbiAgICAgICQuYWpheCh7dHlwZTogJ1BPU1QnLCB1cmw6IG9yaWdpbiArICcvdXNlci9zZXNzaW9uaXplJ30pLmRvbmUoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgbW9kZWwuc2V0KCdfc2Vzc2lvbi51c2VyLmlkJywgZGF0YS51c2VyLmlkKTtcbiAgICAgICAgbW9kZWwuc2V0KCdfc2Vzc2lvbi51c2VyLnJlZ2lzdGVyZWQnLCBkYXRhLnVzZXIucmVnaXN0ZXJlZCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIG1vZGVsLm9uKCdjaGFuZ2UnLCAnX3Nlc3Npb24udXNlci5pZCcsIGZ1bmN0aW9uICh1c2VySWQpIHtcbiAgICAgIGlmICghdXNlcklkKSByZXR1cm47XG4gICAgICB2YXIgJHByaXZhdGUgPSBtb2RlbC5hdCgndXNlcnNQcml2YXRlLicgKyB1c2VySWQpO1xuICAgICAgdmFyICRwdWJsaWMgPSBtb2RlbC5hdCgndXNlcnNQdWJsaWMuJyArIHVzZXJJZCk7XG4gICAgICBtb2RlbC5zdWJzY3JpYmUoJHByaXZhdGUsICRwdWJsaWMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgbW9kZWwucmVmKCdfcGFnZS51c2VyLnByaXZhdGUnLCAkcHJpdmF0ZSk7XG4gICAgICAgIG1vZGVsLnJlZignX3BhZ2UudXNlci5wdWJsaWMnLCAkcHVibGljKTtcbiAgICAgICAgdmFyIGlzUmVnaXN0ZXJlZCA9ICRwdWJsaWMuZ2V0KCdpc1JlZ2lzdGVyZWQnKTtcbiAgICAgICAgaWYgKG1vZGVsLmdldCgnX3BhZ2UucHJpdmF0ZScpICYmICFpc1JlZ2lzdGVyZWQpIHJldHVybiBhcHAuaGlzdG9yeS5wdXNoKCcvJyk7XG4gICAgICAgIGlmIChtb2RlbC5nZXQoJ19wYWdlLnB1YmxpYycpICYmIGlzUmVnaXN0ZXJlZCkgYXBwLmhpc3RvcnkucHVzaCgnL3NldHRpbmdzJyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIG1vZGVsLm9uKCdjaGFuZ2UnLCAnX3Nlc3Npb24udXNlci5pc1JlZ2lzdGVyZWQnLCBmdW5jdGlvbiAoaXNSZWdpc3RlcmVkKSB7XG4gICAgICBpZiAobW9kZWwuZ2V0KCdfcGFnZS5wcml2YXRlJykgJiYgIWlzUmVnaXN0ZXJlZCkgcmV0dXJuIGFwcC5oaXN0b3J5LnB1c2goJy8nKTtcbiAgICAgIGlmIChtb2RlbC5nZXQoJ19wYWdlLnB1YmxpYycpICYmIGlzUmVnaXN0ZXJlZCkgYXBwLmhpc3RvcnkucHVzaCgnL3NldHRpbmdzJyk7XG4gICAgfSk7XG4gIH0pO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcHApIHtcbiAgYXBwLmdldCgnKicsIGZ1bmN0aW9uIChwYWdlLCBtb2RlbCwgcGFyYW1zLCBuZXh0KSB7XG4gICAgdmFyIHVzZXJJZCA9IG1vZGVsLmdldCgnX3Nlc3Npb24udXNlci5pZCcpO1xuICAgIGlmICghdXNlcklkKSByZXR1cm4gbmV4dCgpO1xuICAgIHZhciAkcHJpdmF0ZSA9IG1vZGVsLmF0KCd1c2Vyc1ByaXZhdGUuJyArIHVzZXJJZCk7XG4gICAgdmFyICRwdWJsaWMgPSBtb2RlbC5hdCgndXNlcnNQdWJsaWMuJyArIHVzZXJJZCk7XG4gICAgbW9kZWwuc3Vic2NyaWJlKCRwcml2YXRlLCAkcHVibGljLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gbmV4dChlcnIpO1xuICAgICAgbW9kZWwucmVmKCdfcGFnZS51c2VyLnByaXZhdGUnLCAkcHJpdmF0ZSk7XG4gICAgICBtb2RlbC5yZWYoJ19wYWdlLnVzZXIucHVibGljJywgJHB1YmxpYyk7XG4gICAgICBuZXh0KCk7XG4gICAgfSk7XG4gIH0pO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcHApIHtcbiAgYXBwLmdldCgnLycsIGZ1bmN0aW9uIChwYWdlKSB7XG4gICAgcGFnZS5yZW5kZXIoJ2hvbWUnKTtcbiAgfSk7XG5cbiAgYXBwLmdldCgnLzQwMycsIGZ1bmN0aW9uIChwYWdlKSB7XG4gICAgcGFnZS5yZW5kZXIoJzQwMycpO1xuICB9KTtcblxuICBhcHAuZ2V0KCcvNDA0JywgZnVuY3Rpb24gKHBhZ2UpIHtcbiAgICBwYWdlLnJlbmRlcignNDA0Jyk7XG4gIH0pO1xuXG4gIGFwcC5nZXQoJy80MDQnLCBmdW5jdGlvbiAocGFnZSkge1xuICAgIHBhZ2UucmVuZGVyKCc0MDQnKTtcbiAgfSk7XG5cbiAgYXBwLmdldCgnLzUwMCcsIGZ1bmN0aW9uIChwYWdlKSB7XG4gICAgcGFnZS5yZW5kZXIoJzUwMCcpO1xuICB9KTtcblxuICBhcHAuZ2V0KCcvZm9yZ290JywgZnVuY3Rpb24gKHBhZ2UsIG1vZGVsKSB7XG4gICAgbW9kZWwuc2V0KCdfcGFnZS5wdWJsaWMnLCB0cnVlKTtcbiAgICBwYWdlLnJlbmRlcignZm9yZ290Jyk7XG4gIH0pO1xuXG4gIGFwcC5nZXQoJy9yZXNldC86dXNlcklkLzp0b2tlbicsIGZ1bmN0aW9uIChwYWdlLCBtb2RlbCkge1xuICAgIG1vZGVsLnNldCgnX3BhZ2UuZm9ybS50b2tlbicsIHBhZ2UucGFyYW1zLnRva2VuKTtcbiAgICBtb2RlbC5zZXQoJ19wYWdlLmZvcm0udXNlcklkJywgcGFnZS5wYXJhbXMudXNlcklkKTtcbiAgICBtb2RlbC5zZXQoJ19wYWdlLnB1YmxpYycsIHRydWUpO1xuICAgIHBhZ2UucmVuZGVyKCdyZXNldCcpO1xuICB9KTtcblxuICBhcHAuZ2V0KCcvc2V0dGluZ3MnLCBmdW5jdGlvbiAocGFnZSwgbW9kZWwpIHtcbiAgICBtb2RlbC5zZXROdWxsKCdfcGFnZS5mb3JtLnVzZXJuYW1lLnVzZXJuYW1lJywgbW9kZWwuZ2V0KCdfcGFnZS51c2VyLnB1YmxpYy5sb2NhbC51c2VybmFtZScpKTtcbiAgICBtb2RlbC5zZXROdWxsKCdfcGFnZS5mb3JtLmVtYWlsLmVtYWlsJywgbW9kZWwuZ2V0KCdfcGFnZS51c2VyLnByaXZhdGUubG9jYWwuZW1haWxzLjAudmFsdWUnKSk7XG4gICAgbW9kZWwuc2V0KCdfcGFnZS5wcml2YXRlJywgdHJ1ZSk7XG4gICAgcGFnZS5yZW5kZXIoJ3NldHRpbmdzJyk7XG4gIH0pO1xuXG4gIGFwcC5nZXQoJy9zaWduaW4nLCBmdW5jdGlvbiAocGFnZSwgbW9kZWwpIHtcbiAgICBtb2RlbC5zZXQoJ19wYWdlLnB1YmxpYycsIHRydWUpO1xuICAgIHBhZ2UucmVuZGVyKCdzaWduaW4nKTtcbiAgfSk7XG5cbiAgYXBwLmdldCgnL3NpZ251cCcsIGZ1bmN0aW9uIChwYWdlLCBtb2RlbCkge1xuICAgIG1vZGVsLnNldCgnX3BhZ2UucHVibGljJywgdHJ1ZSk7XG4gICAgcGFnZS5yZW5kZXIoJ3NpZ251cCcpO1xuICB9KTtcblxuICBhcHAuZ2V0KCcvdXNlci9hdXRoLzpwcm92aWRlci9kb25lJywgZnVuY3Rpb24gKHBhZ2UsIG1vZGVsKSB7XG4gICAgcGFnZS5yZW5kZXIoJ2hvbWUnKTtcbiAgfSk7XG5cbiAgYXBwLmVudGVyKCcvdXNlci9hdXRoLzpwcm92aWRlci9kb25lJywgZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgaWYgKCF3aW5kb3cub3BlbmVyKSByZXR1cm47XG4gICAgdmFyIHVzZXJJZCA9IG1vZGVsLmdldCgnX3Nlc3Npb24udXNlci5pZCcpO1xuICAgIHdpbmRvdy5vcGVuZXIuREVSQlkuYXBwLm1vZGVsLnNldCgnX3Nlc3Npb24udXNlci5pZCcsIHVzZXJJZCk7XG4gICAgd2luZG93Lm9wZW5lci5ERVJCWS5hcHAubW9kZWwuc2V0KCdfc2Vzc2lvbi51c2VyLnJlZ2lzdGVyZWQnLCB0cnVlKTtcbiAgICB3aW5kb3cuY2xvc2UoKTtcbiAgfSk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFwcCkge1xuICBhcHAudmlldy5mbigndXNlci5kaXNwbGF5TmFtZScsIGZ1bmN0aW9uIChwdWJsaWMpIHtcbiAgICBpZiAocHVibGljLmxvY2FsKSByZXR1cm4gcHVibGljLmxvY2FsLnVzZXJuYW1lO1xuICAgIGlmIChwdWJsaWMuZmFjZWJvb2spIHJldHVybiBwdWJsaWMuZmFjZWJvb2suZGlzcGxheU5hbWU7XG4gICAgaWYgKHB1YmxpYy5nb29nbGUpIHJldHVybiBwdWJsaWMuZ29vZ2xlLmRpc3BsYXlOYW1lO1xuICAgIGlmIChwdWJsaWMudHdpdHRlcikgcmV0dXJuIHB1YmxpYy50d2l0dGVyLmRpc3BsYXlOYW1lO1xuICB9KTtcblxuICBhcHAudmlldy5mbigndXNlci5waG90b1VybCcsIGZ1bmN0aW9uIChwdWJsaWMpIHtcbiAgICBpZiAocHVibGljLmZhY2Vib29rKSByZXR1cm4gJ2h0dHBzOi8vZ3JhcGguZmFjZWJvb2suY29tLycgKyBwdWJsaWMuZmFjZWJvb2sudXNlcm5hbWUgKyAnL3BpY3R1cmUnO1xuICAgIGlmIChwdWJsaWMuZ29vZ2xlICYmIHB1YmxpYy5nb29nbGUucGhvdG9zICYmIHB1YmxpYy5nb29nbGUucGhvdG9zWzBdKSByZXR1cm4gcHVibGljLmdvb2dsZS5waG90b3NbMF0udmFsdWU7XG4gICAgaWYgKHB1YmxpYy50d2l0dGVyICYmIHB1YmxpYy50d2l0dGVyLnBob3RvcyAmJiBwdWJsaWMudHdpdHRlci5waG90b3NbMF0pIHJldHVybiBwdWJsaWMudHdpdHRlci5waG90b3NbMF0udmFsdWU7XG4gICAgaWYgKHB1YmxpYy5ncmF2YXRhciAmJiBwdWJsaWMuZ3JhdmF0YXIudGh1bWJuYWlsVXJsKSByZXR1cm4gcHVibGljLmdyYXZhdGFyLnRodW1ibmFpbFVybDtcbiAgfSk7XG59OyIsInZhciByYWNlciA9IHJlcXVpcmUoJ3JhY2VyJyk7XG52YXIgQkNTb2NrZXQgPSByZXF1aXJlKCdicm93c2VyY2hhbm5lbC9kaXN0L2Jjc29ja2V0LXVuY29tcHJlc3NlZCcpLkJDU29ja2V0O1xuXG5yYWNlci5Nb2RlbC5wcm90b3R5cGUuX2NyZWF0ZVNvY2tldCA9IGZ1bmN0aW9uKGJ1bmRsZSkge1xuICB2YXIgb3B0aW9ucyA9IGJ1bmRsZS5yYWNlckJyb3dzZXJDaGFubmVsO1xuICB2YXIgYmFzZSA9IG9wdGlvbnMuYmFzZSB8fCAnL2NoYW5uZWwnO1xuICBpZiAoYnVuZGxlLm1vdW50KSBiYXNlID0gYnVuZGxlLm1vdW50ICsgYmFzZTtcbiAgcmV0dXJuIG5ldyBCQ1NvY2tldChiYXNlLCBvcHRpb25zKTtcbn07XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5wcm9jZXNzLm5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FuU2V0SW1tZWRpYXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBjYW5Qb3N0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXJcbiAgICA7XG5cbiAgICBpZiAoY2FuU2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZikgeyByZXR1cm4gd2luZG93LnNldEltbWVkaWF0ZShmKSB9O1xuICAgIH1cblxuICAgIGlmIChjYW5Qb3N0KSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKGV2LnNvdXJjZSA9PT0gd2luZG93ICYmIGV2LmRhdGEgPT09ICdwcm9jZXNzLXRpY2snKSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MtdGljaycsICcqJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59KSgpO1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbiIsIihmdW5jdGlvbihwcm9jZXNzLF9fZGlybmFtZSl7dmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmFjZXI7XG5cbmZ1bmN0aW9uIFJhY2VyKCkge1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbn1cblxudXRpbC5tZXJnZUludG8oUmFjZXIucHJvdG90eXBlLCBFdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblxuLy8gTWFrZSBjbGFzc2VzIGFjY2Vzc2libGUgZm9yIHVzZSBieSBwbHVnaW5zIGFuZCB0ZXN0c1xuUmFjZXIucHJvdG90eXBlLk1vZGVsID0gTW9kZWw7XG5SYWNlci5wcm90b3R5cGUudXRpbCA9IHV0aWw7XG5cbi8vIFN1cHBvcnQgcGx1Z2lucyBvbiByYWNlciBpbnN0YW5jZXNcblJhY2VyLnByb3RvdHlwZS51c2UgPSB1dGlsLnVzZTtcblxuUmFjZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHZhciByYWNlciA9IHRoaXM7XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPSBkYXRhLm5vZGVFbnY7XG5cbiAgLy8gSW5pdCBpcyBleGVjdXRlZCBhc3luYyBzbyB0aGF0IHBsdWdpbnMgY2FuIGV4dGVuZCBSYWNlciBldmVuIGlmIHRoZXkgYXJlXG4gIC8vIGluY2x1ZGVkIGFmdGVyIHRoZSBtYWluIGVudHJ5IHBvaW50IGluIHRoZSBidW5kbGVcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICB2YXIgbW9kZWwgPSBuZXcgTW9kZWw7XG5cbiAgICBtb2RlbC5fY3JlYXRlQ29ubmVjdGlvbihkYXRhKTtcblxuICAgIHJhY2VyLmVtaXQoJ21vZGVsJywgbW9kZWwpO1xuXG4gICAgLy8gUmUtY3JlYXRlIGRvY3VtZW50cyBmb3IgYWxsIG1vZGVsIGRhdGFcbiAgICBmb3IgKHZhciBjb2xsZWN0aW9uTmFtZSBpbiBkYXRhLmNvbGxlY3Rpb25zKSB7XG4gICAgICB2YXIgY29sbGVjdGlvbiA9IGRhdGEuY29sbGVjdGlvbnNbY29sbGVjdGlvbk5hbWVdO1xuICAgICAgZm9yICh2YXIgaWQgaW4gY29sbGVjdGlvbikge1xuICAgICAgICB2YXIgZG9jID0gbW9kZWwuZ2V0T3JDcmVhdGVEb2MoY29sbGVjdGlvbk5hbWUsIGlkLCBjb2xsZWN0aW9uW2lkXSk7XG4gICAgICAgIGlmIChkb2Muc2hhcmVEb2MpIHtcbiAgICAgICAgICBtb2RlbC5fbG9hZFZlcnNpb25zW2NvbGxlY3Rpb25OYW1lICsgJy4nICsgaWRdID0gZG9jLnNoYXJlRG9jLnZlcnNpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBTdXBwb3J0IHJlLWluaXQgd2hlbiB0aGVyZSBhcmUgY29udGV4dHMgb3RoZXIgdGhhbiByb290XG4gICAgdmFyIGNvbnRleHQgPSBkYXRhLmNvbnRleHRzLnJvb3Q7XG4gICAgLy8gUmUtc3Vic2NyaWJlIHRvIGRvY3VtZW50IHN1YnNjcmlwdGlvbnNcbiAgICBmb3IgKHZhciBwYXRoIGluIGNvbnRleHQuc3Vic2NyaWJlZERvY3MpIHtcbiAgICAgIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgIG1vZGVsLnN1YnNjcmliZURvYyhzZWdtZW50c1swXSwgc2VnbWVudHNbMV0pO1xuICAgICAgbW9kZWwuX3N1YnNjcmliZWREb2NzW3BhdGhdID0gY29udGV4dC5zdWJzY3JpYmVkRG9jc1twYXRoXTtcbiAgICB9XG4gICAgLy8gSW5pdCBmZXRjaGVkRG9jcyBjb3VudHNcbiAgICBmb3IgKHZhciBwYXRoIGluIGNvbnRleHQuZmV0Y2hlZERvY3MpIHtcbiAgICAgIG1vZGVsLl9mZXRjaGVkRG9jc1twYXRoXSA9IGNvbnRleHQuZmV0Y2hlZERvY3NbcGF0aF07XG4gICAgfVxuXG4gICAgdmFyIHNpbGVudE1vZGVsID0gbW9kZWwuc2lsZW50KCk7XG4gICAgLy8gUmUtY3JlYXRlIHJlZnNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEucmVmcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBkYXRhLnJlZnNbaV07XG4gICAgICBzaWxlbnRNb2RlbC5yZWYoaXRlbVswXSwgaXRlbVsxXSk7XG4gICAgfVxuICAgIC8vIFJlLWNyZWF0ZSByZWZMaXN0c1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5yZWZMaXN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBkYXRhLnJlZkxpc3RzW2ldO1xuICAgICAgc2lsZW50TW9kZWwucmVmTGlzdChpdGVtWzBdLCBpdGVtWzFdLCBpdGVtWzJdLCBpdGVtWzNdKTtcbiAgICB9XG4gICAgLy8gUmUtY3JlYXRlIGZuc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5mbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gZGF0YS5mbnNbaV07XG4gICAgICBzaWxlbnRNb2RlbC5zdGFydC5hcHBseShzaWxlbnRNb2RlbCwgaXRlbSk7XG4gICAgfVxuICAgIC8vIFJlLWNyZWF0ZSBmaWx0ZXJzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gZGF0YS5maWx0ZXJzW2ldO1xuICAgICAgdmFyIGZpbHRlciA9IG1vZGVsLl9maWx0ZXJzLmFkZChpdGVtWzBdLCBpdGVtWzFdLCBpdGVtWzJdKTtcbiAgICAgIGZpbHRlci5yZWYoaXRlbVszXSk7XG4gICAgfVxuICAgIC8vIEluaXQgYW5kIHJlLXN1YnNjcmliZSBxdWVyaWVzIGFzIGFwcHJvcHJpYXRlXG4gICAgbW9kZWwuX2luaXRRdWVyaWVzKGRhdGEucXVlcmllcyk7XG5cbiAgICByYWNlci5fbW9kZWwgPSBtb2RlbDtcbiAgICByYWNlci5lbWl0KCdyZWFkeScsIG1vZGVsKTtcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmFjZXIucHJvdG90eXBlLnJlYWR5ID0gZnVuY3Rpb24oY2IpIHtcbiAgaWYgKHRoaXMuX21vZGVsKSB7XG4gICAgLy8gQ2FsbGJhY2sgYXN5bmMgaW4gY2FzZSB0aGUgY29kZSBkZXBlbmRzIG9uIHNjcmlwdHMgaW5jbHVkZWQgYWZ0ZXIgaW5cbiAgICAvLyB0aGUgYnVuZGxlIGFuZCBpcyBnYXRlZCBieSBhIHJlYWR5XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIGNiKHRoaXMuX21vZGVsKTtcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5vbmNlKCdyZWFkeScsIGNiKTtcbn07XG5cbnV0aWwuc2VydmVyUmVxdWlyZShfX2Rpcm5hbWUgKyAnL1JhY2VyLnNlcnZlci5qcycpO1xuXG59KShyZXF1aXJlKFwiX19icm93c2VyaWZ5X3Byb2Nlc3NcIiksXCIvbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9saWJcIikiLCIoZnVuY3Rpb24ocHJvY2Vzcyl7aWYgKCFwcm9jZXNzLkV2ZW50RW1pdHRlcikgcHJvY2Vzcy5FdmVudEVtaXR0ZXIgPSBmdW5jdGlvbiAoKSB7fTtcblxudmFyIEV2ZW50RW1pdHRlciA9IGV4cG9ydHMuRXZlbnRFbWl0dGVyID0gcHJvY2Vzcy5FdmVudEVtaXR0ZXI7XG52YXIgaXNBcnJheSA9IHR5cGVvZiBBcnJheS5pc0FycmF5ID09PSAnZnVuY3Rpb24nXG4gICAgPyBBcnJheS5pc0FycmF5XG4gICAgOiBmdW5jdGlvbiAoeHMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgICB9XG47XG5mdW5jdGlvbiBpbmRleE9mICh4cywgeCkge1xuICAgIGlmICh4cy5pbmRleE9mKSByZXR1cm4geHMuaW5kZXhPZih4KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh4ID09PSB4c1tpXSkgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhblxuLy8gMTAgbGlzdGVuZXJzIGFyZSBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoXG4vLyBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbi8vXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIXRoaXMuX2V2ZW50cykgdGhpcy5fZXZlbnRzID0ge307XG4gIHRoaXMuX2V2ZW50cy5tYXhMaXN0ZW5lcnMgPSBuO1xufTtcblxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc0FycmF5KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKVxuICAgIHtcbiAgICAgIGlmIChhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBhcmd1bWVudHNbMV07IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmNhdWdodCwgdW5zcGVjaWZpZWQgJ2Vycm9yJyBldmVudC5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpIHJldHVybiBmYWxzZTtcbiAgdmFyIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGlmICghaGFuZGxlcikgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PSAnZnVuY3Rpb24nKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmIChpc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgdmFyIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8vIEV2ZW50RW1pdHRlciBpcyBkZWZpbmVkIGluIHNyYy9ub2RlX2V2ZW50cy5jY1xuLy8gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0KCkgaXMgYWxzbyBkZWZpbmVkIHRoZXJlLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2YgbGlzdGVuZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZExpc3RlbmVyIG9ubHkgdGFrZXMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XG4gIH1cblxuICBpZiAoIXRoaXMuX2V2ZW50cykgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PSBcIm5ld0xpc3RlbmVyc1wiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lcnNcIi5cbiAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodGhpcy5fZXZlbnRzW3R5cGVdKSkge1xuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICAgIHZhciBtO1xuICAgICAgaWYgKHRoaXMuX2V2ZW50cy5tYXhMaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtID0gdGhpcy5fZXZlbnRzLm1heExpc3RlbmVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG0gPSBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgICAgfVxuXG4gICAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5vbih0eXBlLCBmdW5jdGlvbiBnKCkge1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG4gICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBsaXN0ZW5lcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVtb3ZlTGlzdGVuZXIgb25seSB0YWtlcyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIC8vIGRvZXMgbm90IHVzZSBsaXN0ZW5lcnMoKSwgc28gbm8gc2lkZSBlZmZlY3Qgb2YgY3JlYXRpbmcgX2V2ZW50c1t0eXBlXVxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKSByZXR1cm4gdGhpcztcblxuICB2YXIgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNBcnJheShsaXN0KSkge1xuICAgIHZhciBpID0gaW5kZXhPZihsaXN0LCBsaXN0ZW5lcik7XG4gICAgaWYgKGkgPCAwKSByZXR1cm4gdGhpcztcbiAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICBpZiAobGlzdC5sZW5ndGggPT0gMClcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIH0gZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdID09PSBsaXN0ZW5lcikge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZG9lcyBub3QgdXNlIGxpc3RlbmVycygpLCBzbyBubyBzaWRlIGVmZmVjdCBvZiBjcmVhdGluZyBfZXZlbnRzW3R5cGVdXG4gIGlmICh0eXBlICYmIHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbdHlwZV0pIHRoaXMuX2V2ZW50c1t0eXBlXSA9IG51bGw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSB7fTtcbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFtdO1xuICBpZiAoIWlzQXJyYXkodGhpcy5fZXZlbnRzW3R5cGVdKSkge1xuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICB9XG4gIHJldHVybiB0aGlzLl9ldmVudHNbdHlwZV07XG59O1xuXG59KShyZXF1aXJlKFwiX19icm93c2VyaWZ5X3Byb2Nlc3NcIikpIiwidmFyIGFwcCA9IHJlcXVpcmUoJ2RlcmJ5JylcbiAgLmNyZWF0ZUFwcChtb2R1bGUpXG4gIC51c2UocmVxdWlyZSgnLi4vLi4vdWknKSlcbiAgLnVzZShyZXF1aXJlKCdkZXJieS11aS1naXRodWItYnV0dG9ucycpKTtcblxucmVxdWlyZSgnLi9jb250cm9sbGVyRm5zJykoYXBwKTtcbnJlcXVpcmUoJy4vZXZlbnRzJykoYXBwKTtcbnJlcXVpcmUoJy4vdXNlcicpKGFwcCk7XG5yZXF1aXJlKCcuL3JvdXRlcycpKGFwcCk7XG5yZXF1aXJlKCcuL3ZpZXdGbnMnKShhcHApOyIsIihmdW5jdGlvbihfX2ZpbGVuYW1lKXt2YXIgY29uZmlnID0ge1xuICBmaWxlbmFtZTogX19maWxlbmFtZSxcbiAgc2NyaXB0czoge1xuICAgIGNvbm5lY3Rpb25BbGVydDogcmVxdWlyZSgnLi9jb25uZWN0aW9uQWxlcnQnKVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcHAsIG9wdGlvbnMpIHtcbiAgYXBwLmNyZWF0ZUxpYnJhcnkoY29uZmlnLCBvcHRpb25zKTtcbn07XG59KShcIi91aS9pbmRleC5qc1wiKSIsIihmdW5jdGlvbigpe1xuZnVuY3Rpb24gZSgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICB9XG59XG5mdW5jdGlvbiBtKGEpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGIpIHtcbiAgICB0aGlzW2FdID0gYlxuICB9XG59XG5mdW5jdGlvbiBhYShhKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpc1thXVxuICB9XG59XG5mdW5jdGlvbiBiYShhKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYVxuICB9XG59XG52YXIgcCwgY2EgPSBjYSB8fCB7fSwgcSA9IHRoaXM7XG5mdW5jdGlvbiBkYShhKSB7XG4gIGEgPSBhLnNwbGl0KFwiLlwiKTtcbiAgZm9yKHZhciBiID0gcSwgYztjID0gYS5zaGlmdCgpOykge1xuICAgIGlmKG51bGwgIT0gYltjXSkge1xuICAgICAgYiA9IGJbY11cbiAgICB9ZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuICByZXR1cm4gYlxufVxuZnVuY3Rpb24gZWEoKSB7XG59XG5mdW5jdGlvbiBmYShhKSB7XG4gIHZhciBiID0gdHlwZW9mIGE7XG4gIGlmKFwib2JqZWN0XCIgPT0gYikge1xuICAgIGlmKGEpIHtcbiAgICAgIGlmKGEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICByZXR1cm5cImFycmF5XCJcbiAgICAgIH1cbiAgICAgIGlmKGEgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJcbiAgICAgIH1cbiAgICAgIHZhciBjID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpO1xuICAgICAgaWYoXCJbb2JqZWN0IFdpbmRvd11cIiA9PSBjKSB7XG4gICAgICAgIHJldHVyblwib2JqZWN0XCJcbiAgICAgIH1cbiAgICAgIGlmKFwiW29iamVjdCBBcnJheV1cIiA9PSBjIHx8IFwibnVtYmVyXCIgPT0gdHlwZW9mIGEubGVuZ3RoICYmIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGEuc3BsaWNlICYmIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGEucHJvcGVydHlJc0VudW1lcmFibGUgJiYgIWEucHJvcGVydHlJc0VudW1lcmFibGUoXCJzcGxpY2VcIikpIHtcbiAgICAgICAgcmV0dXJuXCJhcnJheVwiXG4gICAgICB9XG4gICAgICBpZihcIltvYmplY3QgRnVuY3Rpb25dXCIgPT0gYyB8fCBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBhLmNhbGwgJiYgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgYS5wcm9wZXJ0eUlzRW51bWVyYWJsZSAmJiAhYS5wcm9wZXJ0eUlzRW51bWVyYWJsZShcImNhbGxcIikpIHtcbiAgICAgICAgcmV0dXJuXCJmdW5jdGlvblwiXG4gICAgICB9XG4gICAgfWVsc2Uge1xuICAgICAgcmV0dXJuXCJudWxsXCJcbiAgICB9XG4gIH1lbHNlIHtcbiAgICBpZihcImZ1bmN0aW9uXCIgPT0gYiAmJiBcInVuZGVmaW5lZFwiID09IHR5cGVvZiBhLmNhbGwpIHtcbiAgICAgIHJldHVyblwib2JqZWN0XCJcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJcbn1cbmZ1bmN0aW9uIHMoYSkge1xuICByZXR1cm5cImFycmF5XCIgPT0gZmEoYSlcbn1cbmZ1bmN0aW9uIGdhKGEpIHtcbiAgdmFyIGIgPSBmYShhKTtcbiAgcmV0dXJuXCJhcnJheVwiID09IGIgfHwgXCJvYmplY3RcIiA9PSBiICYmIFwibnVtYmVyXCIgPT0gdHlwZW9mIGEubGVuZ3RoXG59XG5mdW5jdGlvbiB1KGEpIHtcbiAgcmV0dXJuXCJzdHJpbmdcIiA9PSB0eXBlb2YgYVxufVxuZnVuY3Rpb24gaGEoYSkge1xuICByZXR1cm5cImZ1bmN0aW9uXCIgPT0gZmEoYSlcbn1cbmZ1bmN0aW9uIHYoYSkge1xuICByZXR1cm4gYVtpYV0gfHwgKGFbaWFdID0gKytqYSlcbn1cbnZhciBpYSA9IFwiY2xvc3VyZV91aWRfXCIgKyAoMUU5ICogTWF0aC5yYW5kb20oKSA+Pj4gMCksIGphID0gMDtcbmZ1bmN0aW9uIGthKGEsIGIsIGMpIHtcbiAgcmV0dXJuIGEuY2FsbC5hcHBseShhLmJpbmQsIGFyZ3VtZW50cylcbn1cbmZ1bmN0aW9uIGxhKGEsIGIsIGMpIHtcbiAgaWYoIWEpIHtcbiAgICB0aHJvdyBFcnJvcigpO1xuICB9XG4gIGlmKDIgPCBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdmFyIGQgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIEFycmF5LnByb3RvdHlwZS51bnNoaWZ0LmFwcGx5KGMsIGQpO1xuICAgICAgcmV0dXJuIGEuYXBwbHkoYiwgYylcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhLmFwcGx5KGIsIGFyZ3VtZW50cylcbiAgfVxufVxuZnVuY3Rpb24gdyhhLCBiLCBjKSB7XG4gIHcgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCAmJiAtMSAhPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC50b1N0cmluZygpLmluZGV4T2YoXCJuYXRpdmUgY29kZVwiKSA/IGthIDogbGE7XG4gIHJldHVybiB3LmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbn1cbnZhciB4ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7XG4gIHJldHVybituZXcgRGF0ZVxufTtcbmZ1bmN0aW9uIHkoYSwgYikge1xuICBmdW5jdGlvbiBjKCkge1xuICB9XG4gIGMucHJvdG90eXBlID0gYi5wcm90b3R5cGU7XG4gIGEucmEgPSBiLnByb3RvdHlwZTtcbiAgYS5wcm90b3R5cGUgPSBuZXcgY1xufVxuO2Z1bmN0aW9uIG1hKGEsIGIpIHtcbiAgZm9yKHZhciBjID0gMTtjIDwgYXJndW1lbnRzLmxlbmd0aDtjKyspIHtcbiAgICB2YXIgZCA9IFN0cmluZyhhcmd1bWVudHNbY10pLnJlcGxhY2UoL1xcJC9nLCBcIiQkJCRcIik7XG4gICAgYSA9IGEucmVwbGFjZSgvXFwlcy8sIGQpXG4gIH1cbiAgcmV0dXJuIGFcbn1cbmZ1bmN0aW9uIG5hKGEpIHtcbiAgaWYoIW9hLnRlc3QoYSkpIHtcbiAgICByZXR1cm4gYVxuICB9XG4gIC0xICE9IGEuaW5kZXhPZihcIiZcIikgJiYgKGEgPSBhLnJlcGxhY2UocGEsIFwiJmFtcDtcIikpO1xuICAtMSAhPSBhLmluZGV4T2YoXCI8XCIpICYmIChhID0gYS5yZXBsYWNlKHFhLCBcIiZsdDtcIikpO1xuICAtMSAhPSBhLmluZGV4T2YoXCI+XCIpICYmIChhID0gYS5yZXBsYWNlKHJhLCBcIiZndDtcIikpO1xuICAtMSAhPSBhLmluZGV4T2YoJ1wiJykgJiYgKGEgPSBhLnJlcGxhY2Uoc2EsIFwiJnF1b3Q7XCIpKTtcbiAgcmV0dXJuIGFcbn1cbnZhciBwYSA9IC8mL2csIHFhID0gLzwvZywgcmEgPSAvPi9nLCBzYSA9IC9cXFwiL2csIG9hID0gL1smPD5cXFwiXS87XG52YXIgeiwgdGEsIHVhLCB2YTtcbmZ1bmN0aW9uIHdhKCkge1xuICByZXR1cm4gcS5uYXZpZ2F0b3IgPyBxLm5hdmlnYXRvci51c2VyQWdlbnQgOiBudWxsXG59XG52YSA9IHVhID0gdGEgPSB6ID0gITE7XG52YXIgeGE7XG5pZih4YSA9IHdhKCkpIHtcbiAgdmFyIHlhID0gcS5uYXZpZ2F0b3I7XG4gIHogPSAwID09IHhhLmluZGV4T2YoXCJPcGVyYVwiKTtcbiAgdGEgPSAheiAmJiAtMSAhPSB4YS5pbmRleE9mKFwiTVNJRVwiKTtcbiAgdWEgPSAheiAmJiAtMSAhPSB4YS5pbmRleE9mKFwiV2ViS2l0XCIpO1xuICB2YSA9ICF6ICYmICF1YSAmJiBcIkdlY2tvXCIgPT0geWEucHJvZHVjdFxufVxudmFyIHphID0geiwgQSA9IHRhLCBBYSA9IHZhLCBCID0gdWEsIEJhID0gcS5uYXZpZ2F0b3IsIENhID0gLTEgIT0gKEJhICYmIEJhLnBsYXRmb3JtIHx8IFwiXCIpLmluZGV4T2YoXCJNYWNcIik7XG5mdW5jdGlvbiBEYSgpIHtcbiAgdmFyIGEgPSBxLmRvY3VtZW50O1xuICByZXR1cm4gYSA/IGEuZG9jdW1lbnRNb2RlIDogdm9pZCAwXG59XG52YXIgRWE7XG5hOiB7XG4gIHZhciBGYSA9IFwiXCIsIEdhO1xuICBpZih6YSAmJiBxLm9wZXJhKSB7XG4gICAgdmFyIEhhID0gcS5vcGVyYS52ZXJzaW9uLCBGYSA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgSGEgPyBIYSgpIDogSGFcbiAgfWVsc2Uge1xuICAgIGlmKEFhID8gR2EgPSAvcnZcXDooW15cXCk7XSspKFxcKXw7KS8gOiBBID8gR2EgPSAvTVNJRVxccysoW15cXCk7XSspKFxcKXw7KS8gOiBCICYmIChHYSA9IC9XZWJLaXRcXC8oXFxTKykvKSwgR2EpIHtcbiAgICAgIHZhciBJYSA9IEdhLmV4ZWMod2EoKSksIEZhID0gSWEgPyBJYVsxXSA6IFwiXCJcbiAgICB9XG4gIH1cbiAgaWYoQSkge1xuICAgIHZhciBKYSA9IERhKCk7XG4gICAgaWYoSmEgPiBwYXJzZUZsb2F0KEZhKSkge1xuICAgICAgRWEgPSBTdHJpbmcoSmEpO1xuICAgICAgYnJlYWsgYVxuICAgIH1cbiAgfVxuICBFYSA9IEZhXG59XG52YXIgS2EgPSB7fTtcbmZ1bmN0aW9uIEMoYSkge1xuICB2YXIgYjtcbiAgaWYoIShiID0gS2FbYV0pKSB7XG4gICAgYiA9IDA7XG4gICAgZm9yKHZhciBjID0gU3RyaW5nKEVhKS5yZXBsYWNlKC9eW1xcc1xceGEwXSt8W1xcc1xceGEwXSskL2csIFwiXCIpLnNwbGl0KFwiLlwiKSwgZCA9IFN0cmluZyhhKS5yZXBsYWNlKC9eW1xcc1xceGEwXSt8W1xcc1xceGEwXSskL2csIFwiXCIpLnNwbGl0KFwiLlwiKSwgZiA9IE1hdGgubWF4KGMubGVuZ3RoLCBkLmxlbmd0aCksIGcgPSAwOzAgPT0gYiAmJiBnIDwgZjtnKyspIHtcbiAgICAgIHZhciBoID0gY1tnXSB8fCBcIlwiLCBuID0gZFtnXSB8fCBcIlwiLCBrID0gUmVnRXhwKFwiKFxcXFxkKikoXFxcXEQqKVwiLCBcImdcIiksIHQgPSBSZWdFeHAoXCIoXFxcXGQqKShcXFxcRCopXCIsIFwiZ1wiKTtcbiAgICAgIGRvIHtcbiAgICAgICAgdmFyIGwgPSBrLmV4ZWMoaCkgfHwgW1wiXCIsIFwiXCIsIFwiXCJdLCByID0gdC5leGVjKG4pIHx8IFtcIlwiLCBcIlwiLCBcIlwiXTtcbiAgICAgICAgaWYoMCA9PSBsWzBdLmxlbmd0aCAmJiAwID09IHJbMF0ubGVuZ3RoKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBiID0gKCgwID09IGxbMV0ubGVuZ3RoID8gMCA6IHBhcnNlSW50KGxbMV0sIDEwKSkgPCAoMCA9PSByWzFdLmxlbmd0aCA/IDAgOiBwYXJzZUludChyWzFdLCAxMCkpID8gLTEgOiAoMCA9PSBsWzFdLmxlbmd0aCA/IDAgOiBwYXJzZUludChsWzFdLCAxMCkpID4gKDAgPT0gclsxXS5sZW5ndGggPyAwIDogcGFyc2VJbnQoclsxXSwgMTApKSA/IDEgOiAwKSB8fCAoKDAgPT0gbFsyXS5sZW5ndGgpIDwgKDAgPT0gclsyXS5sZW5ndGgpID8gLTEgOiAoMCA9PSBsWzJdLmxlbmd0aCkgPiAoMCA9PSByWzJdLmxlbmd0aCkgPyAxIDogMCkgfHwgKGxbMl0gPCByWzJdID8gLTEgOiBsWzJdID4gclsyXSA/IDEgOiAwKVxuICAgICAgfXdoaWxlKDAgPT0gYilcbiAgICB9XG4gICAgYiA9IEthW2FdID0gMCA8PSBiXG4gIH1cbiAgcmV0dXJuIGJcbn1cbnZhciBMYSA9IHEuZG9jdW1lbnQsIE1hID0gTGEgJiYgQSA/IERhKCkgfHwgKFwiQ1NTMUNvbXBhdFwiID09IExhLmNvbXBhdE1vZGUgPyBwYXJzZUludChFYSwgMTApIDogNSkgOiB2b2lkIDA7XG5mdW5jdGlvbiBOYShhKSB7XG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID8gRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgTmEpIDogdGhpcy5zdGFjayA9IEVycm9yKCkuc3RhY2sgfHwgXCJcIjtcbiAgYSAmJiAodGhpcy5tZXNzYWdlID0gU3RyaW5nKGEpKVxufVxueShOYSwgRXJyb3IpO1xuTmEucHJvdG90eXBlLm5hbWUgPSBcIkN1c3RvbUVycm9yXCI7XG5mdW5jdGlvbiBPYShhLCBiKSB7XG4gIGIudW5zaGlmdChhKTtcbiAgTmEuY2FsbCh0aGlzLCBtYS5hcHBseShudWxsLCBiKSk7XG4gIGIuc2hpZnQoKTtcbiAgdGhpcy5KYyA9IGFcbn1cbnkoT2EsIE5hKTtcbk9hLnByb3RvdHlwZS5uYW1lID0gXCJBc3NlcnRpb25FcnJvclwiO1xuZnVuY3Rpb24gUGEoYSwgYikge1xuICB0aHJvdyBuZXcgT2EoXCJGYWlsdXJlXCIgKyAoYSA/IFwiOiBcIiArIGEgOiBcIlwiKSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG59XG47dmFyIFFhID0gUmVnRXhwKFwiXig/OihbXjovPyMuXSspOik/KD86Ly8oPzooW14vPyNdKilAKT8oW14vIz9dKj8pKD86OihbMC05XSspKT8oPz1bLyM/XXwkKSk/KFtePyNdKyk/KD86XFxcXD8oW14jXSopKT8oPzojKC4qKSk/JFwiKTtcbmZ1bmN0aW9uIFJhKGEpIHtcbiAgdmFyIGIgPSBTYSwgYztcbiAgZm9yKGMgaW4gYikge1xuICAgIGEuY2FsbCh2b2lkIDAsIGJbY10sIGMsIGIpXG4gIH1cbn1cbmZ1bmN0aW9uIFRhKGEpIHtcbiAgdmFyIGIgPSBbXSwgYyA9IDAsIGQ7XG4gIGZvcihkIGluIGEpIHtcbiAgICBiW2MrK10gPSBhW2RdXG4gIH1cbiAgcmV0dXJuIGJcbn1cbmZ1bmN0aW9uIFVhKGEpIHtcbiAgdmFyIGIgPSBbXSwgYyA9IDAsIGQ7XG4gIGZvcihkIGluIGEpIHtcbiAgICBiW2MrK10gPSBkXG4gIH1cbiAgcmV0dXJuIGJcbn1cbnZhciBWYSA9IFwiY29uc3RydWN0b3IgaGFzT3duUHJvcGVydHkgaXNQcm90b3R5cGVPZiBwcm9wZXJ0eUlzRW51bWVyYWJsZSB0b0xvY2FsZVN0cmluZyB0b1N0cmluZyB2YWx1ZU9mXCIuc3BsaXQoXCIgXCIpO1xuZnVuY3Rpb24gV2EoYSwgYikge1xuICBmb3IodmFyIGMsIGQsIGYgPSAxO2YgPCBhcmd1bWVudHMubGVuZ3RoO2YrKykge1xuICAgIGQgPSBhcmd1bWVudHNbZl07XG4gICAgZm9yKGMgaW4gZCkge1xuICAgICAgYVtjXSA9IGRbY11cbiAgICB9XG4gICAgZm9yKHZhciBnID0gMDtnIDwgVmEubGVuZ3RoO2crKykge1xuICAgICAgYyA9IFZhW2ddLCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZCwgYykgJiYgKGFbY10gPSBkW2NdKVxuICAgIH1cbiAgfVxufVxuO3ZhciBEID0gQXJyYXkucHJvdG90eXBlLCBYYSA9IEQuaW5kZXhPZiA/IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgcmV0dXJuIEQuaW5kZXhPZi5jYWxsKGEsIGIsIGMpXG59IDogZnVuY3Rpb24oYSwgYiwgYykge1xuICBjID0gbnVsbCA9PSBjID8gMCA6IDAgPiBjID8gTWF0aC5tYXgoMCwgYS5sZW5ndGggKyBjKSA6IGM7XG4gIGlmKHUoYSkpIHtcbiAgICByZXR1cm4gdShiKSAmJiAxID09IGIubGVuZ3RoID8gYS5pbmRleE9mKGIsIGMpIDogLTFcbiAgfVxuICBmb3IoO2MgPCBhLmxlbmd0aDtjKyspIHtcbiAgICBpZihjIGluIGEgJiYgYVtjXSA9PT0gYikge1xuICAgICAgcmV0dXJuIGNcbiAgICB9XG4gIH1cbiAgcmV0dXJuLTFcbn0sIFlhID0gRC5mb3JFYWNoID8gZnVuY3Rpb24oYSwgYiwgYykge1xuICBELmZvckVhY2guY2FsbChhLCBiLCBjKVxufSA6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgZm9yKHZhciBkID0gYS5sZW5ndGgsIGYgPSB1KGEpID8gYS5zcGxpdChcIlwiKSA6IGEsIGcgPSAwO2cgPCBkO2crKykge1xuICAgIGcgaW4gZiAmJiBiLmNhbGwoYywgZltnXSwgZywgYSlcbiAgfVxufTtcbmZ1bmN0aW9uIFphKGEpIHtcbiAgcmV0dXJuIEQuY29uY2F0LmFwcGx5KEQsIGFyZ3VtZW50cylcbn1cbmZ1bmN0aW9uICRhKGEpIHtcbiAgdmFyIGIgPSBhLmxlbmd0aDtcbiAgaWYoMCA8IGIpIHtcbiAgICBmb3IodmFyIGMgPSBBcnJheShiKSwgZCA9IDA7ZCA8IGI7ZCsrKSB7XG4gICAgICBjW2RdID0gYVtkXVxuICAgIH1cbiAgICByZXR1cm4gY1xuICB9XG4gIHJldHVybltdXG59XG47ZnVuY3Rpb24gYWIoYSkge1xuICBpZihcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGEuTikge1xuICAgIHJldHVybiBhLk4oKVxuICB9XG4gIGlmKHUoYSkpIHtcbiAgICByZXR1cm4gYS5zcGxpdChcIlwiKVxuICB9XG4gIGlmKGdhKGEpKSB7XG4gICAgZm9yKHZhciBiID0gW10sIGMgPSBhLmxlbmd0aCwgZCA9IDA7ZCA8IGM7ZCsrKSB7XG4gICAgICBiLnB1c2goYVtkXSlcbiAgICB9XG4gICAgcmV0dXJuIGJcbiAgfVxuICByZXR1cm4gVGEoYSlcbn1cbmZ1bmN0aW9uIEUoYSwgYiwgYykge1xuICBpZihcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGEuZm9yRWFjaCkge1xuICAgIGEuZm9yRWFjaChiLCBjKVxuICB9ZWxzZSB7XG4gICAgaWYoZ2EoYSkgfHwgdShhKSkge1xuICAgICAgWWEoYSwgYiwgYylcbiAgICB9ZWxzZSB7XG4gICAgICB2YXIgZDtcbiAgICAgIGlmKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgYS5rYSkge1xuICAgICAgICBkID0gYS5rYSgpXG4gICAgICB9ZWxzZSB7XG4gICAgICAgIGlmKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgYS5OKSB7XG4gICAgICAgICAgaWYoZ2EoYSkgfHwgdShhKSkge1xuICAgICAgICAgICAgZCA9IFtdO1xuICAgICAgICAgICAgZm9yKHZhciBmID0gYS5sZW5ndGgsIGcgPSAwO2cgPCBmO2crKykge1xuICAgICAgICAgICAgICBkLnB1c2goZylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICBkID0gVWEoYSlcbiAgICAgICAgICB9XG4gICAgICAgIH1lbHNlIHtcbiAgICAgICAgICBkID0gdm9pZCAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvcih2YXIgZiA9IGFiKGEpLCBnID0gZi5sZW5ndGgsIGggPSAwO2ggPCBnO2grKykge1xuICAgICAgICBiLmNhbGwoYywgZltoXSwgZCAmJiBkW2hdLCBhKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuO2Z1bmN0aW9uIGJiKGEsIGIpIHtcbiAgdGhpcy5PID0ge307XG4gIHRoaXMuaiA9IFtdO1xuICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIGlmKDEgPCBjKSB7XG4gICAgaWYoYyAlIDIpIHtcbiAgICAgIHRocm93IEVycm9yKFwiVW5ldmVuIG51bWJlciBvZiBhcmd1bWVudHNcIik7XG4gICAgfVxuICAgIGZvcih2YXIgZCA9IDA7ZCA8IGM7ZCArPSAyKSB7XG4gICAgICB0aGlzLnNldChhcmd1bWVudHNbZF0sIGFyZ3VtZW50c1tkICsgMV0pXG4gICAgfVxuICB9ZWxzZSB7XG4gICAgaWYoYSkge1xuICAgICAgYSBpbnN0YW5jZW9mIGJiID8gKGMgPSBhLmthKCksIGQgPSBhLk4oKSkgOiAoYyA9IFVhKGEpLCBkID0gVGEoYSkpO1xuICAgICAgZm9yKHZhciBmID0gMDtmIDwgYy5sZW5ndGg7ZisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGNbZl0sIGRbZl0pXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5wID0gYmIucHJvdG90eXBlO1xucC5mID0gMDtcbnAuYmMgPSAwO1xucC5OID0gZnVuY3Rpb24oKSB7XG4gIGNiKHRoaXMpO1xuICBmb3IodmFyIGEgPSBbXSwgYiA9IDA7YiA8IHRoaXMuai5sZW5ndGg7YisrKSB7XG4gICAgYS5wdXNoKHRoaXMuT1t0aGlzLmpbYl1dKVxuICB9XG4gIHJldHVybiBhXG59O1xucC5rYSA9IGZ1bmN0aW9uKCkge1xuICBjYih0aGlzKTtcbiAgcmV0dXJuIHRoaXMuai5jb25jYXQoKVxufTtcbnAuaWEgPSBmdW5jdGlvbihhKSB7XG4gIHJldHVybiBkYih0aGlzLk8sIGEpXG59O1xucC5yZW1vdmUgPSBmdW5jdGlvbihhKSB7XG4gIHJldHVybiBkYih0aGlzLk8sIGEpID8gKGRlbGV0ZSB0aGlzLk9bYV0sIHRoaXMuZi0tLCB0aGlzLmJjKyssIHRoaXMuai5sZW5ndGggPiAyICogdGhpcy5mICYmIGNiKHRoaXMpLCAhMCkgOiAhMVxufTtcbmZ1bmN0aW9uIGNiKGEpIHtcbiAgaWYoYS5mICE9IGEuai5sZW5ndGgpIHtcbiAgICBmb3IodmFyIGIgPSAwLCBjID0gMDtiIDwgYS5qLmxlbmd0aDspIHtcbiAgICAgIHZhciBkID0gYS5qW2JdO1xuICAgICAgZGIoYS5PLCBkKSAmJiAoYS5qW2MrK10gPSBkKTtcbiAgICAgIGIrK1xuICAgIH1cbiAgICBhLmoubGVuZ3RoID0gY1xuICB9XG4gIGlmKGEuZiAhPSBhLmoubGVuZ3RoKSB7XG4gICAgZm9yKHZhciBmID0ge30sIGMgPSBiID0gMDtiIDwgYS5qLmxlbmd0aDspIHtcbiAgICAgIGQgPSBhLmpbYl0sIGRiKGYsIGQpIHx8IChhLmpbYysrXSA9IGQsIGZbZF0gPSAxKSwgYisrXG4gICAgfVxuICAgIGEuai5sZW5ndGggPSBjXG4gIH1cbn1cbnAuZ2V0ID0gZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gZGIodGhpcy5PLCBhKSA/IHRoaXMuT1thXSA6IGJcbn07XG5wLnNldCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgZGIodGhpcy5PLCBhKSB8fCAodGhpcy5mKyssIHRoaXMuai5wdXNoKGEpLCB0aGlzLmJjKyspO1xuICB0aGlzLk9bYV0gPSBiXG59O1xucC5uID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgYmIodGhpcylcbn07XG5mdW5jdGlvbiBkYihhLCBiKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgYilcbn1cbjtmdW5jdGlvbiBGKGEsIGIpIHtcbiAgdmFyIGM7XG4gIGlmKGEgaW5zdGFuY2VvZiBGKSB7XG4gICAgdGhpcy5EID0gdm9pZCAwICE9PSBiID8gYiA6IGEuRCwgZWIodGhpcywgYS5xYSksIGMgPSBhLmFiLCBIKHRoaXMpLCB0aGlzLmFiID0gYywgZmIodGhpcywgYS5qYSksIGdiKHRoaXMsIGEuQmEpLCBoYih0aGlzLCBhLkgpLCBpYih0aGlzLCBhLlIubigpKSwgYyA9IGEuTWEsIEgodGhpcyksIHRoaXMuTWEgPSBjXG4gIH1lbHNlIHtcbiAgICBpZihhICYmIChjID0gU3RyaW5nKGEpLm1hdGNoKFFhKSkpIHtcbiAgICAgIHRoaXMuRCA9ICEhYjtcbiAgICAgIGViKHRoaXMsIGNbMV0gfHwgXCJcIiwgITApO1xuICAgICAgdmFyIGQgPSBjWzJdIHx8IFwiXCI7XG4gICAgICBIKHRoaXMpO1xuICAgICAgdGhpcy5hYiA9IGQgPyBkZWNvZGVVUklDb21wb25lbnQoZCkgOiBcIlwiO1xuICAgICAgZmIodGhpcywgY1szXSB8fCBcIlwiLCAhMCk7XG4gICAgICBnYih0aGlzLCBjWzRdKTtcbiAgICAgIGhiKHRoaXMsIGNbNV0gfHwgXCJcIiwgITApO1xuICAgICAgaWIodGhpcywgY1s2XSB8fCBcIlwiLCAhMCk7XG4gICAgICBjID0gY1s3XSB8fCBcIlwiO1xuICAgICAgSCh0aGlzKTtcbiAgICAgIHRoaXMuTWEgPSBjID8gZGVjb2RlVVJJQ29tcG9uZW50KGMpIDogXCJcIlxuICAgIH1lbHNlIHtcbiAgICAgIHRoaXMuRCA9ICEhYiwgdGhpcy5SID0gbmV3IGpiKG51bGwsIDAsIHRoaXMuRClcbiAgICB9XG4gIH1cbn1cbnAgPSBGLnByb3RvdHlwZTtcbnAucWEgPSBcIlwiO1xucC5hYiA9IFwiXCI7XG5wLmphID0gXCJcIjtcbnAuQmEgPSBudWxsO1xucC5IID0gXCJcIjtcbnAuTWEgPSBcIlwiO1xucC5tYyA9ICExO1xucC5EID0gITE7XG5wLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhID0gW10sIGIgPSB0aGlzLnFhO1xuICBiICYmIGEucHVzaChrYihiLCBsYiksIFwiOlwiKTtcbiAgaWYoYiA9IHRoaXMuamEpIHtcbiAgICBhLnB1c2goXCIvL1wiKTtcbiAgICB2YXIgYyA9IHRoaXMuYWI7XG4gICAgYyAmJiBhLnB1c2goa2IoYywgbGIpLCBcIkBcIik7XG4gICAgYS5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYikpKTtcbiAgICBiID0gdGhpcy5CYTtcbiAgICBudWxsICE9IGIgJiYgYS5wdXNoKFwiOlwiLCBTdHJpbmcoYikpXG4gIH1cbiAgaWYoYiA9IHRoaXMuSCkge1xuICAgIHRoaXMuamEgJiYgXCIvXCIgIT0gYi5jaGFyQXQoMCkgJiYgYS5wdXNoKFwiL1wiKSwgYS5wdXNoKGtiKGIsIFwiL1wiID09IGIuY2hhckF0KDApID8gbWIgOiBuYikpXG4gIH1cbiAgKGIgPSB0aGlzLlIudG9TdHJpbmcoKSkgJiYgYS5wdXNoKFwiP1wiLCBiKTtcbiAgKGIgPSB0aGlzLk1hKSAmJiBhLnB1c2goXCIjXCIsIGtiKGIsIG9iKSk7XG4gIHJldHVybiBhLmpvaW4oXCJcIilcbn07XG5wLm4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBGKHRoaXMpXG59O1xuZnVuY3Rpb24gZWIoYSwgYiwgYykge1xuICBIKGEpO1xuICBhLnFhID0gYyA/IGIgPyBkZWNvZGVVUklDb21wb25lbnQoYikgOiBcIlwiIDogYjtcbiAgYS5xYSAmJiAoYS5xYSA9IGEucWEucmVwbGFjZSgvOiQvLCBcIlwiKSlcbn1cbmZ1bmN0aW9uIGZiKGEsIGIsIGMpIHtcbiAgSChhKTtcbiAgYS5qYSA9IGMgPyBiID8gZGVjb2RlVVJJQ29tcG9uZW50KGIpIDogXCJcIiA6IGJcbn1cbmZ1bmN0aW9uIGdiKGEsIGIpIHtcbiAgSChhKTtcbiAgaWYoYikge1xuICAgIGIgPSBOdW1iZXIoYik7XG4gICAgaWYoaXNOYU4oYikgfHwgMCA+IGIpIHtcbiAgICAgIHRocm93IEVycm9yKFwiQmFkIHBvcnQgbnVtYmVyIFwiICsgYik7XG4gICAgfVxuICAgIGEuQmEgPSBiXG4gIH1lbHNlIHtcbiAgICBhLkJhID0gbnVsbFxuICB9XG59XG5mdW5jdGlvbiBoYihhLCBiLCBjKSB7XG4gIEgoYSk7XG4gIGEuSCA9IGMgPyBiID8gZGVjb2RlVVJJQ29tcG9uZW50KGIpIDogXCJcIiA6IGJcbn1cbmZ1bmN0aW9uIGliKGEsIGIsIGMpIHtcbiAgSChhKTtcbiAgYiBpbnN0YW5jZW9mIGpiID8gKGEuUiA9IGIsIGEuUi5xYihhLkQpKSA6IChjIHx8IChiID0ga2IoYiwgcGIpKSwgYS5SID0gbmV3IGpiKGIsIDAsIGEuRCkpXG59XG5mdW5jdGlvbiBJKGEsIGIsIGMpIHtcbiAgSChhKTtcbiAgYS5SLnNldChiLCBjKVxufVxuZnVuY3Rpb24gcWIoYSwgYiwgYykge1xuICBIKGEpO1xuICBzKGMpIHx8IChjID0gW1N0cmluZyhjKV0pO1xuICByYihhLlIsIGIsIGMpXG59XG5mdW5jdGlvbiBKKGEpIHtcbiAgSChhKTtcbiAgSShhLCBcInp4XCIsIE1hdGguZmxvb3IoMjE0NzQ4MzY0OCAqIE1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKDM2KSArIE1hdGguYWJzKE1hdGguZmxvb3IoMjE0NzQ4MzY0OCAqIE1hdGgucmFuZG9tKCkpIF4geCgpKS50b1N0cmluZygzNikpO1xuICByZXR1cm4gYVxufVxuZnVuY3Rpb24gSChhKSB7XG4gIGlmKGEubWMpIHtcbiAgICB0aHJvdyBFcnJvcihcIlRyaWVkIHRvIG1vZGlmeSBhIHJlYWQtb25seSBVcmlcIik7XG4gIH1cbn1cbnAucWIgPSBmdW5jdGlvbihhKSB7XG4gIHRoaXMuRCA9IGE7XG4gIHRoaXMuUiAmJiB0aGlzLlIucWIoYSk7XG4gIHJldHVybiB0aGlzXG59O1xuZnVuY3Rpb24gc2IoYSwgYiwgYywgZCkge1xuICB2YXIgZiA9IG5ldyBGKG51bGwsIHZvaWQgMCk7XG4gIGEgJiYgZWIoZiwgYSk7XG4gIGIgJiYgZmIoZiwgYik7XG4gIGMgJiYgZ2IoZiwgYyk7XG4gIGQgJiYgaGIoZiwgZCk7XG4gIHJldHVybiBmXG59XG5mdW5jdGlvbiBrYihhLCBiKSB7XG4gIHJldHVybiB1KGEpID8gZW5jb2RlVVJJKGEpLnJlcGxhY2UoYiwgdGIpIDogbnVsbFxufVxuZnVuY3Rpb24gdGIoYSkge1xuICBhID0gYS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm5cIiVcIiArIChhID4+IDQgJiAxNSkudG9TdHJpbmcoMTYpICsgKGEgJiAxNSkudG9TdHJpbmcoMTYpXG59XG52YXIgbGIgPSAvWyNcXC9cXD9AXS9nLCBuYiA9IC9bXFwjXFw/Ol0vZywgbWIgPSAvW1xcI1xcP10vZywgcGIgPSAvW1xcI1xcP0BdL2csIG9iID0gLyMvZztcbmZ1bmN0aW9uIGpiKGEsIGIsIGMpIHtcbiAgdGhpcy5DID0gYSB8fCBudWxsO1xuICB0aGlzLkQgPSAhIWNcbn1cbmZ1bmN0aW9uIEsoYSkge1xuICBpZighYS5pICYmIChhLmkgPSBuZXcgYmIsIGEuZiA9IDAsIGEuQykpIHtcbiAgICBmb3IodmFyIGIgPSBhLkMuc3BsaXQoXCImXCIpLCBjID0gMDtjIDwgYi5sZW5ndGg7YysrKSB7XG4gICAgICB2YXIgZCA9IGJbY10uaW5kZXhPZihcIj1cIiksIGYgPSBudWxsLCBnID0gbnVsbDtcbiAgICAgIDAgPD0gZCA/IChmID0gYltjXS5zdWJzdHJpbmcoMCwgZCksIGcgPSBiW2NdLnN1YnN0cmluZyhkICsgMSkpIDogZiA9IGJbY107XG4gICAgICBmID0gZGVjb2RlVVJJQ29tcG9uZW50KGYucmVwbGFjZSgvXFwrL2csIFwiIFwiKSk7XG4gICAgICBmID0gTChhLCBmKTtcbiAgICAgIGEuYWRkKGYsIGcgPyBkZWNvZGVVUklDb21wb25lbnQoZy5yZXBsYWNlKC9cXCsvZywgXCIgXCIpKSA6IFwiXCIpXG4gICAgfVxuICB9XG59XG5wID0gamIucHJvdG90eXBlO1xucC5pID0gbnVsbDtcbnAuZiA9IG51bGw7XG5wLmFkZCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgSyh0aGlzKTtcbiAgdGhpcy5DID0gbnVsbDtcbiAgYSA9IEwodGhpcywgYSk7XG4gIHZhciBjID0gdGhpcy5pLmdldChhKTtcbiAgYyB8fCB0aGlzLmkuc2V0KGEsIGMgPSBbXSk7XG4gIGMucHVzaChiKTtcbiAgdGhpcy5mKys7XG4gIHJldHVybiB0aGlzXG59O1xucC5yZW1vdmUgPSBmdW5jdGlvbihhKSB7XG4gIEsodGhpcyk7XG4gIGEgPSBMKHRoaXMsIGEpO1xuICByZXR1cm4gdGhpcy5pLmlhKGEpID8gKHRoaXMuQyA9IG51bGwsIHRoaXMuZiAtPSB0aGlzLmkuZ2V0KGEpLmxlbmd0aCwgdGhpcy5pLnJlbW92ZShhKSkgOiAhMVxufTtcbnAuaWEgPSBmdW5jdGlvbihhKSB7XG4gIEsodGhpcyk7XG4gIGEgPSBMKHRoaXMsIGEpO1xuICByZXR1cm4gdGhpcy5pLmlhKGEpXG59O1xucC5rYSA9IGZ1bmN0aW9uKCkge1xuICBLKHRoaXMpO1xuICBmb3IodmFyIGEgPSB0aGlzLmkuTigpLCBiID0gdGhpcy5pLmthKCksIGMgPSBbXSwgZCA9IDA7ZCA8IGIubGVuZ3RoO2QrKykge1xuICAgIGZvcih2YXIgZiA9IGFbZF0sIGcgPSAwO2cgPCBmLmxlbmd0aDtnKyspIHtcbiAgICAgIGMucHVzaChiW2RdKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY1xufTtcbnAuTiA9IGZ1bmN0aW9uKGEpIHtcbiAgSyh0aGlzKTtcbiAgdmFyIGIgPSBbXTtcbiAgaWYoYSkge1xuICAgIHRoaXMuaWEoYSkgJiYgKGIgPSBaYShiLCB0aGlzLmkuZ2V0KEwodGhpcywgYSkpKSlcbiAgfWVsc2Uge1xuICAgIGEgPSB0aGlzLmkuTigpO1xuICAgIGZvcih2YXIgYyA9IDA7YyA8IGEubGVuZ3RoO2MrKykge1xuICAgICAgYiA9IFphKGIsIGFbY10pXG4gICAgfVxuICB9XG4gIHJldHVybiBiXG59O1xucC5zZXQgPSBmdW5jdGlvbihhLCBiKSB7XG4gIEsodGhpcyk7XG4gIHRoaXMuQyA9IG51bGw7XG4gIGEgPSBMKHRoaXMsIGEpO1xuICB0aGlzLmlhKGEpICYmICh0aGlzLmYgLT0gdGhpcy5pLmdldChhKS5sZW5ndGgpO1xuICB0aGlzLmkuc2V0KGEsIFtiXSk7XG4gIHRoaXMuZisrO1xuICByZXR1cm4gdGhpc1xufTtcbnAuZ2V0ID0gZnVuY3Rpb24oYSwgYikge1xuICB2YXIgYyA9IGEgPyB0aGlzLk4oYSkgOiBbXTtcbiAgcmV0dXJuIDAgPCBjLmxlbmd0aCA/IFN0cmluZyhjWzBdKSA6IGJcbn07XG5mdW5jdGlvbiByYihhLCBiLCBjKSB7XG4gIGEucmVtb3ZlKGIpO1xuICAwIDwgYy5sZW5ndGggJiYgKGEuQyA9IG51bGwsIGEuaS5zZXQoTChhLCBiKSwgJGEoYykpLCBhLmYgKz0gYy5sZW5ndGgpXG59XG5wLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIGlmKHRoaXMuQykge1xuICAgIHJldHVybiB0aGlzLkNcbiAgfVxuICBpZighdGhpcy5pKSB7XG4gICAgcmV0dXJuXCJcIlxuICB9XG4gIGZvcih2YXIgYSA9IFtdLCBiID0gdGhpcy5pLmthKCksIGMgPSAwO2MgPCBiLmxlbmd0aDtjKyspIHtcbiAgICBmb3IodmFyIGQgPSBiW2NdLCBmID0gZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhkKSksIGQgPSB0aGlzLk4oZCksIGcgPSAwO2cgPCBkLmxlbmd0aDtnKyspIHtcbiAgICAgIHZhciBoID0gZjtcbiAgICAgIFwiXCIgIT09IGRbZ10gJiYgKGggKz0gXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGRbZ10pKSk7XG4gICAgICBhLnB1c2goaClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXMuQyA9IGEuam9pbihcIiZcIilcbn07XG5wLm4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGEgPSBuZXcgamI7XG4gIGEuQyA9IHRoaXMuQztcbiAgdGhpcy5pICYmIChhLmkgPSB0aGlzLmkubigpLCBhLmYgPSB0aGlzLmYpO1xuICByZXR1cm4gYVxufTtcbmZ1bmN0aW9uIEwoYSwgYikge1xuICB2YXIgYyA9IFN0cmluZyhiKTtcbiAgYS5EICYmIChjID0gYy50b0xvd2VyQ2FzZSgpKTtcbiAgcmV0dXJuIGNcbn1cbnAucWIgPSBmdW5jdGlvbihhKSB7XG4gIGEgJiYgIXRoaXMuRCAmJiAoSyh0aGlzKSwgdGhpcy5DID0gbnVsbCwgRSh0aGlzLmksIGZ1bmN0aW9uKGEsIGMpIHtcbiAgICB2YXIgZCA9IGMudG9Mb3dlckNhc2UoKTtcbiAgICBjICE9IGQgJiYgKHRoaXMucmVtb3ZlKGMpLCByYih0aGlzLCBkLCBhKSlcbiAgfSwgdGhpcykpO1xuICB0aGlzLkQgPSBhXG59O1xuZnVuY3Rpb24gdWIoKSB7XG59XG51Yi5wcm90b3R5cGUuR2EgPSBudWxsO1xudmFyIHZiO1xuZnVuY3Rpb24gd2IoKSB7XG59XG55KHdiLCB1Yik7XG5mdW5jdGlvbiB4YihhKSB7XG4gIHJldHVybihhID0geWIoYSkpID8gbmV3IEFjdGl2ZVhPYmplY3QoYSkgOiBuZXcgWE1MSHR0cFJlcXVlc3Rcbn1cbmZ1bmN0aW9uIHpiKGEpIHtcbiAgdmFyIGIgPSB7fTtcbiAgeWIoYSkgJiYgKGJbMF0gPSAhMCwgYlsxXSA9ICEwKTtcbiAgcmV0dXJuIGJcbn1cbmZ1bmN0aW9uIHliKGEpIHtcbiAgaWYoIWEuR2IgJiYgXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgJiYgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgQWN0aXZlWE9iamVjdCkge1xuICAgIGZvcih2YXIgYiA9IFtcIk1TWE1MMi5YTUxIVFRQLjYuMFwiLCBcIk1TWE1MMi5YTUxIVFRQLjMuMFwiLCBcIk1TWE1MMi5YTUxIVFRQXCIsIFwiTWljcm9zb2Z0LlhNTEhUVFBcIl0sIGMgPSAwO2MgPCBiLmxlbmd0aDtjKyspIHtcbiAgICAgIHZhciBkID0gYltjXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdChkKSwgYS5HYiA9IGRcbiAgICAgIH1jYXRjaChmKSB7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IEVycm9yKFwiQ291bGQgbm90IGNyZWF0ZSBBY3RpdmVYT2JqZWN0LiBBY3RpdmVYIG1pZ2h0IGJlIGRpc2FibGVkLCBvciBNU1hNTCBtaWdodCBub3QgYmUgaW5zdGFsbGVkXCIpO1xuICB9XG4gIHJldHVybiBhLkdiXG59XG52YiA9IG5ldyB3YjtcbmZ1bmN0aW9uIE0oKSB7XG4gIDAgIT0gQWIgJiYgKHRoaXMuR2MgPSBFcnJvcigpLnN0YWNrLCBCYlt2KHRoaXMpXSA9IHRoaXMpXG59XG52YXIgQWIgPSAwLCBCYiA9IHt9O1xuTS5wcm90b3R5cGUueWIgPSAhMTtcbk0ucHJvdG90eXBlLklhID0gZnVuY3Rpb24oKSB7XG4gIGlmKCF0aGlzLnliICYmICh0aGlzLnliID0gITAsIHRoaXMudSgpLCAwICE9IEFiKSkge1xuICAgIHZhciBhID0gdih0aGlzKTtcbiAgICBkZWxldGUgQmJbYV1cbiAgfVxufTtcbk0ucHJvdG90eXBlLnUgPSBmdW5jdGlvbigpIHtcbiAgaWYodGhpcy5OYikge1xuICAgIGZvcig7dGhpcy5OYi5sZW5ndGg7KSB7XG4gICAgICB0aGlzLk5iLnNoaWZ0KCkoKVxuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIE4oYSwgYikge1xuICB0aGlzLnR5cGUgPSBhO1xuICB0aGlzLmN1cnJlbnRUYXJnZXQgPSB0aGlzLnRhcmdldCA9IGJcbn1cbnAgPSBOLnByb3RvdHlwZTtcbnAudSA9IGUoKTtcbnAuSWEgPSBlKCk7XG5wLm5hID0gITE7XG5wLmRlZmF1bHRQcmV2ZW50ZWQgPSAhMTtcbnAuV2EgPSAhMDtcbnAucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gITA7XG4gIHRoaXMuV2EgPSAhMVxufTtcbnZhciBDYiA9IDA7XG5mdW5jdGlvbiBEYigpIHtcbn1cbnAgPSBEYi5wcm90b3R5cGU7XG5wLmtleSA9IDA7XG5wLmVhID0gITE7XG5wLkhhID0gITE7XG5wLk9hID0gZnVuY3Rpb24oYSwgYiwgYywgZCwgZiwgZykge1xuICBpZihoYShhKSkge1xuICAgIHRoaXMuSWIgPSAhMFxuICB9ZWxzZSB7XG4gICAgaWYoYSAmJiBhLmhhbmRsZUV2ZW50ICYmIGhhKGEuaGFuZGxlRXZlbnQpKSB7XG4gICAgICB0aGlzLkliID0gITFcbiAgICB9ZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgbGlzdGVuZXIgYXJndW1lbnRcIik7XG4gICAgfVxuICB9XG4gIHRoaXMuVyA9IGE7XG4gIHRoaXMuVWIgPSBiO1xuICB0aGlzLnNyYyA9IGM7XG4gIHRoaXMudHlwZSA9IGQ7XG4gIHRoaXMuY2FwdHVyZSA9ICEhZjtcbiAgdGhpcy5sYiA9IGc7XG4gIHRoaXMuSGEgPSAhMTtcbiAgdGhpcy5rZXkgPSArK0NiO1xuICB0aGlzLmVhID0gITFcbn07XG5wLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24oYSkge1xuICByZXR1cm4gdGhpcy5JYiA/IHRoaXMuVy5jYWxsKHRoaXMubGIgfHwgdGhpcy5zcmMsIGEpIDogdGhpcy5XLmhhbmRsZUV2ZW50LmNhbGwodGhpcy5XLCBhKVxufTtcbnZhciBFYiA9ICFBIHx8IEEgJiYgOSA8PSBNYSwgRmIgPSBBICYmICFDKFwiOVwiKTtcbiFCIHx8IEMoXCI1MjhcIik7XG5BYSAmJiBDKFwiMS45YlwiKSB8fCBBICYmIEMoXCI4XCIpIHx8IHphICYmIEMoXCI5LjVcIikgfHwgQiAmJiBDKFwiNTI4XCIpO1xuQWEgJiYgIUMoXCI4XCIpIHx8IEEgJiYgQyhcIjlcIik7XG5mdW5jdGlvbiBHYihhKSB7XG4gIEdiW1wiIFwiXShhKTtcbiAgcmV0dXJuIGFcbn1cbkdiW1wiIFwiXSA9IGVhO1xuZnVuY3Rpb24gSGIoYSwgYikge1xuICBhICYmIHRoaXMuT2EoYSwgYilcbn1cbnkoSGIsIE4pO1xucCA9IEhiLnByb3RvdHlwZTtcbnAudGFyZ2V0ID0gbnVsbDtcbnAucmVsYXRlZFRhcmdldCA9IG51bGw7XG5wLm9mZnNldFggPSAwO1xucC5vZmZzZXRZID0gMDtcbnAuY2xpZW50WCA9IDA7XG5wLmNsaWVudFkgPSAwO1xucC5zY3JlZW5YID0gMDtcbnAuc2NyZWVuWSA9IDA7XG5wLmJ1dHRvbiA9IDA7XG5wLmtleUNvZGUgPSAwO1xucC5jaGFyQ29kZSA9IDA7XG5wLmN0cmxLZXkgPSAhMTtcbnAuYWx0S2V5ID0gITE7XG5wLnNoaWZ0S2V5ID0gITE7XG5wLm1ldGFLZXkgPSAhMTtcbnAueWMgPSAhMTtcbnAuemIgPSBudWxsO1xucC5PYSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGMgPSB0aGlzLnR5cGUgPSBhLnR5cGU7XG4gIE4uY2FsbCh0aGlzLCBjKTtcbiAgdGhpcy50YXJnZXQgPSBhLnRhcmdldCB8fCBhLnNyY0VsZW1lbnQ7XG4gIHRoaXMuY3VycmVudFRhcmdldCA9IGI7XG4gIHZhciBkID0gYS5yZWxhdGVkVGFyZ2V0O1xuICBpZihkKSB7XG4gICAgaWYoQWEpIHtcbiAgICAgIHZhciBmO1xuICAgICAgYToge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEdiKGQubm9kZU5hbWUpO1xuICAgICAgICAgIGYgPSAhMDtcbiAgICAgICAgICBicmVhayBhXG4gICAgICAgIH1jYXRjaChnKSB7XG4gICAgICAgIH1cbiAgICAgICAgZiA9ICExXG4gICAgICB9XG4gICAgICBmIHx8IChkID0gbnVsbClcbiAgICB9XG4gIH1lbHNlIHtcbiAgICBcIm1vdXNlb3ZlclwiID09IGMgPyBkID0gYS5mcm9tRWxlbWVudCA6IFwibW91c2VvdXRcIiA9PSBjICYmIChkID0gYS50b0VsZW1lbnQpXG4gIH1cbiAgdGhpcy5yZWxhdGVkVGFyZ2V0ID0gZDtcbiAgdGhpcy5vZmZzZXRYID0gQiB8fCB2b2lkIDAgIT09IGEub2Zmc2V0WCA/IGEub2Zmc2V0WCA6IGEubGF5ZXJYO1xuICB0aGlzLm9mZnNldFkgPSBCIHx8IHZvaWQgMCAhPT0gYS5vZmZzZXRZID8gYS5vZmZzZXRZIDogYS5sYXllclk7XG4gIHRoaXMuY2xpZW50WCA9IHZvaWQgMCAhPT0gYS5jbGllbnRYID8gYS5jbGllbnRYIDogYS5wYWdlWDtcbiAgdGhpcy5jbGllbnRZID0gdm9pZCAwICE9PSBhLmNsaWVudFkgPyBhLmNsaWVudFkgOiBhLnBhZ2VZO1xuICB0aGlzLnNjcmVlblggPSBhLnNjcmVlblggfHwgMDtcbiAgdGhpcy5zY3JlZW5ZID0gYS5zY3JlZW5ZIHx8IDA7XG4gIHRoaXMuYnV0dG9uID0gYS5idXR0b247XG4gIHRoaXMua2V5Q29kZSA9IGEua2V5Q29kZSB8fCAwO1xuICB0aGlzLmNoYXJDb2RlID0gYS5jaGFyQ29kZSB8fCAoXCJrZXlwcmVzc1wiID09IGMgPyBhLmtleUNvZGUgOiAwKTtcbiAgdGhpcy5jdHJsS2V5ID0gYS5jdHJsS2V5O1xuICB0aGlzLmFsdEtleSA9IGEuYWx0S2V5O1xuICB0aGlzLnNoaWZ0S2V5ID0gYS5zaGlmdEtleTtcbiAgdGhpcy5tZXRhS2V5ID0gYS5tZXRhS2V5O1xuICB0aGlzLnljID0gQ2EgPyBhLm1ldGFLZXkgOiBhLmN0cmxLZXk7XG4gIHRoaXMuc3RhdGUgPSBhLnN0YXRlO1xuICB0aGlzLnpiID0gYTtcbiAgYS5kZWZhdWx0UHJldmVudGVkICYmIHRoaXMucHJldmVudERlZmF1bHQoKTtcbiAgZGVsZXRlIHRoaXMubmFcbn07XG5wLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gIEhiLnJhLnByZXZlbnREZWZhdWx0LmNhbGwodGhpcyk7XG4gIHZhciBhID0gdGhpcy56YjtcbiAgaWYoYS5wcmV2ZW50RGVmYXVsdCkge1xuICAgIGEucHJldmVudERlZmF1bHQoKVxuICB9ZWxzZSB7XG4gICAgaWYoYS5yZXR1cm5WYWx1ZSA9ICExLCBGYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYoYS5jdHJsS2V5IHx8IDExMiA8PSBhLmtleUNvZGUgJiYgMTIzID49IGEua2V5Q29kZSkge1xuICAgICAgICAgIGEua2V5Q29kZSA9IC0xXG4gICAgICAgIH1cbiAgICAgIH1jYXRjaChiKSB7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xucC51ID0gZSgpO1xudmFyIFNhID0ge30sIE8gPSB7fSwgUCA9IHt9LCBJYiA9IHt9O1xuZnVuY3Rpb24gSmIoYSwgYiwgYywgZCwgZikge1xuICBpZihzKGIpKSB7XG4gICAgZm9yKHZhciBnID0gMDtnIDwgYi5sZW5ndGg7ZysrKSB7XG4gICAgICBKYihhLCBiW2ddLCBjLCBkLCBmKVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGE6IHtcbiAgICBpZighYikge1xuICAgICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIGV2ZW50IHR5cGVcIik7XG4gICAgfVxuICAgIGQgPSAhIWQ7XG4gICAgdmFyIGggPSBPO1xuICAgIGIgaW4gaCB8fCAoaFtiXSA9IHtmOjAsIHQ6MH0pO1xuICAgIGggPSBoW2JdO1xuICAgIGQgaW4gaCB8fCAoaFtkXSA9IHtmOjAsIHQ6MH0sIGguZisrKTtcbiAgICB2YXIgaCA9IGhbZF0sIGcgPSB2KGEpLCBuO1xuICAgIGgudCsrO1xuICAgIGlmKGhbZ10pIHtcbiAgICAgIG4gPSBoW2ddO1xuICAgICAgZm9yKHZhciBrID0gMDtrIDwgbi5sZW5ndGg7aysrKSB7XG4gICAgICAgIGlmKGggPSBuW2tdLCBoLlcgPT0gYyAmJiBoLmxiID09IGYpIHtcbiAgICAgICAgICBpZihoLmVhKSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBuW2tdLkhhID0gITE7XG4gICAgICAgICAgYSA9IG5ba107XG4gICAgICAgICAgYnJlYWsgYVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfWVsc2Uge1xuICAgICAgbiA9IGhbZ10gPSBbXSwgaC5mKytcbiAgICB9XG4gICAgayA9IEtiKCk7XG4gICAgaCA9IG5ldyBEYjtcbiAgICBoLk9hKGMsIGssIGEsIGIsIGQsIGYpO1xuICAgIGguSGEgPSAhMTtcbiAgICBrLnNyYyA9IGE7XG4gICAgay5XID0gaDtcbiAgICBuLnB1c2goaCk7XG4gICAgUFtnXSB8fCAoUFtnXSA9IFtdKTtcbiAgICBQW2ddLnB1c2goaCk7XG4gICAgYS5hZGRFdmVudExpc3RlbmVyID8gYSAhPSBxICYmIGEud2IgfHwgYS5hZGRFdmVudExpc3RlbmVyKGIsIGssIGQpIDogYS5hdHRhY2hFdmVudChiIGluIEliID8gSWJbYl0gOiBJYltiXSA9IFwib25cIiArIGIsIGspO1xuICAgIGEgPSBoXG4gIH1cbiAgYiA9IGEua2V5O1xuICBTYVtiXSA9IGE7XG4gIHJldHVybiBiXG59XG5mdW5jdGlvbiBLYigpIHtcbiAgdmFyIGEgPSBMYiwgYiA9IEViID8gZnVuY3Rpb24oYykge1xuICAgIHJldHVybiBhLmNhbGwoYi5zcmMsIGIuVywgYylcbiAgfSA6IGZ1bmN0aW9uKGMpIHtcbiAgICBjID0gYS5jYWxsKGIuc3JjLCBiLlcsIGMpO1xuICAgIGlmKCFjKSB7XG4gICAgICByZXR1cm4gY1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGJcbn1cbmZ1bmN0aW9uIE1iKGEsIGIsIGMsIGQsIGYpIHtcbiAgaWYocyhiKSkge1xuICAgIGZvcih2YXIgZyA9IDA7ZyA8IGIubGVuZ3RoO2crKykge1xuICAgICAgTWIoYSwgYltnXSwgYywgZCwgZilcbiAgICB9XG4gIH1lbHNlIHtcbiAgICBkID0gISFkO1xuICAgIGE6IHtcbiAgICAgIGcgPSBPO1xuICAgICAgaWYoYiBpbiBnICYmIChnID0gZ1tiXSwgZCBpbiBnICYmIChnID0gZ1tkXSwgYSA9IHYoYSksIGdbYV0pKSkge1xuICAgICAgICBhID0gZ1thXTtcbiAgICAgICAgYnJlYWsgYVxuICAgICAgfVxuICAgICAgYSA9IG51bGxcbiAgICB9XG4gICAgaWYoYSkge1xuICAgICAgZm9yKGcgPSAwO2cgPCBhLmxlbmd0aDtnKyspIHtcbiAgICAgICAgaWYoYVtnXS5XID09IGMgJiYgYVtnXS5jYXB0dXJlID09IGQgJiYgYVtnXS5sYiA9PSBmKSB7XG4gICAgICAgICAgTmIoYVtnXS5rZXkpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIE5iKGEpIHtcbiAgdmFyIGIgPSBTYVthXTtcbiAgaWYoIWIgfHwgYi5lYSkge1xuICAgIHJldHVybiExXG4gIH1cbiAgdmFyIGMgPSBiLnNyYywgZCA9IGIudHlwZSwgZiA9IGIuVWIsIGcgPSBiLmNhcHR1cmU7XG4gIGMucmVtb3ZlRXZlbnRMaXN0ZW5lciA/IGMgIT0gcSAmJiBjLndiIHx8IGMucmVtb3ZlRXZlbnRMaXN0ZW5lcihkLCBmLCBnKSA6IGMuZGV0YWNoRXZlbnQgJiYgYy5kZXRhY2hFdmVudChkIGluIEliID8gSWJbZF0gOiBJYltkXSA9IFwib25cIiArIGQsIGYpO1xuICBjID0gdihjKTtcbiAgaWYoUFtjXSkge1xuICAgIHZhciBmID0gUFtjXSwgaCA9IFhhKGYsIGIpO1xuICAgIDAgPD0gaCAmJiBELnNwbGljZS5jYWxsKGYsIGgsIDEpO1xuICAgIDAgPT0gZi5sZW5ndGggJiYgZGVsZXRlIFBbY11cbiAgfVxuICBiLmVhID0gITA7XG4gIGlmKGIgPSBPW2RdW2ddW2NdKSB7XG4gICAgYi5NYiA9ICEwLCBPYihkLCBnLCBjLCBiKVxuICB9XG4gIGRlbGV0ZSBTYVthXTtcbiAgcmV0dXJuITBcbn1cbmZ1bmN0aW9uIE9iKGEsIGIsIGMsIGQpIHtcbiAgaWYoIWQuUWEgJiYgZC5NYikge1xuICAgIGZvcih2YXIgZiA9IDAsIGcgPSAwO2YgPCBkLmxlbmd0aDtmKyspIHtcbiAgICAgIGRbZl0uZWEgPyBkW2ZdLlViLnNyYyA9IG51bGwgOiAoZiAhPSBnICYmIChkW2ddID0gZFtmXSksIGcrKylcbiAgICB9XG4gICAgZC5sZW5ndGggPSBnO1xuICAgIGQuTWIgPSAhMTtcbiAgICAwID09IGcgJiYgKGRlbGV0ZSBPW2FdW2JdW2NdLCBPW2FdW2JdLmYtLSwgMCA9PSBPW2FdW2JdLmYgJiYgKGRlbGV0ZSBPW2FdW2JdLCBPW2FdLmYtLSksIDAgPT0gT1thXS5mICYmIGRlbGV0ZSBPW2FdKVxuICB9XG59XG5mdW5jdGlvbiBQYihhKSB7XG4gIHZhciBiID0gMDtcbiAgaWYobnVsbCAhPSBhKSB7XG4gICAgaWYoYSA9IHYoYSksIFBbYV0pIHtcbiAgICAgIGEgPSBQW2FdO1xuICAgICAgZm9yKHZhciBjID0gYS5sZW5ndGggLSAxOzAgPD0gYztjLS0pIHtcbiAgICAgICAgTmIoYVtjXS5rZXkpLCBiKytcbiAgICAgIH1cbiAgICB9XG4gIH1lbHNlIHtcbiAgICBSYShmdW5jdGlvbihhLCBjKSB7XG4gICAgICBOYihjKTtcbiAgICAgIGIrK1xuICAgIH0pXG4gIH1cbn1cbmZ1bmN0aW9uIFFiKGEsIGIsIGMsIGQsIGYpIHtcbiAgdmFyIGcgPSAxO1xuICBiID0gdihiKTtcbiAgaWYoYVtiXSkge1xuICAgIHZhciBoID0gLS1hLnQsIG4gPSBhW2JdO1xuICAgIG4uUWEgPyBuLlFhKysgOiBuLlFhID0gMTtcbiAgICB0cnkge1xuICAgICAgZm9yKHZhciBrID0gbi5sZW5ndGgsIHQgPSAwO3QgPCBrO3QrKykge1xuICAgICAgICB2YXIgbCA9IG5bdF07XG4gICAgICAgIGwgJiYgIWwuZWEgJiYgKGcgJj0gITEgIT09IFJiKGwsIGYpKVxuICAgICAgfVxuICAgIH1maW5hbGx5IHtcbiAgICAgIGEudCA9IE1hdGgubWF4KGgsIGEudCksIG4uUWEtLSwgT2IoYywgZCwgYiwgbilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEJvb2xlYW4oZylcbn1cbmZ1bmN0aW9uIFJiKGEsIGIpIHtcbiAgYS5IYSAmJiBOYihhLmtleSk7XG4gIHJldHVybiBhLmhhbmRsZUV2ZW50KGIpXG59XG5mdW5jdGlvbiBMYihhLCBiKSB7XG4gIGlmKGEuZWEpIHtcbiAgICByZXR1cm4hMFxuICB9XG4gIHZhciBjID0gYS50eXBlLCBkID0gTztcbiAgaWYoIShjIGluIGQpKSB7XG4gICAgcmV0dXJuITBcbiAgfVxuICB2YXIgZCA9IGRbY10sIGYsIGc7XG4gIGlmKCFFYikge1xuICAgIGYgPSBiIHx8IGRhKFwid2luZG93LmV2ZW50XCIpO1xuICAgIHZhciBoID0gITAgaW4gZCwgbiA9ICExIGluIGQ7XG4gICAgaWYoaCkge1xuICAgICAgaWYoMCA+IGYua2V5Q29kZSB8fCB2b2lkIDAgIT0gZi5yZXR1cm5WYWx1ZSkge1xuICAgICAgICByZXR1cm4hMFxuICAgICAgfVxuICAgICAgYToge1xuICAgICAgICB2YXIgayA9ICExO1xuICAgICAgICBpZigwID09IGYua2V5Q29kZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmLmtleUNvZGUgPSAtMTtcbiAgICAgICAgICAgIGJyZWFrIGFcbiAgICAgICAgICB9Y2F0Y2godCkge1xuICAgICAgICAgICAgayA9ICEwXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKGsgfHwgdm9pZCAwID09IGYucmV0dXJuVmFsdWUpIHtcbiAgICAgICAgICBmLnJldHVyblZhbHVlID0gITBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBrID0gbmV3IEhiO1xuICAgIGsuT2EoZiwgdGhpcyk7XG4gICAgZiA9ICEwO1xuICAgIHRyeSB7XG4gICAgICBpZihoKSB7XG4gICAgICAgIGZvcih2YXIgbCA9IFtdLCByID0gay5jdXJyZW50VGFyZ2V0O3I7ciA9IHIucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGwucHVzaChyKVxuICAgICAgICB9XG4gICAgICAgIGcgPSBkWyEwXTtcbiAgICAgICAgZy50ID0gZy5mO1xuICAgICAgICBmb3IodmFyIEcgPSBsLmxlbmd0aCAtIDE7IWsubmEgJiYgMCA8PSBHICYmIGcudDtHLS0pIHtcbiAgICAgICAgICBrLmN1cnJlbnRUYXJnZXQgPSBsW0ddLCBmICY9IFFiKGcsIGxbR10sIGMsICEwLCBrKVxuICAgICAgICB9XG4gICAgICAgIGlmKG4pIHtcbiAgICAgICAgICBmb3IoZyA9IGRbITFdLCBnLnQgPSBnLmYsIEcgPSAwOyFrLm5hICYmIEcgPCBsLmxlbmd0aCAmJiBnLnQ7RysrKSB7XG4gICAgICAgICAgICBrLmN1cnJlbnRUYXJnZXQgPSBsW0ddLCBmICY9IFFiKGcsIGxbR10sIGMsICExLCBrKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfWVsc2Uge1xuICAgICAgICBmID0gUmIoYSwgaylcbiAgICAgIH1cbiAgICB9ZmluYWxseSB7XG4gICAgICBsICYmIChsLmxlbmd0aCA9IDApXG4gICAgfVxuICAgIHJldHVybiBmXG4gIH1cbiAgYyA9IG5ldyBIYihiLCB0aGlzKTtcbiAgcmV0dXJuIGYgPSBSYihhLCBjKVxufVxuO2Z1bmN0aW9uIFNiKCkge1xuICBNLmNhbGwodGhpcylcbn1cbnkoU2IsIE0pO1xucCA9IFNiLnByb3RvdHlwZTtcbnAud2IgPSAhMDtcbnAucGIgPSBudWxsO1xucC5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oYSwgYiwgYywgZCkge1xuICBKYih0aGlzLCBhLCBiLCBjLCBkKVxufTtcbnAucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQpIHtcbiAgTWIodGhpcywgYSwgYiwgYywgZClcbn07XG5wLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihhKSB7XG4gIHZhciBiID0gYS50eXBlIHx8IGEsIGMgPSBPO1xuICBpZihiIGluIGMpIHtcbiAgICBpZih1KGEpKSB7XG4gICAgICBhID0gbmV3IE4oYSwgdGhpcylcbiAgICB9ZWxzZSB7XG4gICAgICBpZihhIGluc3RhbmNlb2YgTikge1xuICAgICAgICBhLnRhcmdldCA9IGEudGFyZ2V0IHx8IHRoaXNcbiAgICAgIH1lbHNlIHtcbiAgICAgICAgdmFyIGQgPSBhO1xuICAgICAgICBhID0gbmV3IE4oYiwgdGhpcyk7XG4gICAgICAgIFdhKGEsIGQpXG4gICAgICB9XG4gICAgfVxuICAgIHZhciBkID0gMSwgZiwgYyA9IGNbYl0sIGIgPSAhMCBpbiBjLCBnO1xuICAgIGlmKGIpIHtcbiAgICAgIGYgPSBbXTtcbiAgICAgIGZvcihnID0gdGhpcztnO2cgPSBnLnBiKSB7XG4gICAgICAgIGYucHVzaChnKVxuICAgICAgfVxuICAgICAgZyA9IGNbITBdO1xuICAgICAgZy50ID0gZy5mO1xuICAgICAgZm9yKHZhciBoID0gZi5sZW5ndGggLSAxOyFhLm5hICYmIDAgPD0gaCAmJiBnLnQ7aC0tKSB7XG4gICAgICAgIGEuY3VycmVudFRhcmdldCA9IGZbaF0sIGQgJj0gUWIoZywgZltoXSwgYS50eXBlLCAhMCwgYSkgJiYgITEgIT0gYS5XYVxuICAgICAgfVxuICAgIH1cbiAgICBpZighMSBpbiBjKSB7XG4gICAgICBpZihnID0gY1shMV0sIGcudCA9IGcuZiwgYikge1xuICAgICAgICBmb3IoaCA9IDA7IWEubmEgJiYgaCA8IGYubGVuZ3RoICYmIGcudDtoKyspIHtcbiAgICAgICAgICBhLmN1cnJlbnRUYXJnZXQgPSBmW2hdLCBkICY9IFFiKGcsIGZbaF0sIGEudHlwZSwgITEsIGEpICYmICExICE9IGEuV2FcbiAgICAgICAgfVxuICAgICAgfWVsc2Uge1xuICAgICAgICBmb3IoZiA9IHRoaXM7IWEubmEgJiYgZiAmJiBnLnQ7ZiA9IGYucGIpIHtcbiAgICAgICAgICBhLmN1cnJlbnRUYXJnZXQgPSBmLCBkICY9IFFiKGcsIGYsIGEudHlwZSwgITEsIGEpICYmICExICE9IGEuV2FcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBhID0gQm9vbGVhbihkKVxuICB9ZWxzZSB7XG4gICAgYSA9ICEwXG4gIH1cbiAgcmV0dXJuIGFcbn07XG5wLnUgPSBmdW5jdGlvbigpIHtcbiAgU2IucmEudS5jYWxsKHRoaXMpO1xuICBQYih0aGlzKTtcbiAgdGhpcy5wYiA9IG51bGxcbn07XG5mdW5jdGlvbiBUYihhLCBiKSB7XG4gIE0uY2FsbCh0aGlzKTtcbiAgdGhpcy5kYSA9IGEgfHwgMTtcbiAgdGhpcy5FYSA9IGIgfHwgcTtcbiAgdGhpcy5lYiA9IHcodGhpcy5FYywgdGhpcyk7XG4gIHRoaXMub2IgPSB4KClcbn1cbnkoVGIsIFNiKTtcbnAgPSBUYi5wcm90b3R5cGU7XG5wLmVuYWJsZWQgPSAhMTtcbnAuciA9IG51bGw7XG5wLnNldEludGVydmFsID0gZnVuY3Rpb24oYSkge1xuICB0aGlzLmRhID0gYTtcbiAgdGhpcy5yICYmIHRoaXMuZW5hYmxlZCA/ICh0aGlzLnN0b3AoKSwgdGhpcy5zdGFydCgpKSA6IHRoaXMuciAmJiB0aGlzLnN0b3AoKVxufTtcbnAuRWMgPSBmdW5jdGlvbigpIHtcbiAgaWYodGhpcy5lbmFibGVkKSB7XG4gICAgdmFyIGEgPSB4KCkgLSB0aGlzLm9iO1xuICAgIDAgPCBhICYmIGEgPCAwLjggKiB0aGlzLmRhID8gdGhpcy5yID0gdGhpcy5FYS5zZXRUaW1lb3V0KHRoaXMuZWIsIHRoaXMuZGEgLSBhKSA6ICh0aGlzLmRpc3BhdGNoRXZlbnQoVWIpLCB0aGlzLmVuYWJsZWQgJiYgKHRoaXMuciA9IHRoaXMuRWEuc2V0VGltZW91dCh0aGlzLmViLCB0aGlzLmRhKSwgdGhpcy5vYiA9IHgoKSkpXG4gIH1cbn07XG5wLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW5hYmxlZCA9ICEwO1xuICB0aGlzLnIgfHwgKHRoaXMuciA9IHRoaXMuRWEuc2V0VGltZW91dCh0aGlzLmViLCB0aGlzLmRhKSwgdGhpcy5vYiA9IHgoKSlcbn07XG5wLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbmFibGVkID0gITE7XG4gIHRoaXMuciAmJiAodGhpcy5FYS5jbGVhclRpbWVvdXQodGhpcy5yKSwgdGhpcy5yID0gbnVsbClcbn07XG5wLnUgPSBmdW5jdGlvbigpIHtcbiAgVGIucmEudS5jYWxsKHRoaXMpO1xuICB0aGlzLnN0b3AoKTtcbiAgZGVsZXRlIHRoaXMuRWFcbn07XG52YXIgVWIgPSBcInRpY2tcIjtcbmZ1bmN0aW9uIFZiKGEpIHtcbiAgTS5jYWxsKHRoaXMpO1xuICB0aGlzLmUgPSBhO1xuICB0aGlzLmogPSBbXVxufVxueShWYiwgTSk7XG52YXIgV2IgPSBbXTtcbmZ1bmN0aW9uIFhiKGEsIGIsIGMsIGQpIHtcbiAgcyhjKSB8fCAoV2JbMF0gPSBjLCBjID0gV2IpO1xuICBmb3IodmFyIGYgPSAwO2YgPCBjLmxlbmd0aDtmKyspIHtcbiAgICB2YXIgZyA9IEpiKGIsIGNbZl0sIGQgfHwgYSwgITEsIGEuZSB8fCBhKTtcbiAgICBhLmoucHVzaChnKVxuICB9XG59XG5WYi5wcm90b3R5cGUudSA9IGZ1bmN0aW9uKCkge1xuICBWYi5yYS51LmNhbGwodGhpcyk7XG4gIFlhKHRoaXMuaiwgTmIpO1xuICB0aGlzLmoubGVuZ3RoID0gMFxufTtcblZiLnByb3RvdHlwZS5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBFcnJvcihcIkV2ZW50SGFuZGxlci5oYW5kbGVFdmVudCBub3QgaW1wbGVtZW50ZWRcIik7XG59O1xuZnVuY3Rpb24gWWIoYSwgYiwgYykge1xuICBNLmNhbGwodGhpcyk7XG4gIHRoaXMubmMgPSBhO1xuICB0aGlzLmRhID0gYjtcbiAgdGhpcy5lID0gYztcbiAgdGhpcy5oYyA9IHcodGhpcy50YywgdGhpcylcbn1cbnkoWWIsIE0pO1xucCA9IFliLnByb3RvdHlwZTtcbnAuWGEgPSAhMTtcbnAuVGIgPSAwO1xucC5yID0gbnVsbDtcbnAuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnIgJiYgKHEuY2xlYXJUaW1lb3V0KHRoaXMuciksIHRoaXMuciA9IG51bGwsIHRoaXMuWGEgPSAhMSlcbn07XG5wLnUgPSBmdW5jdGlvbigpIHtcbiAgWWIucmEudS5jYWxsKHRoaXMpO1xuICB0aGlzLnN0b3AoKVxufTtcbnAudGMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yID0gbnVsbDtcbiAgdGhpcy5YYSAmJiAhdGhpcy5UYiAmJiAodGhpcy5YYSA9ICExLCBaYih0aGlzKSlcbn07XG5mdW5jdGlvbiBaYihhKSB7XG4gIHZhciBiO1xuICBiID0gYS5oYztcbiAgdmFyIGMgPSBhLmRhO1xuICBpZighaGEoYikpIHtcbiAgICBpZihiICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgYi5oYW5kbGVFdmVudCkge1xuICAgICAgYiA9IHcoYi5oYW5kbGVFdmVudCwgYilcbiAgICB9ZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgbGlzdGVuZXIgYXJndW1lbnRcIik7XG4gICAgfVxuICB9XG4gIGIgPSAyMTQ3NDgzNjQ3IDwgYyA/IC0xIDogcS5zZXRUaW1lb3V0KGIsIGMgfHwgMCk7XG4gIGEuciA9IGI7XG4gIGEubmMuY2FsbChhLmUpXG59XG47ZnVuY3Rpb24gUShhLCBiLCBjLCBkLCBmKSB7XG4gIHRoaXMuYiA9IGE7XG4gIHRoaXMuYSA9IGI7XG4gIHRoaXMuWiA9IGM7XG4gIHRoaXMuQiA9IGQ7XG4gIHRoaXMuQ2EgPSBmIHx8IDE7XG4gIHRoaXMuRGEgPSAkYjtcbiAgdGhpcy5qYiA9IG5ldyBWYih0aGlzKTtcbiAgdGhpcy5TYSA9IG5ldyBUYjtcbiAgdGhpcy5TYS5zZXRJbnRlcnZhbChhYylcbn1cbnAgPSBRLnByb3RvdHlwZTtcbnAudiA9IG51bGw7XG5wLkogPSAhMTtcbnAudWEgPSBudWxsO1xucC5zYiA9IG51bGw7XG5wLnBhID0gbnVsbDtcbnAuc2EgPSBudWxsO1xucC5UID0gbnVsbDtcbnAudyA9IG51bGw7XG5wLlggPSBudWxsO1xucC5sID0gbnVsbDtcbnAuRmEgPSAwO1xucC5LID0gbnVsbDtcbnAudGEgPSBudWxsO1xucC5wID0gbnVsbDtcbnAuaCA9IC0xO1xucC5YYiA9ICEwO1xucC5hYSA9ICExO1xucC5vYSA9IDA7XG5wLlRhID0gbnVsbDtcbnZhciAkYiA9IDQ1RTMsIGFjID0gMjUwO1xuZnVuY3Rpb24gYmMoYSwgYikge1xuICBzd2l0Y2goYSkge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVyblwiTm9uLTIwMCByZXR1cm4gY29kZSAoXCIgKyBiICsgXCIpXCI7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuXCJYTUxIVFRQIGZhaWx1cmUgKG5vIGRhdGEpXCI7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuXCJIdHRwQ29ubmVjdGlvbiB0aW1lb3V0XCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVyblwiVW5rbm93biBlcnJvclwiXG4gIH1cbn1cbnZhciBjYyA9IHt9LCBkYyA9IHt9O1xuZnVuY3Rpb24gZWMoKSB7XG4gIHJldHVybiFBIHx8IEEgJiYgMTAgPD0gTWFcbn1cbnAgPSBRLnByb3RvdHlwZTtcbnAuWSA9IG0oXCJ2XCIpO1xucC5zZXRUaW1lb3V0ID0gbShcIkRhXCIpO1xucC4kYiA9IG0oXCJvYVwiKTtcbmZ1bmN0aW9uIGZjKGEsIGIsIGMpIHtcbiAgYS5zYSA9IDE7XG4gIGEuVCA9IEooYi5uKCkpO1xuICBhLlggPSBjO1xuICBhLnhiID0gITA7XG4gIGdjKGEsIG51bGwpXG59XG5mdW5jdGlvbiBoYyhhLCBiLCBjLCBkLCBmKSB7XG4gIGEuc2EgPSAxO1xuICBhLlQgPSBKKGIubigpKTtcbiAgYS5YID0gbnVsbDtcbiAgYS54YiA9IGM7XG4gIGYgJiYgKGEuWGIgPSAhMSk7XG4gIGdjKGEsIGQpXG59XG5mdW5jdGlvbiBnYyhhLCBiKSB7XG4gIGEucGEgPSB4KCk7XG4gIGljKGEpO1xuICBhLncgPSBhLlQubigpO1xuICBxYihhLncsIFwidFwiLCBhLkNhKTtcbiAgYS5GYSA9IDA7XG4gIGEubCA9IGEuYi5oYihhLmIuWWEoKSA/IGIgOiBudWxsKTtcbiAgMCA8IGEub2EgJiYgKGEuVGEgPSBuZXcgWWIodyhhLmRjLCBhLCBhLmwpLCBhLm9hKSk7XG4gIFhiKGEuamIsIGEubCwgXCJyZWFkeXN0YXRlY2hhbmdlXCIsIGEuQWMpO1xuICB2YXIgYztcbiAgaWYoYS52KSB7XG4gICAgYyA9IGEudjtcbiAgICB2YXIgZCA9IHt9LCBmO1xuICAgIGZvcihmIGluIGMpIHtcbiAgICAgIGRbZl0gPSBjW2ZdXG4gICAgfVxuICAgIGMgPSBkXG4gIH1lbHNlIHtcbiAgICBjID0ge31cbiAgfVxuICBhLlggPyAoYS50YSA9IFwiUE9TVFwiLCBjW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiwgYS5sLnNlbmQoYS53LCBhLnRhLCBhLlgsIGMpKSA6IChhLnRhID0gXCJHRVRcIiwgYS5YYiAmJiAhQiAmJiAoYy5Db25uZWN0aW9uID0gXCJjbG9zZVwiKSwgYS5sLnNlbmQoYS53LCBhLnRhLCBudWxsLCBjKSk7XG4gIGEuYi5HKGpjKTtcbiAgaWYoZCA9IGEuWCkge1xuICAgIGZvcihjID0gXCJcIiwgZCA9IGQuc3BsaXQoXCImXCIpLCBmID0gMDtmIDwgZC5sZW5ndGg7ZisrKSB7XG4gICAgICB2YXIgZyA9IGRbZl0uc3BsaXQoXCI9XCIpO1xuICAgICAgaWYoMSA8IGcubGVuZ3RoKSB7XG4gICAgICAgIHZhciBoID0gZ1swXSwgZyA9IGdbMV0sIG4gPSBoLnNwbGl0KFwiX1wiKTtcbiAgICAgICAgYyA9IDIgPD0gbi5sZW5ndGggJiYgXCJ0eXBlXCIgPT0gblsxXSA/IGMgKyAoaCArIFwiPVwiICsgZyArIFwiJlwiKSA6IGMgKyAoaCArIFwiPXJlZGFjdGVkJlwiKVxuICAgICAgfVxuICAgIH1cbiAgfWVsc2Uge1xuICAgIGMgPSBudWxsXG4gIH1cbiAgYS5hLmluZm8oXCJYTUxIVFRQIFJFUSAoXCIgKyBhLkIgKyBcIikgW2F0dGVtcHQgXCIgKyBhLkNhICsgXCJdOiBcIiArIGEudGEgKyBcIlxcblwiICsgYS53ICsgXCJcXG5cIiArIGMpXG59XG5wLkFjID0gZnVuY3Rpb24oYSkge1xuICBhID0gYS50YXJnZXQ7XG4gIHZhciBiID0gdGhpcy5UYTtcbiAgYiAmJiAzID09IFIoYSkgPyAodGhpcy5hLmRlYnVnKFwiVGhyb3R0bGluZyByZWFkeXN0YXRlY2hhbmdlLlwiKSwgYi5yIHx8IGIuVGIgPyBiLlhhID0gITAgOiBaYihiKSkgOiB0aGlzLmRjKGEpXG59O1xucC5kYyA9IGZ1bmN0aW9uKGEpIHtcbiAgdHJ5IHtcbiAgICBpZihhID09IHRoaXMubCkge1xuICAgICAgYToge1xuICAgICAgICB2YXIgYiA9IFIodGhpcy5sKSwgYyA9IHRoaXMubC5sYSwgZCA9IGtjKHRoaXMubCk7XG4gICAgICAgIGlmKCFlYygpIHx8IEIgJiYgIUMoXCI0MjArXCIpKSB7XG4gICAgICAgICAgaWYoNCA+IGIpIHtcbiAgICAgICAgICAgIGJyZWFrIGFcbiAgICAgICAgICB9XG4gICAgICAgIH1lbHNlIHtcbiAgICAgICAgICBpZigzID4gYiB8fCAzID09IGIgJiYgIXphICYmICFsYyh0aGlzLmwpKSB7XG4gICAgICAgICAgICBicmVhayBhXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWEgfHwgKDQgIT0gYiB8fCBjID09IG1jKSB8fCAoYyA9PSBuYyB8fCAwID49IGQgPyB0aGlzLmIuRyhvYykgOiB0aGlzLmIuRyhwYykpO1xuICAgICAgICBxYyh0aGlzKTtcbiAgICAgICAgdmFyIGYgPSBrYyh0aGlzLmwpO1xuICAgICAgICB0aGlzLmggPSBmO1xuICAgICAgICB2YXIgZyA9IGxjKHRoaXMubCk7XG4gICAgICAgIGcgfHwgdGhpcy5hLmRlYnVnKFwiTm8gcmVzcG9uc2UgdGV4dCBmb3IgdXJpIFwiICsgdGhpcy53ICsgXCIgc3RhdHVzIFwiICsgZik7XG4gICAgICAgIHRoaXMuSiA9IDIwMCA9PSBmO1xuICAgICAgICB0aGlzLmEuaW5mbyhcIlhNTEhUVFAgUkVTUCAoXCIgKyB0aGlzLkIgKyBcIikgWyBhdHRlbXB0IFwiICsgdGhpcy5DYSArIFwiXTogXCIgKyB0aGlzLnRhICsgXCJcXG5cIiArIHRoaXMudyArIFwiXFxuXCIgKyBiICsgXCIgXCIgKyBmKTtcbiAgICAgICAgdGhpcy5KID8gKDQgPT0gYiAmJiBTKHRoaXMpLCB0aGlzLnhiID8gKHJjKHRoaXMsIGIsIGcpLCB6YSAmJiAzID09IGIgJiYgKFhiKHRoaXMuamIsIHRoaXMuU2EsIFViLCB0aGlzLnpjKSwgdGhpcy5TYS5zdGFydCgpKSkgOiAoc2ModGhpcy5hLCB0aGlzLkIsIGcsIG51bGwpLCB0Yyh0aGlzLCBnKSksIHRoaXMuSiAmJiAhdGhpcy5hYSAmJiAoNCA9PSBiID8gdGhpcy5iLm1hKHRoaXMpIDogKHRoaXMuSiA9ICExLCBpYyh0aGlzKSkpKSA6ICg0MDAgPT0gZiAmJiAwIDwgZy5pbmRleE9mKFwiVW5rbm93biBTSURcIikgPyAodGhpcy5wID0gMywgVCh1YyksIHRoaXMuYS4kKFwiWE1MSFRUUCBVbmtub3duIFNJRCAoXCIgKyB0aGlzLkIgKyBcIilcIikpIDogKHRoaXMucCA9IDAsIFQodmMpLCB0aGlzLmEuJChcIlhNTEhUVFAgQmFkIHN0YXR1cyBcIiArIGYgKyBcIiAoXCIgKyB0aGlzLkIgKyBcIilcIikpLCBTKHRoaXMpLCB3Yyh0aGlzKSlcbiAgICAgIH1cbiAgICB9ZWxzZSB7XG4gICAgICB0aGlzLmEuJChcIkNhbGxlZCBiYWNrIHdpdGggYW4gdW5leHBlY3RlZCB4bWxodHRwXCIpXG4gICAgfVxuICB9Y2F0Y2goaCkge1xuICAgIHRoaXMuYS5kZWJ1ZyhcIkZhaWxlZCBjYWxsIHRvIE9uWG1sSHR0cFJlYWR5U3RhdGVDaGFuZ2VkX1wiKSwgdGhpcy5sICYmIGxjKHRoaXMubCkgPyB4Yyh0aGlzLmEsIGgsIFwiUmVzcG9uc2VUZXh0OiBcIiArIGxjKHRoaXMubCkpIDogeGModGhpcy5hLCBoLCBcIk5vIHJlc3BvbnNlIHRleHRcIilcbiAgfWZpbmFsbHkge1xuICB9XG59O1xuZnVuY3Rpb24gcmMoYSwgYiwgYykge1xuICBmb3IodmFyIGQgPSAhMDshYS5hYSAmJiBhLkZhIDwgYy5sZW5ndGg7KSB7XG4gICAgdmFyIGYgPSB5YyhhLCBjKTtcbiAgICBpZihmID09IGRjKSB7XG4gICAgICA0ID09IGIgJiYgKGEucCA9IDQsIFQoemMpLCBkID0gITEpO1xuICAgICAgc2MoYS5hLCBhLkIsIG51bGwsIFwiW0luY29tcGxldGUgUmVzcG9uc2VdXCIpO1xuICAgICAgYnJlYWtcbiAgICB9ZWxzZSB7XG4gICAgICBpZihmID09IGNjKSB7XG4gICAgICAgIGEucCA9IDQ7XG4gICAgICAgIFQoQWMpO1xuICAgICAgICBzYyhhLmEsIGEuQiwgYywgXCJbSW52YWxpZCBDaHVua11cIik7XG4gICAgICAgIGQgPSAhMTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1lbHNlIHtcbiAgICAgICAgc2MoYS5hLCBhLkIsIGYsIG51bGwpLCB0YyhhLCBmKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICA0ID09IGIgJiYgMCA9PSBjLmxlbmd0aCAmJiAoYS5wID0gMSwgVChCYyksIGQgPSAhMSk7XG4gIGEuSiA9IGEuSiAmJiBkO1xuICBkIHx8IChzYyhhLmEsIGEuQiwgYywgXCJbSW52YWxpZCBDaHVua2VkIFJlc3BvbnNlXVwiKSwgUyhhKSwgd2MoYSkpXG59XG5wLnpjID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhID0gUih0aGlzLmwpLCBiID0gbGModGhpcy5sKTtcbiAgdGhpcy5GYSA8IGIubGVuZ3RoICYmIChxYyh0aGlzKSwgcmModGhpcywgYSwgYiksIHRoaXMuSiAmJiA0ICE9IGEgJiYgaWModGhpcykpXG59O1xuZnVuY3Rpb24geWMoYSwgYikge1xuICB2YXIgYyA9IGEuRmEsIGQgPSBiLmluZGV4T2YoXCJcXG5cIiwgYyk7XG4gIGlmKC0xID09IGQpIHtcbiAgICByZXR1cm4gZGNcbiAgfVxuICBjID0gTnVtYmVyKGIuc3Vic3RyaW5nKGMsIGQpKTtcbiAgaWYoaXNOYU4oYykpIHtcbiAgICByZXR1cm4gY2NcbiAgfVxuICBkICs9IDE7XG4gIGlmKGQgKyBjID4gYi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZGNcbiAgfVxuICB2YXIgZiA9IGIuc3Vic3RyKGQsIGMpO1xuICBhLkZhID0gZCArIGM7XG4gIHJldHVybiBmXG59XG5mdW5jdGlvbiBDYyhhLCBiKSB7XG4gIGEucGEgPSB4KCk7XG4gIGljKGEpO1xuICB2YXIgYyA9IGIgPyB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgOiBcIlwiO1xuICBhLncgPSBhLlQubigpO1xuICBJKGEudywgXCJET01BSU5cIiwgYyk7XG4gIEkoYS53LCBcInRcIiwgYS5DYSk7XG4gIHRyeSB7XG4gICAgYS5LID0gbmV3IEFjdGl2ZVhPYmplY3QoXCJodG1sZmlsZVwiKVxuICB9Y2F0Y2goZCkge1xuICAgIGEuYS5JKFwiQWN0aXZlWCBibG9ja2VkXCIpO1xuICAgIFMoYSk7XG4gICAgYS5wID0gNztcbiAgICBUKERjKTtcbiAgICB3YyhhKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgZiA9IFwiPGh0bWw+PGJvZHk+XCI7XG4gIGIgJiYgKGYgKz0gJzxzY3JpcHQ+ZG9jdW1lbnQuZG9tYWluPVwiJyArIGMgKyAnXCJcXHgzYy9zY3JpcHQ+Jyk7XG4gIGYgKz0gXCI8L2JvZHk+PC9odG1sPlwiO1xuICBhLksub3BlbigpO1xuICBhLksud3JpdGUoZik7XG4gIGEuSy5jbG9zZSgpO1xuICBhLksucGFyZW50V2luZG93Lm0gPSB3KGEud2MsIGEpO1xuICBhLksucGFyZW50V2luZG93LmQgPSB3KGEuU2IsIGEsICEwKTtcbiAgYS5LLnBhcmVudFdpbmRvdy5ycGNDbG9zZSA9IHcoYS5TYiwgYSwgITEpO1xuICBjID0gYS5LLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGEuSy5wYXJlbnRXaW5kb3cuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjKTtcbiAgYy5pbm5lckhUTUwgPSAnPGlmcmFtZSBzcmM9XCInICsgYS53ICsgJ1wiPjwvaWZyYW1lPic7XG4gIGEuYS5pbmZvKFwiVFJJREVOVCBSRVEgKFwiICsgYS5CICsgXCIpIFsgYXR0ZW1wdCBcIiArIGEuQ2EgKyBcIl06IEdFVFxcblwiICsgYS53KTtcbiAgYS5iLkcoamMpXG59XG5wLndjID0gZnVuY3Rpb24oYSkge1xuICBVKHcodGhpcy52YywgdGhpcywgYSksIDApXG59O1xucC52YyA9IGZ1bmN0aW9uKGEpIHtcbiAgaWYoIXRoaXMuYWEpIHtcbiAgICB2YXIgYiA9IHRoaXMuYTtcbiAgICBiLmluZm8oXCJUUklERU5UIFRFWFQgKFwiICsgdGhpcy5CICsgXCIpOiBcIiArIEVjKGIsIGEpKTtcbiAgICBxYyh0aGlzKTtcbiAgICB0Yyh0aGlzLCBhKTtcbiAgICBpYyh0aGlzKVxuICB9XG59O1xucC5TYiA9IGZ1bmN0aW9uKGEpIHtcbiAgVSh3KHRoaXMudWMsIHRoaXMsIGEpLCAwKVxufTtcbnAudWMgPSBmdW5jdGlvbihhKSB7XG4gIHRoaXMuYWEgfHwgKHRoaXMuYS5pbmZvKFwiVFJJREVOVCBURVhUIChcIiArIHRoaXMuQiArIFwiKTogXCIgKyBhID8gXCJzdWNjZXNzXCIgOiBcImZhaWx1cmVcIiksIFModGhpcyksIHRoaXMuSiA9IGEsIHRoaXMuYi5tYSh0aGlzKSwgdGhpcy5iLkcoRmMpKVxufTtcbnAubGMgPSBmdW5jdGlvbigpIHtcbiAgcWModGhpcyk7XG4gIHRoaXMuYi5tYSh0aGlzKVxufTtcbnAuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuYWEgPSAhMDtcbiAgUyh0aGlzKVxufTtcbmZ1bmN0aW9uIGljKGEpIHtcbiAgYS5zYiA9IHgoKSArIGEuRGE7XG4gIEdjKGEsIGEuRGEpXG59XG5mdW5jdGlvbiBHYyhhLCBiKSB7XG4gIGlmKG51bGwgIT0gYS51YSkge1xuICAgIHRocm93IEVycm9yKFwiV2F0Y2hEb2cgdGltZXIgbm90IG51bGxcIik7XG4gIH1cbiAgYS51YSA9IFUodyhhLnhjLCBhKSwgYilcbn1cbmZ1bmN0aW9uIHFjKGEpIHtcbiAgYS51YSAmJiAocS5jbGVhclRpbWVvdXQoYS51YSksIGEudWEgPSBudWxsKVxufVxucC54YyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnVhID0gbnVsbDtcbiAgdmFyIGEgPSB4KCk7XG4gIDAgPD0gYSAtIHRoaXMuc2IgPyAodGhpcy5KICYmIHRoaXMuYS5JKFwiUmVjZWl2ZWQgd2F0Y2hkb2cgdGltZW91dCBldmVuIHRob3VnaCByZXF1ZXN0IGxvYWRlZCBzdWNjZXNzZnVsbHlcIiksIHRoaXMuYS5pbmZvKFwiVElNRU9VVDogXCIgKyB0aGlzLncpLCAyICE9IHRoaXMuc2EgJiYgdGhpcy5iLkcob2MpLCBTKHRoaXMpLCB0aGlzLnAgPSAyLCBUKEhjKSwgd2ModGhpcykpIDogKHRoaXMuYS4kKFwiV2F0Y2hEb2cgdGltZXIgY2FsbGVkIHRvbyBlYXJseVwiKSwgR2ModGhpcywgdGhpcy5zYiAtIGEpKVxufTtcbmZ1bmN0aW9uIHdjKGEpIHtcbiAgYS5iLkhiKCkgfHwgYS5hYSB8fCBhLmIubWEoYSlcbn1cbmZ1bmN0aW9uIFMoYSkge1xuICBxYyhhKTtcbiAgdmFyIGIgPSBhLlRhO1xuICBiICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgYi5JYSAmJiBiLklhKCk7XG4gIGEuVGEgPSBudWxsO1xuICBhLlNhLnN0b3AoKTtcbiAgYiA9IGEuamI7XG4gIFlhKGIuaiwgTmIpO1xuICBiLmoubGVuZ3RoID0gMDtcbiAgYS5sICYmIChiID0gYS5sLCBhLmwgPSBudWxsLCBiLmFib3J0KCksIGIuSWEoKSk7XG4gIGEuSyAmJiAoYS5LID0gbnVsbClcbn1cbnAuRWIgPSBhYShcInBcIik7XG5mdW5jdGlvbiB0YyhhLCBiKSB7XG4gIHRyeSB7XG4gICAgYS5iLlBiKGEsIGIpLCBhLmIuRyhGYylcbiAgfWNhdGNoKGMpIHtcbiAgICB4YyhhLmEsIGMsIFwiRXJyb3IgaW4gaHR0cHJlcXVlc3QgY2FsbGJhY2tcIilcbiAgfVxufVxuO2Z1bmN0aW9uIEljKGEpIHtcbiAgYSA9IFN0cmluZyhhKTtcbiAgaWYoL15cXHMqJC8udGVzdChhKSA/IDAgOiAvXltcXF0sOnt9XFxzXFx1MjAyOFxcdTIwMjldKiQvLnRlc3QoYS5yZXBsYWNlKC9cXFxcW1wiXFxcXFxcL2JmbnJ0dV0vZywgXCJAXCIpLnJlcGxhY2UoL1wiW15cIlxcXFxcXG5cXHJcXHUyMDI4XFx1MjAyOVxceDAwLVxceDA4XFx4MGEtXFx4MWZdKlwifHRydWV8ZmFsc2V8bnVsbHwtP1xcZCsoPzpcXC5cXGQqKT8oPzpbZUVdWytcXC1dP1xcZCspPy9nLCBcIl1cIikucmVwbGFjZSgvKD86Xnw6fCwpKD86W1xcc1xcdTIwMjhcXHUyMDI5XSpcXFspKy9nLCBcIlwiKSkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGV2YWwoXCIoXCIgKyBhICsgXCIpXCIpXG4gICAgfWNhdGNoKGIpIHtcbiAgICB9XG4gIH1cbiAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIEpTT04gc3RyaW5nOiBcIiArIGEpO1xufVxuZnVuY3Rpb24gSmMoYSkge1xuICByZXR1cm4gZXZhbChcIihcIiArIGEgKyBcIilcIilcbn1cbmZ1bmN0aW9uIEtjKGEpIHtcbiAgdmFyIGIgPSBbXTtcbiAgTGMobmV3IE1jKHZvaWQgMCksIGEsIGIpO1xuICByZXR1cm4gYi5qb2luKFwiXCIpXG59XG5mdW5jdGlvbiBNYyhhKSB7XG4gIHRoaXMuVmEgPSBhXG59XG5mdW5jdGlvbiBMYyhhLCBiLCBjKSB7XG4gIHN3aXRjaCh0eXBlb2YgYikge1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIE5jKGIsIGMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgYy5wdXNoKGlzRmluaXRlKGIpICYmICFpc05hTihiKSA/IGIgOiBcIm51bGxcIik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgYy5wdXNoKGIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgYy5wdXNoKFwibnVsbFwiKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIGlmKG51bGwgPT0gYikge1xuICAgICAgICBjLnB1c2goXCJudWxsXCIpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYocyhiKSkge1xuICAgICAgICB2YXIgZCA9IGIubGVuZ3RoO1xuICAgICAgICBjLnB1c2goXCJbXCIpO1xuICAgICAgICBmb3IodmFyIGYgPSBcIlwiLCBnID0gMDtnIDwgZDtnKyspIHtcbiAgICAgICAgICBjLnB1c2goZiksIGYgPSBiW2ddLCBMYyhhLCBhLlZhID8gYS5WYS5jYWxsKGIsIFN0cmluZyhnKSwgZikgOiBmLCBjKSwgZiA9IFwiLFwiXG4gICAgICAgIH1cbiAgICAgICAgYy5wdXNoKFwiXVwiKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGMucHVzaChcIntcIik7XG4gICAgICBkID0gXCJcIjtcbiAgICAgIGZvcihnIGluIGIpIHtcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGcpICYmIChmID0gYltnXSwgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBmICYmIChjLnB1c2goZCksIE5jKGcsIGMpLCBjLnB1c2goXCI6XCIpLCBMYyhhLCBhLlZhID8gYS5WYS5jYWxsKGIsIGcsIGYpIDogZiwgYyksIGQgPSBcIixcIikpXG4gICAgICB9XG4gICAgICBjLnB1c2goXCJ9XCIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgRXJyb3IoXCJVbmtub3duIHR5cGU6IFwiICsgdHlwZW9mIGIpO1xuICB9XG59XG52YXIgT2MgPSB7J1wiJzonXFxcXFwiJywgXCJcXFxcXCI6XCJcXFxcXFxcXFwiLCBcIi9cIjpcIlxcXFwvXCIsIFwiXFxiXCI6XCJcXFxcYlwiLCBcIlxcZlwiOlwiXFxcXGZcIiwgXCJcXG5cIjpcIlxcXFxuXCIsIFwiXFxyXCI6XCJcXFxcclwiLCBcIlxcdFwiOlwiXFxcXHRcIiwgXCJcXHgwQlwiOlwiXFxcXHUwMDBiXCJ9LCBQYyA9IC9cXHVmZmZmLy50ZXN0KFwiXFx1ZmZmZlwiKSA/IC9bXFxcXFxcXCJcXHgwMC1cXHgxZlxceDdmLVxcdWZmZmZdL2cgOiAvW1xcXFxcXFwiXFx4MDAtXFx4MWZcXHg3Zi1cXHhmZl0vZztcbmZ1bmN0aW9uIE5jKGEsIGIpIHtcbiAgYi5wdXNoKCdcIicsIGEucmVwbGFjZShQYywgZnVuY3Rpb24oYSkge1xuICAgIGlmKGEgaW4gT2MpIHtcbiAgICAgIHJldHVybiBPY1thXVxuICAgIH1cbiAgICB2YXIgYiA9IGEuY2hhckNvZGVBdCgwKSwgZiA9IFwiXFxcXHVcIjtcbiAgICAxNiA+IGIgPyBmICs9IFwiMDAwXCIgOiAyNTYgPiBiID8gZiArPSBcIjAwXCIgOiA0MDk2ID4gYiAmJiAoZiArPSBcIjBcIik7XG4gICAgcmV0dXJuIE9jW2FdID0gZiArIGIudG9TdHJpbmcoMTYpXG4gIH0pLCAnXCInKVxufVxuO2Z1bmN0aW9uIFFjKGEpIHtcbiAgcmV0dXJuIFJjKGEgfHwgYXJndW1lbnRzLmNhbGxlZS5jYWxsZXIsIFtdKVxufVxuZnVuY3Rpb24gUmMoYSwgYikge1xuICB2YXIgYyA9IFtdO1xuICBpZigwIDw9IFhhKGIsIGEpKSB7XG4gICAgYy5wdXNoKFwiWy4uLmNpcmN1bGFyIHJlZmVyZW5jZS4uLl1cIilcbiAgfWVsc2Uge1xuICAgIGlmKGEgJiYgNTAgPiBiLmxlbmd0aCkge1xuICAgICAgYy5wdXNoKFNjKGEpICsgXCIoXCIpO1xuICAgICAgZm9yKHZhciBkID0gYS5hcmd1bWVudHMsIGYgPSAwO2YgPCBkLmxlbmd0aDtmKyspIHtcbiAgICAgICAgMCA8IGYgJiYgYy5wdXNoKFwiLCBcIik7XG4gICAgICAgIHZhciBnO1xuICAgICAgICBnID0gZFtmXTtcbiAgICAgICAgc3dpdGNoKHR5cGVvZiBnKSB7XG4gICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgZyA9IGcgPyBcIm9iamVjdFwiIDogXCJudWxsXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBnID0gU3RyaW5nKGcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgIGcgPSBnID8gXCJ0cnVlXCIgOiBcImZhbHNlXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgIGcgPSAoZyA9IFNjKGcpKSA/IGcgOiBcIltmbl1cIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBnID0gdHlwZW9mIGdcbiAgICAgICAgfVxuICAgICAgICA0MCA8IGcubGVuZ3RoICYmIChnID0gZy5zdWJzdHIoMCwgNDApICsgXCIuLi5cIik7XG4gICAgICAgIGMucHVzaChnKVxuICAgICAgfVxuICAgICAgYi5wdXNoKGEpO1xuICAgICAgYy5wdXNoKFwiKVxcblwiKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGMucHVzaChSYyhhLmNhbGxlciwgYikpXG4gICAgICB9Y2F0Y2goaCkge1xuICAgICAgICBjLnB1c2goXCJbZXhjZXB0aW9uIHRyeWluZyB0byBnZXQgY2FsbGVyXVxcblwiKVxuICAgICAgfVxuICAgIH1lbHNlIHtcbiAgICAgIGEgPyBjLnB1c2goXCJbLi4ubG9uZyBzdGFjay4uLl1cIikgOiBjLnB1c2goXCJbZW5kXVwiKVxuICAgIH1cbiAgfVxuICByZXR1cm4gYy5qb2luKFwiXCIpXG59XG5mdW5jdGlvbiBTYyhhKSB7XG4gIGlmKFRjW2FdKSB7XG4gICAgcmV0dXJuIFRjW2FdXG4gIH1cbiAgYSA9IFN0cmluZyhhKTtcbiAgaWYoIVRjW2FdKSB7XG4gICAgdmFyIGIgPSAvZnVuY3Rpb24gKFteXFwoXSspLy5leGVjKGEpO1xuICAgIFRjW2FdID0gYiA/IGJbMV0gOiBcIltBbm9ueW1vdXNdXCJcbiAgfVxuICByZXR1cm4gVGNbYV1cbn1cbnZhciBUYyA9IHt9O1xuZnVuY3Rpb24gVWMoYSwgYiwgYywgZCwgZikge1xuICB0aGlzLnJlc2V0KGEsIGIsIGMsIGQsIGYpXG59XG5VYy5wcm90b3R5cGUuQ2MgPSAwO1xuVWMucHJvdG90eXBlLkJiID0gbnVsbDtcblVjLnByb3RvdHlwZS5BYiA9IG51bGw7XG52YXIgVmMgPSAwO1xuVWMucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oYSwgYiwgYywgZCwgZikge1xuICB0aGlzLkNjID0gXCJudW1iZXJcIiA9PSB0eXBlb2YgZiA/IGYgOiBWYysrO1xuICB0aGlzLlFjID0gZCB8fCB4KCk7XG4gIHRoaXMuemEgPSBhO1xuICB0aGlzLm9jID0gYjtcbiAgdGhpcy5JYyA9IGM7XG4gIGRlbGV0ZSB0aGlzLkJiO1xuICBkZWxldGUgdGhpcy5BYlxufTtcblVjLnByb3RvdHlwZS5ZYiA9IG0oXCJ6YVwiKTtcbmZ1bmN0aW9uIFYoYSkge1xuICB0aGlzLnBjID0gYVxufVxuVi5wcm90b3R5cGUuUmEgPSBudWxsO1xuVi5wcm90b3R5cGUuemEgPSBudWxsO1xuVi5wcm90b3R5cGUuZmIgPSBudWxsO1xuVi5wcm90b3R5cGUuRmIgPSBudWxsO1xuZnVuY3Rpb24gV2MoYSwgYikge1xuICB0aGlzLm5hbWUgPSBhO1xuICB0aGlzLnZhbHVlID0gYlxufVxuV2MucHJvdG90eXBlLnRvU3RyaW5nID0gYWEoXCJuYW1lXCIpO1xudmFyIFhjID0gbmV3IFdjKFwiU0VWRVJFXCIsIDFFMyksIFljID0gbmV3IFdjKFwiV0FSTklOR1wiLCA5MDApLCBaYyA9IG5ldyBXYyhcIklORk9cIiwgODAwKSwgJGMgPSBuZXcgV2MoXCJDT05GSUdcIiwgNzAwKSwgYWQgPSBuZXcgV2MoXCJGSU5FXCIsIDUwMCk7XG5wID0gVi5wcm90b3R5cGU7XG5wLmdldFBhcmVudCA9IGFhKFwiUmFcIik7XG5wLlliID0gbShcInphXCIpO1xuZnVuY3Rpb24gYmQoYSkge1xuICBpZihhLnphKSB7XG4gICAgcmV0dXJuIGEuemFcbiAgfVxuICBpZihhLlJhKSB7XG4gICAgcmV0dXJuIGJkKGEuUmEpXG4gIH1cbiAgUGEoXCJSb290IGxvZ2dlciBoYXMgbm8gbGV2ZWwgc2V0LlwiKTtcbiAgcmV0dXJuIG51bGxcbn1cbnAubG9nID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICBpZihhLnZhbHVlID49IGJkKHRoaXMpLnZhbHVlKSB7XG4gICAgZm9yKGEgPSB0aGlzLmtjKGEsIGIsIGMpLCBiID0gXCJsb2c6XCIgKyBhLm9jLCBxLmNvbnNvbGUgJiYgKHEuY29uc29sZS50aW1lU3RhbXAgPyBxLmNvbnNvbGUudGltZVN0YW1wKGIpIDogcS5jb25zb2xlLm1hcmtUaW1lbGluZSAmJiBxLmNvbnNvbGUubWFya1RpbWVsaW5lKGIpKSwgcS5tc1dyaXRlUHJvZmlsZXJNYXJrICYmIHEubXNXcml0ZVByb2ZpbGVyTWFyayhiKSwgYiA9IHRoaXM7YjspIHtcbiAgICAgIGMgPSBiO1xuICAgICAgdmFyIGQgPSBhO1xuICAgICAgaWYoYy5GYikge1xuICAgICAgICBmb3IodmFyIGYgPSAwLCBnID0gdm9pZCAwO2cgPSBjLkZiW2ZdO2YrKykge1xuICAgICAgICAgIGcoZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYiA9IGIuZ2V0UGFyZW50KClcbiAgICB9XG4gIH1cbn07XG5wLmtjID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICB2YXIgZCA9IG5ldyBVYyhhLCBTdHJpbmcoYiksIHRoaXMucGMpO1xuICBpZihjKSB7XG4gICAgZC5CYiA9IGM7XG4gICAgdmFyIGY7XG4gICAgdmFyIGcgPSBhcmd1bWVudHMuY2FsbGVlLmNhbGxlcjtcbiAgICB0cnkge1xuICAgICAgdmFyIGg7XG4gICAgICB2YXIgbiA9IGRhKFwid2luZG93LmxvY2F0aW9uLmhyZWZcIik7XG4gICAgICBpZih1KGMpKSB7XG4gICAgICAgIGggPSB7bWVzc2FnZTpjLCBuYW1lOlwiVW5rbm93biBlcnJvclwiLCBsaW5lTnVtYmVyOlwiTm90IGF2YWlsYWJsZVwiLCBmaWxlTmFtZTpuLCBzdGFjazpcIk5vdCBhdmFpbGFibGVcIn1cbiAgICAgIH1lbHNlIHtcbiAgICAgICAgdmFyIGssIHQsIGwgPSAhMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBrID0gYy5saW5lTnVtYmVyIHx8IGMuSGMgfHwgXCJOb3QgYXZhaWxhYmxlXCJcbiAgICAgICAgfWNhdGNoKHIpIHtcbiAgICAgICAgICBrID0gXCJOb3QgYXZhaWxhYmxlXCIsIGwgPSAhMFxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdCA9IGMuZmlsZU5hbWUgfHwgYy5maWxlbmFtZSB8fCBjLnNvdXJjZVVSTCB8fCBxLiRnb29nRGVidWdGbmFtZSB8fCBuXG4gICAgICAgIH1jYXRjaChHKSB7XG4gICAgICAgICAgdCA9IFwiTm90IGF2YWlsYWJsZVwiLCBsID0gITBcbiAgICAgICAgfVxuICAgICAgICBoID0gIWwgJiYgYy5saW5lTnVtYmVyICYmIGMuZmlsZU5hbWUgJiYgYy5zdGFjayA/IGMgOiB7bWVzc2FnZTpjLm1lc3NhZ2UsIG5hbWU6Yy5uYW1lLCBsaW5lTnVtYmVyOmssIGZpbGVOYW1lOnQsIHN0YWNrOmMuc3RhY2sgfHwgXCJOb3QgYXZhaWxhYmxlXCJ9XG4gICAgICB9XG4gICAgICBmID0gXCJNZXNzYWdlOiBcIiArIG5hKGgubWVzc2FnZSkgKyAnXFxuVXJsOiA8YSBocmVmPVwidmlldy1zb3VyY2U6JyArIGguZmlsZU5hbWUgKyAnXCIgdGFyZ2V0PVwiX25ld1wiPicgKyBoLmZpbGVOYW1lICsgXCI8L2E+XFxuTGluZTogXCIgKyBoLmxpbmVOdW1iZXIgKyBcIlxcblxcbkJyb3dzZXIgc3RhY2s6XFxuXCIgKyBuYShoLnN0YWNrICsgXCItPiBcIikgKyBcIltlbmRdXFxuXFxuSlMgc3RhY2sgdHJhdmVyc2FsOlxcblwiICsgbmEoUWMoZykgKyBcIi0+IFwiKVxuICAgIH1jYXRjaChTZCkge1xuICAgICAgZiA9IFwiRXhjZXB0aW9uIHRyeWluZyB0byBleHBvc2UgZXhjZXB0aW9uISBZb3Ugd2luLCB3ZSBsb3NlLiBcIiArIFNkXG4gICAgfVxuICAgIGQuQWIgPSBmXG4gIH1cbiAgcmV0dXJuIGRcbn07XG5wLkkgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHRoaXMubG9nKFhjLCBhLCBiKVxufTtcbnAuJCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdGhpcy5sb2coWWMsIGEsIGIpXG59O1xucC5pbmZvID0gZnVuY3Rpb24oYSwgYikge1xuICB0aGlzLmxvZyhaYywgYSwgYilcbn07XG5mdW5jdGlvbiBXKGEsIGIpIHtcbiAgYS5sb2coYWQsIGIsIHZvaWQgMClcbn1cbnZhciBjZCA9IHt9LCBkZCA9IG51bGw7XG5mdW5jdGlvbiBlZChhKSB7XG4gIGRkIHx8IChkZCA9IG5ldyBWKFwiXCIpLCBjZFtcIlwiXSA9IGRkLCBkZC5ZYigkYykpO1xuICB2YXIgYjtcbiAgaWYoIShiID0gY2RbYV0pKSB7XG4gICAgYiA9IG5ldyBWKGEpO1xuICAgIHZhciBjID0gYS5sYXN0SW5kZXhPZihcIi5cIiksIGQgPSBhLnN1YnN0cihjICsgMSksIGMgPSBlZChhLnN1YnN0cigwLCBjKSk7XG4gICAgYy5mYiB8fCAoYy5mYiA9IHt9KTtcbiAgICBjLmZiW2RdID0gYjtcbiAgICBiLlJhID0gYztcbiAgICBjZFthXSA9IGJcbiAgfVxuICByZXR1cm4gYlxufVxuO2Z1bmN0aW9uIFgoKSB7XG4gIHRoaXMucSA9IGVkKFwiZ29vZy5uZXQuQnJvd3NlckNoYW5uZWxcIilcbn1cbmZ1bmN0aW9uIHNjKGEsIGIsIGMsIGQpIHtcbiAgYS5pbmZvKFwiWE1MSFRUUCBURVhUIChcIiArIGIgKyBcIik6IFwiICsgRWMoYSwgYykgKyAoZCA/IFwiIFwiICsgZCA6IFwiXCIpKVxufVxuWC5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbihhKSB7XG4gIHRoaXMuaW5mbyhhKVxufTtcbmZ1bmN0aW9uIHhjKGEsIGIsIGMpIHtcbiAgYS5JKChjIHx8IFwiRXhjZXB0aW9uXCIpICsgYilcbn1cblgucHJvdG90eXBlLmluZm8gPSBmdW5jdGlvbihhKSB7XG4gIHRoaXMucS5pbmZvKGEpXG59O1xuWC5wcm90b3R5cGUuJCA9IGZ1bmN0aW9uKGEpIHtcbiAgdGhpcy5xLiQoYSlcbn07XG5YLnByb3RvdHlwZS5JID0gZnVuY3Rpb24oYSkge1xuICB0aGlzLnEuSShhKVxufTtcbmZ1bmN0aW9uIEVjKGEsIGIpIHtcbiAgaWYoIWIgfHwgYiA9PSBmZCkge1xuICAgIHJldHVybiBiXG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIgYyA9IEpjKGIpO1xuICAgIGlmKGMpIHtcbiAgICAgIGZvcih2YXIgZCA9IDA7ZCA8IGMubGVuZ3RoO2QrKykge1xuICAgICAgICBpZihzKGNbZF0pKSB7XG4gICAgICAgICAgdmFyIGYgPSBjW2RdO1xuICAgICAgICAgIGlmKCEoMiA+IGYubGVuZ3RoKSkge1xuICAgICAgICAgICAgdmFyIGcgPSBmWzFdO1xuICAgICAgICAgICAgaWYocyhnKSAmJiAhKDEgPiBnLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgdmFyIGggPSBnWzBdO1xuICAgICAgICAgICAgICBpZihcIm5vb3BcIiAhPSBoICYmIFwic3RvcFwiICE9IGgpIHtcbiAgICAgICAgICAgICAgICBmb3IodmFyIG4gPSAxO24gPCBnLmxlbmd0aDtuKyspIHtcbiAgICAgICAgICAgICAgICAgIGdbbl0gPSBcIlwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBLYyhjKVxuICB9Y2F0Y2goaykge1xuICAgIHJldHVybiBhLmRlYnVnKFwiRXhjZXB0aW9uIHBhcnNpbmcgZXhwZWN0ZWQgSlMgYXJyYXkgLSBwcm9iYWJseSB3YXMgbm90IEpTXCIpLCBiXG4gIH1cbn1cbjtmdW5jdGlvbiBnZChhLCBiKSB7XG4gIHRoaXMuT2MgPSBuZXcgTWMoYSk7XG4gIHRoaXMuUCA9IGIgPyBKYyA6IEljXG59XG5nZC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihhKSB7XG4gIHJldHVybiB0aGlzLlAoYSlcbn07XG52YXIgbWMgPSA3LCBuYyA9IDg7XG5mdW5jdGlvbiBoZChhKSB7XG4gIE0uY2FsbCh0aGlzKTtcbiAgdGhpcy5oZWFkZXJzID0gbmV3IGJiO1xuICB0aGlzLnZhID0gYSB8fCBudWxsXG59XG55KGhkLCBTYik7XG5oZC5wcm90b3R5cGUucSA9IGVkKFwiZ29vZy5uZXQuWGhySW9cIik7XG52YXIgaWQgPSAvXmh0dHBzPyQvaTtcbnAgPSBoZC5wcm90b3R5cGU7XG5wLlMgPSAhMTtcbnAuZyA9IG51bGw7XG5wLmJiID0gbnVsbDtcbnAuUGEgPSBcIlwiO1xucC5KYiA9IFwiXCI7XG5wLmxhID0gMDtcbnAucCA9IFwiXCI7XG5wLmliID0gITE7XG5wLk5hID0gITE7XG5wLm1iID0gITE7XG5wLmNhID0gITE7XG5wLiRhID0gMDtcbnAuZmEgPSBudWxsO1xucC5XYiA9IFwiXCI7XG5wLmNjID0gITE7XG5wLnNlbmQgPSBmdW5jdGlvbihhLCBiLCBjLCBkKSB7XG4gIGlmKHRoaXMuZykge1xuICAgIHRocm93IEVycm9yKFwiW2dvb2cubmV0LlhocklvXSBPYmplY3QgaXMgYWN0aXZlIHdpdGggYW5vdGhlciByZXF1ZXN0PVwiICsgdGhpcy5QYSArIFwiOyBuZXdVcmk9XCIgKyBhKTtcbiAgfVxuICBiID0gYiA/IGIudG9VcHBlckNhc2UoKSA6IFwiR0VUXCI7XG4gIHRoaXMuUGEgPSBhO1xuICB0aGlzLnAgPSBcIlwiO1xuICB0aGlzLmxhID0gMDtcbiAgdGhpcy5KYiA9IGI7XG4gIHRoaXMuaWIgPSAhMTtcbiAgdGhpcy5TID0gITA7XG4gIHRoaXMuZyA9IHRoaXMudmEgPyB4Yih0aGlzLnZhKSA6IHhiKHZiKTtcbiAgdGhpcy5iYiA9IHRoaXMudmEgPyB0aGlzLnZhLkdhIHx8ICh0aGlzLnZhLkdhID0gemIodGhpcy52YSkpIDogdmIuR2EgfHwgKHZiLkdhID0gemIodmIpKTtcbiAgdGhpcy5nLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHcodGhpcy5PYiwgdGhpcyk7XG4gIHRyeSB7XG4gICAgVyh0aGlzLnEsIFkodGhpcywgXCJPcGVuaW5nIFhoclwiKSksIHRoaXMubWIgPSAhMCwgdGhpcy5nLm9wZW4oYiwgYSwgITApLCB0aGlzLm1iID0gITFcbiAgfWNhdGNoKGYpIHtcbiAgICBXKHRoaXMucSwgWSh0aGlzLCBcIkVycm9yIG9wZW5pbmcgWGhyOiBcIiArIGYubWVzc2FnZSkpO1xuICAgIGpkKHRoaXMsIGYpO1xuICAgIHJldHVyblxuICB9XG4gIGEgPSBjIHx8IFwiXCI7XG4gIHZhciBnID0gdGhpcy5oZWFkZXJzLm4oKTtcbiAgZCAmJiBFKGQsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBnLnNldChiLCBhKVxuICB9KTtcbiAgZCA9IHEuRm9ybURhdGEgJiYgYSBpbnN0YW5jZW9mIHEuRm9ybURhdGE7XG4gIFwiUE9TVFwiICE9IGIgfHwgKGcuaWEoXCJDb250ZW50LVR5cGVcIikgfHwgZCkgfHwgZy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOFwiKTtcbiAgRShnLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgdGhpcy5nLnNldFJlcXVlc3RIZWFkZXIoYiwgYSlcbiAgfSwgdGhpcyk7XG4gIHRoaXMuV2IgJiYgKHRoaXMuZy5yZXNwb25zZVR5cGUgPSB0aGlzLldiKTtcbiAgXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB0aGlzLmcgJiYgKHRoaXMuZy53aXRoQ3JlZGVudGlhbHMgPSB0aGlzLmNjKTtcbiAgdHJ5IHtcbiAgICB0aGlzLmZhICYmIChxLmNsZWFyVGltZW91dCh0aGlzLmZhKSwgdGhpcy5mYSA9IG51bGwpLCAwIDwgdGhpcy4kYSAmJiAoVyh0aGlzLnEsIFkodGhpcywgXCJXaWxsIGFib3J0IGFmdGVyIFwiICsgdGhpcy4kYSArIFwibXMgaWYgaW5jb21wbGV0ZVwiKSksIHRoaXMuZmEgPSBxLnNldFRpbWVvdXQodyh0aGlzLkRhLCB0aGlzKSwgdGhpcy4kYSkpLCBXKHRoaXMucSwgWSh0aGlzLCBcIlNlbmRpbmcgcmVxdWVzdFwiKSksIHRoaXMuTmEgPSAhMCwgdGhpcy5nLnNlbmQoYSksIHRoaXMuTmEgPSAhMVxuICB9Y2F0Y2goaCkge1xuICAgIFcodGhpcy5xLCBZKHRoaXMsIFwiU2VuZCBlcnJvcjogXCIgKyBoLm1lc3NhZ2UpKSwgamQodGhpcywgaClcbiAgfVxufTtcbnAuRGEgPSBmdW5jdGlvbigpIHtcbiAgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgY2EgJiYgdGhpcy5nICYmICh0aGlzLnAgPSBcIlRpbWVkIG91dCBhZnRlciBcIiArIHRoaXMuJGEgKyBcIm1zLCBhYm9ydGluZ1wiLCB0aGlzLmxhID0gbmMsIFcodGhpcy5xLCBZKHRoaXMsIHRoaXMucCkpLCB0aGlzLmRpc3BhdGNoRXZlbnQoXCJ0aW1lb3V0XCIpLCB0aGlzLmFib3J0KG5jKSlcbn07XG5mdW5jdGlvbiBqZChhLCBiKSB7XG4gIGEuUyA9ICExO1xuICBhLmcgJiYgKGEuY2EgPSAhMCwgYS5nLmFib3J0KCksIGEuY2EgPSAhMSk7XG4gIGEucCA9IGI7XG4gIGEubGEgPSA1O1xuICBrZChhKTtcbiAgbGQoYSlcbn1cbmZ1bmN0aW9uIGtkKGEpIHtcbiAgYS5pYiB8fCAoYS5pYiA9ICEwLCBhLmRpc3BhdGNoRXZlbnQoXCJjb21wbGV0ZVwiKSwgYS5kaXNwYXRjaEV2ZW50KFwiZXJyb3JcIikpXG59XG5wLmFib3J0ID0gZnVuY3Rpb24oYSkge1xuICB0aGlzLmcgJiYgdGhpcy5TICYmIChXKHRoaXMucSwgWSh0aGlzLCBcIkFib3J0aW5nXCIpKSwgdGhpcy5TID0gITEsIHRoaXMuY2EgPSAhMCwgdGhpcy5nLmFib3J0KCksIHRoaXMuY2EgPSAhMSwgdGhpcy5sYSA9IGEgfHwgbWMsIHRoaXMuZGlzcGF0Y2hFdmVudChcImNvbXBsZXRlXCIpLCB0aGlzLmRpc3BhdGNoRXZlbnQoXCJhYm9ydFwiKSwgbGQodGhpcykpXG59O1xucC51ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZyAmJiAodGhpcy5TICYmICh0aGlzLlMgPSAhMSwgdGhpcy5jYSA9ICEwLCB0aGlzLmcuYWJvcnQoKSwgdGhpcy5jYSA9ICExKSwgbGQodGhpcywgITApKTtcbiAgaGQucmEudS5jYWxsKHRoaXMpXG59O1xucC5PYiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLm1iIHx8IHRoaXMuTmEgfHwgdGhpcy5jYSA/IG1kKHRoaXMpIDogdGhpcy5zYygpXG59O1xucC5zYyA9IGZ1bmN0aW9uKCkge1xuICBtZCh0aGlzKVxufTtcbmZ1bmN0aW9uIG1kKGEpIHtcbiAgaWYoYS5TICYmIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGNhKSB7XG4gICAgaWYoYS5iYlsxXSAmJiA0ID09IFIoYSkgJiYgMiA9PSBrYyhhKSkge1xuICAgICAgVyhhLnEsIFkoYSwgXCJMb2NhbCByZXF1ZXN0IGVycm9yIGRldGVjdGVkIGFuZCBpZ25vcmVkXCIpKVxuICAgIH1lbHNlIHtcbiAgICAgIGlmKGEuTmEgJiYgNCA9PSBSKGEpKSB7XG4gICAgICAgIHEuc2V0VGltZW91dCh3KGEuT2IsIGEpLCAwKVxuICAgICAgfWVsc2Uge1xuICAgICAgICBpZihhLmRpc3BhdGNoRXZlbnQoXCJyZWFkeXN0YXRlY2hhbmdlXCIpLCA0ID09IFIoYSkpIHtcbiAgICAgICAgICBXKGEucSwgWShhLCBcIlJlcXVlc3QgY29tcGxldGVcIikpO1xuICAgICAgICAgIGEuUyA9ICExO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgYiA9IGtjKGEpLCBjLCBkO1xuICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICBzd2l0Y2goYikge1xuICAgICAgICAgICAgICAgIGNhc2UgMjAwOlxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBjYXNlIDIwMTpcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgY2FzZSAyMDI6XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGNhc2UgMjA0OlxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBjYXNlIDIwNjpcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgY2FzZSAzMDQ6XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGNhc2UgMTIyMzpcbiAgICAgICAgICAgICAgICAgIGQgPSAhMDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIGQgPSAhMVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZighKGMgPSBkKSkge1xuICAgICAgICAgICAgICB2YXIgZjtcbiAgICAgICAgICAgICAgaWYoZiA9IDAgPT09IGIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZyA9IFN0cmluZyhhLlBhKS5tYXRjaChRYSlbMV0gfHwgbnVsbDtcbiAgICAgICAgICAgICAgICBpZighZyAmJiBzZWxmLmxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaCA9IHNlbGYubG9jYXRpb24ucHJvdG9jb2wsIGcgPSBoLnN1YnN0cigwLCBoLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGYgPSAhaWQudGVzdChnID8gZy50b0xvd2VyQ2FzZSgpIDogXCJcIilcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjID0gZlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoYykge1xuICAgICAgICAgICAgICBhLmRpc3BhdGNoRXZlbnQoXCJjb21wbGV0ZVwiKSwgYS5kaXNwYXRjaEV2ZW50KFwic3VjY2Vzc1wiKVxuICAgICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgICBhLmxhID0gNjtcbiAgICAgICAgICAgICAgdmFyIG47XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbiA9IDIgPCBSKGEpID8gYS5nLnN0YXR1c1RleHQgOiBcIlwiXG4gICAgICAgICAgICAgIH1jYXRjaChrKSB7XG4gICAgICAgICAgICAgICAgVyhhLnEsIFwiQ2FuIG5vdCBnZXQgc3RhdHVzOiBcIiArIGsubWVzc2FnZSksIG4gPSBcIlwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYS5wID0gbiArIFwiIFtcIiArIGtjKGEpICsgXCJdXCI7XG4gICAgICAgICAgICAgIGtkKGEpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfWZpbmFsbHkge1xuICAgICAgICAgICAgbGQoYSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGxkKGEsIGIpIHtcbiAgaWYoYS5nKSB7XG4gICAgdmFyIGMgPSBhLmcsIGQgPSBhLmJiWzBdID8gZWEgOiBudWxsO1xuICAgIGEuZyA9IG51bGw7XG4gICAgYS5iYiA9IG51bGw7XG4gICAgYS5mYSAmJiAocS5jbGVhclRpbWVvdXQoYS5mYSksIGEuZmEgPSBudWxsKTtcbiAgICBiIHx8IGEuZGlzcGF0Y2hFdmVudChcInJlYWR5XCIpO1xuICAgIHRyeSB7XG4gICAgICBjLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGRcbiAgICB9Y2F0Y2goZikge1xuICAgICAgYS5xLkkoXCJQcm9ibGVtIGVuY291bnRlcmVkIHJlc2V0dGluZyBvbnJlYWR5c3RhdGVjaGFuZ2U6IFwiICsgZi5tZXNzYWdlKVxuICAgIH1cbiAgfVxufVxucC5pc0FjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4hIXRoaXMuZ1xufTtcbmZ1bmN0aW9uIFIoYSkge1xuICByZXR1cm4gYS5nID8gYS5nLnJlYWR5U3RhdGUgOiAwXG59XG5mdW5jdGlvbiBrYyhhKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIDIgPCBSKGEpID8gYS5nLnN0YXR1cyA6IC0xXG4gIH1jYXRjaChiKSB7XG4gICAgcmV0dXJuIGEucS4kKFwiQ2FuIG5vdCBnZXQgc3RhdHVzOiBcIiArIGIubWVzc2FnZSksIC0xXG4gIH1cbn1cbmZ1bmN0aW9uIGxjKGEpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYS5nID8gYS5nLnJlc3BvbnNlVGV4dCA6IFwiXCJcbiAgfWNhdGNoKGIpIHtcbiAgICByZXR1cm4gVyhhLnEsIFwiQ2FuIG5vdCBnZXQgcmVzcG9uc2VUZXh0OiBcIiArIGIubWVzc2FnZSksIFwiXCJcbiAgfVxufVxucC5FYiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdSh0aGlzLnApID8gdGhpcy5wIDogU3RyaW5nKHRoaXMucClcbn07XG5mdW5jdGlvbiBZKGEsIGIpIHtcbiAgcmV0dXJuIGIgKyBcIiBbXCIgKyBhLkpiICsgXCIgXCIgKyBhLlBhICsgXCIgXCIgKyBrYyhhKSArIFwiXVwiXG59XG47ZnVuY3Rpb24gbmQoKSB7XG4gIHRoaXMuVmIgPSB4KClcbn1cbm5ldyBuZDtcbm5kLnByb3RvdHlwZS5zZXQgPSBtKFwiVmJcIik7XG5uZC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zZXQoeCgpKVxufTtcbm5kLnByb3RvdHlwZS5nZXQgPSBhYShcIlZiXCIpO1xuZnVuY3Rpb24gb2QoYSwgYiwgYywgZCwgZikge1xuICAobmV3IFgpLmRlYnVnKFwiVGVzdExvYWRJbWFnZVdpdGhSZXRyaWVzOiBcIiArIGYpO1xuICBpZigwID09IGQpIHtcbiAgICBjKCExKVxuICB9ZWxzZSB7XG4gICAgdmFyIGcgPSBmIHx8IDA7XG4gICAgZC0tO1xuICAgIHBkKGEsIGIsIGZ1bmN0aW9uKGYpIHtcbiAgICAgIGYgPyBjKCEwKSA6IHEuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgb2QoYSwgYiwgYywgZCwgZylcbiAgICAgIH0sIGcpXG4gICAgfSlcbiAgfVxufVxuZnVuY3Rpb24gcGQoYSwgYiwgYykge1xuICBmdW5jdGlvbiBkKGEsIGIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmLmRlYnVnKFwiVGVzdExvYWRJbWFnZTogXCIgKyBiKSwgZy5vbmxvYWQgPSBudWxsLCBnLm9uZXJyb3IgPSBudWxsLCBnLm9uYWJvcnQgPSBudWxsLCBnLm9udGltZW91dCA9IG51bGwsIHEuY2xlYXJUaW1lb3V0KGgpLCBjKGEpXG4gICAgICB9Y2F0Y2goZCkge1xuICAgICAgICB4YyhmLCBkKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgZiA9IG5ldyBYO1xuICBmLmRlYnVnKFwiVGVzdExvYWRJbWFnZTogbG9hZGluZyBcIiArIGEpO1xuICB2YXIgZyA9IG5ldyBJbWFnZSwgaCA9IG51bGw7XG4gIGcub25sb2FkID0gZCghMCwgXCJsb2FkZWRcIik7XG4gIGcub25lcnJvciA9IGQoITEsIFwiZXJyb3JcIik7XG4gIGcub25hYm9ydCA9IGQoITEsIFwiYWJvcnRcIik7XG4gIGcub250aW1lb3V0ID0gZCghMSwgXCJ0aW1lb3V0XCIpO1xuICBoID0gcS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGlmKGcub250aW1lb3V0KSB7XG4gICAgICBnLm9udGltZW91dCgpXG4gICAgfVxuICB9LCBiKTtcbiAgZy5zcmMgPSBhXG59XG47ZnVuY3Rpb24gcWQoYSwgYikge1xuICB0aGlzLmIgPSBhO1xuICB0aGlzLmEgPSBiO1xuICB0aGlzLlAgPSBuZXcgZ2QobnVsbCwgITApXG59XG5wID0gcWQucHJvdG90eXBlO1xucC52ID0gbnVsbDtcbnAuQSA9IG51bGw7XG5wLlVhID0gITE7XG5wLmFjID0gbnVsbDtcbnAuS2EgPSBudWxsO1xucC5uYiA9IG51bGw7XG5wLkggPSBudWxsO1xucC5jID0gbnVsbDtcbnAuaCA9IC0xO1xucC5MID0gbnVsbDtcbnAud2EgPSBudWxsO1xucC5ZID0gbShcInZcIik7XG5wLlpiID0gbShcIlBcIik7XG5wLmdiID0gZnVuY3Rpb24oYSkge1xuICB0aGlzLkggPSBhO1xuICBhID0gcmQodGhpcy5iLCB0aGlzLkgpO1xuICBUKHNkKTtcbiAgdGhpcy5hYyA9IHgoKTtcbiAgdmFyIGIgPSB0aGlzLmIuQ2I7XG4gIG51bGwgIT0gYiA/ICh0aGlzLkwgPSB0aGlzLmIuY29ycmVjdEhvc3RQcmVmaXgoYlswXSksICh0aGlzLndhID0gYlsxXSkgPyAodGhpcy5jID0gMSwgdGQodGhpcykpIDogKHRoaXMuYyA9IDIsIHVkKHRoaXMpKSkgOiAocWIoYSwgXCJNT0RFXCIsIFwiaW5pdFwiKSwgdGhpcy5BID0gbmV3IFEodGhpcywgdGhpcy5hLCB2b2lkIDAsIHZvaWQgMCwgdm9pZCAwKSwgdGhpcy5BLlkodGhpcy52KSwgaGModGhpcy5BLCBhLCAhMSwgbnVsbCwgITApLCB0aGlzLmMgPSAwKVxufTtcbmZ1bmN0aW9uIHRkKGEpIHtcbiAgdmFyIGIgPSB2ZChhLmIsIGEud2EsIFwiL21haWwvaW1hZ2VzL2NsZWFyZG90LmdpZlwiKTtcbiAgSihiKTtcbiAgb2QoYi50b1N0cmluZygpLCA1RTMsIHcoYS5pYywgYSksIDMsIDJFMyk7XG4gIGEuRyhqYylcbn1cbnAuaWMgPSBmdW5jdGlvbihhKSB7XG4gIGlmKGEpIHtcbiAgICB0aGlzLmMgPSAyLCB1ZCh0aGlzKVxuICB9ZWxzZSB7XG4gICAgVCh3ZCk7XG4gICAgdmFyIGIgPSB0aGlzLmI7XG4gICAgYi5hLmRlYnVnKFwiVGVzdCBDb25uZWN0aW9uIEJsb2NrZWRcIik7XG4gICAgYi5oID0gYi5VLmg7XG4gICAgWihiLCA5KVxuICB9XG4gIGEgJiYgdGhpcy5HKHBjKVxufTtcbmZ1bmN0aW9uIHVkKGEpIHtcbiAgYS5hLmRlYnVnKFwiVGVzdENvbm5lY3Rpb246IHN0YXJ0aW5nIHN0YWdlIDJcIik7XG4gIGEuQSA9IG5ldyBRKGEsIGEuYSwgdm9pZCAwLCB2b2lkIDAsIHZvaWQgMCk7XG4gIGEuQS5ZKGEudik7XG4gIHZhciBiID0geGQoYS5iLCBhLkwsIGEuSCk7XG4gIFQoeWQpO1xuICBpZihlYygpKSB7XG4gICAgcWIoYiwgXCJUWVBFXCIsIFwieG1saHR0cFwiKSwgaGMoYS5BLCBiLCAhMSwgYS5MLCAhMSlcbiAgfWVsc2Uge1xuICAgIHFiKGIsIFwiVFlQRVwiLCBcImh0bWxcIik7XG4gICAgdmFyIGMgPSBhLkE7XG4gICAgYSA9IEJvb2xlYW4oYS5MKTtcbiAgICBjLnNhID0gMztcbiAgICBjLlQgPSBKKGIubigpKTtcbiAgICBDYyhjLCBhKVxuICB9XG59XG5wLmhiID0gZnVuY3Rpb24oYSkge1xuICByZXR1cm4gdGhpcy5iLmhiKGEpXG59O1xucC5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLkEgJiYgKHRoaXMuQS5jYW5jZWwoKSwgdGhpcy5BID0gbnVsbCk7XG4gIHRoaXMuaCA9IC0xXG59O1xucC5IYiA9IGJhKCExKTtcbnAuUGIgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHRoaXMuaCA9IGEuaDtcbiAgaWYoMCA9PSB0aGlzLmMpIHtcbiAgICBpZih0aGlzLmEuZGVidWcoXCJUZXN0Q29ubmVjdGlvbjogR290IGRhdGEgZm9yIHN0YWdlIDFcIiksIGIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5QLnBhcnNlKGIpXG4gICAgICB9Y2F0Y2goZCkge1xuICAgICAgICB4Yyh0aGlzLmEsIGQpO1xuICAgICAgICB6ZCh0aGlzLmIsIHRoaXMpO1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRoaXMuTCA9IHRoaXMuYi5jb3JyZWN0SG9zdFByZWZpeChjWzBdKTtcbiAgICAgIHRoaXMud2EgPSBjWzFdXG4gICAgfWVsc2Uge1xuICAgICAgdGhpcy5hLmRlYnVnKFwiVGVzdENvbm5lY3Rpb246IE51bGwgcmVzcG9uc2VUZXh0XCIpLCB6ZCh0aGlzLmIsIHRoaXMpXG4gICAgfVxuICB9ZWxzZSB7XG4gICAgaWYoMiA9PSB0aGlzLmMpIHtcbiAgICAgIGlmKHRoaXMuVWEpIHtcbiAgICAgICAgVChBZCksIHRoaXMubmIgPSB4KClcbiAgICAgIH1lbHNlIHtcbiAgICAgICAgaWYoXCIxMTExMVwiID09IGIpIHtcbiAgICAgICAgICBpZihUKEJkKSwgdGhpcy5VYSA9ICEwLCB0aGlzLkthID0geCgpLCBjID0gdGhpcy5LYSAtIHRoaXMuYWMsIGVjKCkgfHwgNTAwID4gYykge1xuICAgICAgICAgICAgdGhpcy5oID0gMjAwLCB0aGlzLkEuY2FuY2VsKCksIHRoaXMuYS5kZWJ1ZyhcIlRlc3QgY29ubmVjdGlvbiBzdWNjZWVkZWQ7IHVzaW5nIHN0cmVhbWluZyBjb25uZWN0aW9uXCIpLCBUKENkKSwgRGQodGhpcy5iLCB0aGlzLCAhMClcbiAgICAgICAgICB9XG4gICAgICAgIH1lbHNlIHtcbiAgICAgICAgICBUKEVkKSwgdGhpcy5LYSA9IHRoaXMubmIgPSB4KCksIHRoaXMuVWEgPSAhMVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xucC5tYSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmggPSB0aGlzLkEuaDtcbiAgaWYoIXRoaXMuQS5KKSB7XG4gICAgdGhpcy5hLmRlYnVnKFwiVGVzdENvbm5lY3Rpb246IHJlcXVlc3QgZmFpbGVkLCBpbiBzdGF0ZSBcIiArIHRoaXMuYyksIDAgPT0gdGhpcy5jID8gVChGZCkgOiAyID09IHRoaXMuYyAmJiBUKEdkKSwgemQodGhpcy5iLCB0aGlzKVxuICB9ZWxzZSB7XG4gICAgaWYoMCA9PSB0aGlzLmMpIHtcbiAgICAgIHRoaXMuYS5kZWJ1ZyhcIlRlc3RDb25uZWN0aW9uOiByZXF1ZXN0IGNvbXBsZXRlIGZvciBpbml0aWFsIGNoZWNrXCIpLCB0aGlzLndhID8gKHRoaXMuYyA9IDEsIHRkKHRoaXMpKSA6ICh0aGlzLmMgPSAyLCB1ZCh0aGlzKSlcbiAgICB9ZWxzZSB7XG4gICAgICBpZigyID09IHRoaXMuYykge1xuICAgICAgICB0aGlzLmEuZGVidWcoXCJUZXN0Q29ubmVjdGlvbjogcmVxdWVzdCBjb21wbGV0ZSBmb3Igc3RhZ2UgMlwiKTtcbiAgICAgICAgdmFyIGEgPSAhMTtcbiAgICAgICAgKGEgPSBlYygpID8gdGhpcy5VYSA6IDIwMCA+IHRoaXMubmIgLSB0aGlzLkthID8gITEgOiAhMCkgPyAodGhpcy5hLmRlYnVnKFwiVGVzdCBjb25uZWN0aW9uIHN1Y2NlZWRlZDsgdXNpbmcgc3RyZWFtaW5nIGNvbm5lY3Rpb25cIiksIFQoQ2QpLCBEZCh0aGlzLmIsIHRoaXMsICEwKSkgOiAodGhpcy5hLmRlYnVnKFwiVGVzdCBjb25uZWN0aW9uIGZhaWxlZDsgbm90IHVzaW5nIHN0cmVhbWluZ1wiKSwgVChIZCksIERkKHRoaXMuYiwgdGhpcywgITEpKVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnAuWWEgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuYi5ZYSgpXG59O1xucC5pc0FjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5iLmlzQWN0aXZlKClcbn07XG5wLkcgPSBmdW5jdGlvbihhKSB7XG4gIHRoaXMuYi5HKGEpXG59O1xuZnVuY3Rpb24gSWQoYSwgYikge1xuICB0aGlzLnZiID0gYSB8fCBudWxsO1xuICB0aGlzLmMgPSBKZDtcbiAgdGhpcy5zID0gW107XG4gIHRoaXMuUSA9IFtdO1xuICB0aGlzLmEgPSBuZXcgWDtcbiAgdGhpcy5QID0gbmV3IGdkKG51bGwsICEwKTtcbiAgdGhpcy5DYiA9IGIgfHwgbnVsbFxufVxuZnVuY3Rpb24gS2QoYSwgYikge1xuICB0aGlzLkxiID0gYTtcbiAgdGhpcy5tYXAgPSBiO1xuICB0aGlzLkZjID0gbnVsbFxufVxucCA9IElkLnByb3RvdHlwZTtcbnAudiA9IG51bGw7XG5wLnhhID0gbnVsbDtcbnAubyA9IG51bGw7XG5wLmsgPSBudWxsO1xucC5IID0gbnVsbDtcbnAuTGEgPSBudWxsO1xucC51YiA9IG51bGw7XG5wLkwgPSBudWxsO1xucC5mYyA9ICEwO1xucC5BYSA9IDA7XG5wLnFjID0gMDtcbnAuSmEgPSAhMTtcbnAuZSA9IG51bGw7XG5wLkYgPSBudWxsO1xucC5NID0gbnVsbDtcbnAuYmEgPSBudWxsO1xucC5VID0gbnVsbDtcbnAucmIgPSBudWxsO1xucC5lYyA9ICEwO1xucC55YSA9IC0xO1xucC5LYiA9IC0xO1xucC5oID0gLTE7XG5wLlYgPSAwO1xucC5nYSA9IDA7XG5wLmdjID0gNUUzO1xucC5CYyA9IDFFNDtcbnAua2IgPSAyO1xucC5EYiA9IDJFNDtcbnAub2EgPSAwO1xucC5aYSA9ICExO1xucC5oYSA9IDg7XG52YXIgSmQgPSAxLCBMZCA9IG5ldyBTYjtcbmZ1bmN0aW9uIE1kKGEsIGIpIHtcbiAgTi5jYWxsKHRoaXMsIFwic3RhdGV2ZW50XCIsIGEpO1xuICB0aGlzLlBjID0gYlxufVxueShNZCwgTik7XG5mdW5jdGlvbiBOZChhLCBiLCBjLCBkKSB7XG4gIE4uY2FsbCh0aGlzLCBcInRpbWluZ2V2ZW50XCIsIGEpO1xuICB0aGlzLnNpemUgPSBiO1xuICB0aGlzLk5jID0gYztcbiAgdGhpcy5NYyA9IGRcbn1cbnkoTmQsIE4pO1xudmFyIGpjID0gMSwgcGMgPSAyLCBvYyA9IDMsIEZjID0gNDtcbmZ1bmN0aW9uIE9kKGEsIGIpIHtcbiAgTi5jYWxsKHRoaXMsIFwic2VydmVycmVhY2hhYmlsaXR5XCIsIGEpO1xuICB0aGlzLkxjID0gYlxufVxueShPZCwgTik7XG52YXIgc2QgPSAzLCB3ZCA9IDQsIHlkID0gNSwgQmQgPSA2LCBBZCA9IDcsIEVkID0gOCwgRmQgPSA5LCBHZCA9IDEwLCBIZCA9IDExLCBDZCA9IDEyLCB1YyA9IDEzLCB2YyA9IDE0LCB6YyA9IDE1LCBBYyA9IDE2LCBCYyA9IDE3LCBIYyA9IDE4LCBEYyA9IDIyLCBmZCA9IFwieTJmJVwiO1xucCA9IElkLnByb3RvdHlwZTtcbnAuZ2IgPSBmdW5jdGlvbihhLCBiLCBjLCBkLCBmKSB7XG4gIHRoaXMuYS5kZWJ1ZyhcImNvbm5lY3QoKVwiKTtcbiAgVCgwKTtcbiAgdGhpcy5IID0gYjtcbiAgdGhpcy54YSA9IGMgfHwge307XG4gIGQgJiYgdm9pZCAwICE9PSBmICYmICh0aGlzLnhhLk9TSUQgPSBkLCB0aGlzLnhhLk9BSUQgPSBmKTtcbiAgdGhpcy5hLmRlYnVnKFwiY29ubmVjdFRlc3RfKClcIik7XG4gIFBkKHRoaXMpICYmICh0aGlzLlUgPSBuZXcgcWQodGhpcywgdGhpcy5hKSwgdGhpcy5VLlkodGhpcy52KSwgdGhpcy5VLlpiKHRoaXMuUCksIHRoaXMuVS5nYihhKSlcbn07XG5wLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5hLmRlYnVnKFwiZGlzY29ubmVjdCgpXCIpO1xuICBRZCh0aGlzKTtcbiAgaWYoMyA9PSB0aGlzLmMpIHtcbiAgICB2YXIgYSA9IHRoaXMuQWErKywgYiA9IHRoaXMuTGEubigpO1xuICAgIEkoYiwgXCJTSURcIiwgdGhpcy5aKTtcbiAgICBJKGIsIFwiUklEXCIsIGEpO1xuICAgIEkoYiwgXCJUWVBFXCIsIFwidGVybWluYXRlXCIpO1xuICAgIFJkKHRoaXMsIGIpO1xuICAgIGEgPSBuZXcgUSh0aGlzLCB0aGlzLmEsIHRoaXMuWiwgYSwgdm9pZCAwKTtcbiAgICBhLnNhID0gMjtcbiAgICBhLlQgPSBKKGIubigpKTtcbiAgICBiID0gbmV3IEltYWdlO1xuICAgIGIuc3JjID0gYS5UO1xuICAgIGIub25sb2FkID0gYi5vbmVycm9yID0gdyhhLmxjLCBhKTtcbiAgICBhLnBhID0geCgpO1xuICAgIGljKGEpXG4gIH1cbiAgVGQodGhpcylcbn07XG5mdW5jdGlvbiBRZChhKSB7XG4gIGEuVSAmJiAoYS5VLmFib3J0KCksIGEuVSA9IG51bGwpO1xuICBhLmsgJiYgKGEuay5jYW5jZWwoKSwgYS5rID0gbnVsbCk7XG4gIGEuTSAmJiAocS5jbGVhclRpbWVvdXQoYS5NKSwgYS5NID0gbnVsbCk7XG4gIFVkKGEpO1xuICBhLm8gJiYgKGEuby5jYW5jZWwoKSwgYS5vID0gbnVsbCk7XG4gIGEuRiAmJiAocS5jbGVhclRpbWVvdXQoYS5GKSwgYS5GID0gbnVsbClcbn1cbnAuWSA9IG0oXCJ2XCIpO1xucC4kYiA9IG0oXCJvYVwiKTtcbnAuSGIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIDAgPT0gdGhpcy5jXG59O1xucC5aYiA9IG0oXCJQXCIpO1xuZnVuY3Rpb24gVmQoYSkge1xuICBhLm8gfHwgYS5GIHx8IChhLkYgPSBVKHcoYS5SYiwgYSksIDApLCBhLlYgPSAwKVxufVxucC5SYiA9IGZ1bmN0aW9uKGEpIHtcbiAgdGhpcy5GID0gbnVsbDtcbiAgdGhpcy5hLmRlYnVnKFwic3RhcnRGb3J3YXJkQ2hhbm5lbF9cIik7XG4gIGlmKFBkKHRoaXMpKSB7XG4gICAgaWYodGhpcy5jID09IEpkKSB7XG4gICAgICBpZihhKSB7XG4gICAgICAgIHRoaXMuYS5JKFwiTm90IHN1cHBvc2VkIHRvIHJldHJ5IHRoZSBvcGVuXCIpXG4gICAgICB9ZWxzZSB7XG4gICAgICAgIHRoaXMuYS5kZWJ1ZyhcIm9wZW5fKClcIik7XG4gICAgICAgIHRoaXMuQWEgPSBNYXRoLmZsb29yKDFFNSAqIE1hdGgucmFuZG9tKCkpO1xuICAgICAgICBhID0gdGhpcy5BYSsrO1xuICAgICAgICB2YXIgYiA9IG5ldyBRKHRoaXMsIHRoaXMuYSwgXCJcIiwgYSwgdm9pZCAwKTtcbiAgICAgICAgYi5ZKHRoaXMudik7XG4gICAgICAgIHZhciBjID0gV2QodGhpcyksIGQgPSB0aGlzLkxhLm4oKTtcbiAgICAgICAgSShkLCBcIlJJRFwiLCBhKTtcbiAgICAgICAgdGhpcy52YiAmJiBJKGQsIFwiQ1ZFUlwiLCB0aGlzLnZiKTtcbiAgICAgICAgUmQodGhpcywgZCk7XG4gICAgICAgIGZjKGIsIGQsIGMpO1xuICAgICAgICB0aGlzLm8gPSBiO1xuICAgICAgICB0aGlzLmMgPSAyXG4gICAgICB9XG4gICAgfWVsc2Uge1xuICAgICAgMyA9PSB0aGlzLmMgJiYgKGEgPyBYZCh0aGlzLCBhKSA6IDAgPT0gdGhpcy5zLmxlbmd0aCA/IHRoaXMuYS5kZWJ1ZyhcInN0YXJ0Rm9yd2FyZENoYW5uZWxfIHJldHVybmVkOiBub3RoaW5nIHRvIHNlbmRcIikgOiB0aGlzLm8gPyB0aGlzLmEuSShcInN0YXJ0Rm9yd2FyZENoYW5uZWxfIHJldHVybmVkOiBjb25uZWN0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3NcIikgOiAoWGQodGhpcyksIHRoaXMuYS5kZWJ1ZyhcInN0YXJ0Rm9yd2FyZENoYW5uZWxfIGZpbmlzaGVkLCBzZW50IHJlcXVlc3RcIikpKVxuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIFhkKGEsIGIpIHtcbiAgdmFyIGMsIGQ7XG4gIGIgPyA2IDwgYS5oYSA/IChhLnMgPSBhLlEuY29uY2F0KGEucyksIGEuUS5sZW5ndGggPSAwLCBjID0gYS5BYSAtIDEsIGQgPSBXZChhKSkgOiAoYyA9IGIuQiwgZCA9IGIuWCkgOiAoYyA9IGEuQWErKywgZCA9IFdkKGEpKTtcbiAgdmFyIGYgPSBhLkxhLm4oKTtcbiAgSShmLCBcIlNJRFwiLCBhLlopO1xuICBJKGYsIFwiUklEXCIsIGMpO1xuICBJKGYsIFwiQUlEXCIsIGEueWEpO1xuICBSZChhLCBmKTtcbiAgYyA9IG5ldyBRKGEsIGEuYSwgYS5aLCBjLCBhLlYgKyAxKTtcbiAgYy5ZKGEudik7XG4gIGMuc2V0VGltZW91dChNYXRoLnJvdW5kKDAuNSAqIGEuRGIpICsgTWF0aC5yb3VuZCgwLjUgKiBhLkRiICogTWF0aC5yYW5kb20oKSkpO1xuICBhLm8gPSBjO1xuICBmYyhjLCBmLCBkKVxufVxuZnVuY3Rpb24gUmQoYSwgYikge1xuICBpZihhLmUpIHtcbiAgICB2YXIgYyA9IGEuZS5nZXRBZGRpdGlvbmFsUGFyYW1zKGEpO1xuICAgIGMgJiYgRShjLCBmdW5jdGlvbihhLCBjKSB7XG4gICAgICBJKGIsIGMsIGEpXG4gICAgfSlcbiAgfVxufVxuZnVuY3Rpb24gV2QoYSkge1xuICB2YXIgYiA9IE1hdGgubWluKGEucy5sZW5ndGgsIDFFMyksIGMgPSBbXCJjb3VudD1cIiArIGJdLCBkO1xuICA2IDwgYS5oYSAmJiAwIDwgYiA/IChkID0gYS5zWzBdLkxiLCBjLnB1c2goXCJvZnM9XCIgKyBkKSkgOiBkID0gMDtcbiAgZm9yKHZhciBmID0gMDtmIDwgYjtmKyspIHtcbiAgICB2YXIgZyA9IGEuc1tmXS5MYiwgaCA9IGEuc1tmXS5tYXAsIGcgPSA2ID49IGEuaGEgPyBmIDogZyAtIGQ7XG4gICAgdHJ5IHtcbiAgICAgIEUoaCwgZnVuY3Rpb24oYSwgYikge1xuICAgICAgICBjLnB1c2goXCJyZXFcIiArIGcgKyBcIl9cIiArIGIgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChhKSlcbiAgICAgIH0pXG4gICAgfWNhdGNoKG4pIHtcbiAgICAgIGMucHVzaChcInJlcVwiICsgZyArIFwiX3R5cGU9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoXCJfYmFkbWFwXCIpKSwgYS5lICYmIGEuZS5iYWRNYXBFcnJvcihhLCBoKVxuICAgIH1cbiAgfVxuICBhLlEgPSBhLlEuY29uY2F0KGEucy5zcGxpY2UoMCwgYikpO1xuICByZXR1cm4gYy5qb2luKFwiJlwiKVxufVxuZnVuY3Rpb24gWWQoYSkge1xuICBhLmsgfHwgYS5NIHx8IChhLnRiID0gMSwgYS5NID0gVSh3KGEuUWIsIGEpLCAwKSwgYS5nYSA9IDApXG59XG5mdW5jdGlvbiBaZChhKSB7XG4gIGlmKGEuayB8fCBhLk0pIHtcbiAgICByZXR1cm4gYS5hLkkoXCJSZXF1ZXN0IGFscmVhZHkgaW4gcHJvZ3Jlc3NcIiksICExXG4gIH1cbiAgaWYoMyA8PSBhLmdhKSB7XG4gICAgcmV0dXJuITFcbiAgfVxuICBhLmEuZGVidWcoXCJHb2luZyB0byByZXRyeSBHRVRcIik7XG4gIGEudGIrKztcbiAgYS5NID0gVSh3KGEuUWIsIGEpLCAkZChhLCBhLmdhKSk7XG4gIGEuZ2ErKztcbiAgcmV0dXJuITBcbn1cbnAuUWIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5NID0gbnVsbDtcbiAgaWYoUGQodGhpcykpIHtcbiAgICB0aGlzLmEuZGVidWcoXCJDcmVhdGluZyBuZXcgSHR0cFJlcXVlc3RcIik7XG4gICAgdGhpcy5rID0gbmV3IFEodGhpcywgdGhpcy5hLCB0aGlzLlosIFwicnBjXCIsIHRoaXMudGIpO1xuICAgIHRoaXMuay5ZKHRoaXMudik7XG4gICAgdGhpcy5rLiRiKHRoaXMub2EpO1xuICAgIHZhciBhID0gdGhpcy51Yi5uKCk7XG4gICAgSShhLCBcIlJJRFwiLCBcInJwY1wiKTtcbiAgICBJKGEsIFwiU0lEXCIsIHRoaXMuWik7XG4gICAgSShhLCBcIkNJXCIsIHRoaXMucmIgPyBcIjBcIiA6IFwiMVwiKTtcbiAgICBJKGEsIFwiQUlEXCIsIHRoaXMueWEpO1xuICAgIFJkKHRoaXMsIGEpO1xuICAgIGlmKGVjKCkpIHtcbiAgICAgIEkoYSwgXCJUWVBFXCIsIFwieG1saHR0cFwiKSwgaGModGhpcy5rLCBhLCAhMCwgdGhpcy5MLCAhMSlcbiAgICB9ZWxzZSB7XG4gICAgICBJKGEsIFwiVFlQRVwiLCBcImh0bWxcIik7XG4gICAgICB2YXIgYiA9IHRoaXMuaywgYyA9IEJvb2xlYW4odGhpcy5MKTtcbiAgICAgIGIuc2EgPSAzO1xuICAgICAgYi5UID0gSihhLm4oKSk7XG4gICAgICBDYyhiLCBjKVxuICAgIH1cbiAgICB0aGlzLmEuZGVidWcoXCJOZXcgUmVxdWVzdCBjcmVhdGVkXCIpXG4gIH1cbn07XG5mdW5jdGlvbiBQZChhKSB7XG4gIGlmKGEuZSkge1xuICAgIHZhciBiID0gYS5lLm9rVG9NYWtlUmVxdWVzdChhKTtcbiAgICBpZigwICE9IGIpIHtcbiAgICAgIHJldHVybiBhLmEuZGVidWcoXCJIYW5kbGVyIHJldHVybmVkIGVycm9yIGNvZGUgZnJvbSBva1RvTWFrZVJlcXVlc3RcIiksIFooYSwgYiksICExXG4gICAgfVxuICB9XG4gIHJldHVybiEwXG59XG5mdW5jdGlvbiBEZChhLCBiLCBjKSB7XG4gIGEuYS5kZWJ1ZyhcIlRlc3QgQ29ubmVjdGlvbiBGaW5pc2hlZFwiKTtcbiAgYS5yYiA9IGEuZWMgJiYgYztcbiAgYS5oID0gYi5oO1xuICBhLmEuZGVidWcoXCJjb25uZWN0Q2hhbm5lbF8oKVwiKTtcbiAgYS5qYyhKZCwgMCk7XG4gIGEuTGEgPSByZChhLCBhLkgpO1xuICBWZChhKVxufVxuZnVuY3Rpb24gemQoYSwgYikge1xuICBhLmEuZGVidWcoXCJUZXN0IENvbm5lY3Rpb24gRmFpbGVkXCIpO1xuICBhLmggPSBiLmg7XG4gIFooYSwgMilcbn1cbnAuUGIgPSBmdW5jdGlvbihhLCBiKSB7XG4gIGlmKDAgIT0gdGhpcy5jICYmICh0aGlzLmsgPT0gYSB8fCB0aGlzLm8gPT0gYSkpIHtcbiAgICBpZih0aGlzLmggPSBhLmgsIHRoaXMubyA9PSBhICYmIDMgPT0gdGhpcy5jKSB7XG4gICAgICBpZig3IDwgdGhpcy5oYSkge1xuICAgICAgICB2YXIgYztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjID0gdGhpcy5QLnBhcnNlKGIpXG4gICAgICAgIH1jYXRjaChkKSB7XG4gICAgICAgICAgYyA9IG51bGxcbiAgICAgICAgfVxuICAgICAgICBpZihzKGMpICYmIDMgPT0gYy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgZiA9IGM7XG4gICAgICAgICAgaWYoMCA9PSBmWzBdKSB7XG4gICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgIGlmKHRoaXMuYS5kZWJ1ZyhcIlNlcnZlciBjbGFpbXMgb3VyIGJhY2tjaGFubmVsIGlzIG1pc3NpbmcuXCIpLCB0aGlzLk0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmEuZGVidWcoXCJCdXQgd2UgYXJlIGN1cnJlbnRseSBzdGFydGluZyB0aGUgcmVxdWVzdC5cIilcbiAgICAgICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuaykge1xuICAgICAgICAgICAgICAgICAgaWYodGhpcy5rLnBhICsgM0UzIDwgdGhpcy5vLnBhKSB7XG4gICAgICAgICAgICAgICAgICAgIFVkKHRoaXMpLCB0aGlzLmsuY2FuY2VsKCksIHRoaXMuayA9IG51bGxcbiAgICAgICAgICAgICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgYVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuYS4kKFwiV2UgZG8gbm90IGhhdmUgYSBCYWNrQ2hhbm5lbCBlc3RhYmxpc2hlZFwiKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBaZCh0aGlzKTtcbiAgICAgICAgICAgICAgICBUKDE5KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgdGhpcy5LYiA9IGZbMV0sIGMgPSB0aGlzLktiIC0gdGhpcy55YSwgMCA8IGMgJiYgKGYgPSBmWzJdLCB0aGlzLmEuZGVidWcoZiArIFwiIGJ5dGVzIChpbiBcIiArIGMgKyBcIiBhcnJheXMpIGFyZSBvdXRzdGFuZGluZyBvbiB0aGUgQmFja0NoYW5uZWxcIiksIDM3NTAwID4gZiAmJiAodGhpcy5yYiAmJiAwID09IHRoaXMuZ2EpICYmICF0aGlzLmJhICYmICh0aGlzLmJhID0gVSh3KHRoaXMucmMsIHRoaXMpLCA2RTMpKSlcbiAgICAgICAgICB9XG4gICAgICAgIH1lbHNlIHtcbiAgICAgICAgICB0aGlzLmEuZGVidWcoXCJCYWQgUE9TVCByZXNwb25zZSBkYXRhIHJldHVybmVkXCIpLCBaKHRoaXMsIDExKVxuICAgICAgICB9XG4gICAgICB9ZWxzZSB7XG4gICAgICAgIGIgIT0gZmQgJiYgKHRoaXMuYS5kZWJ1ZyhcIkJhZCBkYXRhIHJldHVybmVkIC0gbWlzc2luZy9pbnZhbGQgbWFnaWMgY29va2llXCIpLCBaKHRoaXMsIDExKSlcbiAgICAgIH1cbiAgICB9ZWxzZSB7XG4gICAgICBpZih0aGlzLmsgPT0gYSAmJiBVZCh0aGlzKSwgIS9eW1xcc1xceGEwXSokLy50ZXN0KGIpKSB7XG4gICAgICAgIGMgPSB0aGlzLlAucGFyc2UoYik7XG4gICAgICAgIGZvcih2YXIgZiA9IHRoaXMuZSAmJiB0aGlzLmUuY2hhbm5lbEhhbmRsZU11bHRpcGxlQXJyYXlzID8gW10gOiBudWxsLCBnID0gMDtnIDwgYy5sZW5ndGg7ZysrKSB7XG4gICAgICAgICAgdmFyIGggPSBjW2ddO1xuICAgICAgICAgIHRoaXMueWEgPSBoWzBdO1xuICAgICAgICAgIGggPSBoWzFdO1xuICAgICAgICAgIDIgPT0gdGhpcy5jID8gXCJjXCIgPT0gaFswXSA/ICh0aGlzLlogPSBoWzFdLCB0aGlzLkwgPSB0aGlzLmNvcnJlY3RIb3N0UHJlZml4KGhbMl0pLCBoID0gaFszXSwgdGhpcy5oYSA9IG51bGwgIT0gaCA/IGggOiA2LCB0aGlzLmMgPSAzLCB0aGlzLmUgJiYgdGhpcy5lLmNoYW5uZWxPcGVuZWQodGhpcyksIHRoaXMudWIgPSB4ZCh0aGlzLCB0aGlzLkwsIHRoaXMuSCksIFlkKHRoaXMpKSA6IFwic3RvcFwiID09IGhbMF0gJiYgWih0aGlzLCA3KSA6IDMgPT0gdGhpcy5jICYmIChcInN0b3BcIiA9PSBoWzBdID8gKGYgJiYgZi5sZW5ndGggJiYgKHRoaXMuZS5jaGFubmVsSGFuZGxlTXVsdGlwbGVBcnJheXModGhpcywgZiksIGYubGVuZ3RoID0gMCksIFoodGhpcywgNykpIDogXCJub29wXCIgIT0gaFswXSAmJiAoZiA/IGYucHVzaChoKSA6IHRoaXMuZSAmJiB0aGlzLmUuY2hhbm5lbEhhbmRsZUFycmF5KHRoaXMsIGgpKSwgdGhpcy5nYSA9IDApXG4gICAgICAgIH1cbiAgICAgICAgZiAmJiBmLmxlbmd0aCAmJiB0aGlzLmUuY2hhbm5lbEhhbmRsZU11bHRpcGxlQXJyYXlzKHRoaXMsIGYpXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xucC5jb3JyZWN0SG9zdFByZWZpeCA9IGZ1bmN0aW9uKGEpIHtcbiAgcmV0dXJuIHRoaXMuZmMgPyB0aGlzLmUgPyB0aGlzLmUuY29ycmVjdEhvc3RQcmVmaXgoYSkgOiBhIDogbnVsbFxufTtcbnAucmMgPSBmdW5jdGlvbigpIHtcbiAgbnVsbCAhPSB0aGlzLmJhICYmICh0aGlzLmJhID0gbnVsbCwgdGhpcy5rLmNhbmNlbCgpLCB0aGlzLmsgPSBudWxsLCBaZCh0aGlzKSwgVCgyMCkpXG59O1xuZnVuY3Rpb24gVWQoYSkge1xuICBudWxsICE9IGEuYmEgJiYgKHEuY2xlYXJUaW1lb3V0KGEuYmEpLCBhLmJhID0gbnVsbClcbn1cbnAubWEgPSBmdW5jdGlvbihhKSB7XG4gIHRoaXMuYS5kZWJ1ZyhcIlJlcXVlc3QgY29tcGxldGVcIik7XG4gIHZhciBiO1xuICBpZih0aGlzLmsgPT0gYSkge1xuICAgIFVkKHRoaXMpLCB0aGlzLmsgPSBudWxsLCBiID0gMlxuICB9ZWxzZSB7XG4gICAgaWYodGhpcy5vID09IGEpIHtcbiAgICAgIHRoaXMubyA9IG51bGwsIGIgPSAxXG4gICAgfWVsc2Uge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIHRoaXMuaCA9IGEuaDtcbiAgaWYoMCAhPSB0aGlzLmMpIHtcbiAgICBpZihhLkopIHtcbiAgICAgIDEgPT0gYiA/IChiID0geCgpIC0gYS5wYSwgTGQuZGlzcGF0Y2hFdmVudChuZXcgTmQoTGQsIGEuWCA/IGEuWC5sZW5ndGggOiAwLCBiLCB0aGlzLlYpKSwgVmQodGhpcyksIHRoaXMuUS5sZW5ndGggPSAwKSA6IFlkKHRoaXMpXG4gICAgfWVsc2Uge1xuICAgICAgdmFyIGMgPSBhLkViKCk7XG4gICAgICBpZigzID09IGMgfHwgNyA9PSBjIHx8IDAgPT0gYyAmJiAwIDwgdGhpcy5oKSB7XG4gICAgICAgIHRoaXMuYS5kZWJ1ZyhcIk5vdCByZXRyeWluZyBkdWUgdG8gZXJyb3IgdHlwZVwiKVxuICAgICAgfWVsc2Uge1xuICAgICAgICB0aGlzLmEuZGVidWcoXCJNYXliZSByZXRyeWluZywgbGFzdCBlcnJvcjogXCIgKyBiYyhjLCB0aGlzLmgpKTtcbiAgICAgICAgdmFyIGQ7XG4gICAgICAgIGlmKGQgPSAxID09IGIpIHtcbiAgICAgICAgICB0aGlzLm8gfHwgdGhpcy5GID8gKHRoaXMuYS5JKFwiUmVxdWVzdCBhbHJlYWR5IGluIHByb2dyZXNzXCIpLCBkID0gITEpIDogdGhpcy5jID09IEpkIHx8IHRoaXMuViA+PSAodGhpcy5KYSA/IDAgOiB0aGlzLmtiKSA/IGQgPSAhMSA6ICh0aGlzLmEuZGVidWcoXCJHb2luZyB0byByZXRyeSBQT1NUXCIpLCB0aGlzLkYgPSBVKHcodGhpcy5SYiwgdGhpcywgYSksICRkKHRoaXMsIHRoaXMuVikpLCB0aGlzLlYrKywgZCA9ICEwKVxuICAgICAgICB9XG4gICAgICAgIGlmKGQgfHwgMiA9PSBiICYmIFpkKHRoaXMpKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hLmRlYnVnKFwiRXhjZWVkZWQgbWF4IG51bWJlciBvZiByZXRyaWVzXCIpXG4gICAgICB9XG4gICAgICB0aGlzLmEuZGVidWcoXCJFcnJvcjogSFRUUCByZXF1ZXN0IGZhaWxlZFwiKTtcbiAgICAgIHN3aXRjaChjKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBaKHRoaXMsIDUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgWih0aGlzLCAxMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBaKHRoaXMsIDYpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgWih0aGlzLCAxMik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgWih0aGlzLCAyKVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uICRkKGEsIGIpIHtcbiAgdmFyIGMgPSBhLmdjICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYS5CYyk7XG4gIGEuaXNBY3RpdmUoKSB8fCAoYS5hLmRlYnVnKFwiSW5hY3RpdmUgY2hhbm5lbFwiKSwgYyAqPSAyKTtcbiAgcmV0dXJuIGMgKiBiXG59XG5wLmpjID0gZnVuY3Rpb24oYSkge1xuICBpZighKDAgPD0gWGEoYXJndW1lbnRzLCB0aGlzLmMpKSkge1xuICAgIHRocm93IEVycm9yKFwiVW5leHBlY3RlZCBjaGFubmVsIHN0YXRlOiBcIiArIHRoaXMuYyk7XG4gIH1cbn07XG5mdW5jdGlvbiBaKGEsIGIpIHtcbiAgYS5hLmluZm8oXCJFcnJvciBjb2RlIFwiICsgYik7XG4gIGlmKDIgPT0gYiB8fCA5ID09IGIpIHtcbiAgICB2YXIgYyA9IG51bGw7XG4gICAgYS5lICYmIChjID0gYS5lLmdldE5ldHdvcmtUZXN0SW1hZ2VVcmkoYSkpO1xuICAgIHZhciBkID0gdyhhLkRjLCBhKTtcbiAgICBjIHx8IChjID0gbmV3IEYoXCIvL3d3dy5nb29nbGUuY29tL2ltYWdlcy9jbGVhcmRvdC5naWZcIiksIEooYykpO1xuICAgIHBkKGMudG9TdHJpbmcoKSwgMUU0LCBkKVxuICB9ZWxzZSB7XG4gICAgVCgyKVxuICB9XG4gIGFlKGEsIGIpXG59XG5wLkRjID0gZnVuY3Rpb24oYSkge1xuICBhID8gKHRoaXMuYS5pbmZvKFwiU3VjY2Vzc2Z1bGx5IHBpbmdlZCBnb29nbGUuY29tXCIpLCBUKDIpKSA6ICh0aGlzLmEuaW5mbyhcIkZhaWxlZCB0byBwaW5nIGdvb2dsZS5jb21cIiksIFQoMSksIGFlKHRoaXMsIDgpKVxufTtcbmZ1bmN0aW9uIGFlKGEsIGIpIHtcbiAgYS5hLmRlYnVnKFwiSHR0cENoYW5uZWw6IGVycm9yIC0gXCIgKyBiKTtcbiAgYS5jID0gMDtcbiAgYS5lICYmIGEuZS5jaGFubmVsRXJyb3IoYSwgYik7XG4gIFRkKGEpO1xuICBRZChhKVxufVxuZnVuY3Rpb24gVGQoYSkge1xuICBhLmMgPSAwO1xuICBhLmggPSAtMTtcbiAgaWYoYS5lKSB7XG4gICAgaWYoMCA9PSBhLlEubGVuZ3RoICYmIDAgPT0gYS5zLmxlbmd0aCkge1xuICAgICAgYS5lLmNoYW5uZWxDbG9zZWQoYSlcbiAgICB9ZWxzZSB7XG4gICAgICBhLmEuZGVidWcoXCJOdW1iZXIgb2YgdW5kZWxpdmVyZWQgbWFwcywgcGVuZGluZzogXCIgKyBhLlEubGVuZ3RoICsgXCIsIG91dGdvaW5nOiBcIiArIGEucy5sZW5ndGgpO1xuICAgICAgdmFyIGIgPSAkYShhLlEpLCBjID0gJGEoYS5zKTtcbiAgICAgIGEuUS5sZW5ndGggPSAwO1xuICAgICAgYS5zLmxlbmd0aCA9IDA7XG4gICAgICBhLmUuY2hhbm5lbENsb3NlZChhLCBiLCBjKVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmQoYSwgYikge1xuICB2YXIgYyA9IHZkKGEsIG51bGwsIGIpO1xuICBhLmEuZGVidWcoXCJHZXRGb3J3YXJkQ2hhbm5lbFVyaTogXCIgKyBjKTtcbiAgcmV0dXJuIGNcbn1cbmZ1bmN0aW9uIHhkKGEsIGIsIGMpIHtcbiAgYiA9IHZkKGEsIGEuWWEoKSA/IGIgOiBudWxsLCBjKTtcbiAgYS5hLmRlYnVnKFwiR2V0QmFja0NoYW5uZWxVcmk6IFwiICsgYik7XG4gIHJldHVybiBiXG59XG5mdW5jdGlvbiB2ZChhLCBiLCBjKSB7XG4gIHZhciBkID0gYyBpbnN0YW5jZW9mIEYgPyBjLm4oKSA6IG5ldyBGKGMsIHZvaWQgMCk7XG4gIGlmKFwiXCIgIT0gZC5qYSkge1xuICAgIGIgJiYgZmIoZCwgYiArIFwiLlwiICsgZC5qYSksIGdiKGQsIGQuQmEpXG4gIH1lbHNlIHtcbiAgICB2YXIgZiA9IHdpbmRvdy5sb2NhdGlvbiwgZCA9IHNiKGYucHJvdG9jb2wsIGIgPyBiICsgXCIuXCIgKyBmLmhvc3RuYW1lIDogZi5ob3N0bmFtZSwgZi5wb3J0LCBjKVxuICB9XG4gIGEueGEgJiYgRShhLnhhLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgSShkLCBiLCBhKVxuICB9KTtcbiAgSShkLCBcIlZFUlwiLCBhLmhhKTtcbiAgUmQoYSwgZCk7XG4gIHJldHVybiBkXG59XG5wLmhiID0gZnVuY3Rpb24oYSkge1xuICBpZihhICYmICF0aGlzLlphKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJDYW4ndCBjcmVhdGUgc2Vjb25kYXJ5IGRvbWFpbiBjYXBhYmxlIFhocklvIG9iamVjdC5cIik7XG4gIH1cbiAgYSA9IG5ldyBoZDtcbiAgYS5jYyA9IHRoaXMuWmE7XG4gIHJldHVybiBhXG59O1xucC5pc0FjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4hIXRoaXMuZSAmJiB0aGlzLmUuaXNBY3RpdmUodGhpcylcbn07XG5mdW5jdGlvbiBVKGEsIGIpIHtcbiAgaWYoIWhhKGEpKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJGbiBtdXN0IG5vdCBiZSBudWxsIGFuZCBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gIH1cbiAgcmV0dXJuIHEuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBhKClcbiAgfSwgYilcbn1cbnAuRyA9IGZ1bmN0aW9uKGEpIHtcbiAgTGQuZGlzcGF0Y2hFdmVudChuZXcgT2QoTGQsIGEpKVxufTtcbmZ1bmN0aW9uIFQoYSkge1xuICBMZC5kaXNwYXRjaEV2ZW50KG5ldyBNZChMZCwgYSkpXG59XG5wLllhID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLlphIHx8ICFlYygpXG59O1xuZnVuY3Rpb24gYmUoKSB7XG59XG5wID0gYmUucHJvdG90eXBlO1xucC5jaGFubmVsSGFuZGxlTXVsdGlwbGVBcnJheXMgPSBudWxsO1xucC5va1RvTWFrZVJlcXVlc3QgPSBiYSgwKTtcbnAuY2hhbm5lbE9wZW5lZCA9IGUoKTtcbnAuY2hhbm5lbEhhbmRsZUFycmF5ID0gZSgpO1xucC5jaGFubmVsRXJyb3IgPSBlKCk7XG5wLmNoYW5uZWxDbG9zZWQgPSBlKCk7XG5wLmdldEFkZGl0aW9uYWxQYXJhbXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJue31cbn07XG5wLmdldE5ldHdvcmtUZXN0SW1hZ2VVcmkgPSBiYShudWxsKTtcbnAuaXNBY3RpdmUgPSBiYSghMCk7XG5wLmJhZE1hcEVycm9yID0gZSgpO1xucC5jb3JyZWN0SG9zdFByZWZpeCA9IGZ1bmN0aW9uKGEpIHtcbiAgcmV0dXJuIGFcbn07XG52YXIgJCwgY2UsIGRlID0gW10uc2xpY2U7XG5jZSA9IHswOlwiT2tcIiwgNDpcIlVzZXIgaXMgbG9nZ2luZyBvdXRcIiwgNjpcIlVua25vd24gc2Vzc2lvbiBJRFwiLCA3OlwiU3RvcHBlZCBieSBzZXJ2ZXJcIiwgODpcIkdlbmVyYWwgbmV0d29yayBlcnJvclwiLCAyOlwiUmVxdWVzdCBmYWlsZWRcIiwgOTpcIkJsb2NrZWQgYnkgYSBuZXR3b3JrIGFkbWluaXN0cmF0b3JcIiwgNTpcIk5vIGRhdGEgZnJvbSBzZXJ2ZXJcIiwgMTA6XCJHb3QgYmFkIGRhdGEgZnJvbSB0aGUgc2VydmVyXCIsIDExOlwiR290IGEgYmFkIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlclwifTtcbiQgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBjLCBkLCBmLCBnLCBoLCBuLCBrLCB0LCBsLCByO1xuICB0ID0gdGhpcztcbiAgYSB8fCAoYSA9IFwiY2hhbm5lbFwiKTtcbiAgYS5tYXRjaCgvOlxcL1xcLy8pICYmIGEucmVwbGFjZSgvXndzLywgXCJodHRwXCIpO1xuICBiIHx8IChiID0ge30pO1xuICBzKGIgfHwgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGIpICYmIChiID0ge30pO1xuICBuID0gYi5yZWNvbm5lY3RUaW1lIHx8IDNFMztcbiAgciA9IGZ1bmN0aW9uKGEpIHtcbiAgICB0LnJlYWR5U3RhdGUgPSB0LnJlYWR5U3RhdGUgPSBhXG4gIH07XG4gIHIodGhpcy5DTE9TRUQpO1xuICBsID0gbnVsbDtcbiAgZyA9IGIuS2M7XG4gIGMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYSwgYjtcbiAgICBiID0gYXJndW1lbnRzWzBdO1xuICAgIGEgPSAyIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBkZS5jYWxsKGFyZ3VtZW50cywgMSkgOiBbXTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdFtiXSA/IHRbYl0uYXBwbHkodCwgYSkgOiB2b2lkIDBcbiAgICB9Y2F0Y2goYykge1xuICAgICAgdGhyb3cgYSA9IGMsIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBjb25zb2xlICYmIG51bGwgIT09IGNvbnNvbGUgJiYgY29uc29sZS5lcnJvcihhLnN0YWNrKSwgYTtcbiAgICB9XG4gIH07XG4gIGQgPSBuZXcgYmU7XG4gIGQuY2hhbm5lbE9wZW5lZCA9IGZ1bmN0aW9uKCkge1xuICAgIGcgPSBsO1xuICAgIHIoJC5PUEVOKTtcbiAgICByZXR1cm4gYyhcIm9ub3BlblwiKVxuICB9O1xuICBmID0gbnVsbDtcbiAgZC5jaGFubmVsRXJyb3IgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIGQ7XG4gICAgZCA9IGNlW2JdO1xuICAgIGYgPSBiO1xuICAgIHIoJC5jYik7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjKFwib25lcnJvclwiLCBkLCBiKVxuICAgIH1jYXRjaChnKSB7XG4gICAgfVxuICB9O1xuICBrID0gbnVsbDtcbiAgZC5jaGFubmVsQ2xvc2VkID0gZnVuY3Rpb24oYSwgZCwgZykge1xuICAgIGlmKHQucmVhZHlTdGF0ZSAhPT0gJC5DTE9TRUQpIHtcbiAgICAgIGwgPSBudWxsO1xuICAgICAgYSA9IGYgPyBjZVtmXSA6IFwiQ2xvc2VkXCI7XG4gICAgICByKCQuQ0xPU0VEKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGMoXCJvbmNsb3NlXCIsIGEsIGQsIGcpXG4gICAgICB9Y2F0Y2goZWUpIHtcbiAgICAgIH1cbiAgICAgIGIucmVjb25uZWN0ICYmICg3ICE9PSBmICYmIDAgIT09IGYpICYmIChkID0gNiA9PT0gZiA/IDAgOiBuLCBjbGVhclRpbWVvdXQoayksIGsgPSBzZXRUaW1lb3V0KGgsIGQpKTtcbiAgICAgIHJldHVybiBmID0gbnVsbFxuICAgIH1cbiAgfTtcbiAgZC5jaGFubmVsSGFuZGxlQXJyYXkgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGMoXCJvbm1lc3NhZ2VcIiwgYilcbiAgfTtcbiAgaCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmKGwpIHtcbiAgICAgIHRocm93IEVycm9yKFwiUmVjb25uZWN0KCkgY2FsbGVkIGZyb20gaW52YWxpZCBzdGF0ZVwiKTtcbiAgICB9XG4gICAgcigkLkNPTk5FQ1RJTkcpO1xuICAgIGMoXCJvbmNvbm5lY3RpbmdcIik7XG4gICAgY2xlYXJUaW1lb3V0KGspO1xuICAgIGwgPSBuZXcgSWQoYi5hcHBWZXJzaW9uLCBudWxsICE9IGcgPyBnLkNiIDogdm9pZCAwKTtcbiAgICBiLmNyb3NzRG9tYWluWGhyICYmIChsLlphID0gITApO1xuICAgIGwuZSA9IGQ7XG4gICAgZiA9IG51bGw7XG4gICAgaWYoYi5mYWlsRmFzdCkge1xuICAgICAgdmFyIGggPSBsO1xuICAgICAgaC5KYSA9ICEwO1xuICAgICAgaC5hLmluZm8oXCJzZXRGYWlsRmFzdDogdHJ1ZVwiKTtcbiAgICAgIChoLm8gfHwgaC5GKSAmJiBoLlYgPiAoaC5KYSA/IDAgOiBoLmtiKSAmJiAoaC5hLmluZm8oXCJSZXRyeSBjb3VudCBcIiArIGguViArIFwiID4gbmV3IG1heFJldHJpZXMgXCIgKyAoaC5KYSA/IDAgOiBoLmtiKSArIFwiLiBGYWlsIGltbWVkaWF0ZWx5IVwiKSwgaC5vID8gKGguby5jYW5jZWwoKSwgaC5tYShoLm8pKSA6IChxLmNsZWFyVGltZW91dChoLkYpLCBoLkYgPSBudWxsLCBaKGgsIDIpKSlcbiAgICB9XG4gICAgcmV0dXJuIGwuZ2IoXCJcIiArIGEgKyBcIi90ZXN0XCIsIFwiXCIgKyBhICsgXCIvYmluZFwiLCBiLmV4dHJhUGFyYW1zLCBudWxsICE9IGcgPyBnLlogOiB2b2lkIDAsIG51bGwgIT0gZyA/IGcueWEgOiB2b2lkIDApXG4gIH07XG4gIHRoaXMub3BlbiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmKHQucmVhZHlTdGF0ZSAhPT0gdC5DTE9TRUQpIHtcbiAgICAgIHRocm93IEVycm9yKFwiQWxyZWFkeSBvcGVuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gaCgpXG4gIH07XG4gIHRoaXMuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICBjbGVhclRpbWVvdXQoayk7XG4gICAgZiA9IDA7XG4gICAgaWYodC5yZWFkeVN0YXRlICE9PSAkLkNMT1NFRCkge1xuICAgICAgcmV0dXJuIHIoJC5jYiksIGwuZGlzY29ubmVjdCgpXG4gICAgfVxuICB9O1xuICB0aGlzLnNlbmRNYXAgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIGI7XG4gICAgaWYoKGIgPSB0LnJlYWR5U3RhdGUpID09PSAkLmNiIHx8IGIgPT09ICQuQ0xPU0VEKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkNhbm5vdCBzZW5kIHRvIGEgY2xvc2VkIGNvbm5lY3Rpb25cIik7XG4gICAgfVxuICAgIGIgPSBsO1xuICAgIGlmKDAgPT0gYi5jKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgb3BlcmF0aW9uOiBzZW5kaW5nIG1hcCB3aGVuIHN0YXRlIGlzIGNsb3NlZFwiKTtcbiAgICB9XG4gICAgMUUzID09IGIucy5sZW5ndGggJiYgYi5hLkkoXCJBbHJlYWR5IGhhdmUgMTAwMCBxdWV1ZWQgbWFwcyB1cG9uIHF1ZXVlaW5nIFwiICsgS2MoYSkpO1xuICAgIGIucy5wdXNoKG5ldyBLZChiLnFjKyssIGEpKTtcbiAgICAyICE9IGIuYyAmJiAzICE9IGIuYyB8fCBWZChiKVxuICB9O1xuICB0aGlzLnNlbmQgPSBmdW5jdGlvbihhKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZE1hcCh7SlNPTjpLYyhhKX0pXG4gIH07XG4gIGgoKTtcbiAgcmV0dXJuIHRoaXNcbn07XG4kLnByb3RvdHlwZS5DT05ORUNUSU5HID0gJC5DT05ORUNUSU5HID0gJC5DT05ORUNUSU5HID0gMDtcbiQucHJvdG90eXBlLk9QRU4gPSAkLk9QRU4gPSAkLk9QRU4gPSAxO1xuJC5wcm90b3R5cGUuQ0xPU0lORyA9ICQuQ0xPU0lORyA9ICQuY2IgPSAyO1xuJC5wcm90b3R5cGUuQ0xPU0VEID0gJC5DTE9TRUQgPSAkLkNMT1NFRCA9IDM7XG4oXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGV4cG9ydHMgJiYgbnVsbCAhPT0gZXhwb3J0cyA/IGV4cG9ydHMgOiB3aW5kb3cpLkJDU29ja2V0ID0gJDtcblxufSkoKTtcbiIsImV4cG9ydHMuc2V0dXAgPSBmdW5jdGlvbihsaWJyYXJ5KSB7XG4gIGxpYnJhcnkudmlldy5mbignc2VudGVuY2VDYXNlJywgZnVuY3Rpb24odGV4dCkge1xuICAgIHJldHVybiB0ZXh0ICYmICh0ZXh0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4dC5zbGljZSgxKSk7XG4gIH0pO1xufTtcblxuZXhwb3J0cy5yZWNvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgbW9kZWwuc2V0KCdoaWRlUmVjb25uZWN0JywgdHJ1ZSk7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgbW9kZWwuc2V0KCdoaWRlUmVjb25uZWN0JywgZmFsc2UpO1xuICB9LCAxMDAwKTtcbiAgbW9kZWwucmVjb25uZWN0KCk7XG59O1xuXG5leHBvcnRzLnJlbG9hZCA9IGZ1bmN0aW9uKCkge1xuICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG59OyIsIihmdW5jdGlvbihnbG9iYWwpe3ZhciByYWNlciA9IHJlcXVpcmUoJ3JhY2VyJylcbiAgLCB0cmFja3MgPSByZXF1aXJlKCd0cmFja3MnKVxuICAsIHNoYXJlZENyZWF0ZUFwcCA9IHJlcXVpcmUoJy4vYXBwJykuY3JlYXRlXG4gICwgZGVyYnlNb2RlbCA9IHJlcXVpcmUoJy4vZGVyYnkuTW9kZWwnKVxuICAsIERvbSA9IHJlcXVpcmUoJy4vRG9tJylcbiAgLCB2aWV3TW9kZWwgPSByZXF1aXJlKCcuL3ZpZXdNb2RlbCcpXG4gICwgcmVmcmVzaCA9IHJlcXVpcmUoJy4vcmVmcmVzaCcpXG5cbm1vZHVsZS5leHBvcnRzID0gZGVyYnlCcm93c2VyO1xuXG5mdW5jdGlvbiBkZXJieUJyb3dzZXIoZGVyYnkpIHtcbiAgLy8gVGhpcyBhc3N1bWVzIHRoYXQgb25seSBhIHNpbmdsZSBpbnN0YW5jZSBvZiB0aGlzIG1vZHVsZSBjYW4gcnVuIGF0IGEgdGltZSxcbiAgLy8gd2hpY2ggaXMgcmVhc29uYWJsZSBpbiB0aGUgYnJvd3Nlci4gVGhpcyBpcyB3cml0dGVuIGxpa2UgdGhpcyBzbyB0aGF0XG4gIC8vIHRoZSBERVJCWSBnbG9iYWwgY2FuIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZSB0ZW1wbGF0ZXMgYW5kIGRhdGEuXG4gIGdsb2JhbC5ERVJCWSA9IGRlcmJ5O1xuICBkZXJieS5jcmVhdGVBcHAgPSBjcmVhdGVBcHA7XG4gIGRlcmJ5LmluaXQgPSBpbml0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBcHAoYXBwTW9kdWxlKSB7XG4gIGlmIChkZXJieUJyb3dzZXIuY3JlYXRlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZGVyYnkuY3JlYXRlQXBwKCkgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGluIHRoZSBicm93c2VyJyk7XG4gIH0gZWxzZSB7XG4gICAgZGVyYnlCcm93c2VyLmNyZWF0ZWQgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGFwcCA9IHNoYXJlZENyZWF0ZUFwcCh0aGlzLCBhcHBNb2R1bGUpXG4gIGdsb2JhbC5ERVJCWS5hcHAgPSBhcHA7XG5cbiAgcmFjZXIub25jZSgnbW9kZWwnLCBmdW5jdGlvbihtb2RlbCkge1xuICAgIGFwcC5lbWl0KCdtb2RlbCcsIG1vZGVsKTtcbiAgfSk7XG5cbiAgLy8gQWRkcyBnZXQsIHBvc3QsIHB1dCwgZGVsLCBlbnRlciwgYW5kIGV4aXQgbWV0aG9kc1xuICAvLyBhcyB3ZWxsIGFzIGhpc3RvcnkgdG8gYXBwXG4gIHRyYWNrcy5zZXR1cChhcHAsIGNyZWF0ZVBhZ2UsIG9uUm91dGUpO1xuXG4gIG9uUmVuZGVyRXJyb3IgPSBmdW5jdGlvbihlcnIsIHVybCkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24gPSB1cmw7XG4gICAgfSwgMCk7XG4gICAgdGhyb3cgZXJyO1xuICB9XG5cbiAgZnVuY3Rpb24gUGFnZShhcHApIHtcbiAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICB0aGlzLm1vZGVsID0gYXBwLm1vZGVsO1xuICAgIHRoaXMuZG9tID0gYXBwLmRvbTtcbiAgICB0aGlzLmhpc3RvcnkgPSBhcHAuaGlzdG9yeTtcbiAgICB0aGlzLl92aWV3TW9kZWxzID0gW107XG4gICAgdGhpcy5fcm91dGluZyA9IGZhbHNlO1xuICB9XG4gIFBhZ2UucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG5zLCBjdHgpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY3R4ID0gbnM7XG4gICAgICAgIG5zID0gJyc7XG4gICAgICB9XG4gICAgICBjdHggfHwgKGN0eCA9IHt9KTtcbiAgICAgIGN0eC4kdXJsID0gdGhpcy5wYXJhbXMudXJsO1xuICAgICAgYXBwLnZpZXcucmVuZGVyKHRoaXMubW9kZWwsIG5zLCBjdHgpO1xuICAgICAgdGhpcy5fcm91dGluZyA9IGZhbHNlO1xuICAgICAgdHJhY2tzLnJlbmRlcih0aGlzLCB7XG4gICAgICAgIHVybDogdGhpcy5wYXJhbXMudXJsXG4gICAgICAsIHByZXZpb3VzOiB0aGlzLnBhcmFtcy5wcmV2aW91c1xuICAgICAgLCBtZXRob2Q6ICdlbnRlcidcbiAgICAgICwgbm9OYXZpZ2F0ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBvblJlbmRlckVycm9yKGVyciwgdGhpcy5wYXJhbXMudXJsKTtcbiAgICB9XG4gIH07XG4gIFBhZ2UucHJvdG90eXBlLmluaXQgPSB2aWV3TW9kZWwucGFnZUluaXQ7XG5cbiAgZnVuY3Rpb24gY3JlYXRlUGFnZSgpIHtcbiAgICByZXR1cm4gbmV3IFBhZ2UoYXBwKTtcbiAgfVxuICBmdW5jdGlvbiBvblJvdXRlKGNhbGxiYWNrLCBwYWdlLCBwYXJhbXMsIG5leHQsIGlzVHJhbnNpdGlvbmFsLCBkb25lKSB7XG4gICAgaWYgKCFhcHAuX2luaXRpYWxpemVkKSByZXR1cm47XG4gICAgdHJ5IHtcbiAgICAgIGlmIChpc1RyYW5zaXRpb25hbCkge1xuICAgICAgICBpZiAoY2FsbGJhY2subGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgY2FsbGJhY2socGFnZS5tb2RlbCwgcGFyYW1zLCBuZXh0LCBkb25lKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayhwYWdlLm1vZGVsLCBwYXJhbXMsIG5leHQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLm1ldGhvZCA9PT0gJ2VudGVyJyB8fCBwYXJhbXMubWV0aG9kID09PSAnZXhpdCcpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbChhcHAsIHBhZ2UubW9kZWwsIHBhcmFtcyk7XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXBhZ2UuX3JvdXRpbmcpIHtcbiAgICAgICAgdHJhY2tzLnJlbmRlcihwYWdlLCB7XG4gICAgICAgICAgdXJsOiBwYWdlLnBhcmFtcy5wcmV2aW91c1xuICAgICAgICAsIG1ldGhvZDogJ2V4aXQnXG4gICAgICAgICwgbm9OYXZpZ2F0ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgYXBwLnZpZXcuX2JlZm9yZVJvdXRlKCk7XG4gICAgICB9XG4gICAgICBwYWdlLl9yb3V0aW5nID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrKHBhZ2UsIHBhZ2UubW9kZWwsIHBhcmFtcywgbmV4dCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBvblJlbmRlckVycm9yKGVyciwgcGFnZS5wYXJhbXMudXJsKTtcbiAgICB9XG4gIH1cblxuICBhcHAucmVhZHkgPSBmdW5jdGlvbihmbikge1xuICAgIGlmIChhcHAuX2luaXRpYWxpemVkKSByZXR1cm4gZm4uY2FsbChhcHAucGFnZSwgYXBwLm1vZGVsKTtcbiAgICBhcHAub25jZSgncmVhZHknLCBmdW5jdGlvbigpIHtcbiAgICAgIGZuLmNhbGwoYXBwLnBhZ2UsIGFwcC5tb2RlbCk7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBhcHA7XG59XG5cbmZ1bmN0aW9uIGluaXQobW9kZWxCdW5kbGUsIGN0eCkge1xuICB2YXIgYXBwID0gZ2xvYmFsLkRFUkJZLmFwcFxuICAgICwgbnMgPSBjdHguJG5zXG4gICAgLCByZW5kZXJIYXNoID0gY3R4LiRyZW5kZXJIYXNoXG4gICAgLCBkZXJieSA9IHRoaXNcblxuICAvLyBUaGUgcmVhZHkgZXZlbnQgaXMgZmlyZWQgYWZ0ZXIgdGhlIG1vZGVsIGRhdGEgaXMgaW5pdGlhbGl6ZWRcbiAgcmFjZXIucmVhZHkoZnVuY3Rpb24obW9kZWwpIHtcbiAgICB2YXIgZG9tID0gbmV3IERvbShtb2RlbCk7XG5cbiAgICBhcHAubW9kZWwgPSBtb2RlbDtcbiAgICBhcHAuZG9tID0gZG9tO1xuXG4gICAgLy8gQ2FsbGluZyBoaXN0b3J5LnBhZ2UoKSBjcmVhdGVzIHRoZSBpbml0aWFsIHBhZ2UsIHdoaWNoIGlzIG9ubHlcbiAgICAvLyBjcmVhdGVkIG9uZSB0aW1lIG9uIHRoZSBjbGllbnRcbiAgICAvLyBUT0RPOiBUaGlzIGlzIGEgcmF0aGVyIG9idHVzZSBtZWNoYW5pc21cbiAgICB2YXIgcGFnZSA9IGFwcC5oaXN0b3J5LnBhZ2UoKTtcbiAgICBhcHAucGFnZSA9IHBhZ2U7XG4gICAgcGFnZS5tb2RlbCA9IG1vZGVsO1xuICAgIHBhZ2UuZG9tID0gZG9tO1xuXG4gICAgLy8gUmVpbml0aWFsaXplIGFueSB2aWV3TW9kZWxzIHdoaWNoIHdlcmUgYWxyZWFkeSBpbml0aWFsaXplZFxuICAgIC8vIGR1cmluZyByZW5kZXJpbmcgb24gdGhlIHNlcnZlclxuICAgIGlmIChjdHguJHZpZXdNb2RlbHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3R4LiR2aWV3TW9kZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gY3R4LiR2aWV3TW9kZWxzW2ldO1xuICAgICAgICB2YXIgdmlld01vZGVsID0gYXBwLl92aWV3TW9kZWxzW2l0ZW1bMF1dO1xuICAgICAgICBpdGVtWzFdLnVuc2hpZnQocGFnZSk7XG4gICAgICAgIHZpZXdNb2RlbC5pbml0LmFwcGx5KHZpZXdNb2RlbCwgaXRlbVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVyYnlNb2RlbC5pbml0KGRlcmJ5LCBhcHApO1xuICAgIC8vIENhdGNoIGVycm9ycyB0aHJvd24gd2hlbiByZW5kZXJpbmcgYW5kIHRoZW4gdGhyb3cgZnJvbSBhIHNldFRpbWVvdXQuXG4gICAgLy8gVGhpcyB3YXksIHRoZSByZW1haW5pbmcgaW5pdCBjb2RlIGNhbiBydW4gYW5kIHRoZSBhcHAgc3RpbGwgY29ubmVjdHNcbiAgICB0cnkge1xuICAgICAgLy8gUmVuZGVyIGltbWVkaWF0ZWx5IHVwb24gaW5pdGlhbGl6YXRpb24gc28gdGhhdCB0aGUgcGFnZSBpcyBpblxuICAgICAgLy8gRVhBQ1RMWSB0aGUgc2FtZSBzdGF0ZSBpdCB3YXMgd2hlbiByZW5kZXJlZCBvbiB0aGUgc2VydmVyXG4gICAgICBhcHAudmlldy5yZW5kZXIobW9kZWwsIG5zLCBjdHgsIHJlbmRlckhhc2gpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICAgIGFwcC5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgYXBwLmVtaXQoJ3JlYWR5Jyk7XG5cbiAgICB0cmFja3MucmVuZGVyKGFwcC5oaXN0b3J5LnBhZ2UoKSwge1xuICAgICAgdXJsOiB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoXG4gICAgLCBtZXRob2Q6ICdlbnRlcidcbiAgICAsIG5vTmF2aWdhdGU6IHRydWVcbiAgICB9KTtcblxuICAgIC8vIERlbGF5aW5nIGhlcmUgdG8gbWFrZSBzdXJlIHRoYXQgYWxsIHJlYWR5IGNhbGxiYWNrcyBhcmUgY2FsbGVkIGJlZm9yZVxuICAgIC8vIHRoZSBjcmVhdGUgZnVuY3Rpb25zIHJ1biBvbiB2YXJpb3VzIGNvbXBvbmVudHNcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgYXBwLnZpZXcuX2FmdGVyUmVuZGVyKG5zLCBjdHgpO1xuICAgIH0sIDApO1xuXG4gICAgaWYgKGN0eC4kc2NyaXB0UGF0aCkge1xuICAgICAgbW9kZWwuY2hhbm5lbC5zZW5kKCdkZXJieTphcHAnLCBjdHguJHNjcmlwdFBhdGgpO1xuICAgICAgcmVmcmVzaC5hdXRvUmVmcmVzaChhcHAudmlldywgbW9kZWwpO1xuICAgIH1cbiAgfSk7XG4gIHJhY2VyLmluaXQobW9kZWxCdW5kbGUpO1xufVxuXG59KSh3aW5kb3cpIiwidmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciByYWNlciA9IHJlcXVpcmUoJ3JhY2VyJyk7XG52YXIgY29tcG9uZW50ID0gcmVxdWlyZSgnLi9jb21wb25lbnQnKTtcbnZhciBWaWV3ID0gcmVxdWlyZSgnLi9WaWV3Jyk7XG52YXIgdmlld01vZGVsID0gcmVxdWlyZSgnLi92aWV3TW9kZWwnKTtcbnZhciBpc1NlcnZlciA9IHJhY2VyLnV0aWwuaXNTZXJ2ZXI7XG52YXIgcGF0aHMgPSByZXF1aXJlKCcuL3BhdGhzJyk7XG5cbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlQXBwO1xuXG5mdW5jdGlvbiBjcmVhdGVBcHAoZGVyYnksIGFwcE1vZHVsZSkge1xuICB2YXIgYXBwID0gcmFjZXIudXRpbC5tZXJnZUludG8oYXBwTW9kdWxlLmV4cG9ydHMsIEV2ZW50RW1pdHRlci5wcm90b3R5cGUpXG5cbiAgYXBwLnVzZSA9IHJhY2VyLnV0aWwudXNlO1xuICBjb21wb25lbnQoYXBwKTtcbiAgYXBwLmZpbGVuYW1lID0gYXBwTW9kdWxlLmZpbGVuYW1lO1xuICBhcHAudmlldyA9IG5ldyBWaWV3KGFwcC5fbGlicmFyaWVzLCBhcHAsIGFwcE1vZHVsZS5maWxlbmFtZSk7XG4gIGFwcC5mbiA9IGFwcEZuO1xuXG4gIGZ1bmN0aW9uIGFwcEZuKHZhbHVlLCBmbikge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBEb24ndCBiaW5kIHRoZSBmdW5jdGlvbiBvbiB0aGUgc2VydmVyLCBzaW5jZSBlYWNoXG4gICAgICAvLyByZW5kZXIgZ2V0cyBwYXNzZWQgYSBuZXcgbW9kZWwgYXMgcGFydCBvZiB0aGUgYXBwXG4gICAgICBwYXRocy5wYXRoTWVyZ2UoYXBwLCB2YWx1ZSwgZm4sIGJpbmRQYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aHMudHJlZU1lcmdlKGFwcCwgdmFsdWUsIGJpbmRQYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIGFwcDtcbiAgfVxuXG4gIGlmICghaXNTZXJ2ZXIpIHtcbiAgICB2YXIgYmluZFBhZ2UgPSBmdW5jdGlvbihmbikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkoYXBwLnBhZ2UsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICBhcHAuX3ZpZXdNb2RlbHMgPSB7fTtcbiAgYXBwLnZpZXdNb2RlbCA9IHZpZXdNb2RlbC5jb25zdHJ1Y3QuYmluZChhcHApO1xuXG4gIHJldHVybiBhcHA7XG59XG4iLCJ2YXIgcGF0aHMgPSByZXF1aXJlKCcuL3BhdGhzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFxufTtcblxuZnVuY3Rpb24gVmlld01vZGVsKG5hbWUsIHByb3RvKSB7XG4gIHRoaXMubmFtZSA9IG5hbWU7XG4gIHRoaXMucHJvdG8gPSBwcm90bztcbn1cblZpZXdNb2RlbC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKHBhZ2UpIHtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAvLyBWaWV3TW9kZWxzIGFyZSBhY3R1YWxseSBqdXN0IHNjb3BlZCBtb2RlbHMgZm9yIG5vd1xuICB2YXIgX3N1cGVyID0gcGFnZS5tb2RlbC5hdCh0aGlzLm5hbWUpO1xuICB2YXIgdmlld01vZGVsID0gX3N1cGVyLl9jaGlsZCgpO1xuXG4gIC8vIE1peGluIHZpZXdNb2RlbCBzcGVjaWZpYyBtZXRob2RzXG4gIHZpZXdNb2RlbC5fc3VwZXIgPSBfc3VwZXI7XG4gIHZpZXdNb2RlbC5wYWdlID0gcGFnZTtcbiAgdmlld01vZGVsLm1vZGVsID0gcGFnZS5tb2RlbDtcbiAgZm9yIChrZXkgaW4gdGhpcy5wcm90bykge1xuICAgIGlmIChrZXkgPT09ICdpbml0JykgY29udGludWU7XG4gICAgdmlld01vZGVsW2tleV0gPSB0aGlzLnByb3RvW2tleV0uYmluZCh2aWV3TW9kZWwpO1xuICB9XG4gIGlmICh0aGlzLnByb3RvLmluaXQpIHtcbiAgICAvLyBLZWVwIHRyYWNrIG9mIHZpZXdNb2RlbHMgdGhhdCB3ZXJlIGNyZWF0ZWQgc28gdGhhdFxuICAgIC8vIHRoZXkgY2FuIGJlIHJlY3JlYXRlZCBvbiB0aGUgY2xpZW50IGlmIGZpcnN0IHJlbmRlcmVkXG4gICAgLy8gb24gdGhlIHNlcnZlclxuICAgIHBhZ2UuX3ZpZXdNb2RlbHMucHVzaChbdGhpcy5uYW1lLCBhcmdzXSk7XG4gICAgdGhpcy5wcm90by5pbml0LmFwcGx5KHZpZXdNb2RlbCwgYXJncyk7XG4gIH1cblxuICAvLyBNYWtlIHZpZXdNb2RlbCBhdmFpbGFibGUgb24gdGhlIHBhZ2UgZm9yIHVzZSBpblxuICAvLyBldmVudCBjYWxsYmFja3MgYW5kIG90aGVyIGZ1bmN0aW9uc1xuICB2YXIgc2VnbWVudHMgPSB0aGlzLm5hbWUuc3BsaXQoJy4nKTtcbiAgdmFyIGxhc3QgPSBzZWdtZW50cy5wb3AoKTtcbiAgdmFyIG5vZGUgPSBwYXRocy50cmF2ZXJzZU5vZGUocGFnZSwgc2VnbWVudHMpO1xuICBub2RlW2xhc3RdID0gdmlld01vZGVsO1xuXG4gIHJldHVybiB2aWV3TW9kZWw7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdChuYW1lLCBwcm90bykge1xuICAvLyBLZWVwIGEgbWFwIG9mIGRlZmluZWQgdmlld01vZGVscyBzbyB0aGF0IHRoZXkgY2FuXG4gIC8vIGJlIHJlaW5pdGlhbGl6ZWQgZnJvbSB0aGVpciBuYW1lIG9uIHRoZSBjbGllbnRcbiAgdmFyIHZpZXdNb2RlbCA9IHRoaXMuX3ZpZXdNb2RlbHNbbmFtZV0gPSBuZXcgVmlld01vZGVsKG5hbWUsIHByb3RvKTtcbiAgcmV0dXJuIHZpZXdNb2RlbDtcbn1cbiIsIihmdW5jdGlvbigpe3ZhciBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKCcuL0V2ZW50RGlzcGF0Y2hlcicpXG52YXIgUGF0aE1hcCA9IHJlcXVpcmUoJy4vUGF0aE1hcCcpXG52YXIgTW9kZWwgPSByZXF1aXJlKCdyYWNlcicpLk1vZGVsXG52YXIgdmFsdWVCaW5kaW5nID0gcmVxdWlyZSgnLi9WaWV3JykudmFsdWVCaW5kaW5nXG52YXIgYXJyYXlTbGljZSA9IFtdLnNsaWNlO1xuXG5leHBvcnRzLmluaXQgPSBpbml0O1xuXG4vLyBBZGQgc3VwcG9ydCBmb3IgY3JlYXRpbmcgYSBtb2RlbCBhbGlhcyBmcm9tIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IG9iamVjdFxuTW9kZWwucHJvdG90eXBlLl9fYXQgPSBNb2RlbC5wcm90b3R5cGUuYXQ7XG5Nb2RlbC5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHZhciBpc05vZGUgPSBub2RlICYmIChub2RlLnBhcmVudE5vZGUgfHwgbm9kZS5qcXVlcnkgJiYgKG5vZGUgPSBub2RlWzBdKSk7XG4gIGlmICghaXNOb2RlKSByZXR1cm4gdGhpcy5fX2F0KG5vZGUpO1xuXG4gIHVwZGF0ZU1hcmtlcnMoKTtcblxuICB2YXIgYmxvY2tQYXRocyA9IHRoaXMucm9vdC5fX2Jsb2NrUGF0aHNcbiAgICAsIHBhdGhNYXAgPSB0aGlzLnJvb3QuX19wYXRoTWFwXG4gICAgLCBjaGlsZCwgaSwgaWQsIGxhc3QsIHBhdGgsIGJsb2NrUGF0aCwgY2hpbGRyZW4sIGxlbjtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS4kZGVyYnlNYXJrZXJQYXJlbnQgJiYgbGFzdCkge1xuICAgICAgbm9kZSA9IGxhc3Q7XG4gICAgICB3aGlsZSAobm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgIGlmICghKGlkID0gbm9kZS4kZGVyYnlNYXJrZXJJZCkpIGNvbnRpbnVlO1xuICAgICAgICBibG9ja1BhdGggPSBibG9ja1BhdGhzW2lkXTtcbiAgICAgICAgaWYgKG5vZGUuJGRlcmJ5TWFya2VyRW5kIHx8ICFibG9ja1BhdGgpIGJyZWFrO1xuXG4gICAgICAgIHBhdGggPSBwYXRoTWFwLnBhdGhzW2Jsb2NrUGF0aC5pZF07XG4gICAgICAgIGlmICgoYmxvY2tQYXRoLnR5cGUgPT09ICdlYWNoJykgJiYgbGFzdCkge1xuICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgIHdoaWxlIChub2RlID0gbm9kZS5uZXh0U2libGluZykge1xuICAgICAgICAgICAgaWYgKG5vZGUgPT09IGxhc3QpIHtcbiAgICAgICAgICAgICAgcGF0aCA9IHBhdGggKyAnLicgKyBpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUocGF0aCk7XG4gICAgICB9XG4gICAgICBsYXN0ID0gbGFzdC5wYXJlbnROb2RlO1xuICAgICAgbm9kZSA9IGxhc3QucGFyZW50Tm9kZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoKGlkID0gbm9kZS5pZCkgJiYgKGJsb2NrUGF0aCA9IGJsb2NrUGF0aHNbaWRdKSkge1xuICAgICAgcGF0aCA9IHBhdGhNYXAucGF0aHNbYmxvY2tQYXRoLmlkXTtcbiAgICAgIGlmICgoYmxvY2tQYXRoLnR5cGUgPT09ICdlYWNoJykgJiYgbGFzdCkge1xuICAgICAgICBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgIGlmIChjaGlsZCA9PT0gbGFzdCkge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGggKyAnLicgKyBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zY29wZShwYXRoKTtcbiAgICB9XG4gICAgbGFzdCA9IG5vZGU7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfVxuXG4gIC8vIEp1c3QgcmV0dXJuIHRoZSByb290IHNjb3BlIGlmIGEgcGF0aCBjYW4ndCBiZSBmb3VuZFxuICByZXR1cm4gdGhpcy5zY29wZSgpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNYXJrZXJzKCkge1xuICAvLyBOb2RlRmlsdGVyLlNIT1dfQ09NTUVOVCA9PSAxMjhcbiAgdmFyIGNvbW1lbnRJdGVyYXRvciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoZG9jdW1lbnQuYm9keSwgMTI4LCBudWxsLCBmYWxzZSlcbiAgICAsIGNvbW1lbnQsIGlkO1xuICB3aGlsZSAoY29tbWVudCA9IGNvbW1lbnRJdGVyYXRvci5uZXh0Tm9kZSgpKSB7XG4gICAgaWYgKGNvbW1lbnQuJGRlcmJ5Q2hlY2tlZCkgY29udGludWU7XG4gICAgY29tbWVudC4kZGVyYnlDaGVja2VkID0gdHJ1ZTtcbiAgICBpZCA9IGNvbW1lbnQuZGF0YTtcbiAgICBpZiAoaWQuY2hhckF0KDApICE9PSAnJCcpIGNvbnRpbnVlO1xuICAgIGlmIChpZC5jaGFyQXQoMSkgPT09ICckJykge1xuICAgICAgY29tbWVudC4kZGVyYnlNYXJrZXJFbmQgPSB0cnVlO1xuICAgICAgaWQgPSBpZC5zbGljZSgxKTtcbiAgICB9XG4gICAgY29tbWVudC4kZGVyYnlNYXJrZXJJZCA9IGlkO1xuICAgIGNvbW1lbnQucGFyZW50Tm9kZS4kZGVyYnlNYXJrZXJQYXJlbnQgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXQoZGVyYnksIGFwcCkge1xuICB2YXIgbW9kZWwgPSBhcHAubW9kZWw7XG4gIHZhciBkb20gPSBhcHAuZG9tO1xuICB2YXIgcGF0aE1hcCA9IG1vZGVsLl9fcGF0aE1hcCA9IG5ldyBQYXRoTWFwO1xuICB2YXIgZXZlbnRzID0gbW9kZWwuX19ldmVudHMgPSBuZXcgRXZlbnREaXNwYXRjaGVyKHtcbiAgICBvblRyaWdnZXI6IGRlcmJ5TW9kZWxUcmlnZ2VyXG4gICwgb25DbGVhbnVwOiBkZXJieU1vZGVsRXZlbnRzQ2xlYW51cFxuICB9KTtcblxuICBmdW5jdGlvbiBkZXJieU1vZGVsRXZlbnRzQ2xlYW51cChwYXRoSWQsIGxpc3RlbmVyKSB7XG4gICAgdmFyIGlkID0gbGlzdGVuZXJbMF07XG4gICAgcmV0dXJuICFkb20uaXRlbShpZCk7XG4gIH1cblxuICBmdW5jdGlvbiBkZXJieU1vZGVsVHJpZ2dlcihwYXRoSWQsIGxpc3RlbmVyLCB0eXBlLCBwYXNzLCB2YWx1ZSwgaW5kZXgsIGFyZykge1xuICAgIHZhciBpZCA9IGxpc3RlbmVyWzBdXG4gICAgICAsIGVsID0gZG9tLml0ZW0oaWQpO1xuXG4gICAgLy8gSWdub3JlIGlmIHRoZSBlbGVtZW50IGNhbid0IGJlIGZvdW5kLCBhbmQgY2xlYW51cCBhZnRlciBzb21lIGRlbGF5XG4gICAgaWYgKCFlbCkgcmV0dXJuIGV2ZW50cy5kZWxheWVkQ2xlYW51cChwYXRoSWQpO1xuXG4gICAgdmFyIG1ldGhvZCA9IGxpc3RlbmVyWzFdXG4gICAgICAsIHByb3BlcnR5ID0gbGlzdGVuZXJbMl1cbiAgICAgICwgcGFydGlhbCA9IGxpc3RlbmVyLnBhcnRpYWxcbiAgICAgICwgcGF0aCA9IHBhdGhNYXAucGF0aHNbcGF0aElkXVxuICAgICAgLCB0cmlnZ2VySWQ7XG5cbiAgICAvLyBIYW5kbGUgdGV4dCBPVCBldmVudHNcbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZ0luc2VydCcgfHwgdHlwZSA9PT0gJ3N0cmluZ1JlbW92ZScpIHtcbiAgICAgIGlmIChtZXRob2QgIT09ICdwcm9wT3QnIHx8IGVsID09PSBwYXNzLiRlbCkgcmV0dXJuO1xuICAgICAgbWV0aG9kID0gdHlwZTtcbiAgICB9XG4gICAgLy8gSWdub3JlIHNpZGUtZWZmZWN0IGNoYW5nZSBldmVudHMgdGhhdCB3ZXJlIGFscmVhZHkgaGFuZGxlZFxuICAgIGlmIChtZXRob2QgPT09ICdwcm9wT3QnICYmIChwYXNzLiRvcmlnaW5hbCA9PT0gJ3N0cmluZ0luc2VydCcgfHwgcGFzcy4kb3JpZ2luYWwgPT09ICdzdHJpbmdSZW1vdmUnKSkgcmV0dXJuO1xuXG4gICAgaWYgKHBhcnRpYWwpIHtcbiAgICAgIHRyaWdnZXJJZCA9IGlkO1xuICAgICAgaWYgKG1ldGhvZCA9PT0gJ2h0bWwnICYmIHR5cGUpIHtcbiAgICAgICAgaWYgKHBhcnRpYWwudHlwZSA9PT0gJ2VhY2gnKSB7XG4gICAgICAgICAgLy8gSGFuZGxlIGFycmF5IHVwZGF0ZXNcbiAgICAgICAgICBtZXRob2QgPSB0eXBlO1xuICAgICAgICAgIGlmICh0eXBlID09PSAnaW5zZXJ0Jykge1xuICAgICAgICAgICAgdHJpZ2dlcklkID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdyZW1vdmUnKSB7XG4gICAgICAgICAgICBwYXJ0aWFsID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdtb3ZlJykge1xuICAgICAgICAgICAgcGFydGlhbCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gbW9kZWwuZ2V0KHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsaXN0ZW5lci5nZXRWYWx1ZSkge1xuICAgICAgdmFsdWUgPSBsaXN0ZW5lci5nZXRWYWx1ZShtb2RlbCwgcGF0aCk7XG4gICAgfVxuICAgIGlmIChwYXJ0aWFsKSB7XG4gICAgICAvLyBUT0RPIEdldCByaWQgb2YgbW9kZWwuX19mbkN0eCBjYWNoZVxuICAgICAgLy8gV2FzIGNhdXNpbmcgaXNzdWVzIHdpdGggbm90IGVtaXR0aW5nIFwiaW5pdDpjaGlsZFwiIG9yIFwiY3JlYXRlOmNoaWxkXCJcbiAgICAgIC8vIHdoZW4gZHluYW1pY2FsbHkgcmVuZGVyaW5nIGEgY29tcG9uZW50IGluc2lkZSBhIHBhcmVudCBjb21wb25lbnRcbiAgICAgIC8vIHdpdGhpbiBhbiBlYWNoIGJsb2NrLlxuICAgICAgZGVsZXRlIG1vZGVsLl9fZm5DdHg7XG5cbiAgICAgIGlmIChtZXRob2QgPT09ICdpbnNlcnQnKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhbHVlICs9IHBhcnRpYWwobGlzdGVuZXIuY3R4LCBtb2RlbCwgdHJpZ2dlcklkLCB2YWx1ZXNbaV0sIGluZGV4ICsgaSwgbGlzdGVuZXIpIHx8ICc8IS0tZW1wdHktLT4nO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHBhcnRpYWwobGlzdGVuZXIuY3R4LCBtb2RlbCwgdHJpZ2dlcklkLCB2YWx1ZSwgaW5kZXgsIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFsdWUgPSB2YWx1ZUJpbmRpbmcodmFsdWUpO1xuICAgIGRvbS51cGRhdGUoZWwsIG1ldGhvZCwgcGFzcy5pZ25vcmUsIHZhbHVlLCBwcm9wZXJ0eSwgaW5kZXgsIGFyZyk7XG4gICAgLy8gSEFDSzogVXNlIG9mIGdsb2JhbFxuICAgIERFUkJZLmFwcC52aWV3Ll9mbHVzaFVuY3JlYXRlZCgpO1xuICB9XG5cbiAgdmFyIHR5cGVzID0gT2JqZWN0LmtleXMoTW9kZWwuTVVUQVRPUl9FVkVOVFMpO1xuICB0eXBlcy5wdXNoKCdhbGwnKTtcbiAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbih0eXBlKSB7XG4gICAgdmFyIGJlZm9yZVR5cGUgPSAnYmVmb3JlQmluZGluZzonICsgdHlwZTtcbiAgICBtb2RlbC5vbih0eXBlLCBmdW5jdGlvbihzZWdtZW50cywgZXZlbnRBcmdzKSB7XG4gICAgICBtb2RlbC5lbWl0KGJlZm9yZVR5cGUsIHNlZ21lbnRzLCBldmVudEFyZ3MpO1xuICAgIH0pO1xuICB9KTtcblxuICBtb2RlbC5vbignY2hhbmdlJywgJyoqJywgZnVuY3Rpb24gZGVyYnlPbkNoYW5nZShwYXRoLCB2YWx1ZSwgcHJldmlvdXMsIHBhc3MpIHtcbiAgICAvLyBGb3Igc2V0IG9wZXJhdGlvbnMgb24gYXJyYXkgaXRlbXMsIGFsc28gZW1pdCBhIHJlbW92ZSBhbmQgaW5zZXJ0IGluIGNhc2UgdGhlXG4gICAgLy8gYXJyYXkgaXMgYm91bmRcbiAgICBpZiAoL1xcLlxcZCskLy50ZXN0KHBhdGgpKSB7XG4gICAgICB2YXIgaSA9IHBhdGgubGFzdEluZGV4T2YoJy4nKTtcbiAgICAgIHZhciBhcnJheVBhdGggPSBwYXRoLnNsaWNlKDAsIGkpO1xuICAgICAgdmFyIGluZGV4ID0gK3BhdGguc2xpY2UoaSArIDEpO1xuICAgICAgdHJpZ2dlckVhY2goYXJyYXlQYXRoLCAncmVtb3ZlJywgcGFzcywgaW5kZXgpO1xuICAgICAgdHJpZ2dlckVhY2goYXJyYXlQYXRoLCAnaW5zZXJ0JywgcGFzcywgW3ZhbHVlXSwgaW5kZXgpO1xuICAgIH1cbiAgICB0cmlnZ2VyRWFjaChwYXRoLCAnaHRtbCcsIHBhc3MsIHZhbHVlKTtcbiAgfSk7XG5cbiAgbW9kZWwub24oJ2xvYWQnLCAnKionLCBmdW5jdGlvbiBkZXJieU9uTG9hZChwYXRoLCB2YWx1ZSwgcGFzcykge1xuICAgIHRyaWdnZXJFYWNoKHBhdGgsICdodG1sJywgcGFzcywgdmFsdWUpO1xuICB9KTtcblxuICBtb2RlbC5vbigndW5sb2FkJywgJyoqJywgZnVuY3Rpb24gZGVyYnlPbkxvYWQocGF0aCwgcHJldmlvdXMsIHBhc3MpIHtcbiAgICB0cmlnZ2VyRWFjaChwYXRoLCAnaHRtbCcsIHBhc3MsIHZvaWQgMCk7XG4gIH0pO1xuXG4gIG1vZGVsLm9uKCdpbnNlcnQnLCAnKionLCBmdW5jdGlvbiBkZXJieU9uSW5zZXJ0KHBhdGgsIGluZGV4LCB2YWx1ZXMsIHBhc3MpIHtcbiAgICBwYXRoTWFwLm9uSW5zZXJ0KHBhdGgsIGluZGV4LCB2YWx1ZXMubGVuZ3RoKTtcbiAgICB0cmlnZ2VyRWFjaChwYXRoLCAnaW5zZXJ0JywgcGFzcywgdmFsdWVzLCBpbmRleCk7XG4gIH0pO1xuXG4gIG1vZGVsLm9uKCdyZW1vdmUnLCAnKionLCBmdW5jdGlvbiBkZXJieU9uUmVtb3ZlKHBhdGgsIGluZGV4LCByZW1vdmVkLCBwYXNzKSB7XG4gICAgdmFyIGhvd01hbnkgPSByZW1vdmVkLmxlbmd0aDtcbiAgICB2YXIgZW5kID0gaW5kZXggKyBob3dNYW55O1xuICAgIHBhdGhNYXAub25SZW1vdmUocGF0aCwgaW5kZXgsIGhvd01hbnkpO1xuXG4gICAgZm9yICh2YXIgaSA9IGluZGV4OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHZhciBpZCA9IHBhdGhNYXAuaWRzW3BhdGhdO1xuICAgICAgaWYgKGlkKSBldmVudHMudHJpZ2dlcihpZCwgJ3JlbW92ZScsIHBhc3MsIGluZGV4KTtcbiAgICB9XG4gICAgdHJpZ2dlclBhcmVudHMocGF0aCwgcGFzcyk7XG4gIH0pO1xuXG4gIG1vZGVsLm9uKCdtb3ZlJywgJyoqJywgZnVuY3Rpb24gZGVyYnlPbk1vdmUocGF0aCwgZnJvbSwgdG8sIGhvd01hbnksIHBhc3MpIHtcbiAgICBwYXRoTWFwLm9uTW92ZShwYXRoLCBmcm9tLCB0bywgaG93TWFueSk7XG4gICAgdHJpZ2dlckVhY2gocGF0aCwgJ21vdmUnLCBwYXNzLCBmcm9tLCB0bywgaG93TWFueSk7XG4gIH0pO1xuXG4gIG1vZGVsLm9uKCdzdHJpbmdJbnNlcnQnLCAnKionLCBmdW5jdGlvbiBkZXJieU9uU3RyaW5nSW5zZXJ0KHBhdGgsIGluZGV4LCBpbnNlcnRlZCwgcGFzcykge1xuICAgIHZhciB2YWx1ZSA9IG1vZGVsLmdldChwYXRoKTtcbiAgICB2YXIgaWQgPSBwYXRoTWFwLmlkc1twYXRoXTtcbiAgICBldmVudHMudHJpZ2dlcihpZCwgJ3N0cmluZ0luc2VydCcsIHBhc3MsIHZhbHVlLCBpbmRleCwgaW5zZXJ0ZWQpO1xuICB9KTtcblxuICBtb2RlbC5vbignc3RyaW5nUmVtb3ZlJywgJyoqJywgZnVuY3Rpb24gZGVyYnlPblN0cmluZ1JlbW92ZShwYXRoLCBpbmRleCwgaG93TWFueSwgcGFzcykge1xuICAgIHZhciB2YWx1ZSA9IG1vZGVsLmdldChwYXRoKTtcbiAgICB2YXIgaWQgPSBwYXRoTWFwLmlkc1twYXRoXTtcbiAgICBldmVudHMudHJpZ2dlcihpZCwgJ3N0cmluZ1JlbW92ZScsIHBhc3MsIHZhbHVlLCBpbmRleCwgaG93TWFueSk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHRyaWdnZXJFYWNoKHBhdGgsIHR5cGUsIHBhc3MsIGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAvLyBUcmlnZ2VyIGFuIGV2ZW50IG9uIHRoZSBwYXRoIGlmIGl0IGhhcyBhIHBhdGhNYXAgSURcbiAgICB2YXIgaWQgPSBwYXRoTWFwLmlkc1twYXRoXTtcbiAgICBpZiAoaWQpIGV2ZW50cy50cmlnZ2VyKGlkLCB0eXBlLCBwYXNzLCBhcmcwLCBhcmcxLCBhcmcyKTtcbiAgICAvLyBUcmlnZ2VyIGEgcGF0dGVybiBldmVudCBmb3IgdGhlIHBhdGggYW5kIGVhY2ggb2YgaXRzIHBhcmVudCBwYXRoc1xuICAgIC8vIFRoaXMgaXMgdXNlZCBieSB2aWV3IGhlbHBlciBmdW5jdGlvbnMgdG8gbWF0Y2ggdXBkYXRlcyBvbiBhIHBhdGhcbiAgICAvLyBvciBhbnkgb2YgaXRzIGNoaWxkIHNlZ21lbnRzXG4gICAgdHJpZ2dlclBhcmVudHMocGF0aCwgcGFzcyk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmlnZ2VyUGFyZW50cyhwYXRoLCBwYXNzKSB7XG4gICAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSBzZWdtZW50cy5sZW5ndGg7IGkgPD0gbGVuOyBpKyspIHtcbiAgICAgIHZhciBwYXR0ZXJuID0gc2VnbWVudHMuc2xpY2UoMCwgaSkuam9pbignLicpICsgJyonO1xuICAgICAgdmFyIGlkID0gcGF0aE1hcC5pZHNbcGF0dGVybl07XG4gICAgICBpZiAoaWQpIGV2ZW50cy50cmlnZ2VyKGlkLCBudWxsLCBwYXNzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbW9kZWw7XG59XG5cbn0pKCkiLCIoZnVuY3Rpb24oX19kaXJuYW1lKXttb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG4vLyBFeHRlbmQgbW9kZWwgb24gYm90aCBzZXJ2ZXIgYW5kIGNsaWVudCAvL1xucmVxdWlyZSgnLi9ldmVudHMnKTtcbnJlcXVpcmUoJy4vcGF0aHMnKTtcbnJlcXVpcmUoJy4vY29sbGVjdGlvbnMnKTtcbnJlcXVpcmUoJy4vbXV0YXRvcnMnKTtcbnJlcXVpcmUoJy4vc2V0RGlmZicpO1xuXG5yZXF1aXJlKCcuL2Nvbm5lY3Rpb24nKTtcbnJlcXVpcmUoJy4vc3Vic2NyaXB0aW9ucycpO1xucmVxdWlyZSgnLi9RdWVyeScpO1xucmVxdWlyZSgnLi9jb250ZXh0cycpO1xuXG5yZXF1aXJlKCcuL2ZuJyk7XG5yZXF1aXJlKCcuL2ZpbHRlcicpO1xucmVxdWlyZSgnLi9yZWZMaXN0Jyk7XG5yZXF1aXJlKCcuL3JlZicpO1xuXG4vLyBFeHRlbmQgbW9kZWwgZm9yIHNlcnZlciAvL1xudXRpbC5zZXJ2ZXJSZXF1aXJlKF9fZGlybmFtZSArICcvYnVuZGxlJyk7XG51dGlsLnNlcnZlclJlcXVpcmUoX19kaXJuYW1lICsgJy9jb25uZWN0aW9uLnNlcnZlcicpO1xuXG59KShcIi9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL2xpYi9Nb2RlbFwiKSIsIm1vZHVsZS5leHBvcnRzID0ge1xuICB0cmF2ZXJzZU5vZGU6IHRyYXZlcnNlTm9kZVxuLCBwYXRoTWVyZ2U6IHBhdGhNZXJnZVxuLCB0cmVlTWVyZ2U6IHRyZWVNZXJnZVxufTtcblxuZnVuY3Rpb24gdHJhdmVyc2VOb2RlKG5vZGUsIHNlZ21lbnRzKSB7XG4gIHZhciBpLCBsZW4sIHNlZ21lbnRcbiAgZm9yIChpID0gMCwgbGVuID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgbm9kZSA9IG5vZGVbc2VnbWVudF0gfHwgKG5vZGVbc2VnbWVudF0gPSB7fSk7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8vIFJlY3Vyc2l2ZWx5IHNldCBuZXN0ZWQgb2JqZWN0cyBiYXNlZCBvbiBhIHBhdGhcbmZ1bmN0aW9uIHBhdGhNZXJnZShub2RlLCBwYXRoLCB2YWx1ZSwgbm9kZUZuKSB7XG4gIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKVxuICAgICwgbGFzdCwgaSwgbGVuLCBzZWdtZW50XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgbm9kZSA9IHRyYXZlcnNlTm9kZShub2RlLCBzZWdtZW50cyk7XG4gICAgdHJlZU1lcmdlKG5vZGUsIHZhbHVlLCBub2RlRm4pO1xuICAgIHJldHVybjtcbiAgfVxuICBsYXN0ID0gc2VnbWVudHMucG9wKCk7XG4gIG5vZGUgPSB0cmF2ZXJzZU5vZGUobm9kZSwgc2VnbWVudHMpO1xuICBub2RlW2xhc3RdID0gKG5vZGVGbikgPyBub2RlRm4odmFsdWUpIDogdmFsdWU7XG59XG5cbi8vIFJlY3Vyc2l2ZWx5IHNldCBvYmplY3RzIHN1Y2ggdGhhdCB0aGUgbm9uLW9iamVjdHMgYXJlXG4vLyBtZXJnZWQgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBzdHJ1Y3R1cmUgb2YgdGhlIGJhc2Ugbm9kZVxuZnVuY3Rpb24gdHJlZU1lcmdlKG5vZGUsIHRyZWUsIG5vZGVGbikge1xuICB2YXIga2V5LCBjaGlsZCwgdmFsdWVcbiAgZm9yIChrZXkgaW4gdHJlZSkge1xuICAgIHZhbHVlID0gdHJlZVtrZXldO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBjaGlsZCA9IG5vZGVba2V5XSB8fCAobm9kZVtrZXldID0ge30pO1xuICAgICAgdHJlZU1lcmdlKGNoaWxkLCB2YWx1ZSwgbm9kZUZuKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBub2RlW2tleV0gPSAobm9kZUZuKSA/IG5vZGVGbih2YWx1ZSkgOiB2YWx1ZTtcbiAgfVxufVxuIiwiZnVuY3Rpb24gZW1wdHkoKSB7fVxuZnVuY3Rpb24gRXZlbnREaXNwYXRjaGVyTmFtZXMoKSB7fVxuZnVuY3Rpb24gRXZlbnREaXNwYXRjaGVyTGlzdGVuZXJzKCkge31cbmZ1bmN0aW9uIENsZWFudXBQZW5kaW5nTWFwKCkge31cblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudERpc3BhdGNoZXI7XG5cbmZ1bmN0aW9uIEV2ZW50RGlzcGF0Y2hlcihvcHRpb25zKSB7XG4gIHRoaXMuX29uVHJpZ2dlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5vblRyaWdnZXIgfHwgZW1wdHk7XG4gIHRoaXMuX29uQmluZCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5vbkJpbmQgfHwgZW1wdHk7XG4gIHRoaXMuX29uQ2xlYW51cCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5vbkNsZWFudXA7XG4gIHRoaXMuX2NsZWFudXBQZW5kaW5nID0gbmV3IENsZWFudXBQZW5kaW5nTWFwKCk7XG4gIHRoaXMuY2xlYXIoKTtcbn1cblxuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLm5hbWVzID0gbmV3IEV2ZW50RGlzcGF0Y2hlck5hbWVzKCk7XG59O1xuXG5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihuYW1lLCBsaXN0ZW5lciwgYXJnMCkge1xuICB0aGlzLl9vbkJpbmQobmFtZSwgbGlzdGVuZXIsIGFyZzApO1xuICB2YXIgb2JqID0gdGhpcy5uYW1lc1tuYW1lXSB8fCAodGhpcy5uYW1lc1tuYW1lXSA9IG5ldyBFdmVudERpc3BhdGNoZXJMaXN0ZW5lcnMoKSk7XG4gIG9ialtKU09OLnN0cmluZ2lmeShsaXN0ZW5lcildID0gbGlzdGVuZXI7XG4gIHJldHVybiBvYmo7XG59O1xuXG5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSkge1xuICBpZiAoIW5hbWUpIHJldHVybjtcbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMubmFtZXNbbmFtZV07XG4gIHZhciBvblRyaWdnZXIgPSB0aGlzLl9vblRyaWdnZXI7XG4gIHZhciBjb3VudCA9IDA7XG4gIHZhciBrZXksIGxpc3RlbmVyO1xuICBmb3IgKGtleSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBsaXN0ZW5lciA9IGxpc3RlbmVyc1trZXldO1xuICAgIGNvdW50Kys7XG4gICAgaWYgKGZhbHNlICE9PSBvblRyaWdnZXIobmFtZSwgbGlzdGVuZXIsIHZhbHVlLCBhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGRlbGV0ZSBsaXN0ZW5lcnNba2V5XTtcbiAgICBjb3VudC0tO1xuICB9XG4gIGlmICghY291bnQpIGRlbGV0ZSB0aGlzLm5hbWVzW25hbWVdO1xuICByZXR1cm4gY291bnQ7XG59O1xuXG5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmRlbGF5ZWRDbGVhbnVwID0gZnVuY3Rpb24obmFtZSkge1xuICBpZiAodGhpcy5fY2xlYW51cFBlbmRpbmdbbmFtZV0pIHJldHVybjtcbiAgdGhpcy5fY2xlYW51cFBlbmRpbmdbbmFtZV0gPSB0cnVlO1xuICB2YXIgZXZlbnREaXNwYXRjaGVyID0gdGhpcztcbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBkZWxldGUgZXZlbnREaXNwYXRjaGVyLl9jbGVhbnVwUGVuZGluZ1tuYW1lXTtcbiAgICBldmVudERpc3BhdGNoZXIuY2xlYW51cChuYW1lKTtcbiAgfSwgMCk7XG59O1xuXG5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLm5hbWVzW25hbWVdO1xuICB2YXIgaGFzS2V5cyA9IGZhbHNlO1xuICB2YXIga2V5LCByZW1vdmU7XG4gIGZvciAoa2V5IGluIGxpc3RlbmVycykge1xuICAgIHJlbW92ZSA9IHRoaXMuX29uQ2xlYW51cChuYW1lLCBsaXN0ZW5lcnNba2V5XSk7XG4gICAgaWYgKHJlbW92ZSkge1xuICAgICAgZGVsZXRlIGxpc3RlbmVyc1trZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYXNLZXlzID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNLZXlzKSBkZWxldGUgdGhpcy5uYW1lc1tuYW1lXTtcbn07XG4iLCIoZnVuY3Rpb24oX19maWxlbmFtZSl7dmFyIGNvbmZpZyA9IHtcbiAgZmlsZW5hbWU6IF9fZmlsZW5hbWUsXG4gIG5zOiAnZ2hidG5zJyxcbiAgc2NyaXB0czoge1xuICAgIGJ1dHRvbjogcmVxdWlyZSgnLi9idXR0b24nKVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCwgb3B0aW9ucykge1xuICBhcHAuY3JlYXRlTGlicmFyeShjb25maWcsIG9wdGlvbnMpO1xufVxufSkoXCIvbm9kZV9tb2R1bGVzL2RlcmJ5LXVpLWdpdGh1Yi1idXR0b25zL2luZGV4LmpzXCIpIiwibW9kdWxlLmV4cG9ydHMgPSBQYXRoTWFwO1xuXG5mdW5jdGlvbiBQYXRoTWFwKCkge1xuICB0aGlzLmNsZWFyKCk7XG4gIHRoaXMuY291bnQgPSAwO1xufVxuXG5QYXRoTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmlkcyA9IHt9O1xuICB0aGlzLnBhdGhzID0ge307XG4gIHRoaXMuYXJyYXlzID0ge307XG59O1xuXG5QYXRoTWFwLnByb3RvdHlwZS5pZCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgLy8gUmV0dXJuIHRoZSBwYXRoIGZvciBhbiBpZCwgb3IgY3JlYXRlIGEgbmV3IGlkIGFuZCBpbmRleCBpdFxuICB2YXIgaWQgPSB0aGlzLmlkc1twYXRoXTtcbiAgaWYgKGlkKSByZXR1cm4gaWQ7XG4gIGlkID0gKCsrdGhpcy5jb3VudCkudG9TdHJpbmcoKTtcbiAgdGhpcy5wYXRoc1tpZF0gPSBwYXRoO1xuICB0aGlzLl9pbmRleEFycmF5KHBhdGgsIGlkKTtcbiAgdGhpcy5pZHNbcGF0aF0gPSBpZDtcbiAgcmV0dXJuIGlkO1xufTtcblxuUGF0aE1hcC5wcm90b3R5cGUuX2luZGV4QXJyYXkgPSBmdW5jdGlvbihwYXRoLCBpZCkge1xuICB2YXIgYXJyLCBpbmRleCwgbWF0Y2gsIG5lc3RlZCwgcmVtYWluZGVyLCBzZXQsIHNldEFycmF5cztcbiAgd2hpbGUgKG1hdGNoID0gL14oLispXFwuKFxcZCspKFxcKj8oPzpcXC4uK3wkKSkvLmV4ZWMocGF0aCkpIHtcbiAgICBwYXRoID0gbWF0Y2hbMV07XG4gICAgaW5kZXggPSArbWF0Y2hbMl07XG4gICAgcmVtYWluZGVyID0gbWF0Y2hbM107XG4gICAgYXJyID0gdGhpcy5hcnJheXNbcGF0aF0gfHwgKHRoaXMuYXJyYXlzW3BhdGhdID0gW10pO1xuICAgIHNldCA9IGFycltpbmRleF0gfHwgKGFycltpbmRleF0gPSB7fSk7XG4gICAgaWYgKG5lc3RlZCkge1xuICAgICAgc2V0QXJyYXlzID0gc2V0LmFycmF5cyB8fCAoc2V0LmFycmF5cyA9IHt9KTtcbiAgICAgIHNldEFycmF5c1tyZW1haW5kZXJdID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0W2lkXSA9IHJlbWFpbmRlcjtcbiAgICB9XG4gICAgbmVzdGVkID0gdHJ1ZTtcbiAgfVxufTtcblxuUGF0aE1hcC5wcm90b3R5cGUuX2luY3JJdGVtcyA9IGZ1bmN0aW9uKHBhdGgsIG1hcCwgc3RhcnQsIGVuZCwgYnlOdW0sIG9sZEFycmF5cywgb2xkUGF0aCkge1xuICB2YXIgYXJyYXlNYXAsIGFycmF5UGF0aCwgYXJyYXlQYXRoVG8sIGksIGlkLCBpZHMsIGl0ZW1QYXRoLCByZW1haW5kZXI7XG4gIGlmIChvbGRBcnJheXMgPT0gbnVsbCkgb2xkQXJyYXlzID0ge307XG5cbiAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlkcyA9IG1hcFtpXTtcbiAgICBpZiAoIWlkcykgY29udGludWU7XG5cbiAgICBmb3IgKGlkIGluIGlkcykge1xuICAgICAgcmVtYWluZGVyID0gaWRzW2lkXTtcbiAgICAgIGlmIChpZCA9PT0gJ2FycmF5cycpIHtcbiAgICAgICAgZm9yIChyZW1haW5kZXIgaW4gaWRzW2lkXSkge1xuICAgICAgICAgIGFycmF5UGF0aCA9IChvbGRQYXRoIHx8IHBhdGgpICsgJy4nICsgaSArIHJlbWFpbmRlcjtcbiAgICAgICAgICBhcnJheU1hcCA9IG9sZEFycmF5c1thcnJheVBhdGhdIHx8IHRoaXMuYXJyYXlzW2FycmF5UGF0aF07XG4gICAgICAgICAgaWYgKGFycmF5TWFwKSB7XG4gICAgICAgICAgICBhcnJheVBhdGhUbyA9IHBhdGggKyAnLicgKyAoaSArIGJ5TnVtKSArIHJlbWFpbmRlcjtcbiAgICAgICAgICAgIHRoaXMuYXJyYXlzW2FycmF5UGF0aFRvXSA9IGFycmF5TWFwO1xuICAgICAgICAgICAgdGhpcy5faW5jckl0ZW1zKGFycmF5UGF0aFRvLCBhcnJheU1hcCwgMCwgYXJyYXlNYXAubGVuZ3RoLCAwLCBvbGRBcnJheXMsIGFycmF5UGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpdGVtUGF0aCA9IHBhdGggKyAnLicgKyAoaSArIGJ5TnVtKSArIHJlbWFpbmRlcjtcbiAgICAgIHRoaXMucGF0aHNbaWRdID0gaXRlbVBhdGg7XG4gICAgICB0aGlzLmlkc1tpdGVtUGF0aF0gPSAraWQ7XG4gICAgfVxuICB9XG59O1xuXG5QYXRoTWFwLnByb3RvdHlwZS5fZGVsSXRlbXMgPSBmdW5jdGlvbihwYXRoLCBtYXAsIHN0YXJ0LCBlbmQsIGxlbiwgb2xkQXJyYXlzKSB7XG4gIHZhciBhcnJheUxlbiwgYXJyYXlNYXAsIGFycmF5UGF0aCwgaSwgaWQsIGlkcywgaXRlbVBhdGgsIHJlbWFpbmRlcjtcbiAgaWYgKG9sZEFycmF5cyA9PSBudWxsKSBvbGRBcnJheXMgPSB7fTtcblxuICBmb3IgKGkgPSBzdGFydDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWRzID0gbWFwW2ldO1xuICAgIGlmICghaWRzKSBjb250aW51ZTtcblxuICAgIGZvciAoaWQgaW4gaWRzKSB7XG4gICAgICBpZiAoaWQgPT09ICdhcnJheXMnKSB7XG4gICAgICAgIGZvciAocmVtYWluZGVyIGluIGlkc1tpZF0pIHtcbiAgICAgICAgICBhcnJheVBhdGggPSBwYXRoICsgJy4nICsgaSArIHJlbWFpbmRlcjtcbiAgICAgICAgICBpZiAoYXJyYXlNYXAgPSB0aGlzLmFycmF5c1thcnJheVBhdGhdKSB7XG4gICAgICAgICAgICBhcnJheUxlbiA9IGFycmF5TWFwLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuX2RlbEl0ZW1zKGFycmF5UGF0aCwgYXJyYXlNYXAsIDAsIGFycmF5TGVuLCBhcnJheUxlbiwgb2xkQXJyYXlzKTtcbiAgICAgICAgICAgIG9sZEFycmF5c1thcnJheVBhdGhdID0gYXJyYXlNYXA7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5hcnJheXNbYXJyYXlQYXRoXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGl0ZW1QYXRoID0gdGhpcy5wYXRoc1tpZF07XG4gICAgICBkZWxldGUgdGhpcy5pZHNbaXRlbVBhdGhdO1xuICAgICAgaWYgKGkgPiBlbmQpIGNvbnRpbnVlO1xuICAgICAgZGVsZXRlIHRoaXMucGF0aHNbaWRdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvbGRBcnJheXM7XG59O1xuXG5QYXRoTWFwLnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uKHBhdGgsIHN0YXJ0LCBob3dNYW55KSB7XG4gIHZhciBtYXAgPSB0aGlzLmFycmF5c1twYXRoXVxuICAgICwgZW5kLCBsZW4sIG9sZEFycmF5cztcbiAgaWYgKCFtYXApIHJldHVybjtcbiAgZW5kID0gc3RhcnQgKyBob3dNYW55O1xuICBsZW4gPSBtYXAubGVuZ3RoO1xuICAvLyBEZWxldGUgaW5kaWNpZXMgZm9yIHJlbW92ZWQgaXRlbXNcbiAgb2xkQXJyYXlzID0gdGhpcy5fZGVsSXRlbXMocGF0aCwgbWFwLCBzdGFydCwgZW5kICsgMSwgbGVuKTtcbiAgLy8gRGVjcmVtZW50IGluZGljaWVzIG9mIGxhdGVyIGl0ZW1zXG4gIHRoaXMuX2luY3JJdGVtcyhwYXRoLCBtYXAsIGVuZCwgbGVuLCAtaG93TWFueSwgb2xkQXJyYXlzKTtcbiAgbWFwLnNwbGljZShzdGFydCwgaG93TWFueSk7XG59O1xuXG5QYXRoTWFwLnByb3RvdHlwZS5vbkluc2VydCA9IGZ1bmN0aW9uKHBhdGgsIHN0YXJ0LCBob3dNYW55KSB7XG4gIHZhciBtYXAgPSB0aGlzLmFycmF5c1twYXRoXVxuICAgICwgZW5kLCBsZW4sIG9sZEFycmF5cztcbiAgaWYgKCFtYXApIHJldHVybjtcbiAgZW5kID0gc3RhcnQgKyBob3dNYW55O1xuICBsZW4gPSBtYXAubGVuZ3RoO1xuICAvLyBEZWxldGUgaW5kaWNpZXMgZm9yIGl0ZW1zIGluIGluc2VydGVkIHBvc2l0aW9uc1xuICBvbGRBcnJheXMgPSB0aGlzLl9kZWxJdGVtcyhwYXRoLCBtYXAsIHN0YXJ0LCBlbmQgKyAxLCBsZW4pO1xuICAvLyBJbmNyZW1lbnQgaW5kaWNpZXMgb2YgbGF0ZXIgaXRlbXNcbiAgdGhpcy5faW5jckl0ZW1zKHBhdGgsIG1hcCwgc3RhcnQsIGxlbiwgaG93TWFueSwgb2xkQXJyYXlzKTtcbiAgd2hpbGUgKGhvd01hbnktLSkge1xuICAgIG1hcC5zcGxpY2Uoc3RhcnQsIDAsIHt9KTtcbiAgfVxufTtcblxuUGF0aE1hcC5wcm90b3R5cGUub25Nb3ZlID0gZnVuY3Rpb24ocGF0aCwgZnJvbSwgdG8sIGhvd01hbnkpIHtcbiAgdmFyIG1hcCA9IHRoaXMuYXJyYXlzW3BhdGhdXG4gICAgLCBhZnRlckZyb20sIGFmdGVyVG8sIGl0ZW1zLCBvbGRBcnJheXM7XG4gIGlmICghbWFwKSByZXR1cm47XG4gIGFmdGVyRnJvbSA9IGZyb20gKyBob3dNYW55O1xuICBhZnRlclRvID0gdG8gKyBob3dNYW55O1xuICAvLyBBZGp1c3QgcGF0aHMgZm9yIGl0ZW1zIGJldHdlZW4gZnJvbSBhbmQgdG9cbiAgaWYgKGZyb20gPiB0bykge1xuICAgIG9sZEFycmF5cyA9IHRoaXMuX2RlbEl0ZW1zKHBhdGgsIG1hcCwgdG8sIGFmdGVyRnJvbSwgYWZ0ZXJGcm9tKTtcbiAgICB0aGlzLl9pbmNySXRlbXMocGF0aCwgbWFwLCB0bywgZnJvbSwgaG93TWFueSwgb2xkQXJyYXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvbGRBcnJheXMgPSB0aGlzLl9kZWxJdGVtcyhwYXRoLCBtYXAsIGZyb20sIGFmdGVyVG8sIGFmdGVyVG8pO1xuICAgIHRoaXMuX2luY3JJdGVtcyhwYXRoLCBtYXAsIGFmdGVyRnJvbSwgYWZ0ZXJUbywgLWhvd01hbnksIG9sZEFycmF5cyk7XG4gIH1cbiAgLy8gQWRqdXN0IHBhdGhzIGZvciB0aGUgbW92ZWQgaXRlbShzKVxuICB0aGlzLl9pbmNySXRlbXMocGF0aCwgbWFwLCBmcm9tLCBhZnRlckZyb20sIHRvIC0gZnJvbSwgb2xkQXJyYXlzKTtcbiAgLy8gRml4IHRoZSBhcnJheSBpbmRleFxuICBpdGVtcyA9IG1hcC5zcGxpY2UoZnJvbSwgaG93TWFueSk7XG4gIG1hcC5zcGxpY2UuYXBwbHkobWFwLCBbdG8sIDBdLmNvbmNhdChpdGVtcykpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBvblN0cmluZ0luc2VydDogb25TdHJpbmdJbnNlcnRcbiwgb25TdHJpbmdSZW1vdmU6IG9uU3RyaW5nUmVtb3ZlXG4sIG9uVGV4dElucHV0OiBvblRleHRJbnB1dFxufTtcblxuZnVuY3Rpb24gb25TdHJpbmdJbnNlcnQoZWwsIHByZXZpb3VzLCBpbmRleCwgdGV4dCkge1xuICBmdW5jdGlvbiB0cmFuc2Zvcm1DdXJzb3IoY3Vyc29yKSB7XG4gICAgcmV0dXJuIChpbmRleCA8IGN1cnNvcikgPyBjdXJzb3IgKyB0ZXh0Lmxlbmd0aCA6IGN1cnNvcjtcbiAgfVxuICB2YXIgbmV3VGV4dCA9IHByZXZpb3VzLnNsaWNlKDAsIGluZGV4KSArIHRleHQgKyBwcmV2aW91cy5zbGljZShpbmRleCk7XG4gIHJlcGxhY2VUZXh0KGVsLCBuZXdUZXh0LCB0cmFuc2Zvcm1DdXJzb3IpO1xufVxuXG5mdW5jdGlvbiBvblN0cmluZ1JlbW92ZShlbCwgcHJldmlvdXMsIGluZGV4LCBob3dNYW55KSB7XG4gIGZ1bmN0aW9uIHRyYW5zZm9ybUN1cnNvcihjdXJzb3IpIHtcbiAgICByZXR1cm4gKGluZGV4IDwgY3Vyc29yKSA/IGN1cnNvciAtIE1hdGgubWluKGhvd01hbnksIGN1cnNvciAtIGluZGV4KSA6IGN1cnNvcjtcbiAgfVxuICB2YXIgbmV3VGV4dCA9IHByZXZpb3VzLnNsaWNlKDAsIGluZGV4KSArIHByZXZpb3VzLnNsaWNlKGluZGV4ICsgaG93TWFueSk7XG4gIHJlcGxhY2VUZXh0KGVsLCBuZXdUZXh0LCB0cmFuc2Zvcm1DdXJzb3IpO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlVGV4dChlbCwgbmV3VGV4dCwgdHJhbnNmb3JtQ3Vyc29yKSB7XG4gIHZhciBzZWxlY3Rpb25TdGFydCA9IHRyYW5zZm9ybUN1cnNvcihlbC5zZWxlY3Rpb25TdGFydCk7XG4gIHZhciBzZWxlY3Rpb25FbmQgPSB0cmFuc2Zvcm1DdXJzb3IoZWwuc2VsZWN0aW9uRW5kKTtcblxuICB2YXIgc2Nyb2xsVG9wID0gZWwuc2Nyb2xsVG9wO1xuICBlbC52YWx1ZSA9IG5ld1RleHQ7XG4gIGlmIChlbC5zY3JvbGxUb3AgIT09IHNjcm9sbFRvcCkge1xuICAgIGVsLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgfVxuICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZWwpIHtcbiAgICBlbC5zZWxlY3Rpb25TdGFydCA9IHNlbGVjdGlvblN0YXJ0O1xuICAgIGVsLnNlbGVjdGlvbkVuZCA9IHNlbGVjdGlvbkVuZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBvblRleHRJbnB1dChtb2RlbCwgcGF0aCwgdmFsdWUpIHtcbiAgdmFyIHByZXZpb3VzID0gbW9kZWwuZ2V0KHBhdGgpIHx8ICcnO1xuICBpZiAocHJldmlvdXMgPT09IHZhbHVlKSByZXR1cm47XG4gIHZhciBzdGFydCA9IDA7XG4gIHdoaWxlIChwcmV2aW91cy5jaGFyQXQoc3RhcnQpID09IHZhbHVlLmNoYXJBdChzdGFydCkpIHtcbiAgICBzdGFydCsrO1xuICB9XG4gIHZhciBlbmQgPSAwO1xuICB3aGlsZSAoXG4gICAgcHJldmlvdXMuY2hhckF0KHByZXZpb3VzLmxlbmd0aCAtIDEgLSBlbmQpID09PSB2YWx1ZS5jaGFyQXQodmFsdWUubGVuZ3RoIC0gMSAtIGVuZCkgJiZcbiAgICBlbmQgKyBzdGFydCA8IHByZXZpb3VzLmxlbmd0aCAmJlxuICAgIGVuZCArIHN0YXJ0IDwgdmFsdWUubGVuZ3RoXG4gICkge1xuICAgIGVuZCsrO1xuICB9XG5cbiAgaWYgKHByZXZpb3VzLmxlbmd0aCAhPT0gc3RhcnQgKyBlbmQpIHtcbiAgICB2YXIgaG93TWFueSA9IHByZXZpb3VzLmxlbmd0aCAtIHN0YXJ0IC0gZW5kO1xuICAgIG1vZGVsLnN0cmluZ1JlbW92ZShwYXRoLCBzdGFydCwgaG93TWFueSk7XG4gIH1cbiAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gc3RhcnQgKyBlbmQpIHtcbiAgICB2YXIgaW5zZXJ0ZWQgPSB2YWx1ZS5zbGljZShzdGFydCwgdmFsdWUubGVuZ3RoIC0gZW5kKTtcbiAgICBtb2RlbC5zdHJpbmdJbnNlcnQocGF0aCwgc3RhcnQsIGluc2VydGVkKTtcbiAgfVxufVxuIiwiKGZ1bmN0aW9uKHByb2Nlc3Mpe2Z1bmN0aW9uIGZpbHRlciAoeHMsIGZuKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGZuKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gUmVnZXggdG8gc3BsaXQgYSBmaWxlbmFtZSBpbnRvIFsqLCBkaXIsIGJhc2VuYW1lLCBleHRdXG4vLyBwb3NpeCB2ZXJzaW9uXG52YXIgc3BsaXRQYXRoUmUgPSAvXiguK1xcLyg/ISQpfFxcLyk/KCg/Oi4rPyk/KFxcLlteLl0qKT8pJC87XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xudmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICB2YXIgcGF0aCA9IChpID49IDApXG4gICAgICA/IGFyZ3VtZW50c1tpXVxuICAgICAgOiBwcm9jZXNzLmN3ZCgpO1xuXG4gIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnIHx8ICFwYXRoKSB7XG4gICAgY29udGludWU7XG4gIH1cblxuICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn1cblxuLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbi8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxucmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xudmFyIGlzQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nLFxuICAgIHRyYWlsaW5nU2xhc2ggPSBwYXRoLnNsaWNlKC0xKSA9PT0gJy8nO1xuXG4vLyBOb3JtYWxpemUgdGhlIHBhdGhcbnBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cbiAgXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIHJldHVybiBwICYmIHR5cGVvZiBwID09PSAnc3RyaW5nJztcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgZGlyID0gc3BsaXRQYXRoUmUuZXhlYyhwYXRoKVsxXSB8fCAnJztcbiAgdmFyIGlzV2luZG93cyA9IGZhbHNlO1xuICBpZiAoIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWVcbiAgICByZXR1cm4gJy4nO1xuICB9IGVsc2UgaWYgKGRpci5sZW5ndGggPT09IDEgfHxcbiAgICAgIChpc1dpbmRvd3MgJiYgZGlyLmxlbmd0aCA8PSAzICYmIGRpci5jaGFyQXQoMSkgPT09ICc6JykpIHtcbiAgICAvLyBJdCBpcyBqdXN0IGEgc2xhc2ggb3IgYSBkcml2ZSBsZXR0ZXIgd2l0aCBhIHNsYXNoXG4gICAgcmV0dXJuIGRpcjtcbiAgfSBlbHNlIHtcbiAgICAvLyBJdCBpcyBhIGZ1bGwgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICByZXR1cm4gZGlyLnN1YnN0cmluZygwLCBkaXIubGVuZ3RoIC0gMSk7XG4gIH1cbn07XG5cblxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IHNwbGl0UGF0aFJlLmV4ZWMocGF0aClbMl0gfHwgJyc7XG4gIC8vIFRPRE86IG1ha2UgdGhpcyBjb21wYXJpc29uIGNhc2UtaW5zZW5zaXRpdmUgb24gd2luZG93cz9cbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhwYXRoKVszXSB8fCAnJztcbn07XG5cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfcHJvY2Vzc1wiKSkiLCIoZnVuY3Rpb24ocHJvY2Vzcyl7dmFyIGRlZXBJcyA9IHJlcXVpcmUoJ2RlZXAtaXMnKTtcblxudmFyIGlzU2VydmVyID0gcHJvY2Vzcy50aXRsZSAhPT0gJ2Jyb3dzZXInO1xudmFyIGlzUHJvZHVjdGlvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbic7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1NlcnZlcjogaXNTZXJ2ZXJcbiwgaXNQcm9kdWN0aW9uOiBpc1Byb2R1Y3Rpb25cblxuLCBhc3luY0dyb3VwOiBhc3luY0dyb3VwXG4sIGNvbnRhaW5zOiBjb250YWluc1xuLCBjb3B5T2JqZWN0OiBjb3B5T2JqZWN0XG4sIGRlZXBDb3B5OiBkZWVwQ29weVxuLCBkZWVwRXF1YWw6IGRlZXBJc1xuLCBlcXVhbDogZXF1YWxcbiwgZXF1YWxzTmFOOiBlcXVhbHNOYU5cbiwgbG9va3VwOiBsb29rdXBcbiwgbWVyZ2VJbnRvOiBtZXJnZUludG9cbiwgbWF5SW1wYWN0OiBtYXlJbXBhY3RcbiwgbWF5SW1wYWN0QW55OiBtYXlJbXBhY3RBbnlcbiwgc2VydmVyUmVxdWlyZTogc2VydmVyUmVxdWlyZVxuLCB1c2U6IHVzZVxufTtcblxuZnVuY3Rpb24gYXN5bmNHcm91cChjYikge1xuICB2YXIgZ3JvdXAgPSBuZXcgQXN5bmNHcm91cChjYik7XG4gIHJldHVybiBmdW5jdGlvbiBhc3luY0dyb3VwQWRkKCkge1xuICAgIHJldHVybiBncm91cC5hZGQoKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiKGVycilcbiAqL1xuZnVuY3Rpb24gQXN5bmNHcm91cChjYikge1xuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaXNEb25lID0gZmFsc2U7XG4gIHRoaXMuY291bnQgPSAwO1xufVxuQXN5bmNHcm91cC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY291bnQrKztcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gZnVuY3Rpb24oZXJyKSB7XG4gICAgc2VsZi5jb3VudC0tO1xuICAgIGlmIChzZWxmLmlzRG9uZSkgcmV0dXJuO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHNlbGYuaXNEb25lID0gdHJ1ZTtcbiAgICAgIHNlbGYuY2IoZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNlbGYuY291bnQgPiAwKSByZXR1cm47XG4gICAgc2VsZi5pc0RvbmUgPSB0cnVlO1xuICAgIHNlbGYuY2IoKTtcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKHNlZ21lbnRzLCB0ZXN0U2VnbWVudHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzZWdtZW50c1tpXSAhPT0gdGVzdFNlZ21lbnRzW2ldKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvcHlPYmplY3Qob2JqZWN0KSB7XG4gIHZhciBvdXQgPSBuZXcgb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBvdXRba2V5XSA9IG9iamVjdFtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBkZWVwQ29weSh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSByZXR1cm4gbmV3IERhdGUodmFsdWUpO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgdmFyIGNvcHk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBjb3B5ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gdmFsdWUubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIGNvcHlbaV0gPSBkZWVwQ29weSh2YWx1ZVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgY29weSA9IG5ldyB2YWx1ZS5jb25zdHJ1Y3RvcjtcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGNvcHlba2V5XSA9IGRlZXBDb3B5KHZhbHVlW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29weTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIChhID09PSBiKSB8fCAoZXF1YWxzTmFOKGEpICYmIGVxdWFsc05hTihiKSk7XG59XG5cbmZ1bmN0aW9uIGVxdWFsc05hTih4KSB7XG4gIHJldHVybiB4ICE9PSB4O1xufVxuXG5mdW5jdGlvbiBsb29rdXAoc2VnbWVudHMsIHZhbHVlKSB7XG4gIGlmICghc2VnbWVudHMpIHJldHVybiB2YWx1ZTtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHZhbHVlO1xuICAgIHZhbHVlID0gdmFsdWVbc2VnbWVudHNbaV1dO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gbWF5SW1wYWN0QW55KHNlZ21lbnRzTGlzdCwgdGVzdFNlZ21lbnRzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWdtZW50c0xpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAobWF5SW1wYWN0KHNlZ21lbnRzTGlzdFtpXSwgdGVzdFNlZ21lbnRzKSkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBtYXlJbXBhY3Qoc2VnbWVudHMsIHRlc3RTZWdtZW50cykge1xuICB2YXIgbGVuID0gTWF0aC5taW4oc2VnbWVudHMubGVuZ3RoLCB0ZXN0U2VnbWVudHMubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChzZWdtZW50c1tpXSAhPT0gdGVzdFNlZ21lbnRzW2ldKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG1lcmdlSW50byh0bywgZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgIHRvW2tleV0gPSBmcm9tW2tleV07XG4gIH1cbiAgcmV0dXJuIHRvO1xufVxuXG5mdW5jdGlvbiBzZXJ2ZXJSZXF1aXJlKG5hbWUpIHtcbiAgaWYgKCFpc1NlcnZlcikgcmV0dXJuO1xuICAvLyBUcmlja3MgQnJvd3NlcmlmeSBpbnRvIG5vdCBsb2dnaW5nIGEgd2FybmluZ1xuICB2YXIgX3JlcXVpcmUgPSByZXF1aXJlO1xuICByZXR1cm4gX3JlcXVpcmUobmFtZSk7XG59XG5cbmZ1bmN0aW9uIHVzZShwbHVnaW4sIG9wdGlvbnMpIHtcbiAgLy8gU2VydmVyLXNpZGUgcGx1Z2lucyBtYXkgYmUgaW5jbHVkZWQgdmlhIGZpbGVuYW1lXG4gIGlmICh0eXBlb2YgcGx1Z2luID09PSAnc3RyaW5nJykge1xuICAgIGlmICghaXNTZXJ2ZXIpIHJldHVybiB0aGlzO1xuICAgIHBsdWdpbiA9IHNlcnZlclJlcXVpcmUocGx1Z2luKTtcbiAgfVxuXG4gIC8vIERvbid0IGluY2x1ZGUgYSBwbHVnaW4gbW9yZSB0aGFuIG9uY2VcbiAgdmFyIHBsdWdpbnMgPSB0aGlzLl9wbHVnaW5zIHx8ICh0aGlzLl9wbHVnaW5zID0gW10pO1xuICBpZiAocGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPT09IC0xKSB7XG4gICAgcGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgcGx1Z2luKHRoaXMsIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG59KShyZXF1aXJlKFwiX19icm93c2VyaWZ5X3Byb2Nlc3NcIikpIiwidmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xuXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbiAobW9kZWwpIHtcbiAgdmFyIGZpbGVuYW1lID0gbW9kZWwuZ2V0KCdmaWxlbmFtZScpIHx8ICdnaXRodWItYnRuLmh0bWwnXG4gICAgLCBmaWxldXJsID0gbW9kZWwuZ2V0KCdmaWxldXJsJylcbiAgICAsIGRvbWFpbiA9IG1vZGVsLmdldCgnZG9tYWluJykgfHwgJ2doYnRucy5jb20nXG4gICAgLCBnaXR1cmwgPSBtb2RlbC5nZXQoJ2dpdHVybCcpXG4gICAgLCBoZWlnaHQgPSBtb2RlbC5nZXQoJ2hlaWdodCcpXG4gICAgLCBwcm90b2NvbCA9IG1vZGVsLmdldCgnc2VjdXJlJykgPyAnaHR0cHMnIDogJ2h0dHAnXG4gICAgLCByZXBvID0gbW9kZWwuZ2V0KCdyZXBvJylcbiAgICAsIHNpemUgPSBtb2RlbC5nZXQoJ3NpemUnKVxuICAgICwgdHlwZSA9IG1vZGVsLmdldCgndHlwZScpXG4gICAgLCB1c2VyID0gbW9kZWwuZ2V0KCd1c2VyJyk7XG5cbiAgaWYgKCFnaXR1cmwgJiYgKCF1c2VyIHx8ICFyZXBvKSkge1xuICAgIHJldHVybiBjb25zb2xlLmVycm9yKCdnaGJ0bnM6YnV0dG9uOiBnaXR1cmwgb3IgdXNlci9yZXBvIHJlcXVpcmVkJyk7XG4gIH1cblxuICBpZiAoIXR5cGUpIHtcbiAgICByZXR1cm4gY29uc29sZS5lcnJvcignZ2hidG5zOmJ1dHRvbjogdHlwZSByZXF1aXJlZCcpO1xuICB9XG5cbiAgaWYgKCFmaWxldXJsKSB7XG4gICAgbW9kZWwuc2V0KCdmaWxldXJsJywgcHJvdG9jb2wgKyAnOi8vJyArIGRvbWFpbiArICcvJyArIGZpbGVuYW1lKTtcbiAgfVxuXG4gIGlmIChnaXR1cmwpIHtcbiAgICB2YXIgZ2l0cGF0aCA9IHVybC5wYXJzZShnaXR1cmwpLnBhdGguc3BsaXQoJy8nKTtcbiAgICBtb2RlbC5zZXQoJ3JlcG8nLCBnaXRwYXRoWzJdLnNsaWNlKDAsIC00KSk7XG4gICAgbW9kZWwuc2V0KCd1c2VyJywgZ2l0cGF0aFsxXSk7XG4gIH1cblxuICBpZiAoIWhlaWdodCkge1xuICAgIG1vZGVsLnNldCgnaGVpZ2h0Jywgc2l6ZSA9PT0gJ2xhcmdlJyA/ICczMCcgOiAnMjAnKTtcbiAgfVxuXG4gIG1vZGVsLnNldCgnc2hvdycsIHRydWUpO1xufTsiLCJ2YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuICAsIHV0aWwgPSByZXF1aXJlKCdyYWNlcicpLnV0aWxcbiAgLCBWaWV3ID0gcmVxdWlyZSgnLi9WaWV3JylcbiAgLCBhcnJheVNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlXG5cbm1vZHVsZS5leHBvcnRzID0gY29tcG9uZW50UGx1Z2luO1xuXG5mdW5jdGlvbiBjb21wb25lbnRQbHVnaW4oYXBwKSB7XG4gIGFwcC5fbGlicmFyaWVzID0gW107XG4gIGFwcC5fbGlicmFyaWVzLm1hcCA9IHt9O1xuICBhcHAuY3JlYXRlTGlicmFyeSA9IGNyZWF0ZUxpYnJhcnk7XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudFByb3RvKCkge31cbnV0aWwubWVyZ2VJbnRvKENvbXBvbmVudFByb3RvLnByb3RvdHlwZSwgRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5cbkNvbXBvbmVudFByb3RvLnByb3RvdHlwZS5lbWl0Q2FuY2VsbGFibGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNhbmNlbGxlZCA9IGZhbHNlXG4gICAgLCBhcmdzID0gYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cylcblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGFyZ3MucHVzaChjYW5jZWwpO1xuICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gIHJldHVybiBjYW5jZWxsZWQ7XG59O1xuXG5Db21wb25lbnRQcm90by5wcm90b3R5cGUuZW1pdERlbGF5YWJsZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZGVsYXllZCA9IGZhbHNlXG4gICAgLCBhcmdzID0gYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cywgMCwgLTEpXG4gICAgLCBjYWxsYmFjayA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV1cblxuICBmdW5jdGlvbiBkZWxheSgpIHtcbiAgICBkZWxheWVkID0gdHJ1ZTtcbiAgfVxuXG4gIGFyZ3MucHVzaChkZWxheSwgY2FsbGJhY2spO1xuICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gIGlmICghZGVsYXllZCkgY2FsbGJhY2soKTtcbiAgcmV0dXJuIGRlbGF5ZWQ7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVMaWJyYXJ5KGNvbmZpZywgb3B0aW9ucykge1xuICBpZiAoIWNvbmZpZyB8fCAhY29uZmlnLmZpbGVuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yICgnQ29uZmlndXJhdGlvbiBhcmd1bWVudCB3aXRoIGEgZmlsZW5hbWUgaXMgcmVxdWlyZWQnKTtcbiAgfVxuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgdmFyIHJvb3QgPSBwYXRoLmRpcm5hbWUoY29uZmlnLmZpbGVuYW1lKTtcbiAgdmFyIG5zID0gb3B0aW9ucy5ucyB8fCBjb25maWcubnMgfHwgcGF0aC5iYXNlbmFtZShyb290KTtcbiAgdmFyIHNjcmlwdHMgPSBjb25maWcuc2NyaXB0cyB8fCB7fTtcbiAgdmFyIHZpZXcgPSBuZXcgVmlldztcbiAgdmFyIGNvbnN0cnVjdG9ycyA9IHt9O1xuICB2YXIgbGlicmFyeSA9IHtcbiAgICBuczogbnNcbiAgLCByb290OiByb290XG4gICwgdmlldzogdmlld1xuICAsIGNvbnN0cnVjdG9yczogY29uc3RydWN0b3JzXG4gICwgc3R5bGVzOiBjb25maWcuc3R5bGVzXG4gIH07XG5cbiAgdmlldy5wYXJlbnQgPSB0aGlzO1xuICB2aWV3Ll9zZWxmTnMgPSAnbGliJztcbiAgdmlldy5fc2VsZkxpYnJhcnkgPSBsaWJyYXJ5O1xuXG4gIGZvciAodmFyIG5hbWUgaW4gc2NyaXB0cykge1xuICAgIHZhciBzY3JpcHQgPSBzY3JpcHRzW25hbWVdO1xuICAgIHNjcmlwdC5zZXR1cCAmJiBzY3JpcHQuc2V0dXAobGlicmFyeSk7XG5cbiAgICB2YXIgQ29tcG9uZW50ID0gZnVuY3Rpb24obW9kZWwsIHNjb3BlKSB7XG4gICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgICAgdGhpcy5oaXN0b3J5ID0gbnVsbDtcbiAgICAgIHRoaXMuZG9tID0gbnVsbDtcblxuICAgICAgLy8gRG9uJ3QgbGltaXQgdGhlIG51bWJlciBvZiBsaXN0ZW5lcnNcbiAgICAgIHRoaXMuc2V0TWF4TGlzdGVuZXJzKDApO1xuXG4gICAgICB2YXIgY29tcG9uZW50ID0gdGhpcztcbiAgICAgIG1vZGVsLl9fb24gPSBtb2RlbC5fb247XG4gICAgICBtb2RlbC5fb24gPSBmdW5jdGlvbihuYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICBjb21wb25lbnQub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBtb2RlbC5yZW1vdmVMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBtb2RlbC5fX29uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICAgIH07XG4gICAgICBjb21wb25lbnQub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgbW9kZWwuc2lsZW50KCkuZGVsKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHByb3RvID0gQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnRQcm90bygpO1xuICAgIHV0aWwubWVyZ2VJbnRvKHByb3RvLCBzY3JpcHQpO1xuXG4gICAgQ29tcG9uZW50LnZpZXcgPSB2aWV3O1xuICAgIENvbXBvbmVudC5ucyA9IENvbXBvbmVudC5wcm90b3R5cGUubnMgPSBucztcbiAgICBDb21wb25lbnQubmFtZSA9IENvbXBvbmVudC5wcm90b3R5cGUubmFtZSA9IG5hbWU7XG5cbiAgICAvLyBOb3RlIHRoYXQgY29tcG9uZW50IG5hbWVzIGFyZSBhbGwgbG93ZXJjYXNlZFxuICAgIGNvbnN0cnVjdG9yc1tuYW1lLnRvTG93ZXJDYXNlKCldID0gQ29tcG9uZW50O1xuICB9XG5cbiAgdmFyIHJlcGxhY2VkID0gZmFsc2U7XG4gIGZvciAodmFyIGkgPSB0aGlzLl9saWJyYXJpZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgaWYgKHRoaXMuX2xpYnJhcmllc1tpXS5ucyA9PT0gbnMpIHtcbiAgICAgIHRoaXMuX2xpYnJhcmllc1tpXSA9IGxpYnJhcnk7XG4gICAgICByZXBsYWNlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmICghcmVwbGFjZWQpIHtcbiAgICB0aGlzLl9saWJyYXJpZXMucHVzaChsaWJyYXJ5KTtcbiAgfVxuICB0aGlzLl9saWJyYXJpZXMubWFwW25zXSA9IGxpYnJhcnk7XG4gIHJldHVybiBsaWJyYXJ5O1xufVxuIiwidmFyIGVzY2FwZUh0bWwgPSByZXF1aXJlKCdodG1sLXV0aWwnKS5lc2NhcGVIdG1sXG4gICwgZXJyb3JzID0ge307XG5cbmV4cG9ydHMuZXJyb3JIdG1sID0gZXJyb3JIdG1sO1xuZXhwb3J0cy5hdXRvUmVmcmVzaCA9IGF1dG9SZWZyZXNoO1xuXG5mdW5jdGlvbiBlcnJvckh0bWwoZXJyb3JzKSB7XG4gIHZhciB0ZXh0ID0gJydcbiAgICAsIHR5cGUsIGVycjtcbiAgZm9yICh0eXBlIGluIGVycm9ycykge1xuICAgIGVyciA9IGVycm9yc1t0eXBlXTtcbiAgICB0ZXh0ICs9ICc8aDM+JyArIGVzY2FwZUh0bWwodHlwZSkgKyAnIEVycm9yPC9oMz48cHJlPicgKyBlc2NhcGVIdG1sKGVycikgKyAnPC9wcmU+JztcbiAgfVxuICBpZiAoIXRleHQpIHJldHVybjtcbiAgcmV0dXJuICc8ZGl2IGlkPSRfZGVyYnlFcnJvciBzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlO2JhY2tncm91bmQ6cmdiYSgwLDAsMCwuNyk7dG9wOjA7bGVmdDowO3JpZ2h0OjA7Ym90dG9tOjA7dGV4dC1hbGlnbjpjZW50ZXJcIj4nICtcbiAgICAnPGRpdiBzdHlsZT1cImJhY2tncm91bmQ6I2ZmZjtwYWRkaW5nOjIwcHggNDBweDttYXJnaW46NjBweDtkaXNwbGF5OmlubGluZS1ibG9jazt0ZXh0LWFsaWduOmxlZnRcIj4nICtcbiAgICB0ZXh0ICsgJzwvZGl2PjwvZGl2Pic7XG59XG5cbmZ1bmN0aW9uIGF1dG9SZWZyZXNoKHZpZXcsIG1vZGVsKSB7XG5cbiAgbW9kZWwuY2hhbm5lbC5vbignZGVyYnk6cmVsb2FkJywgcmVsb2FkT25SZWFkeSk7XG4gIC8vIFdhaXQgdG8gcmVsb2FkIHVudGlsIHRoZSBzZXJ2ZXIgaXMgcmVzcG9uc2l2ZSBhZ2FpbiBhZnRlciByZXN0YXJ0aW5nXG4gIGZ1bmN0aW9uIHJlbG9hZE9uUmVhZHkoKSB7XG4gICAgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHhoci5yZWFkeVN0YXRlICE9PSA0KSByZXR1cm47XG4gICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ucmVsb2FkKHRydWUpO1xuICAgICAgfVxuICAgICAgcmVsb2FkT25SZWFkeSgpO1xuICAgIH07XG4gICAgeGhyLm9wZW4oJ0dFVCcsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICB4aHIuc2VuZCgpO1xuICB9XG5cbiAgbW9kZWwuY2hhbm5lbC5vbignZGVyYnk6cmVmcmVzaENzcycsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnJF9jc3MnKTtcbiAgICBpZiAoZWwpIGVsLmlubmVySFRNTCA9IGRhdGEuY3NzO1xuICAgIHVwZGF0ZUVycm9yKCdDU1MnLCBkYXRhLmVyclRleHQpO1xuICB9KTtcblxuICBtb2RlbC5jaGFubmVsLm9uKCdkZXJieTpyZWZyZXNoSHRtbCcsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2aWV3Ll9tYWtlQWxsKGRhdGEudGVtcGxhdGVzLCBkYXRhLmluc3RhbmNlcyk7XG4gICAgdmlldy5fbWFrZUNvbXBvbmVudHMoZGF0YS5saWJyYXJ5RGF0YSk7XG4gICAgdmFyIGVyclRleHQgPSBkYXRhLmVyclRleHQ7XG4gICAgdHJ5IHtcbiAgICAgIHZpZXcuYXBwLmhpc3RvcnkucmVmcmVzaCgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZXJyVGV4dCB8fCAoZXJyVGV4dCA9IGVyci5zdGFjayk7XG4gICAgfVxuICAgIHVwZGF0ZUVycm9yKCdUZW1wbGF0ZScsIGRhdGEuZXJyVGV4dCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVFcnJvcih0eXBlLCBlcnIpIHtcbiAgaWYgKGVycikge1xuICAgIGVycm9yc1t0eXBlXSA9IGVycjtcbiAgfSBlbHNlIHtcbiAgICBkZWxldGUgZXJyb3JzW3R5cGVdO1xuICB9XG4gIHZhciBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCckX2RlcmJ5RXJyb3InKVxuICAgICwgaHRtbCA9IGVycm9ySHRtbChlcnJvcnMpXG4gICAgLCBmcmFnbWVudCwgcmFuZ2U7XG4gIGlmIChodG1sKSB7XG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5vdXRlckhUTUwgPSBodG1sO1xuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICByYW5nZS5zZWxlY3ROb2RlKGRvY3VtZW50LmJvZHkpO1xuICAgICAgZnJhZ21lbnQgPSByYW5nZS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQoaHRtbCk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZyYWdtZW50KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGVsKSBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgfVxufVxuIiwidmFyIFJvdXRlID0gcmVxdWlyZSgnLi4vdmVuZG9yL2V4cHJlc3Mvcm91dGVyL3JvdXRlJylcbnZhciBIaXN0b3J5ID0gcmVxdWlyZSgnLi9IaXN0b3J5JylcbnZhciByb3V0ZXIgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcm91dGVyJylcbnZhciBjb21wb3NlID0gcmVxdWlyZSgnLi9jb21wb3NlJylcblxucm91dGVyLnNldHVwID0gc2V0dXBcblxuZnVuY3Rpb24gc2V0dXAoYXBwLCBjcmVhdGVQYWdlLCBvblJvdXRlKSB7XG4gIHZhciByb3V0ZXMgPSB7XG4gICAgcXVldWU6IHt9XG4gICwgdHJhbnNpdGlvbmFsOiB7fVxuICAsIG9uUm91dGU6IG9uUm91dGVcbiAgfVxuICBhcHAuaGlzdG9yeSA9IG5ldyBIaXN0b3J5KGNyZWF0ZVBhZ2UsIHJvdXRlcylcblxuICA7WydnZXQnLCAncG9zdCcsICdwdXQnLCAnZGVsJywgJ2VudGVyJywgJ2V4aXQnXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIHZhciBxdWV1ZSA9IHJvdXRlcy5xdWV1ZVttZXRob2RdID0gW11cbiAgICB2YXIgdHJhbnNpdGlvbmFsID0gcm91dGVzLnRyYW5zaXRpb25hbFttZXRob2RdID0gW11cbiAgICB2YXIgdHJhbnNpdGlvbmFsQ2FsbHMgPSBbXVxuXG4gICAgYXBwW21ldGhvZF0gPSBmdW5jdGlvbihwYXR0ZXJuLCBjYWxsYmFjaykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICAgICAgcGF0dGVybi5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICBhcHBbbWV0aG9kXShpdGVtLCBjYWxsYmFjaylcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIGFwcFxuICAgICAgfVxuXG4gICAgICBpZiAocm91dGVyLmlzVHJhbnNpdGlvbmFsKHBhdHRlcm4pKSB7XG4gICAgICAgIHZhciBmcm9tID0gcGF0dGVybi5mcm9tXG4gICAgICAgIHZhciB0byA9IHBhdHRlcm4udG9cbiAgICAgICAgdmFyIGZvcndhcmQgPSBwYXR0ZXJuLmZvcndhcmQgfHwgKGNhbGxiYWNrICYmIGNhbGxiYWNrLmZvcndhcmQpIHx8IGNhbGxiYWNrXG4gICAgICAgIHZhciBiYWNrID0gcGF0dGVybi5iYWNrIHx8IChjYWxsYmFjayAmJiBjYWxsYmFjay5iYWNrKVxuICAgICAgICB0cmFuc2l0aW9uYWxDYWxscy5wdXNoKHtcbiAgICAgICAgICBmcm9tOiBmcm9tXG4gICAgICAgICwgdG86IHRvXG4gICAgICAgICwgZm9yd2FyZDogZm9yd2FyZFxuICAgICAgICAsIGJhY2s6IGJhY2tcbiAgICAgICAgfSlcblxuICAgICAgICB2YXIgZnJvbVJvdXRlID0gbmV3IFJvdXRlKG1ldGhvZCwgZnJvbSwgYmFjaylcbiAgICAgICAgdmFyIHRvUm91dGUgPSBuZXcgUm91dGUobWV0aG9kLCB0bywgZm9yd2FyZClcbiAgICAgICAgZnJvbVJvdXRlLmlzVHJhbnNpdGlvbmFsID0gdHJ1ZVxuICAgICAgICB0b1JvdXRlLmlzVHJhbnNpdGlvbmFsID0gdHJ1ZVxuICAgICAgICB0cmFuc2l0aW9uYWwucHVzaCh7XG4gICAgICAgICAgZnJvbTogZnJvbVJvdXRlXG4gICAgICAgICwgdG86IHRvUm91dGVcbiAgICAgICAgfSlcbiAgICAgICAgaWYgKGJhY2spIHRyYW5zaXRpb25hbC5wdXNoKHtcbiAgICAgICAgICBmcm9tOiB0b1JvdXRlXG4gICAgICAgICwgdG86IGZyb21Sb3V0ZVxuICAgICAgICB9KVxuXG4gICAgICAgIGNvbXBvc2UudHJhbnNpdGlvbihhcHBbbWV0aG9kXSwgdHJhbnNpdGlvbmFsQ2FsbHMsIGZyb20sIHRvLCBmb3J3YXJkLCBiYWNrKVxuICAgICAgICByZXR1cm4gYXBwXG4gICAgICB9XG5cbiAgICAgIHF1ZXVlLnB1c2gobmV3IFJvdXRlKG1ldGhvZCwgcGF0dGVybiwgY2FsbGJhY2spKVxuICAgICAgcmV0dXJuIGFwcFxuICAgIH1cbiAgfSlcbn1cbiIsInZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgT2JqZWN0X2tleXMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbidcbiAgICA/IE9iamVjdC5rZXlzXG4gICAgOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9XG47XG5cbnZhciBkZWVwRXF1YWwgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIC8vIGVuZm9yY2UgT2JqZWN0LmlzICswICE9PSAtMFxuICBpZiAoYWN0dWFsID09PSAwICYmIGV4cGVjdGVkID09PSAwKSB7XG4gICAgcmV0dXJuIGFyZVplcm9zRXF1YWwoYWN0dWFsLCBleHBlY3RlZCk7XG5cbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIH0gZWxzZSBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgRGF0ZSAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIH0gZWxzZSBpZiAoaXNOdW1iZXJOYU4oYWN0dWFsKSkge1xuICAgIHJldHVybiBpc051bWJlck5hTihleHBlY3RlZCk7XG5cbiAgLy8gNy4zLiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKHR5cGVvZiBhY3R1YWwgIT0gJ29iamVjdCcgJiYgdHlwZW9mIGV4cGVjdGVkICE9ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGFjdHVhbCA9PSBleHBlY3RlZDtcblxuICAvLyA3LjQuIEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlck5hTih2YWx1ZSkge1xuICAvLyBOYU4gPT09IE5hTiAtPiBmYWxzZVxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYXJlWmVyb3NFcXVhbCh6ZXJvQSwgemVyb0IpIHtcbiAgLy8gKDEgLyArMHwwKSAtPiBJbmZpbml0eSwgYnV0ICgxIC8gLTApIC0+IC1JbmZpbml0eSBhbmQgKEluZmluaXR5ICE9PSAtSW5maW5pdHkpXG4gIHJldHVybiAoMSAvIHplcm9BKSA9PT0gKDEgLyB6ZXJvQik7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIpIHtcbiAgaWYgKGlzVW5kZWZpbmVkT3JOdWxsKGEpIHx8IGlzVW5kZWZpbmVkT3JOdWxsKGIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuXG4gIGlmIChhLnByb3RvdHlwZSAhPT0gYi5wcm90b3R5cGUpIHJldHVybiBmYWxzZTtcbiAgLy9+fn5JJ3ZlIG1hbmFnZWQgdG8gYnJlYWsgT2JqZWN0LmtleXMgdGhyb3VnaCBzY3Jld3kgYXJndW1lbnRzIHBhc3NpbmcuXG4gIC8vICAgQ29udmVydGluZyB0byBhcnJheSBzb2x2ZXMgdGhlIHByb2JsZW0uXG4gIGlmIChpc0FyZ3VtZW50cyhhKSkge1xuICAgIGlmICghaXNBcmd1bWVudHMoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuICAgIGIgPSBwU2xpY2UuY2FsbChiKTtcbiAgICByZXR1cm4gZGVlcEVxdWFsKGEsIGIpO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIGthID0gT2JqZWN0X2tleXMoYSksXG4gICAgICAgIGtiID0gT2JqZWN0X2tleXMoYiksXG4gICAgICAgIGtleSwgaTtcbiAgfSBjYXRjaCAoZSkgey8vaGFwcGVucyB3aGVuIG9uZSBpcyBhIHN0cmluZyBsaXRlcmFsIGFuZCB0aGUgb3RoZXIgaXNuJ3RcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghZGVlcEVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuIiwidmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xuXG4vLyBUaGlzIG1hcCBkZXRlcm1pbmVzIHdoaWNoIGV2ZW50cyBnZXQgcmUtZW1pdHRlZCBhcyBhbiAnYWxsJyBldmVudFxuTW9kZWwuTVVUQVRPUl9FVkVOVFMgPSB7XG4gIGNoYW5nZTogdHJ1ZVxuLCBpbnNlcnQ6IHRydWVcbiwgcmVtb3ZlOiB0cnVlXG4sIG1vdmU6IHRydWVcbiwgc3RyaW5nSW5zZXJ0OiB0cnVlXG4sIHN0cmluZ1JlbW92ZTogdHJ1ZVxuLCBsb2FkOiB0cnVlXG4sIHVubG9hZDogdHJ1ZVxufTtcblxuTW9kZWwuSU5JVFMucHVzaChmdW5jdGlvbihtb2RlbCkge1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAvLyBTZXQgbWF4IGxpc3RlbmVycyB0byB1bmxpbWl0ZWRcbiAgbW9kZWwuc2V0TWF4TGlzdGVuZXJzKDApO1xuXG4gIC8vIFVzZWQgaW4gYXN5bmMgbWV0aG9kcyB0byBlbWl0IGFuIGVycm9yIGV2ZW50IGlmIGEgY2FsbGJhY2sgaXMgbm90IHN1cHBsaWVkLlxuICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgdGhlcmUgaXMgbm8gaGFuZGxlciBmb3IgbW9kZWwub24oJ2Vycm9yJylcbiAgbW9kZWwucm9vdC5fZGVmYXVsdENhbGxiYWNrID0gZGVmYXVsdENhbGxiYWNrO1xuICBmdW5jdGlvbiBkZWZhdWx0Q2FsbGJhY2soZXJyKSB7XG4gICAgaWYgKHR5cGVvZiBlcnIgPT09ICdzdHJpbmcnKSBlcnIgPSBuZXcgRXJyb3IoZXJyKTtcbiAgICBpZiAoZXJyKSBtb2RlbC5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cblxuICBtb2RlbC5yb290Ll9tdXRhdG9yRXZlbnRRdWV1ZSA9IG51bGw7XG4gIG1vZGVsLl9wYXNzID0gbmV3IFBhc3NlZCh7fSwge30pO1xufSk7XG5cbnV0aWwubWVyZ2VJbnRvKE1vZGVsLnByb3RvdHlwZSwgRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5cbi8vIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24sIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIsIGFuZFxuLy8gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlIHJldHVybiBgdGhpc2AuIFRoZSBNb2RlbCBlcXVpdmFsZW50cyByZXR1cm5cbi8vIHRoZSBsaXN0ZW5lciBpbnN0ZWFkLCBzaW5jZSBpdCBpcyBtYWRlIGludGVybmFsbHkgZm9yIG1ldGhvZCBzdWJzY3JpcHRpb25zXG4vLyBhbmQgbWF5IG5lZWQgdG8gYmUgcGFzc2VkIHRvIHJlbW92ZUxpc3RlbmVyLlxuXG5Nb2RlbC5wcm90b3R5cGUuX2VtaXQgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ7XG5Nb2RlbC5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKE1vZGVsLk1VVEFUT1JfRVZFTlRTW3R5cGVdKSB7XG4gICAgaWYgKHRoaXMuX3NpbGVudCkgcmV0dXJuIHRoaXM7XG4gICAgdmFyIHNlZ21lbnRzID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBldmVudEFyZ3MgPSBhcmd1bWVudHNbMl07XG4gICAgaWYgKHRoaXMucm9vdC5fbXV0YXRvckV2ZW50UXVldWUpIHtcbiAgICAgIHRoaXMucm9vdC5fbXV0YXRvckV2ZW50UXVldWUucHVzaChbdHlwZSwgc2VnbWVudHMsIGV2ZW50QXJnc10pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMucm9vdC5fbXV0YXRvckV2ZW50UXVldWUgPSBbXTtcbiAgICB0aGlzLl9lbWl0KHR5cGUsIHNlZ21lbnRzLCBldmVudEFyZ3MpO1xuICAgIHRoaXMuX2VtaXQoJ2FsbCcsIHNlZ21lbnRzLCBbdHlwZV0uY29uY2F0KGV2ZW50QXJncykpO1xuICAgIHdoaWxlICh0aGlzLnJvb3QuX211dGF0b3JFdmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgdmFyIHF1ZXVlZCA9IHRoaXMucm9vdC5fbXV0YXRvckV2ZW50UXVldWUuc2hpZnQoKTtcbiAgICAgIHR5cGUgPSBxdWV1ZWRbMF07XG4gICAgICBzZWdtZW50cyA9IHF1ZXVlZFsxXTtcbiAgICAgIGV2ZW50QXJncyA9IHF1ZXVlZFsyXTtcbiAgICAgIHRoaXMuX2VtaXQodHlwZSwgc2VnbWVudHMsIGV2ZW50QXJncyk7XG4gICAgICB0aGlzLl9lbWl0KCdhbGwnLCBzZWdtZW50cywgW3R5cGVdLmNvbmNhdChldmVudEFyZ3MpKTtcbiAgICB9XG4gICAgdGhpcy5yb290Ll9tdXRhdG9yRXZlbnRRdWV1ZSA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2VtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5fb24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuTW9kZWwucHJvdG90eXBlLmFkZExpc3RlbmVyID1cbk1vZGVsLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKHR5cGUsIHBhdHRlcm4sIGNiKSB7XG4gIHZhciBsaXN0ZW5lciA9IGV2ZW50TGlzdGVuZXIodGhpcywgcGF0dGVybiwgY2IpO1xuICB0aGlzLl9vbih0eXBlLCBsaXN0ZW5lcik7XG4gIHJldHVybiBsaXN0ZW5lcjtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgcGF0dGVybiwgY2IpIHtcbiAgdmFyIGxpc3RlbmVyID0gZXZlbnRMaXN0ZW5lcih0aGlzLCBwYXR0ZXJuLCBjYik7XG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdmFyIG1hdGNoZXMgPSBsaXN0ZW5lci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGlmIChtYXRjaGVzKSB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuICB9XG4gIHRoaXMuX29uKHR5cGUsIGcpO1xuICByZXR1cm4gZztcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5fcmVtb3ZlQWxsTGlzdGVuZXJzID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnM7XG5Nb2RlbC5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSwgc3VicGF0dGVybikge1xuICBpZiAoIXRoaXMuX2V2ZW50cykgcmV0dXJuIHRoaXM7XG5cbiAgLy8gSWYgYSBwYXR0ZXJuIGlzIHNwZWNpZmllZCB3aXRob3V0IGFuIGV2ZW50IHR5cGUsIHJlbW92ZSBhbGwgbW9kZWwgZXZlbnRcbiAgLy8gbGlzdGVuZXJzIHVuZGVyIHRoYXQgcGF0dGVybiBmb3IgYWxsIGV2ZW50c1xuICBpZiAoIXR5cGUpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXksIHN1YnBhdHRlcm4pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBwYXR0ZXJuID0gdGhpcy5wYXRoKHN1YnBhdHRlcm4pO1xuICAvLyBJZiBubyBwYXR0ZXJuIGlzIHNwZWNpZmllZCwgcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgbGlrZSBub3JtYWxcbiAgaWYgKCFwYXR0ZXJuKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbW92ZUFsbExpc3RlbmVycyh0eXBlKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgYW4gZXZlbnQgdW5kZXIgYSBwYXR0ZXJuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycyh0eXBlKTtcbiAgdmFyIHNlZ21lbnRzID0gcGF0dGVybi5zcGxpdCgnLicpO1xuICAvLyBNYWtlIHN1cmUgdG8gaXRlcmF0ZSBpbiByZXZlcnNlLCBzaW5jZSB0aGUgYXJyYXkgbWlnaHQgYmVcbiAgLy8gbXV0YXRlZCBhcyBsaXN0ZW5lcnMgYXJlIHJlbW92ZWRcbiAgZm9yICh2YXIgaSA9IGxpc3RlbmVycy5sZW5ndGg7IGktLTspIHtcbiAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG4gICAgaWYgKHBhdHRlcm5Db250YWluZWQocGF0dGVybiwgc2VnbWVudHMsIGxpc3RlbmVyKSkge1xuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBwYXR0ZXJuQ29udGFpbmVkKHBhdHRlcm4sIHNlZ21lbnRzLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdGVuZXJTZWdtZW50cyA9IGxpc3RlbmVyLnBhdHRlcm5TZWdtZW50cztcbiAgaWYgKCFsaXN0ZW5lclNlZ21lbnRzKSByZXR1cm4gZmFsc2U7XG4gIGlmIChwYXR0ZXJuID09PSBsaXN0ZW5lci5wYXR0ZXJuIHx8IHBhdHRlcm4gPT09ICcqKicpIHJldHVybiB0cnVlO1xuICB2YXIgbGVuID0gc2VnbWVudHMubGVuZ3RoO1xuICBpZiAobGVuID4gbGlzdGVuZXJTZWdtZW50cy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChzZWdtZW50c1tpXSAhPT0gbGlzdGVuZXJTZWdtZW50c1tpXSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5Nb2RlbC5wcm90b3R5cGUucGFzcyA9IGZ1bmN0aW9uKG9iamVjdCwgaW52ZXJ0KSB7XG4gIHZhciBtb2RlbCA9IHRoaXMuX2NoaWxkKCk7XG4gIG1vZGVsLl9wYXNzID0gKGludmVydCkgP1xuICAgIG5ldyBQYXNzZWQob2JqZWN0LCB0aGlzLl9wYXNzKSA6XG4gICAgbmV3IFBhc3NlZCh0aGlzLl9wYXNzLCBvYmplY3QpO1xuICByZXR1cm4gbW9kZWw7XG59O1xuXG5mdW5jdGlvbiBQYXNzZWQocHJldmlvdXMsIHZhbHVlKSB7XG4gIGZvciAodmFyIGtleSBpbiBwcmV2aW91cykge1xuICAgIHRoaXNba2V5XSA9IHByZXZpb3VzW2tleV07XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgdGhpc1trZXldID0gdmFsdWVba2V5XTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSByZXR1cm5lZCBNb2RlbCB3aWxsIG9yIHdvbid0IHRyaWdnZXIgZXZlbnQgaGFuZGxlcnMgd2hlbiB0aGUgbW9kZWwgZW1pdHNcbiAqIGV2ZW50cywgZGVwZW5kaW5nIG9uIGB2YWx1ZWBcbiAqIEBwYXJhbSB7Qm9vbGVhbnxOdWxsfSB2YWx1ZSBkZWZhdWx0cyB0byB0cnVlXG4gKiBAcmV0dXJuIHtNb2RlbH1cbiAqL1xuTW9kZWwucHJvdG90eXBlLnNpbGVudCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBtb2RlbCA9IHRoaXMuX2NoaWxkKCk7XG4gIG1vZGVsLl9zaWxlbnQgPSAodmFsdWUgPT0gbnVsbCkgPyB0cnVlIDogdmFsdWU7XG4gIHJldHVybiBtb2RlbDtcbn07XG5cbmZ1bmN0aW9uIGV2ZW50TGlzdGVuZXIobW9kZWwsIHN1YnBhdHRlcm4sIGNiKSB7XG4gIGlmIChjYikge1xuICAgIC8vIEZvciBzaWduYXR1cmVzOlxuICAgIC8vIG1vZGVsLm9uKCdjaGFuZ2UnLCAnZXhhbXBsZS5zdWJwYXRoJywgY2FsbGJhY2spXG4gICAgLy8gbW9kZWwuYXQoJ2V4YW1wbGUnKS5vbignY2hhbmdlJywgJ3N1YnBhdGgnLCBjYWxsYmFjaylcbiAgICB2YXIgcGF0dGVybiA9IG1vZGVsLnBhdGgoc3VicGF0dGVybik7XG4gICAgcmV0dXJuIG1vZGVsRXZlbnRMaXN0ZW5lcihwYXR0ZXJuLCBjYik7XG4gIH1cbiAgdmFyIHBhdGggPSBtb2RlbC5wYXRoKCk7XG4gIGNiID0gYXJndW1lbnRzWzFdO1xuICAvLyBGb3Igc2lnbmF0dXJlOlxuICAvLyBtb2RlbC5hdCgnZXhhbXBsZScpLm9uKCdjaGFuZ2UnLCBjYWxsYmFjaylcbiAgaWYgKHBhdGgpIHJldHVybiBtb2RlbEV2ZW50TGlzdGVuZXIocGF0aCwgY2IpO1xuICAvLyBGb3Igc2lnbmF0dXJlOlxuICAvLyBtb2RlbC5vbignbm9ybWFsRXZlbnQnLCBjYWxsYmFjaylcbiAgcmV0dXJuIGNiO1xufVxuXG5mdW5jdGlvbiBtb2RlbEV2ZW50TGlzdGVuZXIocGF0dGVybiwgY2IpIHtcbiAgdmFyIHBhdHRlcm5TZWdtZW50cyA9IHBhdHRlcm4uc3BsaXQoJy4nKTtcbiAgdmFyIHRlc3RGbiA9IHRlc3RQYXR0ZXJuRm4ocGF0dGVybiwgcGF0dGVyblNlZ21lbnRzKTtcblxuICBmdW5jdGlvbiBtb2RlbExpc3RlbmVyKHNlZ21lbnRzLCBldmVudEFyZ3MpIHtcbiAgICB2YXIgY2FwdHVyZXMgPSB0ZXN0Rm4oc2VnbWVudHMpO1xuICAgIGlmICghY2FwdHVyZXMpIHJldHVybjtcblxuICAgIHZhciBhcmdzID0gKGNhcHR1cmVzLmxlbmd0aCkgPyBjYXB0dXJlcy5jb25jYXQoZXZlbnRBcmdzKSA6IGV2ZW50QXJncztcbiAgICBjYi5hcHBseShudWxsLCBhcmdzKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFVzZWQgaW4gTW9kZWwjcmVtb3ZlQWxsTGlzdGVuZXJzXG4gIG1vZGVsTGlzdGVuZXIucGF0dGVybiA9IHBhdHRlcm47XG4gIG1vZGVsTGlzdGVuZXIucGF0dGVyblNlZ21lbnRzID0gcGF0dGVyblNlZ21lbnRzO1xuXG4gIHJldHVybiBtb2RlbExpc3RlbmVyO1xufVxuXG5mdW5jdGlvbiB0ZXN0UGF0dGVybkZuKHBhdHRlcm4sIHBhdHRlcm5TZWdtZW50cykge1xuICBpZiAocGF0dGVybiA9PT0gJyoqJykge1xuICAgIHJldHVybiBmdW5jdGlvbiB0ZXN0UGF0dGVybihzZWdtZW50cykge1xuICAgICAgcmV0dXJuIFtzZWdtZW50cy5qb2luKCcuJyldO1xuICAgIH07XG4gIH1cblxuICB2YXIgZW5kaW5nUmVzdCA9IHN0cmlwUmVzdFdpbGRjYXJkKHBhdHRlcm5TZWdtZW50cyk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHRlc3RQYXR0ZXJuKHNlZ21lbnRzKSB7XG4gICAgLy8gQW55IHBhdHRlcm4gd2l0aCBtb3JlIHNlZ21lbnRzIGRvZXMgbm90IG1hdGNoXG4gICAgdmFyIHBhdHRlcm5MZW4gPSBwYXR0ZXJuU2VnbWVudHMubGVuZ3RoO1xuICAgIGlmIChwYXR0ZXJuTGVuID4gc2VnbWVudHMubGVuZ3RoKSByZXR1cm47XG5cbiAgICAvLyBBIHBhdHRlcm4gd2l0aCB0aGUgc2FtZSBudW1iZXIgb2Ygc2VnbWVudHMgbWF0Y2hlcyBpZiBlYWNoXG4gICAgLy8gb2YgdGhlIHNlZ21lbnRzIGFyZSB3aWxkY2FyZHMgb3IgZXF1YWwuIEEgc2hvcnRlciBwYXR0ZXJuIG1hdGNoZXNcbiAgICAvLyBpZiBpdCBlbmRzIGluIGEgcmVzdCB3aWxkY2FyZCBhbmQgZWFjaCBvZiB0aGUgY29ycmVzcG9uZGluZ1xuICAgIC8vIHNlZ21lbnRzIGFyZSB3aWxkY2FyZHMgb3IgZXF1YWwuXG4gICAgaWYgKHBhdHRlcm5MZW4gPT09IHNlZ21lbnRzLmxlbmd0aCB8fCBlbmRpbmdSZXN0KSB7XG4gICAgICB2YXIgY2FwdHVyZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0dGVybkxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBwYXR0ZXJuU2VnbWVudCA9IHBhdHRlcm5TZWdtZW50c1tpXTtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICAgICAgaWYgKHBhdHRlcm5TZWdtZW50ID09PSAnKicgfHwgcGF0dGVyblNlZ21lbnQgPT09ICcqKicpIHtcbiAgICAgICAgICBjYXB0dXJlcy5wdXNoKHNlZ21lbnQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXR0ZXJuU2VnbWVudCAhPT0gc2VnbWVudCkgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGVuZGluZ1Jlc3QpIHtcbiAgICAgICAgdmFyIHJlbWFpbmRlciA9IHNlZ21lbnRzLnNsaWNlKGkpLmpvaW4oJy4nKTtcbiAgICAgICAgY2FwdHVyZXMucHVzaChyZW1haW5kZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhcHR1cmVzO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gc3RyaXBSZXN0V2lsZGNhcmQoc2VnbWVudHMpIHtcbiAgLy8gWydleGFtcGxlJywgJyoqJ10gLT4gWydleGFtcGxlJ107IHJldHVybiB0cnVlXG4gIHZhciBsYXN0SW5kZXggPSBzZWdtZW50cy5sZW5ndGggLSAxO1xuICBpZiAoc2VnbWVudHNbbGFzdEluZGV4XSA9PT0gJyoqJykge1xuICAgIHNlZ21lbnRzLnBvcCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIFsnZXhhbXBsZScsICdzdWJwYXRoKionXSAtPiBbJ2V4YW1wbGUnLCAnc3VicGF0aCddOyByZXR1cm4gdHJ1ZVxuICB2YXIgbWF0Y2ggPSAvXihbXlxcKl0rKVxcKlxcKiQvLmV4ZWMoc2VnbWVudHNbbGFzdEluZGV4XSk7XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWxzZTtcbiAgc2VnbWVudHNbbGFzdEluZGV4XSA9IG1hdGNoWzFdO1xuICByZXR1cm4gdHJ1ZTtcbn1cbiIsInZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcblxuZXhwb3J0cy5taXhpbiA9IHt9O1xuXG5Nb2RlbC5wcm90b3R5cGUuX3NwbGl0UGF0aCA9IGZ1bmN0aW9uKHN1YnBhdGgpIHtcbiAgdmFyIHBhdGggPSB0aGlzLnBhdGgoc3VicGF0aCk7XG4gIHJldHVybiAocGF0aCAmJiBwYXRoLnNwbGl0KCcuJykpIHx8IFtdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXRoIGVxdWl2YWxlbnQgdG8gdGhlIHBhdGggb2YgdGhlIGN1cnJlbnQgc2NvcGVkIG1vZGVsIHBsdXNcbiAqIChvcHRpb25hbGx5KSBhIHN1ZmZpeCBzdWJwYXRoXG4gKlxuICogQG9wdGlvbmFsIEBwYXJhbSB7U3RyaW5nfSBzdWJwYXRoXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGFic29sdXRlIHBhdGhcbiAqIEBhcGkgcHVibGljXG4gKi9cbk1vZGVsLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24oc3VicGF0aCkge1xuICBpZiAoc3VicGF0aCA9PSBudWxsIHx8IHN1YnBhdGggPT09ICcnKSByZXR1cm4gKHRoaXMuX2F0KSA/IHRoaXMuX2F0IDogJyc7XG4gIGlmICh0eXBlb2Ygc3VicGF0aCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHN1YnBhdGggPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuICh0aGlzLl9hdCkgPyB0aGlzLl9hdCArICcuJyArIHN1YnBhdGggOiAnJyArIHN1YnBhdGg7XG4gIH1cbiAgaWYgKHR5cGVvZiBzdWJwYXRoLnBhdGggPT09ICdmdW5jdGlvbicpIHJldHVybiBzdWJwYXRoLnBhdGgoKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5pc1BhdGggPSBmdW5jdGlvbihzdWJwYXRoKSB7XG4gIHJldHVybiB0aGlzLnBhdGgoc3VicGF0aCkgIT0gbnVsbDtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5zY29wZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIG1vZGVsID0gdGhpcy5fY2hpbGQoKTtcbiAgbW9kZWwuX2F0ID0gcGF0aDtcbiAgcmV0dXJuIG1vZGVsO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBtb2RlbCBvYmplY3Qgc2NvcGVkIHRvIGEgcGFydGljdWxhciBwYXRoLlxuICogRXhhbXBsZTpcbiAqICAgICB2YXIgdXNlciA9IG1vZGVsLmF0KCd1c2Vycy4xJyk7XG4gKiAgICAgdXNlci5zZXQoJ3VzZXJuYW1lJywgJ2JyaWFuJyk7XG4gKiAgICAgdXNlci5vbigncHVzaCcsICd0b2RvcycsIGZ1bmN0aW9uICh0b2RvKSB7XG4gKiAgICAgICAvLyAuLi5cbiAqICAgICB9KTtcbiAqXG4gKiAgQHBhcmFtIHtTdHJpbmd9IHNlZ21lbnRcbiAqICBAcmV0dXJuIHtNb2RlbH0gYSBzY29wZWQgbW9kZWxcbiAqICBAYXBpIHB1YmxpY1xuICovXG5Nb2RlbC5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbihzdWJwYXRoKSB7XG4gIHZhciBwYXRoID0gdGhpcy5wYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5zY29wZShwYXRoKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIG1vZGVsIHNjb3BlIHRoYXQgaXMgYSBudW1iZXIgb2YgbGV2ZWxzIGFib3ZlIHRoZSBjdXJyZW50IHNjb3BlZFxuICogcGF0aC4gTnVtYmVyIG9mIGxldmVscyBkZWZhdWx0cyB0byAxLCBzbyB0aGlzIG1ldGhvZCBjYWxsZWQgd2l0aG91dFxuICogYXJndW1lbnRzIHJldHVybnMgdGhlIG1vZGVsIHNjb3BlJ3MgcGFyZW50IG1vZGVsIHNjb3BlLlxuICpcbiAqIEBvcHRpb25hbCBAcGFyYW0ge051bWJlcn0gbGV2ZWxzXG4gKiBAcmV0dXJuIHtNb2RlbH0gYSBzY29wZWQgbW9kZWxcbiAqL1xuTW9kZWwucHJvdG90eXBlLnBhcmVudCA9IGZ1bmN0aW9uKGxldmVscykge1xuICBpZiAobGV2ZWxzID09IG51bGwpIGxldmVscyA9IDE7XG4gIHZhciBzZWdtZW50cyA9IHRoaXMuX3NwbGl0UGF0aCgpO1xuICB2YXIgbGVuID0gTWF0aC5tYXgoMCwgc2VnbWVudHMubGVuZ3RoIC0gbGV2ZWxzKTtcbiAgdmFyIHBhdGggPSBzZWdtZW50cy5zbGljZSgwLCBsZW4pLmpvaW4oJy4nKTtcbiAgcmV0dXJuIHRoaXMuc2NvcGUocGF0aCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGxhc3QgcHJvcGVydHkgc2VnbWVudCBvZiB0aGUgY3VycmVudCBtb2RlbCBzY29wZSBwYXRoXG4gKlxuICogQG9wdGlvbmFsIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbk1vZGVsLnByb3RvdHlwZS5sZWFmID0gZnVuY3Rpb24ocGF0aCkge1xuICBpZiAoIXBhdGgpIHBhdGggPSB0aGlzLnBhdGgoKTtcbiAgdmFyIGkgPSBwYXRoLmxhc3RJbmRleE9mKCcuJyk7XG4gIHJldHVybiBwYXRoLnNsaWNlKGkgKyAxKTtcbn07XG4iLCJ2YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyk7XG52YXIgTG9jYWxEb2MgPSByZXF1aXJlKCcuL0xvY2FsRG9jJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxuZnVuY3Rpb24gQ29sbGVjdGlvbk1hcCgpIHt9XG5mdW5jdGlvbiBNb2RlbERhdGEoKSB7fVxuZnVuY3Rpb24gRG9jTWFwKCkge31cbmZ1bmN0aW9uIENvbGxlY3Rpb25EYXRhKCkge31cblxuTW9kZWwuSU5JVFMucHVzaChmdW5jdGlvbihtb2RlbCkge1xuICBtb2RlbC5yb290LmNvbGxlY3Rpb25zID0gbmV3IENvbGxlY3Rpb25NYXA7XG4gIG1vZGVsLnJvb3QuZGF0YSA9IG5ldyBNb2RlbERhdGE7XG59KTtcblxuTW9kZWwucHJvdG90eXBlLmdldENvbGxlY3Rpb24gPSBmdW5jdGlvbihjb2xsZWN0aW9uTmFtZSkge1xuICByZXR1cm4gdGhpcy5yb290LmNvbGxlY3Rpb25zW2NvbGxlY3Rpb25OYW1lXTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuZ2V0RG9jID0gZnVuY3Rpb24oY29sbGVjdGlvbk5hbWUsIGlkKSB7XG4gIHZhciBjb2xsZWN0aW9uID0gdGhpcy5yb290LmNvbGxlY3Rpb25zW2NvbGxlY3Rpb25OYW1lXTtcbiAgcmV0dXJuIGNvbGxlY3Rpb24gJiYgY29sbGVjdGlvbi5kb2NzW2lkXTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oc3VicGF0aCkge1xuICB2YXIgc2VnbWVudHMgPSB0aGlzLl9zcGxpdFBhdGgoc3VicGF0aCk7XG4gIHJldHVybiB0aGlzLl9nZXQoc2VnbWVudHMpO1xufTtcbk1vZGVsLnByb3RvdHlwZS5fZ2V0ID0gZnVuY3Rpb24oc2VnbWVudHMpIHtcbiAgcmV0dXJuIHV0aWwubG9va3VwKHNlZ21lbnRzLCB0aGlzLnJvb3QuZGF0YSk7XG59O1xuTW9kZWwucHJvdG90eXBlLmdldE9yQ3JlYXRlQ29sbGVjdGlvbiA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLnJvb3QuY29sbGVjdGlvbnNbbmFtZV07XG4gIGlmIChjb2xsZWN0aW9uKSByZXR1cm4gY29sbGVjdGlvbjtcbiAgdmFyIERvYyA9IHRoaXMuX2dldERvY0NvbnN0cnVjdG9yKG5hbWUpO1xuICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24odGhpcy5yb290LCBuYW1lLCBEb2MpO1xuICB0aGlzLnJvb3QuY29sbGVjdGlvbnNbbmFtZV0gPSBjb2xsZWN0aW9uO1xuICByZXR1cm4gY29sbGVjdGlvbjtcbn07XG5Nb2RlbC5wcm90b3R5cGUuX2dldERvY0NvbnN0cnVjdG9yID0gZnVuY3Rpb24oKSB7XG4gIC8vIE9ubHkgY3JlYXRlIGxvY2FsIGRvY3VtZW50cy4gVGhpcyBpcyBvdmVycmlkZW4gaW4gLi9jb25uZWN0aW9uLmpzLCBzbyB0aGF0XG4gIC8vIHRoZSBSZW1vdGVEb2MgYmVoYXZpb3IgY2FuIGJlIHNlbGVjdGl2ZWx5IGluY2x1ZGVkXG4gIHJldHVybiBMb2NhbERvYztcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBleGlzdGluZyBkb2N1bWVudCB3aXRoIGlkIGluIGEgY29sbGVjdGlvbi4gSWYgdGhlIGRvY3VtZW50IGRvZXNcbiAqIG5vdCBleGlzdCwgdGhlbiBjcmVhdGVzIHRoZSBkb2N1bWVudCB3aXRoIGlkIGluIGEgY29sbGVjdGlvbiBhbmQgcmV0dXJucyB0aGVcbiAqIG5ldyBkb2N1bWVudC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2xsZWN0aW9uTmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdIGRhdGEgdG8gY3JlYXRlIGlmIGRvYyB3aXRoIGlkIGRvZXMgbm90IGV4aXN0IGluIGNvbGxlY3Rpb25cbiAqL1xuTW9kZWwucHJvdG90eXBlLmdldE9yQ3JlYXRlRG9jID0gZnVuY3Rpb24oY29sbGVjdGlvbk5hbWUsIGlkLCBkYXRhKSB7XG4gIHZhciBjb2xsZWN0aW9uID0gdGhpcy5nZXRPckNyZWF0ZUNvbGxlY3Rpb24oY29sbGVjdGlvbk5hbWUpO1xuICByZXR1cm4gY29sbGVjdGlvbi5kb2NzW2lkXSB8fCBjb2xsZWN0aW9uLmFkZChpZCwgZGF0YSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2xsZWN0aW9uTmFtZVxuICovXG5Nb2RlbC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb25OYW1lKSB7XG4gIC8vIFRPRE86IG5vbi1jb2xsZWN0aW9uc1xuICB2YXIgY29sbGVjdGlvbiA9IHRoaXMuZ2V0Q29sbGVjdGlvbihjb2xsZWN0aW9uTmFtZSk7XG4gIGNvbGxlY3Rpb24gJiYgY29sbGVjdGlvbi5kZXN0cm95KCk7XG4gIHRoaXMucmVtb3ZlQWxsUmVmcyhjb2xsZWN0aW9uTmFtZSk7XG4gIHRoaXMuc3RvcEFsbChjb2xsZWN0aW9uTmFtZSk7XG4gIHRoaXMucmVtb3ZlQWxsRmlsdGVycyhjb2xsZWN0aW9uTmFtZSk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKG51bGwsIGNvbGxlY3Rpb25OYW1lKTtcbn07XG5cbmZ1bmN0aW9uIENvbGxlY3Rpb24obW9kZWwsIG5hbWUsIERvYykge1xuICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gIHRoaXMubmFtZSA9IG5hbWU7XG4gIHRoaXMuRG9jID0gRG9jO1xuICB0aGlzLmRvY3MgPSBuZXcgRG9jTWFwKCk7XG4gIHRoaXMuZGF0YSA9IG1vZGVsLmRhdGFbbmFtZV0gPSBuZXcgQ29sbGVjdGlvbkRhdGEoKTtcbn1cblxuLyoqXG4gKiBBZGRzIGEgZG9jdW1lbnQgd2l0aCBgaWRgIGFuZCBgZGF0YWAgdG8gYHRoaXNgIENvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcmV0dXJuIHtMb2NhbERvY3xSZW1vdGVEb2N9IGRvY1xuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihpZCwgZGF0YSkge1xuICB2YXIgZG9jID0gbmV3IHRoaXMuRG9jKHRoaXMubW9kZWwsIHRoaXMubmFtZSwgaWQsIGRhdGEpO1xuICB0aGlzLmRvY3NbaWRdID0gZG9jO1xuICByZXR1cm4gZG9jO1xufTtcbkNvbGxlY3Rpb24ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgZGVsZXRlIHRoaXMubW9kZWwuY29sbGVjdGlvbnNbdGhpcy5uYW1lXTtcbiAgZGVsZXRlIHRoaXMubW9kZWwuZGF0YVt0aGlzLm5hbWVdO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBkb2N1bWVudCB3aXRoIGBpZGAgZnJvbSBgdGhpc2AgQ29sbGVjdGlvbi4gSWYgdGhlcmUgYXJlIG5vIG1vcmVcbiAqIGRvY3VtZW50cyBpbiB0aGUgQ29sbGVjdGlvbiBhZnRlciB0aGUgZ2l2ZW4gZG9jdW1lbnQgaXMgcmVtb3ZlZCwgdGhlbiB0aGlzXG4gKiBhbHNvIGRlc3Ryb3lzIHRoZSBDb2xsZWN0aW9uLlxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKi9cbkNvbGxlY3Rpb24ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGlkKSB7XG4gIGRlbGV0ZSB0aGlzLmRvY3NbaWRdO1xuICBkZWxldGUgdGhpcy5kYXRhW2lkXTtcbiAgaWYgKG5vS2V5cyh0aGlzLmRvY3MpKSB0aGlzLmRlc3Ryb3koKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBtYXBzIGRvYyBpZHMgdG8gZnVsbHkgcmVzb2x2ZWQgZG9jdW1lbnRzLlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YTtcbn07XG5cbmZ1bmN0aW9uIG5vS2V5cyhvYmplY3QpIHtcbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xuXG5Nb2RlbC5wcm90b3R5cGUuX211dGF0ZSA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBmbiwgY2IpIHtcbiAgaWYgKCFjYikgY2IgPSB0aGlzLnJvb3QuX2RlZmF1bHRDYWxsYmFjaztcbiAgdmFyIGNvbGxlY3Rpb25OYW1lID0gc2VnbWVudHNbMF07XG4gIHZhciBpZCA9IHNlZ21lbnRzWzFdO1xuICBpZiAoIWNvbGxlY3Rpb25OYW1lIHx8ICFpZCkge1xuICAgIHZhciBtZXNzYWdlID0gZm4ubmFtZSArICcgbXVzdCBiZSBwZXJmb3JtZWQgdW5kZXIgYSBjb2xsZWN0aW9uICcgK1xuICAgICAgJ2FuZCBkb2N1bWVudCBpZC4gSW52YWxpZCBwYXRoOiAnICsgc2VnbWVudHMuam9pbignLicpO1xuICAgIHJldHVybiBjYihuZXcgRXJyb3IobWVzc2FnZSkpO1xuICB9XG4gIHZhciBkb2MgPSB0aGlzLmdldE9yQ3JlYXRlRG9jKGNvbGxlY3Rpb25OYW1lLCBpZCk7XG4gIHZhciBkb2NTZWdtZW50cyA9IHNlZ21lbnRzLnNsaWNlKDIpO1xuICByZXR1cm4gZm4oZG9jLCBkb2NTZWdtZW50cywgY2IpO1xufTtcblxuTW9kZWwucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3VicGF0aCwgdmFsdWUsIGNiO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzFdO1xuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgdmFsdWUgPSBhcmd1bWVudHNbMV07XG4gICAgY2IgPSBhcmd1bWVudHNbMl07XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fc2V0KHNlZ21lbnRzLCB2YWx1ZSwgY2IpO1xufTtcbk1vZGVsLnByb3RvdHlwZS5fc2V0ID0gZnVuY3Rpb24oc2VnbWVudHMsIHZhbHVlLCBjYikge1xuICBzZWdtZW50cyA9IHRoaXMuX2RlcmVmZXJlbmNlKHNlZ21lbnRzKTtcbiAgdmFyIG1vZGVsID0gdGhpcztcbiAgZnVuY3Rpb24gc2V0KGRvYywgZG9jU2VnbWVudHMsIGZuQ2IpIHtcbiAgICB2YXIgcHJldmlvdXMgPSBkb2Muc2V0KGRvY1NlZ21lbnRzLCB2YWx1ZSwgZm5DYik7XG4gICAgbW9kZWwuZW1pdCgnY2hhbmdlJywgc2VnbWVudHMsIFt2YWx1ZSwgcHJldmlvdXMsIG1vZGVsLl9wYXNzXSk7XG4gICAgcmV0dXJuIHByZXZpb3VzO1xuICB9XG4gIHJldHVybiB0aGlzLl9tdXRhdGUoc2VnbWVudHMsIHNldCwgY2IpO1xufTtcblxuTW9kZWwucHJvdG90eXBlLnNldEVhY2ggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN1YnBhdGgsIG9iamVjdCwgY2I7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgb2JqZWN0ID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIG9iamVjdCA9IGFyZ3VtZW50c1sxXTtcbiAgfSBlbHNlIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIG9iamVjdCA9IGFyZ3VtZW50c1sxXTtcbiAgICBjYiA9IGFyZ3VtZW50c1syXTtcbiAgfVxuICB2YXIgc2VnbWVudHMgPSB0aGlzLl9zcGxpdFBhdGgoc3VicGF0aCk7XG4gIHJldHVybiB0aGlzLl9zZXRFYWNoKHNlZ21lbnRzLCBvYmplY3QsIGNiKTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuX3NldEVhY2ggPSBmdW5jdGlvbihzZWdtZW50cywgb2JqZWN0LCBjYikge1xuICBzZWdtZW50cyA9IHRoaXMuX2RlcmVmZXJlbmNlKHNlZ21lbnRzKTtcbiAgdmFyIGdyb3VwID0gdXRpbC5hc3luY0dyb3VwKGNiIHx8IHRoaXMucm9vdC5fZGVmYXVsdENhbGxiYWNrKTtcbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgIHRoaXMuX3NldChzZWdtZW50cy5jb25jYXQoa2V5KSwgdmFsdWUsIGdyb3VwKCkpO1xuICB9XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWJwYXRoLCB2YWx1ZSwgY2I7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFsdWUgPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGNiID0gYXJndW1lbnRzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFsdWUgPSBhcmd1bWVudHNbMV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgdmFsdWUgPSBhcmd1bWVudHNbMV07XG4gICAgY2IgPSBhcmd1bWVudHNbMl07XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fYWRkKHNlZ21lbnRzLCB2YWx1ZSwgY2IpO1xufTtcbk1vZGVsLnByb3RvdHlwZS5fYWRkID0gZnVuY3Rpb24oc2VnbWVudHMsIHZhbHVlLCBjYikge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHZhciBtZXNzYWdlID0gJ2FkZCByZXF1aXJlcyBhbiBvYmplY3QgdmFsdWUuIEludmFsaWQgdmFsdWU6ICcgKyB2YWx1ZTtcbiAgICBjYiB8fCAoY2IgPSB0aGlzLnJvb3QuX2RlZmF1bHRDYWxsYmFjayk7XG4gICAgcmV0dXJuIGNiKG5ldyBFcnJvcihtZXNzYWdlKSk7XG4gIH1cbiAgdmFyIGlkID0gdmFsdWUuaWQgfHwgdGhpcy5pZCgpO1xuICB2YWx1ZS5pZCA9IGlkO1xuICB0aGlzLl9zZXQoc2VnbWVudHMuY29uY2F0KGlkKSwgdmFsdWUsIGNiKTtcbiAgcmV0dXJuIGlkO1xufTtcblxuTW9kZWwucHJvdG90eXBlLnNldE51bGwgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN1YnBhdGgsIHZhbHVlLCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YWx1ZSA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YWx1ZSA9IGFyZ3VtZW50c1sxXTtcbiAgfSBlbHNlIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzFdO1xuICAgIGNiID0gYXJndW1lbnRzWzJdO1xuICB9XG4gIHZhciBzZWdtZW50cyA9IHRoaXMuX3NwbGl0UGF0aChzdWJwYXRoKTtcbiAgcmV0dXJuIHRoaXMuX3NldE51bGwoc2VnbWVudHMsIHZhbHVlLCBjYik7XG59O1xuTW9kZWwucHJvdG90eXBlLl9zZXROdWxsID0gZnVuY3Rpb24oc2VnbWVudHMsIHZhbHVlLCBjYikge1xuICBzZWdtZW50cyA9IHRoaXMuX2RlcmVmZXJlbmNlKHNlZ21lbnRzKTtcbiAgdmFyIG1vZGVsID0gdGhpcztcbiAgZnVuY3Rpb24gc2V0TnVsbChkb2MsIGRvY1NlZ21lbnRzLCBmbkNiKSB7XG4gICAgdmFyIHByZXZpb3VzID0gZG9jLmdldChkb2NTZWdtZW50cyk7XG4gICAgaWYgKHByZXZpb3VzICE9IG51bGwpIHtcbiAgICAgIGZuQ2IoKTtcbiAgICAgIHJldHVybiBwcmV2aW91cztcbiAgICB9XG4gICAgZG9jLnNldChkb2NTZWdtZW50cywgdmFsdWUsIGZuQ2IpO1xuICAgIG1vZGVsLmVtaXQoJ2NoYW5nZScsIHNlZ21lbnRzLCBbdmFsdWUsIHByZXZpb3VzLCBtb2RlbC5fcGFzc10pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcy5fbXV0YXRlKHNlZ21lbnRzLCBzZXROdWxsLCBjYik7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWJwYXRoLCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgY2IgPSBhcmd1bWVudHNbMV07XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fZGVsKHNlZ21lbnRzLCBjYik7XG59O1xuTW9kZWwucHJvdG90eXBlLl9kZWwgPSBmdW5jdGlvbihzZWdtZW50cywgY2IpIHtcbiAgc2VnbWVudHMgPSB0aGlzLl9kZXJlZmVyZW5jZShzZWdtZW50cyk7XG4gIHZhciBtb2RlbCA9IHRoaXM7XG4gIGZ1bmN0aW9uIGRlbChkb2MsIGRvY1NlZ21lbnRzLCBmbkNiKSB7XG4gICAgdmFyIHByZXZpb3VzID0gZG9jLmRlbChkb2NTZWdtZW50cywgZm5DYik7XG4gICAgLy8gV2hlbiBkZWxldGluZyBhbiBlbnRpcmUgZG9jdW1lbnQsIGFsc28gcmVtb3ZlIHRoZSByZWZlcmVuY2UgdG8gdGhlXG4gICAgLy8gZG9jdW1lbnQgb2JqZWN0IGZyb20gaXRzIGNvbGxlY3Rpb25cbiAgICBpZiAoc2VnbWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgY29sbGVjdGlvbk5hbWUgPSBzZWdtZW50c1swXTtcbiAgICAgIHZhciBpZCA9IHNlZ21lbnRzWzFdO1xuICAgICAgbW9kZWwucm9vdC5jb2xsZWN0aW9uc1tjb2xsZWN0aW9uTmFtZV0ucmVtb3ZlKGlkKTtcbiAgICB9XG4gICAgbW9kZWwuZW1pdCgnY2hhbmdlJywgc2VnbWVudHMsIFt2b2lkIDAsIHByZXZpb3VzLCBtb2RlbC5fcGFzc10pO1xuICAgIHJldHVybiBwcmV2aW91cztcbiAgfVxuICByZXR1cm4gdGhpcy5fbXV0YXRlKHNlZ21lbnRzLCBkZWwsIGNiKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5pbmNyZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN1YnBhdGgsIGJ5TnVtYmVyLCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgYnlOdW1iZXIgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgYnlOdW1iZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgICAgYnlOdW1iZXIgPSBhcmd1bWVudHNbMV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgYnlOdW1iZXIgPSBhcmd1bWVudHNbMV07XG4gICAgY2IgPSBhcmd1bWVudHNbMl07XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5faW5jcmVtZW50KHNlZ21lbnRzLCBieU51bWJlciwgY2IpO1xufTtcbk1vZGVsLnByb3RvdHlwZS5faW5jcmVtZW50ID0gZnVuY3Rpb24oc2VnbWVudHMsIGJ5TnVtYmVyLCBjYikge1xuICBzZWdtZW50cyA9IHRoaXMuX2RlcmVmZXJlbmNlKHNlZ21lbnRzKTtcbiAgaWYgKGJ5TnVtYmVyID09IG51bGwpIGJ5TnVtYmVyID0gMTtcbiAgdmFyIG1vZGVsID0gdGhpcztcbiAgZnVuY3Rpb24gaW5jcmVtZW50KGRvYywgZG9jU2VnbWVudHMsIGZuQ2IpIHtcbiAgICB2YXIgdmFsdWUgPSBkb2MuaW5jcmVtZW50KGRvY1NlZ21lbnRzLCBieU51bWJlciwgZm5DYik7XG4gICAgdmFyIHByZXZpb3VzID0gdmFsdWUgLSBieU51bWJlcjtcbiAgICBtb2RlbC5lbWl0KCdjaGFuZ2UnLCBzZWdtZW50cywgW3ZhbHVlLCBwcmV2aW91cywgbW9kZWwuX3Bhc3NdKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX211dGF0ZShzZWdtZW50cywgaW5jcmVtZW50LCBjYik7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3VicGF0aCwgdmFsdWUsIGNiO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzFdO1xuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgdmFsdWUgPSBhcmd1bWVudHNbMV07XG4gICAgY2IgPSBhcmd1bWVudHNbMl07XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fcHVzaChzZWdtZW50cywgdmFsdWUsIGNiKTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuX3B1c2ggPSBmdW5jdGlvbihzZWdtZW50cywgdmFsdWUsIGNiKSB7XG4gIHZhciBmb3JBcnJheU11dGF0b3IgPSB0cnVlO1xuICBzZWdtZW50cyA9IHRoaXMuX2RlcmVmZXJlbmNlKHNlZ21lbnRzLCBmb3JBcnJheU11dGF0b3IpO1xuICB2YXIgbW9kZWwgPSB0aGlzO1xuICBmdW5jdGlvbiBwdXNoKGRvYywgZG9jU2VnbWVudHMsIGZuQ2IpIHtcbiAgICB2YXIgbGVuZ3RoID0gZG9jLnB1c2goZG9jU2VnbWVudHMsIHZhbHVlLCBmbkNiKTtcbiAgICBtb2RlbC5lbWl0KCdpbnNlcnQnLCBzZWdtZW50cywgW2xlbmd0aCAtIDEsIFt2YWx1ZV0sIG1vZGVsLl9wYXNzXSk7XG4gICAgcmV0dXJuIGxlbmd0aDtcbiAgfVxuICByZXR1cm4gdGhpcy5fbXV0YXRlKHNlZ21lbnRzLCBwdXNoLCBjYik7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3VicGF0aCwgdmFsdWUsIGNiO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzFdO1xuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgdmFsdWUgPSBhcmd1bWVudHNbMV07XG4gICAgY2IgPSBhcmd1bWVudHNbMl07XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fdW5zaGlmdChzZWdtZW50cywgdmFsdWUsIGNiKTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuX3Vuc2hpZnQgPSBmdW5jdGlvbihzZWdtZW50cywgdmFsdWUsIGNiKSB7XG4gIHZhciBmb3JBcnJheU11dGF0b3IgPSB0cnVlO1xuICBzZWdtZW50cyA9IHRoaXMuX2RlcmVmZXJlbmNlKHNlZ21lbnRzLCBmb3JBcnJheU11dGF0b3IpO1xuICB2YXIgbW9kZWwgPSB0aGlzO1xuICBmdW5jdGlvbiB1bnNoaWZ0KGRvYywgZG9jU2VnbWVudHMsIGZuQ2IpIHtcbiAgICB2YXIgbGVuZ3RoID0gZG9jLnVuc2hpZnQoZG9jU2VnbWVudHMsIHZhbHVlLCBmbkNiKTtcbiAgICBtb2RlbC5lbWl0KCdpbnNlcnQnLCBzZWdtZW50cywgWzAsIFt2YWx1ZV0sIG1vZGVsLl9wYXNzXSk7XG4gICAgcmV0dXJuIGxlbmd0aDtcbiAgfVxuICByZXR1cm4gdGhpcy5fbXV0YXRlKHNlZ21lbnRzLCB1bnNoaWZ0LCBjYik7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWJwYXRoLCBpbmRleCwgdmFsdWVzLCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdOb3QgZW5vdWdoIGFyZ3VtZW50cyBmb3IgaW5zZXJ0JykpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBpbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YWx1ZXMgPSBhcmd1bWVudHNbMV07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgaW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgdmFsdWVzID0gYXJndW1lbnRzWzJdO1xuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgaW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgdmFsdWVzID0gYXJndW1lbnRzWzJdO1xuICAgIGNiID0gYXJndW1lbnRzWzNdO1xuICB9XG4gIHZhciBzZWdtZW50cyA9IHRoaXMuX3NwbGl0UGF0aChzdWJwYXRoKTtcbiAgcmV0dXJuIHRoaXMuX2luc2VydChzZWdtZW50cywgK2luZGV4LCB2YWx1ZXMsIGNiKTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuX2luc2VydCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBpbmRleCwgdmFsdWVzLCBjYikge1xuICB2YXIgZm9yQXJyYXlNdXRhdG9yID0gdHJ1ZTtcbiAgc2VnbWVudHMgPSB0aGlzLl9kZXJlZmVyZW5jZShzZWdtZW50cywgZm9yQXJyYXlNdXRhdG9yKTtcbiAgdmFyIG1vZGVsID0gdGhpcztcbiAgZnVuY3Rpb24gaW5zZXJ0KGRvYywgZG9jU2VnbWVudHMsIGZuQ2IpIHtcbiAgICB2YXIgaW5zZXJ0ZWQgPSAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSA/IHZhbHVlcyA6IFt2YWx1ZXNdO1xuICAgIHZhciBsZW5ndGggPSBkb2MuaW5zZXJ0KGRvY1NlZ21lbnRzLCBpbmRleCwgaW5zZXJ0ZWQsIGZuQ2IpO1xuICAgIG1vZGVsLmVtaXQoJ2luc2VydCcsIHNlZ21lbnRzLCBbaW5kZXgsIGluc2VydGVkLCBtb2RlbC5fcGFzc10pO1xuICAgIHJldHVybiBsZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX211dGF0ZShzZWdtZW50cywgaW5zZXJ0LCBjYik7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWJwYXRoLCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgY2IgPSBhcmd1bWVudHNbMV07XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fcG9wKHNlZ21lbnRzLCBjYik7XG59O1xuTW9kZWwucHJvdG90eXBlLl9wb3AgPSBmdW5jdGlvbihzZWdtZW50cywgY2IpIHtcbiAgdmFyIGZvckFycmF5TXV0YXRvciA9IHRydWU7XG4gIHNlZ21lbnRzID0gdGhpcy5fZGVyZWZlcmVuY2Uoc2VnbWVudHMsIGZvckFycmF5TXV0YXRvcik7XG4gIHZhciBtb2RlbCA9IHRoaXM7XG4gIGZ1bmN0aW9uIHBvcChkb2MsIGRvY1NlZ21lbnRzLCBmbkNiKSB7XG4gICAgdmFyIGFyciA9IGRvYy5nZXQoZG9jU2VnbWVudHMpO1xuICAgIHZhciBsZW5ndGggPSBhcnIgJiYgYXJyLmxlbmd0aDtcbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgZm5DYigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBkb2MucG9wKGRvY1NlZ21lbnRzLCBmbkNiKTtcbiAgICBtb2RlbC5lbWl0KCdyZW1vdmUnLCBzZWdtZW50cywgW2xlbmd0aCAtIDEsIFt2YWx1ZV0sIG1vZGVsLl9wYXNzXSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzLl9tdXRhdGUoc2VnbWVudHMsIHBvcCwgY2IpO1xufTtcblxuTW9kZWwucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWJwYXRoLCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgY2IgPSBhcmd1bWVudHNbMV07XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fc2hpZnQoc2VnbWVudHMsIGNiKTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuX3NoaWZ0ID0gZnVuY3Rpb24oc2VnbWVudHMsIGNiKSB7XG4gIHZhciBmb3JBcnJheU11dGF0b3IgPSB0cnVlO1xuICBzZWdtZW50cyA9IHRoaXMuX2RlcmVmZXJlbmNlKHNlZ21lbnRzLCBmb3JBcnJheU11dGF0b3IpO1xuICB2YXIgbW9kZWwgPSB0aGlzO1xuICBmdW5jdGlvbiBzaGlmdChkb2MsIGRvY1NlZ21lbnRzLCBmbkNiKSB7XG4gICAgdmFyIGFyciA9IGRvYy5nZXQoZG9jU2VnbWVudHMpO1xuICAgIHZhciBsZW5ndGggPSBhcnIgJiYgYXJyLmxlbmd0aDtcbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgZm5DYigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBkb2Muc2hpZnQoZG9jU2VnbWVudHMsIGZuQ2IpO1xuICAgIG1vZGVsLmVtaXQoJ3JlbW92ZScsIHNlZ21lbnRzLCBbMCwgW3ZhbHVlXSwgbW9kZWwuX3Bhc3NdKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX211dGF0ZShzZWdtZW50cywgc2hpZnQsIGNiKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN1YnBhdGgsIGluZGV4LCBob3dNYW55LCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGluZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGluZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICBob3dNYW55ID0gYXJndW1lbnRzWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgaW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBhcmd1bWVudHNbMl07XG4gICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgICAgIGhvd01hbnkgPSBhcmd1bWVudHNbMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgICAgICBpbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGluZGV4ID0gYXJndW1lbnRzWzFdO1xuICAgICAgaG93TWFueSA9IGFyZ3VtZW50c1syXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICBpbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgICBob3dNYW55ID0gYXJndW1lbnRzWzJdO1xuICAgIGNiID0gYXJndW1lbnRzWzNdO1xuICB9XG4gIHZhciBzZWdtZW50cyA9IHRoaXMuX3NwbGl0UGF0aChzdWJwYXRoKTtcbiAgaWYgKGluZGV4ID09IG51bGwpIGluZGV4ID0gc2VnbWVudHMucG9wKCk7XG4gIHJldHVybiB0aGlzLl9yZW1vdmUoc2VnbWVudHMsICtpbmRleCwgaG93TWFueSwgY2IpO1xufTtcbk1vZGVsLnByb3RvdHlwZS5fcmVtb3ZlID0gZnVuY3Rpb24oc2VnbWVudHMsIGluZGV4LCBob3dNYW55LCBjYikge1xuICB2YXIgZm9yQXJyYXlNdXRhdG9yID0gdHJ1ZTtcbiAgc2VnbWVudHMgPSB0aGlzLl9kZXJlZmVyZW5jZShzZWdtZW50cywgZm9yQXJyYXlNdXRhdG9yKTtcbiAgaWYgKGhvd01hbnkgPT0gbnVsbCkgaG93TWFueSA9IDE7XG4gIHZhciBtb2RlbCA9IHRoaXM7XG4gIGZ1bmN0aW9uIHJlbW92ZShkb2MsIGRvY1NlZ21lbnRzLCBmbkNiKSB7XG4gICAgdmFyIHJlbW92ZWQgPSBkb2MucmVtb3ZlKGRvY1NlZ21lbnRzLCBpbmRleCwgaG93TWFueSwgZm5DYik7XG4gICAgbW9kZWwuZW1pdCgncmVtb3ZlJywgc2VnbWVudHMsIFtpbmRleCwgcmVtb3ZlZCwgbW9kZWwuX3Bhc3NdKTtcbiAgICByZXR1cm4gcmVtb3ZlZDtcbiAgfVxuICByZXR1cm4gdGhpcy5fbXV0YXRlKHNlZ21lbnRzLCByZW1vdmUsIGNiKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWJwYXRoLCBmcm9tLCB0bywgaG93TWFueSwgY2I7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignTm90IGVub3VnaCBhcmd1bWVudHMgZm9yIG1vdmUnKSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIGZyb20gPSBhcmd1bWVudHNbMF07XG4gICAgdG8gPSBhcmd1bWVudHNbMV07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmcm9tID0gYXJndW1lbnRzWzBdO1xuICAgICAgdG8gPSBhcmd1bWVudHNbMV07XG4gICAgICBjYiA9IGFyZ3VtZW50c1syXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICBmcm9tID0gYXJndW1lbnRzWzBdO1xuICAgICAgdG8gPSBhcmd1bWVudHNbMV07XG4gICAgICBob3dNYW55ID0gYXJndW1lbnRzWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgICAgZnJvbSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHRvID0gYXJndW1lbnRzWzJdO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gYXJndW1lbnRzWzNdO1xuICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGZyb20gPSBhcmd1bWVudHNbMF07XG4gICAgICAgIHRvID0gYXJndW1lbnRzWzFdO1xuICAgICAgICBob3dNYW55ID0gYXJndW1lbnRzWzJdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgZnJvbSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdG8gPSBhcmd1bWVudHNbMl07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgICBmcm9tID0gYXJndW1lbnRzWzFdO1xuICAgICAgdG8gPSBhcmd1bWVudHNbMl07XG4gICAgICBob3dNYW55ID0gYXJndW1lbnRzWzNdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIGZyb20gPSBhcmd1bWVudHNbMV07XG4gICAgdG8gPSBhcmd1bWVudHNbMl07XG4gICAgaG93TWFueSA9IGFyZ3VtZW50c1szXTtcbiAgICBjYiA9IGFyZ3VtZW50c1s0XTtcbiAgfVxuICB2YXIgc2VnbWVudHMgPSB0aGlzLl9zcGxpdFBhdGgoc3VicGF0aCk7XG4gIHJldHVybiB0aGlzLl9tb3ZlKHNlZ21lbnRzLCBmcm9tLCB0bywgaG93TWFueSwgY2IpO1xufTtcbk1vZGVsLnByb3RvdHlwZS5fbW92ZSA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBmcm9tLCB0bywgaG93TWFueSwgY2IpIHtcbiAgdmFyIGZvckFycmF5TXV0YXRvciA9IHRydWU7XG4gIHNlZ21lbnRzID0gdGhpcy5fZGVyZWZlcmVuY2Uoc2VnbWVudHMsIGZvckFycmF5TXV0YXRvcik7XG4gIGlmIChob3dNYW55ID09IG51bGwpIGhvd01hbnkgPSAxO1xuICB2YXIgbW9kZWwgPSB0aGlzO1xuICBmdW5jdGlvbiBtb3ZlKGRvYywgZG9jU2VnbWVudHMsIGZuQ2IpIHtcbiAgICAvLyBDYXN0IHRvIG51bWJlcnNcbiAgICBmcm9tID0gK2Zyb207XG4gICAgdG8gPSArdG87XG4gICAgLy8gQ29udmVydCBuZWdhdGl2ZSBpbmRpY2VzIGludG8gcG9zaXRpdmVcbiAgICBpZiAoZnJvbSA8IDAgfHwgdG8gPCAwKSB7XG4gICAgICB2YXIgbGVuID0gZG9jLmdldChkb2NTZWdtZW50cykubGVuZ3RoO1xuICAgICAgaWYgKGZyb20gPCAwKSBmcm9tICs9IGxlbjtcbiAgICAgIGlmICh0byA8IDApIHRvICs9IGxlbjtcbiAgICB9XG4gICAgdmFyIG1vdmVkID0gZG9jLm1vdmUoZG9jU2VnbWVudHMsIGZyb20sIHRvLCBob3dNYW55LCBmbkNiKTtcbiAgICBtb2RlbC5lbWl0KCdtb3ZlJywgc2VnbWVudHMsIFtmcm9tLCB0bywgbW92ZWQubGVuZ3RoLCBtb2RlbC5fcGFzc10pO1xuICAgIHJldHVybiBtb3ZlZDtcbiAgfVxuICByZXR1cm4gdGhpcy5fbXV0YXRlKHNlZ21lbnRzLCBtb3ZlLCBjYik7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuc3RyaW5nSW5zZXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWJwYXRoLCBpbmRleCwgdGV4dCwgY2I7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignTm90IGVub3VnaCBhcmd1bWVudHMgZm9yIHN0cmluZ0luc2VydCcpKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgaW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgdGV4dCA9IGFyZ3VtZW50c1sxXTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGV4dCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGNiID0gYXJndW1lbnRzWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgICAgaW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgICB0ZXh0ID0gYXJndW1lbnRzWzJdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIGluZGV4ID0gYXJndW1lbnRzWzFdO1xuICAgIHRleHQgPSBhcmd1bWVudHNbMl07XG4gICAgY2IgPSBhcmd1bWVudHNbM107XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fc3RyaW5nSW5zZXJ0KHNlZ21lbnRzLCBpbmRleCwgdGV4dCwgY2IpO1xufTtcbk1vZGVsLnByb3RvdHlwZS5fc3RyaW5nSW5zZXJ0ID0gZnVuY3Rpb24oc2VnbWVudHMsIGluZGV4LCB0ZXh0LCBjYikge1xuICBzZWdtZW50cyA9IHRoaXMuX2RlcmVmZXJlbmNlKHNlZ21lbnRzKTtcbiAgdmFyIG1vZGVsID0gdGhpcztcbiAgZnVuY3Rpb24gc3RyaW5nSW5zZXJ0KGRvYywgZG9jU2VnbWVudHMsIGZuQ2IpIHtcbiAgICB2YXIgcHJldmlvdXMgPSBkb2Muc3RyaW5nSW5zZXJ0KGRvY1NlZ21lbnRzLCBpbmRleCwgdGV4dCwgZm5DYik7XG4gICAgbW9kZWwuZW1pdCgnc3RyaW5nSW5zZXJ0Jywgc2VnbWVudHMsIFtpbmRleCwgdGV4dCwgbW9kZWwuX3Bhc3NdKTtcbiAgICB2YXIgdmFsdWUgPSBkb2MuZ2V0KGRvY1NlZ21lbnRzKTtcbiAgICB2YXIgcGFzcyA9IG1vZGVsLnBhc3MoeyRvcmlnaW5hbDogJ3N0cmluZ0luc2VydCd9KS5fcGFzcztcbiAgICBtb2RlbC5lbWl0KCdjaGFuZ2UnLCBzZWdtZW50cywgW3ZhbHVlLCBwcmV2aW91cywgcGFzc10pO1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gdGhpcy5fbXV0YXRlKHNlZ21lbnRzLCBzdHJpbmdJbnNlcnQsIGNiKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5zdHJpbmdSZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN1YnBhdGgsIGluZGV4LCBob3dNYW55LCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdOb3QgZW5vdWdoIGFyZ3VtZW50cyBmb3Igc3RyaW5nUmVtb3ZlJykpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBpbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgICBob3dNYW55ID0gYXJndW1lbnRzWzFdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgICBob3dNYW55ID0gYXJndW1lbnRzWzFdO1xuICAgICAgY2IgPSBhcmd1bWVudHNbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgICBpbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGhvd01hbnkgPSBhcmd1bWVudHNbMl07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgaW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgaG93TWFueSA9IGFyZ3VtZW50c1syXTtcbiAgICBjYiA9IGFyZ3VtZW50c1szXTtcbiAgfVxuICB2YXIgc2VnbWVudHMgPSB0aGlzLl9zcGxpdFBhdGgoc3VicGF0aCk7XG4gIHJldHVybiB0aGlzLl9zdHJpbmdSZW1vdmUoc2VnbWVudHMsIGluZGV4LCBob3dNYW55LCBjYik7XG59O1xuTW9kZWwucHJvdG90eXBlLl9zdHJpbmdSZW1vdmUgPSBmdW5jdGlvbihzZWdtZW50cywgaW5kZXgsIGhvd01hbnksIGNiKSB7XG4gIHNlZ21lbnRzID0gdGhpcy5fZGVyZWZlcmVuY2Uoc2VnbWVudHMpO1xuICB2YXIgbW9kZWwgPSB0aGlzO1xuICBmdW5jdGlvbiBzdHJpbmdSZW1vdmUoZG9jLCBkb2NTZWdtZW50cywgZm5DYikge1xuICAgIHZhciBwcmV2aW91cyA9IGRvYy5zdHJpbmdSZW1vdmUoZG9jU2VnbWVudHMsIGluZGV4LCBob3dNYW55LCBmbkNiKTtcbiAgICBtb2RlbC5lbWl0KCdzdHJpbmdSZW1vdmUnLCBzZWdtZW50cywgW2luZGV4LCBob3dNYW55LCBtb2RlbC5fcGFzc10pO1xuICAgIHZhciB2YWx1ZSA9IGRvYy5nZXQoZG9jU2VnbWVudHMpO1xuICAgIHZhciBwYXNzID0gbW9kZWwucGFzcyh7JG9yaWdpbmFsOiAnc3RyaW5nUmVtb3ZlJ30pLl9wYXNzO1xuICAgIG1vZGVsLmVtaXQoJ2NoYW5nZScsIHNlZ21lbnRzLCBbdmFsdWUsIHByZXZpb3VzLCBwYXNzXSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiB0aGlzLl9tdXRhdGUoc2VnbWVudHMsIHN0cmluZ1JlbW92ZSwgY2IpO1xufTtcbiIsIihmdW5jdGlvbihwcm9jZXNzKXt2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcbnZhciBRdWVyeSA9IHJlcXVpcmUoJy4vUXVlcnknKTtcblxuTW9kZWwuSU5JVFMucHVzaChmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICBtb2RlbC5yb290LmZldGNoT25seSA9IG9wdGlvbnMuZmV0Y2hPbmx5O1xuICBtb2RlbC5yb290LnVubG9hZERlbGF5ID0gb3B0aW9ucy51bmxvYWREZWxheSB8fCAxMDAwO1xuXG4gIC8vIEtlZXBzIHRyYWNrIG9mIHRoZSBjb3VudCBvZiBmZXRjaGVzICh0aGF0IGhhdmVuJ3QgYmVlbiB1bmRvbmUgYnkgYW5cbiAgLy8gdW5mZXRjaCkgcGVyIGRvYy4gTWFwcyBkb2MgaWQgdG8gdGhlIGZldGNoIGNvdW50LlxuICBtb2RlbC5yb290Ll9mZXRjaGVkRG9jcyA9IG5ldyBGZXRjaGVkRG9jcztcblxuICAvLyBLZWVwcyB0cmFjayBvZiB0aGUgY291bnQgb2Ygc3Vic2NyaWJlcyAodGhhdCBoYXZlbid0IGJlZW4gdW5kb25lIGJ5IGFuXG4gIC8vIHVuc3Vic2NyaWJlKSBwZXIgZG9jLiBNYXBzIGRvYyBpZCB0byB0aGUgc3Vic2NyaWJlIGNvdW50LlxuICBtb2RlbC5yb290Ll9zdWJzY3JpYmVkRG9jcyA9IG5ldyBTdWJzY3JpYmVkRG9jcztcblxuICAvLyBNYXBzIGRvYyBwYXRoIHRvIGRvYyB2ZXJzaW9uXG4gIG1vZGVsLnJvb3QuX2xvYWRWZXJzaW9ucyA9IG5ldyBMb2FkVmVyc2lvbnM7XG59KTtcblxuZnVuY3Rpb24gRmV0Y2hlZERvY3MoKSB7fVxuZnVuY3Rpb24gU3Vic2NyaWJlZERvY3MoKSB7fVxuZnVuY3Rpb24gTG9hZFZlcnNpb25zKCkge31cblxuTW9kZWwucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2ZvclN1YnNjcmliYWJsZShhcmd1bWVudHMsICdmZXRjaCcpO1xuICByZXR1cm4gdGhpcztcbn07XG5Nb2RlbC5wcm90b3R5cGUudW5mZXRjaCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9mb3JTdWJzY3JpYmFibGUoYXJndW1lbnRzLCAndW5mZXRjaCcpO1xuICByZXR1cm4gdGhpcztcbn07XG5Nb2RlbC5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2ZvclN1YnNjcmliYWJsZShhcmd1bWVudHMsICdzdWJzY3JpYmUnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuTW9kZWwucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2ZvclN1YnNjcmliYWJsZShhcmd1bWVudHMsICd1bnN1YnNjcmliZScpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJndW1lbnRzfSBhcmd1bWVudHNPYmplY3QgY2FuIHRha2UgMSBvZiB0d28gZm9ybXNcbiAqICAgMS4gW1tzdWJzY3JpYmFibGVPYmplY3RzLi4uXSwgY2JdXG4gKiAgIDIuIFtzdWJzY3JpYmFibGVPYmplY3RzLi4uLCBjYl1cbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgY2FuIGJlICdmZXRjaCcsICd1bmZldGNoJywgJ3N1YnNjcmliZScsICd1bnN1YnNjcmliZSdcbiAqL1xuTW9kZWwucHJvdG90eXBlLl9mb3JTdWJzY3JpYmFibGUgPSBmdW5jdGlvbihhcmd1bWVudHNPYmplY3QsIG1ldGhvZCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcmd1bWVudHNPYmplY3RbMF0pKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHNPYmplY3RbMF07XG4gICAgdmFyIGNiID0gYXJndW1lbnRzT2JqZWN0WzFdIHx8IHRoaXMucm9vdC5fZGVmYXVsdENhbGxiYWNrO1xuICB9IGVsc2Uge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzT2JqZWN0KTtcbiAgICB2YXIgbGFzdCA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICB2YXIgY2IgPSAodHlwZW9mIGxhc3QgPT09ICdmdW5jdGlvbicpID8gYXJncy5wb3AoKSA6IHRoaXMucm9vdC5fZGVmYXVsdENhbGxiYWNrO1xuICB9XG4gIC8vIElmIG5vIHF1ZXJpZXMgb3IgcGF0aHMgYXJlIHBhc3NlZCBpbiwgdHJ5IHRvIHVzZSB0aGlzIG1vZGVsJ3Mgc2NvcGVcbiAgaWYgKCFhcmdzLmxlbmd0aCkgYXJncy5wdXNoKG51bGwpO1xuICB2YXIgZ3JvdXAgPSB1dGlsLmFzeW5jR3JvdXAoY2IpO1xuICB2YXIgZG9jTWV0aG9kID0gbWV0aG9kICsgJ0RvYyc7XG5cbiAgdmFyIGZpbmlzaGVkID0gZ3JvdXAoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBhcmdzW2ldO1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUXVlcnkpIHtcbiAgICAgIGl0ZW1bbWV0aG9kXShncm91cCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5fZGVyZWZlcmVuY2UodGhpcy5fc3BsaXRQYXRoKGl0ZW0pKTtcbiAgICAgIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgLy8gRG8gdGhlIGFwcHJvcHJpYXRlIG1ldGhvZCBmb3IgYSBzaW5nbGUgZG9jdW1lbnQuXG4gICAgICAgIHRoaXNbZG9jTWV0aG9kXShzZWdtZW50c1swXSwgc2VnbWVudHNbMV0sIGdyb3VwKCkpO1xuICAgICAgfSBlbHNlIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gTWFrZSBhIHF1ZXJ5IHRvIGFuIGVudGlyZSBjb2xsZWN0aW9uLlxuICAgICAgICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5KHNlZ21lbnRzWzBdLCB7fSk7XG4gICAgICAgIHF1ZXJ5W21ldGhvZF0oZ3JvdXAoKSk7XG4gICAgICB9IGVsc2UgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYihuZXcgRXJyb3IoJ05vIHBhdGggc3BlY2lmaWVkIGZvciAnICsgbWV0aG9kKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYihuZXcgRXJyb3IoJ0Nhbm5vdCAnICsgbWV0aG9kICsgJyB0byBhIHBhdGggd2l0aGluIGEgZG9jdW1lbnQ6ICcgK1xuICAgICAgICAgICAgc2VnbWVudHMuam9pbignLicpKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZpbmlzaGVkKCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfVxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYihlcnIpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFscmVhZHlMb2FkZWRcbiAqL1xuTW9kZWwucHJvdG90eXBlLmZldGNoRG9jID0gZnVuY3Rpb24oY29sbGVjdGlvbk5hbWUsIGlkLCBjYiwgYWxyZWFkeUxvYWRlZCkge1xuICBpZiAoIWNiKSBjYiA9IHRoaXMucm9vdC5fZGVmYXVsdENhbGxiYWNrO1xuXG4gIC8vIE1haW50YWluIGEgY291bnQgb2YgZmV0Y2hlcyBzbyB0aGF0IHdlIGNhbiB1bmxvYWQgdGhlIGRvY3VtZW50IHdoZW5cbiAgLy8gdGhlcmUgYXJlIG5vIHJlbWFpbmluZyBmZXRjaGVzIG9yIHN1YnNjcmliZXMgZm9yIHRoYXQgZG9jdW1lbnRcbiAgdmFyIHBhdGggPSBjb2xsZWN0aW9uTmFtZSArICcuJyArIGlkO1xuICB0aGlzLmVtaXQoJ2ZldGNoRG9jJywgcGF0aCwgdGhpcy5fY29udGV4dCwgdGhpcy5fcGFzcyk7XG4gIHRoaXMucm9vdC5fZmV0Y2hlZERvY3NbcGF0aF0gPSAodGhpcy5yb290Ll9mZXRjaGVkRG9jc1twYXRoXSB8fCAwKSArIDE7XG5cbiAgdmFyIG1vZGVsID0gdGhpcztcbiAgdmFyIGRvYyA9IHRoaXMuZ2V0T3JDcmVhdGVEb2MoY29sbGVjdGlvbk5hbWUsIGlkKTtcbiAgaWYgKGFscmVhZHlMb2FkZWQpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZldGNoRG9jQ2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIGRvYy5zaGFyZURvYy5mZXRjaChmZXRjaERvY0NhbGxiYWNrKTtcbiAgfVxuICBmdW5jdGlvbiBmZXRjaERvY0NhbGxiYWNrKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuICAgIGlmIChkb2Muc2hhcmVEb2MudmVyc2lvbiAhPT0gbW9kZWwucm9vdC5fbG9hZFZlcnNpb25zW3BhdGhdKSB7XG4gICAgICBtb2RlbC5yb290Ll9sb2FkVmVyc2lvbnNbcGF0aF0gPSBkb2Muc2hhcmVEb2MudmVyc2lvbjtcbiAgICAgIGRvYy5fdXBkYXRlQ29sbGVjdGlvbkRhdGEoKTtcbiAgICAgIG1vZGVsLmVtaXQoJ2xvYWQnLCBbY29sbGVjdGlvbk5hbWUsIGlkXSwgW2RvYy5nZXQoKSwgbW9kZWwuX3Bhc3NdKTtcbiAgICB9XG4gICAgY2IoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sbGVjdGlvbk5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCBvZiB0aGUgZG9jdW1lbnQgd2Ugd2FudCB0byBzdWJzY3JpYmUgdG9cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiKGVycilcbiAqL1xuTW9kZWwucHJvdG90eXBlLnN1YnNjcmliZURvYyA9IGZ1bmN0aW9uKGNvbGxlY3Rpb25OYW1lLCBpZCwgY2IpIHtcbiAgaWYgKCFjYikgY2IgPSB0aGlzLnJvb3QuX2RlZmF1bHRDYWxsYmFjaztcblxuICB2YXIgcGF0aCA9IGNvbGxlY3Rpb25OYW1lICsgJy4nICsgaWQ7XG4gIHRoaXMuZW1pdCgnc3Vic2NyaWJlRG9jJywgcGF0aCwgdGhpcy5fY29udGV4dCwgdGhpcy5fcGFzcyk7XG4gIHZhciBjb3VudCA9IHRoaXMucm9vdC5fc3Vic2NyaWJlZERvY3NbcGF0aF0gPSAodGhpcy5yb290Ll9zdWJzY3JpYmVkRG9jc1twYXRoXSB8fCAwKSArIDE7XG4gIC8vIEFscmVhZHkgcmVxdWVzdGVkIGEgc3Vic2NyaWJlLCBzbyBqdXN0IHJldHVyblxuICBpZiAoY291bnQgPiAxKSByZXR1cm4gY2IoKTtcblxuICAvLyBTdWJzY3JpYmUgaWYgY3VycmVudGx5IHVuc3Vic2NyaWJlZFxuICB2YXIgbW9kZWwgPSB0aGlzO1xuICB2YXIgZG9jID0gdGhpcy5nZXRPckNyZWF0ZURvYyhjb2xsZWN0aW9uTmFtZSwgaWQpO1xuICBpZiAodGhpcy5yb290LmZldGNoT25seSkge1xuICAgIC8vIE9ubHkgZmV0Y2ggaWYgdGhlIGRvY3VtZW50IGlzbid0IGFscmVhZHkgbG9hZGVkXG4gICAgaWYgKGRvYy5nZXQoKSA9PT0gdm9pZCAwKSB7XG4gICAgICBkb2Muc2hhcmVEb2MuZmV0Y2goc3Vic2NyaWJlRG9jQ2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKHN1YnNjcmliZURvY0NhbGxiYWNrKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZG9jLnNoYXJlRG9jLnN1YnNjcmliZShzdWJzY3JpYmVEb2NDYWxsYmFjayk7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlRG9jQ2FsbGJhY2soZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgaWYgKCFkb2MuY3JlYXRlZExvY2FsbHkgJiYgZG9jLnNoYXJlRG9jLnZlcnNpb24gIT09IG1vZGVsLnJvb3QuX2xvYWRWZXJzaW9uc1twYXRoXSkge1xuICAgICAgbW9kZWwucm9vdC5fbG9hZFZlcnNpb25zW3BhdGhdID0gZG9jLnNoYXJlRG9jLnZlcnNpb247XG4gICAgICBkb2MuX3VwZGF0ZUNvbGxlY3Rpb25EYXRhKCk7XG4gICAgICBtb2RlbC5lbWl0KCdsb2FkJywgW2NvbGxlY3Rpb25OYW1lLCBpZF0sIFtkb2MuZ2V0KCksIG1vZGVsLl9wYXNzXSk7XG4gICAgfVxuICAgIGNiKCk7XG4gIH1cbn07XG5cbk1vZGVsLnByb3RvdHlwZS51bmZldGNoRG9jID0gZnVuY3Rpb24oY29sbGVjdGlvbk5hbWUsIGlkLCBjYikge1xuICBpZiAoIWNiKSBjYiA9IHRoaXMucm9vdC5fZGVmYXVsdENhbGxiYWNrO1xuICB2YXIgcGF0aCA9IGNvbGxlY3Rpb25OYW1lICsgJy4nICsgaWQ7XG4gIHRoaXMuZW1pdCgndW5mZXRjaERvYycsIHBhdGgsIHRoaXMuX2NvbnRleHQsIHRoaXMuX3Bhc3MpO1xuICB2YXIgZmV0Y2hlZERvY3MgPSB0aGlzLnJvb3QuX2ZldGNoZWREb2NzO1xuXG4gIC8vIE5vIGVmZmVjdCBpZiB0aGUgZG9jdW1lbnQgaGFzIG5vIGZldGNoIGNvdW50XG4gIGlmICghZmV0Y2hlZERvY3NbcGF0aF0pIHJldHVybiBjYigpO1xuXG4gIHZhciBtb2RlbCA9IHRoaXM7XG4gIGlmICh0aGlzLnJvb3QudW5sb2FkRGVsYXkgJiYgIXRoaXMuX3Bhc3MuJHF1ZXJ5KSB7XG4gICAgc2V0VGltZW91dChmaW5pc2hVbmZldGNoRG9jLCB0aGlzLnJvb3QudW5sb2FkRGVsYXkpO1xuICB9IGVsc2Uge1xuICAgIGZpbmlzaFVuZmV0Y2hEb2MoKTtcbiAgfVxuICBmdW5jdGlvbiBmaW5pc2hVbmZldGNoRG9jKCkge1xuICAgIHZhciBjb3VudCA9IC0tZmV0Y2hlZERvY3NbcGF0aF07XG4gICAgaWYgKGNvdW50KSByZXR1cm4gY2IobnVsbCwgY291bnQpO1xuICAgIGRlbGV0ZSBmZXRjaGVkRG9jc1twYXRoXTtcbiAgICBtb2RlbC5fbWF5YmVVbmxvYWREb2MoY29sbGVjdGlvbk5hbWUsIGlkLCBwYXRoKTtcbiAgICBjYihudWxsLCAwKTtcbiAgfVxufTtcblxuTW9kZWwucHJvdG90eXBlLnVuc3Vic2NyaWJlRG9jID0gZnVuY3Rpb24oY29sbGVjdGlvbk5hbWUsIGlkLCBjYikge1xuICBpZiAoIWNiKSBjYiA9IHRoaXMucm9vdC5fZGVmYXVsdENhbGxiYWNrO1xuICB2YXIgcGF0aCA9IGNvbGxlY3Rpb25OYW1lICsgJy4nICsgaWQ7XG4gIHRoaXMuZW1pdCgndW5zdWJzY3JpYmVEb2MnLCBwYXRoLCB0aGlzLl9jb250ZXh0LCB0aGlzLl9wYXNzKTtcbiAgdmFyIHN1YnNjcmliZWREb2NzID0gdGhpcy5yb290Ll9zdWJzY3JpYmVkRG9jcztcblxuICAvLyBObyBlZmZlY3QgaWYgdGhlIGRvY3VtZW50IGlzIG5vdCBjdXJyZW50bHkgc3Vic2NyaWJlZFxuICBpZiAoIXN1YnNjcmliZWREb2NzW3BhdGhdKSByZXR1cm4gY2IoKTtcblxuICB2YXIgbW9kZWwgPSB0aGlzO1xuICBpZiAodGhpcy5yb290LnVubG9hZERlbGF5ICYmICF0aGlzLl9wYXNzLiRxdWVyeSkge1xuICAgIHNldFRpbWVvdXQoZmluaXNoVW5zdWJzY3JpYmVEb2MsIHRoaXMucm9vdC51bmxvYWREZWxheSk7XG4gIH0gZWxzZSB7XG4gICAgZmluaXNoVW5zdWJzY3JpYmVEb2MoKTtcbiAgfVxuICBmdW5jdGlvbiBmaW5pc2hVbnN1YnNjcmliZURvYygpIHtcbiAgICB2YXIgY291bnQgPSAtLXN1YnNjcmliZWREb2NzW3BhdGhdO1xuICAgIC8vIElmIHRoZXJlIGFyZSBtb3JlIHJlbWFpbmluZyBzdWJzY3JpcHRpb25zLCBvbmx5IGRlY3JlbWVudCB0aGUgY291bnRcbiAgICAvLyBhbmQgY2FsbGJhY2sgd2l0aCBob3cgbWFueSBzdWJzY3JpcHRpb25zIGFyZSByZW1haW5pbmdcbiAgICBpZiAoY291bnQpIHJldHVybiBjYihudWxsLCBjb3VudCk7XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBvbmx5IG9uZSByZW1haW5pbmcgc3Vic2NyaXB0aW9uLCBhY3R1YWxseSB1bnN1YnNjcmliZVxuICAgIGRlbGV0ZSBzdWJzY3JpYmVkRG9jc1twYXRoXTtcbiAgICBpZiAobW9kZWwucm9vdC5mZXRjaE9ubHkpIHtcbiAgICAgIHVuc3Vic2NyaWJlRG9jQ2FsbGJhY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNoYXJlRG9jID0gbW9kZWwucm9vdC5zaGFyZUNvbm5lY3Rpb24uZ2V0KGNvbGxlY3Rpb25OYW1lLCBpZCk7XG4gICAgICBpZiAoIXNoYXJlRG9jKSB7XG4gICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ1NoYXJlIGRvY3VtZW50IG5vdCBmb3VuZCBmb3I6ICcgKyBwYXRoKSk7XG4gICAgICB9XG4gICAgICBzaGFyZURvYy51bnN1YnNjcmliZSh1bnN1YnNjcmliZURvY0NhbGxiYWNrKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdW5zdWJzY3JpYmVEb2NDYWxsYmFjayhlcnIpIHtcbiAgICBtb2RlbC5fbWF5YmVVbmxvYWREb2MoY29sbGVjdGlvbk5hbWUsIGlkLCBwYXRoKTtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcbiAgICBjYihudWxsLCAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBkb2N1bWVudCBmcm9tIHRoZSBsb2NhbCBtb2RlbCBpZiB0aGUgbW9kZWwgbm8gbG9uZ2VyIGhhcyBhbnlcbiAqIHJlbWFpbmluZyBmZXRjaGVzIG9yIHN1YnNjcmliZXMgb24gcGF0aC5cbiAqIENhbGxlZCBmcm9tIE1vZGVsLnByb3RvdHlwZS51bmZldGNoRG9jIGFuZCBNb2RlbC5wcm90b3R5cGUudW5zdWJzY3JpYmVEb2MgYXNcbiAqIHBhcnQgb2YgYXR0ZW1wdGVkIGNsZWFudXAuXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sbGVjdGlvbk5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqL1xuTW9kZWwucHJvdG90eXBlLl9tYXliZVVubG9hZERvYyA9IGZ1bmN0aW9uKGNvbGxlY3Rpb25OYW1lLCBpZCwgcGF0aCkge1xuICB2YXIgZG9jID0gdGhpcy5nZXREb2MoY29sbGVjdGlvbk5hbWUsIGlkKTtcbiAgaWYgKCFkb2MpIHJldHVybjtcbiAgLy8gUmVtb3ZlIHRoZSBkb2N1bWVudCBmcm9tIHRoZSBsb2NhbCBtb2RlbCBpZiBpdCBubyBsb25nZXIgaGFzIGFueVxuICAvLyByZW1haW5pbmcgZmV0Y2hlcyBvciBzdWJzY3JpYmVzXG4gIGlmICh0aGlzLnJvb3QuX2ZldGNoZWREb2NzW3BhdGhdIHx8IHRoaXMucm9vdC5fc3Vic2NyaWJlZERvY3NbcGF0aF0pIHJldHVybjtcbiAgdmFyIHByZXZpb3VzID0gZG9jLmdldCgpO1xuICB0aGlzLnJvb3QuY29sbGVjdGlvbnNbY29sbGVjdGlvbk5hbWVdLnJlbW92ZShpZCk7XG4gIGlmIChkb2Muc2hhcmVEb2MpIGRvYy5zaGFyZURvYy5kZXN0cm95KCk7XG4gIGRlbGV0ZSB0aGlzLnJvb3QuX2xvYWRWZXJzaW9uc1twYXRoXTtcbiAgdGhpcy5lbWl0KCd1bmxvYWQnLCBbY29sbGVjdGlvbk5hbWUsIGlkXSwgW3ByZXZpb3VzLCB0aGlzLl9wYXNzXSk7XG59O1xuXG59KShyZXF1aXJlKFwiX19icm93c2VyaWZ5X3Byb2Nlc3NcIikpIiwiLyoqXG4gKiBDb250ZXh0cyBhcmUgdXNlZnVsIGZvciBrZWVwaW5nIHRyYWNrIG9mIHRoZSBvcmlnaW4gb2Ygc3Vic2NyaWJlcy5cbiAqL1xuXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyk7XG52YXIgUXVlcnkgPSByZXF1aXJlKCcuL1F1ZXJ5Jyk7XG5cbk1vZGVsLklOSVRTLnB1c2goZnVuY3Rpb24obW9kZWwpIHtcbiAgbW9kZWwucm9vdC5fY29udGV4dHMgPSBuZXcgQ29udGV4dHM7XG4gIG1vZGVsLnNldENvbnRleHQoJ3Jvb3QnKTtcbiAgWyAnZmV0Y2hEb2MnLCAnc3Vic2NyaWJlRG9jJywgJ3VuZmV0Y2hEb2MnLCAndW5zdWJzY3JpYmVEb2MnXG4gICwgJ2ZldGNoUXVlcnknLCAnc3Vic2NyaWJlUXVlcnknLCAndW5mZXRjaFF1ZXJ5JywgJ3Vuc3Vic2NyaWJlUXVlcnknXG4gIF0uZm9yRWFjaChmdW5jdGlvbihldmVudCkge1xuICAgIG1vZGVsLm9uKGV2ZW50LCBmdW5jdGlvbihpdGVtLCBjb250ZXh0LCBwYXNzKSB7XG4gICAgICBjb250ZXh0W2V2ZW50XShpdGVtLCBwYXNzKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuTW9kZWwucHJvdG90eXBlLmNvbnRleHQgPSBmdW5jdGlvbihpZCkge1xuICB2YXIgbW9kZWwgPSB0aGlzLl9jaGlsZCgpO1xuICBtb2RlbC5zZXRDb250ZXh0KGlkKTtcbiAgcmV0dXJuIG1vZGVsO1xufTtcblxuTW9kZWwucHJvdG90eXBlLnNldENvbnRleHQgPSBmdW5jdGlvbihpZCkge1xuICB2YXIgY29udGV4dCA9IHRoaXMucm9vdC5fY29udGV4dHNbaWRdIHx8IG5ldyBDb250ZXh0KHRoaXMsIGlkKTtcbiAgdGhpcy5fY29udGV4dCA9IHRoaXMucm9vdC5fY29udGV4dHNbaWRdID0gY29udGV4dDtcbiAgcmV0dXJuIGNvbnRleHQ7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUudW5sb2FkID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIGNvbnRleHQgPSAoaWQpID8gdGhpcy5yb290Ll9jb250ZXh0c1tpZF0gOiB0aGlzLl9jb250ZXh0O1xuICBjb250ZXh0LnVubG9hZCgpO1xufTtcblxuZnVuY3Rpb24gQ29udGV4dHMoKSB7fVxuXG5mdW5jdGlvbiBGZXRjaGVkRG9jcygpIHt9XG5mdW5jdGlvbiBTdWJzY3JpYmVkRG9jcygpIHt9XG5mdW5jdGlvbiBGZXRjaGVkUXVlcmllcygpIHt9XG5mdW5jdGlvbiBTdWJzY3JpYmVkUXVlcmllcygpIHt9XG5cbmZ1bmN0aW9uIENvbnRleHQobW9kZWwsIGlkKSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgdGhpcy5pZCA9IGlkO1xuICB0aGlzLmZldGNoZWREb2NzID0gbmV3IEZldGNoZWREb2NzO1xuICB0aGlzLnN1YnNjcmliZWREb2NzID0gbmV3IFN1YnNjcmliZWREb2NzO1xuICB0aGlzLmZldGNoZWRRdWVyaWVzID0gbmV3IEZldGNoZWRRdWVyaWVzO1xuICB0aGlzLnN1YnNjcmliZWRRdWVyaWVzID0gbmV3IFN1YnNjcmliZWRRdWVyaWVzO1xufVxuXG5Db250ZXh0LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBmZXRjaGVkRG9jczogdGhpcy5mZXRjaGVkRG9jc1xuICAsIHN1YnNjcmliZWREb2NzOiB0aGlzLnN1YnNjcmliZWREb2NzXG4gICwgZmV0Y2hlZFF1ZXJpZXM6IHRoaXMuZmV0Y2hlZFF1ZXJpZXNcbiAgLCBzdWJzY3JpYmVkUXVlcmllczogdGhpcy5zdWJzY3JpYmVkUXVlcmllc1xuICB9O1xufTtcblxuQ29udGV4dC5wcm90b3R5cGUuZmV0Y2hEb2MgPSBmdW5jdGlvbihwYXRoLCBwYXNzKSB7XG4gIGlmIChwYXNzLiRxdWVyeSkgcmV0dXJuO1xuICBtYXBJbmNyZW1lbnQodGhpcy5mZXRjaGVkRG9jcywgcGF0aCk7XG59O1xuQ29udGV4dC5wcm90b3R5cGUuc3Vic2NyaWJlRG9jID0gZnVuY3Rpb24ocGF0aCwgcGFzcykge1xuICBpZiAocGFzcy4kcXVlcnkpIHJldHVybjtcbiAgbWFwSW5jcmVtZW50KHRoaXMuc3Vic2NyaWJlZERvY3MsIHBhdGgpO1xufTtcbkNvbnRleHQucHJvdG90eXBlLnVuZmV0Y2hEb2MgPSBmdW5jdGlvbihwYXRoLCBwYXNzKSB7XG4gIGlmIChwYXNzLiRxdWVyeSkgcmV0dXJuO1xuICBtYXBEZWNyZW1lbnQodGhpcy5mZXRjaGVkRG9jcywgcGF0aCk7XG59O1xuQ29udGV4dC5wcm90b3R5cGUudW5zdWJzY3JpYmVEb2MgPSBmdW5jdGlvbihwYXRoLCBwYXNzKSB7XG4gIGlmIChwYXNzLiRxdWVyeSkgcmV0dXJuO1xuICBtYXBEZWNyZW1lbnQodGhpcy5zdWJzY3JpYmVkRG9jcywgcGF0aCk7XG59O1xuQ29udGV4dC5wcm90b3R5cGUuZmV0Y2hRdWVyeSA9IGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gIG1hcEluY3JlbWVudCh0aGlzLmZldGNoZWRRdWVyaWVzLCBxdWVyeS5oYXNoKTtcbn07XG5Db250ZXh0LnByb3RvdHlwZS5zdWJzY3JpYmVRdWVyeSA9IGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gIG1hcEluY3JlbWVudCh0aGlzLnN1YnNjcmliZWRRdWVyaWVzLCBxdWVyeS5oYXNoKTtcbn07XG5Db250ZXh0LnByb3RvdHlwZS51bmZldGNoUXVlcnkgPSBmdW5jdGlvbihxdWVyeSkge1xuICBtYXBEZWNyZW1lbnQodGhpcy5mZXRjaGVkUXVlcmllcywgcXVlcnkuaGFzaCk7XG59O1xuQ29udGV4dC5wcm90b3R5cGUudW5zdWJzY3JpYmVRdWVyeSA9IGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gIG1hcERlY3JlbWVudCh0aGlzLnN1YnNjcmliZWRRdWVyaWVzLCBxdWVyeS5oYXNoKTtcbn07XG5mdW5jdGlvbiBtYXBJbmNyZW1lbnQobWFwLCBrZXkpIHtcbiAgbWFwW2tleV0gPSAobWFwW2tleV0gfHwgMCkgKyAxO1xufVxuZnVuY3Rpb24gbWFwRGVjcmVtZW50KG1hcCwga2V5KSB7XG4gIG1hcFtrZXldICYmIG1hcFtrZXldLS07XG4gIGlmICghbWFwW2tleV0pIGRlbGV0ZSBtYXBba2V5XTtcbn1cblxuQ29udGV4dC5wcm90b3R5cGUudW5sb2FkID0gZnVuY3Rpb24oKSB7XG4gIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gIGZvciAodmFyIGhhc2ggaW4gdGhpcy5mZXRjaGVkUXVlcmllcykge1xuICAgIHZhciBxdWVyeSA9IG1vZGVsLnJvb3QuX3F1ZXJpZXMubWFwW2hhc2hdO1xuICAgIGlmICghcXVlcnkpIGNvbnRpbnVlO1xuICAgIHZhciBjb3VudCA9IHRoaXMuZmV0Y2hlZFF1ZXJpZXNbaGFzaF07XG4gICAgd2hpbGUgKGNvdW50LS0pIHF1ZXJ5LnVuZmV0Y2gobnVsbCk7XG4gIH1cbiAgZm9yICh2YXIgaGFzaCBpbiB0aGlzLnN1YnNjcmliZWRRdWVyaWVzKSB7XG4gICAgdmFyIHF1ZXJ5ID0gbW9kZWwucm9vdC5fcXVlcmllcy5tYXBbaGFzaF07XG4gICAgaWYgKCFxdWVyeSkgY29udGludWU7XG4gICAgdmFyIGNvdW50ID0gdGhpcy5zdWJzY3JpYmVkUXVlcmllc1toYXNoXTtcbiAgICB3aGlsZSAoY291bnQtLSkgcXVlcnkudW5zdWJzY3JpYmUobnVsbCk7XG4gIH1cbiAgZm9yICh2YXIgcGF0aCBpbiB0aGlzLmZldGNoZWREb2NzKSB7XG4gICAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICAgIHZhciBjb3VudCA9IHRoaXMuZmV0Y2hlZERvY3NbcGF0aF07XG4gICAgd2hpbGUgKGNvdW50LS0pIG1vZGVsLnVuZmV0Y2hEb2Moc2VnbWVudHNbMF0sIHNlZ21lbnRzWzFdKTtcbiAgfVxuICBmb3IgKHZhciBwYXRoIGluIHRoaXMuc3Vic2NyaWJlZERvY3MpIHtcbiAgICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgdmFyIGNvdW50ID0gdGhpcy5zdWJzY3JpYmVkRG9jc1twYXRoXTtcbiAgICB3aGlsZSAoY291bnQtLSkgbW9kZWwudW5zdWJzY3JpYmVEb2Moc2VnbWVudHNbMF0sIHNlZ21lbnRzWzFdKTtcbiAgfVxuICBtb2RlbC5fY29udGV4dCA9IG1vZGVsLnJvb3QuX2NvbnRleHRzW3RoaXMuaWRdID0gbmV3IENvbnRleHQobW9kZWwsIHRoaXMuaWQpO1xufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xudmFyIGRlZmF1bHRGbnMgPSByZXF1aXJlKCcuL2RlZmF1bHRGbnMnKTtcblxuZnVuY3Rpb24gTmFtZWRGbnMoKSB7fVxuXG5Nb2RlbC5JTklUUy5wdXNoKGZ1bmN0aW9uKG1vZGVsKSB7XG4gIG1vZGVsLnJvb3QuX25hbWVkRm5zID0gbmV3IE5hbWVkRm5zKCk7XG4gIG1vZGVsLnJvb3QuX2ZucyA9IG5ldyBGbnMobW9kZWwpO1xuICBtb2RlbC5vbignYWxsJywgZm5MaXN0ZW5lcik7XG4gIGZ1bmN0aW9uIGZuTGlzdGVuZXIoc2VnbWVudHMsIGV2ZW50QXJncykge1xuICAgIHZhciBwYXNzID0gZXZlbnRBcmdzW2V2ZW50QXJncy5sZW5ndGggLSAxXTtcbiAgICB2YXIgbWFwID0gbW9kZWwucm9vdC5fZm5zLmZyb21NYXA7XG4gICAgZm9yICh2YXIgcGF0aCBpbiBtYXApIHtcbiAgICAgIHZhciBmbiA9IG1hcFtwYXRoXTtcbiAgICAgIGlmIChwYXNzLiRmbiA9PT0gZm4pIGNvbnRpbnVlO1xuICAgICAgaWYgKHV0aWwubWF5SW1wYWN0QW55KGZuLmlucHV0c1NlZ21lbnRzLCBzZWdtZW50cykpIHtcbiAgICAgICAgLy8gTXV0YXRpb24gYWZmZWN0aW5nIGlucHV0IHBhdGhcbiAgICAgICAgZm4ub25JbnB1dChwYXNzKTtcbiAgICAgIH0gZWxzZSBpZiAodXRpbC5tYXlJbXBhY3QoZm4uZnJvbVNlZ21lbnRzLCBzZWdtZW50cykpIHtcbiAgICAgICAgLy8gTXV0YXRpb24gYWZmZWN0aW5nIG91dHB1dCBwYXRoXG4gICAgICAgIGZuLm9uT3V0cHV0KHBhc3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbk1vZGVsLnByb3RvdHlwZS5mbiA9IGZ1bmN0aW9uKG5hbWUsIGZucykge1xuICB0aGlzLnJvb3QuX25hbWVkRm5zW25hbWVdID0gZm5zO1xufTtcblxuZnVuY3Rpb24gcGFyc2VTdGFydEFyZ3VtZW50cyhtb2RlbCwgYXJncywgaGFzUGF0aCkge1xuICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZm5zID0gYXJnc1swXTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmFtZSA9IGFyZ3NbMF07XG4gIH1cbiAgaWYgKGhhc1BhdGgpIHtcbiAgICB2YXIgcGF0aCA9IG1vZGVsLnBhdGgoYXJnc1sxXSk7XG4gICAgdmFyIGlucHV0UGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAyKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaW5wdXRQYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpO1xuICB9XG4gIHZhciBpID0gaW5wdXRQYXRocy5sZW5ndGggLSAxO1xuICBpZiAobW9kZWwuaXNQYXRoKGlucHV0UGF0aHNbaV0pKSB7XG4gICAgaW5wdXRQYXRoc1tpXSA9IG1vZGVsLnBhdGgoaW5wdXRQYXRoc1tpXSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG9wdGlvbnMgPSBpbnB1dFBhdGhzLnBvcCgpO1xuICB9XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpbnB1dFBhdGhzW2ldID0gbW9kZWwucGF0aChpbnB1dFBhdGhzW2ldKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWVcbiAgLCBwYXRoOiBwYXRoXG4gICwgaW5wdXRQYXRoczogaW5wdXRQYXRoc1xuICAsIGZuczogZm5zXG4gICwgb3B0aW9uczogb3B0aW9uc1xuICB9O1xufVxuXG5Nb2RlbC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBhcmdzID0gcGFyc2VTdGFydEFyZ3VtZW50cyh0aGlzLCBhcmd1bWVudHMsIGZhbHNlKTtcbiAgcmV0dXJuIHRoaXMucm9vdC5fZm5zLmdldChhcmdzLm5hbWUsIGFyZ3MuaW5wdXRQYXRocywgYXJncy5mbnMsIGFyZ3Mub3B0aW9ucyk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihuYW1lLCBzdWJwYXRoKSB7XG4gIHZhciBhcmdzID0gcGFyc2VTdGFydEFyZ3VtZW50cyh0aGlzLCBhcmd1bWVudHMsIHRydWUpO1xuICByZXR1cm4gdGhpcy5yb290Ll9mbnMuc3RhcnQoYXJncy5uYW1lLCBhcmdzLnBhdGgsIGFyZ3MuaW5wdXRQYXRocywgYXJncy5mbnMsIGFyZ3Mub3B0aW9ucyk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKHN1YnBhdGgpIHtcbiAgdmFyIHBhdGggPSB0aGlzLnBhdGgoc3VicGF0aCk7XG4gIHRoaXMucm9vdC5fZm5zLnN0b3AocGF0aCk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuc3RvcEFsbCA9IGZ1bmN0aW9uKHN1YnBhdGgpIHtcbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICB2YXIgZm5zID0gdGhpcy5yb290Ll9mbnMuZnJvbU1hcDtcbiAgZm9yICh2YXIgZnJvbSBpbiBmbnMpIHtcbiAgICBpZiAodXRpbC5jb250YWlucyhzZWdtZW50cywgZm5zW2Zyb21dLmZyb21TZWdtZW50cykpIHtcbiAgICAgIHRoaXMuc3RvcChmcm9tKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIEZyb21NYXAoKSB7fVxuZnVuY3Rpb24gRm5zKG1vZGVsKSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgdGhpcy5uYW1lTWFwID0gbW9kZWwucm9vdC5fbmFtZWRGbnM7XG4gIHRoaXMuZnJvbU1hcCA9IG5ldyBGcm9tTWFwO1xufVxuXG5GbnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUsIGlucHV0UGF0aHMsIGZucywgb3B0aW9ucykge1xuICBmbnMgfHwgKGZucyA9IHRoaXMubmFtZU1hcFtuYW1lXSB8fCBkZWZhdWx0Rm5zW25hbWVdKTtcbiAgdmFyIGZuID0gbmV3IEZuKHRoaXMubW9kZWwsIG5hbWUsIG51bGwsIGlucHV0UGF0aHMsIGZucywgb3B0aW9ucyk7XG4gIHJldHVybiBmbi5nZXQoKTtcbn07XG5cbkZucy5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihuYW1lLCBwYXRoLCBpbnB1dFBhdGhzLCBmbnMsIG9wdGlvbnMpIHtcbiAgZm5zIHx8IChmbnMgPSB0aGlzLm5hbWVNYXBbbmFtZV0gfHwgZGVmYXVsdEZuc1tuYW1lXSk7XG4gIHZhciBmbiA9IG5ldyBGbih0aGlzLm1vZGVsLCBuYW1lLCBwYXRoLCBpbnB1dFBhdGhzLCBmbnMsIG9wdGlvbnMpO1xuICB0aGlzLmZyb21NYXBbcGF0aF0gPSBmbjtcbiAgcmV0dXJuIGZuLm9uSW5wdXQoKTtcbn07XG5cbkZucy5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGZuID0gdGhpcy5mcm9tTWFwW3BhdGhdO1xuICBkZWxldGUgdGhpcy5mcm9tTWFwW3BhdGhdO1xuICByZXR1cm4gZm47XG59O1xuXG5GbnMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3V0ID0gW107XG4gIGZvciAodmFyIGZyb20gaW4gdGhpcy5mcm9tTWFwKSB7XG4gICAgdmFyIGZuID0gdGhpcy5mcm9tTWFwW2Zyb21dO1xuICAgIC8vIERvbid0IHRyeSB0byBidW5kbGUgbm9uLW5hbWVkIGZ1bmN0aW9ucyB0aGF0IHdlcmUgc3RhcnRlZCB2aWFcbiAgICAvLyBtb2RlbC5zdGFydCBkaXJlY3RseSBpbnN0ZWFkIG9mIGJ5IG5hbWVcbiAgICBpZiAoIWZuLm5hbWUpIGNvbnRpbnVlO1xuICAgIG91dC5wdXNoKFtmbi5uYW1lLCBmbi5mcm9tXS5jb25jYXQoZm4uaW5wdXRQYXRocykpO1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG5mdW5jdGlvbiBGbihtb2RlbCwgbmFtZSwgZnJvbSwgaW5wdXRQYXRocywgZm5zLCBvcHRpb25zKSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbC5wYXNzKHskZm46IHRoaXN9KTtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5mcm9tID0gZnJvbTtcbiAgdGhpcy5pbnB1dFBhdGhzID0gaW5wdXRQYXRocztcbiAgaWYgKCFmbnMpIHtcbiAgICB2YXIgZXJyID0gbmV3IFR5cGVFcnJvcignTW9kZWwgZnVuY3Rpb24gbm90IGZvdW5kOiAnICsgbmFtZSk7XG4gICAgbW9kZWwuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG4gIHRoaXMuZ2V0Rm4gPSBmbnMuZ2V0IHx8IGZucztcbiAgdGhpcy5zZXRGbiA9IGZucy5zZXQ7XG4gIHRoaXMuZnJvbVNlZ21lbnRzID0gZnJvbSAmJiBmcm9tLnNwbGl0KCcuJyk7XG4gIHRoaXMuaW5wdXRzU2VnbWVudHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmlucHV0UGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2VnbWVudHMgPSB0aGlzLmlucHV0UGF0aHNbaV0uc3BsaXQoJy4nKTtcbiAgICB0aGlzLmlucHV0c1NlZ21lbnRzLnB1c2goc2VnbWVudHMpO1xuICB9XG4gIHZhciBjb3B5ID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5jb3B5KSB8fCAnb3V0cHV0JztcbiAgdGhpcy5jb3B5SW5wdXQgPSAoY29weSA9PT0gJ2lucHV0JyB8fCBjb3B5ID09PSAnYm90aCcpO1xuICB0aGlzLmNvcHlPdXRwdXQgPSAoY29weSA9PT0gJ291dHB1dCcgfHwgY29weSA9PT0gJ2JvdGgnKTtcbn1cblxuRm4ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24oZm4sIGlucHV0cykge1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5pbnB1dHNTZWdtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBpbnB1dCA9IHRoaXMubW9kZWwuX2dldCh0aGlzLmlucHV0c1NlZ21lbnRzW2ldKTtcbiAgICBpbnB1dHMucHVzaCh0aGlzLmNvcHlJbnB1dCA/IHV0aWwuZGVlcENvcHkoaW5wdXQpIDogaW5wdXQpO1xuICB9XG4gIHJldHVybiBmbi5hcHBseSh0aGlzLm1vZGVsLCBpbnB1dHMpO1xufTtcblxuRm4ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5hcHBseSh0aGlzLmdldEZuLCBbXSk7XG59O1xuXG52YXIgZGlmZk9wdGlvbnMgPSB7ZXF1YWw6IHV0aWwuZGVlcEVxdWFsfTtcbnZhciBlYWNoRGlmZk9wdGlvbnMgPSB7ZWFjaDogdHJ1ZSwgZXF1YWw6IHV0aWwuZGVlcEVxdWFsfTtcblxuRm4ucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHZhbHVlLCBwYXNzKSB7XG4gIGlmICghdGhpcy5zZXRGbikgcmV0dXJuO1xuICB2YXIgb3V0ID0gdGhpcy5hcHBseSh0aGlzLnNldEZuLCBbdmFsdWVdKTtcbiAgaWYgKCFvdXQpIHJldHVybjtcbiAgdmFyIGlucHV0c1NlZ21lbnRzID0gdGhpcy5pbnB1dHNTZWdtZW50cztcbiAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbC5wYXNzKHBhc3MsIHRydWUpO1xuICBmb3IgKHZhciBrZXkgaW4gb3V0KSB7XG4gICAgaWYgKGtleSA9PT0gJ2VhY2gnKSB7XG4gICAgICB2YXIgZWFjaCA9IG91dFtrZXldO1xuICAgICAgZm9yIChrZXkgaW4gZWFjaCkge1xuICAgICAgICB2YXIgdmFsdWUgPSAodGhpcy5jb3B5T3V0cHV0KSA/IHV0aWwuZGVlcENvcHkoZWFjaFtrZXldKSA6IGVhY2hba2V5XTtcbiAgICAgICAgbW9kZWwuX3NldERpZmYoaW5wdXRzU2VnbWVudHNba2V5XSwgdmFsdWUsIGVhY2hEaWZmT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIHZhbHVlID0gKHRoaXMuY29weU91dHB1dCkgPyB1dGlsLmRlZXBDb3B5KG91dFtrZXldKSA6IG91dFtrZXldO1xuICAgIG1vZGVsLl9zZXREaWZmKGlucHV0c1NlZ21lbnRzW2tleV0sIHZhbHVlLCBkaWZmT3B0aW9ucyk7XG4gIH1cbn07XG5cbkZuLnByb3RvdHlwZS5vbklucHV0ID0gZnVuY3Rpb24ocGFzcykge1xuICB2YXIgdmFsdWUgPSAodGhpcy5jb3B5T3V0cHV0KSA/IHV0aWwuZGVlcENvcHkodGhpcy5nZXQoKSkgOiB0aGlzLmdldCgpO1xuICB0aGlzLm1vZGVsLnBhc3MocGFzcywgdHJ1ZSkuX3NldERpZmYodGhpcy5mcm9tU2VnbWVudHMsIHZhbHVlLCBkaWZmT3B0aW9ucyk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbkZuLnByb3RvdHlwZS5vbk91dHB1dCA9IGZ1bmN0aW9uKHBhc3MpIHtcbiAgdmFyIHZhbHVlID0gdGhpcy5tb2RlbC5fZ2V0KHRoaXMuZnJvbVNlZ21lbnRzKTtcbiAgcmV0dXJuIHRoaXMuc2V0KHZhbHVlLCBwYXNzKTtcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcbnZhciBkZWZhdWx0Rm5zID0gcmVxdWlyZSgnLi9kZWZhdWx0Rm5zJyk7XG5cbk1vZGVsLklOSVRTLnB1c2goZnVuY3Rpb24obW9kZWwpIHtcbiAgbW9kZWwucm9vdC5fZmlsdGVycyA9IG5ldyBGaWx0ZXJzKG1vZGVsKTtcbiAgbW9kZWwub24oJ2FsbCcsIGZpbHRlckxpc3RlbmVyKTtcbiAgZnVuY3Rpb24gZmlsdGVyTGlzdGVuZXIoc2VnbWVudHMsIGV2ZW50QXJncykge1xuICAgIHZhciBwYXNzID0gZXZlbnRBcmdzW2V2ZW50QXJncy5sZW5ndGggLSAxXTtcbiAgICB2YXIgbWFwID0gbW9kZWwucm9vdC5fZmlsdGVycy5mcm9tTWFwO1xuICAgIGZvciAodmFyIHBhdGggaW4gbWFwKSB7XG4gICAgICB2YXIgZmlsdGVyID0gbWFwW3BhdGhdO1xuICAgICAgaWYgKHBhc3MuJGZpbHRlciA9PT0gZmlsdGVyKSBjb250aW51ZTtcbiAgICAgIGlmICh1dGlsLm1heUltcGFjdChmaWx0ZXIuaW5wdXRTZWdtZW50cywgc2VnbWVudHMpKSB7XG4gICAgICAgIGZpbHRlci51cGRhdGUocGFzcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcblxuTW9kZWwucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uKGlucHV0LCBmbikge1xuICB2YXIgaW5wdXRQYXRoID0gdGhpcy5wYXRoKGlucHV0KTtcbiAgcmV0dXJuIHRoaXMucm9vdC5fZmlsdGVycy5hZGQoaW5wdXRQYXRoLCBmbik7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uKGlucHV0LCBmbikge1xuICB2YXIgaW5wdXRQYXRoID0gdGhpcy5wYXRoKGlucHV0KTtcbiAgcmV0dXJuIHRoaXMucm9vdC5fZmlsdGVycy5hZGQoaW5wdXRQYXRoLCBudWxsLCBmbiB8fCAnYXNjJyk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUucmVtb3ZlQWxsRmlsdGVycyA9IGZ1bmN0aW9uKHN1YnBhdGgpIHtcbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICB2YXIgZmlsdGVycyA9IHRoaXMucm9vdC5fZmlsdGVycy5mcm9tTWFwO1xuICBmb3IgKHZhciBmcm9tIGluIGZpbHRlcnMpIHtcbiAgICBpZiAodXRpbC5jb250YWlucyhzZWdtZW50cywgZmlsdGVyc1tmcm9tXS5mcm9tU2VnbWVudHMpKSB7XG4gICAgICBmaWx0ZXJzW2Zyb21dLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIEZyb21NYXAoKSB7fVxuZnVuY3Rpb24gRmlsdGVycyhtb2RlbCkge1xuICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gIHRoaXMuZnJvbU1hcCA9IG5ldyBGcm9tTWFwO1xufVxuXG5GaWx0ZXJzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihpbnB1dFBhdGgsIGZpbHRlckZuLCBzb3J0Rm4pIHtcbiAgcmV0dXJuIG5ldyBGaWx0ZXIodGhpcywgaW5wdXRQYXRoLCBmaWx0ZXJGbiwgc29ydEZuKTtcbn07XG5cbkZpbHRlcnMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3V0ID0gW107XG4gIGZvciAodmFyIGZyb20gaW4gdGhpcy5mcm9tTWFwKSB7XG4gICAgdmFyIGZpbHRlciA9IHRoaXMuZnJvbU1hcFtmcm9tXTtcbiAgICAvLyBEb24ndCB0cnkgdG8gYnVuZGxlIGlmIGZ1bmN0aW9ucyB3ZXJlIHBhc3NlZCBkaXJlY3RseSBpbnN0ZWFkIG9mIGJ5IG5hbWVcbiAgICBpZiAoIWZpbHRlci5idW5kbGUpIGNvbnRpbnVlO1xuICAgIG91dC5wdXNoKFtmaWx0ZXIuaW5wdXRQYXRoLCBmaWx0ZXIuZmlsdGVyTmFtZSwgZmlsdGVyLnNvcnROYW1lLCBmcm9tXSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbmZ1bmN0aW9uIEZpbHRlcihmaWx0ZXJzLCBpbnB1dFBhdGgsIGZpbHRlckZuLCBzb3J0Rm4pIHtcbiAgdGhpcy5maWx0ZXJzID0gZmlsdGVycztcbiAgdGhpcy5tb2RlbCA9IGZpbHRlcnMubW9kZWwucGFzcyh7JGZpbHRlcjogdGhpc30pO1xuICB0aGlzLmlucHV0UGF0aCA9IGlucHV0UGF0aDtcbiAgdGhpcy5pbnB1dFNlZ21lbnRzID0gaW5wdXRQYXRoLnNwbGl0KCcuJyk7XG4gIHRoaXMuZmlsdGVyTmFtZSA9IG51bGw7XG4gIHRoaXMuc29ydE5hbWUgPSBudWxsO1xuICB0aGlzLmJ1bmRsZSA9IHRydWU7XG4gIHRoaXMuZmlsdGVyRm4gPSBudWxsO1xuICB0aGlzLnNvcnRGbiA9IG51bGw7XG4gIGlmIChmaWx0ZXJGbikgdGhpcy5maWx0ZXIoZmlsdGVyRm4pO1xuICBpZiAoc29ydEZuKSB0aGlzLnNvcnQoc29ydEZuKTtcbiAgdGhpcy5pZHNTZWdtZW50cyA9IG51bGw7XG4gIHRoaXMuZnJvbSA9IG51bGw7XG4gIHRoaXMuZnJvbVNlZ21lbnRzID0gbnVsbDtcbn1cblxuRmlsdGVyLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbihmbikge1xuICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5maWx0ZXJGbiA9IGZuO1xuICAgIHRoaXMuYnVuZGxlID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaWYgKHR5cGVvZiBmbiA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLmZpbHRlck5hbWUgPSBmbjtcbiAgICB0aGlzLmZpbHRlckZuID0gdGhpcy5tb2RlbC5yb290Ll9uYW1lZEZuc1tmbl0gfHwgZGVmYXVsdEZuc1tmbl07XG4gICAgaWYgKCF0aGlzLmZpbHRlckZuKSB7XG4gICAgICB2YXIgZXJyID0gbmV3IFR5cGVFcnJvcignRmlsdGVyIGZ1bmN0aW9uIG5vdCBmb3VuZDogJyArIGZuKTtcbiAgICAgIHRoaXMubW9kZWwuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbkZpbHRlci5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uKGZuKSB7XG4gIGlmICghZm4pIGZuID0gJ2FzYyc7XG4gIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLnNvcnRGbiA9IGZuO1xuICAgIHRoaXMuYnVuZGxlID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaWYgKHR5cGVvZiBmbiA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLnNvcnROYW1lID0gZm47XG4gICAgdGhpcy5zb3J0Rm4gPSB0aGlzLm1vZGVsLnJvb3QuX25hbWVkRm5zW2ZuXSB8fCBkZWZhdWx0Rm5zW2ZuXTtcbiAgICBpZiAoIXRoaXMuc29ydEZuKSB7XG4gICAgICB2YXIgZXJyID0gbmV3IFR5cGVFcnJvcignU29ydCBmdW5jdGlvbiBub3QgZm91bmQ6ICcgKyBmbik7XG4gICAgICB0aGlzLm1vZGVsLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5GaWx0ZXIucHJvdG90eXBlLmlkcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbXMgPSB0aGlzLm1vZGVsLl9nZXQodGhpcy5pbnB1dFNlZ21lbnRzKTtcbiAgdmFyIGlkcyA9IFtdO1xuICBpZiAoIWl0ZW1zKSByZXR1cm4gaWRzO1xuICBpZiAoQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICBpZiAodGhpcy5maWx0ZXJGbikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5maWx0ZXJGbi5jYWxsKHRoaXMubW9kZWwsIGl0ZW1zW2ldLCBpLCBpdGVtcykpIHtcbiAgICAgICAgICBpZHMucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSBpZHMucHVzaChpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuZmlsdGVyRm4pIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBpdGVtcykge1xuICAgICAgICBpZiAoaXRlbXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJlxuICAgICAgICAgIHRoaXMuZmlsdGVyRm4uY2FsbCh0aGlzLm1vZGVsLCBpdGVtc1trZXldLCBrZXksIGl0ZW1zKVxuICAgICAgICApIHtcbiAgICAgICAgICBpZHMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlkcyA9IE9iamVjdC5rZXlzKGl0ZW1zKTtcbiAgICB9XG4gIH1cbiAgdmFyIHNvcnRGbiA9IHRoaXMuc29ydEZuO1xuICBpZiAoc29ydEZuKSB7XG4gICAgaWRzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIHNvcnRGbihpdGVtc1thXSwgaXRlbXNbYl0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBpZHM7XG59O1xuXG5GaWx0ZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbXMgPSB0aGlzLm1vZGVsLl9nZXQodGhpcy5pbnB1dFNlZ21lbnRzKTtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgaWYgKHRoaXMuZmlsdGVyRm4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyRm4uY2FsbCh0aGlzLm1vZGVsLCBpdGVtc1tpXSwgaSwgaXRlbXMpKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKGl0ZW1zW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRzID0gaXRlbXMuc2xpY2UoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuZmlsdGVyRm4pIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBpdGVtcykge1xuICAgICAgICBpZiAoaXRlbXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJlxuICAgICAgICAgIHRoaXMuZmlsdGVyRm4uY2FsbCh0aGlzLm1vZGVsLCBpdGVtc1trZXldLCBrZXksIGl0ZW1zKVxuICAgICAgICApIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2goaXRlbXNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIga2V5IGluIGl0ZW1zKSB7XG4gICAgICAgIGlmIChpdGVtcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKGl0ZW1zW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh0aGlzLnNvcnRGbikgcmVzdWx0cy5zb3J0KHRoaXMuc29ydEZuKTtcbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG5GaWx0ZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKHBhc3MpIHtcbiAgdmFyIGlkcyA9IHRoaXMuaWRzKCk7XG4gIHRoaXMubW9kZWwucGFzcyhwYXNzLCB0cnVlKS5fc2V0RGlmZih0aGlzLmlkc1NlZ21lbnRzLCBpZHMpO1xufTtcblxuRmlsdGVyLnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbihmcm9tKSB7XG4gIGZyb20gPSB0aGlzLm1vZGVsLnBhdGgoZnJvbSk7XG4gIHRoaXMuZnJvbSA9IGZyb207XG4gIHRoaXMuZnJvbVNlZ21lbnRzID0gZnJvbS5zcGxpdCgnLicpO1xuICB0aGlzLmZpbHRlcnMuZnJvbU1hcFtmcm9tXSA9IHRoaXM7XG4gIHRoaXMuaWRzU2VnbWVudHMgPSBbJyRmaWx0ZXJzJywgZnJvbS5yZXBsYWNlKC9cXC4vZywgJ3wnKV07XG4gIHRoaXMudXBkYXRlKCk7XG4gIHJldHVybiB0aGlzLm1vZGVsLnJlZkxpc3QoZnJvbSwgdGhpcy5pbnB1dFBhdGgsIHRoaXMuaWRzU2VnbWVudHMuam9pbignLicpKTtcbn07XG5cbkZpbHRlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICBkZWxldGUgdGhpcy5maWx0ZXJzLmZyb21NYXBbdGhpcy5mcm9tXTtcbiAgdGhpcy5tb2RlbC5yZW1vdmVSZWZMaXN0KHRoaXMuZnJvbSk7XG4gIHRoaXMubW9kZWwuX2RlbCh0aGlzLmlkc1NlZ21lbnRzKTtcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcblxuTW9kZWwuSU5JVFMucHVzaChmdW5jdGlvbihtb2RlbCkge1xuICB2YXIgcm9vdCA9IG1vZGVsLnJvb3Q7XG4gIHJvb3QuX3JlZkxpc3RzID0gbmV3IFJlZkxpc3RzKHJvb3QpO1xuICBmb3IgKHZhciB0eXBlIGluIE1vZGVsLk1VVEFUT1JfRVZFTlRTKSB7XG4gICAgYWRkTGlzdGVuZXIocm9vdCwgdHlwZSk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihtb2RlbCwgdHlwZSkge1xuICBtb2RlbC5vbih0eXBlLCByZWZMaXN0TGlzdGVuZXIpO1xuICBmdW5jdGlvbiByZWZMaXN0TGlzdGVuZXIoc2VnbWVudHMsIGV2ZW50QXJncykge1xuICAgIHZhciBwYXNzID0gZXZlbnRBcmdzW2V2ZW50QXJncy5sZW5ndGggLSAxXTtcbiAgICAvLyBDaGVjayBmb3IgdXBkYXRlcyBvbiBvciB1bmRlcm5lYXRoIHBhdGhzXG4gICAgdmFyIGZyb21NYXAgPSBtb2RlbC5fcmVmTGlzdHMuZnJvbU1hcDtcbiAgICBmb3IgKHZhciBmcm9tIGluIGZyb21NYXApIHtcbiAgICAgIHZhciByZWZMaXN0ID0gZnJvbU1hcFtmcm9tXTtcbiAgICAgIGlmIChwYXNzLiRyZWZMaXN0ID09PSByZWZMaXN0KSBjb250aW51ZTtcbiAgICAgIHJlZkxpc3Qub25NdXRhdGlvbih0eXBlLCBzZWdtZW50cywgZXZlbnRBcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtBcnJheX0gc2VnbWVudHNcbiAqIEBwYXJhbSB7QXJyYXl9IGV2ZW50QXJnc1xuICogQHBhcmFtIHtSZWZMaXN0fSByZWZMaXN0XG4gKi9cbmZ1bmN0aW9uIHBhdGNoRnJvbUV2ZW50KHR5cGUsIHNlZ21lbnRzLCBldmVudEFyZ3MsIHJlZkxpc3QpIHtcbiAgdmFyIGZyb21MZW5ndGggPSByZWZMaXN0LmZyb21TZWdtZW50cy5sZW5ndGg7XG4gIHZhciBzZWdtZW50c0xlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgdmFyIHBhc3MgPSBldmVudEFyZ3NbZXZlbnRBcmdzLmxlbmd0aCAtIDFdO1xuICB2YXIgbW9kZWwgPSByZWZMaXN0Lm1vZGVsLnBhc3MocGFzcywgdHJ1ZSk7XG5cbiAgLy8gTXV0YXRpb24gb24gdGhlIGBmcm9tYCBvdXRwdXQgaXRzZWxmXG4gIGlmIChzZWdtZW50c0xlbmd0aCA9PT0gZnJvbUxlbmd0aCkge1xuICAgIGlmICh0eXBlID09PSAnaW5zZXJ0Jykge1xuICAgICAgdmFyIGluZGV4ID0gZXZlbnRBcmdzWzBdO1xuICAgICAgdmFyIHZhbHVlcyA9IGV2ZW50QXJnc1sxXTtcbiAgICAgIHZhciBpZHMgPSBzZXROZXdUb1ZhbHVlcyhtb2RlbCwgcmVmTGlzdCwgdmFsdWVzKTtcbiAgICAgIG1vZGVsLl9pbnNlcnQocmVmTGlzdC5pZHNTZWdtZW50cywgaW5kZXgsIGlkcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdyZW1vdmUnKSB7XG4gICAgICB2YXIgaW5kZXggPSBldmVudEFyZ3NbMF07XG4gICAgICB2YXIgaG93TWFueSA9IGV2ZW50QXJnc1sxXS5sZW5ndGg7XG4gICAgICB2YXIgaWRzID0gbW9kZWwuX3JlbW92ZShyZWZMaXN0Lmlkc1NlZ21lbnRzLCBpbmRleCwgaG93TWFueSk7XG4gICAgICAvLyBEZWxldGUgdGhlIGFwcHJvcHJpYXRlIGl0ZW1zIHVuZGVybmVhdGggYHRvYCBpZiB0aGUgYGRlbGV0ZVJlbW92ZWRgXG4gICAgICAvLyBvcHRpb24gd2FzIHNldCB0cnVlXG4gICAgICBpZiAocmVmTGlzdC5kZWxldGVSZW1vdmVkKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSByZWZMaXN0Lml0ZW1CeUlkKGlkc1tpXSk7XG4gICAgICAgICAgbW9kZWwuX2RlbChyZWZMaXN0LnRvU2VnbWVudHNCeUl0ZW0oaXRlbSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdtb3ZlJykge1xuICAgICAgdmFyIGZyb20gPSBldmVudEFyZ3NbMF07XG4gICAgICB2YXIgdG8gPSBldmVudEFyZ3NbMV07XG4gICAgICB2YXIgaG93TWFueSA9IGV2ZW50QXJnc1syXTtcbiAgICAgIG1vZGVsLl9tb3ZlKHJlZkxpc3QuaWRzU2VnbWVudHMsIGZyb20sIHRvLCBob3dNYW55KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGFuZ2Ugb2YgdGhlIGVudGlyZSBvdXRwdXRcbiAgICB2YXIgdmFsdWVzID0gKHR5cGUgPT09ICdjaGFuZ2UnKSA/XG4gICAgICBldmVudEFyZ3NbMF0gOiBtb2RlbC5fZ2V0KHJlZkxpc3QuZnJvbVNlZ21lbnRzKTtcbiAgICAvLyBTZXQgaWRzIHRvIGVtcHR5IGxpc3QgaWYgb3V0cHV0IGlzIHNldCB0byBudWxsXG4gICAgaWYgKCF2YWx1ZXMpIHtcbiAgICAgIG1vZGVsLl9zZXQocmVmTGlzdC5pZHNTZWdtZW50cywgW10pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgZW50aXJlIG91dHB1dCBpcyBzZXQsIGNyZWF0ZSBhIGxpc3Qgb2YgaWRzIGJhc2VkIG9uIHRoZSBvdXRwdXQsXG4gICAgLy8gYW5kIHVwZGF0ZSB0aGUgY29ycmVzcG9uZGluZyBpdGVtc1xuICAgIHZhciBpZHMgPSBzZXROZXdUb1ZhbHVlcyhtb2RlbCwgcmVmTGlzdCwgdmFsdWVzKTtcbiAgICBtb2RlbC5fc2V0KHJlZkxpc3QuaWRzU2VnbWVudHMsIGlkcyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgbXV0YXRpb24gaXMgb24gYSBwYXJlbnQgb2YgYGZyb21gLCB3ZSBtaWdodCBuZWVkIHRvIHJlLWNyZWF0ZSB0aGVcbiAgLy8gZW50aXJlIHJlZkxpc3Qgb3V0cHV0XG4gIGlmIChzZWdtZW50c0xlbmd0aCA8IGZyb21MZW5ndGgpIHtcbiAgICBtb2RlbC5fc2V0QXJyYXlEaWZmKHJlZkxpc3QuZnJvbVNlZ21lbnRzLCByZWZMaXN0LmdldCgpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaW5kZXggPSBzZWdtZW50c1tmcm9tTGVuZ3RoXTtcbiAgdmFyIHZhbHVlID0gbW9kZWwuX2dldChyZWZMaXN0LmZyb21TZWdtZW50cy5jb25jYXQoaW5kZXgpKTtcbiAgdmFyIHRvU2VnbWVudHMgPSByZWZMaXN0LnRvU2VnbWVudHNCeUl0ZW0odmFsdWUpO1xuXG4gIC8vIE11dGF0aW9uIHVuZGVybmVhdGggYSBjaGlsZCBvZiB0aGUgYGZyb21gIG9iamVjdC5cbiAgaWYgKHNlZ21lbnRzTGVuZ3RoID4gZnJvbUxlbmd0aCArIDEpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdNdXRhdGlvbiBvbiBkZXNjZW5kYW50IG9mIHJlZkxpc3QgYGZyb21gIHNob3VsZCBoYXZlIGJlZW4gZGVyZWZlcmVuY2VkOiAnICsgc2VnbWVudHMuam9pbignLicpO1xuICAgIG1vZGVsLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKG1lc3NhZ2UpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBPdGhlcndpc2UsIG11dGF0aW9uIG9mIGEgY2hpbGQgb2YgdGhlIGBmcm9tYCBvYmplY3RcblxuICAvLyBJZiBjaGFuZ2luZyB0aGUgaXRlbSBpdHNlbGYsIGl0IHdpbGwgYWxzbyBoYXZlIHRvIGJlIHJlLXNldCBvbiB0aGVcbiAgLy8gb3JpZ2luYWwgb2JqZWN0XG4gIGlmICh0eXBlID09PSAnY2hhbmdlJykge1xuICAgIG1vZGVsLl9zZXQodG9TZWdtZW50cywgdmFsdWUpO1xuICAgIHVwZGF0ZUlkRm9yVmFsdWUobW9kZWwsIHJlZkxpc3QsIGluZGV4LCB2YWx1ZSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIFRoZSBzYW1lIGdvZXMgZm9yIHN0cmluZyBtdXRhdGlvbnMsIHNpbmNlIHN0cmluZ3MgYXJlIGltbXV0YWJsZVxuICBpZiAodHlwZSA9PT0gJ3N0cmluZ0luc2VydCcpIHtcbiAgICB2YXIgc3RyaW5nSW5kZXggPSBldmVudEFyZ3NbMF07XG4gICAgdmFyIHN0cmluZ1ZhbHVlID0gZXZlbnRBcmdzWzFdO1xuICAgIG1vZGVsLl9zdHJpbmdJbnNlcnQodG9TZWdtZW50cywgc3RyaW5nSW5kZXgsIHN0cmluZ1ZhbHVlKTtcbiAgICB1cGRhdGVJZEZvclZhbHVlKG1vZGVsLCByZWZMaXN0LCBpbmRleCwgdmFsdWUpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZSA9PT0gJ3N0cmluZ1JlbW92ZScpIHtcbiAgICB2YXIgc3RyaW5nSW5kZXggPSBldmVudEFyZ3NbMF07XG4gICAgdmFyIGhvd01hbnkgPSBldmVudEFyZ3NbMV07XG4gICAgbW9kZWwuX3N0cmluZ1JlbW92ZSh0b1NlZ21lbnRzLCBzdHJpbmdJbmRleCwgaG93TWFueSk7XG4gICAgdXBkYXRlSWRGb3JWYWx1ZShtb2RlbCwgcmVmTGlzdCwgaW5kZXgsIHZhbHVlKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdpbnNlcnQnIHx8IHR5cGUgPT09ICdyZW1vdmUnIHx8IHR5cGUgPT09ICdtb3ZlJykge1xuICAgIHZhciBtZXNzYWdlID0gJ0FycmF5IG11dGF0aW9uIG9uIGNoaWxkIG9mIHJlZkxpc3QgYGZyb21gIHNob3VsZCBoYXZlIGJlZW4gZGVyZWZlcmVuY2VkOiAnICsgc2VnbWVudHMuam9pbignLicpO1xuICAgIG1vZGVsLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKG1lc3NhZ2UpKTtcbiAgICByZXR1cm47XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtNb2RlbH0gbW9kZWxcbiAqIEBwYXJhbSB7UmVmTGlzdH0gcmVmTGlzdFxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzXG4gKi9cbmZ1bmN0aW9uIHNldE5ld1RvVmFsdWVzKG1vZGVsLCByZWZMaXN0LCB2YWx1ZXMsIGZuKSB7XG4gIHZhciBpZHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgdmFyIGlkID0gcmVmTGlzdC5pZEJ5SXRlbSh2YWx1ZSk7XG4gICAgaWYgKGlkID09PSB2b2lkIDAgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWQgPSB2YWx1ZS5pZCA9IG1vZGVsLmlkKCk7XG4gICAgfVxuICAgIHZhciB0b1NlZ21lbnRzID0gcmVmTGlzdC50b1NlZ21lbnRzQnlJdGVtKHZhbHVlKTtcbiAgICBpZiAoaWQgPT09IHZvaWQgMCB8fCB0b1NlZ21lbnRzID09PSB2b2lkIDApIHtcbiAgICAgIHZhciBtZXNzYWdlID0gJ1VuYWJsZSB0byBhZGQgaXRlbSB0byByZWZMaXN0OiAnICsgdmFsdWU7XG4gICAgICByZXR1cm4gbW9kZWwuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IobWVzc2FnZSkpO1xuICAgIH1cbiAgICBpZiAobW9kZWwuX2dldCh0b1NlZ21lbnRzKSAhPT0gdmFsdWUpIHtcbiAgICAgIG1vZGVsLl9zZXQodG9TZWdtZW50cywgdmFsdWUpO1xuICAgIH1cbiAgICBpZHMucHVzaChpZCk7XG4gIH1cbiAgcmV0dXJuIGlkcztcbn1cbmZ1bmN0aW9uIHVwZGF0ZUlkRm9yVmFsdWUobW9kZWwsIHJlZkxpc3QsIGluZGV4LCB2YWx1ZSkge1xuICB2YXIgaWQgPSByZWZMaXN0LmlkQnlJdGVtKHZhbHVlKTtcbiAgdmFyIG91dFNlZ21lbnRzID0gcmVmTGlzdC5pZHNTZWdtZW50cy5jb25jYXQoaW5kZXgpO1xuICBtb2RlbC5fc2V0KG91dFNlZ21lbnRzLCBpZCk7XG59XG5cbmZ1bmN0aW9uIHBhdGNoVG9FdmVudCh0eXBlLCBzZWdtZW50cywgZXZlbnRBcmdzLCByZWZMaXN0KSB7XG4gIHZhciB0b0xlbmd0aCA9IHJlZkxpc3QudG9TZWdtZW50cy5sZW5ndGg7XG4gIHZhciBzZWdtZW50c0xlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgdmFyIHBhc3MgPSBldmVudEFyZ3NbZXZlbnRBcmdzLmxlbmd0aCAtIDFdO1xuICB2YXIgbW9kZWwgPSByZWZMaXN0Lm1vZGVsLnBhc3MocGFzcywgdHJ1ZSk7XG5cbiAgLy8gTXV0YXRpb24gb24gdGhlIGB0b2Agb2JqZWN0IGl0c2VsZlxuICBpZiAoc2VnbWVudHNMZW5ndGggPT09IHRvTGVuZ3RoKSB7XG4gICAgaWYgKHR5cGUgPT09ICdpbnNlcnQnKSB7XG4gICAgICB2YXIgaW5zZXJ0SW5kZXggPSBldmVudEFyZ3NbMF07XG4gICAgICB2YXIgdmFsdWVzID0gZXZlbnRBcmdzWzFdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICB2YXIgaW5kaWNlcyA9IHJlZkxpc3QuaW5kaWNlc0J5SXRlbSh2YWx1ZSk7XG4gICAgICAgIGlmICghaW5kaWNlcykgY29udGludWU7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW5kaWNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBvdXRTZWdtZW50cyA9IHJlZkxpc3QuZnJvbVNlZ21lbnRzLmNvbmNhdChpbmRpY2VzW2pdKTtcbiAgICAgICAgICBtb2RlbC5fc2V0KG91dFNlZ21lbnRzLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ3JlbW92ZScpIHtcbiAgICAgIHZhciByZW1vdmVJbmRleCA9IGV2ZW50QXJnc1swXTtcbiAgICAgIHZhciB2YWx1ZXMgPSBldmVudEFyZ3NbMV07XG4gICAgICB2YXIgaG93TWFueSA9IHZhbHVlcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gcmVtb3ZlSW5kZXgsIGxlbiA9IHJlbW92ZUluZGV4ICsgaG93TWFueTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBpbmRpY2VzID0gcmVmTGlzdC5pbmRpY2VzQnlJdGVtKHZhbHVlc1tpXSk7XG4gICAgICAgIGlmICghaW5kaWNlcykgY29udGludWU7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBpbmRpY2VzTGVuID0gaW5kaWNlcy5sZW5ndGg7IGogPCBpbmRpY2VzTGVuOyBqKyspIHtcbiAgICAgICAgICB2YXIgb3V0U2VnbWVudHMgPSByZWZMaXN0LmZyb21TZWdtZW50cy5jb25jYXQoaW5kaWNlc1tqXSk7XG4gICAgICAgICAgbW9kZWwuX3NldChvdXRTZWdtZW50cywgdm9pZCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnbW92ZScpIHtcbiAgICAgIC8vIE1vdmluZyBpdGVtcyBpbiB0aGUgYHRvYCBvYmplY3Qgc2hvdWxkIGhhdmUgbm8gZWZmZWN0IG9uIHRoZSBvdXRwdXRcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICAvLyBNdXRhdGlvbiBvbiBvciBhYm92ZSB0aGUgYHRvYCBvYmplY3RcbiAgaWYgKHNlZ21lbnRzTGVuZ3RoIDw9IHRvTGVuZ3RoKSB7XG4gICAgLy8gSWYgdGhlIGVudGlyZSBgdG9gIG9iamVjdCBpcyB1cGRhdGVkLCB3ZSBuZWVkIHRvIHJlLWNyZWF0ZSB0aGVcbiAgICAvLyBlbnRpcmUgcmVmTGlzdCBvdXRwdXQgYW5kIGFwcGx5IHdoYXQgaXMgZGlmZmVyZW50XG4gICAgbW9kZWwuX3NldEFycmF5RGlmZihyZWZMaXN0LmZyb21TZWdtZW50cywgcmVmTGlzdC5nZXQoKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gTXV0YXRpb24gdW5kZXJuZWF0aCBhIGNoaWxkIG9mIHRoZSBgdG9gIG9iamVjdC4gVGhlIGl0ZW0gd2lsbCBhbHJlYWR5XG4gIC8vIGJlIHVwIHRvIGRhdGUsIHNpbmNlIGl0IGlzIHVuZGVyIGFuIG9iamVjdCByZWZlcmVuY2UuIEp1c3QgcmUtZW1pdFxuICBpZiAoc2VnbWVudHNMZW5ndGggPiB0b0xlbmd0aCArIDEpIHtcbiAgICB2YXIgdmFsdWUgPSBtb2RlbC5fZ2V0KHNlZ21lbnRzLnNsaWNlKDAsIHRvTGVuZ3RoICsgMSkpO1xuICAgIHZhciBpbmRpY2VzID0gcmVmTGlzdC5pbmRpY2VzQnlJdGVtKHZhbHVlKTtcbiAgICBpZiAoIWluZGljZXMpIHJldHVybjtcbiAgICB2YXIgcmVtYWluaW5nID0gc2VnbWVudHMuc2xpY2UodG9MZW5ndGggKyAxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpbmRleCA9IGluZGljZXNbaV07XG4gICAgICB2YXIgZGVyZWZlcmVuY2VkID0gcmVmTGlzdC5mcm9tU2VnbWVudHMuY29uY2F0KGluZGV4LCByZW1haW5pbmcpO1xuICAgICAgZGVyZWZlcmVuY2VkID0gbW9kZWwuX2RlcmVmZXJlbmNlKGRlcmVmZXJlbmNlZCwgbnVsbCwgcmVmTGlzdCk7XG4gICAgICBldmVudEFyZ3MgPSBldmVudEFyZ3Muc2xpY2UoKTtcbiAgICAgIGV2ZW50QXJnc1tldmVudEFyZ3MubGVuZ3RoIC0gMV0gPSBtb2RlbC5fcGFzcztcbiAgICAgIG1vZGVsLmVtaXQodHlwZSwgZGVyZWZlcmVuY2VkLCBldmVudEFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBPdGhlcndpc2UsIG11dGF0aW9uIG9mIGEgY2hpbGQgb2YgdGhlIGB0b2Agb2JqZWN0XG5cbiAgLy8gSWYgY2hhbmdpbmcgdGhlIGl0ZW0gaXRzZWxmLCBpdCB3aWxsIGFsc28gaGF2ZSB0byBiZSByZS1zZXQgb24gdGhlXG4gIC8vIGFycmF5IGNyZWF0ZWQgYnkgdGhlIHJlZkxpc3RcbiAgaWYgKHR5cGUgPT09ICdjaGFuZ2UnIHx8IHR5cGUgPT09ICdsb2FkJyB8fCB0eXBlID09PSAndW5sb2FkJykge1xuICAgIHZhciB2YWx1ZSwgcHJldmlvdXM7XG4gICAgaWYgKHR5cGUgPT09ICdjaGFuZ2UnKSB7XG4gICAgICB2YWx1ZSA9IGV2ZW50QXJnc1swXTtcbiAgICAgIHByZXZpb3VzID0gZXZlbnRBcmdzWzFdO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2xvYWQnKSB7XG4gICAgICB2YWx1ZSA9IGV2ZW50QXJnc1swXTtcbiAgICAgIHByZXZpb3VzID0gdm9pZCAwO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3VubG9hZCcpIHtcbiAgICAgIHZhbHVlID0gdm9pZCAwO1xuICAgICAgcHJldmlvdXMgPSBldmVudEFyZ3NbMF07XG4gICAgfVxuICAgIHZhciBuZXdJbmRpY2VzID0gcmVmTGlzdC5pbmRpY2VzQnlJdGVtKHZhbHVlKTtcbiAgICB2YXIgb2xkSW5kaWNlcyA9IHJlZkxpc3QuaW5kaWNlc0J5SXRlbShwcmV2aW91cyk7XG4gICAgaWYgKCFuZXdJbmRpY2VzICYmICFvbGRJbmRpY2VzKSByZXR1cm47XG4gICAgaWYgKG9sZEluZGljZXMgJiYgIWVxdWl2YWxlbnRBcnJheXMob2xkSW5kaWNlcywgbmV3SW5kaWNlcykpIHtcbiAgICAgIC8vIFRoZSBjaGFuZ2VkIGl0ZW0gdXNlZCB0byByZWZlciB0byBzb21lIGluZGljZXMsIGJ1dCBubyBsb25nZXIgZG9lc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbGRJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvdXRTZWdtZW50cyA9IHJlZkxpc3QuZnJvbVNlZ21lbnRzLmNvbmNhdChvbGRJbmRpY2VzW2ldKTtcbiAgICAgICAgbW9kZWwuX3NldChvdXRTZWdtZW50cywgdm9pZCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5ld0luZGljZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3SW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgb3V0U2VnbWVudHMgPSByZWZMaXN0LmZyb21TZWdtZW50cy5jb25jYXQobmV3SW5kaWNlc1tpXSk7XG4gICAgICAgIG1vZGVsLl9zZXQob3V0U2VnbWVudHMsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gbW9kZWwuX2dldChzZWdtZW50cy5zbGljZSgwLCB0b0xlbmd0aCArIDEpKTtcbiAgdmFyIGluZGljZXMgPSByZWZMaXN0LmluZGljZXNCeUl0ZW0odmFsdWUpO1xuICBpZiAoIWluZGljZXMpIHJldHVybjtcblxuICAvLyBUaGUgc2FtZSBnb2VzIGZvciBzdHJpbmcgbXV0YXRpb25zLCBzaW5jZSBzdHJpbmdzIGFyZSBpbW11dGFibGVcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmdJbnNlcnQnKSB7XG4gICAgdmFyIHN0cmluZ0luZGV4ID0gZXZlbnRBcmdzWzBdO1xuICAgIHZhciB2YWx1ZSA9IGV2ZW50QXJnc1sxXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdXRTZWdtZW50cyA9IHJlZkxpc3QuZnJvbVNlZ21lbnRzKGluZGljZXNbaV0pO1xuICAgICAgbW9kZWwuX3N0cmluZ0luc2VydChvdXRTZWdtZW50cywgc3RyaW5nSW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlID09PSAnc3RyaW5nUmVtb3ZlJykge1xuICAgIHZhciBzdHJpbmdJbmRleCA9IGV2ZW50QXJnc1swXTtcbiAgICB2YXIgaG93TWFueSA9IGV2ZW50QXJnc1sxXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdXRTZWdtZW50cyA9IHJlZkxpc3QuZnJvbVNlZ21lbnRzKGluZGljZXNbaV0pO1xuICAgICAgbW9kZWwuX3N0cmluZ1JlbW92ZShvdXRTZWdtZW50cywgc3RyaW5nSW5kZXgsIGhvd01hbnkpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdpbnNlcnQnIHx8IHR5cGUgPT09ICdyZW1vdmUnIHx8IHR5cGUgPT09ICdtb3ZlJykge1xuICAgIC8vIEFycmF5IG11dGF0aW9ucyB3aWxsIGhhdmUgYWxyZWFkeSBiZWVuIHVwZGF0ZWQgdmlhIGFuIG9iamVjdFxuICAgIC8vIHJlZmVyZW5jZSwgc28gb25seSByZS1lbWl0XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVyZWZlcmVuY2VkID0gcmVmTGlzdC5mcm9tU2VnbWVudHMuY29uY2F0KGluZGljZXNbaV0pO1xuICAgICAgZGVyZWZlcmVuY2VkID0gbW9kZWwuX2RlcmVmZXJlbmNlKGRlcmVmZXJlbmNlZCwgbnVsbCwgcmVmTGlzdCk7XG4gICAgICBldmVudEFyZ3MgPSBldmVudEFyZ3Muc2xpY2UoKTtcbiAgICAgIGV2ZW50QXJnc1tldmVudEFyZ3MubGVuZ3RoIC0gMV0gPSBtb2RlbC5fcGFzcztcbiAgICAgIG1vZGVsLmVtaXQodHlwZSwgZGVyZWZlcmVuY2VkLCBldmVudEFyZ3MpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZXF1aXZhbGVudEFycmF5cyhhLCBiKSB7XG4gIGlmICghYSB8fCAhYikgcmV0dXJuIGZhbHNlO1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHBhdGNoSWRzRXZlbnQodHlwZSwgc2VnbWVudHMsIGV2ZW50QXJncywgcmVmTGlzdCkge1xuICB2YXIgaWRzTGVuZ3RoID0gcmVmTGlzdC5pZHNTZWdtZW50cy5sZW5ndGg7XG4gIHZhciBzZWdtZW50c0xlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgdmFyIHBhc3MgPSBldmVudEFyZ3NbZXZlbnRBcmdzLmxlbmd0aCAtIDFdO1xuICB2YXIgbW9kZWwgPSByZWZMaXN0Lm1vZGVsLnBhc3MocGFzcywgdHJ1ZSk7XG5cbiAgLy8gQW4gYXJyYXkgbXV0YXRpb24gb2YgdGhlIGlkcyBzaG91bGQgYmUgbWlycm9yZWQgd2l0aCBhIGxpa2UgY2hhbmdlIGluXG4gIC8vIHRoZSBvdXRwdXQgYXJyYXlcbiAgaWYgKHNlZ21lbnRzTGVuZ3RoID09PSBpZHNMZW5ndGgpIHtcbiAgICBpZiAodHlwZSA9PT0gJ2luc2VydCcpIHtcbiAgICAgIHZhciBpbmRleCA9IGV2ZW50QXJnc1swXTtcbiAgICAgIHZhciBpbnNlcnRlZCA9IGV2ZW50QXJnc1sxXTtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5zZXJ0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcmVmTGlzdC5pdGVtQnlJZChpbnNlcnRlZFtpXSk7XG4gICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIG1vZGVsLl9pbnNlcnQocmVmTGlzdC5mcm9tU2VnbWVudHMsIGluZGV4LCB2YWx1ZXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAncmVtb3ZlJykge1xuICAgICAgdmFyIGluZGV4ID0gZXZlbnRBcmdzWzBdO1xuICAgICAgdmFyIGhvd01hbnkgPSBldmVudEFyZ3NbMV0ubGVuZ3RoO1xuICAgICAgbW9kZWwuX3JlbW92ZShyZWZMaXN0LmZyb21TZWdtZW50cywgaW5kZXgsIGhvd01hbnkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnbW92ZScpIHtcbiAgICAgIHZhciBmcm9tID0gZXZlbnRBcmdzWzBdO1xuICAgICAgdmFyIHRvID0gZXZlbnRBcmdzWzFdO1xuICAgICAgdmFyIGhvd01hbnkgPSBldmVudEFyZ3NbMl07XG4gICAgICBtb2RlbC5fbW92ZShyZWZMaXN0LmZyb21TZWdtZW50cywgZnJvbSwgdG8sIGhvd01hbnkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIC8vIE11dGF0aW9uIG9uIHRoZSBgaWRzYCBsaXN0IGl0c2VsZlxuICBpZiAoc2VnbWVudHNMZW5ndGggPD0gaWRzTGVuZ3RoKSB7XG4gICAgLy8gSWYgdGhlIGVudGlyZSBgaWRzYCBhcnJheSBpcyB1cGRhdGVkLCB3ZSBuZWVkIHRvIHJlLWNyZWF0ZSB0aGVcbiAgICAvLyBlbnRpcmUgcmVmTGlzdCBvdXRwdXQgYW5kIGFwcGx5IHdoYXQgaXMgZGlmZmVyZW50XG4gICAgbW9kZWwuX3NldEFycmF5RGlmZihyZWZMaXN0LmZyb21TZWdtZW50cywgcmVmTGlzdC5nZXQoKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlLCBkaXJlY3QgbXV0YXRpb24gb2YgYSBjaGlsZCBpbiB0aGUgYGlkc2Agb2JqZWN0IG9yIG11dGF0aW9uXG4gIC8vIHVuZGVybmVhdGggYW4gaXRlbSBpbiB0aGUgYGlkc2AgbGlzdC4gVXBkYXRlIHRoZSBpdGVtIGZvciB0aGUgYXBwcm9wcmlhdGVcbiAgLy8gaWQgaWYgaXQgaGFzIGNoYW5nZWRcbiAgdmFyIGluZGV4ID0gc2VnbWVudHNbaWRzTGVuZ3RoXTtcbiAgdmFyIGlkID0gcmVmTGlzdC5pZEJ5SW5kZXgoaW5kZXgpO1xuICB2YXIgaXRlbSA9IHJlZkxpc3QuaXRlbUJ5SWQoaWQpO1xuICB2YXIgaXRlbVNlZ21lbnRzID0gcmVmTGlzdC5mcm9tU2VnbWVudHMuY29uY2F0KGluZGV4KTtcbiAgaWYgKG1vZGVsLl9nZXQoaXRlbVNlZ21lbnRzKSAhPT0gaXRlbSkge1xuICAgIG1vZGVsLl9zZXQoaXRlbVNlZ21lbnRzLCBpdGVtKTtcbiAgfVxufVxuXG5Nb2RlbC5wcm90b3R5cGUucmVmTGlzdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZnJvbSwgdG8sIGlkcywgb3B0aW9ucztcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB0byA9IGFyZ3VtZW50c1swXTtcbiAgICBpZHMgPSBhcmd1bWVudHNbMV07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIGlmICh0aGlzLmlzUGF0aChhcmd1bWVudHNbMl0pKSB7XG4gICAgICBmcm9tID0gYXJndW1lbnRzWzBdO1xuICAgICAgdG8gPSBhcmd1bWVudHNbMV07XG4gICAgICBpZHMgPSBhcmd1bWVudHNbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvID0gYXJndW1lbnRzWzBdO1xuICAgICAgaWRzID0gYXJndW1lbnRzWzFdO1xuICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50c1syXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZnJvbSA9IGFyZ3VtZW50c1swXTtcbiAgICB0byA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZHMgPSBhcmd1bWVudHNbMl07XG4gICAgb3B0aW9ucyA9IGFyZ3VtZW50c1szXTtcbiAgfVxuICB2YXIgZnJvbVBhdGggPSB0aGlzLnBhdGgoZnJvbSk7XG4gIGlmIChBcnJheS5pc0FycmF5KHRvKSkge1xuICAgIHZhciB0b1BhdGggPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b1BhdGgucHVzaCh0aGlzLnBhdGgodG9baV0pKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRvUGF0aCA9IHRoaXMucGF0aCh0byk7XG4gIH1cbiAgdmFyIGlkc1BhdGggPSB0aGlzLnBhdGgoaWRzKTtcbiAgdmFyIHJlZkxpc3QgPSB0aGlzLnJvb3QuX3JlZkxpc3RzLmFkZChmcm9tUGF0aCwgdG9QYXRoLCBpZHNQYXRoLCBvcHRpb25zKTtcbiAgdGhpcy5wYXNzKHskcmVmTGlzdDogcmVmTGlzdH0pLl9zZXRBcnJheURpZmYocmVmTGlzdC5mcm9tU2VnbWVudHMsIHJlZkxpc3QuZ2V0KCkpO1xuICByZXR1cm4gdGhpcy5zY29wZShmcm9tUGF0aCk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUucmVtb3ZlUmVmTGlzdCA9IGZ1bmN0aW9uKGZyb20pIHtcbiAgdmFyIGZyb21QYXRoID0gdGhpcy5wYXRoKGZyb20pO1xuICB2YXIgcmVmTGlzdCA9IHRoaXMucm9vdC5fcmVmTGlzdHMucmVtb3ZlKGZyb21QYXRoKTtcbiAgaWYgKHJlZkxpc3QpIHRoaXMuX2RlbChyZWZMaXN0LmZyb21TZWdtZW50cyk7XG59O1xuXG5mdW5jdGlvbiBSZWZMaXN0KG1vZGVsLCBmcm9tLCB0bywgaWRzLCBvcHRpb25zKSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbCAmJiBtb2RlbC5wYXNzKHskcmVmTGlzdDogdGhpc30pO1xuICB0aGlzLmZyb20gPSBmcm9tO1xuICB0aGlzLnRvID0gdG87XG4gIHRoaXMuaWRzID0gaWRzO1xuICB0aGlzLmZyb21TZWdtZW50cyA9IGZyb20gJiYgZnJvbS5zcGxpdCgnLicpO1xuICB0aGlzLnRvU2VnbWVudHMgPSB0byAmJiB0by5zcGxpdCgnLicpO1xuICB0aGlzLmlkc1NlZ21lbnRzID0gaWRzICYmIGlkcy5zcGxpdCgnLicpO1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLmRlbGV0ZVJlbW92ZWQgPSBvcHRpb25zICYmIG9wdGlvbnMuZGVsZXRlUmVtb3ZlZDtcbn1cblxuLy8gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gYXNzdW1lcyB0aGF0IHRoZSBpZHMgYXJyYXkgaXMgYSBmbGF0IGxpc3Qgb2Zcbi8vIGtleXMgb24gdGhlIHRvIG9iamVjdC4gSWRlYWxseSwgdGhpcyBtYXBwaW5nIGNvdWxkIGJlIGN1c3RvbWl6ZWQgdmlhXG4vLyBpbmhlcml0aW5nIGZyb20gUmVmTGlzdCBhbmQgb3ZlcnJpZGluZyB0aGVzZSBtZXRob2RzIHdpdGhvdXQgaGF2aW5nIHRvXG4vLyBtb2RpZnkgdGhlIGFib3ZlIGV2ZW50IGhhbmRsaW5nIGNvZGUuXG4vLyBcbi8vIEluIHRoZSBkZWZhdWx0IHJlZkxpc3QgaW1wbGVtZW50YXRpb24sIGBrZXlgIGFuZCBgaWRgIGFyZSBlcXVhbC5cbi8vIFxuLy8gVGVybXMgaW4gdGhlIGJlbG93IG1ldGhvZHM6XG4vLyAgIGBpdGVtYCAgLSBPYmplY3Qgb24gdGhlIGB0b2AgcGF0aCwgd2hpY2ggZ2V0cyBtaXJyb3JlZCBvbiB0aGUgYGZyb21gIHBhdGhcbi8vICAgYGtleWAgICAtIFRoZSBwcm9wZXJ0eSB1bmRlciBgdG9gIGF0IHdoaWNoIGFuIGl0ZW0gaXMgbG9jYXRlZFxuLy8gICBgaWRgICAgIC0gU3RyaW5nIG9yIG9iamVjdCBpbiB0aGUgYXJyYXkgYXQgdGhlIGBpZHNgIHBhdGhcbi8vICAgYGluZGV4YCAtIFRoZSBpbmRleCBvZiBhbiBpZCwgd2hpY2ggY29ycmVzcG9uZHMgdG8gYW4gaW5kZXggb24gYGZyb21gXG5SZWZMaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGlkcyA9IHRoaXMubW9kZWwuX2dldCh0aGlzLmlkc1NlZ21lbnRzKTtcbiAgaWYgKCFpZHMpIHJldHVybiBbXTtcbiAgdmFyIGl0ZW1zID0gdGhpcy5tb2RlbC5fZ2V0KHRoaXMudG9TZWdtZW50cyk7XG4gIHZhciBvdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gaWRzW2ldO1xuICAgIG91dC5wdXNoKGl0ZW1zICYmIGl0ZW1zW2tleV0pO1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuUmVmTGlzdC5wcm90b3R5cGUuZGVyZWZlcmVuY2UgPSBmdW5jdGlvbihzZWdtZW50cywgaSkge1xuICB2YXIgcmVtYWluaW5nID0gc2VnbWVudHMuc2xpY2UoaSArIDEpO1xuICB2YXIga2V5ID0gdGhpcy5pZEJ5SW5kZXgocmVtYWluaW5nWzBdKTtcbiAgaWYgKGtleSA9PSBudWxsKSByZXR1cm4gW107XG4gIHJlbWFpbmluZ1swXSA9IGtleTtcbiAgcmV0dXJuIHRoaXMudG9TZWdtZW50cy5jb25jYXQocmVtYWluaW5nKTtcbn07XG5SZWZMaXN0LnByb3RvdHlwZS50b1NlZ21lbnRzQnlJdGVtID0gZnVuY3Rpb24oaXRlbSkge1xuICB2YXIga2V5ID0gdGhpcy5pZEJ5SXRlbShpdGVtKTtcbiAgaWYgKGtleSA9PT0gdm9pZCAwKSByZXR1cm47XG4gIHJldHVybiB0aGlzLnRvU2VnbWVudHMuY29uY2F0KGtleSk7XG59O1xuUmVmTGlzdC5wcm90b3R5cGUuaWRCeUl0ZW0gPSBmdW5jdGlvbihpdGVtKSB7XG4gIGlmIChpdGVtICYmIGl0ZW0uaWQpIHJldHVybiBpdGVtLmlkO1xuICB2YXIgaXRlbXMgPSB0aGlzLm1vZGVsLl9nZXQodGhpcy50b1NlZ21lbnRzKTtcbiAgZm9yICh2YXIga2V5IGluIGl0ZW1zKSB7XG4gICAgaWYgKGl0ZW0gPT09IGl0ZW1zW2tleV0pIHJldHVybiBrZXk7XG4gIH1cbn07XG5SZWZMaXN0LnByb3RvdHlwZS5pbmRpY2VzQnlJdGVtID0gZnVuY3Rpb24oaXRlbSkge1xuICB2YXIgaWQgPSB0aGlzLmlkQnlJdGVtKGl0ZW0pO1xuICB2YXIgaWRzID0gdGhpcy5tb2RlbC5fZ2V0KHRoaXMuaWRzU2VnbWVudHMpO1xuICBpZiAoIWlkcykgcmV0dXJuO1xuICB2YXIgaW5kaWNlcztcbiAgdmFyIGluZGV4ID0gLTE7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaW5kZXggPSBpZHMuaW5kZXhPZihpZCwgaW5kZXggKyAxKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSBicmVhaztcbiAgICBpZiAoaW5kaWNlcykge1xuICAgICAgaW5kaWNlcy5wdXNoKGluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kaWNlcyA9IFtpbmRleF07XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmRpY2VzO1xufTtcblJlZkxpc3QucHJvdG90eXBlLml0ZW1CeUlkID0gZnVuY3Rpb24oaWQpIHtcbiAgcmV0dXJuIHRoaXMubW9kZWwuX2dldCh0aGlzLnRvU2VnbWVudHMuY29uY2F0KGlkKSk7XG59O1xuUmVmTGlzdC5wcm90b3R5cGUuaWRCeUluZGV4ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgcmV0dXJuIHRoaXMubW9kZWwuX2dldCh0aGlzLmlkc1NlZ21lbnRzLmNvbmNhdChpbmRleCkpO1xufTtcblJlZkxpc3QucHJvdG90eXBlLm9uTXV0YXRpb24gPSBmdW5jdGlvbih0eXBlLCBzZWdtZW50cywgZXZlbnRBcmdzKSB7XG4gIGlmICh1dGlsLm1heUltcGFjdCh0aGlzLnRvU2VnbWVudHMsIHNlZ21lbnRzKSkge1xuICAgIHBhdGNoVG9FdmVudCh0eXBlLCBzZWdtZW50cywgZXZlbnRBcmdzLCB0aGlzKTtcbiAgfSBlbHNlIGlmICh1dGlsLm1heUltcGFjdCh0aGlzLmlkc1NlZ21lbnRzLCBzZWdtZW50cykpIHtcbiAgICBwYXRjaElkc0V2ZW50KHR5cGUsIHNlZ21lbnRzLCBldmVudEFyZ3MsIHRoaXMpO1xuICB9IGVsc2UgaWYgKHV0aWwubWF5SW1wYWN0KHRoaXMuZnJvbVNlZ21lbnRzLCBzZWdtZW50cykpIHtcbiAgICBwYXRjaEZyb21FdmVudCh0eXBlLCBzZWdtZW50cywgZXZlbnRBcmdzLCB0aGlzKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gRnJvbU1hcCgpIHt9XG5cbmZ1bmN0aW9uIFJlZkxpc3RzKG1vZGVsKSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgdGhpcy5mcm9tTWFwID0gbmV3IEZyb21NYXA7XG59XG5cblJlZkxpc3RzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihmcm9tLCB0bywgaWRzLCBvcHRpb25zKSB7XG4gIHZhciByZWZMaXN0ID0gbmV3IFJlZkxpc3QodGhpcy5tb2RlbCwgZnJvbSwgdG8sIGlkcywgb3B0aW9ucyk7XG4gIHRoaXMuZnJvbU1hcFtmcm9tXSA9IHJlZkxpc3Q7XG4gIHJldHVybiByZWZMaXN0O1xufTtcblxuUmVmTGlzdHMucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGZyb20pIHtcbiAgdmFyIHJlZkxpc3QgPSB0aGlzLmZyb21NYXBbZnJvbV07XG4gIGRlbGV0ZSB0aGlzLmZyb21NYXBbZnJvbV07XG4gIHJldHVybiByZWZMaXN0O1xufTtcblxuUmVmTGlzdHMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3V0ID0gW107XG4gIGZvciAodmFyIGZyb20gaW4gdGhpcy5mcm9tTWFwKSB7XG4gICAgdmFyIHJlZkxpc3QgPSB0aGlzLmZyb21NYXBbZnJvbV07XG4gICAgb3V0LnB1c2goW3JlZkxpc3QuZnJvbSwgcmVmTGlzdC50bywgcmVmTGlzdC5pZHMsIHJlZkxpc3Qub3B0aW9uc10pO1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyk7XG5cbk1vZGVsLklOSVRTLnB1c2goZnVuY3Rpb24obW9kZWwpIHtcbiAgdmFyIHJvb3QgPSBtb2RlbC5yb290O1xuICByb290Ll9yZWZzID0gbmV3IFJlZnMocm9vdCk7XG4gIGFkZEluZGV4TGlzdGVuZXJzKHJvb3QpO1xuICBhZGRMaXN0ZW5lcihyb290LCAnY2hhbmdlJywgcmVmQ2hhbmdlKTtcbiAgYWRkTGlzdGVuZXIocm9vdCwgJ2xvYWQnLCByZWZMb2FkKTtcbiAgYWRkTGlzdGVuZXIocm9vdCwgJ3VubG9hZCcsIHJlZlVubG9hZCk7XG4gIGFkZExpc3RlbmVyKHJvb3QsICdpbnNlcnQnLCByZWZJbnNlcnQpO1xuICBhZGRMaXN0ZW5lcihyb290LCAncmVtb3ZlJywgcmVmUmVtb3ZlKTtcbiAgYWRkTGlzdGVuZXIocm9vdCwgJ21vdmUnLCByZWZNb3ZlKTtcbiAgYWRkTGlzdGVuZXIocm9vdCwgJ3N0cmluZ0luc2VydCcsIHJlZlN0cmluZ0luc2VydCk7XG4gIGFkZExpc3RlbmVyKHJvb3QsICdzdHJpbmdSZW1vdmUnLCByZWZTdHJpbmdSZW1vdmUpO1xufSk7XG5cbmZ1bmN0aW9uIGFkZEluZGV4TGlzdGVuZXJzKG1vZGVsKSB7XG4gIG1vZGVsLm9uKCdpbnNlcnQnLCBmdW5jdGlvbiByZWZJbnNlcnRJbmRleChzZWdtZW50cywgZXZlbnRBcmdzKSB7XG4gICAgdmFyIGluZGV4ID0gZXZlbnRBcmdzWzBdO1xuICAgIHZhciBob3dNYW55ID0gZXZlbnRBcmdzWzFdLmxlbmd0aDtcbiAgICBmdW5jdGlvbiBwYXRjaEluc2VydChyZWZJbmRleCkge1xuICAgICAgcmV0dXJuIChpbmRleCA8PSByZWZJbmRleCkgPyByZWZJbmRleCArIGhvd01hbnkgOiByZWZJbmRleDtcbiAgICB9XG4gICAgb25JbmRleENoYW5nZShzZWdtZW50cywgcGF0Y2hJbnNlcnQpO1xuICB9KTtcbiAgbW9kZWwub24oJ3JlbW92ZScsIGZ1bmN0aW9uIHJlZlJlbW92ZUluZGV4KHNlZ21lbnRzLCBldmVudEFyZ3MpIHtcbiAgICB2YXIgaW5kZXggPSBldmVudEFyZ3NbMF07XG4gICAgdmFyIGhvd01hbnkgPSBldmVudEFyZ3NbMV0ubGVuZ3RoO1xuICAgIGZ1bmN0aW9uIHBhdGNoUmVtb3ZlKHJlZkluZGV4KSB7XG4gICAgICByZXR1cm4gKGluZGV4IDw9IHJlZkluZGV4KSA/IHJlZkluZGV4IC0gaG93TWFueSA6IHJlZkluZGV4O1xuICAgIH1cbiAgICBvbkluZGV4Q2hhbmdlKHNlZ21lbnRzLCBwYXRjaFJlbW92ZSk7XG4gIH0pO1xuICBtb2RlbC5vbignbW92ZScsIGZ1bmN0aW9uIHJlZk1vdmVJbmRleChzZWdtZW50cywgZXZlbnRBcmdzKSB7XG4gICAgdmFyIGZyb20gPSBldmVudEFyZ3NbMF07XG4gICAgdmFyIHRvID0gZXZlbnRBcmdzWzFdO1xuICAgIHZhciBob3dNYW55ID0gZXZlbnRBcmdzWzJdO1xuICAgIGZ1bmN0aW9uIHBhdGNoTW92ZShyZWZJbmRleCkge1xuICAgICAgLy8gSWYgdGhlIGluZGV4IHdhcyBtb3ZlZCBpdHNlbGZcbiAgICAgIGlmIChmcm9tIDw9IHJlZkluZGV4ICYmIHJlZkluZGV4IDwgZnJvbSArIGhvd01hbnkpIHtcbiAgICAgICAgcmV0dXJuIHJlZkluZGV4ICsgdG8gLSBmcm9tO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIHBhcnQgb2YgYSBtb3ZlXG4gICAgICBpZiAoZnJvbSA8PSByZWZJbmRleCkgcmVmSW5kZXggLT0gaG93TWFueTtcbiAgICAgIC8vIEluc2VydCBwYXJ0IG9mIGEgbW92ZVxuICAgICAgaWYgKHRvIDw9IHJlZkluZGV4KSByZWZJbmRleCArPSBob3dNYW55O1xuICAgICAgcmV0dXJuIHJlZkluZGV4O1xuICAgIH1cbiAgICBvbkluZGV4Q2hhbmdlKHNlZ21lbnRzLCBwYXRjaE1vdmUpO1xuICB9KTtcbiAgZnVuY3Rpb24gb25JbmRleENoYW5nZShzZWdtZW50cywgcGF0Y2gpIHtcbiAgICB2YXIgZnJvbU1hcCA9IG1vZGVsLl9yZWZzLmZyb21NYXA7XG4gICAgZm9yICh2YXIgZnJvbSBpbiBmcm9tTWFwKSB7XG4gICAgICB2YXIgcmVmID0gZnJvbU1hcFtmcm9tXTtcbiAgICAgIGlmICghKHJlZi51cGRhdGVJbmRpY2VzICYmXG4gICAgICAgIHV0aWwuY29udGFpbnMoc2VnbWVudHMsIHJlZi50b1NlZ21lbnRzKSAmJlxuICAgICAgICByZWYudG9TZWdtZW50cy5sZW5ndGggPiBzZWdtZW50cy5sZW5ndGgpKSBjb250aW51ZTtcbiAgICAgIHZhciBpbmRleCA9ICtyZWYudG9TZWdtZW50c1tzZWdtZW50cy5sZW5ndGhdO1xuICAgICAgdmFyIHBhdGNoZWQgPSBwYXRjaChpbmRleCk7XG4gICAgICBpZiAoaW5kZXggPT09IHBhdGNoZWQpIGNvbnRpbnVlO1xuICAgICAgbW9kZWwuX3JlZnMucmVtb3ZlKGZyb20pO1xuICAgICAgcmVmLnRvU2VnbWVudHNbc2VnbWVudHMubGVuZ3RoXSA9ICcnICsgcGF0Y2hlZDtcbiAgICAgIHJlZi50byA9IHJlZi50b1NlZ21lbnRzLmpvaW4oJy4nKTtcbiAgICAgIG1vZGVsLl9yZWZzLl9hZGQocmVmKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVmQ2hhbmdlKG1vZGVsLCBkZXJlZmVyZW5jZWQsIGV2ZW50QXJncykge1xuICB2YXIgdmFsdWUgPSBldmVudEFyZ3NbMF07XG4gIG1vZGVsLl9zZXQoZGVyZWZlcmVuY2VkLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiByZWZMb2FkKG1vZGVsLCBkZXJlZmVyZW5jZWQsIGV2ZW50QXJncykge1xuICB2YXIgdmFsdWUgPSBldmVudEFyZ3NbMF07XG4gIG1vZGVsLl9zZXQoZGVyZWZlcmVuY2VkLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiByZWZVbmxvYWQobW9kZWwsIGRlcmVmZXJlbmNlZCwgZXZlbnRBcmdzKSB7XG4gIG1vZGVsLl9kZWwoZGVyZWZlcmVuY2VkKTtcbn1cbmZ1bmN0aW9uIHJlZkluc2VydChtb2RlbCwgZGVyZWZlcmVuY2VkLCBldmVudEFyZ3MpIHtcbiAgdmFyIGluZGV4ID0gZXZlbnRBcmdzWzBdO1xuICB2YXIgdmFsdWVzID0gZXZlbnRBcmdzWzFdO1xuICBtb2RlbC5faW5zZXJ0KGRlcmVmZXJlbmNlZCwgaW5kZXgsIHZhbHVlcyk7XG59XG5mdW5jdGlvbiByZWZSZW1vdmUobW9kZWwsIGRlcmVmZXJlbmNlZCwgZXZlbnRBcmdzKSB7XG4gIHZhciBpbmRleCA9IGV2ZW50QXJnc1swXTtcbiAgdmFyIGhvd01hbnkgPSBldmVudEFyZ3NbMV0ubGVuZ3RoO1xuICBtb2RlbC5fcmVtb3ZlKGRlcmVmZXJlbmNlZCwgaW5kZXgsIGhvd01hbnkpO1xufVxuZnVuY3Rpb24gcmVmTW92ZShtb2RlbCwgZGVyZWZlcmVuY2VkLCBldmVudEFyZ3MpIHtcbiAgdmFyIGZyb20gPSBldmVudEFyZ3NbMF07XG4gIHZhciB0byA9IGV2ZW50QXJnc1sxXTtcbiAgdmFyIGhvd01hbnkgPSBldmVudEFyZ3NbMl07XG4gIG1vZGVsLl9tb3ZlKGRlcmVmZXJlbmNlZCwgZnJvbSwgdG8sIGhvd01hbnkpO1xufVxuZnVuY3Rpb24gcmVmU3RyaW5nSW5zZXJ0KG1vZGVsLCBkZXJlZmVyZW5jZWQsIGV2ZW50QXJncykge1xuICB2YXIgaW5kZXggPSBldmVudEFyZ3NbMF07XG4gIHZhciB0ZXh0ID0gZXZlbnRBcmdzWzFdO1xuICBtb2RlbC5fc3RyaW5nSW5zZXJ0KGRlcmVmZXJlbmNlZCwgaW5kZXgsIHRleHQpO1xufVxuZnVuY3Rpb24gcmVmU3RyaW5nUmVtb3ZlKG1vZGVsLCBkZXJlZmVyZW5jZWQsIGV2ZW50QXJncykge1xuICB2YXIgaW5kZXggPSBldmVudEFyZ3NbMF07XG4gIHZhciBob3dNYW55ID0gZXZlbnRBcmdzWzFdO1xuICBtb2RlbC5fc3RyaW5nUmVtb3ZlKGRlcmVmZXJlbmNlZCwgaW5kZXgsIGhvd01hbnkpO1xufVxuXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihtb2RlbCwgdHlwZSwgZm4pIHtcbiAgbW9kZWwub24odHlwZSwgcmVmTGlzdGVuZXIpO1xuICBmdW5jdGlvbiByZWZMaXN0ZW5lcihzZWdtZW50cywgZXZlbnRBcmdzKSB7XG4gICAgdmFyIHBhc3MgPSBldmVudEFyZ3NbZXZlbnRBcmdzLmxlbmd0aCAtIDFdO1xuICAgIC8vIEZpbmQgY2FzZXMgd2hlcmUgYW4gZXZlbnQgaXMgZW1pdHRlZCBvbiBhIHBhdGggd2hlcmUgYSByZWZlcmVuY2VcbiAgICAvLyBpcyBwb2ludGluZy4gQWxsIG9yaWdpbmFsIG11dGF0aW9ucyBoYXBwZW4gb24gdGhlIGZ1bGx5IGRlcmVmZXJlbmNlZFxuICAgIC8vIGxvY2F0aW9uLCBzbyB0aGlzIGRldGVjdGlvbiBvbmx5IG5lZWRzIHRvIGhhcHBlbiBpbiBvbmUgZGlyZWN0aW9uXG4gICAgdmFyIHRvTWFwID0gbW9kZWwuX3JlZnMudG9NYXA7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgc3VicGF0aCA9IChzdWJwYXRoKSA/IHN1YnBhdGggKyAnLicgKyBzZWdtZW50c1tpXSA6IHNlZ21lbnRzW2ldO1xuICAgICAgLy8gSWYgYSByZWYgaXMgZm91bmQgcG9pbnRpbmcgdG8gYSBtYXRjaGluZyBzdWJwYXRoLCByZS1lbWl0IG9uIHRoZVxuICAgICAgLy8gcGxhY2Ugd2hlcmUgdGhlIHJlZmVyZW5jZSBpcyBjb21pbmcgZnJvbSBhcyBpZiB0aGUgbXV0YXRpb24gYWxzb1xuICAgICAgLy8gb2NjdXJlZCBhdCB0aGF0IHBhdGhcbiAgICAgIHZhciByZWZzID0gdG9NYXBbc3VicGF0aF07XG4gICAgICBpZiAoIXJlZnMpIGNvbnRpbnVlO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IHNlZ21lbnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgIGZvciAodmFyIHJlZkluZGV4ID0gMCwgbnVtUmVmcyA9IHJlZnMubGVuZ3RoOyByZWZJbmRleCA8IG51bVJlZnM7IHJlZkluZGV4KyspIHtcbiAgICAgICAgdmFyIHJlZiA9IHJlZnNbcmVmSW5kZXhdO1xuICAgICAgICB2YXIgZGVyZWZlcmVuY2VkID0gcmVmLmZyb21TZWdtZW50cy5jb25jYXQocmVtYWluaW5nKTtcbiAgICAgICAgLy8gVGhlIHZhbHVlIG1heSBhbHJlYWR5IGJlIHVwIHRvIGRhdGUgdmlhIG9iamVjdCByZWZlcmVuY2UuIElmIHNvLFxuICAgICAgICAvLyBzaW1wbHkgcmUtZW1pdCB0aGUgZXZlbnQuIE90aGVyd2lzZSwgcGVyZm9ybSB0aGUgc2FtZSBtdXRhdGlvbiBvblxuICAgICAgICAvLyB0aGUgcmVmJ3MgcGF0aFxuICAgICAgICBpZiAocGFzcy4kb3JpZ2luYWwgfHwgbW9kZWwuX2dldChkZXJlZmVyZW5jZWQpID09PSBtb2RlbC5fZ2V0KHNlZ21lbnRzKSkge1xuICAgICAgICAgIG1vZGVsLmVtaXQodHlwZSwgZGVyZWZlcmVuY2VkLCBldmVudEFyZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzZXR0ZXJNb2RlbCA9IHJlZi5tb2RlbC5wYXNzKHBhc3MsIHRydWUpO1xuICAgICAgICAgIHNldHRlck1vZGVsLl9kZXJlZmVyZW5jZSA9IG5vb3BEZXJlZmVyZW5jZTtcbiAgICAgICAgICBmbihzZXR0ZXJNb2RlbCwgZGVyZWZlcmVuY2VkLCBldmVudEFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIElmIGEgcmVmIHBvaW50cyB0byBhIGNoaWxkIG9mIGEgbWF0Y2hpbmcgc3VicGF0aCwgZ2V0IHRoZSB2YWx1ZSBpblxuICAgIC8vIGNhc2UgaXQgaGFzIGNoYW5nZWQgYW5kIHNldCBpZiBkaWZmZXJlbnRcbiAgICB2YXIgcGFyZW50VG9NYXAgPSBtb2RlbC5fcmVmcy5wYXJlbnRUb01hcDtcbiAgICB2YXIgcmVmcyA9IHBhcmVudFRvTWFwW3N1YnBhdGhdO1xuICAgIGlmICghcmVmcykgcmV0dXJuO1xuICAgIGZvciAodmFyIHJlZkluZGV4ID0gMCwgbnVtUmVmcyA9IHJlZnMubGVuZ3RoOyByZWZJbmRleCA8IG51bVJlZnM7IHJlZkluZGV4KyspIHtcbiAgICAgIHZhciByZWYgPSByZWZzW3JlZkluZGV4XTtcbiAgICAgIHZhciB2YWx1ZSA9IG1vZGVsLl9nZXQocmVmLnRvU2VnbWVudHMpO1xuICAgICAgdmFyIHByZXZpb3VzID0gbW9kZWwuX2dldChyZWYuZnJvbVNlZ21lbnRzKTtcbiAgICAgIGlmIChwcmV2aW91cyAhPT0gdmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRlck1vZGVsID0gcmVmLm1vZGVsLnBhc3MocGFzcywgdHJ1ZSk7XG4gICAgICAgIHNldHRlck1vZGVsLl9kZXJlZmVyZW5jZSA9IG5vb3BEZXJlZmVyZW5jZTtcbiAgICAgICAgc2V0dGVyTW9kZWwuX3NldChyZWYuZnJvbVNlZ21lbnRzLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbk1vZGVsLnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGZyb20sIHRvLCBvcHRpb25zO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHRvID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBpZiAodGhpcy5pc1BhdGgoYXJndW1lbnRzWzFdKSkge1xuICAgICAgZnJvbSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHRvID0gYXJndW1lbnRzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0byA9IGFyZ3VtZW50c1swXTtcbiAgICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZyb20gPSBhcmd1bWVudHNbMF07XG4gICAgdG8gPSBhcmd1bWVudHNbMV07XG4gICAgb3B0aW9ucyA9IGFyZ3VtZW50c1syXTtcbiAgfVxuICB2YXIgZnJvbVBhdGggPSB0aGlzLnBhdGgoZnJvbSk7XG4gIHZhciB0b1BhdGggPSB0aGlzLnBhdGgodG8pO1xuICB2YXIgZnJvbVNlZ21lbnRzID0gZnJvbVBhdGguc3BsaXQoJy4nKTtcbiAgaWYgKGZyb21TZWdtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAncmVmIG11c3QgYmUgcGVyZm9ybWVkIHVuZGVyIGEgY29sbGVjdGlvbiAnICtcbiAgICAgICdhbmQgZG9jdW1lbnQgaWQuIEludmFsaWQgcGF0aDogJyArIGZyb21QYXRoO1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IobWVzc2FnZSkpO1xuICB9XG4gIHRoaXMucm9vdC5fcmVmcy5yZW1vdmUoZnJvbVBhdGgpO1xuICB2YXIgdmFsdWUgPSB0aGlzLmdldCh0byk7XG4gIHRoaXMuX3NldChmcm9tU2VnbWVudHMsIHZhbHVlKTtcbiAgdGhpcy5yb290Ll9yZWZzLmFkZChmcm9tUGF0aCwgdG9QYXRoLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXMuc2NvcGUoZnJvbVBhdGgpO1xufTtcblxuTW9kZWwucHJvdG90eXBlLnJlbW92ZVJlZiA9IGZ1bmN0aW9uKGZyb20pIHtcbiAgdmFyIGZyb21QYXRoID0gdGhpcy5wYXRoKGZyb20pO1xuICB0aGlzLnJvb3QuX3JlZnMucmVtb3ZlKGZyb21QYXRoKTtcbiAgdGhpcy5kZWwoZnJvbSk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUucmVtb3ZlQWxsUmVmcyA9IGZ1bmN0aW9uKHN1YnBhdGgpIHtcbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICB2YXIgcmVmcyA9IHRoaXMucm9vdC5fcmVmcy5mcm9tTWFwO1xuICB2YXIgcmVmTGlzdHMgPSB0aGlzLnJvb3QuX3JlZkxpc3RzLmZyb21NYXA7XG4gIGZvciAodmFyIGZyb20gaW4gcmVmcykge1xuICAgIGlmICh1dGlsLmNvbnRhaW5zKHNlZ21lbnRzLCByZWZzW2Zyb21dLmZyb21TZWdtZW50cykpIHtcbiAgICAgIHRoaXMucmVtb3ZlUmVmKGZyb20pO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBmcm9tIGluIHJlZkxpc3RzKSB7XG4gICAgaWYgKHV0aWwuY29udGFpbnMoc2VnbWVudHMsIHJlZkxpc3RzW2Zyb21dLmZyb21TZWdtZW50cykpIHtcbiAgICAgIHRoaXMucmVtb3ZlUmVmTGlzdChmcm9tKTtcbiAgICB9XG4gIH1cbn07XG5cbk1vZGVsLnByb3RvdHlwZS5kZXJlZmVyZW5jZSA9IGZ1bmN0aW9uKHN1YnBhdGgpIHtcbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fZGVyZWZlcmVuY2Uoc2VnbWVudHMpLmpvaW4oJy4nKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5fZGVyZWZlcmVuY2UgPSBmdW5jdGlvbihzZWdtZW50cywgZm9yQXJyYXlNdXRhdG9yLCBpZ25vcmUpIHtcbiAgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHNlZ21lbnRzO1xuICB2YXIgcmVmcyA9IHRoaXMucm9vdC5fcmVmcy5mcm9tTWFwO1xuICB2YXIgcmVmTGlzdHMgPSB0aGlzLnJvb3QuX3JlZkxpc3RzLmZyb21NYXA7XG4gIGRvIHtcbiAgICB2YXIgc3VicGF0aCA9ICcnO1xuICAgIHZhciBkb0FnYWluID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzdWJwYXRoID0gKHN1YnBhdGgpID8gc3VicGF0aCArICcuJyArIHNlZ21lbnRzW2ldIDogc2VnbWVudHNbaV07XG5cbiAgICAgIHZhciByZWYgPSByZWZzW3N1YnBhdGhdO1xuICAgICAgaWYgKHJlZikge1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gc2VnbWVudHMuc2xpY2UoaSArIDEpO1xuICAgICAgICBzZWdtZW50cyA9IHJlZi50b1NlZ21lbnRzLmNvbmNhdChyZW1haW5pbmcpO1xuICAgICAgICBkb0FnYWluID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWZMaXN0ID0gcmVmTGlzdHNbc3VicGF0aF07XG4gICAgICBpZiAocmVmTGlzdCAmJiByZWZMaXN0ICE9PSBpZ25vcmUpIHtcbiAgICAgICAgdmFyIGJlbG93RGVzY2VuZGFudCA9IGkgKyAyIDwgbGVuO1xuICAgICAgICB2YXIgYmVsb3dDaGlsZCA9IGkgKyAxIDwgbGVuO1xuICAgICAgICBpZiAoIShiZWxvd0Rlc2NlbmRhbnQgfHwgZm9yQXJyYXlNdXRhdG9yICYmIGJlbG93Q2hpbGQpKSBjb250aW51ZTtcbiAgICAgICAgc2VnbWVudHMgPSByZWZMaXN0LmRlcmVmZXJlbmNlKHNlZ21lbnRzLCBpKTtcbiAgICAgICAgZG9BZ2FpbiA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSB3aGlsZSAoZG9BZ2Fpbik7XG4gIC8vIElmIGEgZGVyZWZlcmVuY2UgZmFpbHMsIHJldHVybiBhIHBhdGggdGhhdCB3aWxsIHJlc3VsdCBpbiBhIG51bGwgdmFsdWVcbiAgLy8gaW5zdGVhZCBvZiBhIHBhdGggdG8gZXZlcnl0aGluZyBpbiB0aGUgbW9kZWxcbiAgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFsnJG51bGwnXTtcbiAgcmV0dXJuIHNlZ21lbnRzO1xufTtcblxuZnVuY3Rpb24gbm9vcERlcmVmZXJlbmNlKHNlZ21lbnRzKSB7XG4gIHJldHVybiBzZWdtZW50cztcbn1cblxuZnVuY3Rpb24gUmVmKG1vZGVsLCBmcm9tLCB0bywgb3B0aW9ucykge1xuICB0aGlzLm1vZGVsID0gbW9kZWwgJiYgbW9kZWwucGFzcyh7JHJlZjogdGhpc30pO1xuICB0aGlzLmZyb20gPSBmcm9tO1xuICB0aGlzLnRvID0gdG87XG4gIHRoaXMuZnJvbVNlZ21lbnRzID0gZnJvbS5zcGxpdCgnLicpO1xuICB0aGlzLnRvU2VnbWVudHMgPSB0by5zcGxpdCgnLicpO1xuICB0aGlzLnBhcmVudFRvcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMSwgbGVuID0gdGhpcy50b1NlZ21lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHBhcmVudFRvID0gdGhpcy50b1NlZ21lbnRzLnNsaWNlKDAsIGkpLmpvaW4oJy4nKTtcbiAgICB0aGlzLnBhcmVudFRvcy5wdXNoKHBhcmVudFRvKTtcbiAgfVxuICB0aGlzLnVwZGF0ZUluZGljZXMgPSBvcHRpb25zICYmIG9wdGlvbnMudXBkYXRlSW5kaWNlcztcbn1cbmZ1bmN0aW9uIEZyb21NYXAoKSB7fVxuZnVuY3Rpb24gVG9NYXAoKSB7fVxuXG5mdW5jdGlvbiBSZWZzKG1vZGVsKSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgdGhpcy5mcm9tTWFwID0gbmV3IEZyb21NYXA7XG4gIHRoaXMudG9NYXAgPSBuZXcgVG9NYXA7XG4gIHRoaXMucGFyZW50VG9NYXAgPSBuZXcgVG9NYXA7XG59XG5cblJlZnMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGZyb20sIHRvLCBvcHRpb25zKSB7XG4gIHZhciByZWYgPSBuZXcgUmVmKHRoaXMubW9kZWwsIGZyb20sIHRvLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXMuX2FkZChyZWYpO1xufTtcblxuUmVmcy5wcm90b3R5cGUuX2FkZCA9IGZ1bmN0aW9uKHJlZikge1xuICB0aGlzLmZyb21NYXBbcmVmLmZyb21dID0gcmVmO1xuICBsaXN0TWFwQWRkKHRoaXMudG9NYXAsIHJlZi50bywgcmVmKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJlZi5wYXJlbnRUb3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBsaXN0TWFwQWRkKHRoaXMucGFyZW50VG9NYXAsIHJlZi5wYXJlbnRUb3NbaV0sIHJlZik7XG4gIH1cbiAgcmV0dXJuIHJlZjtcbn07XG5cblJlZnMucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGZyb20pIHtcbiAgdmFyIHJlZiA9IHRoaXMuZnJvbU1hcFtmcm9tXTtcbiAgaWYgKCFyZWYpIHJldHVybjtcbiAgZGVsZXRlIHRoaXMuZnJvbU1hcFtmcm9tXTtcbiAgbGlzdE1hcFJlbW92ZSh0aGlzLnRvTWFwLCByZWYudG8sIHJlZik7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSByZWYucGFyZW50VG9zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbGlzdE1hcFJlbW92ZSh0aGlzLnBhcmVudFRvTWFwLCByZWYucGFyZW50VG9zW2ldLCByZWYpO1xuICB9XG4gIHJldHVybiByZWY7XG59O1xuXG5SZWZzLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgdmFyIG91dCA9IFtdO1xuICBmb3IgKHZhciBmcm9tIGluIHRoaXMuZnJvbU1hcCkge1xuICAgIHZhciByZWYgPSB0aGlzLmZyb21NYXBbZnJvbV07XG4gICAgb3V0LnB1c2goW3JlZi5mcm9tLCByZWYudG9dKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuZnVuY3Rpb24gbGlzdE1hcEFkZChtYXAsIG5hbWUsIGl0ZW0pIHtcbiAgbWFwW25hbWVdIHx8IChtYXBbbmFtZV0gPSBbXSk7XG4gIG1hcFtuYW1lXS5wdXNoKGl0ZW0pO1xufVxuXG5mdW5jdGlvbiBsaXN0TWFwUmVtb3ZlKG1hcCwgbmFtZSwgaXRlbSkge1xuICB2YXIgaXRlbXMgPSBtYXBbbmFtZV07XG4gIGlmICghaXRlbXMpIHJldHVybjtcbiAgdmFyIGluZGV4ID0gaXRlbXMuaW5kZXhPZihpdGVtKTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuO1xuICBpdGVtcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBpZiAoIWl0ZW1zLmxlbmd0aCkgZGVsZXRlIG1hcFtuYW1lXTtcbn1cbiIsInZhciBwdW55Y29kZSA9IHsgZW5jb2RlIDogZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMgfSB9O1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YoYXJyYXksIHN1YmplY3QpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGFycmF5Lmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICBpZihhcnJheVtpXSA9PSBzdWJqZWN0KSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIG9iamVjdEtleXMob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCAhPT0gT2JqZWN0KG9iamVjdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgb2JqZWN0Jyk7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIGtleXNba2V5cy5sZW5ndGhdID0ga2V5O1xuICAgIHJldHVybiBrZXlzO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKyQvLFxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICd+JywgJ1snLCAnXScsICdgJ10uY29uY2F0KGRlbGltcyksXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXVxuICAgICAgLmNvbmNhdCh1bndpc2UpLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBub25BdXRoQ2hhcnMgPSBbJy8nLCAnQCcsICc/JywgJyMnXS5jb25jYXQoZGVsaW1zKSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bYS16QS1aMC05XVthLXowLTlBLVpfLV17MCw2Mn0kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFthLXpBLVowLTldW2EtejAtOUEtWl8tXXswLDYyfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBoYXZlIGEgcGF0aCBjb21wb25lbnQuXG4gICAgcGF0aGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHR5cGVvZih1cmwpID09PSAnb2JqZWN0JyAmJiB1cmwuaHJlZikgcmV0dXJuIHVybDtcblxuICBpZiAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgdmFyIG91dCA9IHt9LFxuICAgICAgcmVzdCA9IHVybDtcblxuICAvLyBjdXQgb2ZmIGFueSBkZWxpbWl0ZXJzLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIjxodHRwOi8vZm9vLmNvbT5cIlxuICBmb3IgKHZhciBpID0gMCwgbCA9IHJlc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGFycmF5SW5kZXhPZihkZWxpbXMsIHJlc3QuY2hhckF0KGkpKSA9PT0gLTEpIGJyZWFrO1xuICB9XG4gIGlmIChpICE9PSAwKSByZXN0ID0gcmVzdC5zdWJzdHIoaSk7XG5cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgb3V0LnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgb3V0LnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy8gZG9uJ3QgZW5mb3JjZSBmdWxsIFJGQyBjb3JyZWN0bmVzcywganVzdCBiZSB1bnN0dXBpZCBhYm91dCBpdC5cblxuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBub24tYXV0aCBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICB2YXIgYXRTaWduID0gYXJyYXlJbmRleE9mKHJlc3QsICdAJyk7XG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIC8vIHRoZXJlICptYXkgYmUqIGFuIGF1dGhcbiAgICAgIHZhciBoYXNBdXRoID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9uQXV0aENoYXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgaW5kZXggPSBhcnJheUluZGV4T2YocmVzdCwgbm9uQXV0aENoYXJzW2ldKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSAmJiBpbmRleCA8IGF0U2lnbikge1xuICAgICAgICAgIC8vIG5vdCBhIHZhbGlkIGF1dGguICBTb21ldGhpbmcgbGlrZSBodHRwOi8vZm9vLmNvbS9iYXJAYmF6L1xuICAgICAgICAgIGhhc0F1dGggPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGhhc0F1dGgpIHtcbiAgICAgICAgLy8gcGx1Y2sgb2ZmIHRoZSBhdXRoIHBvcnRpb24uXG4gICAgICAgIG91dC5hdXRoID0gcmVzdC5zdWJzdHIoMCwgYXRTaWduKTtcbiAgICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKGF0U2lnbiArIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmaXJzdE5vbkhvc3QgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBpbmRleCA9IGFycmF5SW5kZXhPZihyZXN0LCBub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSAmJlxuICAgICAgICAgIChmaXJzdE5vbkhvc3QgPCAwIHx8IGluZGV4IDwgZmlyc3ROb25Ib3N0KSkgZmlyc3ROb25Ib3N0ID0gaW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0Tm9uSG9zdCAhPT0gLTEpIHtcbiAgICAgIG91dC5ob3N0ID0gcmVzdC5zdWJzdHIoMCwgZmlyc3ROb25Ib3N0KTtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cihmaXJzdE5vbkhvc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQuaG9zdCA9IHJlc3Q7XG4gICAgICByZXN0ID0gJyc7XG4gICAgfVxuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB2YXIgcCA9IHBhcnNlSG9zdChvdXQuaG9zdCk7XG4gICAgdmFyIGtleXMgPSBvYmplY3RLZXlzKHApO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgb3V0W2tleV0gPSBwW2tleV07XG4gICAgfVxuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIG91dC5ob3N0bmFtZSA9IG91dC5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmIChvdXQuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIG91dC5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gb3V0Lmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dC5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICBvdXQuaG9zdG5hbWUgPSBvdXQuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnkgY29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHRoZSBwYXJ0IG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgLy8gaGFzIG5vbiBBU0NJSSBjaGFyYWN0ZXJzLiBJLmUuIGl0IGRvc2VudCBtYXR0ZXIgaWZcbiAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBpbiBBU0NJSS5cbiAgICB2YXIgZG9tYWluQXJyYXkgPSBvdXQuaG9zdG5hbWUuc3BsaXQoJy4nKTtcbiAgICB2YXIgbmV3T3V0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb21haW5BcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHMgPSBkb21haW5BcnJheVtpXTtcbiAgICAgIG5ld091dC5wdXNoKHMubWF0Y2goL1teQS1aYS16MC05Xy1dLykgP1xuICAgICAgICAgICd4bi0tJyArIHB1bnljb2RlLmVuY29kZShzKSA6IHMpO1xuICAgIH1cbiAgICBvdXQuaG9zdG5hbWUgPSBuZXdPdXQuam9pbignLicpO1xuXG4gICAgb3V0Lmhvc3QgPSAob3V0Lmhvc3RuYW1lIHx8ICcnKSArXG4gICAgICAgICgob3V0LnBvcnQpID8gJzonICsgb3V0LnBvcnQgOiAnJyk7XG4gICAgb3V0LmhyZWYgKz0gb3V0Lmhvc3Q7XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgbWFrZSBzdXJlIHRoYXQgZGVsaW1zIG5ldmVyIGFwcGVhciBpbiBhIHVybC5cbiAgICB2YXIgY2hvcCA9IHJlc3QubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZGVsaW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGMgPSBhcnJheUluZGV4T2YocmVzdCwgZGVsaW1zW2ldKTtcbiAgICAgIGlmIChjICE9PSAtMSkge1xuICAgICAgICBjaG9wID0gTWF0aC5taW4oYywgY2hvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnN1YnN0cigwLCBjaG9wKTtcbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSBhcnJheUluZGV4T2YocmVzdCwgJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIG91dC5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gYXJyYXlJbmRleE9mKHJlc3QsICc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICBvdXQuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIG91dC5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIG91dC5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKG91dC5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICBvdXQuc2VhcmNoID0gJyc7XG4gICAgb3V0LnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIG91dC5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICBvdXQuaG9zdG5hbWUgJiYgIW91dC5wYXRobmFtZSkge1xuICAgIG91dC5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKG91dC5wYXRobmFtZSB8fCBvdXQuc2VhcmNoKSB7XG4gICAgb3V0LnBhdGggPSAob3V0LnBhdGhuYW1lID8gb3V0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgIChvdXQuc2VhcmNoID8gb3V0LnNlYXJjaCA6ICcnKTtcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICBvdXQuaHJlZiA9IHVybEZvcm1hdChvdXQpO1xuICByZXR1cm4gb3V0O1xufVxuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKHR5cGVvZihvYmopID09PSAnc3RyaW5nJykgb2JqID0gdXJsUGFyc2Uob2JqKTtcblxuICB2YXIgYXV0aCA9IG9iai5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBhdXRoLnNwbGl0KCdAJykuam9pbignJTQwJyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub25BdXRoQ2hhcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgbkFDID0gbm9uQXV0aENoYXJzW2ldO1xuICAgICAgYXV0aCA9IGF1dGguc3BsaXQobkFDKS5qb2luKGVuY29kZVVSSUNvbXBvbmVudChuQUMpKTtcbiAgICB9XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSBvYmoucHJvdG9jb2wgfHwgJycsXG4gICAgICBob3N0ID0gKG9iai5ob3N0ICE9PSB1bmRlZmluZWQpID8gYXV0aCArIG9iai5ob3N0IDpcbiAgICAgICAgICBvYmouaG9zdG5hbWUgIT09IHVuZGVmaW5lZCA/IChcbiAgICAgICAgICAgICAgYXV0aCArIG9iai5ob3N0bmFtZSArXG4gICAgICAgICAgICAgIChvYmoucG9ydCA/ICc6JyArIG9iai5wb3J0IDogJycpXG4gICAgICAgICAgKSA6XG4gICAgICAgICAgZmFsc2UsXG4gICAgICBwYXRobmFtZSA9IG9iai5wYXRobmFtZSB8fCAnJyxcbiAgICAgIHF1ZXJ5ID0gb2JqLnF1ZXJ5ICYmXG4gICAgICAgICAgICAgICgodHlwZW9mIG9iai5xdWVyeSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICBvYmplY3RLZXlzKG9iai5xdWVyeSkubGVuZ3RoKSA/XG4gICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeShvYmoucXVlcnkpIDpcbiAgICAgICAgICAgICAgICAgJycpIHx8ICcnLFxuICAgICAgc2VhcmNoID0gb2JqLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJycsXG4gICAgICBoYXNoID0gb2JqLmhhc2ggfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAob2JqLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufVxuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybEZvcm1hdCh1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpKTtcbn1cblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG5cbiAgc291cmNlID0gdXJsUGFyc2UodXJsRm9ybWF0KHNvdXJjZSksIGZhbHNlLCB0cnVlKTtcbiAgcmVsYXRpdmUgPSB1cmxQYXJzZSh1cmxGb3JtYXQocmVsYXRpdmUpLCBmYWxzZSwgdHJ1ZSk7XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIHNvdXJjZS5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICBzb3VyY2UuaHJlZiA9IHVybEZvcm1hdChzb3VyY2UpO1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgcmVsYXRpdmUucHJvdG9jb2wgPSBzb3VyY2UucHJvdG9jb2w7XG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSAmJlxuICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSAmJiAhcmVsYXRpdmUucGF0aG5hbWUpIHtcbiAgICAgIHJlbGF0aXZlLnBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSA9ICcvJztcbiAgICB9XG4gICAgcmVsYXRpdmUuaHJlZiA9IHVybEZvcm1hdChyZWxhdGl2ZSk7XG4gICAgcmV0dXJuIHJlbGF0aXZlO1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSBzb3VyY2UucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICByZWxhdGl2ZS5ocmVmID0gdXJsRm9ybWF0KHJlbGF0aXZlKTtcbiAgICAgIHJldHVybiByZWxhdGl2ZTtcbiAgICB9XG4gICAgc291cmNlLnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVsYXRpdmUucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9XG4gICAgc291cmNlLnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgc291cmNlLnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICBzb3VyY2UucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzb3VyY2UuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgc291cmNlLmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHNvdXJjZS5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgc291cmNlLnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoc291cmNlLnBhdGhuYW1lICE9PSB1bmRlZmluZWQgfHwgc291cmNlLnNlYXJjaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzb3VyY2UucGF0aCA9IChzb3VyY2UucGF0aG5hbWUgPyBzb3VyY2UucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAoc291cmNlLnNlYXJjaCA/IHNvdXJjZS5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHNvdXJjZS5zbGFzaGVzID0gc291cmNlLnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICBzb3VyY2UuaHJlZiA9IHVybEZvcm1hdChzb3VyY2UpO1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAoc291cmNlLnBhdGhuYW1lICYmIHNvdXJjZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0ICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgKSxcbiAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHNvdXJjZS5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgIHNyY1BhdGggPSBzb3VyY2UucGF0aG5hbWUgJiYgc291cmNlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHBzeWNob3RpYyA9IHNvdXJjZS5wcm90b2NvbCAmJlxuICAgICAgICAgICFzbGFzaGVkUHJvdG9jb2xbc291cmNlLnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyBzb3VyY2UucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuXG4gICAgZGVsZXRlIHNvdXJjZS5ob3N0bmFtZTtcbiAgICBkZWxldGUgc291cmNlLnBvcnQ7XG4gICAgaWYgKHNvdXJjZS5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSBzb3VyY2UuaG9zdDtcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHNvdXJjZS5ob3N0KTtcbiAgICB9XG4gICAgZGVsZXRlIHNvdXJjZS5ob3N0O1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgZGVsZXRlIHJlbGF0aXZlLmhvc3RuYW1lO1xuICAgICAgZGVsZXRlIHJlbGF0aXZlLnBvcnQ7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSByZWxhdGl2ZS5ob3N0O1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICBzb3VyY2UuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHNvdXJjZS5ob3N0O1xuICAgIHNvdXJjZS5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHNvdXJjZS5ob3N0bmFtZTtcbiAgICBzb3VyY2Uuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHNvdXJjZS5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHNvdXJjZS5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgc291cmNlLnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoJ3NlYXJjaCcgaW4gcmVsYXRpdmUpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICBzb3VyY2UuaG9zdG5hbWUgPSBzb3VyY2UuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSBzb3VyY2UuaG9zdCAmJiBhcnJheUluZGV4T2Yoc291cmNlLmhvc3QsICdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgc291cmNlLmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHNvdXJjZS5ob3N0ID0gc291cmNlLmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBzb3VyY2Uuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHNvdXJjZS5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoc291cmNlLnBhdGhuYW1lICE9PSB1bmRlZmluZWQgfHwgc291cmNlLnNlYXJjaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzb3VyY2UucGF0aCA9IChzb3VyY2UucGF0aG5hbWUgPyBzb3VyY2UucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAoc291cmNlLnNlYXJjaCA/IHNvdXJjZS5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHNvdXJjZS5ocmVmID0gdXJsRm9ybWF0KHNvdXJjZSk7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgZGVsZXRlIHNvdXJjZS5wYXRobmFtZTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCFzb3VyY2Uuc2VhcmNoKSB7XG4gICAgICBzb3VyY2UucGF0aCA9ICcvJyArIHNvdXJjZS5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSBzb3VyY2UucGF0aDtcbiAgICB9XG4gICAgc291cmNlLmhyZWYgPSB1cmxGb3JtYXQoc291cmNlKTtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAoc291cmNlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCkgJiYgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fFxuICAgICAgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgc291cmNlLmhvc3RuYW1lID0gc291cmNlLmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gc291cmNlLmhvc3QgJiYgYXJyYXlJbmRleE9mKHNvdXJjZS5ob3N0LCAnQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICBzb3VyY2UuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHNvdXJjZS5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgc291cmNlLmhvc3QgPSBzb3VyY2UuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHNvdXJjZS5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBzb3VyY2UucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoc291cmNlLnBhdGhuYW1lICE9PSB1bmRlZmluZWQgfHwgc291cmNlLnNlYXJjaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc291cmNlLnBhdGggPSAoc291cmNlLnBhdGhuYW1lID8gc291cmNlLnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzb3VyY2Uuc2VhcmNoID8gc291cmNlLnNlYXJjaCA6ICcnKTtcbiAgfVxuICBzb3VyY2UuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgc291cmNlLmF1dGg7XG4gIHNvdXJjZS5zbGFzaGVzID0gc291cmNlLnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgc291cmNlLmhyZWYgPSB1cmxGb3JtYXQoc291cmNlKTtcbiAgcmV0dXJuIHNvdXJjZTtcbn1cblxuZnVuY3Rpb24gcGFyc2VIb3N0KGhvc3QpIHtcbiAgdmFyIG91dCA9IHt9O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgb3V0LnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIG91dC5ob3N0bmFtZSA9IGhvc3Q7XG4gIHJldHVybiBvdXQ7XG59XG4iLCJ2YXIgcmFjZXIgPSByZXF1aXJlKCdyYWNlcicpXG4gICwgZG9tU2hpbSA9IHJlcXVpcmUoJ2RvbS1zaGltJylcbiAgLCBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKCcuL0V2ZW50RGlzcGF0Y2hlcicpXG4gICwgdmlld1BhdGggPSByZXF1aXJlKCcuL3ZpZXdQYXRoJylcbiAgLCBlc2NhcGVIdG1sID0gcmVxdWlyZSgnaHRtbC11dGlsJykuZXNjYXBlSHRtbFxuICAsIHRleHRPdCA9IHJlcXVpcmUoJy4vdGV4dE90JylcbiAgLCBtZXJnZSA9IHJhY2VyLnV0aWwubWVyZ2VcbiAgLCBtYXJrZXJzID0ge31cbiAgLCBtYXJrZXJzRGlydHkgPSB0cnVlXG4gICwgZ2xvYmFsRWxlbWVudHMgPSB7XG4gICAgICAkX3dpbjogd2luZG93XG4gICAgLCAkX2RvYzogZG9jdW1lbnRcbiAgICB9XG4gICwgYWRkTGlzdGVuZXIsIHJlbW92ZUxpc3RlbmVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERvbTtcblxuZnVuY3Rpb24gRG9tKG1vZGVsKSB7XG4gIHZhciBkb20gPSB0aGlzXG4gIHZhciBmbnMgPSB0aGlzLmZuc1xuXG4gIC8vIE1hcCBkb20gZXZlbnQgbmFtZSAtPiB0cnVlXG4gIHZhciBsaXN0ZW5lckFkZGVkID0ge307XG4gIHZhciBjYXB0dXJlTGlzdGVuZXJBZGRlZCA9IHt9XG5cbiAgLy8gRE9NIGxpc3RlbmVyIGNhcHR1cmluZyBhbGxvd3MgYmx1ciBhbmQgZm9jdXMgdG8gYmUgZGVsZWdhdGVkXG4gIC8vIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDA4LzA0L2RlbGVnYXRpbmdfdGhlLmh0bWxcbiAgdmFyIGNhcHR1cmVFdmVudHMgPSB0aGlzLl9jYXB0dXJlRXZlbnRzID0gbmV3IEV2ZW50RGlzcGF0Y2hlcih7XG4gICAgb25UcmlnZ2VyOiBvbkNhcHR1cmVUcmlnZ2VyXG4gICwgb25CaW5kOiBvbkNhcHR1cmVCaW5kXG4gIH0pO1xuICBmdW5jdGlvbiBvbkNhcHR1cmVUcmlnZ2VyKG5hbWUsIGxpc3RlbmVyLCBlKSB7XG4gICAgdmFyIGlkID0gbGlzdGVuZXIuaWRcbiAgICAgICwgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG5cbiAgICAvLyBSZW1vdmUgbGlzdGVuZXIgaWYgZWxlbWVudCBpc24ndCBmb3VuZFxuICAgIGlmICghZWwpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChlbC50YWdOYW1lID09PSAnSFRNTCcgfHwgZWwuY29udGFpbnMoZS50YXJnZXQpKSB7XG4gICAgICBvbkRvbVRyaWdnZXIobmFtZSwgbGlzdGVuZXIsIGlkLCBlLCBlbCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG9uQ2FwdHVyZUJpbmQobmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoY2FwdHVyZUxpc3RlbmVyQWRkZWRbbmFtZV0pIHJldHVybjtcbiAgICBhZGRMaXN0ZW5lcihkb2N1bWVudCwgbmFtZSwgY2FwdHVyZVRyaWdnZXIsIHRydWUpO1xuICAgIGNhcHR1cmVMaXN0ZW5lckFkZGVkW25hbWVdID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnREaXNwYXRjaGVyKHtcbiAgICBvblRyaWdnZXI6IG9uRG9tVHJpZ2dlclxuICAsIG9uQmluZDogb25Eb21CaW5kXG4gIH0pO1xuICBmdW5jdGlvbiBvbkRvbVRyaWdnZXIobmFtZSwgbGlzdGVuZXIsIGlkLCBlLCBlbCwgbmV4dCkge1xuICAgIHZhciBkZWxheSA9IGxpc3RlbmVyLmRlbGF5XG4gICAgICAsIGZpbmlzaCA9IGxpc3RlbmVyLmZuO1xuXG4gICAgZS5wYXRoID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgaWYgKCFuYW1lKSByZXR1cm4gbW9kZWwuX19wYXRoTWFwLnBhdGhzW2xpc3RlbmVyLnBhdGhJZF07XG4gICAgICByZXR1cm4gdmlld1BhdGguY3R4UGF0aChsaXN0ZW5lci52aWV3LCBsaXN0ZW5lci5jdHgsIG5hbWUpO1xuICAgIH07XG4gICAgZS5nZXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgcGF0aCA9IGUucGF0aChuYW1lKTtcbiAgICAgIHJldHVybiB2aWV3UGF0aC5kYXRhVmFsdWUobGlzdGVuZXIudmlldywgbGlzdGVuZXIuY3R4LCBtb2RlbCwgcGF0aCk7XG4gICAgfTtcbiAgICBlLmF0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgcmV0dXJuIG1vZGVsLmF0KGUucGF0aChuYW1lKSk7XG4gICAgfTtcblxuICAgIGlmICghZmluaXNoKSB7XG4gICAgICAvLyBVcGRhdGUgdGhlIG1vZGVsIHdoZW4gdGhlIGVsZW1lbnQncyB2YWx1ZSBjaGFuZ2VzXG4gICAgICBmaW5pc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZG9tLmdldE1ldGhvZHNbbGlzdGVuZXIubWV0aG9kXShlbCwgbGlzdGVuZXIucHJvcGVydHkpXG4gICAgICAgICAgLCBzZXRWYWx1ZSA9IGxpc3RlbmVyLnNldFZhbHVlO1xuXG4gICAgICAgIC8vIEFsbG93IHRoZSBsaXN0ZW5lciB0byBvdmVycmlkZSB0aGUgc2V0dGluZyBmdW5jdGlvblxuICAgICAgICBpZiAoc2V0VmFsdWUpIHtcbiAgICAgICAgICBzZXRWYWx1ZShtb2RlbCwgdmFsdWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSB0aGlzIGxpc3RlbmVyIGlmIGl0cyBwYXRoIGlkIGlzIG5vIGxvbmdlciByZWdpc3RlcmVkXG4gICAgICAgIHZhciBwYXRoID0gbW9kZWwuX19wYXRoTWFwLnBhdGhzW2xpc3RlbmVyLnBhdGhJZF07XG4gICAgICAgIGlmICghcGF0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIC8vIFNldCB0aGUgdmFsdWUgaWYgY2hhbmdlZFxuICAgICAgICBpZiAobW9kZWwuZ2V0KHBhdGgpID09PSB2YWx1ZSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBzZXR0ZXJNb2RlbCA9IG1vZGVsLnBhc3MoeyRlOiBlLCAkZWw6IGVsfSk7XG4gICAgICAgIGlmIChsaXN0ZW5lci5tZXRob2QgPT09ICdwcm9wT3QnKSB7XG4gICAgICAgICAgcmV0dXJuIHRleHRPdC5vblRleHRJbnB1dChzZXR0ZXJNb2RlbCwgcGF0aCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHNldHRlck1vZGVsLnNldChwYXRoLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRlbGF5ICE9IG51bGwpIHtcbiAgICAgIHNldFRpbWVvdXQoZmluaXNoLCBkZWxheSwgZSwgZWwsIG5leHQsIGRvbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbmlzaChlLCBlbCwgbmV4dCwgZG9tKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25Eb21CaW5kKG5hbWUsIGxpc3RlbmVyLCBldmVudE5hbWUpIHtcbiAgICBpZiAobGlzdGVuZXJBZGRlZFtldmVudE5hbWVdKSByZXR1cm47XG4gICAgYWRkTGlzdGVuZXIoZG9jdW1lbnQsIGV2ZW50TmFtZSwgdHJpZ2dlckRvbSwgdHJ1ZSk7XG4gICAgbGlzdGVuZXJBZGRlZFtldmVudE5hbWVdID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyaWdnZXJEb20oZSwgZWwsIG5vQnViYmxlLCBjb250aW51ZWQpIHtcbiAgICBpZiAoIWVsKSBlbCA9IGUudGFyZ2V0O1xuICAgIHZhciBwcmVmaXggPSBlLnR5cGUgKyAnOidcbiAgICAgICwgaWQ7XG5cbiAgICAvLyBOZXh0IGNhbiBiZSBjYWxsZWQgZnJvbSBhIGxpc3RlbmVyIHRvIGNvbnRpbnVlIGJ1YmJsaW5nXG4gICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHRyaWdnZXJEb20oZSwgZWwucGFyZW50Tm9kZSwgZmFsc2UsIHRydWUpO1xuICAgIH1cbiAgICBuZXh0LmZpcnN0VHJpZ2dlciA9ICFjb250aW51ZWQ7XG4gICAgaWYgKG5vQnViYmxlICYmIChpZCA9IGVsLmlkKSkge1xuICAgICAgcmV0dXJuIGV2ZW50cy50cmlnZ2VyKHByZWZpeCArIGlkLCBpZCwgZSwgZWwsIG5leHQpO1xuICAgIH1cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgd2hpbGUgKCEoaWQgPSBlbC5pZCkpIHtcbiAgICAgICAgaWYgKCEoZWwgPSBlbC5wYXJlbnROb2RlKSkgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gU3RvcCBidWJibGluZyBvbmNlIHRoZSBldmVudCBpcyBoYW5kbGVkXG4gICAgICBpZiAoZXZlbnRzLnRyaWdnZXIocHJlZml4ICsgaWQsIGlkLCBlLCBlbCwgbmV4dCkpIHJldHVybjtcbiAgICAgIGlmICghKGVsID0gZWwucGFyZW50Tm9kZSkpIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjYXB0dXJlVHJpZ2dlcihlKSB7XG4gICAgY2FwdHVyZUV2ZW50cy50cmlnZ2VyKGUudHlwZSwgZSk7XG4gIH1cblxuICB0aGlzLnRyaWdnZXIgPSB0cmlnZ2VyRG9tO1xuICB0aGlzLmNhcHR1cmVUcmlnZ2VyID0gY2FwdHVyZVRyaWdnZXI7XG5cbiAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gIHRoaXMuX2NvbXBvbmVudHMgPSBbXTtcbiAgdGhpcy5fcGVuZGluZ1VwZGF0ZXMgPSBbXTtcblxuICBmdW5jdGlvbiBjb21wb25lbnRDbGVhbnVwKCkge1xuICAgIHZhciBjb21wb25lbnRzID0gZG9tLl9jb21wb25lbnRzXG4gICAgICAsIG1hcCA9IGdldE1hcmtlcnMoKVxuICAgICAgLCBpLCBjb21wb25lbnRcbiAgICBmb3IgKGkgPSBjb21wb25lbnRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcbiAgICAgIGlmIChjb21wb25lbnQgJiYgIWdldE1hcmtlcihtYXAsIGNvbXBvbmVudC5zY29wZSkpIHtcbiAgICAgICAgY29tcG9uZW50LmVtaXQoJ2Rlc3Ryb3knKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gVE9ETyBUaGlzICdjbGVhbnVwJyBldmVudCBpcyBuZXZlciBlbWl0dGVkOyBkZWFsIHdpdGggbGF0ZXJcbiAgLy8gVGhpcyBjbGVhbnVwIGxpc3RlbmVycyBpcyBwbGFjZWQgYXQgdGhlIGJlZ2lubmluZyBzbyB0aGF0IGNvbXBvbmVudFxuICAvLyBzY29wZXMgYXJlIGNsZWFyZWQgYmVmb3JlIGFueSByZWYgY2xlYW51cHMgYXJlIGNoZWNrZWRcbiAgbW9kZWwubGlzdGVuZXJzKCdjbGVhbnVwJykudW5zaGlmdChjb21wb25lbnRDbGVhbnVwKTtcbn1cblxuRG9tLnByb3RvdHlwZSA9IHtcbiAgY2xlYXI6IGRvbUNsZWFyXG4sIGJpbmQ6IGRvbUJpbmRcbiwgaXRlbTogZG9tSXRlbVxuLCBtYXJrZXI6IGRvbU1hcmtlclxuLCB1cGRhdGU6IGRvbVVwZGF0ZVxuLCBhZGRMaXN0ZW5lcjogZG9tQWRkTGlzdGVuZXJcbiwgcmVtb3ZlTGlzdGVuZXI6IGRvbVJlbW92ZUxpc3RlbmVyXG4sIGFkZENvbXBvbmVudDogYWRkQ29tcG9uZW50XG4sIF9zZXREaXJ0eTogc2V0RGlydHlcblxuLCBnZXRNZXRob2RzOiB7XG4gICAgYXR0cjogZ2V0QXR0clxuICAsIHByb3A6IGdldFByb3BcbiAgLCBwcm9wT3Q6IGdldFByb3BPdFxuICAsIHN0cmluZ0luc2VydDogZ2V0UHJvcE90XG4gICwgc3RyaW5nUmVtb3ZlOiBnZXRQcm9wT3RcbiAgLCBodG1sOiBnZXRIdG1sXG4gICAgLy8gVGhlc2UgbWV0aG9kcyByZXR1cm4gTmFOLCBiZWNhdXNlIGl0IG5ldmVyIGVxdWFscyBhbnl0aGluZyBlbHNlLiBUaHVzLFxuICAgIC8vIHdoZW4gY29tcGFyZWQgYWdhaW5zdCB0aGUgbmV3IHZhbHVlLCB0aGUgbmV3IHZhbHVlIHdpbGwgYWx3YXlzIGJlIHNldFxuICAsIGluc2VydDogZ2V0TmFOXG4gICwgcmVtb3ZlOiBnZXROYU5cbiAgLCBtb3ZlOiBnZXROYU5cbiAgfVxuXG4sIHNldE1ldGhvZHM6IHtcbiAgICBhdHRyOiBzZXRBdHRyXG4gICwgcHJvcDogc2V0UHJvcFxuICAsIHByb3BPdDogc2V0UHJvcE90XG4gICwgc3RyaW5nSW5zZXJ0OiBzZXRTdHJpbmdJbnNlcnRcbiAgLCBzdHJpbmdSZW1vdmU6IHNldFN0cmluZ1JlbW92ZVxuICAsIGh0bWw6IHNldEh0bWxcbiAgLCBpbnNlcnQ6IHNldEluc2VydFxuICAsIHJlbW92ZTogc2V0UmVtb3ZlXG4gICwgbW92ZTogc2V0TW92ZVxuICB9XG5cbiwgZm5zOiB7XG4gICAgJGZvckNoaWxkcmVuOiBmb3JDaGlsZHJlblxuICAsICRmb3JOYW1lOiBmb3JOYW1lXG4gIH1cbn1cblxuZnVuY3Rpb24gZG9tQ2xlYXIoKSB7XG4gIHRoaXMuX2V2ZW50cy5jbGVhcigpO1xuICB0aGlzLl9jYXB0dXJlRXZlbnRzLmNsZWFyKCk7XG4gIHZhciBjb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50c1xuICAgICwgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzXG4gICAgLCBpLCBjb21wb25lbnRcbiAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aDsgaS0tOykge1xuICAgIHJlbW92ZUxpc3RlbmVyLmFwcGx5KG51bGwsIGxpc3RlbmVyc1tpXSk7XG4gIH1cbiAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gIGZvciAoaSA9IGNvbXBvbmVudHMubGVuZ3RoOyBpLS07KSB7XG4gICAgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcbiAgICBjb21wb25lbnQgJiYgY29tcG9uZW50LmVtaXQoJ2Rlc3Ryb3knKTtcbiAgfVxuICB0aGlzLl9jb21wb25lbnRzID0gW107XG4gIG1hcmtlcnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gZG9tTGlzdGVuZXJIYXNoKCkge1xuICB2YXIgb3V0ID0ge31cbiAgICAsIGtleVxuICBmb3IgKGtleSBpbiB0aGlzKSB7XG4gICAgaWYgKGtleSA9PT0gJ3ZpZXcnIHx8IGtleSA9PT0gJ2N0eCcgfHwga2V5ID09PSAncGF0aElkJykgY29udGludWU7XG4gICAgb3V0W2tleV0gPSB0aGlzW2tleV07XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gZG9tQmluZChldmVudE5hbWUsIGlkLCBsaXN0ZW5lcikge1xuICBsaXN0ZW5lci50b0pTT04gPSBkb21MaXN0ZW5lckhhc2g7XG4gIGlmIChsaXN0ZW5lci5jYXB0dXJlKSB7XG4gICAgbGlzdGVuZXIuaWQgPSBpZDtcbiAgICB0aGlzLl9jYXB0dXJlRXZlbnRzLmJpbmQoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZXZlbnRzLmJpbmQoXCJcIiArIGV2ZW50TmFtZSArIFwiOlwiICsgaWQsIGxpc3RlbmVyLCBldmVudE5hbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRvbUl0ZW0oaWQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSB8fCBnbG9iYWxFbGVtZW50c1tpZF0gfHwgZ2V0UmFuZ2UoaWQpO1xufVxuXG4vLyBIQUNLOiBDcmFwcHkgaW50ZXJmYWNlLiBTaG91bGQgcmVmYWN0b3IgbWFya2VyIGdldHRpbmcgdG8gYmUgYSBwcm90b3R5cGVcbi8vIG1ldGhvZCBhbmQgbWFrZSBkaXJ0eSBhIHByb3BlcnR5IG9mIGRvbSBpbnN0YW5jZVxuZnVuY3Rpb24gc2V0RGlydHkodmFsdWUpIHtcbiAgbWFya2Vyc0RpcnR5ID0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGRvbVVwZGF0ZShlbCwgbWV0aG9kLCBpZ25vcmUsIHZhbHVlLCBwcm9wZXJ0eSwgaW5kZXgsIGFyZykge1xuICAvLyBXcmFwcGVkIGluIGEgdHJ5IC8gY2F0Y2ggc28gdGhhdCBlcnJvcnMgdGhyb3duIG9uIERPTSB1cGRhdGVzIGRvbid0XG4gIC8vIHN0b3Agc3Vic2VxdWVudCBjb2RlIGZyb20gcnVubmluZ1xuICB0cnkge1xuICAgIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIHRoZSBlbGVtZW50IGlzIGFscmVhZHkgdXAgdG8gZGF0ZVxuICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5nZXRNZXRob2RzW21ldGhvZF0oZWwsIHByb3BlcnR5KSkgcmV0dXJuO1xuICAgIHRoaXMuc2V0TWV0aG9kc1ttZXRob2RdKGVsLCBpZ25vcmUsIHZhbHVlLCBwcm9wZXJ0eSwgaW5kZXgsIGFyZyk7XG4gICAgbWFya2Vyc0RpcnR5ID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9LCAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkb21BZGRMaXN0ZW5lcihlbCwgbmFtZSwgY2FsbGJhY2ssIGNhcHR1cmVzKSB7XG4gIHRoaXMuX2xpc3RlbmVycy5wdXNoKFtlbCwgbmFtZSwgY2FsbGJhY2ssIGNhcHR1cmVzXSk7XG4gIGFkZExpc3RlbmVyKGVsLCBuYW1lLCBjYWxsYmFjaywgY2FwdHVyZXMpO1xufVxuZnVuY3Rpb24gZG9tUmVtb3ZlTGlzdGVuZXIoZWwsIG5hbWUsIGNhbGxiYWNrLCBjYXB0dXJlcykge1xuICByZW1vdmVMaXN0ZW5lcihlbCwgbmFtZSwgY2FsbGJhY2ssIGNhcHR1cmVzKTtcbn1cblxuZnVuY3Rpb24gYWRkQ29tcG9uZW50KGN0eCwgY29tcG9uZW50KSB7XG4gIHZhciBjb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50c1xuICAgICwgZG9tID0gY29tcG9uZW50LmRvbSA9IE9iamVjdC5jcmVhdGUodGhpcyk7XG5cbiAgY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gIGNvbXBvbmVudC5vbignZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbmRleCA9IGNvbXBvbmVudHMuaW5kZXhPZihjb21wb25lbnQpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHJldHVybjtcbiAgICAvLyBUaGUgY29tcG9uZW50cyBhcnJheSBnZXRzIHJlcGxhY2VkIG9uIGEgZG9tLmNsZWFyLCBzbyB3ZSBhbGxvd1xuICAgIC8vIGl0IHRvIGdldCBzcGFyc2UgYXMgaW5kaXZpZHVhbCBjb21wb25lbnRzIGFyZSBkZXN0cm95ZWRcbiAgICBkZWxldGUgY29tcG9uZW50c1tpbmRleF07XG4gIH0pO1xuXG4gIGRvbS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKGVsLCBuYW1lLCBjYWxsYmFjaywgY2FwdHVyZXMpIHtcbiAgICBjb21wb25lbnQub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGVsLCBuYW1lLCBjYWxsYmFjaywgY2FwdHVyZXMpO1xuICAgIH0pO1xuICAgIGFkZExpc3RlbmVyKGVsLCBuYW1lLCBjYWxsYmFjaywgY2FwdHVyZXMpO1xuICB9O1xuXG4gIGRvbS5lbGVtZW50ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBpZCA9IGN0eC4kZWxlbWVudHNbbmFtZV07XG4gICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgfTtcblxuICByZXR1cm4gZG9tO1xufVxuXG5cbmZ1bmN0aW9uIGdldEF0dHIoZWwsIGF0dHIpIHtcbiAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUoYXR0cik7XG59XG5mdW5jdGlvbiBnZXRQcm9wKGVsLCBwcm9wKSB7XG4gIHJldHVybiBlbFtwcm9wXTtcbn1cbmZ1bmN0aW9uIGdldFByb3BPdChlbCwgcHJvcCkge1xuICAvLyBJRSBhbmQgT3BlcmEgcmVwbGFjZSBcXG4gd2l0aCBcXHJcXG5cbiAgdmFyIHZhbHVlID0gZWxbcHJvcF07XG4gIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5yZXBsYWNlICYmIHZhbHVlLnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJyk7XG59XG5mdW5jdGlvbiBnZXRIdG1sKGVsKSB7XG4gIHJldHVybiBlbC5pbm5lckhUTUw7XG59XG5mdW5jdGlvbiBnZXROYU4oKSB7XG4gIHJldHVybiBOYU47XG59XG5cbmZ1bmN0aW9uIHNldEF0dHIoZWwsIGlnbm9yZSwgdmFsdWUsIGF0dHIpIHtcbiAgZWwuc2V0QXR0cmlidXRlICYmIGVsLnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBzZXRQcm9wKGVsLCBpZ25vcmUsIHZhbHVlLCBwcm9wKSB7XG4gIGVsW3Byb3BdID0gdmFsdWU7XG59XG5mdW5jdGlvbiBzZXRQcm9wT3QoZWwsIGlnbm9yZSwgdmFsdWUsIHByb3ApIHtcbiAgZWxbcHJvcF0gPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNldFN0cmluZ0luc2VydChlbCwgaWdub3JlLCB2YWx1ZSwgcHJvcCwgaW5kZXgsIHRleHQpIHtcbiAgdmFyIHByZXZpb3VzID0gZ2V0UHJvcE90KGVsLCBwcm9wKTtcbiAgdGV4dE90Lm9uU3RyaW5nSW5zZXJ0KGVsLCBwcmV2aW91cywgaW5kZXgsIHRleHQpO1xufVxuZnVuY3Rpb24gc2V0U3RyaW5nUmVtb3ZlKGVsLCBpZ25vcmUsIHZhbHVlLCBwcm9wLCBpbmRleCwgaG93TWFueSkge1xuICB2YXIgcHJldmlvdXMgPSBnZXRQcm9wT3QoZWwsIHByb3ApO1xuICB0ZXh0T3Qub25TdHJpbmdSZW1vdmUoZWwsIHByZXZpb3VzLCBpbmRleCwgaG93TWFueSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VTVkdGcmFnbWVudChmcmFnbWVudCwgc3ZnRWxlbWVudCkge1xuICAvLyBUT0RPOiBBbGxvdyBvcHRpb25hbCBuYW1lc3BhY2UgZGVjbGFyYXRpb25zXG4gIHZhciBwcmUgPSAnPHN2ZyB4bWxucz1odHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyB4bWxuczp4bGluaz1odHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rPicgXG4gICAgLCBwb3N0ID0gJzwvc3ZnPidcbiAgICAsIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKVxuICByYW5nZS5zZWxlY3ROb2RlKHN2Z0VsZW1lbnQpO1xuICByZXR1cm4gcmFuZ2UuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KHByZSArIGZyYWdtZW50ICsgcG9zdCk7XG59XG5mdW5jdGlvbiBhcHBlbmRTVkcoZWxlbWVudCwgZnJhZ21lbnQsIHN2Z0VsZW1lbnQpIHtcbiAgdmFyIGZyYWcgPSBtYWtlU1ZHRnJhZ21lbnQoZnJhZ21lbnQsIHN2Z0VsZW1lbnQpXG4gICAgLCBjaGlsZHJlbiA9IGZyYWcuY2hpbGROb2Rlc1swXS5jaGlsZE5vZGVzXG4gICAgLCBpXG4gIGZvciAoaSA9IGNoaWxkcmVuLmxlbmd0aDsgaS0tOykge1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoY2hpbGRyZW5bMF0pO1xuICB9XG59XG5mdW5jdGlvbiBpbnNlcnRCZWZvcmVTVkcoZWxlbWVudCwgZnJhZ21lbnQsIHN2Z0VsZW1lbnQpIHtcbiAgdmFyIGZyYWcgPSBtYWtlU1ZHRnJhZ21lbnQoZnJhZ21lbnQsIHN2Z0VsZW1lbnQpXG4gICAgLCBjaGlsZHJlbiA9IGZyYWcuY2hpbGROb2Rlc1swXS5jaGlsZE5vZGVzXG4gICAgLCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGVcbiAgICAsIGlcbiAgZm9yIChpID0gY2hpbGRyZW4ubGVuZ3RoOyBpLS07KSB7XG4gICAgcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZHJlblswXSwgZWxlbWVudCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkcmVuKGVsZW1lbnQpIHtcbiAgdmFyIGNoaWxkcmVuID0gZWxlbWVudC5jaGlsZE5vZGVzXG4gICAgLCBpXG4gIGZvciAoaSA9IGNoaWxkcmVuLmxlbmd0aDsgaS0tOykge1xuICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGRyZW5bMF0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzU1ZHKG9iaikge1xuICByZXR1cm4gISFvYmoub3duZXJTVkdFbGVtZW50IHx8IG9iai50YWdOYW1lID09PSBcInN2Z1wiO1xufVxuZnVuY3Rpb24gc3ZnUm9vdChvYmopIHtcbiAgcmV0dXJuIG9iai5vd25lclNWR0VsZW1lbnQgfHwgb2JqO1xufVxuZnVuY3Rpb24gaXNSYW5nZShvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNsb25lUmFuZ2U7XG59XG5cbmZ1bmN0aW9uIHNldEh0bWwob2JqLCBpZ25vcmUsIHZhbHVlLCBlc2NhcGUpIHtcbiAgaWYgKGVzY2FwZSkgdmFsdWUgPSBlc2NhcGVIdG1sKHZhbHVlKTtcbiAgaWYoaXNSYW5nZShvYmopKSB7XG4gICAgaWYoaXNTVkcob2JqLnN0YXJ0Q29udGFpbmVyKSkge1xuICAgICAgLy8gU1ZHIEVsZW1lbnRcbiAgICAgIG9iai5kZWxldGVDb250ZW50cygpO1xuICAgICAgdmFyIHN2Z0VsZW1lbnQgPSBzdmdSb290KG9iai5zdGFydENvbnRhaW5lcik7XG4gICAgICBvYmouaW5zZXJ0Tm9kZShtYWtlU1ZHRnJhZ21lbnQodmFsdWUsIHN2Z0VsZW1lbnQpKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmFuZ2VcbiAgICAgIG9iai5kZWxldGVDb250ZW50cygpO1xuICAgICAgb2JqLmluc2VydE5vZGUob2JqLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCh2YWx1ZSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBpZiAoaXNTVkcob2JqKSkge1xuICAgIC8vIFNWRyBFbGVtZW50XG4gICAgdmFyIHN2Z0VsZW1lbnQgPSBzdmdSb290KG9iaik7XG4gICAgcmVtb3ZlQ2hpbGRyZW4ob2JqKTtcbiAgICBhcHBlbmRTVkcob2JqLCB2YWx1ZSwgc3ZnRWxlbWVudCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIEhUTUwgRWxlbWVudFxuICBpZiAoaWdub3JlICYmIG9iai5pZCA9PT0gaWdub3JlKSByZXR1cm47XG4gIG9iai5pbm5lckhUTUwgPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNldEluc2VydChvYmosIGlnbm9yZSwgdmFsdWUsIGVzY2FwZSwgaW5kZXgpIHtcbiAgaWYgKGVzY2FwZSkgdmFsdWUgPSBlc2NhcGVIdG1sKHZhbHVlKTtcbiAgaWYgKG9iai5ub2RlVHlwZSkge1xuICAgIC8vIEVsZW1lbnRcbiAgICBpZiAocmVmID0gb2JqLmNoaWxkTm9kZXNbaW5kZXhdKSB7XG4gICAgICBpZiAoaXNTVkcob2JqKSkge1xuICAgICAgICB2YXIgc3ZnRWxlbWVudCA9IG9iai5vd25lclNWR0VsZW1lbnQgfHwgb2JqO1xuICAgICAgICBpbnNlcnRCZWZvcmVTVkcocmVmLCB2YWx1ZSwgc3ZnRWxlbWVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMob2JqKTtcbiAgICAgIG9iai5pbnNlcnRCZWZvcmUocmFuZ2UuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KHZhbHVlKSwgcmVmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzU1ZHKG9iaikpIHtcbiAgICAgICAgdmFyIHN2Z0VsZW1lbnQgPSBvYmoub3duZXJTVkdFbGVtZW50IHx8IG9iajtcbiAgICAgICAgYXBwZW5kU1ZHKG9iaiwgdmFsdWUsIHN2Z0VsZW1lbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG9iaik7XG4gICAgICBvYmouYXBwZW5kQ2hpbGQocmFuZ2UuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KHZhbHVlKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFJhbmdlXG4gICAgaWYgKGlzU1ZHKG9iai5zdGFydENvbnRhaW5lcikpIHtcbiAgICAgIHZhciBlbCA9IG9iai5zdGFydENvbnRhaW5lclxuICAgICAgLCByZWYgPSBlbC5jaGlsZE5vZGVzW29iai5zdGFydE9mZnNldCArIGluZGV4XTtcbiAgICAgIHZhciBzdmdFbGVtZW50ID0gc3ZnUm9vdChyZWYpO1xuICAgICAgZWwuaW5zZXJ0QmVmb3JlKG1ha2VTVkdGcmFnbWVudCh2YWx1ZSwgc3ZnRWxlbWVudCksIHJlZilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVsID0gb2JqLnN0YXJ0Q29udGFpbmVyXG4gICAgICAgICwgcmVmID0gZWwuY2hpbGROb2Rlc1tvYmouc3RhcnRPZmZzZXQgKyBpbmRleF07XG4gICAgICBlbC5pbnNlcnRCZWZvcmUob2JqLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCh2YWx1ZSksIHJlZik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRSZW1vdmUoZWwsIGlnbm9yZSwgaW5kZXgpIHtcbiAgaWYgKCFlbC5ub2RlVHlwZSkge1xuICAgIC8vIFJhbmdlXG4gICAgaW5kZXggKz0gZWwuc3RhcnRPZmZzZXQ7XG4gICAgZWwgPSBlbC5zdGFydENvbnRhaW5lcjtcbiAgfVxuICB2YXIgY2hpbGQgPSBlbC5jaGlsZE5vZGVzW2luZGV4XTtcbiAgaWYgKGNoaWxkKSBlbC5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5mdW5jdGlvbiBzZXRNb3ZlKGVsLCBpZ25vcmUsIGZyb20sIHByb3BlcnR5LCB0bywgaG93TWFueSkge1xuICB2YXIgY2hpbGQsIGZyYWdtZW50LCBuZXh0Q2hpbGQsIG9mZnNldCwgcmVmLCB0b0VsO1xuICBpZiAoIWVsLm5vZGVUeXBlKSB7XG4gICAgb2Zmc2V0ID0gZWwuc3RhcnRPZmZzZXQ7XG4gICAgZnJvbSArPSBvZmZzZXQ7XG4gICAgdG8gKz0gb2Zmc2V0O1xuICAgIGVsID0gZWwuc3RhcnRDb250YWluZXI7XG4gIH1cbiAgY2hpbGQgPSBlbC5jaGlsZE5vZGVzW2Zyb21dO1xuXG4gIC8vIERvbid0IG1vdmUgaWYgdGhlIGl0ZW0gYXQgdGhlIGRlc3RpbmF0aW9uIGlzIHBhc3NlZCBhcyB0aGUgaWdub3JlXG4gIC8vIG9wdGlvbiwgc2luY2UgdGhpcyBpbmRpY2F0ZXMgdGhlIGludGVuZGVkIGl0ZW0gd2FzIGFscmVhZHkgbW92ZWRcbiAgLy8gQWxzbyBkb24ndCBtb3ZlIGlmIHRoZSBjaGlsZCB0byBtb3ZlIG1hdGNoZXMgdGhlIGlnbm9yZSBvcHRpb25cbiAgaWYgKCFjaGlsZCB8fCBpZ25vcmUgJiYgKHRvRWwgPSBlbC5jaGlsZE5vZGVzW3RvXSkgJiZcbiAgICAgIHRvRWwuaWQgPT09IGlnbm9yZSB8fCBjaGlsZC5pZCA9PT0gaWdub3JlKSByZXR1cm47XG5cbiAgcmVmID0gZWwuY2hpbGROb2Rlc1t0byA+IGZyb20gPyB0byArIGhvd01hbnkgOiB0b107XG4gIGlmIChob3dNYW55ID4gMSkge1xuICAgIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIHdoaWxlIChob3dNYW55LS0pIHtcbiAgICAgIG5leHRDaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgaWYgKCEoY2hpbGQgPSBuZXh0Q2hpbGQpKSBicmVhaztcbiAgICB9XG4gICAgZWwuaW5zZXJ0QmVmb3JlKGZyYWdtZW50LCByZWYpO1xuICAgIHJldHVybjtcbiAgfVxuICBlbC5pbnNlcnRCZWZvcmUoY2hpbGQsIHJlZik7XG59XG5cbmZ1bmN0aW9uIGZvckNoaWxkcmVuKGUsIGVsLCBuZXh0LCBkb20pIHtcbiAgLy8gUHJldmVudCBpbmZpbnRlIGVtaXNzaW9uXG4gIGlmICghbmV4dC5maXJzdFRyaWdnZXIpIHJldHVybjtcblxuICAvLyBSZS10cmlnZ2VyIHRoZSBldmVudCBvbiBhbGwgY2hpbGQgZWxlbWVudHNcbiAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGROb2RlcztcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aCwgY2hpbGQ7IGkgPCBsZW47IGkrKykge1xuICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGNoaWxkLm5vZGVUeXBlICE9PSAxKSBjb250aW51ZTsgIC8vIE5vZGUuRUxFTUVOVF9OT0RFXG4gICAgZG9tLnRyaWdnZXIoZSwgY2hpbGQsIHRydWUsIHRydWUpO1xuICAgIGZvckNoaWxkcmVuKGUsIGNoaWxkLCBuZXh0LCBkb20pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvck5hbWUoZSwgZWwsIG5leHQsIGRvbSkge1xuICAvLyBQcmV2ZW50IGluZmludGUgZW1pc3Npb25cbiAgaWYgKCFuZXh0LmZpcnN0VHJpZ2dlcikgcmV0dXJuO1xuXG4gIHZhciBuYW1lID0gZWwuZ2V0QXR0cmlidXRlKCduYW1lJyk7XG4gIGlmICghbmFtZSkgcmV0dXJuO1xuXG4gIC8vIFJlLXRyaWdnZXIgdGhlIGV2ZW50IG9uIGFsbCBvdGhlciBlbGVtZW50cyB3aXRoXG4gIC8vIHRoZSBzYW1lICduYW1lJyBhdHRyaWJ1dGVcbiAgdmFyIGVsZW1lbnRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUobmFtZSlcbiAgICAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgaWYgKCEobGVuID4gMSkpIHJldHVybjtcbiAgZm9yICh2YXIgaSA9IDAsIGVsZW1lbnQ7IGkgPCBsZW47IGkrKykge1xuICAgIGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICBpZiAoZWxlbWVudCA9PT0gZWwpIGNvbnRpbnVlO1xuICAgIGRvbS50cmlnZ2VyKGUsIGVsZW1lbnQsIGZhbHNlLCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRNYXJrZXJzKCkge1xuICB2YXIgbWFwID0ge307XG4gIC8vIE5vZGVGaWx0ZXIuU0hPV19DT01NRU5UID09IDEyOFxuICB2YXIgY29tbWVudEl0ZXJhdG9yID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihkb2N1bWVudCwgMTI4LCBudWxsLCBmYWxzZSk7XG4gIHZhciBjb21tZW50O1xuICB3aGlsZSAoY29tbWVudCA9IGNvbW1lbnRJdGVyYXRvci5uZXh0Tm9kZSgpKSB7XG4gICAgbWFwW2NvbW1lbnQuZGF0YV0gPSBjb21tZW50O1xuICB9XG4gIHJldHVybiBtYXA7XG59XG5cbmZ1bmN0aW9uIGdldE1hcmtlcihtYXAsIG5hbWUpIHtcbiAgdmFyIG1hcmtlciA9IG1hcFtuYW1lXTtcbiAgaWYgKCFtYXJrZXIpIHJldHVybjtcblxuICAvLyBDb21tZW50IG5vZGVzIG1heSBjb250aW51ZSB0byBleGlzdCBldmVuIGlmIHRoZXkgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbVxuICAvLyB0aGUgcGFnZS4gVGh1cywgbWFrZSBzdXJlIHRoZXkgYXJlIHN0aWxsIHNvbWV3aGVyZSBpbiB0aGUgcGFnZSBib2R5XG4gIGlmICghZG9jdW1lbnQuY29udGFpbnMobWFya2VyKSkge1xuICAgIGRlbGV0ZSBtYXBbbmFtZV07XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiBtYXJrZXI7XG59XG5cbmZ1bmN0aW9uIGRvbU1hcmtlcihuYW1lKSB7XG4gIHZhciBtYXJrZXIgPSBnZXRNYXJrZXIobWFya2VycywgbmFtZSk7XG4gIGlmICghbWFya2VyICYmIG1hcmtlcnNEaXJ0eSkge1xuICAgIG1hcmtlcnMgPSBnZXRNYXJrZXJzKCk7XG4gICAgbWFya2Vyc0RpcnR5ID0gZmFsc2U7XG4gICAgbWFya2VyID0gZ2V0TWFya2VyKG1hcmtlcnMsIG5hbWUpO1xuICB9XG4gIHJldHVybiBtYXJrZXI7XG59XG5cbmZ1bmN0aW9uIGdldFJhbmdlKG5hbWUpIHtcbiAgdmFyIHN0YXJ0ID0gZG9tTWFya2VyKG5hbWUpO1xuICBpZiAoIXN0YXJ0KSByZXR1cm47XG4gIHZhciBlbmQgPSBkb21NYXJrZXIoJyQnICsgbmFtZSk7XG4gIGlmICghZW5kKSByZXR1cm47XG5cbiAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgcmFuZ2Uuc2V0U3RhcnRBZnRlcihzdGFydCk7XG4gIHJhbmdlLnNldEVuZEJlZm9yZShlbmQpO1xuICByZXR1cm4gcmFuZ2U7XG59XG5cbmlmIChkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG4gIGFkZExpc3RlbmVyID0gZnVuY3Rpb24oZWwsIG5hbWUsIGNhbGxiYWNrLCBjYXB0dXJlcykge1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgY2FsbGJhY2ssIGNhcHR1cmVzIHx8IGZhbHNlKTtcbiAgfTtcbiAgcmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbihlbCwgbmFtZSwgY2FsbGJhY2ssIGNhcHR1cmVzKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBjYWxsYmFjaywgY2FwdHVyZXMgfHwgZmFsc2UpO1xuICB9O1xufVxuIiwidmFyIGRlZmF1bHRGbnMgPSBtb2R1bGUuZXhwb3J0cyA9IG5ldyBEZWZhdWx0Rm5zO1xuXG5kZWZhdWx0Rm5zLnJldmVyc2UgPSBuZXcgRm5QYWlyKGdldFJldmVyc2UsIHNldFJldmVyc2UpO1xuZGVmYXVsdEZucy5hc2MgPSBhc2M7XG5kZWZhdWx0Rm5zLmRlc2MgPSBkZXNjO1xuXG5mdW5jdGlvbiBEZWZhdWx0Rm5zKCkge31cbmZ1bmN0aW9uIEZuUGFpcihnZXQsIHNldCkge1xuICB0aGlzLmdldCA9IGdldDtcbiAgdGhpcy5zZXQgPSBzZXQ7XG59XG5cbmZ1bmN0aW9uIGdldFJldmVyc2UoYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5ICYmIGFycmF5LnNsaWNlKCkucmV2ZXJzZSgpO1xufVxuZnVuY3Rpb24gc2V0UmV2ZXJzZSh2YWx1ZXMpIHtcbiAgcmV0dXJuIHswOiBnZXRSZXZlcnNlKHZhbHVlcyl9O1xufVxuXG5mdW5jdGlvbiBhc2MoYSwgYikge1xuICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBkZXNjKGEsIGIpIHtcbiAgaWYgKGEgPiBiKSByZXR1cm4gLTE7XG4gIGlmIChhIDwgYikgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufVxuIiwiKGZ1bmN0aW9uKGdsb2JhbCl7dmFyIGh0bWxVdGlsID0gcmVxdWlyZSgnaHRtbC11dGlsJylcbnZhciBtZDUgPSByZXF1aXJlKCdNRDUnKVxudmFyIHBhcnNlSHRtbCA9IGh0bWxVdGlsLnBhcnNlXG52YXIgdHJpbVRleHQgPSBodG1sVXRpbC50cmltVGV4dFxudmFyIHVuZXNjYXBlRW50aXRpZXMgPSBodG1sVXRpbC51bmVzY2FwZUVudGl0aWVzXG52YXIgZXNjYXBlSHRtbCA9IGh0bWxVdGlsLmVzY2FwZUh0bWxcbnZhciBlc2NhcGVBdHRyaWJ1dGUgPSBodG1sVXRpbC5lc2NhcGVBdHRyaWJ1dGVcbnZhciBpc1ZvaWQgPSBodG1sVXRpbC5pc1ZvaWRcbnZhciBjb25kaXRpb25hbENvbW1lbnQgPSBodG1sVXRpbC5jb25kaXRpb25hbENvbW1lbnRcbnZhciBtYXJrdXAgPSByZXF1aXJlKCcuL21hcmt1cCcpXG52YXIgdmlld1BhdGggPSByZXF1aXJlKCcuL3ZpZXdQYXRoJylcbnZhciB3cmFwUmVtYWluZGVyID0gdmlld1BhdGgud3JhcFJlbWFpbmRlclxudmFyIGN0eFBhdGggPSB2aWV3UGF0aC5jdHhQYXRoXG52YXIgZXh0cmFjdFBsYWNlaG9sZGVyID0gdmlld1BhdGguZXh0cmFjdFBsYWNlaG9sZGVyXG52YXIgZGF0YVZhbHVlID0gdmlld1BhdGguZGF0YVZhbHVlXG52YXIgcGF0aEZuQXJncyA9IHZpZXdQYXRoLnBhdGhGbkFyZ3NcbnZhciBpc0JvdW5kID0gdmlld1BhdGguaXNCb3VuZFxudmFyIGV2ZW50QmluZGluZyA9IHJlcXVpcmUoJy4vZXZlbnRCaW5kaW5nJylcbnZhciBzcGxpdEV2ZW50cyA9IGV2ZW50QmluZGluZy5zcGxpdEV2ZW50c1xudmFyIGZuTGlzdGVuZXIgPSBldmVudEJpbmRpbmcuZm5MaXN0ZW5lclxudmFyIGRlcmJ5ID0gcmVxdWlyZSgnLi9kZXJieScpXG5cbm1vZHVsZS5leHBvcnRzID0gVmlldztcblxuZnVuY3Rpb24gZW1wdHkoKSB7XG4gIHJldHVybiAnJztcbn1cblxudmFyIGRlZmF1bHRDdHggPSB7XG4gICRhbGlhc2VzOiB7fVxuLCAkcGF0aHM6IFtdXG4sICRpbmRpY2VzOiBbXVxufTtcblxudmFyIENBTUVMX1JFR0VYUCA9IC8oW2Etel0pKFtBLVpdKS9nO1xuXG52YXIgZGVmYXVsdEdldEZucyA9IHtcbiAgZXF1YWw6IGZ1bmN0aW9uIGdldEVxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gYSA9PT0gYjtcbiAgfVxuLCBub3Q6IGZ1bmN0aW9uIGdldE5vdCh2YWx1ZSkge1xuICAgIHJldHVybiAhdmFsdWU7XG4gIH1cbiwgb3I6IGZ1bmN0aW9uIGdldE9yKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgaWYgKGFyZykgcmV0dXJuIGFyZztcbiAgICB9O1xuICAgIHJldHVybiBhcmc7XG4gIH1cbiwgYW5kOiBmdW5jdGlvbiBnZXRBbmQoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgICBpZiAoIWFyZykgcmV0dXJuIGFyZztcbiAgICB9O1xuICAgIHJldHVybiBhcmc7XG4gIH1cbiwgZ3Q6IGZ1bmN0aW9uIGdldEd0KGEsIGIpIHtcbiAgICByZXR1cm4gYSA+IGI7XG4gIH1cbiwgbHQ6IGZ1bmN0aW9uIGdldEx0KGEsIGIpIHtcbiAgICByZXR1cm4gYSA8IGI7XG4gIH1cbiwgZ3RlOiBmdW5jdGlvbiBnZXRHdGUoYSwgYikge1xuICAgIHJldHVybiBhID49IGI7XG4gIH1cbiwgbHRlOiBmdW5jdGlvbiBnZXRMdGUoYSwgYikge1xuICAgIHJldHVybiBhIDw9IGI7XG4gIH1cbiwgZGFzaDogZnVuY3Rpb24gZ2V0RGFzaCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZVxuICAgICAgLnJlcGxhY2UoL1s6X1xcc10vZywgJy0nKVxuICAgICAgLnJlcGxhY2UoQ0FNRUxfUkVHRVhQLCAnJDEtJDInKVxuICAgICAgLnRvTG93ZXJDYXNlKClcbiAgfVxuLCBqb2luOiBmdW5jdGlvbiBnZXRKb2luKGl0ZW1zLCBwcm9wZXJ0eSwgc2VwYXJhdG9yKSB7XG4gICAgdmFyIGxpc3QsIGk7XG4gICAgaWYgKCFpdGVtcykgcmV0dXJuO1xuICAgIGlmIChwcm9wZXJ0eSkge1xuICAgICAgbGlzdCA9IFtdO1xuICAgICAgZm9yIChpID0gaXRlbXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIGxpc3RbaV0gPSBpdGVtc1tpXVtwcm9wZXJ0eV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3QgPSBpdGVtcztcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Quam9pbihzZXBhcmF0b3IgfHwgJywgJyk7XG4gIH1cbiwgbG9nOiBmdW5jdGlvbiBnZXRMb2coKSB7XG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgfVxuLCB0cmFjZTogZnVuY3Rpb24gZ2V0VHJhY2UoKSB7XG4gICAgY29uc29sZS50cmFjZSgpO1xuICB9XG4sIGRlYnVnZ2VyOiBmdW5jdGlvbiBnZXREZWJ1Z2dlcigpIHtcbiAgICBkZWJ1Z2dlcjtcbiAgfVxuLCBwYXRoOiBmdW5jdGlvbiBnZXRQYXRoKG5hbWUpIHtcbiAgICByZXR1cm4gY3R4UGF0aCh0aGlzLnZpZXcsIHRoaXMuY3R4LCBuYW1lKTtcbiAgfVxuLCBub29wOiBmdW5jdGlvbiBub29wKCkge31cbiwgbG9va3VwOiB2aWV3UGF0aC5sb29rdXBcbn07XG5cbnZhciBkZWZhdWx0U2V0Rm5zID0ge1xuICBlcXVhbDogZnVuY3Rpb24gc2V0RXF1YWwodmFsdWUsIGEsIGIpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgW2JdO1xuICB9XG4sIG5vdDogZnVuY3Rpb24gc2V0Tm90KHZhbHVlKSB7XG4gICAgcmV0dXJuIFshdmFsdWVdO1xuICB9XG59O1xuXG5mdW5jdGlvbiBWaWV3KGxpYnJhcmllcywgYXBwLCBhcHBGaWxlbmFtZSkge1xuICB0aGlzLl9saWJyYXJpZXMgPSBsaWJyYXJpZXMgfHwgW107XG4gIHRoaXMuYXBwID0gYXBwIHx8IHt9O1xuICB0aGlzLl9hcHBGaWxlbmFtZSA9IGFwcEZpbGVuYW1lO1xuICB0aGlzLl9pbmxpbmUgPSAnJztcbiAgdGhpcy5jbGVhcigpO1xuICB0aGlzLmdldEZucyA9IGRlcmJ5LnV0aWwuY29weU9iamVjdChkZWZhdWx0R2V0Rm5zKTtcbiAgdGhpcy5zZXRGbnMgPSBkZXJieS51dGlsLmNvcHlPYmplY3QoZGVmYXVsdFNldEZucyk7XG4gIGlmICh0aGlzLl9pbml0KSB0aGlzLl9pbml0KCk7XG4gIHRoaXMuX2lkQ291bnQgPSAwO1xuICB0aGlzLl91bmNyZWF0ZWQgPSBbXTtcbn1cblZpZXcucHJvdG90eXBlID0ge1xuICBkZWZhdWx0Vmlld3M6IHtcbiAgICBkb2N0eXBlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnPCFET0NUWVBFIGh0bWw+JztcbiAgICB9XG4gICwgcm9vdDogZW1wdHlcbiAgLCBjaGFyc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnPG1ldGEgY2hhcnNldD11dGYtOD4nO1xuICAgIH1cbiAgLCB0aXRsZSRzOiBlbXB0eVxuICAsIGhlYWQ6IGVtcHR5XG4gICwgaGVhZGVyOiBlbXB0eVxuICAsIGJvZHk6IGVtcHR5XG4gICwgZm9vdGVyOiBlbXB0eVxuICAsIHNjcmlwdHM6IGVtcHR5XG4gICwgdGFpbDogZW1wdHlcbiAgfVxuXG4sIF9zZWxmTnM6ICdhcHAnXG5cbiAgLy8gQWxsIGF1dG9tYXRpY2FsbHkgY3JlYXRlZCBpZHMgc3RhcnQgd2l0aCBhIGRvbGxhciBzaWduXG4gIC8vIFRPRE86IGNoYW5nZSB0aGlzIHNpbmNlIGl0IG1lc3NlcyB1cCBxdWVyeSBzZWxlY3RvcnMgdW5sZXNzIGVzY2FwZWRcbiwgX3VuaXF1ZUlkOiB1bmlxdWVJZFxuXG4sIGNsZWFyOiBjbGVhclxuLCBfcmVzZXRGb3JSZW5kZXI6IHJlc2V0Rm9yUmVuZGVyXG4sIG1ha2U6IG1ha2VcbiwgX21ha2VBbGw6IG1ha2VBbGxcbiwgX21ha2VDb21wb25lbnRzOiBtYWtlQ29tcG9uZW50c1xuLCBfZmluZFZpZXc6IGZpbmRWaWV3XG4sIF9maW5kOiBmaW5kXG4sIGdldDogZ2V0XG4sIGZuOiBmblxuLCByZW5kZXI6IHJlbmRlclxuLCBjb21wb25lbnRzQnlOYW1lOiBjb21wb25lbnRzQnlOYW1lXG4sIF9jb21wb25lbnRDb25zdHJ1Y3RvcjogY29tcG9uZW50Q29uc3RydWN0b3JcbiwgX2ZsdXNoVW5jcmVhdGVkOiBmbHVzaFVuY3JlYXRlZFxuLCBfYmVmb3JlUmVuZGVyOiBiZWZvcmVSZW5kZXJcbiwgX2FmdGVyUmVuZGVyOiBhZnRlclJlbmRlclxuLCBfYmVmb3JlUm91dGU6IGJlZm9yZVJvdXRlXG5cbiwgaW5saW5lOiBlbXB0eVxuXG4sIGVzY2FwZUh0bWw6IGVzY2FwZUh0bWxcbiwgZXNjYXBlQXR0cmlidXRlOiBlc2NhcGVBdHRyaWJ1dGVcbn1cblxuVmlldy52YWx1ZUJpbmRpbmcgPSB2YWx1ZUJpbmRpbmc7XG5cbmZ1bmN0aW9uIGNsZWFyKCkge1xuICB0aGlzLl92aWV3cyA9IGRlcmJ5LnV0aWwuY29weU9iamVjdCh0aGlzLmRlZmF1bHRWaWV3cyk7XG4gIHRoaXMuX3JlbmRlcnMgPSB7fTtcbiAgdGhpcy5fcmVzZXRGb3JSZW5kZXIoKTtcbn1cblxuZnVuY3Rpb24gcmVzZXRGb3JSZW5kZXIobW9kZWwsIGNvbXBvbmVudEluc3RhbmNlcykge1xuICBjb21wb25lbnRJbnN0YW5jZXMgfHwgKGNvbXBvbmVudEluc3RhbmNlcyA9IHt9KTtcbiAgaWYgKG1vZGVsKSB0aGlzLm1vZGVsID0gbW9kZWw7XG4gIHRoaXMuX2NvbXBvbmVudEluc3RhbmNlcyA9IGNvbXBvbmVudEluc3RhbmNlcztcbiAgdmFyIGxpYnJhcmllcyA9IHRoaXMuX2xpYnJhcmllc1xuICAgICwgaVxuICBmb3IgKGkgPSBsaWJyYXJpZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgbGlicmFyaWVzW2ldLnZpZXcuX3Jlc2V0Rm9yUmVuZGVyKG1vZGVsLCBjb21wb25lbnRJbnN0YW5jZXMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBvbmVudHNCeU5hbWUobmFtZSkge1xuICByZXR1cm4gdGhpcy5fY29tcG9uZW50SW5zdGFuY2VzW25hbWVdIHx8IFtdO1xufVxuXG5mdW5jdGlvbiBjb21wb25lbnRDb25zdHJ1Y3RvcihuYW1lKSB7XG4gIHJldHVybiB0aGlzLl9zZWxmTGlicmFyeSAmJiB0aGlzLl9zZWxmTGlicmFyeS5jb25zdHJ1Y3RvcnNbbmFtZV07XG59XG5cbmZ1bmN0aW9uIHVuaXF1ZUlkKCkge1xuICByZXR1cm4gJyQnICsgKHRoaXMuX2lkQ291bnQrKykudG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBtYWtlKG5hbWUsIHRlbXBsYXRlLCBvcHRpb25zLCB0ZW1wbGF0ZVBhdGgpIHtcbiAgdmFyIHZpZXcgPSB0aGlzXG4gICAgLCBpc1N0cmluZyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5saXRlcmFsXG4gICAgLCBub01pbmlmeSA9IGlzU3RyaW5nXG4gICAgLCBvbkJpbmQsIHJlbmRlcmVyLCByZW5kZXIsIG1hdGNoVGl0bGU7XG5cbiAgaWYgKHRlbXBsYXRlUGF0aCAmJiAocmVuZGVyID0gdGhpcy5fcmVuZGVyc1t0ZW1wbGF0ZVBhdGhdKSkge1xuICAgIHRoaXMuX3ZpZXdzW25hbWVdID0gcmVuZGVyO1xuICAgIHJldHVyblxuICB9XG5cbiAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgbWF0Y2hUaXRsZSA9IC8oPzpefFxcOil0aXRsZShcXCRzKT8kLy5leGVjKG5hbWUpO1xuICBpZiAobWF0Y2hUaXRsZSkge1xuICAgIGlzU3RyaW5nID0gISFtYXRjaFRpdGxlWzFdO1xuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgb25CaW5kID0gZnVuY3Rpb24oZXZlbnRzLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBiaW5kRXZlbnRzKGV2ZW50cywgbmFtZSwgcmVuZGVyLCBbJyRfZG9jJywgJ3Byb3AnLCAndGl0bGUnXSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1ha2UobmFtZSArICckcycsIHRlbXBsYXRlLCBvcHRpb25zLCB0ZW1wbGF0ZVBhdGgpO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlciA9IGZ1bmN0aW9uKGN0eCwgbW9kZWwsIHRyaWdnZXJJZCkge1xuICAgIGlmICghcmVuZGVyZXIpIHtcbiAgICAgIHJlbmRlcmVyID0gcGFyc2UodmlldywgbmFtZSwgdGVtcGxhdGUsIGlzU3RyaW5nLCBvbkJpbmQsIG5vTWluaWZ5KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlbmRlcmVyKGN0eCwgbW9kZWwsIHRyaWdnZXJJZCk7XG4gIH1cblxuICByZW5kZXIubm9udm9pZCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5ub252b2lkO1xuXG4gIHRoaXMuX3ZpZXdzW25hbWVdID0gcmVuZGVyO1xuICBpZiAodGVtcGxhdGVQYXRoKSB0aGlzLl9yZW5kZXJzW3RlbXBsYXRlUGF0aF0gPSByZW5kZXI7XG59XG5cbmZ1bmN0aW9uIG1ha2VBbGwodGVtcGxhdGVzLCBpbnN0YW5jZXMpIHtcbiAgdmFyIG5hbWUsIGluc3RhbmNlLCBvcHRpb25zLCB0ZW1wbGF0ZVBhdGg7XG4gIGlmICghaW5zdGFuY2VzKSByZXR1cm47XG4gIHRoaXMuY2xlYXIoKTtcbiAgZm9yIChuYW1lIGluIGluc3RhbmNlcykge1xuICAgIGluc3RhbmNlID0gaW5zdGFuY2VzW25hbWVdO1xuICAgIHRlbXBsYXRlUGF0aCA9IGluc3RhbmNlWzBdO1xuICAgIG9wdGlvbnMgPSBpbnN0YW5jZVsxXTtcbiAgICB0aGlzLm1ha2UobmFtZSwgdGVtcGxhdGVzW3RlbXBsYXRlUGF0aF0sIG9wdGlvbnMsIHRlbXBsYXRlUGF0aCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUNvbXBvbmVudHMoY29tcG9uZW50cykge1xuICB2YXIgbGlicmFyaWVzTWFwID0gdGhpcy5fbGlicmFyaWVzLm1hcFxuICAgICwgbmFtZSwgY29tcG9uZW50LCBsaWJyYXJ5O1xuICBmb3IgKG5hbWUgaW4gY29tcG9uZW50cykge1xuICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbbmFtZV07XG4gICAgbGlicmFyeSA9IGxpYnJhcmllc01hcFtuYW1lXTtcbiAgICBsaWJyYXJ5ICYmIGxpYnJhcnkudmlldy5fbWFrZUFsbChjb21wb25lbnQudGVtcGxhdGVzLCBjb21wb25lbnQuaW5zdGFuY2VzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kVmlldyhuYW1lLCBucykge1xuICB2YXIgaXRlbXMgPSB0aGlzLl92aWV3c1xuICAgICwgaXRlbSwgaSwgc2VnbWVudHMsIHRlc3ROcztcbiAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgaWYgKG5zKSB7XG4gICAgbnMgPSBucy50b0xvd2VyQ2FzZSgpO1xuICAgIGl0ZW0gPSBpdGVtc1tucyArICc6JyArIG5hbWVdO1xuICAgIGlmIChpdGVtKSByZXR1cm4gaXRlbTtcblxuICAgIHNlZ21lbnRzID0gbnMuc3BsaXQoJzonKTtcbiAgICBmb3IgKGkgPSBzZWdtZW50cy5sZW5ndGg7IGktLSA+IDE7KSB7XG4gICAgICB0ZXN0TnMgPSBzZWdtZW50cy5zbGljZSgwLCBpKS5qb2luKCc6Jyk7XG4gICAgICBpdGVtID0gaXRlbXNbdGVzdE5zICsgJzonICsgbmFtZV07XG4gICAgICBpZiAoaXRlbSkgcmV0dXJuIGl0ZW07XG4gICAgfVxuICB9XG4gIHJldHVybiBpdGVtc1tuYW1lXTtcbn1cblxuZnVuY3Rpb24gZmluZChuYW1lLCBucywgb3B0aW9uYWwpIHtcbiAgdmFyIHZpZXcgPSB0aGlzLl9maW5kVmlldyhuYW1lLCBucyk7XG4gIGlmICh2aWV3KSByZXR1cm4gdmlldztcbiAgaWYgKG9wdGlvbmFsKSByZXR1cm4gZW1wdHk7XG4gIGlmIChucykgbmFtZSA9IG5zICsgJzonICsgbmFtZTtcbiAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgZmluZCB0ZW1wbGF0ZTogXFxuICBcIiArIG5hbWUgKyAnXFxuXFxuJyArXG4gICAgJ0F2YWlsYWJsZSB0ZW1wbGF0ZXM6IFxcbiAgJyArIE9iamVjdC5rZXlzKHRoaXMuX3ZpZXdzKS5qb2luKCdcXG4gICcpXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldChuYW1lLCBucywgY3R4KSB7XG4gIGlmICh0eXBlb2YgbnMgPT09ICdvYmplY3QnKSB7XG4gICAgY3R4ID0gbnM7XG4gICAgbnMgPSAnJztcbiAgfVxuICBjdHggPSBjdHggPyBleHRlbmQoY3R4LCBkZWZhdWx0Q3R4KSA6IGRlcmJ5LnV0aWwuY29weU9iamVjdChkZWZhdWx0Q3R4KTtcbiAgdGhpcy5hcHAubW9kZWwgPSB0aGlzLm1vZGVsO1xuICBjdHguJGZuQ3R4ID0gW3RoaXMuYXBwXTtcbiAgY3R4LiRwYXRoSWRzID0ge307XG4gIHJldHVybiB0aGlzLl9maW5kKG5hbWUsIG5zKShjdHgpO1xufVxuXG5mdW5jdGlvbiBmbihuYW1lLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yICh2YXIgayBpbiBuYW1lKSB7XG4gICAgICB0aGlzLmZuKGssIG5hbWVba10pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGdldCwgc2V0O1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGdldCA9IHZhbHVlLmdldDtcbiAgICBzZXQgPSB2YWx1ZS5zZXQ7XG4gIH0gZWxzZSB7XG4gICAgZ2V0ID0gdmFsdWU7XG4gIH1cbiAgdGhpcy5nZXRGbnNbbmFtZV0gPSBnZXQ7XG4gIGlmIChzZXQpIHRoaXMuc2V0Rm5zW25hbWVdID0gc2V0O1xufVxuXG5mdW5jdGlvbiBlbWl0UmVuZGVyKHZpZXcsIG5zLCBjdHgsIG5hbWUpIHtcbiAgaWYgKHZpZXcuaXNTZXJ2ZXIpIHJldHVybjtcbiAgdmlldy5hcHAuZW1pdChuYW1lLCBjdHgpO1xuICBpZiAobnMpIHZpZXcuYXBwLmVtaXQobmFtZSArICc6JyArIG5zLCBjdHgpO1xufVxuZnVuY3Rpb24gYmVmb3JlUmVuZGVyKG1vZGVsLCBucywgY3R4KSB7XG4gIGN0eCA9IChjdHggJiYgT2JqZWN0LmNyZWF0ZShjdHgpKSB8fCB7fTtcbiAgY3R4LiRucyA9IG5zO1xuICBlbWl0UmVuZGVyKHRoaXMsIG5zLCBjdHgsICdwcmU6cmVuZGVyJyk7XG4gIHJldHVybiBjdHg7XG59XG5mdW5jdGlvbiBhZnRlclJlbmRlcihucywgY3R4KSB7XG4gIGVtaXRSZW5kZXIodGhpcywgbnMsIGN0eCwgJ3JlbmRlcicpO1xufVxuZnVuY3Rpb24gYmVmb3JlUm91dGUoKSB7XG4gIHRoaXMuYXBwLmRvbS5jbGVhcigpO1xuICAvLyBSZW1vdmUgYWxsIGRhdGEsIHJlZnMsIGxpc3RlbmVycywgYW5kIHJlYWN0aXZlIGZ1bmN0aW9uc1xuICAvLyBmb3IgdGhlIHByZXZpb3VzIHBhZ2VcbiAgdmFyIHNpbGVudE1vZGVsID0gdGhpcy5tb2RlbC5zaWxlbnQoKTtcbiAgc2lsZW50TW9kZWwuZGVzdHJveSgnX3BhZ2UnKTtcbiAgc2lsZW50TW9kZWwuZGVzdHJveSgnJGNvbXBvbmVudHMnKTtcbiAgLy8gVW5mZXRjaCBhbmQgdW5zdWJzY3JpYmUgZnJvbSBhbGwgcXVlcmllcyBhbmQgZG9jdW1lbnRzXG4gIHNpbGVudE1vZGVsLnVubG9hZCgpO1xuICB2YXIgbGFzdFJlbmRlciA9IHRoaXMuX2xhc3RSZW5kZXI7XG4gIGlmICghbGFzdFJlbmRlcikgcmV0dXJuO1xuICBlbWl0UmVuZGVyKHRoaXMsIGxhc3RSZW5kZXIubnMsIGxhc3RSZW5kZXIuY3R4LCAncmVwbGFjZScpO1xufVxuXG5mdW5jdGlvbiByZW5kZXIobW9kZWwsIG5zLCBjdHgsIHJlbmRlckhhc2gpIHtcbiAgaWYgKHR5cGVvZiBucyA9PT0gJ29iamVjdCcpIHtcbiAgICByZW5kZXJIYXNoID0gY3R4O1xuICAgIGN0eCA9IG5zO1xuICAgIG5zID0gJyc7XG4gIH1cbiAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuXG4gIGlmICghY3R4LiRpc1NlcnZlcikgY3R4ID0gdGhpcy5fYmVmb3JlUmVuZGVyKG1vZGVsLCBucywgY3R4KTtcbiAgdGhpcy5fbGFzdFJlbmRlciA9IHtcbiAgICBuczogbnNcbiAgLCBjdHg6IGN0eFxuICB9O1xuXG4gIHRoaXMuX3Jlc2V0Rm9yUmVuZGVyKCk7XG4gIG1vZGVsLl9fcGF0aE1hcC5jbGVhcigpO1xuICBtb2RlbC5fX2V2ZW50cy5jbGVhcigpO1xuICBtb2RlbC5fX2Jsb2NrUGF0aHMgPSB7fTtcbiAgdGhpcy5hcHAuZG9tLmNsZWFyKCk7XG4gIG1vZGVsLnNpbGVudCgpLmRlc3Ryb3koJyRjb21wb25lbnRzJyk7XG5cbiAgdmFyIHRpdGxlID0gdGhpcy5nZXQoJ3RpdGxlJHMnLCBucywgY3R4KVxuICAgICwgaGVhZEh0bWwgPSB0aGlzLmdldCgnaGVhZCcsIG5zLCBjdHgpXG4gICAgLCByb290SHRtbCA9IHRoaXMuZ2V0KCdyb290JywgbnMsIGN0eClcbiAgICAsIGJvZHlIdG1sID0gdGhpcy5nZXQoJ2hlYWRlcicsIG5zLCBjdHgpICtcbiAgICAgICAgdGhpcy5nZXQoJ2JvZHknLCBucywgY3R4KSArXG4gICAgICAgIHRoaXMuZ2V0KCdmb290ZXInLCBucywgY3R4KVxuICAgICwgZG9jID0gd2luZG93LmRvY3VtZW50XG4gICAgLCBlcnJcblxuICBpZiAocmVuZGVySGFzaCkge1xuICAgIC8vIENoZWNrIGhhc2hlcyBpbiBkZXZlbG9wbWVudCB0byBoZWxwIGZpbmQgcmVuZGVyaW5nIGJ1Z3NcbiAgICBpZiAocmVuZGVySGFzaCA9PT0gbWQ1KGJvZHlIdG1sKSkge1xuICAgICAgdGhpcy5fZmx1c2hVbmNyZWF0ZWQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXJyID0gbmV3IEVycm9yKCdTZXJ2ZXIgYW5kIGNsaWVudCBwYWdlIHJlbmRlcnMgZG8gbm90IG1hdGNoJyk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9LCAwKTtcbiAgfSBlbHNlIGlmIChjdHguJGlzU2VydmVyKSB7XG4gICAgLy8gRG9uJ3QgZmluaXNoIHJlbmRlcmluZyBjbGllbnQgc2lkZSBvbiB0aGUgdmVyeSBmaXJzdCBsb2FkLCBzaW5jZVxuICAgIC8vIHRoZSBwYWdlIHNob3VsZCBhbHJlYWR5IGhhdmUgdGhlIHNhbWUgSFRNTCBmcm9tIHRoZSBzZXJ2ZXJcbiAgICB0aGlzLl9mbHVzaFVuY3JlYXRlZCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2MuZG9jdW1lbnRFbGVtZW50XG4gICAgLCBhdHRycyA9IGRvY3VtZW50RWxlbWVudC5hdHRyaWJ1dGVzXG4gICAgLCBpLCBhdHRyLCBmYWtlUm9vdCwgYm9keTtcblxuICAvLyBSZW1vdmUgYWxsIGN1cnJlbnQgYXR0cmlidXRlcyBvbiB0aGUgZG9jdW1lbnRFbGVtZW50IGFuZCByZXBsYWNlXG4gIC8vIHRoZW0gd2l0aCB0aGUgYXR0cmlidXRlcyBpbiB0aGUgcmVuZGVyZWQgcm9vdEh0bWxcbiAgZm9yIChpID0gYXR0cnMubGVuZ3RoOyBpLS07KSB7XG4gICAgYXR0ciA9IGF0dHJzW2ldO1xuICAgIGRvY3VtZW50RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0ci5uYW1lKTtcbiAgfVxuICAvLyBVc2luZyB0aGUgRE9NIHRvIGdldCB0aGUgYXR0cmlidXRlcyBvbiBhbiA8aHRtbD4gdGFnIHdvdWxkIHJlcXVpcmVcbiAgLy8gc29tZSBzb3J0IG9mIGlmcmFtZSBoYWNrIHVudGlsIERPTVBhcnNlciBoYXMgYmV0dGVyIGJyb3dzZXIgc3VwcG9ydC5cbiAgLy8gU3RyaW5nIHBhcnNpbmcgdGhlIGh0bWwgc2hvdWxkIGJlIHNpbXBsZXIgYW5kIG1vcmUgZWZmaWNpZW50XG4gIHBhcnNlSHRtbChyb290SHRtbCwge1xuICAgIHN0YXJ0OiBmdW5jdGlvbih0YWcsIHRhZ05hbWUsIGF0dHJzKSB7XG4gICAgICBpZiAodGFnTmFtZSAhPT0gJ2h0bWwnKSByZXR1cm47XG4gICAgICBmb3IgKHZhciBhdHRyIGluIGF0dHJzKSB7XG4gICAgICAgIGRvY3VtZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0ciwgYXR0cnNbYXR0cl0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgZmFrZVJvb3QgPSBkb2MuY3JlYXRlRWxlbWVudCgnaHRtbCcpO1xuICBmYWtlUm9vdC5pbm5lckhUTUwgPSBib2R5SHRtbDtcbiAgYm9keSA9IGZha2VSb290LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF07XG4gIGRvY3VtZW50RWxlbWVudC5yZXBsYWNlQ2hpbGQoYm9keSwgZG9jLmJvZHkpO1xuICBkb2MudGl0bGUgPSB0aXRsZTtcblxuICB0aGlzLmFwcC5kb20uX3NldERpcnR5KHRydWUpO1xuICB0aGlzLl9mbHVzaFVuY3JlYXRlZCgpO1xuICB0aGlzLl9hZnRlclJlbmRlcihucywgY3R4KTtcbn1cblxuXG5mdW5jdGlvbiBleHRlbmQocGFyZW50LCBvYmopIHtcbiAgdmFyIG91dCA9IE9iamVjdC5jcmVhdGUocGFyZW50KVxuICAgICwga2V5O1xuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICBvdXRba2V5XSA9IG9ialtrZXldO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIG1vZGVsTGlzdGVuZXIocGFyYW1zLCB0cmlnZ2VySWQsIGJsb2NrUGF0aHMsIHBhdGhJZCwgcGFydGlhbCwgY3R4LCBzYXZlQmxvY2tQYXRoKSB7XG4gIHZhciBsaXN0ZW5lciA9IHR5cGVvZiBwYXJhbXMgPT09ICdmdW5jdGlvbidcbiAgICA/IHBhcmFtcyh0cmlnZ2VySWQsIGJsb2NrUGF0aHMsIHNhdmVCbG9ja1BhdGggJiYgcGF0aElkKVxuICAgIDogcGFyYW1zO1xuICBsaXN0ZW5lci5wYXJ0aWFsID0gcGFydGlhbDtcbiAgbGlzdGVuZXIuY3R4ID0gY3R4LiRzdHJpbmdDdHggfHwgY3R4O1xuICByZXR1cm4gbGlzdGVuZXI7XG59XG5cbmZ1bmN0aW9uIGJpbmRQYXRoRXZlbnQoZXZlbnRzLCBiaW5kTmFtZSwgZ2V0TmFtZSwgcGFydGlhbCwgcGFyYW1zLCBzYXZlQmxvY2tQYXRoKSB7XG4gIGV2ZW50cy5wdXNoKGZ1bmN0aW9uKGN0eCwgbW9kZWxFdmVudHMsIGRvbSwgcGF0aE1hcCwgdmlldywgYmxvY2tQYXRocywgdHJpZ2dlcklkKSB7XG4gICAgdmFyIHBhdGggPSBjdHhQYXRoKHZpZXcsIGN0eCwgYmluZE5hbWUpXG4gICAgaWYgKCFwYXRoKSByZXR1cm47XG4gICAgdmFyIHBhdGhJZCA9IHBhdGhNYXAuaWQocGF0aCk7XG4gICAgdmFyIGxpc3RlbmVyID0gbW9kZWxMaXN0ZW5lcihwYXJhbXMsIHRyaWdnZXJJZCwgYmxvY2tQYXRocywgcGF0aElkLCBwYXJ0aWFsLCBjdHgsIHNhdmVCbG9ja1BhdGgpO1xuICAgIGlmIChiaW5kTmFtZSAhPT0gZ2V0TmFtZSkge1xuICAgICAgbGlzdGVuZXIuZ2V0VmFsdWUgPSBmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICByZXR1cm4gZGF0YVZhbHVlKHZpZXcsIGN0eCwgbW9kZWwsIGdldE5hbWUpO1xuICAgICAgfTtcbiAgICB9XG4gICAgbW9kZWxFdmVudHMuYmluZChwYXRoSWQsIGxpc3RlbmVyKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBiaW5kRWFjaFBhdGhFdmVudChldmVudHMsIG5hbWUsIGdldE5hbWUsIHBhcnRpYWwsIHBhcmFtcykge1xuICB2YXIgYnJhY2tldEluZGV4ID0gbmFtZS5pbmRleE9mKCdbJyk7XG4gIGlmICh+YnJhY2tldEluZGV4KSB7XG4gICAgLy8gQmluZCB0byBlYWNoIG9mIHRoZSBpdGVtcyBpbnNpZGUgYnJhY2tldHNcbiAgICB2YXIgcGF0aHMgPSB2aWV3UGF0aC5zcXVhcmVCcmFja2V0c0FyZ3MobmFtZSk7XG4gICAgZm9yICh2YXIgaSA9IHBhdGhzLmxlbmd0aDsgaS0tOykge1xuICAgICAgYmluZEVhY2hQYXRoRXZlbnQoZXZlbnRzLCBwYXRoc1tpXSwgZ2V0TmFtZSwgcGFydGlhbCwgcGFyYW1zKTtcbiAgICB9XG4gICAgLy8gQmluZCB0byBhbnl0aGluZyB1bmRlciB0aGUgcm9vdC4gVGhpcyBpbnMndCB2ZXJ5IGVmZmljZW50LCBidXQgaXRcbiAgICAvLyBzaG91bGQgY292ZXIgdmFyaW91cyBjYXNlcyB0aGF0IHdvdWxkIHJlcXVpcmUgdXBkYXRpbmcgdGhlIGJpbmRpbmdzXG4gICAgLy8gd2hlbiB0aGUgYXJndW1lbnRzIGluc2lkZSBvZiB0aGUgYnJhY2tldHMgY2hhbmdlLCB3aGljaCBJIGRvbid0IGZlZWxcbiAgICAvLyBsaWtlIGZpZ3VyaW5nIG91dCBhdCB0aGUgbW9tZW50XG4gICAgdmFyIGJlZm9yZSA9IG5hbWUuc2xpY2UoMCwgYnJhY2tldEluZGV4KTtcbiAgICBpZiAoYmVmb3JlKSBiaW5kRWFjaFBhdGhFdmVudChldmVudHMsIGJlZm9yZSArICcqJywgZ2V0TmFtZSwgcGFydGlhbCwgcGFyYW1zKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gLyhcXC4qKSguKikvLmV4ZWMobmFtZSk7XG4gIHZhciBwcmVmaXggPSBtYXRjaFsxXSB8fCAnJztcbiAgdmFyIHJlbGF0aXZlTmFtZSA9IG1hdGNoWzJdIHx8ICcnO1xuICB2YXIgc2VnbWVudHMgPSByZWxhdGl2ZU5hbWUuc3BsaXQoJy4nKTtcbiAgLy8gVGhpcyBsb29wIHN0b3BzIGJlZm9yZSByZWFjaGluZyB6ZXJvXG4gIHZhciBzYXZlQmxvY2tQYXRoID0gdHJ1ZTtcbiAgZm9yICh2YXIgaSA9IHNlZ21lbnRzLmxlbmd0aDsgaTsgaS0tKSB7XG4gICAgdmFyIGJpbmROYW1lID0gcHJlZml4ICsgc2VnbWVudHMuc2xpY2UoMCwgaSkuam9pbignLicpO1xuICAgIGJpbmRQYXRoRXZlbnQoZXZlbnRzLCBiaW5kTmFtZSwgZ2V0TmFtZSwgcGFydGlhbCwgcGFyYW1zLCBzYXZlQmxvY2tQYXRoKTtcbiAgICBzYXZlQmxvY2tQYXRoID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGJpbmRFdmVudHMoZXZlbnRzLCBuYW1lLCBwYXJ0aWFsLCBwYXJhbXMpIHtcbiAgaWYgKH5uYW1lLmluZGV4T2YoJygnKSkge1xuICAgIHZhciBhcmdzID0gcGF0aEZuQXJncyhuYW1lKTtcbiAgICBmb3IgKHZhciBpID0gYXJncy5sZW5ndGg7IGktLTspIHtcbiAgICAgIGJpbmRFYWNoUGF0aEV2ZW50KGV2ZW50cywgYXJnc1tpXSArICcqJywgbmFtZSwgcGFydGlhbCwgcGFyYW1zKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGJpbmRFYWNoUGF0aEV2ZW50KGV2ZW50cywgbmFtZSwgbmFtZSwgcGFydGlhbCwgcGFyYW1zKTtcbn1cblxuZnVuY3Rpb24gYmluZEV2ZW50c0J5SWQoZXZlbnRzLCBuYW1lLCBwYXJ0aWFsLCBhdHRycywgbWV0aG9kLCBwcm9wLCBibG9ja1R5cGUpIHtcbiAgZnVuY3Rpb24gcGFyYW1zKHRyaWdnZXJJZCwgYmxvY2tQYXRocywgcGF0aElkKSB7XG4gICAgdmFyIGlkID0gYXR0cnMuX2lkIHx8IGF0dHJzLmlkO1xuICAgIGlmIChibG9ja1R5cGUgJiYgcGF0aElkKSB7XG4gICAgICBibG9ja1BhdGhzW2lkXSA9IHtpZDogcGF0aElkLCB0eXBlOiBibG9ja1R5cGV9O1xuICAgIH1cbiAgICByZXR1cm4gW2lkLCBtZXRob2QsIHByb3BdO1xuICB9XG4gIGJpbmRFdmVudHMoZXZlbnRzLCBuYW1lLCBwYXJ0aWFsLCBwYXJhbXMpO1xufVxuXG5mdW5jdGlvbiBiaW5kRXZlbnRzQnlJZFN0cmluZyhldmVudHMsIG5hbWUsIHBhcnRpYWwsIGF0dHJzLCBtZXRob2QsIHByb3ApIHtcbiAgZnVuY3Rpb24gcGFyYW1zKHRyaWdnZXJJZCkge1xuICAgIHZhciBpZCA9IHRyaWdnZXJJZCB8fCBhdHRycy5faWQgfHwgYXR0cnMuaWQ7XG4gICAgcmV0dXJuIFtpZCwgbWV0aG9kLCBwcm9wXTtcbiAgfVxuICBiaW5kRXZlbnRzKGV2ZW50cywgbmFtZSwgcGFydGlhbCwgcGFyYW1zKTtcbn1cblxuZnVuY3Rpb24gYWRkSWQodmlldywgYXR0cnMpIHtcbiAgaWYgKGF0dHJzLmlkID09IG51bGwpIHtcbiAgICBhdHRycy5pZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGF0dHJzLl9pZCA9IHZpZXcuX3VuaXF1ZUlkKCk7XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoVmFsdWUoaHRtbCwgaSwgdmFsdWUsIGlzQXR0cikge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaSA9IGh0bWwucHVzaCh2YWx1ZSwgJycpIC0gMTtcbiAgfSBlbHNlIHtcbiAgICBodG1sW2ldICs9IGlzQXR0ciA/IGVzY2FwZUF0dHJpYnV0ZSh2YWx1ZSkgOiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaTtcbn1cblxuZnVuY3Rpb24gcmVkdWNlU3RhY2soc3RhY2spIHtcbiAgdmFyIGh0bWwgPSBbJyddXG4gICAgLCBpID0gMFxuICAgICwgYXR0cnMsIGJvb2wsIGl0ZW0sIGtleSwgdmFsdWUsIGosIGxlbjtcblxuICBmb3IgKGogPSAwLCBsZW4gPSBzdGFjay5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgIGl0ZW0gPSBzdGFja1tqXTtcbiAgICBzd2l0Y2ggKGl0ZW1bMF0pIHtcbiAgICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgaHRtbFtpXSArPSAnPCcgKyBpdGVtWzFdO1xuICAgICAgICBhdHRycyA9IGl0ZW1bMl07XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBpZCBhdHRyaWJ1dGUgaXMgcmVuZGVyZWQgZmlyc3RcbiAgICAgICAgaWYgKCdpZCcgaW4gYXR0cnMpIHtcbiAgICAgICAgICBodG1sW2ldICs9ICcgaWQ9JztcbiAgICAgICAgICBpID0gcHVzaFZhbHVlKGh0bWwsIGksIGF0dHJzLmlkLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgICAgICAgIGlmIChrZXkgPT09ICdpZCcpIGNvbnRpbnVlO1xuICAgICAgICAgIHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGJvb2wgPSB2YWx1ZS5ib29sKSB7XG4gICAgICAgICAgICAgIGkgPSBwdXNoVmFsdWUoaHRtbCwgaSwgYm9vbCk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaHRtbFtpXSArPSAnICcgKyBrZXkgKyAnPSc7XG4gICAgICAgICAgICBpID0gcHVzaFZhbHVlKGh0bWwsIGksIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHRtbFtpXSArPSAnICcgKyBrZXk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGh0bWxbaV0gKz0gJz4nO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICBpID0gcHVzaFZhbHVlKGh0bWwsIGksIGl0ZW1bMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgIGh0bWxbaV0gKz0gJzwvJyArIGl0ZW1bMV0gKyAnPic7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWFya2VyJzpcbiAgICAgICAgaHRtbFtpXSArPSAnPCEtLScgKyBpdGVtWzFdO1xuICAgICAgICBpID0gcHVzaFZhbHVlKGh0bWwsIGksIGl0ZW1bMl0uaWQpO1xuICAgICAgICBodG1sW2ldICs9ICctLT4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaHRtbDtcbn1cblxuZnVuY3Rpb24gcmVuZGVyZXIodmlldywgaXRlbXMsIGV2ZW50cywgb25SZW5kZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGN0eCwgbW9kZWwsIHRyaWdnZXJJZCkge1xuICAgIGlmICghbW9kZWwpIG1vZGVsID0gdmlldy5tb2RlbDsgIC8vIE5lZWRlZCwgc2luY2UgbW9kZWwgcGFyYW1ldGVyIGlzIG9wdGlvbmFsXG5cbiAgICBpZiAob25SZW5kZXIpIGN0eCA9IG9uUmVuZGVyKGN0eCk7XG5cbiAgICB2YXIgaHRtbCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgaHRtbCArPSAodHlwZW9mIGl0ZW0gPT09ICdmdW5jdGlvbicpID8gaXRlbShjdHgsIG1vZGVsKSB8fCAnJyA6IGl0ZW07XG4gICAgfVxuICAgIGlmICh2aWV3LmlzU2VydmVyKSByZXR1cm4gaHRtbDtcblxuICAgIHZhciBwYXRoTWFwID0gbW9kZWwuX19wYXRoTWFwO1xuICAgIHZhciBtb2RlbEV2ZW50cyA9IG1vZGVsLl9fZXZlbnRzO1xuICAgIHZhciBibG9ja1BhdGhzID0gbW9kZWwuX19ibG9ja1BhdGhzO1xuICAgIHZhciBkb20gPSBnbG9iYWwuREVSQlkgJiYgZ2xvYmFsLkRFUkJZLmFwcC5kb207XG4gICAgLy8gTm90ZSB0aGF0IHRoZSBldmVudHMgYXJyYXkgY2FuIGdyb3cgZHVyaW5nIHJlbmRlcmluZ1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgZXZlbnQ7XG4gICAgd2hpbGUgKGV2ZW50ID0gZXZlbnRzW2krK10pIHtcbiAgICAgIGV2ZW50KGN0eCwgbW9kZWxFdmVudHMsIGRvbSwgcGF0aE1hcCwgdmlldywgYmxvY2tQYXRocywgdHJpZ2dlcklkKTtcbiAgICB9XG4gICAgcmV0dXJuIGh0bWw7XG4gIH1cbn1cblxuZnVuY3Rpb24gYmluZENvbXBvbmVudEV2ZW50KGNvbXBvbmVudCwgbmFtZSwgbGlzdGVuZXIpIHtcbiAgaWYgKG5hbWUgPT09ICdpbml0JyB8fCBuYW1lID09PSAnY3JlYXRlJykge1xuICAgIGNvbXBvbmVudC5vbmNlKG5hbWUsIGxpc3RlbmVyLmZuKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBFeHRyYSBpbmRpcmVjdGlvbiBhbGxvd3MgbGlzdGVuZXIgdG8gb3ZlcndyaXRlIGl0c2VsZiBhZnRlciBmaXJzdCBydW5cbiAgICBjb21wb25lbnQub24obmFtZSwgZnVuY3Rpb24oKSB7XG4gICAgICBsaXN0ZW5lci5mbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBiaW5kQ29tcG9uZW50RXZlbnRzKGN0eCwgY29tcG9uZW50LCBldmVudHMpIHtcbiAgdmFyIHZpZXcgPSBldmVudHMuJHZpZXdcbiAgICAsIGl0ZW1zID0gZXZlbnRzLiRldmVudHNcbiAgICAsIGxpc3RlbmVyQ3R4ID0gT2JqZWN0LmNyZWF0ZShjdHgpXG4gICAgLCBpLCBpdGVtLCBuYW1lLCBsaXN0ZW5lclxuICAvLyBUaGUgZm5DdHggd2lsbCBpbmNsdWRlIHRoaXMgY29tcG9uZW50LCBidXQgd2Ugd2FudCB0byBlbWl0XG4gIC8vIG9uIHRoZSBwYXJlbnQgY29tcG9uZW50IG9yIGFwcFxuICBsaXN0ZW5lckN0eC4kZm5DdHggPSBsaXN0ZW5lckN0eC4kZm5DdHguc2xpY2UoMCwgLTEpO1xuICBmb3IgKGkgPSBpdGVtcy5sZW5ndGg7IGktLTspIHtcbiAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgbmFtZSA9IGl0ZW1bMF07XG4gICAgbGlzdGVuZXIgPSBmbkxpc3RlbmVyKHZpZXcsIGxpc3RlbmVyQ3R4LCBpdGVtWzJdKTtcbiAgICBiaW5kQ29tcG9uZW50RXZlbnQoY29tcG9uZW50LCBuYW1lLCBsaXN0ZW5lcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50KHZpZXcsIG1vZGVsLCBDb21wb25lbnQsIHNjb3BlLCBjdHgsIG1hY3JvQ3R4KSB7XG4gIHZhciBzY29wZWQgPSBtb2RlbC5zY29wZShzY29wZSk7XG4gIHZhciBtYXJrZXIgPSAnPCEtLScgKyBzY29wZSArICctLT4nO1xuICB2YXIgcHJlZml4ID0gc2NvcGUgKyAnLic7XG4gIHZhciBjb21wb25lbnQgPSBuZXcgQ29tcG9uZW50KHNjb3BlZCwgc2NvcGUpO1xuICB2YXIgcGFyZW50Rm5DdHggPSBtb2RlbC5fX2ZuQ3R4IHx8IGN0eC4kZm5DdHg7XG4gIHZhciBzaWxlbnRDdHggPSBPYmplY3QuY3JlYXRlKGN0eCk7XG4gIHNpbGVudEN0eC4kc2lsZW50ID0gdHJ1ZTtcbiAgdmFyIHNpbGVudE1vZGVsID0gbW9kZWwuc2lsZW50KCk7XG4gIHZhciBpLCBrZXksIHBhdGgsIHZhbHVlLCBpbnN0YW5jZU5hbWUsIGluc3RhbmNlcztcblxuICBjdHguJGZuQ3R4ID0gbW9kZWwuX19mbkN0eCA9IHBhcmVudEZuQ3R4LmNvbmNhdChjb21wb25lbnQpO1xuXG4gIC8vIEhBQ0s6IEVuc3VyZSB0aGF0IHNjb3BlZCBtb2RlbCBoYXMgc29tZXRoaW5nIHNldFxuICBzY29wZWQuc2V0KCckbnVsbCcsIG51bGwpO1xuXG4gIGZvciAoa2V5IGluIG1hY3JvQ3R4KSB7XG4gICAgdmFsdWUgPSBtYWNyb0N0eFtrZXldO1xuICAgIGlmIChrZXkgPT09ICdiaW5kJykge1xuICAgICAgYmluZENvbXBvbmVudEV2ZW50cyhjdHgsIGNvbXBvbmVudCwgdmFsdWUpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS4kbWF0Y2hOYW1lKSB7XG4gICAgICBwYXRoID0gY3R4UGF0aCh2aWV3LCBjdHgsIHZhbHVlLiRtYXRjaE5hbWUpO1xuICAgICAgaWYgKHZhbHVlLiRib3VuZCkge1xuICAgICAgICBzaWxlbnRNb2RlbC5yZWYocHJlZml4ICsga2V5LCBwYXRoLCB7dXBkYXRlSW5kaWNlczogdHJ1ZX0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gZGF0YVZhbHVlKHZpZXcsIGN0eCwgbW9kZWwsIHBhdGgpO1xuICAgICAgc2lsZW50TW9kZWwuc2V0KHByZWZpeCArIGtleSwgdmFsdWUpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgaG93IHRvIGdldCB2YWx1ZSBvZiB0ZW1wbGF0aXplZCBhdHRyaWJ1dGVzXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykgY29udGludWU7XG4gICAgc2lsZW50TW9kZWwuc2V0KHByZWZpeCArIGtleSwgdmFsdWUpO1xuICB9XG5cbiAgaW5zdGFuY2VOYW1lID0gc2NvcGVkLmdldCgnbmFtZScpO1xuICBpZiAoaW5zdGFuY2VOYW1lKSB7XG4gICAgaW5zdGFuY2VzID0gdmlldy5fY29tcG9uZW50SW5zdGFuY2VzW2luc3RhbmNlTmFtZV0gfHxcbiAgICAgICh2aWV3Ll9jb21wb25lbnRJbnN0YW5jZXNbaW5zdGFuY2VOYW1lXSA9IFtdKTtcbiAgICBpbnN0YW5jZXMucHVzaChjb21wb25lbnQpO1xuICB9XG5cbiAgaWYgKGNvbXBvbmVudC5pbml0KSBjb21wb25lbnQuaW5pdChzY29wZWQpO1xuICBjb21wb25lbnQuZW1pdCgnaW5pdCcsIGNvbXBvbmVudCk7XG5cbiAgaWYgKHZpZXcuaXNTZXJ2ZXIgfHwgY3R4LiRzaWxlbnQpIHJldHVybiBtYXJrZXI7XG5cbiAgdmFyIGFwcCA9IGdsb2JhbC5ERVJCWSAmJiBnbG9iYWwuREVSQlkuYXBwXG4gICAgLCBkb20gPSBhcHAuZG9tXG4gIGNvbXBvbmVudC5kb20gPSBkb207XG4gIGNvbXBvbmVudC5oaXN0b3J5ID0gYXBwLmhpc3Rvcnk7XG5cbiAgdmFyIHVuY3JlYXRlZCA9IG5ldyBVbmNyZWF0ZWRDb21wb25lbnQoY29tcG9uZW50LCBzY29wZWQsIGRvbSwgc2NvcGUsIGN0eCk7XG4gIHZpZXcuX3VuY3JlYXRlZC5wdXNoKHVuY3JlYXRlZCk7XG5cbiAgcmV0dXJuIG1hcmtlcjtcbn1cblxuZnVuY3Rpb24gVW5jcmVhdGVkQ29tcG9uZW50KGNvbXBvbmVudCwgbW9kZWwsIGRvbSwgc2NvcGUsIGN0eCkge1xuICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICB0aGlzLmRvbSA9IGRvbTtcbiAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICB0aGlzLmN0eCA9IGN0eDtcbn1cblVuY3JlYXRlZENvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIC8vIFRPRE86IEZpZ3VyZSBvdXQgdW5kZXJseWluZyBpc3N1ZSBhbmQgcmVtb3ZlXG4gIC8vIElmIGZvciBzb21lIHJlYXNvbiwgY29tcG9uZW50J3Mgc2NvcGVkIG1vZGVsIGRvZXMgbm90IGhhdmUgYW55IGRhdGEsXG4gIC8vIGRvIG5vdGhpbmcuIE5vdCBzdXJlIHdoeSBpdCB3b3VsZCBnZXQgdG8gdGhpcyBzdGF0ZSwgYnV0IGl0IGRvZXMuXG4gIGlmICghdGhpcy5tb2RlbC5nZXQoKSkgcmV0dXJuO1xuXG4gIC8vIERlc3Ryb3kgaW4gY2FzZSBjb21wb25lbnQgd2FzIGNyZWF0ZWQgYW5kIHJlcGxhY2VkIHdpdGhpbiByZW5kZXJpbmdcbiAgaWYgKCF0aGlzLmRvbS5tYXJrZXIodGhpcy5zY29wZSkpIHtcbiAgICB0aGlzLmNvbXBvbmVudC5lbWl0KCdkZXN0cm95Jyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5kb20uYWRkQ29tcG9uZW50KHRoaXMuY3R4LCB0aGlzLmNvbXBvbmVudCk7XG4gIGlmICh0aGlzLmNvbXBvbmVudC5jcmVhdGUpIHRoaXMuY29tcG9uZW50LmNyZWF0ZSh0aGlzLm1vZGVsLCB0aGlzLmNvbXBvbmVudC5kb20pO1xuICB0aGlzLmNvbXBvbmVudC5lbWl0KCdjcmVhdGUnLCB0aGlzLmNvbXBvbmVudCk7XG59O1xuXG5mdW5jdGlvbiBmbHVzaFVuY3JlYXRlZCgpIHtcbiAgdmFyIHVuY3JlYXRlZDtcbiAgd2hpbGUgKHVuY3JlYXRlZCA9IHRoaXMuX3VuY3JlYXRlZC5zaGlmdCgpKSB7XG4gICAgdW5jcmVhdGVkLmNyZWF0ZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBleHRlbmRDdHgodmlldywgY3R4LCB2YWx1ZSwgbmFtZSwgYWxpYXMsIGlzRWFjaCkge1xuICB2YXIgcGF0aCA9IGN0eFBhdGgodmlldywgY3R4LCBuYW1lKVxuICAgICwgYWxpYXNlcztcbiAgY3R4ID0gZXh0ZW5kKGN0eCwgdmFsdWUpO1xuICBjdHhbJ3RoaXMnXSA9IHZhbHVlO1xuICBpZiAoYWxpYXMpIHtcbiAgICBhbGlhc2VzID0gY3R4LiRhbGlhc2VzID0gT2JqZWN0LmNyZWF0ZShjdHguJGFsaWFzZXMpO1xuICAgIGFsaWFzZXNbYWxpYXNdID0gY3R4LiRwYXRocy5sZW5ndGg7XG4gICAgaWYgKGlzRWFjaCkgYWxpYXNlc1thbGlhc10rKztcbiAgfVxuICBpZiAocGF0aCkge1xuICAgIGN0eC4kcGF0aHMgPSBbcGF0aF0uY29uY2F0KGN0eC4kcGF0aHMpO1xuICB9XG4gIGN0eC4kcGF0aElkcyA9IE9iamVjdC5jcmVhdGUoY3R4LiRwYXRoSWRzKTtcbiAgcmV0dXJuIGN0eDtcbn1cblxuZnVuY3Rpb24gcGFydGlhbFZhbHVlKHZpZXcsIGN0eCwgbW9kZWwsIG5hbWUsIHZhbHVlLCBsaXN0ZW5lcikge1xuICBpZiAobGlzdGVuZXIpIHJldHVybiB2YWx1ZTtcbiAgcmV0dXJuIG5hbWUgPyBkYXRhVmFsdWUodmlldywgY3R4LCBtb2RlbCwgbmFtZSkgOiB0cnVlO1xufVxuXG5mdW5jdGlvbiBwYXJ0aWFsRm4odmlldywgbmFtZSwgdHlwZSwgYWxpYXMsIHJlbmRlciwgbnMsIG1hY3JvQ3R4KSB7XG4gIGZ1bmN0aW9uIHBhcnRpYWxCbG9jayAoY3R4LCBtb2RlbCwgdHJpZ2dlcklkLCB2YWx1ZSwgaW5kZXgsIGxpc3RlbmVyKSB7XG4gICAgLy8gSW5oZXJpdCAmIHJlbmRlciBhdHRyaWJ1dGUgY29udGV4dCB2YWx1ZXNcbiAgICB2YXIgcmVuZGVyTWFjcm9DdHggPSB7fVxuICAgICAgLCBwYXJlbnRNYWNyb0N0eCA9IGN0eC4kbWFjcm9DdHhcbiAgICAgICwgbWVyZ2VkTWFjcm9DdHggPSBtYWNyb0N0eFxuICAgICAgLCBrZXksIHZhbCwgbWF0Y2hOYW1lXG4gICAgaWYgKG1hY3JvQ3R4LmluaGVyaXQpIHtcbiAgICAgIG1lcmdlZE1hY3JvQ3R4ID0ge307XG4gICAgICBkZXJieS51dGlsLm1lcmdlSW50byhtZXJnZWRNYWNyb0N0eCwgcGFyZW50TWFjcm9DdHgpO1xuICAgICAgZGVyYnkudXRpbC5tZXJnZUludG8obWVyZ2VkTWFjcm9DdHgsIG1hY3JvQ3R4KTtcbiAgICAgIGRlbGV0ZSBtZXJnZWRNYWNyb0N0eC5pbmhlcml0O1xuICAgIH1cbiAgICBmb3IgKGtleSBpbiBtZXJnZWRNYWNyb0N0eCkge1xuICAgICAgdmFsID0gbWVyZ2VkTWFjcm9DdHhba2V5XTtcbiAgICAgIGlmICh2YWwgJiYgdmFsLiRtYXRjaE5hbWUpIHtcbiAgICAgICAgbWF0Y2hOYW1lID0gY3R4UGF0aCh2aWV3LCBjdHgsIHZhbC4kbWF0Y2hOYW1lKTtcbiAgICAgICAgaWYgKG1hdGNoTmFtZS5jaGFyQXQoMCkgPT09ICdAJykge1xuICAgICAgICAgIHZhbCA9IGRhdGFWYWx1ZSh2aWV3LCBjdHgsIG1vZGVsLCBtYXRjaE5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IGRlcmJ5LnV0aWwuY29weU9iamVjdCh2YWwpO1xuICAgICAgICAgIHZhbC4kbWF0Y2hOYW1lID0gbWF0Y2hOYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZW5kZXJNYWNyb0N0eFtrZXldID0gdmFsO1xuICAgIH1cblxuICAgIC8vIEZpbmQgdGhlIGFwcHJvcHJpYXRlIHBhcnRpYWwgdGVtcGxhdGVcbiAgICB2YXIgcGFydGlhbE5zLCBwYXJ0aWFsTmFtZSwgcGFydGlhbE9wdGlvbmFsLCBhcnI7XG4gICAgaWYgKG5hbWUgPT09ICdkZXJieTp2aWV3Jykge1xuICAgICAgcGFydGlhbE5zID0gbWVyZ2VkTWFjcm9DdHgubnMgfHwgdmlldy5fc2VsZk5zO1xuICAgICAgcGFydGlhbE5hbWUgPSBtZXJnZWRNYWNyb0N0eC52aWV3O1xuICAgICAgcGFydGlhbE9wdGlvbmFsID0gbWVyZ2VkTWFjcm9DdHgub3B0aW9uYWw7XG4gICAgICBpZiAoIXBhcnRpYWxOYW1lKSB0aHJvdyBuZXcgRXJyb3IoJzxkZXJieTp2aWV3PiB0YWcgd2l0aG91dCBhIFwidmlld1wiIGF0dHJpYnV0ZScpXG4gICAgICBpZiAocGFydGlhbE5zLiRtYXRjaE5hbWUpIHtcbiAgICAgICAgcGFydGlhbE5zID0gZGF0YVZhbHVlKHZpZXcsIGN0eCwgbW9kZWwsIHBhcnRpYWxOcy4kbWF0Y2hOYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0aWFsTmFtZS4kbWF0Y2hOYW1lKSB7XG4gICAgICAgIHBhcnRpYWxOYW1lID0gZGF0YVZhbHVlKHZpZXcsIGN0eCwgbW9kZWwsIHBhcnRpYWxOYW1lLiRtYXRjaE5hbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhcnIgPSBzcGxpdFBhcnRpYWwobmFtZSk7XG4gICAgICBwYXJ0aWFsTnMgPSBhcnJbMF07XG4gICAgICBwYXJ0aWFsTmFtZSA9IGFyclsxXTtcbiAgICB9XG4gICAgLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gdXNpbmcgPGRlcmJ5OnZpZXcgdmlldz17ey4uLn19PlxuICAgIGlmICh0eXBlb2YgcGFydGlhbE5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBhcnRpYWxOYW1lID0gcGFydGlhbE5hbWUoT2JqZWN0LmNyZWF0ZShjdHgpLCBtb2RlbCk7XG4gICAgfVxuICAgIHZhciBwYXJ0aWFsVmlldyA9IG5zVmlldyh2aWV3LCBwYXJ0aWFsTnMpXG4gICAgICAsIHJlbmRlciA9IHBhcnRpYWxWaWV3Ll9maW5kKHBhcnRpYWxOYW1lLCBucywgcGFydGlhbE9wdGlvbmFsKVxuICAgICAgLCBDb21wb25lbnQgPSBwYXJ0aWFsVmlldy5fY29tcG9uZW50Q29uc3RydWN0b3IocGFydGlhbE5hbWUpXG4gICAgICAsIHJlbmRlckN0eCwgc2NvcGUsIG91dCwgbWFya2VyXG5cbiAgICAvLyBQcmVwYXJlIHRoZSBjb250ZXh0IGZvciByZW5kZXJpbmdcbiAgICBpZiAoQ29tcG9uZW50KSB7XG4gICAgICBzY29wZSA9ICckY29tcG9uZW50cy4nICsgdmlldy5fdW5pcXVlSWQoKTtcbiAgICAgIHJlbmRlckN0eCA9IGV4dGVuZEN0eCh2aWV3LCBjdHgsIG51bGwsIHNjb3BlLCAnc2VsZicpO1xuICAgICAgcmVuZGVyQ3R4LiRlbGVtZW50cyA9IHt9O1xuICAgICAgbWFya2VyID0gY3JlYXRlQ29tcG9uZW50KHZpZXcsIG1vZGVsLCBDb21wb25lbnQsIHNjb3BlLCByZW5kZXJDdHgsIHJlbmRlck1hY3JvQ3R4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVuZGVyQ3R4ID0gT2JqZWN0LmNyZWF0ZShjdHgpO1xuICAgIH1cbiAgICByZW5kZXJDdHguJG1hY3JvQ3R4ID0gcmVuZGVyTWFjcm9DdHg7XG5cbiAgICBvdXQgPSByZW5kZXIocmVuZGVyQ3R4LCBtb2RlbCk7XG4gICAgaWYgKENvbXBvbmVudCkge1xuICAgICAgaWYgKG1vZGVsLl9fZm5DdHgpIHtcbiAgICAgICAgbW9kZWwuX19mbkN0eCA9IG1vZGVsLl9fZm5DdHguc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgICAgb3V0ID0gbWFya2VyICsgb3V0O1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgZnVuY3Rpb24gd2l0aEJsb2NrKGN0eCwgbW9kZWwsIHRyaWdnZXJJZCwgdmFsdWUsIGluZGV4LCBsaXN0ZW5lcikge1xuICAgIHZhbHVlID0gcGFydGlhbFZhbHVlKHZpZXcsIGN0eCwgbW9kZWwsIG5hbWUsIHZhbHVlLCBsaXN0ZW5lcik7XG4gICAgdmFyIHJlbmRlckN0eCA9IGV4dGVuZEN0eCh2aWV3LCBjdHgsIHZhbHVlLCBuYW1lLCBhbGlhcyk7XG4gICAgcmV0dXJuIHJlbmRlcihyZW5kZXJDdHgsIG1vZGVsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlmQmxvY2soY3R4LCBtb2RlbCwgdHJpZ2dlcklkLCB2YWx1ZSwgaW5kZXgsIGxpc3RlbmVyKSB7XG4gICAgdmFsdWUgPSBwYXJ0aWFsVmFsdWUodmlldywgY3R4LCBtb2RlbCwgbmFtZSwgdmFsdWUsIGxpc3RlbmVyKTtcbiAgICBpZiAoIShBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmxlbmd0aCA6IHZhbHVlKSkgcmV0dXJuO1xuICAgIHZhciByZW5kZXJDdHggPSBleHRlbmRDdHgodmlldywgY3R4LCB2YWx1ZSwgbmFtZSwgYWxpYXMpO1xuICAgIHJldHVybiByZW5kZXIocmVuZGVyQ3R4LCBtb2RlbCk7XG4gIH1cblxuICBmdW5jdGlvbiB1bmxlc3NCbG9jayhjdHgsIG1vZGVsLCB0cmlnZ2VySWQsIHZhbHVlLCBpbmRleCwgbGlzdGVuZXIpIHtcbiAgICB2YWx1ZSA9IHBhcnRpYWxWYWx1ZSh2aWV3LCBjdHgsIG1vZGVsLCBuYW1lLCB2YWx1ZSwgbGlzdGVuZXIpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmxlbmd0aCA6IHZhbHVlKSByZXR1cm47XG4gICAgdmFyIHJlbmRlckN0eCA9IGV4dGVuZEN0eCh2aWV3LCBjdHgsIHZhbHVlLCBuYW1lLCBhbGlhcyk7XG4gICAgcmV0dXJuIHJlbmRlcihyZW5kZXJDdHgsIG1vZGVsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVhY2hCbG9jayhjdHgsIG1vZGVsLCB0cmlnZ2VySWQsIHZhbHVlLCBpbmRleCwgbGlzdGVuZXIpIHtcbiAgICB2YWx1ZSA9IHBhcnRpYWxWYWx1ZSh2aWV3LCBjdHgsIG1vZGVsLCBuYW1lLCB2YWx1ZSwgbGlzdGVuZXIpO1xuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG5cbiAgICBpZiAobGlzdGVuZXIgJiYgIWlzQXJyYXkpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSByZXR1cm47XG4gICAgICB2YXIgbGlzdEN0eCA9IGV4dGVuZEN0eCh2aWV3LCBjdHgsIG51bGwsIG5hbWUsIGFsaWFzLCB0cnVlKTtcbiAgICAgIHZhciBpdGVtUGF0aCA9IGxpc3RDdHguJHBhdGhzWzBdICsgJy4nICsgaW5kZXg7XG4gICAgICB2YXIgaXRlbSA9IHBhcnRpYWxWYWx1ZSh2aWV3LCBsaXN0Q3R4LCBtb2RlbCwgaXRlbVBhdGgsIHZhbHVlLCBsaXN0ZW5lcik7XG4gICAgICByZW5kZXJDdHggPSBleHRlbmQobGlzdEN0eCwgaXRlbSk7XG4gICAgICByZW5kZXJDdHhbJ3RoaXMnXSA9IGl0ZW07XG4gICAgICByZW5kZXJDdHguJGluZGljZXMgPSBbaW5kZXhdLmNvbmNhdChyZW5kZXJDdHguJGluZGljZXMpO1xuICAgICAgcmVuZGVyQ3R4LiRpbmRleCA9IGluZGV4O1xuICAgICAgcmVuZGVyQ3R4LiRwYXRocyA9IFtpdGVtUGF0aF0uY29uY2F0KHJlbmRlckN0eC4kcGF0aHMpO1xuICAgICAgcmV0dXJuIHJlbmRlcihyZW5kZXJDdHgsIG1vZGVsKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzQXJyYXkgfHwgIXZhbHVlLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgdmFyIGxpc3RDdHggPSBleHRlbmRDdHgodmlldywgY3R4LCBudWxsLCBuYW1lLCBhbGlhcywgdHJ1ZSk7XG5cbiAgICB2YXIgb3V0ID0gJyc7XG4gICAgdmFyIGluZGljZXMgPSBsaXN0Q3R4LiRpbmRpY2VzO1xuICAgIHZhciBwYXRocyA9IGxpc3RDdHguJHBhdGhzO1xuICAgIHZhciBiYXNlUGF0aCA9IHBhdGhzWzBdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSB2YWx1ZVtpXTtcbiAgICAgIHZhciByZW5kZXJDdHggPSBleHRlbmQobGlzdEN0eCwgaXRlbSk7XG4gICAgICByZW5kZXJDdHhbJ3RoaXMnXSA9IGl0ZW07XG4gICAgICByZW5kZXJDdHguJGluZGljZXMgPSBbaV0uY29uY2F0KGluZGljZXMpO1xuICAgICAgcmVuZGVyQ3R4LiRpbmRleCA9IGk7XG4gICAgICByZW5kZXJDdHguJHBhdGhzID0gW2Jhc2VQYXRoICsgJy4nICsgaV0uY29uY2F0KHBhdGhzKTtcbiAgICAgIG91dCArPSAoaXRlbSA9PT0gdm9pZCAwKSA/XG4gICAgICAgICc8IS0tZW1wdHktLT4nIDpcbiAgICAgICAgcmVuZGVyKHJlbmRlckN0eCwgbW9kZWwpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgdmFyIGJsb2NrID1cbiAgICAgICh0eXBlID09PSAncGFydGlhbCcpID8gcGFydGlhbEJsb2NrXG4gICAgOiAodHlwZSA9PT0gJ3dpdGgnIHx8IHR5cGUgPT09ICdlbHNlJykgPyB3aXRoQmxvY2tcbiAgICA6ICh0eXBlID09PSAnaWYnIHx8IHR5cGUgPT09ICdlbHNlIGlmJykgPyBpZkJsb2NrXG4gICAgOiAodHlwZSA9PT0gJ3VubGVzcycpID8gdW5sZXNzQmxvY2tcbiAgICA6ICh0eXBlID09PSAnZWFjaCcpID8gZWFjaEJsb2NrXG4gICAgOiBudWxsXG5cbiAgaWYgKCFibG9jaykgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGJsb2NrIHR5cGU6ICcgKyB0eXBlKTtcbiAgYmxvY2sudHlwZSA9IHR5cGU7XG4gIHJldHVybiBibG9jaztcbn1cblxudmFyIG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBhcnJheVRvU3RyaW5nID0gQXJyYXkucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiB2YWx1ZUJpbmRpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6XG4gICAgKHZhbHVlLnRvU3RyaW5nID09PSBvYmplY3RUb1N0cmluZyB8fCB2YWx1ZS50b1N0cmluZyA9PT0gYXJyYXlUb1N0cmluZykgP1xuICAgIEpTT04uc3RyaW5naWZ5KHZhbHVlKSA6IHZhbHVlO1xufVxuXG5mdW5jdGlvbiB2YWx1ZVRleHQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlQmluZGluZyh2YWx1ZSkudG9TdHJpbmcoKTtcbn1cblxuZnVuY3Rpb24gdGV4dEZuKHZpZXcsIG5hbWUsIGVzY2FwZSwgZm9yY2UpIHtcbiAgdmFyIGZpbHRlciA9IGVzY2FwZSA/IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGVzY2FwZSh2YWx1ZVRleHQodmFsdWUpKTtcbiAgfSA6IHZhbHVlVGV4dDtcbiAgcmV0dXJuIGZ1bmN0aW9uKGN0eCwgbW9kZWwpIHtcbiAgICByZXR1cm4gZGF0YVZhbHVlKHZpZXcsIGN0eCwgbW9kZWwsIG5hbWUsIGZpbHRlciwgZm9yY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNlY3Rpb25Gbih2aWV3LCBxdWV1ZSkge1xuICB2YXIgcmVuZGVyID0gcmVuZGVyZXIodmlldywgcmVkdWNlU3RhY2socXVldWUuc3RhY2spLCBxdWV1ZS5ldmVudHMpO1xuICB2YXIgYmxvY2sgPSBxdWV1ZS5ibG9jaztcbiAgcmV0dXJuIHBhcnRpYWxGbih2aWV3LCBibG9jay5uYW1lLCBibG9jay50eXBlLCBibG9jay5hbGlhcywgcmVuZGVyKTtcbn1cblxuZnVuY3Rpb24gYmxvY2tGbih2aWV3LCBzZWN0aW9ucykge1xuICB2YXIgbGVuID0gc2VjdGlvbnMubGVuZ3RoO1xuICBpZiAoIWxlbikgcmV0dXJuO1xuICBpZiAobGVuID09PSAxKSB7XG4gICAgcmV0dXJuIHNlY3Rpb25Gbih2aWV3LCBzZWN0aW9uc1swXSk7XG5cbiAgfSBlbHNlIHtcbiAgICB2YXIgZm5zID0gW11cbiAgICAgICwgaSwgb3V0O1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZm5zLnB1c2goc2VjdGlvbkZuKHZpZXcsIHNlY3Rpb25zW2ldKSk7XG4gICAgfVxuICAgIG91dCA9IGZ1bmN0aW9uKGN0eCwgbW9kZWwsIHRyaWdnZXJJZCwgdmFsdWUsIGluZGV4LCBsaXN0ZW5lcikge1xuICAgICAgdmFyIG91dDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBvdXQgPSBmbnNbaV0oY3R4LCBtb2RlbCwgdHJpZ2dlcklkLCB2YWx1ZSwgaW5kZXgsIGxpc3RlbmVyKTtcbiAgICAgICAgaWYgKG91dCAhPSBudWxsKSByZXR1cm4gb3V0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlTWFya3VwKHR5cGUsIGF0dHIsIHRhZ05hbWUsIGV2ZW50cywgYXR0cnMsIHZhbHVlKSB7XG4gIHZhciBwYXJzZXIgPSBtYXJrdXBbdHlwZV1bYXR0cl1cbiAgICAsIGFueU91dCwgYW55UGFyc2VyLCBlbE91dCwgZWxQYXJzZXIsIG91dDtcbiAgaWYgKCFwYXJzZXIpIHJldHVybjtcbiAgaWYgKGFueVBhcnNlciA9IHBhcnNlclsnKiddKSB7XG4gICAgYW55T3V0ID0gYW55UGFyc2VyKGV2ZW50cywgYXR0cnMsIHZhbHVlKTtcbiAgfVxuICBpZiAoZWxQYXJzZXIgPSBwYXJzZXJbdGFnTmFtZV0pIHtcbiAgICBlbE91dCA9IGVsUGFyc2VyKGV2ZW50cywgYXR0cnMsIHZhbHVlKTtcbiAgfVxuICBvdXQgPSBhbnlPdXQgPyBleHRlbmQoYW55T3V0LCBlbE91dCkgOiBlbE91dDtcbiAgaWYgKG91dCAmJiBvdXQuZGVsKSBkZWxldGUgYXR0cnNbYXR0cl07XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIHB1c2hUZXh0KHN0YWNrLCB0ZXh0KSB7XG4gIGlmICh0ZXh0KSBzdGFjay5wdXNoKFsndGV4dCcsIHRleHRdKTtcbn1cblxuZnVuY3Rpb24gcHVzaFZhckZuKHZpZXcsIHN0YWNrLCBmbiwgbmFtZSwgZXNjYXBlRm4pIHtcbiAgaWYgKGZuKSB7XG4gICAgcHVzaFRleHQoc3RhY2ssIGZuKTtcbiAgfSBlbHNlIHtcbiAgICBwdXNoVGV4dChzdGFjaywgdGV4dEZuKHZpZXcsIG5hbWUsIGVzY2FwZUZuKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNQYXJ0aWFsKHZpZXcsIHRhZ05hbWUpIHtcbiAgaWYgKHRhZ05hbWUgPT09ICdkZXJieTp2aWV3JykgcmV0dXJuIHRydWU7XG4gIHZhciBzcGxpdCA9IHNwbGl0UGFydGlhbCh0YWdOYW1lKTtcbiAgaWYgKCFzcGxpdCkgcmV0dXJuIGZhbHNlO1xuICB2YXIgdGFnTnMgPSBzcGxpdFswXTtcbiAgcmV0dXJuIChcbiAgICB0YWdOcyA9PT0gJ2FwcCcgfHxcbiAgICB0YWdOcyA9PT0gJ2xpYicgfHxcbiAgICAhIWxpYnJhcnlGb3JOcyh2aWV3LCB0YWdOcylcbiAgKTtcbn1cblxuZnVuY3Rpb24gaXNQYXJ0aWFsU2VjdGlvbih0YWdOYW1lKSB7XG4gIHJldHVybiB0YWdOYW1lLmNoYXJBdCgwKSA9PT0gJ0AnO1xufVxuXG5mdW5jdGlvbiBwYXJ0aWFsU2VjdGlvbk5hbWUodGFnTmFtZSkge1xuICByZXR1cm4gaXNQYXJ0aWFsU2VjdGlvbih0YWdOYW1lKSA/IHRhZ05hbWUuc2xpY2UoMSkgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBsaWJyYXJ5Rm9yTnModmlldywgbnMpIHtcbiAgdmFyIGxpYnJhcnkgPSB2aWV3Ll9saWJyYXJpZXMubWFwW25zXTtcbiAgaWYgKGxpYnJhcnkpIHJldHVybiBsaWJyYXJ5O1xuICBpZiAodmlldy5wYXJlbnQpIHJldHVybiB2aWV3LnBhcmVudC52aWV3Ll9saWJyYXJpZXMubWFwW25zXTtcbn1cblxuZnVuY3Rpb24gbnNWaWV3KHZpZXcsIG5zKSB7XG4gIGlmIChucyA9PT0gdmlldy5fc2VsZk5zKSByZXR1cm4gdmlldztcbiAgaWYgKHZpZXcucGFyZW50ICYmIG5zID09PSB2aWV3LnBhcmVudC52aWV3Ll9zZWxmTnMpIHJldHVybiB2aWV3LnBhcmVudC52aWV3O1xuICB2YXIgbGlicmFyeSA9IGxpYnJhcnlGb3JOcyh2aWV3LCBucyk7XG4gIGlmICghbGlicmFyeSkgdGhyb3cgbmV3IEVycm9yKCdObyBsaWJyYXJ5IGZvdW5kIHdpdGggbmFtZXNwYWNlICcgKyBucyk7XG4gIHZhciBwYXJ0aWFsVmlldyA9IGxpYnJhcnkudmlldztcbiAgcGFydGlhbFZpZXcuX3VuaXF1ZUlkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZpZXcuX3VuaXF1ZUlkKCk7XG4gIH07XG4gIHBhcnRpYWxWaWV3Lm1vZGVsID0gdmlldy5tb2RlbDtcbiAgcGFydGlhbFZpZXcuX3VuY3JlYXRlZCA9IHZpZXcuX3VuY3JlYXRlZDtcbiAgcmV0dXJuIHBhcnRpYWxWaWV3O1xufVxuXG5mdW5jdGlvbiBzcGxpdFBhcnRpYWwocGFydGlhbCkge1xuICB2YXIgaSA9IHBhcnRpYWwuaW5kZXhPZignOicpO1xuICBpZiAoaSA9PT0gLTEpIHJldHVybjtcbiAgdmFyIHBhcnRpYWxOcyA9IHBhcnRpYWwuc2xpY2UoMCwgaSk7XG4gIHZhciBwYXJ0aWFsTmFtZSA9IHBhcnRpYWwuc2xpY2UoaSArIDEpO1xuICByZXR1cm4gW3BhcnRpYWxOcywgcGFydGlhbE5hbWVdO1xufVxuXG5mdW5jdGlvbiBmaW5kQ29tcG9uZW50KHZpZXcsIHBhcnRpYWwsIG5zKSB7XG4gIHZhciBhcnIgPSBzcGxpdFBhcnRpYWwocGFydGlhbClcbiAgICAsIHBhcnRpYWxOcyA9IGFyclswXVxuICAgICwgcGFydGlhbE5hbWUgPSBhcnJbMV1cbiAgICAsIHBhcnRpYWxWaWV3ID0gbnNWaWV3KHZpZXcsIHBhcnRpYWxOcylcbiAgcmV0dXJuIHBhcnRpYWxWaWV3Ll9maW5kKHBhcnRpYWxOYW1lLCBucyk7XG59XG5cbmZ1bmN0aW9uIGlzVm9pZENvbXBvbmVudCh2aWV3LCBwYXJ0aWFsLCBucykge1xuICBpZiAocGFydGlhbCA9PT0gJ2RlcmJ5OnZpZXcnKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuICFmaW5kQ29tcG9uZW50KHZpZXcsIHBhcnRpYWwsIG5zKS5ub252b2lkO1xufVxuXG5mdW5jdGlvbiBwdXNoVmFyKHZpZXcsIG5zLCBzdGFjaywgZXZlbnRzLCByZW1haW5kZXIsIG1hdGNoLCBmbikge1xuICB2YXIgbmFtZSA9IG1hdGNoLm5hbWVcbiAgICAsIHBhcnRpYWwgPSBtYXRjaC5wYXJ0aWFsXG4gICAgLCBlc2NhcGVGbiA9IG1hdGNoLmVzY2FwZWQgJiYgZXNjYXBlSHRtbFxuICAgICwgYXR0ciwgYXR0cnMsIGJvdW5kT3V0LCBsYXN0LCB0YWdOYW1lLCB3cmFwO1xuXG4gIGlmIChwYXJ0aWFsKSB7XG4gICAgZm4gPSBwYXJ0aWFsRm4odmlldywgcGFydGlhbCwgJ3BhcnRpYWwnLCBudWxsLCBudWxsLCBucywgbWF0Y2gubWFjcm9DdHgpO1xuICB9XG5cbiAgZWxzZSBpZiAobWF0Y2guYm91bmQpIHtcbiAgICBsYXN0ID0gbGFzdEl0ZW0oc3RhY2spO1xuICAgIHdyYXAgPSBtYXRjaC5wcmUgfHxcbiAgICAgICFsYXN0IHx8XG4gICAgICAobGFzdFswXSAhPT0gJ3N0YXJ0JykgfHxcbiAgICAgIGlzVm9pZCh0YWdOYW1lID0gbGFzdFsxXSkgfHxcbiAgICAgIHdyYXBSZW1haW5kZXIodGFnTmFtZSwgcmVtYWluZGVyKTtcblxuICAgIGlmICh3cmFwKSB7XG4gICAgICBzdGFjay5wdXNoKFsnbWFya2VyJywgJycsIGF0dHJzID0ge31dKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXR0cnMgPSBsYXN0WzJdO1xuICAgICAgZm9yIChhdHRyIGluIGF0dHJzKSB7XG4gICAgICAgIHBhcnNlTWFya3VwKCdib3VuZFBhcmVudCcsIGF0dHIsIHRhZ05hbWUsIGV2ZW50cywgYXR0cnMsIG1hdGNoKTtcbiAgICAgIH1cbiAgICAgIGJvdW5kT3V0ID0gcGFyc2VNYXJrdXAoJ2JvdW5kUGFyZW50JywgJyonLCB0YWdOYW1lLCBldmVudHMsIGF0dHJzLCBtYXRjaCk7XG4gICAgICBpZiAoYm91bmRPdXQpIHtcbiAgICAgICAgYmluZEV2ZW50c0J5SWQoZXZlbnRzLCBuYW1lLCBudWxsLCBhdHRycywgYm91bmRPdXQubWV0aG9kLCBib3VuZE91dC5wcm9wZXJ0eSk7XG4gICAgICB9XG4gICAgfVxuICAgIGFkZElkKHZpZXcsIGF0dHJzKTtcblxuICAgIGlmICghYm91bmRPdXQpIHtcbiAgICAgIGJpbmRFdmVudHNCeUlkKGV2ZW50cywgbmFtZSwgZm4sIGF0dHJzLCAnaHRtbCcsICFmbiAmJiBlc2NhcGVGbiwgbWF0Y2gudHlwZSk7XG4gICAgfVxuICB9XG5cbiAgcHVzaFZhckZuKHZpZXcsIHN0YWNrLCBmbiwgbmFtZSwgZXNjYXBlRm4pO1xuICBpZiAod3JhcCkge1xuICAgIHN0YWNrLnB1c2goW1xuICAgICAgJ21hcmtlcidcbiAgICAsICckJ1xuICAgICwgeyBpZDogZnVuY3Rpb24oKSB7IHJldHVybiBhdHRycy5faWQgfSB9XG4gICAgXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaFZhclN0cmluZyh2aWV3LCBucywgc3RhY2ssIGV2ZW50cywgcmVtYWluZGVyLCBtYXRjaCwgZm4pIHtcbiAgdmFyIG5hbWUgPSBtYXRjaC5uYW1lXG4gICAgLCBlc2NhcGVGbiA9ICFtYXRjaC5lc2NhcGVkICYmIHVuZXNjYXBlRW50aXRpZXM7XG4gIGZ1bmN0aW9uIGJpbmRPbmNlKGN0eCkge1xuICAgIGN0eC4kb25CaW5kKGV2ZW50cywgbmFtZSk7XG4gICAgYmluZE9uY2UgPSBlbXB0eTtcbiAgfVxuICBpZiAobWF0Y2guYm91bmQpIHtcbiAgICBldmVudHMucHVzaChmdW5jdGlvbihjdHgpIHtcbiAgICAgIGJpbmRPbmNlKGN0eCk7XG4gICAgfSk7XG4gIH1cbiAgcHVzaFZhckZuKHZpZXcsIHN0YWNrLCBmbiwgbmFtZSwgZXNjYXBlRm4pO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1hdGNoRXJyb3IodGV4dCwgbWVzc2FnZSkge1xuICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSArICdcXG5cXG4nICsgdGV4dCArICdcXG4nKTtcbn1cblxuZnVuY3Rpb24gb25CbG9jayhzdGFydCwgZW5kLCBibG9jaywgcXVldWVzLCBjYWxsYmFja3MpIHtcbiAgdmFyIGxhc3RRdWV1ZSwgcXVldWU7XG4gIGlmIChlbmQpIHtcbiAgICBsYXN0UXVldWUgPSBxdWV1ZXMucG9wKCk7XG4gICAgcXVldWUgPSBsYXN0SXRlbShxdWV1ZXMpO1xuICAgIHF1ZXVlLnNlY3Rpb25zLnB1c2gobGFzdFF1ZXVlKTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZSA9IGxhc3RJdGVtKHF1ZXVlcyk7XG4gIH1cblxuICBpZiAoc3RhcnQpIHtcbiAgICBxdWV1ZSA9IHtcbiAgICAgIHN0YWNrOiBbXVxuICAgICwgZXZlbnRzOiBbXVxuICAgICwgYmxvY2s6IGJsb2NrXG4gICAgLCBzZWN0aW9uczogW11cbiAgICB9O1xuICAgIHF1ZXVlcy5wdXNoKHF1ZXVlKTtcbiAgICBjYWxsYmFja3Mub25TdGFydChxdWV1ZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGVuZCkge1xuICAgICAgY2FsbGJhY2tzLm9uU3RhcnQocXVldWUpO1xuICAgICAgY2FsbGJhY2tzLm9uRW5kKHF1ZXVlLnNlY3Rpb25zKTtcbiAgICAgIHF1ZXVlLnNlY3Rpb25zID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrcy5vbkNvbnRlbnQoYmxvY2spO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZU1hdGNoKHRleHQsIG1hdGNoLCBxdWV1ZXMsIGNhbGxiYWNrcykge1xuICB2YXIgaGFzaCA9IG1hdGNoLmhhc2hcbiAgICAsIHR5cGUgPSBtYXRjaC50eXBlXG4gICAgLCBuYW1lID0gbWF0Y2gubmFtZVxuICAgICwgYmxvY2sgPSBsYXN0SXRlbShxdWV1ZXMpLmJsb2NrXG4gICAgLCBibG9ja1R5cGUgPSBibG9jayAmJiBibG9jay50eXBlXG4gICAgLCBzdGFydEJsb2NrLCBlbmRCbG9jaztcblxuICBpZiAodHlwZSA9PT0gJ2lmJyB8fCB0eXBlID09PSAndW5sZXNzJyB8fCB0eXBlID09PSAnZWFjaCcgfHwgdHlwZSA9PT0gJ3dpdGgnKSB7XG4gICAgaWYgKGhhc2ggPT09ICcjJykge1xuICAgICAgc3RhcnRCbG9jayA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChoYXNoID09PSAnLycpIHtcbiAgICAgIGVuZEJsb2NrID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VNYXRjaEVycm9yKHRleHQsIHR5cGUgKyAnIGJsb2NrcyBtdXN0IGJlZ2luIHdpdGggYSAjJyk7XG4gICAgfVxuXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Vsc2UnIHx8IHR5cGUgPT09ICdlbHNlIGlmJykge1xuICAgIGlmIChoYXNoKSB7XG4gICAgICBwYXJzZU1hdGNoRXJyb3IodGV4dCwgdHlwZSArICcgYmxvY2tzIG1heSBub3Qgc3RhcnQgd2l0aCAnICsgaGFzaCk7XG4gICAgfVxuICAgIGlmIChibG9ja1R5cGUgIT09ICdpZicgJiYgYmxvY2tUeXBlICE9PSAnZWxzZSBpZicgJiZcbiAgICAgICAgYmxvY2tUeXBlICE9PSAndW5sZXNzJyAmJiBibG9ja1R5cGUgIT09ICdlYWNoJykge1xuICAgICAgcGFyc2VNYXRjaEVycm9yKHRleHQsIHR5cGUgKyAnIG1heSBvbmx5IGZvbGxvdyBgaWZgLCBgZWxzZSBpZmAsIGB1bmxlc3NgLCBvciBgZWFjaGAnKTtcbiAgICB9XG4gICAgc3RhcnRCbG9jayA9IHRydWU7XG4gICAgZW5kQmxvY2sgPSB0cnVlO1xuXG4gIH0gZWxzZSBpZiAoaGFzaCA9PT0gJy8nKSB7XG4gICAgZW5kQmxvY2sgPSB0cnVlO1xuXG4gIH0gZWxzZSBpZiAoaGFzaCA9PT0gJyMnKSB7XG4gICAgcGFyc2VNYXRjaEVycm9yKHRleHQsICcjIG11c3QgYmUgZm9sbG93ZWQgYnkgYGlmYCwgYHVubGVzc2AsIGBlYWNoYCwgb3IgYHdpdGhgJyk7XG4gIH1cblxuICBpZiAoZW5kQmxvY2sgJiYgIWJsb2NrKSB7XG4gICAgcGFyc2VNYXRjaEVycm9yKHRleHQsICdVbm1hdGNoZWQgdGVtcGxhdGUgZW5kIHRhZycpO1xuICB9XG5cbiAgb25CbG9jayhzdGFydEJsb2NrLCBlbmRCbG9jaywgbWF0Y2gsIHF1ZXVlcywgY2FsbGJhY2tzKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VBdHRyKHZpZXcsIHZpZXdOYW1lLCBldmVudHMsIHRhZ05hbWUsIGF0dHJzLCBhdHRyKSB7XG4gIHZhciB2YWx1ZSA9IGF0dHJzW2F0dHJdO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSByZXR1cm47XG5cbiAgdmFyIGF0dHJPdXQgPSBwYXJzZU1hcmt1cCgnYXR0cicsIGF0dHIsIHRhZ05hbWUsIGV2ZW50cywgYXR0cnMsIHZhbHVlKSB8fCB7fVxuICAgICwgYm91bmRPdXQsIG1hdGNoLCBuYW1lLCByZW5kZXIsIG1ldGhvZCwgcHJvcGVydHk7XG4gIGlmIChhdHRyT3V0LmFkZElkKSBhZGRJZCh2aWV3LCBhdHRycyk7XG5cbiAgaWYgKG1hdGNoID0gZXh0cmFjdFBsYWNlaG9sZGVyKHZhbHVlKSkge1xuICAgIG5hbWUgPSBtYXRjaC5uYW1lO1xuXG4gICAgaWYgKG1hdGNoLnByZSB8fCBtYXRjaC5wb3N0KSB7XG4gICAgICAvLyBBdHRyaWJ1dGVzIG11c3QgYmUgYSBzaW5nbGUgc3RyaW5nLCBzbyBjcmVhdGUgYSBzdHJpbmcgcGFydGlhbFxuICAgICAgYWRkSWQodmlldywgYXR0cnMpO1xuICAgICAgcmVuZGVyID0gcGFyc2Uodmlldywgdmlld05hbWUsIHZhbHVlLCB0cnVlLCBmdW5jdGlvbihldmVudHMsIG5hbWUpIHtcbiAgICAgICAgYmluZEV2ZW50c0J5SWRTdHJpbmcoZXZlbnRzLCBuYW1lLCByZW5kZXIsIGF0dHJzLCAnYXR0cicsIGF0dHIpO1xuICAgICAgfSk7XG5cbiAgICAgIGF0dHJzW2F0dHJdID0gYXR0ciA9PT0gJ2lkJyA/IGZ1bmN0aW9uKGN0eCwgbW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJzLl9pZCA9IGVzY2FwZUF0dHJpYnV0ZShyZW5kZXIoY3R4LCBtb2RlbCkpO1xuICAgICAgfSA6IGZ1bmN0aW9uKGN0eCwgbW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIGVzY2FwZUF0dHJpYnV0ZShyZW5kZXIoY3R4LCBtb2RlbCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtYXRjaC5ib3VuZCkge1xuICAgICAgYm91bmRPdXQgPSBwYXJzZU1hcmt1cCgnYm91bmQnLCBhdHRyLCB0YWdOYW1lLCBldmVudHMsIGF0dHJzLCBtYXRjaCkgfHwge307XG4gICAgICBhZGRJZCh2aWV3LCBhdHRycyk7XG4gICAgICBtZXRob2QgPSBib3VuZE91dC5tZXRob2QgfHwgJ2F0dHInO1xuICAgICAgcHJvcGVydHkgPSBib3VuZE91dC5wcm9wZXJ0eSB8fCBhdHRyO1xuICAgICAgYmluZEV2ZW50c0J5SWQoZXZlbnRzLCBuYW1lLCBudWxsLCBhdHRycywgbWV0aG9kLCBwcm9wZXJ0eSk7XG4gICAgfVxuXG4gICAgaWYgKCFhdHRyT3V0LmRlbCkge1xuICAgICAgYXR0cnNbYXR0cl0gPSBhdHRyT3V0LmJvb2wgPyB7XG4gICAgICAgIGJvb2w6IGZ1bmN0aW9uKGN0eCwgbW9kZWwpIHtcbiAgICAgICAgICByZXR1cm4gKGRhdGFWYWx1ZSh2aWV3LCBjdHgsIG1vZGVsLCBuYW1lKSkgPyAnICcgKyBhdHRyIDogJyc7XG4gICAgICAgIH1cbiAgICAgIH0gOiB0ZXh0Rm4odmlldywgbmFtZSwgZXNjYXBlQXR0cmlidXRlLCB0cnVlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VQYXJ0aWFsQXR0cih2aWV3LCB2aWV3TmFtZSwgZXZlbnRzLCBhdHRycywgYXR0cikge1xuICB2YXIgdmFsdWUgPSBhdHRyc1thdHRyXVxuICAgICwgbWF0Y2g7XG5cbiAgaWYgKCF2YWx1ZSkge1xuICAgIC8vIEEgdHJ1ZSBib29sZWFuIGF0dHJpYnV0ZSB3aWxsIGhhdmUgYSB2YWx1ZSBvZiBudWxsXG4gICAgaWYgKHZhbHVlID09PSBudWxsKSBhdHRyc1thdHRyXSA9IHRydWU7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGF0dHIgPT09ICdiaW5kJykge1xuICAgIGF0dHJzW2F0dHJdID0geyRldmVudHM6IHNwbGl0RXZlbnRzKHZhbHVlKSwgJHZpZXc6IHZpZXd9O1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChtYXRjaCA9IGV4dHJhY3RQbGFjZWhvbGRlcih2YWx1ZSkpIHtcbiAgICAvLyBUaGlzIGF0dHJpYnV0ZSBuZWVkcyB0byBiZSB0cmVhdGVkIGFzIGEgc2VjdGlvblxuICAgIGlmIChtYXRjaC5wcmUgfHwgbWF0Y2gucG9zdCkgcmV0dXJuIHRydWU7XG5cbiAgICBhdHRyc1thdHRyXSA9IHskbWF0Y2hOYW1lOiBtYXRjaC5uYW1lLCAkYm91bmQ6IG1hdGNoLmJvdW5kfTtcblxuICB9IGVsc2UgaWYgKHZhbHVlID09PSAndHJ1ZScpIHtcbiAgICBhdHRyc1thdHRyXSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09ICdmYWxzZScpIHtcbiAgICBhdHRyc1thdHRyXSA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSAnbnVsbCcpIHtcbiAgICBhdHRyc1thdHRyXSA9IG51bGw7XG4gIH0gZWxzZSBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgIGF0dHJzW2F0dHJdID0gK3ZhbHVlO1xuICB9IGVsc2UgaWYgKC9eW3tbXS8udGVzdCh2YWx1ZSkpIHtcbiAgICB0cnkge1xuICAgICAgYXR0cnNbYXR0cl0gPSBKU09OLnBhcnNlKHZhbHVlKVxuICAgIH0gY2F0Y2ggKGVycikge31cbiAgfVxufVxuXG5mdW5jdGlvbiBsYXN0SXRlbShhcnIpIHtcbiAgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMV07XG59XG5cbmZ1bmN0aW9uIHBhcnNlKHZpZXcsIHZpZXdOYW1lLCB0ZW1wbGF0ZSwgaXNTdHJpbmcsIG9uQmluZCwgbm9NaW5pZnkpIHtcbiAgdmFyIHF1ZXVlcywgc3RhY2ssIGV2ZW50cywgb25SZW5kZXIsIHB1c2g7XG5cbiAgcXVldWVzID0gW3tcbiAgICBzdGFjazogc3RhY2sgPSBbXVxuICAsIGV2ZW50czogZXZlbnRzID0gW11cbiAgLCBzZWN0aW9uczogW11cbiAgfV07XG5cbiAgZnVuY3Rpb24gb25TdGFydChxdWV1ZSkge1xuICAgIHN0YWNrID0gcXVldWUuc3RhY2s7XG4gICAgZXZlbnRzID0gcXVldWUuZXZlbnRzO1xuICB9XG5cbiAgaWYgKGlzU3RyaW5nKSB7XG4gICAgcHVzaCA9IHB1c2hWYXJTdHJpbmc7XG4gICAgb25SZW5kZXIgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmIChjdHguJHN0cmluZ0N0eCkgcmV0dXJuIGN0eDtcbiAgICAgIGN0eCA9IE9iamVjdC5jcmVhdGUoY3R4KTtcbiAgICAgIGN0eC4kb25CaW5kID0gb25CaW5kO1xuICAgICAgY3R4LiRzdHJpbmdDdHggPSBjdHg7XG4gICAgICByZXR1cm4gY3R4O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwdXNoID0gcHVzaFZhcjtcbiAgfVxuXG4gIHZhciBpbmRleCA9IHZpZXdOYW1lLmxhc3RJbmRleE9mKCc6JylcbiAgICAsIG5zID0gfmluZGV4ID8gdmlld05hbWUuc2xpY2UoMCwgaW5kZXgpIDogJydcblxuICBmdW5jdGlvbiBwYXJzZVN0YXJ0KHRhZywgdGFnTmFtZSwgYXR0cnMpIHtcbiAgICB2YXIgYXR0ciwgYmxvY2ssIG91dCwgcGFyc2VyLCBpc1NlY3Rpb24sIGF0dHJCbG9ja1xuICAgIGlmICgneC1uby1taW5pZnknIGluIGF0dHJzKSB7XG4gICAgICBkZWxldGUgYXR0cnNbJ3gtbm8tbWluaWZ5J107XG4gICAgICBub01pbmlmeSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlzUGFydGlhbCh2aWV3LCB0YWdOYW1lKSkge1xuICAgICAgYmxvY2sgPSB7XG4gICAgICAgIHBhcnRpYWw6IHRhZ05hbWVcbiAgICAgICwgbWFjcm9DdHg6IGF0dHJzXG4gICAgICB9O1xuICAgICAgb25CbG9jayh0cnVlLCBmYWxzZSwgYmxvY2ssIHF1ZXVlcywge29uU3RhcnQ6IG9uU3RhcnR9KTtcblxuICAgICAgZm9yIChhdHRyIGluIGF0dHJzKSB7XG4gICAgICAgIGlzU2VjdGlvbiA9IHBhcnNlUGFydGlhbEF0dHIodmlldywgdmlld05hbWUsIGV2ZW50cywgYXR0cnMsIGF0dHIpO1xuICAgICAgICBpZiAoIWlzU2VjdGlvbikgY29udGludWU7XG4gICAgICAgIGF0dHJCbG9jayA9IHtcbiAgICAgICAgICBwYXJ0aWFsOiAnQCcgKyBhdHRyXG4gICAgICAgICwgbWFjcm9DdHg6IGxhc3RJdGVtKHF1ZXVlcykuYmxvY2subWFjcm9DdHhcbiAgICAgICAgfTtcbiAgICAgICAgb25CbG9jayh0cnVlLCBmYWxzZSwgYXR0ckJsb2NrLCBxdWV1ZXMsIHtvblN0YXJ0OiBvblN0YXJ0fSk7XG4gICAgICAgIHBhcnNlVGV4dChhdHRyc1thdHRyXSk7XG4gICAgICAgIHBhcnNlRW5kKHRhZywgJ0AnICsgYXR0cik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1ZvaWRDb21wb25lbnQodmlldywgdGFnTmFtZSwgbnMpKSB7XG4gICAgICAgIG9uQmxvY2soZmFsc2UsIHRydWUsIG51bGwsIHF1ZXVlcywge1xuICAgICAgICAgIG9uU3RhcnQ6IG9uU3RhcnRcbiAgICAgICAgLCBvbkVuZDogZnVuY3Rpb24ocXVldWVzKSB7XG4gICAgICAgICAgICBwdXNoKHZpZXcsIG5zLCBzdGFjaywgZXZlbnRzLCAnJywgYmxvY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNQYXJ0aWFsU2VjdGlvbih0YWdOYW1lKSkge1xuICAgICAgYmxvY2sgPSB7XG4gICAgICAgIHBhcnRpYWw6IHRhZ05hbWVcbiAgICAgICwgbWFjcm9DdHg6IGxhc3RJdGVtKHF1ZXVlcykuYmxvY2subWFjcm9DdHhcbiAgICAgIH07XG4gICAgICBvbkJsb2NrKHRydWUsIGZhbHNlLCBibG9jaywgcXVldWVzLCB7b25TdGFydDogb25TdGFydH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwYXJzZXIgPSBtYXJrdXAuZWxlbWVudFt0YWdOYW1lXSkge1xuICAgICAgb3V0ID0gcGFyc2VyKGV2ZW50cywgYXR0cnMpO1xuICAgICAgaWYgKG91dCAhPSBudWxsID8gb3V0LmFkZElkIDogdm9pZCAwKSB7XG4gICAgICAgIGFkZElkKHZpZXcsIGF0dHJzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgIHBhcnNlQXR0cih2aWV3LCB2aWV3TmFtZSwgZXZlbnRzLCB0YWdOYW1lLCBhdHRycywgYXR0cik7XG4gICAgfVxuICAgIHN0YWNrLnB1c2goWydzdGFydCcsIHRhZ05hbWUsIGF0dHJzXSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVRleHQodGV4dCwgaXNSYXdUZXh0LCByZW1haW5kZXIpIHtcbiAgICB2YXIgbWF0Y2ggPSBleHRyYWN0UGxhY2Vob2xkZXIodGV4dClcbiAgICAgICwgcG9zdCwgcHJlO1xuICAgIGlmICghbWF0Y2ggfHwgaXNSYXdUZXh0KSB7XG4gICAgICBpZiAoIW5vTWluaWZ5KSB7XG4gICAgICAgIHRleHQgPSBpc1N0cmluZyA/IHVuZXNjYXBlRW50aXRpZXModHJpbVRleHQodGV4dCkpIDogdHJpbVRleHQodGV4dCk7XG4gICAgICB9XG4gICAgICBwdXNoVGV4dChzdGFjaywgdGV4dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcHJlID0gbWF0Y2gucHJlO1xuICAgIHBvc3QgPSBtYXRjaC5wb3N0O1xuICAgIGlmIChpc1N0cmluZykgcHJlID0gdW5lc2NhcGVFbnRpdGllcyhwcmUpO1xuICAgIHB1c2hUZXh0KHN0YWNrLCBwcmUpO1xuICAgIHJlbWFpbmRlciA9IHBvc3QgfHwgcmVtYWluZGVyO1xuXG4gICAgcGFyc2VNYXRjaCh0ZXh0LCBtYXRjaCwgcXVldWVzLCB7XG4gICAgICBvblN0YXJ0OiBvblN0YXJ0XG4gICAgLCBvbkVuZDogZnVuY3Rpb24oc2VjdGlvbnMpIHtcbiAgICAgICAgdmFyIGZuID0gYmxvY2tGbih2aWV3LCBzZWN0aW9ucyk7XG4gICAgICAgIHB1c2godmlldywgbnMsIHN0YWNrLCBldmVudHMsIHJlbWFpbmRlciwgc2VjdGlvbnNbMF0uYmxvY2ssIGZuKTtcbiAgICAgIH1cbiAgICAsIG9uQ29udGVudDogZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgcHVzaCh2aWV3LCBucywgc3RhY2ssIGV2ZW50cywgcmVtYWluZGVyLCBtYXRjaCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAocG9zdCkgcmV0dXJuIHBhcnNlVGV4dChwb3N0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRW5kKHRhZywgdGFnTmFtZSkge1xuICAgIHZhciBzZWN0aW9uTmFtZSA9IHBhcnRpYWxTZWN0aW9uTmFtZSh0YWdOYW1lKVxuICAgICAgLCBlbmRzUGFydGlhbCA9IGlzUGFydGlhbCh2aWV3LCB0YWdOYW1lKVxuICAgIGlmIChlbmRzUGFydGlhbCAmJiBpc1ZvaWRDb21wb25lbnQodmlldywgdGFnTmFtZSwgbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuZCB0YWcgXCInICsgdGFnICsgJ1wiIGlzIG5vdCBhbGxvd2VkIGZvciB2b2lkIGNvbXBvbmVudCcpXG4gICAgfVxuICAgIGlmIChzZWN0aW9uTmFtZSB8fCBlbmRzUGFydGlhbCkge1xuICAgICAgb25CbG9jayhmYWxzZSwgdHJ1ZSwgbnVsbCwgcXVldWVzLCB7XG4gICAgICAgIG9uU3RhcnQ6IG9uU3RhcnRcbiAgICAgICwgb25FbmQ6IGZ1bmN0aW9uKHF1ZXVlcykge1xuICAgICAgICAgIHZhciBxdWV1ZSA9IHF1ZXVlc1swXVxuICAgICAgICAgICAgLCBibG9jayA9IHF1ZXVlLmJsb2NrXG4gICAgICAgICAgICAsIGZuID0gcmVuZGVyZXIodmlldywgcmVkdWNlU3RhY2socXVldWUuc3RhY2spLCBxdWV1ZS5ldmVudHMpXG4gICAgICAgICAgZm4udW5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoc2VjdGlvbk5hbWUpIHtcbiAgICAgICAgICAgIGJsb2NrLm1hY3JvQ3R4W3NlY3Rpb25OYW1lXSA9IGZuO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBQdXQgdGhlIHJlbWFpbmluZyBjb250ZW50IG5vdCBpbiBhIHNlY3Rpb24gaW4gdGhlIGRlZmF1bHQgXCJjb250ZW50XCIgc2VjdGlvbixcbiAgICAgICAgICAvLyB1bmxlc3MgXCJpbmhlcml0XCIgaXMgc3BlY2lmaWVkIGFuZCB0aGVyZSBpcyBubyBjb250ZW50LCBzbyB0aGF0IHRoZSBwYXJlbnRcbiAgICAgICAgICAvLyBjb250ZW50IGNhbiBiZSBpbmhlcml0ZWRcbiAgICAgICAgICBpZiAocXVldWUuc3RhY2subGVuZ3RoIHx8ICFibG9jay5tYWNyb0N0eC5pbmhlcml0KSB7XG4gICAgICAgICAgICBibG9jay5tYWNyb0N0eC5jb250ZW50ID0gZm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHB1c2godmlldywgbnMsIHN0YWNrLCBldmVudHMsICcnLCBibG9jayk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0YWNrLnB1c2goWydlbmQnLCB0YWdOYW1lXSk7XG4gIH1cblxuICBpZiAoaXNTdHJpbmcpIHtcbiAgICBwYXJzZVRleHQodGVtcGxhdGUpO1xuICB9IGVsc2Uge1xuICAgIHBhcnNlSHRtbCh0ZW1wbGF0ZSwge1xuICAgICAgc3RhcnQ6IHBhcnNlU3RhcnRcbiAgICAsIHRleHQ6IHBhcnNlVGV4dFxuICAgICwgZW5kOiBwYXJzZUVuZFxuICAgICwgY29tbWVudDogZnVuY3Rpb24odGFnKSB7XG4gICAgICAgIGlmIChjb25kaXRpb25hbENvbW1lbnQodGFnKSkgcHVzaFRleHQoc3RhY2ssIHRhZyk7XG4gICAgICB9XG4gICAgLCBvdGhlcjogZnVuY3Rpb24odGFnKSB7XG4gICAgICAgIHB1c2hUZXh0KHN0YWNrLCB0YWcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZW5kZXJlcih2aWV3LCByZWR1Y2VTdGFjayhzdGFjayksIGV2ZW50cywgb25SZW5kZXIpO1xufVxuXG59KSh3aW5kb3cpIiwidmFyIGV2ZW50QmluZGluZyA9IHJlcXVpcmUoJy4vZXZlbnRCaW5kaW5nJylcbiAgLCBzcGxpdEV2ZW50cyA9IGV2ZW50QmluZGluZy5zcGxpdEV2ZW50c1xuICAsIGNvbnRhaW5zRXZlbnQgPSBldmVudEJpbmRpbmcuY29udGFpbnNFdmVudFxuICAsIGFkZERvbUV2ZW50ID0gZXZlbnRCaW5kaW5nLmFkZERvbUV2ZW50XG4gICwgVEVYVF9FVkVOVFMgPSAna2V5dXAsa2V5ZG93bi8wLGN1dC8wLHBhc3RlLzAsZHJhZ292ZXIvMCxibHVyJ1xuICAsIEFVVE9DT01QTEVURV9PRkYgPSB7XG4gICAgICBjaGVja2JveDogdHJ1ZVxuICAgICwgcmFkaW86IHRydWVcbiAgICB9XG4gICwgb25CaW5kQSwgb25CaW5kRm9ybTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGJvdW5kOiB7XG4gICAgJ3ZhbHVlJzoge1xuICAgICAgJ2lucHV0JzogZnVuY3Rpb24oZXZlbnRzLCBhdHRycywgbWF0Y2gpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBhdHRycy50eXBlXG4gICAgICAgICAgLCBldmVudE5hbWVzLCBtZXRob2Q7XG4gICAgICAgIGlmICh0eXBlID09PSAncmFkaW8nIHx8IHR5cGUgPT09ICdjaGVja2JveCcpIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdyYW5nZScgfHwgJ3gtYmx1cicgaW4gYXR0cnMpIHtcbiAgICAgICAgICAvLyBPbmx5IHVwZGF0ZSBhZnRlciB0aGUgZWxlbWVudCBsb3NlcyBmb2N1c1xuICAgICAgICAgIGRlbGV0ZSBhdHRyc1sneC1ibHVyJ107XG4gICAgICAgICAgZXZlbnROYW1lcyA9ICdjaGFuZ2UsYmx1cic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQnkgZGVmYXVsdCwgdXBkYXRlIGFzIHRoZSB1c2VyIHR5cGVzXG4gICAgICAgICAgZXZlbnROYW1lcyA9IFRFWFRfRVZFTlRTO1xuICAgICAgICB9XG4gICAgICAgIGlmICgneC1hdG9taWMnIGluIGF0dHJzKSB7XG4gICAgICAgICAgZGVsZXRlIGF0dHJzWyd4LWF0b21pYyddO1xuICAgICAgICAgIG1ldGhvZCA9ICdwcm9wJztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAndGV4dCcgfHwgIXR5cGUpIHtcbiAgICAgICAgICBtZXRob2QgPSAncHJvcE90JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZXRob2QgPSAncHJvcCc7XG4gICAgICAgIH1cbiAgICAgICAgYWRkRG9tRXZlbnQoZXZlbnRzLCBhdHRycywgZXZlbnROYW1lcywgbWF0Y2gsIHtcbiAgICAgICAgICBtZXRob2Q6IG1ldGhvZFxuICAgICAgICAsIHByb3BlcnR5OiAndmFsdWUnXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge21ldGhvZDogbWV0aG9kfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgLCAnY2hlY2tlZCc6IHtcbiAgICAgICcqJzogZnVuY3Rpb24oZXZlbnRzLCDCoGF0dHJzLCBtYXRjaCkge1xuICAgICAgICBhZGREb21FdmVudChldmVudHMsIGF0dHJzLCAnY2hhbmdlJywgbWF0Y2gsIHtcbiAgICAgICAgICBtZXRob2Q6ICdwcm9wJ1xuICAgICAgICAsIHByb3BlcnR5OiAnY2hlY2tlZCdcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7bWV0aG9kOiAncHJvcCd9O1xuICAgICAgfVxuICAgIH1cblxuICAsICdzZWxlY3RlZCc6IHtcbiAgICAgICcqJzogZnVuY3Rpb24oZXZlbnRzLCBhdHRycywgbWF0Y2gpIHtcbiAgICAgICAgYWRkRG9tRXZlbnQoZXZlbnRzLCBhdHRycywgJ2NoYW5nZScsIG1hdGNoLCB7XG4gICAgICAgICAgbWV0aG9kOiAncHJvcCdcbiAgICAgICAgLCBwcm9wZXJ0eTogJ3NlbGVjdGVkJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHttZXRob2Q6ICdwcm9wJ307XG4gICAgICB9XG4gICAgfVxuXG4gICwgJ2Rpc2FibGVkJzoge1xuICAgICAgJyonOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHttZXRob2Q6ICdwcm9wJ307XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiwgYm91bmRQYXJlbnQ6IHtcbiAgICAnY29udGVudGVkaXRhYmxlJzoge1xuICAgICAgJyonOiBmdW5jdGlvbihldmVudHMsIGF0dHJzLCBtYXRjaCkge1xuICAgICAgICBhZGREb21FdmVudChldmVudHMsIGF0dHJzLCBURVhUX0VWRU5UUywgbWF0Y2gsIHtcbiAgICAgICAgICBtZXRob2Q6ICdodG1sJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgLCAnKic6IHtcbiAgICAgICd0ZXh0YXJlYSc6IGZ1bmN0aW9uKGV2ZW50cywgYXR0cnMsIG1hdGNoKSB7XG4gICAgICAgIGlmICgneC1hdG9taWMnIGluIGF0dHJzKSB7XG4gICAgICAgICAgZGVsZXRlIGF0dHJzWyd4LWF0b21pYyddO1xuICAgICAgICAgIHZhciBtZXRob2QgPSAncHJvcCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG1ldGhvZCA9ICdwcm9wT3QnO1xuICAgICAgICB9XG4gICAgICAgIGFkZERvbUV2ZW50KGV2ZW50cywgYXR0cnMsIFRFWFRfRVZFTlRTLCBtYXRjaCwge1xuICAgICAgICAgIG1ldGhvZDogbWV0aG9kXG4gICAgICAgICwgcHJvcGVydHk6ICd2YWx1ZSdcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7bWV0aG9kOiBtZXRob2QsIHByb3BlcnR5OiAndmFsdWUnfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuLCBlbGVtZW50OiB7XG4gICAgJ3NlbGVjdCc6IGZ1bmN0aW9uKGV2ZW50cywgYXR0cnMpIHtcbiAgICAgIC8vIERpc3RyaWJ1dGUgY2hhbmdlIGV2ZW50IHRvIGNoaWxkIG5vZGVzIG9mIHNlbGVjdCBlbGVtZW50c1xuICAgICAgYWRkRG9tRXZlbnQoZXZlbnRzLCBhdHRycywgJ2NoYW5nZTokZm9yQ2hpbGRyZW4nKTtcbiAgICAgIHJldHVybiB7YWRkSWQ6IHRydWV9O1xuICAgIH1cblxuICAsICdpbnB1dCc6IGZ1bmN0aW9uKGV2ZW50cywgYXR0cnMpIHtcbiAgICAgIGlmIChBVVRPQ09NUExFVEVfT0ZGW2F0dHJzLnR5cGVdICYmICEoJ2F1dG9jb21wbGV0ZScgaW4gYXR0cnMpKSB7XG4gICAgICAgIGF0dHJzLmF1dG9jb21wbGV0ZSA9ICdvZmYnO1xuICAgICAgfVxuICAgICAgaWYgKGF0dHJzLnR5cGUgPT09ICdyYWRpbycpIHtcbiAgICAgICAgLy8gRGlzdHJpYnV0ZSBjaGFuZ2UgZXZlbnRzIHRvIG90aGVyIGVsZW1lbnRzIHdpdGggdGhlIHNhbWUgbmFtZVxuICAgICAgICBhZGREb21FdmVudChldmVudHMsIGF0dHJzLCAnY2hhbmdlOiRmb3JOYW1lJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiwgYXR0cjoge1xuICAgICd4LWJpbmQnOiB7XG4gICAgICAnKic6IGZ1bmN0aW9uKGV2ZW50cywgYXR0cnMsIGV2ZW50TmFtZXMpIHtcbiAgICAgICAgYWRkRG9tRXZlbnQoZXZlbnRzLCBhdHRycywgZXZlbnROYW1lcyk7XG4gICAgICAgIHJldHVybiB7YWRkSWQ6IHRydWUsIGRlbDogdHJ1ZX07XG4gICAgICB9XG5cbiAgICAsICdhJzogb25CaW5kQSA9IGZ1bmN0aW9uKGV2ZW50cywgYXR0cnMsIGV2ZW50TmFtZXMpIHtcbiAgICAgICAgaWYgKGNvbnRhaW5zRXZlbnQoZXZlbnROYW1lcywgWydjbGljaycsICdmb2N1cyddKSAmJiAhKCdocmVmJyBpbiBhdHRycykpIHtcbiAgICAgICAgICBhdHRycy5ocmVmID0gJyMnO1xuICAgICAgICAgIGlmICghKCdvbmNsaWNrJyBpbiBhdHRycykpIHtcbiAgICAgICAgICAgIGF0dHJzLm9uY2xpY2sgPSAncmV0dXJuIGZhbHNlJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICwgJ2Zvcm0nOiBvbkJpbmRGb3JtID0gZnVuY3Rpb24oZXZlbnRzLCBhdHRycywgZXZlbnROYW1lcykge1xuICAgICAgICBpZiAoY29udGFpbnNFdmVudChldmVudE5hbWVzLCAnc3VibWl0JykpIHtcbiAgICAgICAgICBpZiAoISgnb25zdWJtaXQnIGluIGF0dHJzKSkge1xuICAgICAgICAgICAgYXR0cnMub25zdWJtaXQgPSAncmV0dXJuIGZhbHNlJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgLCAneC1jYXB0dXJlJzoge1xuICAgICAgJyonOiBmdW5jdGlvbihldmVudHMsIGF0dHJzLCBldmVudE5hbWVzKSB7XG4gICAgICAgIGFkZERvbUV2ZW50KGV2ZW50cywgYXR0cnMsIGV2ZW50TmFtZXMsIG51bGwsIHtjYXB0dXJlOiB0cnVlfSk7XG4gICAgICAgIHJldHVybiB7YWRkSWQ6IHRydWUsIGRlbDogdHJ1ZX07XG4gICAgICB9XG4gICAgLCAnYSc6IG9uQmluZEFcbiAgICAsICdmb3JtJzogb25CaW5kRm9ybVxuICAgIH1cblxuICAsICd4LWFzJzoge1xuICAgICAgJyonOiBmdW5jdGlvbihldmVudHMsIGF0dHJzLCBuYW1lKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgIGN0eC4kZWxlbWVudHNbbmFtZV0gPSBhdHRycy5faWQgfHwgYXR0cnMuaWQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge2FkZElkOiB0cnVlLCBkZWw6IHRydWV9XG4gICAgICB9XG4gIH1cblxuICAsICdjaGVja2VkJzoge1xuICAgICAgJyonOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtib29sOiB0cnVlfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgLCAnc2VsZWN0ZWQnOiB7XG4gICAgICAnKic6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge2Jvb2w6IHRydWV9O1xuICAgICAgfVxuICAgIH1cblxuICAsICdkaXNhYmxlZCc6IHtcbiAgICAgICcqJzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7Ym9vbDogdHJ1ZX07XG4gICAgICB9XG4gICAgfVxuXG4gICwgJ2F1dG9mb2N1cyc6IHtcbiAgICAgICcqJzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7Ym9vbDogdHJ1ZX07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiwgVEVYVF9FVkVOVFM6IFRFWFRfRVZFTlRTXG4sIEFVVE9DT01QTEVURV9PRkY6IEFVVE9DT01QTEVURV9PRkZcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJ3JhY2VyJykudXRpbFxuICAsIHZpZXdQYXRoID0gcmVxdWlyZSgnLi92aWV3UGF0aCcpXG4gICwgZXh0cmFjdFBsYWNlaG9sZGVyID0gdmlld1BhdGguZXh0cmFjdFBsYWNlaG9sZGVyXG4gICwgZGF0YVZhbHVlID0gdmlld1BhdGguZGF0YVZhbHVlXG4gICwgY3R4UGF0aCA9IHZpZXdQYXRoLmN0eFBhdGhcbiAgLCBwYXRoRm5BcmdzID0gdmlld1BhdGgucGF0aEZuQXJnc1xuICAsIHNldEJvdW5kRm4gPSB2aWV3UGF0aC5zZXRCb3VuZEZuXG4gICwgYXJyYXlTbGljZSA9IFtdLnNsaWNlXG5cbmV4cG9ydHMuc3BsaXRFdmVudHMgPSBzcGxpdEV2ZW50cztcbmV4cG9ydHMuZm5MaXN0ZW5lciA9IGZuTGlzdGVuZXI7XG5leHBvcnRzLmNvbnRhaW5zRXZlbnQgPSBjb250YWluc0V2ZW50O1xuZXhwb3J0cy5hZGREb21FdmVudCA9IHV0aWwuaXNTZXJ2ZXIgPyBlbXB0eSA6IGFkZERvbUV2ZW50O1xuXG5mdW5jdGlvbiBzcGxpdEV2ZW50cyhldmVudE5hbWVzKSB7XG4gIHZhciBwYWlycyA9IGV2ZW50TmFtZXMuc3BsaXQoJywnKVxuICAgICwgZXZlbnRMaXN0ID0gW11cbiAgICAsIGksIGosIHBhaXIsIHNlZ21lbnRzLCBuYW1lLCBldmVudE5hbWUsIGRlbGF5LCBmbnMsIGZuO1xuICBmb3IgKGkgPSBwYWlycy5sZW5ndGg7IGktLTspIHtcbiAgICBwYWlyID0gcGFpcnNbaV07XG4gICAgc2VnbWVudHMgPSBwYWlyLnNwbGl0KCc6Jyk7XG4gICAgbmFtZSA9IHNlZ21lbnRzWzBdLnNwbGl0KCcvJyk7XG4gICAgZXZlbnROYW1lID0gbmFtZVswXS50cmltKCk7XG4gICAgZGVsYXkgPSBuYW1lWzFdO1xuICAgIGZucyA9IChzZWdtZW50c1sxXSB8fCAnJykudHJpbSgpLnNwbGl0KC9cXHMrLyk7XG4gICAgZm9yIChqID0gZm5zLmxlbmd0aDsgai0tOykge1xuICAgICAgZm4gPSBmbnNbal07XG4gICAgICBmbnNbal0gPSBleHRyYWN0UGxhY2Vob2xkZXIoZm4pIHx8IGZuO1xuICAgIH1cbiAgICBldmVudExpc3QucHVzaChbZXZlbnROYW1lLCBkZWxheSwgZm5zXSk7XG4gIH1cbiAgcmV0dXJuIGV2ZW50TGlzdDtcbn1cblxuZnVuY3Rpb24gY29udGFpbnNFdmVudChldmVudE5hbWVzLCBleHBlY3RlZCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWQpKSBleHBlY3RlZCA9IFtleHBlY3RlZF07XG4gIHZhciBldmVudExpc3QgPSBzcGxpdEV2ZW50cyhldmVudE5hbWVzKVxuICAgICwgaSwgaiwgZXZlbnROYW1lXG4gIGZvciAoaSA9IGV2ZW50TGlzdC5sZW5ndGg7IGktLTspIHtcbiAgICBldmVudE5hbWUgPSBldmVudExpc3RbaV1bMF07XG4gICAgZm9yIChqID0gZXhwZWN0ZWQubGVuZ3RoOyBqLS07KSB7XG4gICAgICBpZiAoZXZlbnROYW1lID09PSBleHBlY3RlZFtqXSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYWRkRG9tRXZlbnQoZXZlbnRzLCBhdHRycywgZXZlbnROYW1lcywgbWF0Y2gsIG9wdGlvbnMpIHtcbiAgdmFyIGV2ZW50TGlzdCA9IHNwbGl0RXZlbnRzKGV2ZW50TmFtZXMpXG4gICAgLCBhcmdzLCBuYW1lO1xuXG4gIGlmIChtYXRjaCkge1xuICAgIG5hbWUgPSBtYXRjaC5uYW1lO1xuXG4gICAgaWYgKH5uYW1lLmluZGV4T2YoJygnKSkge1xuICAgICAgYXJncyA9IHBhdGhGbkFyZ3MobmFtZSk7XG4gICAgICBpZiAoIWFyZ3MubGVuZ3RoKSByZXR1cm47XG5cbiAgICAgIGV2ZW50cy5wdXNoKGZ1bmN0aW9uKGN0eCwgbW9kZWxFdmVudHMsIGRvbSwgcGF0aE1hcCwgdmlldykge1xuICAgICAgICB2YXIgaWQgPSBhdHRycy5faWQgfHwgYXR0cnMuaWRcbiAgICAgICAgICAsIHBhdGhzID0gW11cbiAgICAgICAgICAsIGFyZywgcGF0aCwgcGF0aElkLCBldmVudCwgZXZlbnROYW1lLCBldmVudE9wdGlvbnMsIGksIGo7XG4gICAgICAgIG9wdGlvbnMuc2V0VmFsdWUgPSBmdW5jdGlvbihtb2RlbCwgdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gc2V0Qm91bmRGbih2aWV3LCBjdHgsIG1vZGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gYXJncy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICBhcmcgPSBhcmdzW2ldO1xuICAgICAgICAgIHBhdGggPSBjdHhQYXRoKHZpZXcsIGN0eCwgYXJnKTtcbiAgICAgICAgICBwYXRocy5wdXNoKHBhdGgpO1xuICAgICAgICAgIHBhdGhJZCA9IHBhdGhNYXAuaWQocGF0aCk7XG4gICAgICAgICAgZm9yIChqID0gZXZlbnRMaXN0Lmxlbmd0aDsgai0tOykge1xuICAgICAgICAgICAgZXZlbnQgPSBldmVudExpc3Rbal07XG4gICAgICAgICAgICBldmVudE5hbWUgPSBldmVudFswXTtcbiAgICAgICAgICAgIGV2ZW50T3B0aW9ucyA9IHV0aWwubWVyZ2VJbnRvKHt2aWV3OiB2aWV3LCBjdHg6IGN0eCwgcGF0aElkOiBwYXRoSWQsIGRlbGF5OiBldmVudFsxXX0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgZG9tLmJpbmQoZXZlbnROYW1lLCBpZCwgZXZlbnRPcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2ZW50cy5wdXNoKGZ1bmN0aW9uKGN0eCwgbW9kZWxFdmVudHMsIGRvbSwgcGF0aE1hcCwgdmlldykge1xuICAgICAgdmFyIGlkID0gYXR0cnMuX2lkIHx8IGF0dHJzLmlkXG4gICAgICAgICwgcGF0aElkID0gcGF0aE1hcC5pZChjdHhQYXRoKHZpZXcsIGN0eCwgbmFtZSkpXG4gICAgICAgICwgZXZlbnQsIGV2ZW50TmFtZSwgZXZlbnRPcHRpb25zLCBpO1xuICAgICAgZm9yIChpID0gZXZlbnRMaXN0Lmxlbmd0aDsgaS0tOykge1xuICAgICAgICBldmVudCA9IGV2ZW50TGlzdFtpXTtcbiAgICAgICAgZXZlbnROYW1lID0gZXZlbnRbMF07XG4gICAgICAgIGV2ZW50T3B0aW9ucyA9IHV0aWwubWVyZ2VJbnRvKHt2aWV3OiB2aWV3LCBjdHg6IGN0eCwgcGF0aElkOiBwYXRoSWQsIGRlbGF5OiBldmVudFsxXX0sIG9wdGlvbnMpO1xuICAgICAgICBkb20uYmluZChldmVudE5hbWUsIGlkLCBldmVudE9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGV2ZW50cy5wdXNoKGZ1bmN0aW9uKGN0eCwgbW9kZWxFdmVudHMsIGRvbSwgcGF0aE1hcCwgdmlldykge1xuICAgIHZhciBpZCA9IGF0dHJzLl9pZCB8fCBhdHRycy5pZFxuICAgICAgLCBwYXRoSWQgPSBwYXRoTWFwLmlkKGN0eFBhdGgodmlldywgY3R4LCAnLicpKVxuICAgICAgLCBldmVudCwgZXZlbnROYW1lLCBldmVudE9wdGlvbnMsIGk7XG4gICAgZm9yIChpID0gZXZlbnRMaXN0Lmxlbmd0aDsgaS0tOykge1xuICAgICAgZXZlbnQgPSBldmVudExpc3RbaV07XG4gICAgICBldmVudE5hbWUgPSBldmVudFswXTtcbiAgICAgIGV2ZW50T3B0aW9ucyA9IGZuTGlzdGVuZXIodmlldywgY3R4LCBldmVudFsyXSwgZG9tKTtcbiAgICAgIGV2ZW50T3B0aW9ucy5kZWxheSA9IGV2ZW50WzFdO1xuICAgICAgdXRpbC5tZXJnZUludG8oZXZlbnRPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgIHV0aWwubWVyZ2VJbnRvKGV2ZW50T3B0aW9ucywge3ZpZXc6IHZpZXcsIGN0eDogY3R4LCBwYXRoSWQ6IHBhdGhJZH0pO1xuICAgICAgZG9tLmJpbmQoZXZlbnROYW1lLCBpZCwgZXZlbnRPcHRpb25zKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlYWNoRm5MaXN0ZW5lcih2aWV3LCBjdHgsIGZuT2JqLCBkb20pIHtcbiAgdmFyIGZuTmFtZSwgZm4sIGZuQ3R4cywgaSwgZm5DdHg7XG5cbiAgZm5OYW1lID0gdHlwZW9mIGZuT2JqID09PSAnb2JqZWN0J1xuICAgID8gZGF0YVZhbHVlKHZpZXcsIGN0eCwgdmlldy5tb2RlbCwgZm5PYmoubmFtZSlcbiAgICA6IGZuTmFtZSA9IGZuT2JqO1xuXG4gIC8vIElmIGEgcGxhY2Vob2xkZXIgZm9yIGFuIGV2ZW50IG5hbWUgZG9lcyBub3QgaGF2ZSBhIHZhbHVlLCBkbyBub3RoaW5nXG4gIGlmICghZm5OYW1lKSByZXR1cm4gZW1wdHk7XG5cbiAgLy8gU2VlIGlmIGl0IGlzIGEgYnVpbHQtaW4gZnVuY3Rpb25cbiAgZm4gPSBkb20gJiYgZG9tLmZuc1tmbk5hbWVdO1xuXG4gIC8vIExvb2t1cCB0aGUgZnVuY3Rpb24gbmFtZSBvbiB0aGUgY29tcG9uZW50IHNjcmlwdCBvciBhcHBcblxuICAvLyBUT0RPOiBUaGlzIHNpbXBseSBsb29rcyBpbiB0aGUgbG9jYWwgc2NvcGUgZm9yIHRoZSBmdW5jdGlvblxuICAvLyBhbmQgdGhlbiBnb2VzIHVwIHRoZSBzY29wZSBpZiBhIGZ1bmN0aW9uIG5hbWUgaXMgbm90IGZvdW5kLlxuICAvLyBCZXR0ZXIgd291bGQgYmUgdG8gYWN0dWFsbHkgZmlndXJlIG91dCB0aGUgc2NvcGUgb2Ygd2hlcmUgdGhlXG4gIC8vIGZ1bmN0aW9uIG5hbWUgaXMgc3BlY2ZpZWQsIHNpbmNlIHRoZXJlIGNvdWxkIGVhc2lseSBiZSBuYW1lc3BhY2VcbiAgLy8gY29uZmxpY3RzIGJldHdlZW4gZnVuY3Rpb25zIGluIGEgY29tcG9uZW50IGFuZCBmdW5jdGlvbnMgaW4gYW5cbiAgLy8gYXBwIHVzaW5nIHRoYXQgY29tcG9uZW50LiBIb3cgdG8gaW1wbGVtZW50IHRoaXMgY29ycmVjdGx5IGlzIG5vdFxuICAvLyBvYnZpb3VzIGF0IHRoZSBtb21lbnQuXG4gIGlmICghZm4pIHtcbiAgICBmbkN0eHMgPSBjdHguJGZuQ3R4O1xuICAgIGZvciAoaSA9IGZuQ3R4cy5sZW5ndGg7IGktLTspIHtcbiAgICAgIGZuQ3R4ID0gZm5DdHhzW2ldO1xuICAgICAgZm4gPSBmbkN0eFtmbk5hbWVdIHx8IHZpZXdQYXRoLmxvb2t1cChmbk5hbWUsIGZuQ3R4KTtcbiAgICAgIGlmIChmbikgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmICghZm4pIHRocm93IG5ldyBFcnJvcignQm91bmQgZnVuY3Rpb24gbm90IGZvdW5kOiAnICsgZm5OYW1lKTtcblxuICAvLyBCaW5kIHRoZSBsaXN0ZW5lciB0byB0aGUgYXBwIG9yIGNvbXBvbmVudCBvYmplY3Qgb24gd2hpY2ggaXRcbiAgLy8gd2FzIGRlZmluZWQgc28gdGhhdCB0aGUgYHRoaXNgIGNvbnRleHQgd2lsbCBiZSB0aGUgaW5zdGFuY2VcbiAgcmV0dXJuIGZuLmJpbmQoZm5DdHgpO1xufVxuXG5mdW5jdGlvbiBmbkxpc3RlbmVyKHZpZXcsIGN0eCwgZm5OYW1lcywgZG9tKSB7XG4gIHZhciBsaXN0ZW5lciA9IHtcbiAgICBmbjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGVuID0gZm5OYW1lcy5sZW5ndGhcbiAgICAgICAgLCBhcmdzID0gYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgICAgICAgLCBpLCBmbiwgYm91bmRGbnNcblxuICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBubyBoYW5kbGVyIGZ1bmN0aW9ucyB3ZXJlIHNwZWNpZmllZFxuICAgICAgICByZXR1cm4gbGlzdGVuZXIuZm4gPSBlbXB0eTtcblxuICAgICAgfSBlbHNlIGlmIChsZW4gPT09IDEpIHtcbiAgICAgICAgZm4gPSBlYWNoRm5MaXN0ZW5lcih2aWV3LCBjdHgsIGZuTmFtZXNbMF0sIGRvbSk7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJvdW5kRm5zID0gW107XG4gICAgICAgIGZvciAoaSA9IGxlbjsgaS0tOykge1xuICAgICAgICAgIGJvdW5kRm5zLnB1c2goZWFjaEZuTGlzdGVuZXIodmlldywgY3R4LCBmbk5hbWVzW2ldLCBkb20pKTtcbiAgICAgICAgfVxuICAgICAgICBmbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgICAgICAgICBmb3IgKHZhciBpID0gYm91bmRGbnMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICBib3VuZEZuc1tpXS5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXIuZm4gPSBmbjtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGxpc3RlbmVyO1xufVxuXG5mdW5jdGlvbiBlbXB0eSgpIHt9XG4iLCJ2YXIgZW50aXR5Q29kZSA9IHJlcXVpcmUoJy4vZW50aXR5Q29kZScpXG4gICwgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhcnNlOiBwYXJzZVxuLCBlc2NhcGVIdG1sOiBlc2NhcGVIdG1sXG4sIGVzY2FwZUF0dHJpYnV0ZTogZXNjYXBlQXR0cmlidXRlXG4sIHVuZXNjYXBlRW50aXRpZXM6IHVuZXNjYXBlRW50aXRpZXNcbiwgaXNWb2lkOiBpc1ZvaWRcbiwgY29uZGl0aW9uYWxDb21tZW50OiBjb25kaXRpb25hbENvbW1lbnRcbiwgdHJpbUxlYWRpbmc6IHRyaW1MZWFkaW5nXG4sIHRyaW1UZXh0OiB0cmltVGV4dFxuLCB0cmltVGFnOiB0cmltVGFnXG4sIG1pbmlmeTogbWluaWZ5XG59XG5cbmZ1bmN0aW9uIGVzY2FwZUh0bWwodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiAnJ1xuXG4gIHJldHVybiB2YWx1ZVxuICAgIC50b1N0cmluZygpXG4gICAgLnJlcGxhY2UoLyYoPyFcXHMpfDwvZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXRjaCA9PT0gJyYnID8gJyZhbXA7JyA6ICcmbHQ7J1xuICAgIH0pXG59XG5cbmZ1bmN0aW9uIGVzY2FwZUF0dHJpYnV0ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSA9PT0gJycpIHJldHVybiAnXCJcIidcblxuICB2YWx1ZSA9IHZhbHVlXG4gICAgLnRvU3RyaW5nKClcbiAgICAucmVwbGFjZSgvJig/IVxccyl8XCIvZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXRjaCA9PT0gJyYnID8gJyZhbXA7JyA6ICcmcXVvdDsnXG4gICAgfSlcbiAgcmV0dXJuIC9bID08PiddLy50ZXN0KHZhbHVlKSA/ICdcIicgKyB2YWx1ZSArICdcIicgOiB2YWx1ZVxufVxuXG4vLyBCYXNlZCBvbjpcbi8vIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9qc2xpYnMvd2lraS9KYXZhc2NyaXB0VGlwcyNFc2NhcGVfYW5kX3VuZXNjYXBlX0hUTUxfZW50aXRpZXNcbmZ1bmN0aW9uIHVuZXNjYXBlRW50aXRpZXMoaHRtbCkge1xuICByZXR1cm4gaHRtbC5yZXBsYWNlKC8mKFteO10rKTsvZywgZnVuY3Rpb24obWF0Y2gsIGVudGl0eSkge1xuICAgIHZhciBjaGFyQ29kZSA9IGVudGl0eS5jaGFyQXQoMCkgPT09ICcjJ1xuICAgICAgICAgID8gZW50aXR5LmNoYXJBdCgxKSA9PT0gJ3gnXG4gICAgICAgICAgICA/IGVudGl0eS5zbGljZSgyLCAxNylcbiAgICAgICAgICAgIDogZW50aXR5LnNsaWNlKDEpXG4gICAgICAgICAgOiBlbnRpdHlDb2RlW2VudGl0eV1cbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSlcbiAgfSlcbn1cblxudmFyIHZvaWRFbGVtZW50ID0ge1xuICBhcmVhOiAxXG4sIGJhc2U6IDFcbiwgYnI6IDFcbiwgY29sOiAxXG4sIGNvbW1hbmQ6IDFcbiwgZW1iZWQ6IDFcbiwgaHI6IDFcbiwgaW1nOiAxXG4sIGlucHV0OiAxXG4sIGtleWdlbjogMVxuLCBsaW5rOiAxXG4sIG1ldGE6IDFcbiwgcGFyYW06IDFcbiwgc291cmNlOiAxXG4sIHRyYWNrOiAxXG4sIHdicjogMVxufVxuZnVuY3Rpb24gaXNWb2lkKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUgaW4gdm9pZEVsZW1lbnRcbn1cblxuLy8gQXNzdW1lIGFueSBIVE1MIGNvbW1lbnQgdGhhdCBzdGFydHMgd2l0aCBgPCEtLVtgIG9yIGVuZHMgd2l0aCBgXS0tPmBcbi8vIGlzIGEgY29uZGl0aW9uYWwgY29tbWVudC4gVGhpcyBjYW4gYWxzbyBiZSB1c2VkIHRvIGtlZXAgY29tbWVudHMgaW5cbi8vIG1pbmlmaWVkIEhUTUwsIHN1Y2ggYXMgYDwhLS1bIENvcHlyaWdodCBKb2huIERvZSwgTUlUIExpY2Vuc2VkIF0tLT5gXG5mdW5jdGlvbiBjb25kaXRpb25hbENvbW1lbnQodGFnKSB7XG4gIHJldHVybiAvKD86XjwhLS1cXFspfCg/OlxcXS0tPiQpLy50ZXN0KHRhZylcbn1cblxuLy8gUmVtb3ZlIGxlYWRpbmcgd2hpdGVzcGFjZSBhbmQgbmV3bGluZXMgZnJvbSBhIHN0cmluZy4gV2hpdGVzcGFjZSBhdCB0aGUgZW5kXG4vLyBvZiBhIGxpbmUgd2lsbCBiZSBtYWludGFpbmVkXG5mdW5jdGlvbiB0cmltTGVhZGluZyh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0ID8gdGV4dC5yZXBsYWNlKC9cXHI/XFxuXFxzKi9nLCAnJykgOiAnJ1xufVxuXG4vLyBSZW1vdmUgbGVhZGluZyAmIHRyYWlsaW5nIHdoaXRlc3BhY2UgYW5kIG5ld2xpbmVzIGZyb20gYSBzdHJpbmdcbmZ1bmN0aW9uIHRyaW1UZXh0KHRleHQpIHtcbiAgcmV0dXJuIHRleHQgPyB0ZXh0LnJlcGxhY2UoL1xccypcXHI/XFxuXFxzKi9nLCAnJykgOiAnJ1xufVxuXG4vLyBXaXRoaW4gYSB0YWcsIHJlbW92ZSBsZWFkaW5nICYgdHJhaWxpbmcgd2hpdGVzcGFjZS4gS2VlcCBhIGxpbmVicmVhaywgc2luY2Vcbi8vIHRoaXMgY291bGQgYmUgdGhlIHNlcGFyYXRvciBiZXR3ZWVuIGF0dHJpYnV0ZXNcbmZ1bmN0aW9uIHRyaW1UYWcodGFnKSB7XG4gIHJldHVybiB0YWcucmVwbGFjZSgvKD86XFxzKlxccj9cXG5cXHMqKSsvZywgJ1xcbicpXG59XG5cbi8vIFJlbW92ZSBsaW5lYnJlYWtzLCBsZWFkaW5nICYgdHJhaWxpbmcgc3BhY2UsIGFuZCBjb21tZW50cy4gTWFpbnRhaW4gYVxuLy8gbGluZWJyZWFrIGJldHdlZW4gSFRNTCB0YWcgYXR0cmlidXRlcyBhbmQgbWFpbnRhaW4gY29uZGl0aW9uYWwgY29tbWVudHMuXG5mdW5jdGlvbiBtaW5pZnkoaHRtbCkge1xuICB2YXIgbWluaWZpZWQgPSAnJ1xuICAgICwgbWluaWZ5Q29udGVudCA9IHRydWVcblxuICBwYXJzZShodG1sLCB7XG4gICAgc3RhcnQ6IGZ1bmN0aW9uKHRhZywgdGFnTmFtZSwgYXR0cnMpIHtcbiAgICAgIG1pbmlmeUNvbnRlbnQgPSAhKCd4LW5vLW1pbmlmeScgaW4gYXR0cnMpXG4gICAgICBtaW5pZmllZCArPSB0cmltVGFnKHRhZylcbiAgICB9XG4gICwgZW5kOiBmdW5jdGlvbih0YWcpIHtcbiAgICAgIG1pbmlmaWVkICs9IHRyaW1UYWcodGFnKVxuICAgIH1cbiAgLCB0ZXh0OiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICBtaW5pZmllZCArPSBtaW5pZnlDb250ZW50ID8gdHJpbVRleHQodGV4dCkgOiB0ZXh0XG4gICAgfVxuICAsIGNvbW1lbnQ6IGZ1bmN0aW9uKHRhZykge1xuICAgICAgaWYgKGNvbmRpdGlvbmFsQ29tbWVudCh0YWcpKSBtaW5pZmllZCArPSB0YWdcbiAgICB9XG4gICwgb3RoZXI6IGZ1bmN0aW9uKHRhZykge1xuICAgICAgbWluaWZpZWQgKz0gdGFnXG4gICAgfVxuICB9KVxuICByZXR1cm4gbWluaWZpZWRcbn1cbiIsInZhciByb3V0ZXIgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcm91dGVyJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHRyYW5zaXRpb246IHRyYW5zaXRpb25cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhZGQgKGUuZy4sIGFwcC5nZXQsIGFwcC5wb3N0LCBldGMuKVxuICogQHBhcmFtIHtBcnJheX0gdHJhbnNpdGlvbkNhbGxzIGlzIGFuIGFycmF5IG9mIG9iamVjdHMgdGhhdCBsb29rIFxuICogICBsaWtlIHtmcm9tLCB0bywgZm9yd2FyZCwgYmFja31cbiAqIEBwYXJhbSB7U3RyaW5nfSBmcm9tXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZvcndhcmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGJhY2tcbiAqL1xuZnVuY3Rpb24gdHJhbnNpdGlvbihhZGQsIGNhbGxzLCBmcm9tLCB0bywgZm9yd2FyZCwgYmFjaykge1xuICBpZiAoZnJvbSA9PT0gdG8pIHJldHVyblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgY2FsbCA9IGNhbGxzW2ldXG4gICAgaWYgKGNhbGwuZnJvbSA9PT0gdG8pIHtcbiAgICAgIGlmIChoYXNUcmFuc2l0aW9uKGNhbGxzLCBmcm9tLCBjYWxsLnRvKSkgY29udGludWVcbiAgICAgIHZhciBjb21wb3NlZEZvcndhcmQgPSBjb21wb3NlQ2FsbGJhY2tzKGZvcndhcmQsIGNhbGwuZm9yd2FyZCwgdG8pXG4gICAgICBpZiAoYmFjayAmJiBjYWxsLmJhY2spIHtcbiAgICAgICAgdmFyIGNvbXBvc2VkQmFjayA9IGNvbXBvc2VDYWxsYmFja3MoY2FsbC5iYWNrLCBiYWNrLCB0bylcbiAgICAgIH1cbiAgICAgIGFkZCh7XG4gICAgICAgIGZyb206IGZyb21cbiAgICAgICwgdG86IGNhbGwudG9cbiAgICAgICwgZm9yd2FyZDogY29tcG9zZWRGb3J3YXJkXG4gICAgICAsIGJhY2s6IGNvbXBvc2VkQmFja1xuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKGNhbGwudG8gPT09IGZyb20pIHtcbiAgICAgIGlmIChoYXNUcmFuc2l0aW9uKGNhbGxzLCBjYWxsLmZyb20sIHRvKSkgY29udGludWVcbiAgICAgIHZhciBjb21wb3NlZEZvcndhcmQgPSBjb21wb3NlQ2FsbGJhY2tzKGNhbGwuZm9yd2FyZCwgZm9yd2FyZCwgZnJvbSlcbiAgICAgIGlmIChiYWNrICYmIGNhbGwuYmFjaykge1xuICAgICAgICB2YXIgY29tcG9zZWRCYWNrID0gY29tcG9zZUNhbGxiYWNrcyhiYWNrLCBjYWxsLmJhY2ssIGZyb20pXG4gICAgICB9XG4gICAgICBhZGQoe1xuICAgICAgICBmcm9tOiBjYWxsLmZyb21cbiAgICAgICwgdG86IHRvXG4gICAgICAsIGZvcndhcmQ6IGNvbXBvc2VkRm9yd2FyZFxuICAgICAgLCBiYWNrOiBjb21wb3NlZEJhY2tcbiAgICAgIH0pXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1RyYW5zaXRpb24oY2FsbHMsIGZyb20sIHRvKSB7XG4gIGZvciAodmFyIGkgPSBjYWxscy5sZW5ndGg7IGktLTspIHtcbiAgICB2YXIgY2FsbCA9IGNhbGxzW2ldO1xuICAgIGlmIChjYWxsLmZyb20gPT09IGZyb20gJiYgY2FsbC50byA9PT0gdG8pIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8vIFRPRE86IEFzeW5jIHN1cHBvcnRcbmZ1bmN0aW9uIGNvbXBvc2VDYWxsYmFja3MoZmlyc3QsIHNlY29uZCwgaW50ZXJtZWRpYXRlUGF0aCkge1xuICBmdW5jdGlvbiBjb21wb3NlZChzZWxmLCBtb2RlbCwgcGFyYW1zLCBuZXh0LCBkb25lKSB7XG4gICAgdmFyIGludGVybWVkaWF0ZVVybCA9IHJvdXRlci5tYXBSb3V0ZShpbnRlcm1lZGlhdGVQYXRoLCBwYXJhbXMpXG4gICAgdmFyIHVybCA9IHBhcmFtcy51cmxcbiAgICB2YXIgc2tpcHBlZCA9IGZhbHNlXG4gICAgZnVuY3Rpb24gd3JhcE5leHQoZXJyKSB7XG4gICAgICBza2lwcGVkID0gdHJ1ZVxuICAgICAgbmV4dChlcnIpXG4gICAgfVxuICAgIHBhcmFtcy51cmwgPSBpbnRlcm1lZGlhdGVVcmxcbiAgICBpZiAoZmlyc3QubGVuZ3RoID09PSA0KSB7XG4gICAgICBmaXJzdC5jYWxsKHNlbGYsIG1vZGVsLCBwYXJhbXMsIHdyYXBOZXh0LCBkb25lRmlyc3QpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZpcnN0LmNhbGwoc2VsZiwgbW9kZWwsIHBhcmFtcywgd3JhcE5leHQpXG4gICAgICBkb25lRmlyc3QoKVxuICAgIH1cbiAgICBmdW5jdGlvbiBkb25lRmlyc3QoKSB7XG4gICAgICBpZiAoc2tpcHBlZCkgcmV0dXJuXG4gICAgICBwYXJhbXMucHJldmlvdXMgPSBpbnRlcm1lZGlhdGVVcmxcbiAgICAgIHBhcmFtcy51cmwgPSB1cmxcbiAgICAgIGlmIChzZWNvbmQubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHNlY29uZC5jYWxsKHNlbGYsIG1vZGVsLCBwYXJhbXMsIG5leHQsIGRvbmUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWNvbmQuY2FsbChzZWxmLCBtb2RlbCwgcGFyYW1zLCBuZXh0KVxuICAgICAgICBkb25lICYmIGRvbmUoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBUaGVzZSBuZWVkIHRvIGJlIGRlZmluZWQgaW5kaXZpZHVhbGx5LCBzaW5jZSB0aGVpclxuICAvLyBhcmd1bWVudCBsZW5ndGggd2lsbCBiZSBjaGVja2VkXG4gIGZ1bmN0aW9uIGFzeW5jQ29tcG9zZWRDYWxsYmFjayhtb2RlbCwgcGFyYW1zLCBuZXh0LCBkb25lKSB7XG4gICAgY29tcG9zZWQodGhpcywgbW9kZWwsIHBhcmFtcywgbmV4dCwgZG9uZSk7XG4gIH1cbiAgZnVuY3Rpb24gY29tcG9zZWRDYWxsYmFjayhtb2RlbCwgcGFyYW1zLCBuZXh0KSB7XG4gICAgY29tcG9zZWQodGhpcywgbW9kZWwsIHBhcmFtcywgbmV4dCk7XG4gIH1cbiAgcmV0dXJuIChmaXJzdC5sZW5ndGggPT09IDQgfHwgc2Vjb25kLmxlbmd0aCA9PT0gNCkgP1xuICAgIGFzeW5jQ29tcG9zZWRDYWxsYmFjayA6IGNvbXBvc2VkQ2FsbGJhY2s7XG59XG4iLCJ2YXIgZG9jID0gZG9jdW1lbnRcbiAgLCBlbGVtZW50UHJvdG8gPSBIVE1MRWxlbWVudC5wcm90b3R5cGVcbiAgLCBub2RlUHJvdG8gPSBOb2RlLnByb3RvdHlwZVxuXG4vLyBBZGQgc3VwcG9ydCBmb3IgTm9kZS5jb250YWlucyBmb3IgRmlyZWZveCA8IDlcbmlmICghZG9jLmNvbnRhaW5zKSB7XG4gIG5vZGVQcm90by5jb250YWlucyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gISEodGhpcy5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihub2RlKSAmIDE2KVxuICB9XG59XG5cbi8vIEFkZCBzdXBwb3J0IGZvciBpbnNlcnRBZGphY2VudEhUTUwgZm9yIEZpcmVmb3ggPCA4XG4vLyBCYXNlZCBvbiBpbnNlcnRBZGphY2VudEhUTUwuanMgYnkgRWxpIEdyZXksIGh0dHA6Ly9lbGlncmV5LmNvbVxuaWYgKCFkb2MuYm9keS5pbnNlcnRBZGphY2VudEhUTUwpIHtcbiAgZWxlbWVudFByb3RvLmluc2VydEFkamFjZW50SFRNTCA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBodG1sKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gcG9zaXRpb24udG9Mb3dlckNhc2UoKVxuICAgICAgLCByZWYgPSB0aGlzXG4gICAgICAsIHBhcmVudCA9IHJlZi5wYXJlbnROb2RlXG4gICAgICAsIGNvbnRhaW5lciA9IGRvYy5jcmVhdGVFbGVtZW50KHBhcmVudC50YWdOYW1lKVxuICAgICAgLCBmaXJzdENoaWxkLCBuZXh0U2libGluZywgbm9kZVxuXG4gICAgY29udGFpbmVyLmlubmVySFRNTCA9IGh0bWxcbiAgICBpZiAocG9zaXRpb24gPT09ICdiZWZvcmVlbmQnKSB7XG4gICAgICB3aGlsZSAobm9kZSA9IGNvbnRhaW5lci5maXJzdENoaWxkKSB7XG4gICAgICAgIHJlZi5hcHBlbmRDaGlsZChub2RlKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdiZWZvcmViZWdpbicpIHtcbiAgICAgIHdoaWxlIChub2RlID0gY29udGFpbmVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShub2RlLCByZWYpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2FmdGVyZW5kJykge1xuICAgICAgbmV4dFNpYmxpbmcgPSByZWYubmV4dFNpYmxpbmdcbiAgICAgIHdoaWxlIChub2RlID0gY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgICAgICBuZXh0U2libGluZyA9IHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgbmV4dFNpYmxpbmcpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2FmdGVyYmVnaW4nKSB7XG4gICAgICBmaXJzdENoaWxkID0gcmVmLmZpcnN0Q2hpbGRcbiAgICAgIHdoaWxlIChub2RlID0gY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgICAgICBmaXJzdENoaWxkID0gcmVmLmluc2VydEJlZm9yZShub2RlLCBmaXJzdENoaWxkKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5lbGVtZW50UHJvdG8ubWF0Y2hlcyA9XG4gIGVsZW1lbnRQcm90by53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcbiAgZWxlbWVudFByb3RvLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuICBlbGVtZW50UHJvdG8ub01hdGNoZXNTZWxlY3RvciB8fFxuICBlbGVtZW50UHJvdG8ubXNNYXRjaGVzU2VsZWN0b3JcbiIsInZhciBpc0FycmF5ID0gdHlwZW9mIEFycmF5LmlzQXJyYXkgPT09ICdmdW5jdGlvbidcbiAgICA/IEFycmF5LmlzQXJyYXlcbiAgICA6IGZ1bmN0aW9uICh4cykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgIH07XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gb2JqZWN0S2V5cyhvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ICE9PSBPYmplY3Qob2JqZWN0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBvYmplY3QnKTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkga2V5c1trZXlzLmxlbmd0aF0gPSBrZXk7XG4gICAgcmV0dXJuIGtleXM7XG59XG5cblxuLyohXG4gKiBxdWVyeXN0cmluZ1xuICogQ29weXJpZ2h0KGMpIDIwMTAgVEogSG9sb3dheWNodWsgPHRqQHZpc2lvbi1tZWRpYS5jYT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogTGlicmFyeSB2ZXJzaW9uLlxuICovXG5cbmV4cG9ydHMudmVyc2lvbiA9ICcwLjMuMSc7XG5cbi8qKlxuICogT2JqZWN0I3RvU3RyaW5nKCkgcmVmIGZvciBzdHJpbmdpZnkoKS5cbiAqL1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIENhY2hlIG5vbi1pbnRlZ2VyIHRlc3QgcmVnZXhwLlxuICovXG5cbnZhciBub3RpbnQgPSAvW14wLTldLztcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gcXVlcnkgYHN0cmAsIHJldHVybmluZyBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24oc3RyKXtcbiAgaWYgKG51bGwgPT0gc3RyIHx8ICcnID09IHN0cikgcmV0dXJuIHt9O1xuXG4gIGZ1bmN0aW9uIHByb21vdGUocGFyZW50LCBrZXkpIHtcbiAgICBpZiAocGFyZW50W2tleV0ubGVuZ3RoID09IDApIHJldHVybiBwYXJlbnRba2V5XSA9IHt9O1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgaSBpbiBwYXJlbnRba2V5XSkgdFtpXSA9IHBhcmVudFtrZXldW2ldO1xuICAgIHBhcmVudFtrZXldID0gdDtcbiAgICByZXR1cm4gdDtcbiAgfVxuXG4gIHJldHVybiBTdHJpbmcoc3RyKVxuICAgIC5zcGxpdCgnJicpXG4gICAgLnJlZHVjZShmdW5jdGlvbihyZXQsIHBhaXIpe1xuICAgICAgdHJ5eyBcbiAgICAgICAgcGFpciA9IGRlY29kZVVSSUNvbXBvbmVudChwYWlyLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAvLyBpZ25vcmVcbiAgICAgIH1cblxuICAgICAgdmFyIGVxbCA9IHBhaXIuaW5kZXhPZignPScpXG4gICAgICAgICwgYnJhY2UgPSBsYXN0QnJhY2VJbktleShwYWlyKVxuICAgICAgICAsIGtleSA9IHBhaXIuc3Vic3RyKDAsIGJyYWNlIHx8IGVxbClcbiAgICAgICAgLCB2YWwgPSBwYWlyLnN1YnN0cihicmFjZSB8fCBlcWwsIHBhaXIubGVuZ3RoKVxuICAgICAgICAsIHZhbCA9IHZhbC5zdWJzdHIodmFsLmluZGV4T2YoJz0nKSArIDEsIHZhbC5sZW5ndGgpXG4gICAgICAgICwgcGFyZW50ID0gcmV0O1xuXG4gICAgICAvLyA/Zm9vXG4gICAgICBpZiAoJycgPT0ga2V5KSBrZXkgPSBwYWlyLCB2YWwgPSAnJztcblxuICAgICAgLy8gbmVzdGVkXG4gICAgICBpZiAofmtleS5pbmRleE9mKCddJykpIHtcbiAgICAgICAgdmFyIHBhcnRzID0ga2V5LnNwbGl0KCdbJylcbiAgICAgICAgICAsIGxlbiA9IHBhcnRzLmxlbmd0aFxuICAgICAgICAgICwgbGFzdCA9IGxlbiAtIDE7XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2UocGFydHMsIHBhcmVudCwga2V5KSB7XG4gICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0cy5zaGlmdCgpO1xuXG4gICAgICAgICAgLy8gZW5kXG4gICAgICAgICAgaWYgKCFwYXJ0KSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheShwYXJlbnRba2V5XSkpIHtcbiAgICAgICAgICAgICAgcGFyZW50W2tleV0ucHVzaCh2YWwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PSB0eXBlb2YgcGFyZW50W2tleV0pIHtcbiAgICAgICAgICAgICAgcGFyZW50W2tleV0gPSB2YWw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCd1bmRlZmluZWQnID09IHR5cGVvZiBwYXJlbnRba2V5XSkge1xuICAgICAgICAgICAgICBwYXJlbnRba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcmVudFtrZXldID0gW3BhcmVudFtrZXldLCB2YWxdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIC8vIGFycmF5XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9iaiA9IHBhcmVudFtrZXldID0gcGFyZW50W2tleV0gfHwgW107XG4gICAgICAgICAgICBpZiAoJ10nID09IHBhcnQpIHtcbiAgICAgICAgICAgICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgICAgIGlmICgnJyAhPSB2YWwpIG9iai5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoJ29iamVjdCcgPT0gdHlwZW9mIG9iaikge1xuICAgICAgICAgICAgICAgIG9ialtvYmplY3RLZXlzKG9iaikubGVuZ3RoXSA9IHZhbDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmogPSBwYXJlbnRba2V5XSA9IFtwYXJlbnRba2V5XSwgdmFsXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcHJvcFxuICAgICAgICAgICAgfSBlbHNlIGlmICh+cGFydC5pbmRleE9mKCddJykpIHtcbiAgICAgICAgICAgICAgcGFydCA9IHBhcnQuc3Vic3RyKDAsIHBhcnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgIGlmKG5vdGludC50ZXN0KHBhcnQpICYmIGlzQXJyYXkob2JqKSkgb2JqID0gcHJvbW90ZShwYXJlbnQsIGtleSk7XG4gICAgICAgICAgICAgIHBhcnNlKHBhcnRzLCBvYmosIHBhcnQpO1xuICAgICAgICAgICAgLy8ga2V5XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZihub3RpbnQudGVzdChwYXJ0KSAmJiBpc0FycmF5KG9iaikpIG9iaiA9IHByb21vdGUocGFyZW50LCBrZXkpO1xuICAgICAgICAgICAgICBwYXJzZShwYXJ0cywgb2JqLCBwYXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZShwYXJ0cywgcGFyZW50LCAnYmFzZScpO1xuICAgICAgLy8gb3B0aW1pemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChub3RpbnQudGVzdChrZXkpICYmIGlzQXJyYXkocGFyZW50LmJhc2UpKSB7XG4gICAgICAgICAgdmFyIHQgPSB7fTtcbiAgICAgICAgICBmb3IodmFyIGsgaW4gcGFyZW50LmJhc2UpIHRba10gPSBwYXJlbnQuYmFzZVtrXTtcbiAgICAgICAgICBwYXJlbnQuYmFzZSA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KHBhcmVudC5iYXNlLCBrZXksIHZhbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSwge2Jhc2U6IHt9fSkuYmFzZTtcbn07XG5cbi8qKlxuICogVHVybiB0aGUgZ2l2ZW4gYG9iamAgaW50byBhIHF1ZXJ5IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudmFyIHN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24ob2JqLCBwcmVmaXgpIHtcbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlBcnJheShvYmosIHByZWZpeCk7XG4gIH0gZWxzZSBpZiAoJ1tvYmplY3QgT2JqZWN0XScgPT0gdG9TdHJpbmcuY2FsbChvYmopKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdChvYmosIHByZWZpeCk7XG4gIH0gZWxzZSBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIG9iaikge1xuICAgIHJldHVybiBzdHJpbmdpZnlTdHJpbmcob2JqLCBwcmVmaXgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcmVmaXg7XG4gIH1cbn07XG5cbi8qKlxuICogU3RyaW5naWZ5IHRoZSBnaXZlbiBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlTdHJpbmcoc3RyLCBwcmVmaXgpIHtcbiAgaWYgKCFwcmVmaXgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ2lmeSBleHBlY3RzIGFuIG9iamVjdCcpO1xuICByZXR1cm4gcHJlZml4ICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cik7XG59XG5cbi8qKlxuICogU3RyaW5naWZ5IHRoZSBnaXZlbiBgYXJyYC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXhcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5KGFyciwgcHJlZml4KSB7XG4gIHZhciByZXQgPSBbXTtcbiAgaWYgKCFwcmVmaXgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ2lmeSBleHBlY3RzIGFuIG9iamVjdCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIHJldC5wdXNoKHN0cmluZ2lmeShhcnJbaV0sIHByZWZpeCArICdbXScpKTtcbiAgfVxuICByZXR1cm4gcmV0LmpvaW4oJyYnKTtcbn1cblxuLyoqXG4gKiBTdHJpbmdpZnkgdGhlIGdpdmVuIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXhcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdChvYmosIHByZWZpeCkge1xuICB2YXIgcmV0ID0gW11cbiAgICAsIGtleXMgPSBvYmplY3RLZXlzKG9iailcbiAgICAsIGtleTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGtleXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIHJldC5wdXNoKHN0cmluZ2lmeShvYmpba2V5XSwgcHJlZml4XG4gICAgICA/IHByZWZpeCArICdbJyArIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJ10nXG4gICAgICA6IGVuY29kZVVSSUNvbXBvbmVudChrZXkpKSk7XG4gIH1cbiAgcmV0dXJuIHJldC5qb2luKCcmJyk7XG59XG5cbi8qKlxuICogU2V0IGBvYmpgJ3MgYGtleWAgdG8gYHZhbGAgcmVzcGVjdGluZ1xuICogdGhlIHdlaXJkIGFuZCB3b25kZXJmdWwgc3ludGF4IG9mIGEgcXMsXG4gKiB3aGVyZSBcImZvbz1iYXImZm9vPWJhelwiIGJlY29tZXMgYW4gYXJyYXkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2V0KG9iaiwga2V5LCB2YWwpIHtcbiAgdmFyIHYgPSBvYmpba2V5XTtcbiAgaWYgKHVuZGVmaW5lZCA9PT0gdikge1xuICAgIG9ialtrZXldID0gdmFsO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodikpIHtcbiAgICB2LnB1c2godmFsKTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IFt2LCB2YWxdO1xuICB9XG59XG5cbi8qKlxuICogTG9jYXRlIGxhc3QgYnJhY2UgaW4gYHN0cmAgd2l0aGluIHRoZSBrZXkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbGFzdEJyYWNlSW5LZXkoc3RyKSB7XG4gIHZhciBsZW4gPSBzdHIubGVuZ3RoXG4gICAgLCBicmFjZVxuICAgICwgYztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGMgPSBzdHJbaV07XG4gICAgaWYgKCddJyA9PSBjKSBicmFjZSA9IGZhbHNlO1xuICAgIGlmICgnWycgPT0gYykgYnJhY2UgPSB0cnVlO1xuICAgIGlmICgnPScgPT0gYyAmJiAhYnJhY2UpIHJldHVybiBpO1xuICB9XG59XG4iLCJ2YXIgdHJpbUxlYWRpbmcgPSByZXF1aXJlKCdodG1sLXV0aWwnKS50cmltTGVhZGluZztcblxuZXhwb3J0cy53cmFwUmVtYWluZGVyID0gd3JhcFJlbWFpbmRlcjtcbmV4cG9ydHMuZXh0cmFjdFBsYWNlaG9sZGVyID0gZXh0cmFjdFBsYWNlaG9sZGVyO1xuZXhwb3J0cy5wYXRoRm5BcmdzID0gcGF0aEZuQXJncztcbmV4cG9ydHMuc3F1YXJlQnJhY2tldHNBcmdzID0gc3F1YXJlQnJhY2tldHNBcmdzO1xuZXhwb3J0cy5jdHhQYXRoID0gY3R4UGF0aDtcbmV4cG9ydHMuZ2V0VmFsdWUgPSBnZXRWYWx1ZTtcbmV4cG9ydHMuZGF0YVZhbHVlID0gZGF0YVZhbHVlO1xuZXhwb3J0cy5zZXRCb3VuZEZuID0gc2V0Qm91bmRGbjtcbmV4cG9ydHMubG9va3VwID0gbG9va3VwO1xuZXhwb3J0cy5yZXBsYWNlU3F1YXJlQnJhY2tldHMgPSByZXBsYWNlU3F1YXJlQnJhY2tldHM7XG5cbmZ1bmN0aW9uIHdyYXBSZW1haW5kZXIodGFnTmFtZSwgcmVtYWluZGVyKSB7XG4gIGlmICghcmVtYWluZGVyKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiAhKG5ldyBSZWdFeHAoJ148XFwvJyArIHRhZ05hbWUsICdpJykpLnRlc3QocmVtYWluZGVyKTtcbn1cblxudmFyIG9wZW5QbGFjZWhvbGRlciA9IC9eKFtcXHNcXFNdKj8pKFxce3sxLDN9KVxccyooW1xcc1xcU10qKS9cbiAgLCBhbGlhc0NvbnRlbnQgPSAvXihbXFxzXFxTXSopXFxzK2FzXFxzKzooXFxTKylcXHMqJC9cbiAgLCBibG9ja0NvbnRlbnQgPSAvXihbXFwjXFwvXT8pKGVsc2VcXHNpZnxpZnxlbHNlfHVubGVzc3xlYWNofHdpdGh8dW5lc2NhcGVkKT9cXHMqKFtcXHNcXFNdKj8pXFxzKiQvXG4gICwgY2xvc2VNYXAgPSB7IDE6ICd9JywgMjogJ319JyB9XG5mdW5jdGlvbiBleHRyYWN0UGxhY2Vob2xkZXIodGV4dCkge1xuICB2YXIgbWF0Y2ggPSBvcGVuUGxhY2Vob2xkZXIuZXhlYyh0ZXh0KTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuO1xuICB2YXIgcHJlID0gbWF0Y2hbMV1cbiAgICAsIG9wZW4gPSBtYXRjaFsyXVxuICAgICwgcmVtYWluZGVyID0gbWF0Y2hbM11cbiAgICAsIG9wZW5MZW4gPSBvcGVuLmxlbmd0aFxuICAgICwgYm91bmQgPSBvcGVuTGVuID09PSAxXG4gICAgLCBlbmQgPSBtYXRjaEJyYWNlcyhyZW1haW5kZXIsIG9wZW5MZW4sIDAsICd7JywgJ30nKVxuICAgICwgZW5kSW5uZXIgPSBlbmQgLSBvcGVuTGVuXG4gICAgLCBpbm5lciA9IHJlbWFpbmRlci5zbGljZSgwLCBlbmRJbm5lcilcbiAgICAsIHBvc3QgPSByZW1haW5kZXIuc2xpY2UoZW5kKVxuICAgICwgYWxpYXMsIGhhc2gsIHR5cGUsIG5hbWUsIGVzY2FwZWQ7XG5cbiAgaWYgKC9bXCJ7W10vLnRlc3QoaW5uZXIpKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UgZGlkbid0IGFjY2lkZW50YWxseSBtYXRjaCBhIEpTT04gbGl0ZXJhbFxuICAgIHRyeSB7XG4gICAgICBKU09OLnBhcnNlKG9wZW4gKyBpbm5lciArIGNsb3NlTWFwW29wZW5MZW5dKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG5cbiAgbWF0Y2ggPSBhbGlhc0NvbnRlbnQuZXhlYyhpbm5lcik7XG4gIGlmIChtYXRjaCkge1xuICAgIGlubmVyID0gbWF0Y2hbMV07XG4gICAgYWxpYXMgPSBtYXRjaFsyXTtcbiAgfVxuXG4gIG1hdGNoID0gYmxvY2tDb250ZW50LmV4ZWMoaW5uZXIpXG4gIGlmICghbWF0Y2gpIHJldHVybjtcbiAgaGFzaCA9IG1hdGNoWzFdO1xuICB0eXBlID0gbWF0Y2hbMl07XG4gIG5hbWUgPSBtYXRjaFszXTtcblxuICBlc2NhcGVkID0gdHJ1ZTtcbiAgaWYgKHR5cGUgPT09ICd1bmVzY2FwZWQnKSB7XG4gICAgZXNjYXBlZCA9IGZhbHNlO1xuICAgIHR5cGUgPSAnJztcbiAgfVxuICBpZiAoYm91bmQpIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1xcYnRoaXNcXGIvLCAnLicpO1xuICByZXR1cm4ge1xuICAgIHByZTogcHJlXG4gICwgcG9zdDogcG9zdFxuICAsIGJvdW5kOiBib3VuZFxuICAsIGFsaWFzOiBhbGlhc1xuICAsIGhhc2g6IGhhc2hcbiAgLCB0eXBlOiB0eXBlXG4gICwgbmFtZTogbmFtZVxuICAsIGVzY2FwZWQ6IGVzY2FwZWRcbiAgLCBzb3VyY2U6IHRleHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hCcmFjZXModGV4dCwgbnVtLCBpLCBvcGVuQ2hhciwgY2xvc2VDaGFyKSB7XG4gIHZhciBjbG9zZSwgaGFzQ2xvc2UsIGhhc09wZW4sIG9wZW47XG4gIGkrKztcbiAgd2hpbGUgKG51bSkge1xuICAgIGNsb3NlID0gdGV4dC5pbmRleE9mKGNsb3NlQ2hhciwgaSk7XG4gICAgb3BlbiA9IHRleHQuaW5kZXhPZihvcGVuQ2hhciwgaSk7XG4gICAgaGFzQ2xvc2UgPSB+Y2xvc2U7XG4gICAgaGFzT3BlbiA9IH5vcGVuO1xuICAgIGlmIChoYXNDbG9zZSAmJiAoIWhhc09wZW4gfHwgKGNsb3NlIDwgb3BlbikpKSB7XG4gICAgICBpID0gY2xvc2UgKyAxO1xuICAgICAgbnVtLS07XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKGhhc09wZW4pIHtcbiAgICAgIGkgPSBvcGVuICsgMTtcbiAgICAgIG51bSsrO1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5cbnZhciBmbkNhbGwgPSAvXihbXihdKylcXHMqXFwoXFxzKihbXFxzXFxTXSo/KVxccypcXClcXHMqJC9cbiAgLCBhcmdTZXBhcmF0b3IgPSAvXFxzKihbLChdKVxccyovZ1xuICAsIG5vdFNlcGFyYXRvciA9IC9bXixcXHNdL2dcbiAgLCBub3RQYXRoQXJnID0gLyg/Ol5bJ1wiXFxkXFwtW3tdKXwoPzpebnVsbCQpfCg/Ol50cnVlJCl8KD86XmZhbHNlJCkvO1xuXG5mdW5jdGlvbiBmbkFyZ3MoaW5uZXIpIHtcbiAgdmFyIGFyZ3MgPSBbXVxuICAgICwgbGFzdEluZGV4ID0gMFxuICAgICwgbWF0Y2gsIGVuZCwgbGFzdDtcbiAgd2hpbGUgKG1hdGNoID0gYXJnU2VwYXJhdG9yLmV4ZWMoaW5uZXIpKSB7XG4gICAgaWYgKG1hdGNoWzFdID09PSAnKCcpIHtcbiAgICAgIGVuZCA9IG1hdGNoQnJhY2VzKGlubmVyLCAxLCBhcmdTZXBhcmF0b3IubGFzdEluZGV4LCAnKCcsICcpJyk7XG4gICAgICBhcmdzLnB1c2goaW5uZXIuc2xpY2UobGFzdEluZGV4LCBlbmQpKTtcbiAgICAgIG5vdFNlcGFyYXRvci5sYXN0SW5kZXggPSBlbmQ7XG4gICAgICBsYXN0SW5kZXggPSBhcmdTZXBhcmF0b3IubGFzdEluZGV4ID1cbiAgICAgICAgbm90U2VwYXJhdG9yLnRlc3QoaW5uZXIpID8gbm90U2VwYXJhdG9yLmxhc3RJbmRleCAtIDEgOiBlbmQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgYXJncy5wdXNoKGlubmVyLnNsaWNlKGxhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICBsYXN0SW5kZXggPSBhcmdTZXBhcmF0b3IubGFzdEluZGV4O1xuICB9XG4gIGxhc3QgPSBpbm5lci5zbGljZShsYXN0SW5kZXgpO1xuICBpZiAobGFzdCkgYXJncy5wdXNoKGxhc3QpO1xuICByZXR1cm4gYXJncztcbn1cblxuZnVuY3Rpb24gZm5DYWxsRXJyb3IobmFtZSkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ21hbGZvcm1lZCB2aWV3IGZ1bmN0aW9uIGNhbGw6ICcgKyBuYW1lKTtcbn1cblxuZnVuY3Rpb24gZm5BcmdWYWx1ZSh2aWV3LCBjdHgsIG1vZGVsLCBuYW1lLCBhcmcpIHtcbiAgdmFyIGxpdGVyYWwgPSBsaXRlcmFsVmFsdWUoYXJnKTtcbiAgaWYgKGxpdGVyYWwgIT09IHZvaWQgMCkgcmV0dXJuIGxpdGVyYWw7XG5cbiAgdmFyIHBhdGhNYXAgPSBtb2RlbC5fX3BhdGhNYXA7XG4gIGlmICghcGF0aE1hcCkgcmV0dXJuIGRhdGFWYWx1ZSh2aWV3LCBjdHgsIG1vZGVsLCBhcmcpO1xuXG4gIHZhciBhcmdJZHMgPSBjdHguaGFzT3duUHJvcGVydHkoJyRmbkFyZ0lkcycpID9cbiAgICBjdHguJGZuQXJnSWRzIDogKGN0eC4kZm5BcmdJZHMgPSB7fSk7XG4gIHZhciBwYXRoSWQgPSBhcmdJZHNbYXJnXTtcbiAgdmFyIHBhdGg7XG4gIGlmIChwYXRoSWQpIHtcbiAgICBwYXRoID0gcGF0aE1hcC5wYXRoc1twYXRoSWRdO1xuICB9IGVsc2Uge1xuICAgIHBhdGggPSBjdHhQYXRoKHZpZXcsIGN0eCwgYXJnKTtcbiAgICBhcmdJZHNbYXJnXSA9IHBhdGhNYXAuaWQocGF0aCk7XG4gIH1cbiAgcmV0dXJuIGRhdGFWYWx1ZSh2aWV3LCBjdHgsIG1vZGVsLCBwYXRoKTtcbn1cblxuZnVuY3Rpb24gZm5WYWx1ZSh2aWV3LCBjdHgsIG1vZGVsLCBuYW1lKSB7XG4gIHZhciBtYXRjaCA9IGZuQ2FsbC5leGVjKG5hbWUpIHx8IGZuQ2FsbEVycm9yKG5hbWUpXG4gICAgLCBmbk5hbWUgPSBtYXRjaFsxXVxuICAgICwgYXJncyA9IGZuQXJncyhtYXRjaFsyXSlcbiAgICAsIGZuLCBmbk5hbWUsIGk7XG4gIGZvciAoaSA9IGFyZ3MubGVuZ3RoOyBpLS07KSB7XG4gICAgYXJnc1tpXSA9IGZuQXJnVmFsdWUodmlldywgY3R4LCBtb2RlbCwgbmFtZSwgYXJnc1tpXSk7XG4gIH1cbiAgaWYgKCEoZm4gPSB2aWV3LmdldEZuc1tmbk5hbWVdKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndmlldyBmdW5jdGlvbiBcIicgKyBmbk5hbWUgKyAnXCIgbm90IGZvdW5kIGZvciBjYWxsOiAnICsgbmFtZSk7XG4gIH1cbiAgcmV0dXJuIGZuLmFwcGx5KHt2aWV3OiB2aWV3LCBjdHg6IGN0eCwgbW9kZWw6IG1vZGVsfSwgYXJncyk7XG59XG5cbmZ1bmN0aW9uIHBhdGhGbkFyZ3MobmFtZSwgcGF0aHMpIHtcbiAgdmFyIG1hdGNoID0gZm5DYWxsLmV4ZWMobmFtZSkgfHwgZm5DYWxsRXJyb3IobmFtZSlcbiAgICAsIGFyZ3MgPSBmbkFyZ3MobWF0Y2hbMl0pXG4gICAgLCBpLCBhcmc7XG4gIGlmIChwYXRocyA9PSBudWxsKSBwYXRocyA9IFtdO1xuICBmb3IgKGkgPSBhcmdzLmxlbmd0aDsgaS0tOykge1xuICAgIGFyZyA9IGFyZ3NbaV07XG4gICAgaWYgKG5vdFBhdGhBcmcudGVzdChhcmcpKSBjb250aW51ZTtcbiAgICBpZiAofmFyZy5pbmRleE9mKCcoJykpIHtcbiAgICAgIHBhdGhGbkFyZ3MoYXJnLCBwYXRocyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcGF0aHMucHVzaChhcmcpO1xuICB9XG4gIHJldHVybiBwYXRocztcbn1cblxuZnVuY3Rpb24gcmVsYXRpdmVQYXRoKHZpZXcsIGN0eCwgaSwgcmVtYWluZGVyKSB7XG4gIHZhciBuYW1lID0gY3R4LiRwYXRoc1tpIC0gMV0gKyByZW1haW5kZXI7XG5cbiAgLy8gcGF0aE1hcCBpcyBvbmx5IGNyZWF0ZWQgaW4gdGhlIGJyb3dzZXJcbiAgdmFyIHBhdGhNYXAgPSB2aWV3Lm1vZGVsLl9fcGF0aE1hcDtcbiAgaWYgKCFwYXRoTWFwKSByZXR1cm4gbmFtZTtcbiAgdmFyIHBhdGhJZCA9IGN0eC4kcGF0aElkc1tuYW1lXSB8fCAoY3R4LiRwYXRoSWRzW25hbWVdID0gcGF0aE1hcC5pZChuYW1lKSk7XG4gIHJldHVybiBwYXRoTWFwLnBhdGhzW3BhdGhJZF07XG59XG5cbmZ1bmN0aW9uIG1hY3JvTmFtZSh2aWV3LCBjdHgsIG5hbWUpIHtcbiAgaWYgKG5hbWUuY2hhckF0KDApICE9PSAnQCcpIHJldHVybjtcblxuICB2YXIgc2VnbWVudHMgPSBuYW1lLnNsaWNlKDEpLnNwbGl0KCcuJyk7XG4gIHZhciBiYXNlID0gc2VnbWVudHMuc2hpZnQoKS50b0xvd2VyQ2FzZSgpO1xuICB2YXIgdmFsdWUgPSBsb29rdXAoYmFzZSwgY3R4LiRtYWNyb0N0eCk7XG4gIHZhciBtYXRjaE5hbWUgPSB2YWx1ZSAmJiB2YWx1ZS4kbWF0Y2hOYW1lO1xuICB2YXIgcmVtYWluZGVyID0gc2VnbWVudHMuam9pbignLicpO1xuXG4gIGlmIChtYXRjaE5hbWUpIHtcbiAgICBpZiAoIXJlbWFpbmRlcikgcmV0dXJuIHZhbHVlO1xuICAgIHJldHVybiB7JG1hdGNoTmFtZTogbWF0Y2hOYW1lICsgJy4nICsgcmVtYWluZGVyfTtcbiAgfVxuICByZXR1cm4gKHJlbWFpbmRlcikgPyBiYXNlICsgJy4nICsgcmVtYWluZGVyIDogYmFzZTtcbn1cblxuZnVuY3Rpb24gY3R4UGF0aCh2aWV3LCBjdHgsIG5hbWUpIHtcbiAgdmFyIGlzV2lsZGNhcmQgPSBuYW1lLmNoYXJBdChuYW1lLmxlbmd0aCAtIDEpID09PSAnKic7XG4gIGlmIChpc1dpbGRjYXJkKSBuYW1lID0gbmFtZS5zbGljZSgwLCAtMSk7XG5cbiAgdmFyIG1hY3JvUGF0aCA9IG1hY3JvTmFtZSh2aWV3LCBjdHgsIG5hbWUpO1xuICBpZiAobWFjcm9QYXRoICYmIG1hY3JvUGF0aC4kbWF0Y2hOYW1lKSBuYW1lID0gbWFjcm9QYXRoLiRtYXRjaE5hbWU7XG5cbiAgdmFyIGZpcnN0Q2hhciA9IG5hbWUuY2hhckF0KDApXG4gICAgLCBpLCBhbGlhc05hbWUsIHJlbWFpbmRlclxuXG4gIC8vIFJlc29sdmUgcGF0aCBhbGlhc2VzXG4gIGlmIChmaXJzdENoYXIgPT09ICc6Jykge1xuICAgIGlmICh+KGkgPSBuYW1lLnNlYXJjaCgvWy5bXS8pKSkge1xuICAgICAgYWxpYXNOYW1lID0gbmFtZS5zbGljZSgxLCBpKTtcbiAgICAgIHJlbWFpbmRlciA9IG5hbWUuc2xpY2UoaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFsaWFzTmFtZSA9IG5hbWUuc2xpY2UoMSk7XG4gICAgICByZW1haW5kZXIgPSAnJztcbiAgICB9XG4gICAgYWxpYXNOYW1lID0gYWxpYXNOYW1lO1xuICAgIGkgPSBjdHguJHBhdGhzLmxlbmd0aCAtIGN0eC4kYWxpYXNlc1thbGlhc05hbWVdO1xuICAgIGlmIChpICE9PSBpKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIGFsaWFzOiAnICsgbmFtZSk7XG5cbiAgICBuYW1lID0gcmVsYXRpdmVQYXRoKHZpZXcsIGN0eCwgaSwgcmVtYWluZGVyKTtcblxuICAvLyBSZXNvbHZlIHJlbGF0aXZlIHBhdGhzXG4gIH0gZWxzZSBpZiAoZmlyc3RDaGFyID09PSAnLicpIHtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAobmFtZS5jaGFyQXQoaSkgPT09ICcuJykge1xuICAgICAgaSsrO1xuICAgIH1cbiAgICByZW1haW5kZXIgPSBpID09PSBuYW1lLmxlbmd0aCA/ICcnIDogbmFtZS5zbGljZShpIC0gMSk7XG5cbiAgICBuYW1lID0gcmVsYXRpdmVQYXRoKHZpZXcsIGN0eCwgaSwgcmVtYWluZGVyKTtcbiAgfVxuXG4gIG5hbWUgPSByZXBsYWNlU3F1YXJlQnJhY2tldHModmlldywgY3R4LCBuYW1lKTtcbiAgaWYgKGlzV2lsZGNhcmQpIG5hbWUgKz0gJyonO1xuICByZXR1cm4gbmFtZTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZVNxdWFyZUJyYWNrZXRzKHZpZXcsIGN0eCwgbmFtZSkge1xuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgdmFyIGkgPSBuYW1lLmluZGV4T2YoJ1snKTtcbiAgaWYgKGkgPT09IC0xKSByZXR1cm4gbmFtZTtcblxuICB2YXIgZW5kID0gbWF0Y2hCcmFjZXMobmFtZSwgMSwgaSwgJ1snLCAnXScpO1xuICAvLyBUaGlzIHNob3VsZG4ndCBub3JtYWxseSBoYXBwZW4sIGJ1dCBqdXN0IGluIGNhc2UgcmV0dXJuXG4gIGlmIChlbmQgPT09IC0xKSByZXR1cm47XG4gIHZhciBiZWZvcmUgPSBuYW1lLnNsaWNlKDAsIGkpO1xuICB2YXIgaW5zaWRlID0gbmFtZS5zbGljZShpICsgMSwgZW5kIC0gMSk7XG4gIHZhciBhZnRlciA9IG5hbWUuc2xpY2UoZW5kKTtcblxuICBuYW1lID0gcmVwbGFjZVNxdWFyZUJyYWNrZXRzKHZpZXcsIGN0eCwgaW5zaWRlKTtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUodmlldywgY3R4LCB2aWV3Lm1vZGVsLCBuYW1lKTtcbiAgbmFtZSA9ICh2YWx1ZSA9PSBudWxsKSA/ICckbnVsbCcgOiB2YWx1ZTtcbiAgdmFyIG91dCA9IChiZWZvcmUpID8gYmVmb3JlICsgJy4nICsgbmFtZSA6IG5hbWU7XG5cbiAgd2hpbGUgKGFmdGVyKSB7XG4gICAgaSA9IGFmdGVyLmluZGV4T2YoJ1snKTtcbiAgICBpZiAoaSA9PT0gLTEpIHJldHVybiBvdXQgKyBhZnRlcjtcblxuICAgIG5hbWUgPSBhZnRlcjtcbiAgICBlbmQgPSBtYXRjaEJyYWNlcyhuYW1lLCAxLCBpLCAnWycsICddJyk7XG4gICAgaWYgKGVuZCA9PT0gLTEpIHJldHVybjtcbiAgICBiZWZvcmUgPSBuYW1lLnNsaWNlKDAsIGkpO1xuICAgIGluc2lkZSA9IG5hbWUuc2xpY2UoaSArIDEsIGVuZCAtIDEpO1xuICAgIGFmdGVyID0gbmFtZS5zbGljZShlbmQpO1xuXG4gICAgaWYgKGJlZm9yZSkgb3V0ICs9IGJlZm9yZTtcblxuICAgIG5hbWUgPSByZXBsYWNlU3F1YXJlQnJhY2tldHModmlldywgY3R4LCBpbnNpZGUpO1xuICAgIHZhbHVlID0gZ2V0VmFsdWUodmlldywgY3R4LCB2aWV3Lm1vZGVsLCBuYW1lKTtcbiAgICB2YWx1ZSA9ICh2YWx1ZSA9PSBudWxsKSA/ICckbnVsbCcgOiB2YWx1ZTtcbiAgICBvdXQgKz0gJy4nICsgdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gc3F1YXJlQnJhY2tldHNBcmdzKG5hbWUsIHBhdGhzKSB7XG4gIHBhdGhzIHx8IChwYXRocyA9IFtdKTtcblxuICB3aGlsZSAobmFtZSkge1xuICAgIGkgPSBuYW1lLmluZGV4T2YoJ1snKTtcbiAgICBpZiAoaSA9PT0gLTEpIHJldHVybiBwYXRocztcblxuICAgIGVuZCA9IG1hdGNoQnJhY2VzKG5hbWUsIDEsIGksICdbJywgJ10nKTtcbiAgICBpZiAoZW5kID09PSAtMSkgcmV0dXJuIHBhdGhzO1xuICAgIGluc2lkZSA9IG5hbWUuc2xpY2UoaSArIDEsIGVuZCAtIDEpO1xuICAgIG5hbWUgPSBuYW1lLnNsaWNlKGVuZCk7XG5cbiAgICBpZiAoaW5zaWRlLmluZGV4T2YoJ1snKSA9PT0gLTEpIHtcbiAgICAgIHBhdGhzLnB1c2goaW5zaWRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3F1YXJlQnJhY2tldHNBcmdzKGluc2lkZSwgcGF0aHMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGF0aHM7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZVZhbHVlKHZhbHVlLCBlc2NhcGUpIHtcbiAgcmV0dXJuIGVzY2FwZSA/IGVzY2FwZSh2YWx1ZSkgOiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gbGl0ZXJhbFZhbHVlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gJ251bGwnKSByZXR1cm4gbnVsbDtcbiAgaWYgKHZhbHVlID09PSAndHJ1ZScpIHJldHVybiB0cnVlO1xuICBpZiAodmFsdWUgPT09ICdmYWxzZScpIHJldHVybiBmYWxzZTtcbiAgdmFyIGZpcnN0Q2hhciA9IHZhbHVlLmNoYXJBdCgwKVxuICAgICwgbWF0Y2g7XG4gIGlmIChmaXJzdENoYXIgPT09IFwiJ1wiKSB7XG4gICAgbWF0Y2ggPSAvXicoLiopJyQvLmV4ZWModmFsdWUpIHx8IGZuQ2FsbEVycm9yKHZhbHVlKTtcbiAgICByZXR1cm4gbWF0Y2hbMV07XG4gIH1cbiAgaWYgKGZpcnN0Q2hhciA9PT0gJ1wiJykge1xuICAgIG1hdGNoID0gL15cIiguKilcIiQvLmV4ZWModmFsdWUpIHx8IGZuQ2FsbEVycm9yKHZhbHVlKTtcbiAgICByZXR1cm4gbWF0Y2hbMV07XG4gIH1cbiAgaWYgKC9eW1xcZFxcLV0vLnRlc3QoZmlyc3RDaGFyKSAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgcmV0dXJuICt2YWx1ZTtcbiAgfVxuICBpZiAoZmlyc3RDaGFyID09PSAnWycgfHwgZmlyc3RDaGFyID09PSAneycpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUodmlldywgY3R4LCBtb2RlbCwgbmFtZSwgZXNjYXBlLCBmb3JjZUVzY2FwZSkge1xuICB2YXIgbGl0ZXJhbCA9IGxpdGVyYWxWYWx1ZShuYW1lKVxuICBpZiAobGl0ZXJhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGRhdGFWYWx1ZSh2aWV3LCBjdHgsIG1vZGVsLCBuYW1lLCBlc2NhcGUsIGZvcmNlRXNjYXBlKTtcbiAgfVxuICByZXR1cm4gbGl0ZXJhbDtcbn1cblxuZnVuY3Rpb24gZGF0YVZhbHVlKHZpZXcsIGN0eCwgbW9kZWwsIG5hbWUsIGVzY2FwZSwgZm9yY2VFc2NhcGUpIHtcbiAgdmFyIG1hY3JvUGF0aCwgcGF0aCwgdmFsdWU7XG4gIGlmICghbmFtZSkgcmV0dXJuO1xuICBpZiAofm5hbWUuaW5kZXhPZignKCcpKSB7XG4gICAgdmFsdWUgPSBmblZhbHVlKHZpZXcsIGN0eCwgbW9kZWwsIG5hbWUpO1xuICAgIHJldHVybiBlc2NhcGVWYWx1ZSh2YWx1ZSwgZXNjYXBlKTtcbiAgfVxuICBwYXRoID0gY3R4UGF0aCh2aWV3LCBjdHgsIG5hbWUpO1xuICBtYWNyb1BhdGggPSBtYWNyb05hbWUodmlldywgY3R4LCBwYXRoKTtcbiAgaWYgKG1hY3JvUGF0aCkge1xuICAgIGlmIChtYWNyb1BhdGguJG1hdGNoTmFtZSkge1xuICAgICAgcGF0aCA9IG1hY3JvUGF0aC4kbWF0Y2hOYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IGxvb2t1cChtYWNyb1BhdGgsIGN0eC4kbWFjcm9DdHgpO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAodmFsdWUudW5lc2NhcGVkICYmICFmb3JjZUVzY2FwZSkgcmV0dXJuIHZhbHVlKGN0eCwgbW9kZWwpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlKGN0eCwgbW9kZWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVzY2FwZVZhbHVlKHZhbHVlLCBlc2NhcGUpO1xuICAgIH1cbiAgfVxuICB2YWx1ZSA9IGxvb2t1cChwYXRoLCBjdHgpO1xuICBpZiAodmFsdWUgPT09IHZvaWQgMCkgdmFsdWUgPSBtb2RlbC5nZXQocGF0aClcbiAgcmV0dXJuIGVzY2FwZVZhbHVlKHZhbHVlLCBlc2NhcGUpO1xufVxuXG5mdW5jdGlvbiBzZXRCb3VuZEZuKHZpZXcsIGN0eCwgbW9kZWwsIG5hbWUsIHZhbHVlKSB7XG4gIHZhciBtYXRjaCA9IGZuQ2FsbC5leGVjKG5hbWUpIHx8IGZuQ2FsbEVycm9yKG5hbWUpXG4gICAgLCBmbk5hbWUgPSBtYXRjaFsxXVxuICAgICwgYXJncyA9IGZuQXJncyhtYXRjaFsyXSlcbiAgICAsIGdldCA9IHZpZXcuZ2V0Rm5zW2ZuTmFtZV1cbiAgICAsIHNldCA9IHZpZXcuc2V0Rm5zW2ZuTmFtZV1cbiAgICAsIG51bUlucHV0cyA9IHNldCAmJiBzZXQubGVuZ3RoIC0gMVxuICAgICwgYXJnLCBpLCBpbnB1dHMsIG91dCwga2V5LCBwYXRoLCBsZW47XG5cbiAgaWYgKCEoZ2V0ICYmIHNldCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZpZXcgZnVuY3Rpb24gXCInICsgZm5OYW1lICsgJ1wiIHNldHRlciBub3QgZm91bmQgZm9yIGJpbmRpbmcgdG86ICcgKyBuYW1lKTtcbiAgfVxuXG4gIGlmIChudW1JbnB1dHMpIHtcbiAgICBpbnB1dHMgPSBbdmFsdWVdO1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgbnVtSW5wdXRzKSB7XG4gICAgICBpbnB1dHMucHVzaChmbkFyZ1ZhbHVlKHZpZXcsIGN0eCwgbW9kZWwsIG5hbWUsIGFyZ3NbaSsrXSkpO1xuICAgIH1cbiAgICBvdXQgPSBzZXQuYXBwbHkobnVsbCwgaW5wdXRzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXQgPSBzZXQodmFsdWUpO1xuICB9XG4gIGlmICghb3V0KSByZXR1cm47XG5cbiAgZm9yIChrZXkgaW4gb3V0KSB7XG4gICAgdmFsdWUgPSBvdXRba2V5XTtcbiAgICBhcmcgPSBhcmdzW2tleV07XG4gICAgaWYgKH5hcmcuaW5kZXhPZignKCcpKSB7XG4gICAgICBzZXRCb3VuZEZuKHZpZXcsIGN0eCwgbW9kZWwsIGFyZywgdmFsdWUpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwIHx8IG5vdFBhdGhBcmcudGVzdChhcmcpKSBjb250aW51ZTtcbiAgICBwYXRoID0gY3R4UGF0aCh2aWV3LCBjdHgsIGFyZyk7XG4gICAgaWYgKG1vZGVsLmdldChwYXRoKSA9PT0gdmFsdWUpIGNvbnRpbnVlO1xuICAgIG1vZGVsLnNldChwYXRoLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbG9va3VwKHBhdGgsIG9iaikge1xuICBpZiAoIXBhdGggfHwgIW9iaikgcmV0dXJuO1xuICBpZiAocGF0aC5pbmRleE9mKCcuJykgPT09IC0xKSByZXR1cm4gb2JqW3BhdGhdO1xuXG4gIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIG9iajtcblxuICAgIHZhciBwcm9wID0gcGFydHNbaV07XG4gICAgb2JqID0gb2JqW3Byb3BdO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG4iLCJ2YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaGFubmVsO1xuXG5mdW5jdGlvbiBDaGFubmVsKHNvY2tldCkge1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgdGhpcy5tZXNzYWdlcyA9IG5ldyBNZXNzYWdlcztcblxuICB2YXIgY2hhbm5lbCA9IHRoaXM7XG4gIHZhciBvbm1lc3NhZ2UgPSBzb2NrZXQub25tZXNzYWdlO1xuICBzb2NrZXQub25tZXNzYWdlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIGlmIChkYXRhICYmIGRhdGEucmFjZXIpIHJldHVybiBjaGFubmVsLl9vbk1lc3NhZ2UoZGF0YSk7XG4gICAgb25tZXNzYWdlICYmIG9ubWVzc2FnZS5jYWxsKHNvY2tldCwgZGF0YSk7XG4gIH07XG59XG5cbnV0aWwubWVyZ2VJbnRvKENoYW5uZWwucHJvdG90eXBlLCBFdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblxuQ2hhbm5lbC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG5hbWUsIGRhdGEsIGNiKSB7XG4gIHZhciBtZXNzYWdlID0gdGhpcy5tZXNzYWdlcy5hZGQobmFtZSwgZGF0YSwgY2IpO1xuICAvLyBQcm9hY3RpdmVseSBjYWxsIHRoZSB0b0pTT04gZnVuY3Rpb24sIHNpbmNlIHRoZSBHb29nbGUgQ2xvc3VyZSBKU09OXG4gIC8vIHNlcmlhbGl6ZXIgZG9lc24ndCBjaGVjayBmb3IgaXRcbiAgdGhpcy5zb2NrZXQuc2VuZChtZXNzYWdlLnRvSlNPTigpKTtcbn07XG5cbkNoYW5uZWwucHJvdG90eXBlLl9yZXBseSA9IGZ1bmN0aW9uKGlkLCBuYW1lLCBkYXRhKSB7XG4gIHZhciBtZXNzYWdlID0gbmV3IE1lc3NhZ2UoaWQsIHRydWUsIG5hbWUsIGRhdGEpO1xuICB0aGlzLnNvY2tldC5zZW5kKG1lc3NhZ2UudG9KU09OKCkpO1xufTtcblxuQ2hhbm5lbC5wcm90b3R5cGUuX29uTWVzc2FnZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgaWYgKGRhdGEuYWNrKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VzLnJlbW92ZShkYXRhLmlkKTtcbiAgICBpZiAobWVzc2FnZSAmJiBtZXNzYWdlLmNiKSBtZXNzYWdlLmNiLmFwcGx5KGRhdGEuZGF0YSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuYW1lID0gZGF0YS5yYWNlcjtcbiAgaWYgKGRhdGEuY2IpIHtcbiAgICB2YXIgY2hhbm5lbCA9IHRoaXM7XG4gICAgdmFyIGhhc0xpc3RlbmVycyA9IHRoaXMuZW1pdChuYW1lLCBkYXRhLmRhdGEsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgY2hhbm5lbC5fcmVwbHkoZGF0YS5pZCwgbmFtZSwgYXJncyk7XG4gICAgfSk7XG4gICAgaWYgKCFoYXNMaXN0ZW5lcnMpIHRoaXMuX3JlcGx5KGRhdGEuaWQsIG5hbWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZW1pdChuYW1lLCBkYXRhLmRhdGEpO1xuICAgIHRoaXMuX3JlcGx5KGRhdGEuaWQsIG5hbWUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBNZXNzYWdlc01hcCgpIHt9XG5cbmZ1bmN0aW9uIE1lc3NhZ2VzKCkge1xuICB0aGlzLm1hcCA9IG5ldyBNZXNzYWdlc01hcCgpO1xuICB0aGlzLmlkQ291bnQgPSAwO1xufVxuTWVzc2FnZXMucHJvdG90eXBlLmlkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoKyt0aGlzLmlkQ291bnQpLnRvU3RyaW5nKDM2KTtcbn07XG5NZXNzYWdlcy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24obmFtZSwgZGF0YSwgY2IpIHtcbiAgdmFyIG1lc3NhZ2UgPSBuZXcgTWVzc2FnZSh0aGlzLmlkKCksIGZhbHNlLCBuYW1lLCBkYXRhLCBjYik7XG4gIHRoaXMubWFwW21lc3NhZ2UuaWRdID0gbWVzc2FnZTtcbiAgcmV0dXJuIG1lc3NhZ2U7XG59O1xuTWVzc2FnZXMucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGlkKSB7XG4gIHZhciBtZXNzYWdlID0gdGhpcy5tYXBbaWRdO1xuICBkZWxldGUgdGhpcy5tYXBbaWRdO1xuICByZXR1cm4gbWVzc2FnZTtcbn07XG5cbmZ1bmN0aW9uIE1lc3NhZ2UoaWQsIGFjaywgbmFtZSwgZGF0YSwgY2IpIHtcbiAgdGhpcy5pZCA9IGlkO1xuICB0aGlzLmFjayA9IGFjaztcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5jYiA9IGNiO1xufVxuTWVzc2FnZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmFjZXI6IHRoaXMubmFtZVxuICAsIGlkOiB0aGlzLmlkXG4gICwgZGF0YTogdGhpcy5kYXRhXG4gICwgYWNrOiArdGhpcy5hY2tcbiAgLCBjYjogKHRoaXMuY2IpID8gMSA6IDBcbiAgfTtcbn07XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIEV4cG9zZSBgUm91dGVgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUm91dGU7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBgUm91dGVgIHdpdGggdGhlIGdpdmVuIEhUVFAgYG1ldGhvZGAsIGBwYXRoYCxcbiAqIGFuZCBhbiBhcnJheSBvZiBgY2FsbGJhY2tzYCBhbmQgYG9wdGlvbnNgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogICAtIGBzZW5zaXRpdmVgICAgIGVuYWJsZSBjYXNlLXNlbnNpdGl2ZSByb3V0ZXNcbiAqICAgLSBgc3RyaWN0YCAgICAgICBlbmFibGUgc3RyaWN0IG1hdGNoaW5nIGZvciB0cmFpbGluZyBzbGFzaGVzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7QXJyYXl9IGNhbGxiYWNrc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBSb3V0ZShtZXRob2QsIHBhdGgsIGNhbGxiYWNrcywgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5wYXRoID0gcGF0aDtcbiAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICB0aGlzLnJlZ2V4cCA9IHV0aWxzLnBhdGhSZWdleHAocGF0aFxuICAgICwgdGhpcy5rZXlzID0gW11cbiAgICAsIG9wdGlvbnMuc2Vuc2l0aXZlXG4gICAgLCBvcHRpb25zLnN0cmljdCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyByb3V0ZSBtYXRjaGVzIGBwYXRoYCwgaWYgc29cbiAqIHBvcHVsYXRlIGAucGFyYW1zYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJvdXRlLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uKHBhdGgpe1xuICB2YXIga2V5cyA9IHRoaXMua2V5c1xuICAgICwgcGFyYW1zID0gdGhpcy5wYXJhbXMgPSBbXVxuICAgICwgbSA9IHRoaXMucmVnZXhwLmV4ZWMocGF0aCk7XG5cbiAgaWYgKCFtKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IG0ubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpIC0gMV07XG5cbiAgICB2YXIgdmFsID0gJ3N0cmluZycgPT0gdHlwZW9mIG1baV1cbiAgICAgID8gZGVjb2RlVVJJQ29tcG9uZW50KG1baV0pXG4gICAgICA6IG1baV07XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBwYXJhbXNba2V5Lm5hbWVdID0gdmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJhbXMucHVzaCh2YWwpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBxdW90OiAweDAwMjJcbiwgYW1wOiAweDAwMjZcbiwgYXBvczogMHgwMDI3XG4sIGxwYXI6IDB4MDAyOFxuLCBycGFyOiAweDAwMjlcbiwgbHQ6IDB4MDAzQ1xuLCBndDogMHgwMDNFXG4sIG5ic3A6IDB4MDBBMFxuLCBpZXhjbDogMHgwMEExXG4sIGNlbnQ6IDB4MDBBMlxuLCBwb3VuZDogMHgwMEEzXG4sIGN1cnJlbjogMHgwMEE0XG4sIHllbjogMHgwMEE1XG4sIGJydmJhcjogMHgwMEE2XG4sIHNlY3Q6IDB4MDBBN1xuLCB1bWw6IDB4MDBBOFxuLCBjb3B5OiAweDAwQTlcbiwgb3JkZjogMHgwMEFBXG4sIGxhcXVvOiAweDAwQUJcbiwgbm90OiAweDAwQUNcbiwgc2h5OiAweDAwQURcbiwgcmVnOiAweDAwQUVcbiwgbWFjcjogMHgwMEFGXG4sIGRlZzogMHgwMEIwXG4sIHBsdXNtbjogMHgwMEIxXG4sIHN1cDI6IDB4MDBCMlxuLCBzdXAzOiAweDAwQjNcbiwgYWN1dGU6IDB4MDBCNFxuLCBtaWNybzogMHgwMEI1XG4sIHBhcmE6IDB4MDBCNlxuLCBtaWRkb3Q6IDB4MDBCN1xuLCBjZWRpbDogMHgwMEI4XG4sIHN1cDE6IDB4MDBCOVxuLCBvcmRtOiAweDAwQkFcbiwgcmFxdW86IDB4MDBCQlxuLCBmcmFjMTQ6IDB4MDBCQ1xuLCBmcmFjMTI6IDB4MDBCRFxuLCBmcmFjMzQ6IDB4MDBCRVxuLCBpcXVlc3Q6IDB4MDBCRlxuLCBBZ3JhdmU6IDB4MDBDMFxuLCBBYWN1dGU6IDB4MDBDMVxuLCBBY2lyYzogMHgwMEMyXG4sIEF0aWxkZTogMHgwMEMzXG4sIEF1bWw6IDB4MDBDNFxuLCBBcmluZzogMHgwMEM1XG4sIEFFbGlnOiAweDAwQzZcbiwgQ2NlZGlsOiAweDAwQzdcbiwgRWdyYXZlOiAweDAwQzhcbiwgRWFjdXRlOiAweDAwQzlcbiwgRWNpcmM6IDB4MDBDQVxuLCBFdW1sOiAweDAwQ0JcbiwgSWdyYXZlOiAweDAwQ0NcbiwgSWFjdXRlOiAweDAwQ0RcbiwgSWNpcmM6IDB4MDBDRVxuLCBJdW1sOiAweDAwQ0ZcbiwgRVRIOiAweDAwRDBcbiwgTnRpbGRlOiAweDAwRDFcbiwgT2dyYXZlOiAweDAwRDJcbiwgT2FjdXRlOiAweDAwRDNcbiwgT2NpcmM6IDB4MDBENFxuLCBPdGlsZGU6IDB4MDBENVxuLCBPdW1sOiAweDAwRDZcbiwgdGltZXM6IDB4MDBEN1xuLCBPc2xhc2g6IDB4MDBEOFxuLCBVZ3JhdmU6IDB4MDBEOVxuLCBVYWN1dGU6IDB4MDBEQVxuLCBVY2lyYzogMHgwMERCXG4sIFV1bWw6IDB4MDBEQ1xuLCBZYWN1dGU6IDB4MDBERFxuLCBUSE9STjogMHgwMERFXG4sIHN6bGlnOiAweDAwREZcbiwgYWdyYXZlOiAweDAwRTBcbiwgYWFjdXRlOiAweDAwRTFcbiwgYWNpcmM6IDB4MDBFMlxuLCBhdGlsZGU6IDB4MDBFM1xuLCBhdW1sOiAweDAwRTRcbiwgYXJpbmc6IDB4MDBFNVxuLCBhZWxpZzogMHgwMEU2XG4sIGNjZWRpbDogMHgwMEU3XG4sIGVncmF2ZTogMHgwMEU4XG4sIGVhY3V0ZTogMHgwMEU5XG4sIGVjaXJjOiAweDAwRUFcbiwgZXVtbDogMHgwMEVCXG4sIGlncmF2ZTogMHgwMEVDXG4sIGlhY3V0ZTogMHgwMEVEXG4sIGljaXJjOiAweDAwRUVcbiwgaXVtbDogMHgwMEVGXG4sIGV0aDogMHgwMEYwXG4sIG50aWxkZTogMHgwMEYxXG4sIG9ncmF2ZTogMHgwMEYyXG4sIG9hY3V0ZTogMHgwMEYzXG4sIG9jaXJjOiAweDAwRjRcbiwgb3RpbGRlOiAweDAwRjVcbiwgb3VtbDogMHgwMEY2XG4sIGRpdmlkZTogMHgwMEY3XG4sIG9zbGFzaDogMHgwMEY4XG4sIHVncmF2ZTogMHgwMEY5XG4sIHVhY3V0ZTogMHgwMEZBXG4sIHVjaXJjOiAweDAwRkJcbiwgdXVtbDogMHgwMEZDXG4sIHlhY3V0ZTogMHgwMEZEXG4sIHRob3JuOiAweDAwRkVcbiwgeXVtbDogMHgwMEZGXG4sIE9FbGlnOiAweDAxNTJcbiwgb2VsaWc6IDB4MDE1M1xuLCBTY2Fyb246IDB4MDE2MFxuLCBzY2Fyb246IDB4MDE2MVxuLCBZdW1sOiAweDAxNzhcbiwgZm5vZjogMHgwMTkyXG4sIGNpcmM6IDB4MDJDNlxuLCB0aWxkZTogMHgwMkRDXG4sIEFscGhhOiAweDAzOTFcbiwgQmV0YTogMHgwMzkyXG4sIEdhbW1hOiAweDAzOTNcbiwgRGVsdGE6IDB4MDM5NFxuLCBFcHNpbG9uOiAweDAzOTVcbiwgWmV0YTogMHgwMzk2XG4sIEV0YTogMHgwMzk3XG4sIFRoZXRhOiAweDAzOThcbiwgSW90YTogMHgwMzk5XG4sIEthcHBhOiAweDAzOUFcbiwgTGFtYmRhOiAweDAzOUJcbiwgTXU6IDB4MDM5Q1xuLCBOdTogMHgwMzlEXG4sIFhpOiAweDAzOUVcbiwgT21pY3JvbjogMHgwMzlGXG4sIFBpOiAweDAzQTBcbiwgUmhvOiAweDAzQTFcbiwgU2lnbWE6IDB4MDNBM1xuLCBUYXU6IDB4MDNBNFxuLCBVcHNpbG9uOiAweDAzQTVcbiwgUGhpOiAweDAzQTZcbiwgQ2hpOiAweDAzQTdcbiwgUHNpOiAweDAzQThcbiwgT21lZ2E6IDB4MDNBOVxuLCBhbHBoYTogMHgwM0IxXG4sIGJldGE6IDB4MDNCMlxuLCBnYW1tYTogMHgwM0IzXG4sIGRlbHRhOiAweDAzQjRcbiwgZXBzaWxvbjogMHgwM0I1XG4sIHpldGE6IDB4MDNCNlxuLCBldGE6IDB4MDNCN1xuLCB0aGV0YTogMHgwM0I4XG4sIGlvdGE6IDB4MDNCOVxuLCBrYXBwYTogMHgwM0JBXG4sIGxhbWJkYTogMHgwM0JCXG4sIG11OiAweDAzQkNcbiwgbnU6IDB4MDNCRFxuLCB4aTogMHgwM0JFXG4sIG9taWNyb246IDB4MDNCRlxuLCBwaTogMHgwM0MwXG4sIHJobzogMHgwM0MxXG4sIHNpZ21hZjogMHgwM0MyXG4sIHNpZ21hOiAweDAzQzNcbiwgdGF1OiAweDAzQzRcbiwgdXBzaWxvbjogMHgwM0M1XG4sIHBoaTogMHgwM0M2XG4sIGNoaTogMHgwM0M3XG4sIHBzaTogMHgwM0M4XG4sIG9tZWdhOiAweDAzQzlcbiwgdGhldGFzeW06IDB4MDNEMVxuLCB1cHNpaDogMHgwM0QyXG4sIHBpdjogMHgwM0Q2XG4sIGVuc3A6IDB4MjAwMlxuLCBlbXNwOiAweDIwMDNcbiwgdGhpbnNwOiAweDIwMDlcbiwgenduajogMHgyMDBDXG4sIHp3ajogMHgyMDBEXG4sIGxybTogMHgyMDBFXG4sIHJsbTogMHgyMDBGXG4sIG5kYXNoOiAweDIwMTNcbiwgbWRhc2g6IDB4MjAxNFxuLCBsc3F1bzogMHgyMDE4XG4sIHJzcXVvOiAweDIwMTlcbiwgc2JxdW86IDB4MjAxQVxuLCBsZHF1bzogMHgyMDFDXG4sIHJkcXVvOiAweDIwMURcbiwgYmRxdW86IDB4MjAxRVxuLCBkYWdnZXI6IDB4MjAyMFxuLCBEYWdnZXI6IDB4MjAyMVxuLCBidWxsOiAweDIwMjJcbiwgaGVsbGlwOiAweDIwMjZcbiwgcGVybWlsOiAweDIwMzBcbiwgcHJpbWU6IDB4MjAzMlxuLCBQcmltZTogMHgyMDMzXG4sIGxzYXF1bzogMHgyMDM5XG4sIHJzYXF1bzogMHgyMDNBXG4sIG9saW5lOiAweDIwM0VcbiwgZnJhc2w6IDB4MjA0NFxuLCBldXJvOiAweDIwQUNcbiwgaW1hZ2U6IDB4MjExMVxuLCB3ZWllcnA6IDB4MjExOFxuLCByZWFsOiAweDIxMUNcbiwgdHJhZGU6IDB4MjEyMlxuLCBhbGVmc3ltOiAweDIxMzVcbiwgbGFycjogMHgyMTkwXG4sIHVhcnI6IDB4MjE5MVxuLCByYXJyOiAweDIxOTJcbiwgZGFycjogMHgyMTkzXG4sIGhhcnI6IDB4MjE5NFxuLCBjcmFycjogMHgyMUI1XG4sIGxBcnI6IDB4MjFEMFxuLCB1QXJyOiAweDIxRDFcbiwgckFycjogMHgyMUQyXG4sIGRBcnI6IDB4MjFEM1xuLCBoQXJyOiAweDIxRDRcbiwgZm9yYWxsOiAweDIyMDBcbiwgcGFydDogMHgyMjAyXG4sIGV4aXN0OiAweDIyMDNcbiwgZW1wdHk6IDB4MjIwNVxuLCBuYWJsYTogMHgyMjA3XG4sIGlzaW46IDB4MjIwOFxuLCBub3RpbjogMHgyMjA5XG4sIG5pOiAweDIyMEJcbiwgcHJvZDogMHgyMjBGXG4sIHN1bTogMHgyMjExXG4sIG1pbnVzOiAweDIyMTJcbiwgbG93YXN0OiAweDIyMTdcbiwgcmFkaWM6IDB4MjIxQVxuLCBwcm9wOiAweDIyMURcbiwgaW5maW46IDB4MjIxRVxuLCBhbmc6IDB4MjIyMFxuLCBhbmQ6IDB4MjIyN1xuLCBvcjogMHgyMjI4XG4sIGNhcDogMHgyMjI5XG4sIGN1cDogMHgyMjJBXG4sIGludDogMHgyMjJCXG4sIHRoZXJlNDogMHgyMjM0XG4sIHNpbTogMHgyMjNDXG4sIGNvbmc6IDB4MjI0NVxuLCBhc3ltcDogMHgyMjQ4XG4sIG5lOiAweDIyNjBcbiwgZXF1aXY6IDB4MjI2MVxuLCBsZTogMHgyMjY0XG4sIGdlOiAweDIyNjVcbiwgc3ViOiAweDIyODJcbiwgc3VwOiAweDIyODNcbiwgbnN1YjogMHgyMjg0XG4sIHN1YmU6IDB4MjI4NlxuLCBzdXBlOiAweDIyODdcbiwgb3BsdXM6IDB4MjI5NVxuLCBvdGltZXM6IDB4MjI5N1xuLCBwZXJwOiAweDIyQTVcbiwgc2RvdDogMHgyMkM1XG4sIGxjZWlsOiAweDIzMDhcbiwgcmNlaWw6IDB4MjMwOVxuLCBsZmxvb3I6IDB4MjMwQVxuLCByZmxvb3I6IDB4MjMwQlxuLCBsYW5nOiAweDIzMjlcbiwgcmFuZzogMHgyMzJBXG4sIGxvejogMHgyNUNBXG4sIHNwYWRlczogMHgyNjYwXG4sIGNsdWJzOiAweDI2NjNcbiwgaGVhcnRzOiAweDI2NjVcbiwgZGlhbXM6IDB4MjY2NlxufVxuIiwidmFyIHN0YXJ0VGFnID0gL148KFteXFxzPVxcLyE+XSspKCg/OlxccytbXlxccz1cXC8+XSsoPzpcXHMqPVxccyooPzooPzpcIlteXCJdKlwiKXwoPzonW14nXSonKXxbXj5cXHNdKyk/KT8pKilcXHMqKFxcLz8pXFxzKj4vXG4gICwgZW5kVGFnID0gL148XFwvKFteXFxzPVxcLyE+XSspW14+XSo+L1xuICAsIGNvbW1lbnQgPSAvXjwhLS0oW1xcc1xcU10qPyktLT4vXG4gICwgY29tbWVudEluc2lkZSA9IC88IS0tW1xcc1xcU10qPy0tPi9cbiAgLCBvdGhlciA9IC9ePChbXFxzXFxTXSo/KT4vXG4gICwgYXR0ciA9IC8oW15cXHM9XSspKD86XFxzKig9KVxccyooPzooPzpcIigoPzpcXFxcLnxbXlwiXSkqKVwiKXwoPzonKCg/OlxcXFwufFteJ10pKiknKXwoW14+XFxzXSspKT8pPy9nXG4gICwgcmF3VGFnc0RlZmF1bHQgPSAvXihzdHlsZXxzY3JpcHQpJC9pXG5cbmZ1bmN0aW9uIGVtcHR5KCkge31cblxuZnVuY3Rpb24gbWF0Y2hFbmREZWZhdWx0KHRhZ05hbWUpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoJzwvJyArIHRhZ05hbWUsICdpJylcbn1cblxuZnVuY3Rpb24gb25TdGFydFRhZyhodG1sLCBtYXRjaCwgaGFuZGxlcikge1xuICB2YXIgYXR0cnMgPSB7fVxuICAgICwgdGFnID0gbWF0Y2hbMF1cbiAgICAsIHRhZ05hbWUgPSBtYXRjaFsxXVxuICAgICwgcmVtYWluZGVyID0gbWF0Y2hbMl1cbiAgaHRtbCA9IGh0bWwuc2xpY2UodGFnLmxlbmd0aClcblxuICByZW1haW5kZXIucmVwbGFjZShhdHRyLCBmdW5jdGlvbihtYXRjaCwgbmFtZSwgZXF1YWxzLCBhdHRyMCwgYXR0cjEsIGF0dHIyKSB7XG4gICAgYXR0cnNbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IGF0dHIwIHx8IGF0dHIxIHx8IGF0dHIyIHx8IChlcXVhbHMgPyAnJyA6IG51bGwpXG4gIH0pXG4gIGhhbmRsZXIodGFnLCB0YWdOYW1lLnRvTG93ZXJDYXNlKCksIGF0dHJzLCBodG1sKVxuXG4gIHJldHVybiBodG1sXG59XG5cbmZ1bmN0aW9uIG9uVGFnKGh0bWwsIG1hdGNoLCBoYW5kbGVyKSB7XG4gIHZhciB0YWcgPSBtYXRjaFswXVxuICAgICwgZGF0YSA9IG1hdGNoWzFdXG4gIGh0bWwgPSBodG1sLnNsaWNlKHRhZy5sZW5ndGgpXG5cbiAgaGFuZGxlcih0YWcsIGRhdGEsIGh0bWwpXG5cbiAgcmV0dXJuIGh0bWxcbn1cblxuZnVuY3Rpb24gb25UZXh0KGh0bWwsIGluZGV4LCBpc1Jhd1RleHQsIGhhbmRsZXIpIHtcbiAgdmFyIHRleHRcbiAgaWYgKH5pbmRleCkge1xuICAgIHRleHQgPSBodG1sLnNsaWNlKDAsIGluZGV4KVxuICAgIGh0bWwgPSBodG1sLnNsaWNlKGluZGV4KVxuICB9IGVsc2Uge1xuICAgIHRleHQgPSBodG1sXG4gICAgaHRtbCA9ICcnXG4gIH1cblxuICBpZiAodGV4dCkgaGFuZGxlcih0ZXh0LCBpc1Jhd1RleHQsIGh0bWwpXG5cbiAgcmV0dXJuIGh0bWxcbn1cblxuZnVuY3Rpb24gcmF3RW5kKGh0bWwsIGVuZGluZywgb2Zmc2V0KSB7XG4gIG9mZnNldCB8fCAob2Zmc2V0ID0gMClcbiAgdmFyIGluZGV4ID0gaHRtbC5zZWFyY2goZW5kaW5nKVxuICAgICwgY29tbWVudE1hdGNoID0gaHRtbC5tYXRjaChjb21tZW50SW5zaWRlKVxuICAgICwgY29tbWVudEVuZFxuICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgZW5kaW5nIGNvbmRpdGlvbiBpc24ndCBpbnNpZGUgb2YgYW4gSFRNTCBjb21tZW50XG4gIGlmIChjb21tZW50TWF0Y2ggJiYgY29tbWVudE1hdGNoLmluZGV4IDwgaW5kZXgpIHtcbiAgICBjb21tZW50RW5kID0gY29tbWVudE1hdGNoLmluZGV4ICsgY29tbWVudE1hdGNoWzBdLmxlbmd0aFxuICAgIG9mZnNldCArPSBjb21tZW50RW5kXG4gICAgaHRtbCA9IGh0bWwuc2xpY2UoY29tbWVudEVuZClcbiAgICByZXR1cm4gcmF3RW5kKGh0bWwsIGVuZGluZywgb2Zmc2V0KVxuICB9XG4gIHJldHVybiBpbmRleCArIG9mZnNldFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGh0bWwsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT0gbnVsbCkgb3B0aW9ucyA9IHt9XG5cbiAgaWYgKCFodG1sKSByZXR1cm5cblxuICB2YXIgc3RhcnRIYW5kbGVyID0gb3B0aW9ucy5zdGFydCB8fCBlbXB0eVxuICAgICwgZW5kSGFuZGxlciA9IG9wdGlvbnMuZW5kIHx8IGVtcHR5XG4gICAgLCB0ZXh0SGFuZGxlciA9IG9wdGlvbnMudGV4dCB8fCBlbXB0eVxuICAgICwgY29tbWVudEhhbmRsZXIgPSBvcHRpb25zLmNvbW1lbnQgfHwgZW1wdHlcbiAgICAsIG90aGVySGFuZGxlciA9IG9wdGlvbnMub3RoZXIgfHwgZW1wdHlcbiAgICAsIG1hdGNoRW5kID0gb3B0aW9ucy5tYXRjaEVuZCB8fCBtYXRjaEVuZERlZmF1bHRcbiAgICAsIGVycm9ySGFuZGxlciA9IG9wdGlvbnMuZXJyb3JcbiAgICAsIHJhd1RhZ3MgPSBvcHRpb25zLnJhd1RhZ3MgfHwgcmF3VGFnc0RlZmF1bHRcbiAgICAsIGluZGV4LCBsYXN0LCBtYXRjaCwgdGFnTmFtZSwgZXJyXG5cbiAgd2hpbGUgKGh0bWwpIHtcbiAgICBpZiAoaHRtbCA9PT0gbGFzdCkge1xuICAgICAgZXJyID0gbmV3IEVycm9yKCdIVE1MIHBhcnNlIGVycm9yOiAnICsgaHRtbClcbiAgICAgIGlmIChlcnJvckhhbmRsZXIpIHtcbiAgICAgICAgZXJyb3JIYW5kbGVyKGVycilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuICAgIH1cbiAgICBsYXN0ID0gaHRtbFxuXG4gICAgaWYgKGh0bWxbMF0gPT09ICc8Jykge1xuICAgICAgaWYgKG1hdGNoID0gaHRtbC5tYXRjaChzdGFydFRhZykpIHtcbiAgICAgICAgaHRtbCA9IG9uU3RhcnRUYWcoaHRtbCwgbWF0Y2gsIHN0YXJ0SGFuZGxlcilcblxuICAgICAgICB0YWdOYW1lID0gbWF0Y2hbMV1cbiAgICAgICAgaWYgKHJhd1RhZ3MudGVzdCh0YWdOYW1lKSkge1xuICAgICAgICAgIGluZGV4ID0gcmF3RW5kKGh0bWwsIG1hdGNoRW5kKHRhZ05hbWUpKVxuICAgICAgICAgIGh0bWwgPSBvblRleHQoaHRtbCwgaW5kZXgsIHRydWUsIHRleHRIYW5kbGVyKVxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCA9IGh0bWwubWF0Y2goZW5kVGFnKSkge1xuICAgICAgICBtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgIC8vIHRhZ05hbWVcbiAgICAgICAgaHRtbCA9IG9uVGFnKGh0bWwsIG1hdGNoLCBlbmRIYW5kbGVyKVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPSBodG1sLm1hdGNoKGNvbW1lbnQpKSB7XG4gICAgICAgIGh0bWwgPSBvblRhZyhodG1sLCBtYXRjaCwgY29tbWVudEhhbmRsZXIpXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCA9IGh0bWwubWF0Y2gob3RoZXIpKSB7XG4gICAgICAgIGh0bWwgPSBvblRhZyhodG1sLCBtYXRjaCwgb3RoZXJIYW5kbGVyKVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGluZGV4ID0gaHRtbC5pbmRleE9mKCc8JylcbiAgICBodG1sID0gb25UZXh0KGh0bWwsIGluZGV4LCBmYWxzZSwgdGV4dEhhbmRsZXIpXG4gIH1cbn1cbiIsInZhciBEb2MgPSByZXF1aXJlKCcuL0RvYycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTG9jYWxEb2M7XG5cbmZ1bmN0aW9uIExvY2FsRG9jKG1vZGVsLCBjb2xsZWN0aW9uTmFtZSwgaWQsIHNuYXBzaG90KSB7XG4gIERvYy5jYWxsKHRoaXMsIG1vZGVsLCBjb2xsZWN0aW9uTmFtZSwgaWQpO1xuICB0aGlzLnNuYXBzaG90ID0gc25hcHNob3Q7XG4gIHRoaXMuX3VwZGF0ZUNvbGxlY3Rpb25EYXRhKCk7XG59XG5cbkxvY2FsRG9jLnByb3RvdHlwZSA9IG5ldyBEb2M7XG5cbkxvY2FsRG9jLnByb3RvdHlwZS5fdXBkYXRlQ29sbGVjdGlvbkRhdGEgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jb2xsZWN0aW9uRGF0YVt0aGlzLmlkXSA9IHRoaXMuc25hcHNob3Q7XG59O1xuXG5Mb2NhbERvYy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oc2VnbWVudHMsIHZhbHVlLCBjYikge1xuICBmdW5jdGlvbiBzZXQobm9kZSwga2V5KSB7XG4gICAgdmFyIHByZXZpb3VzID0gbm9kZVtrZXldO1xuICAgIG5vZGVba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiBwcmV2aW91cztcbiAgfVxuICByZXR1cm4gdGhpcy5fYXBwbHkoc2VnbWVudHMsIHNldCwgY2IpO1xufTtcblxuTG9jYWxEb2MucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBjYikge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiB0aGUgdmFsdWUgaXMgYWxyZWFkeSB1bmRlZmluZWQsIHNpbmNlXG4gIC8vIGFwcGx5IGNyZWF0ZXMgb2JqZWN0cyBhcyBpdCB0cmF2ZXJzZXMsIGFuZCB0aGUgZGVsIG1ldGhvZFxuICAvLyBzaG91bGQgbm90IGNyZWF0ZSBhbnl0aGluZ1xuICB2YXIgcHJldmlvdXMgPSB0aGlzLmdldChzZWdtZW50cyk7XG4gIGlmIChwcmV2aW91cyA9PT0gdm9pZCAwKSB7XG4gICAgY2IoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgZnVuY3Rpb24gZGVsKG5vZGUsIGtleSkge1xuICAgIGRlbGV0ZSBub2RlW2tleV07XG4gICAgcmV0dXJuIHByZXZpb3VzO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcHBseShzZWdtZW50cywgZGVsLCBjYik7XG59O1xuXG5Mb2NhbERvYy5wcm90b3R5cGUuaW5jcmVtZW50ID0gZnVuY3Rpb24oc2VnbWVudHMsIGJ5TnVtYmVyLCBjYikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgPT0gbnVsbCkgcmV0dXJuO1xuICAgIHJldHVybiBuZXcgVHlwZUVycm9yKHNlbGYuX2Vycm9yTWVzc2FnZShcbiAgICAgICdpbmNyZW1lbnQgb24gbm9uLW51bWJlcicsIHNlZ21lbnRzLCB2YWx1ZVxuICAgICkpO1xuICB9XG4gIGZ1bmN0aW9uIGluY3JlbWVudChub2RlLCBrZXkpIHtcbiAgICB2YXIgdmFsdWUgPSAobm9kZVtrZXldIHx8IDApICsgYnlOdW1iZXI7XG4gICAgbm9kZVtrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzLl92YWxpZGF0ZWRBcHBseShzZWdtZW50cywgdmFsaWRhdGUsIGluY3JlbWVudCwgY2IpO1xufTtcblxuTG9jYWxEb2MucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihzZWdtZW50cywgdmFsdWUsIGNiKSB7XG4gIGZ1bmN0aW9uIHB1c2goYXJyKSB7XG4gICAgcmV0dXJuIGFyci5wdXNoKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyYXlBcHBseShzZWdtZW50cywgcHVzaCwgY2IpO1xufTtcblxuTG9jYWxEb2MucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbihzZWdtZW50cywgdmFsdWUsIGNiKSB7XG4gIGZ1bmN0aW9uIHVuc2hpZnQoYXJyKSB7XG4gICAgcmV0dXJuIGFyci51bnNoaWZ0KHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyYXlBcHBseShzZWdtZW50cywgdW5zaGlmdCwgY2IpO1xufTtcblxuTG9jYWxEb2MucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBpbmRleCwgdmFsdWVzLCBjYikge1xuICBmdW5jdGlvbiBpbnNlcnQoYXJyKSB7XG4gICAgYXJyLnNwbGljZS5hcHBseShhcnIsIFtpbmRleCwgMF0uY29uY2F0KHZhbHVlcykpO1xuICAgIHJldHVybiBhcnIubGVuZ3RoO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJheUFwcGx5KHNlZ21lbnRzLCBpbnNlcnQsIGNiKTtcbn07XG5cbkxvY2FsRG9jLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbihzZWdtZW50cywgY2IpIHtcbiAgZnVuY3Rpb24gcG9wKGFycikge1xuICAgIHJldHVybiBhcnIucG9wKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FycmF5QXBwbHkoc2VnbWVudHMsIHBvcCwgY2IpO1xufTtcblxuTG9jYWxEb2MucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24oc2VnbWVudHMsIGNiKSB7XG4gIGZ1bmN0aW9uIHNoaWZ0KGFycikge1xuICAgIHJldHVybiBhcnIuc2hpZnQoKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyYXlBcHBseShzZWdtZW50cywgc2hpZnQsIGNiKTtcbn07XG5cbkxvY2FsRG9jLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihzZWdtZW50cywgaW5kZXgsIGhvd01hbnksIGNiKSB7XG4gIGZ1bmN0aW9uIHJlbW92ZShhcnIpIHtcbiAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgaG93TWFueSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FycmF5QXBwbHkoc2VnbWVudHMsIHJlbW92ZSwgY2IpO1xufTtcblxuTG9jYWxEb2MucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbihzZWdtZW50cywgZnJvbSwgdG8sIGhvd01hbnksIGNiKSB7XG4gIGZ1bmN0aW9uIG1vdmUoYXJyKSB7XG4gICAgLy8gUmVtb3ZlIGZyb20gb2xkIGxvY2F0aW9uXG4gICAgdmFyIHZhbHVlcyA9IGFyci5zcGxpY2UoZnJvbSwgaG93TWFueSk7XG4gICAgLy8gSW5zZXJ0IGluIG5ldyBsb2NhdGlvblxuICAgIGFyci5zcGxpY2UuYXBwbHkoYXJyLCBbdG8sIDBdLmNvbmNhdCh2YWx1ZXMpKTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJheUFwcGx5KHNlZ21lbnRzLCBtb3ZlLCBjYik7XG59O1xuXG5Mb2NhbERvYy5wcm90b3R5cGUuc3RyaW5nSW5zZXJ0ID0gZnVuY3Rpb24oc2VnbWVudHMsIGluZGV4LCB2YWx1ZSwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBmdW5jdGlvbiB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHZhbHVlID09IG51bGwpIHJldHVybjtcbiAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihzZWxmLl9lcnJvck1lc3NhZ2UoXG4gICAgICAnc3RyaW5nSW5zZXJ0IG9uIG5vbi1zdHJpbmcnLCBzZWdtZW50cywgdmFsdWVcbiAgICApKTtcbiAgfVxuICBmdW5jdGlvbiBzdHJpbmdJbnNlcnQobm9kZSwga2V5KSB7XG4gICAgdmFyIHByZXZpb3VzID0gbm9kZVtrZXldO1xuICAgIGlmIChwcmV2aW91cyA9PSBudWxsKSB7XG4gICAgICBub2RlW2tleV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiBwcmV2aW91cztcbiAgICB9XG4gICAgbm9kZVtrZXldID0gcHJldmlvdXMuc2xpY2UoMCwgaW5kZXgpICsgdmFsdWUgKyBwcmV2aW91cy5zbGljZShpbmRleCk7XG4gICAgcmV0dXJuIHByZXZpb3VzO1xuICB9XG4gIHJldHVybiB0aGlzLl92YWxpZGF0ZWRBcHBseShzZWdtZW50cywgdmFsaWRhdGUsIHN0cmluZ0luc2VydCwgY2IpO1xufTtcblxuTG9jYWxEb2MucHJvdG90eXBlLnN0cmluZ1JlbW92ZSA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBpbmRleCwgaG93TWFueSwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBmdW5jdGlvbiB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHZhbHVlID09IG51bGwpIHJldHVybjtcbiAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihzZWxmLl9lcnJvck1lc3NhZ2UoXG4gICAgICAnc3RyaW5nUmVtb3ZlIG9uIG5vbi1zdHJpbmcnLCBzZWdtZW50cywgdmFsdWVcbiAgICApKTtcbiAgfVxuICBmdW5jdGlvbiBzdHJpbmdSZW1vdmUobm9kZSwga2V5KSB7XG4gICAgdmFyIHByZXZpb3VzID0gbm9kZVtrZXldO1xuICAgIGlmIChwcmV2aW91cyA9PSBudWxsKSByZXR1cm4gcHJldmlvdXM7XG4gICAgaWYgKGluZGV4IDwgMCkgaW5kZXggKz0gcHJldmlvdXMubGVuZ3RoO1xuICAgIG5vZGVba2V5XSA9IHByZXZpb3VzLnNsaWNlKDAsIGluZGV4KSArIHByZXZpb3VzLnNsaWNlKGluZGV4ICsgaG93TWFueSk7XG4gICAgcmV0dXJuIHByZXZpb3VzO1xuICB9XG4gIHJldHVybiB0aGlzLl92YWxpZGF0ZWRBcHBseShzZWdtZW50cywgdmFsaWRhdGUsIHN0cmluZ1JlbW92ZSwgY2IpO1xufTtcblxuTG9jYWxEb2MucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHNlZ21lbnRzKSB7XG4gIHJldHVybiB1dGlsLmxvb2t1cChzZWdtZW50cywgdGhpcy5zbmFwc2hvdCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9IHNlZ21lbnRzIGlzIHRoZSBhcnJheSByZXByZXNlbnRpbmcgYSBwYXRoXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbihub2RlLCBrZXkpIGFwcGxpZXMgYSBtdXRhdGlvbiBvbiBub2RlW2tleV1cbiAqIEByZXR1cm4ge09iamVjdH0gcmV0dXJucyB0aGUgcmV0dXJuIHZhbHVlIG9mIGZuKG5vZGUsIGtleSlcbiAqL1xuTG9jYWxEb2MucHJvdG90eXBlLl9jcmVhdGVJbXBsaWVkID0gZnVuY3Rpb24oc2VnbWVudHMsIGZuKSB7XG4gIHZhciBub2RlID0gdGhpcztcbiAgdmFyIGtleSA9ICdzbmFwc2hvdCc7XG4gIHZhciBpID0gMDtcbiAgdmFyIG5leHRLZXkgPSBzZWdtZW50c1tpKytdO1xuICB3aGlsZSAobmV4dEtleSAhPSBudWxsKSB7XG4gICAgLy8gR2V0IG9yIGNyZWF0ZSBpbXBsaWVkIG9iamVjdCBvciBhcnJheVxuICAgIG5vZGUgPSBub2RlW2tleV0gfHwgKG5vZGVba2V5XSA9IC9eXFxkKyQvLnRlc3QobmV4dEtleSkgPyBbXSA6IHt9KTtcbiAgICBrZXkgPSBuZXh0S2V5O1xuICAgIG5leHRLZXkgPSBzZWdtZW50c1tpKytdO1xuICB9XG4gIHJldHVybiBmbihub2RlLCBrZXkpO1xufTtcblxuTG9jYWxEb2MucHJvdG90eXBlLl9hcHBseSA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBmbiwgY2IpIHtcbiAgdmFyIG91dCA9IHRoaXMuX2NyZWF0ZUltcGxpZWQoc2VnbWVudHMsIGZuKTtcbiAgdGhpcy5fdXBkYXRlQ29sbGVjdGlvbkRhdGEoKTtcbiAgY2IoKTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbkxvY2FsRG9jLnByb3RvdHlwZS5fdmFsaWRhdGVkQXBwbHkgPSBmdW5jdGlvbihzZWdtZW50cywgdmFsaWRhdGUsIGZuLCBjYikge1xuICB2YXIgb3V0ID0gdGhpcy5fY3JlYXRlSW1wbGllZChzZWdtZW50cywgZnVuY3Rpb24obm9kZSwga2V5KSB7XG4gICAgdmFyIGVyciA9IHZhbGlkYXRlKG5vZGVba2V5XSk7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgcmV0dXJuIGZuKG5vZGUsIGtleSk7XG4gIH0pO1xuICB0aGlzLl91cGRhdGVDb2xsZWN0aW9uRGF0YSgpO1xuICBjYigpO1xuICByZXR1cm4gb3V0O1xufTtcblxuTG9jYWxEb2MucHJvdG90eXBlLl9hcnJheUFwcGx5ID0gZnVuY3Rpb24oc2VnbWVudHMsIGZuLCBjYikge1xuICAvLyBMb29rdXAgYSBwb2ludGVyIHRvIHRoZSBwcm9wZXJ0eSBvciBuZXN0ZWQgcHJvcGVydHkgJlxuICAvLyByZXR1cm4gdGhlIGN1cnJlbnQgdmFsdWUgb3IgY3JlYXRlIGEgbmV3IGFycmF5XG4gIHZhciBhcnIgPSB0aGlzLl9jcmVhdGVJbXBsaWVkKHNlZ21lbnRzLCBub2RlQ3JlYXRlQXJyYXkpO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSB0aGlzLl9lcnJvck1lc3NhZ2UoZm4ubmFtZSArICcgb24gbm9uLWFycmF5Jywgc2VnbWVudHMsIGFycik7XG4gICAgdmFyIGVyciA9IG5ldyBUeXBlRXJyb3IobWVzc2FnZSk7XG4gICAgcmV0dXJuIGNiKGVycik7XG4gIH1cbiAgdmFyIG91dCA9IGZuKGFycik7XG4gIHRoaXMuX3VwZGF0ZUNvbGxlY3Rpb25EYXRhKCk7XG4gIGNiKCk7XG4gIHJldHVybiBvdXQ7XG59O1xuXG5mdW5jdGlvbiBub2RlQ3JlYXRlQXJyYXkobm9kZSwga2V5KSB7XG4gIHJldHVybiBub2RlW2tleV0gfHwgKG5vZGVba2V5XSA9IFtdKTtcbn1cbiIsIi8qKlxuICogUmVtb3RlRG9jIGFkYXB0cyB0aGUgU2hhcmVKUyBvcGVyYXRpb24gcHJvdG9jb2wgdG8gUmFjZXIncyBtdXRhdG9yXG4gKiBpbnRlcmZhY2UuXG4gKlxuICogMS4gSXQgbWFwcyBSYWNlcidzIG11dGF0b3IgbWV0aG9kcyB0byBvdXRnb2luZyBTaGFyZUpTIG9wZXJhdGlvbnMuXG4gKiAyLiBJdCBtYXBzIGluY29taW5nIFNoYXJlSlMgb3BlcmF0aW9ucyB0byBSYWNlciBldmVudHMuXG4gKi9cblxudmFyIERvYyA9IHJlcXVpcmUoJy4vRG9jJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZW1vdGVEb2M7XG5cbmZ1bmN0aW9uIFJlbW90ZURvYyhtb2RlbCwgY29sbGVjdGlvbk5hbWUsIGlkLCBkYXRhKSB7XG4gIERvYy5jYWxsKHRoaXMsIG1vZGVsLCBjb2xsZWN0aW9uTmFtZSwgaWQpO1xuICB2YXIgc2hhcmVEb2MgPSB0aGlzLnNoYXJlRG9jID0gbW9kZWwuX2dldE9yQ3JlYXRlU2hhcmVEb2MoY29sbGVjdGlvbk5hbWUsIGlkLCBkYXRhKTtcbiAgdGhpcy5jcmVhdGVkTG9jYWxseSA9IGZhbHNlO1xuICB0aGlzLm1vZGVsID0gbW9kZWwgPSBtb2RlbC5wYXNzKHskcmVtb3RlOiB0cnVlfSk7XG4gIHRoaXMuX3Bhc3NTdHJpbmdJbnNlcnQgPSBtb2RlbC5wYXNzKHskb3JpZ2luYWw6ICdzdHJpbmdJbnNlcnQnfSkuX3Bhc3M7XG4gIHRoaXMuX3Bhc3NTdHJpbmdSZW1vdmUgPSBtb2RlbC5wYXNzKHskb3JpZ2luYWw6ICdzdHJpbmdSZW1vdmUnfSkuX3Bhc3M7XG4gIHRoaXMuX3VwZGF0ZUNvbGxlY3Rpb25EYXRhKCk7XG5cbiAgdmFyIGRvYyA9IHRoaXM7XG4gIHNoYXJlRG9jLm9uKCdvcCcsIGZ1bmN0aW9uKG9wLCBpc0xvY2FsKSB7XG4gICAgLy8gRG9uJ3QgZW1pdCBvbiBsb2NhbCBvcGVyYXRpb25zLCBzaW5jZSB0aGV5IGFyZSBlbWl0dGVkIGluIHRoZSBtdXRhdG9yXG4gICAgaWYgKGlzTG9jYWwpIHJldHVybjtcbiAgICBkb2MuX3VwZGF0ZUNvbGxlY3Rpb25EYXRhKCk7XG4gICAgZG9jLl9vbk9wKG9wKTtcbiAgfSk7XG4gIHNoYXJlRG9jLm9uKCdkZWwnLCBmdW5jdGlvbihpc0xvY2FsLCBwcmV2aW91cykge1xuICAgIC8vIENhbGxpbmcgdGhlIHNoYXJlRG9jLmRlbCBtZXRob2QgZG9lcyBub3QgZW1pdCBhbiBvcGVyYXRpb24gZXZlbnQsXG4gICAgLy8gc28gd2UgY3JlYXRlIHRoZSBhcHByb3ByaWF0ZSBldmVudCBoZXJlLlxuICAgIGlmIChpc0xvY2FsKSByZXR1cm47XG4gICAgZG9jLl91cGRhdGVDb2xsZWN0aW9uRGF0YSgpO1xuICAgIG1vZGVsLmVtaXQoJ2NoYW5nZScsIFtjb2xsZWN0aW9uTmFtZSwgaWRdLCBbdm9pZCAwLCBwcmV2aW91cywgbW9kZWwuX3Bhc3NdKTtcbiAgfSk7XG4gIHNoYXJlRG9jLm9uKCdjcmVhdGUnLCBmdW5jdGlvbihpc0xvY2FsKSB7XG4gICAgLy8gTG9jYWwgY3JlYXRlcyBzaG91bGQgbm90IGVtaXQgYW4gZXZlbnQsIHNpbmNlIHRoZXkgb25seSBoYXBwZW5cbiAgICAvLyBpbXBsaWNpdGx5IGFzIGEgcmVzdWx0IG9mIGFub3RoZXIgbXV0YXRpb24sIGFuZCB0aGF0IG9wZXJhdGlvbiB3aWxsXG4gICAgLy8gZW1pdCB0aGUgYXBwcm9wcmlhdGUgZXZlbnQuIFJlbW90ZSBjcmVhdGVzIGNhbiBzZXQgdGhlIHNuYXBzaG90IGRhdGFcbiAgICAvLyB3aXRob3V0IGVtaXR0aW5nIGFuIG9wZXJhdGlvbiBldmVudCwgc28gYW4gZXZlbnQgbmVlZHMgdG8gYmUgZW1pdHRlZFxuICAgIC8vIGZvciB0aGVtLlxuICAgIGlmIChpc0xvY2FsKSB7XG4gICAgICAvLyBUcmFjayB3aGVuIGEgZG9jdW1lbnQgd2FzIGNyZWF0ZWQgYnkgdGhpcyBjbGllbnQsIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgIC8vIGVtaXQgYSBsb2FkIGV2ZW50IHdoZW4gc3Vic2VxdWVudGx5IHN1YnNjcmliZWRcbiAgICAgIGRvYy5jcmVhdGVkTG9jYWxseSA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRvYy5fdXBkYXRlQ29sbGVjdGlvbkRhdGEoKTtcbiAgICB2YXIgdmFsdWUgPSBzaGFyZURvYy5zbmFwc2hvdDtcbiAgICBtb2RlbC5lbWl0KCdjaGFuZ2UnLCBbY29sbGVjdGlvbk5hbWUsIGlkXSwgW3ZhbHVlLCB2b2lkIDAsIG1vZGVsLl9wYXNzXSk7XG4gIH0pO1xufVxuXG5SZW1vdGVEb2MucHJvdG90eXBlID0gbmV3IERvYztcblxuUmVtb3RlRG9jLnByb3RvdHlwZS5fdXBkYXRlQ29sbGVjdGlvbkRhdGEgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jb2xsZWN0aW9uRGF0YVt0aGlzLmlkXSA9IHRoaXMuc2hhcmVEb2Muc25hcHNob3Q7XG59O1xuXG5SZW1vdGVEb2MucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCB2YWx1ZSwgY2IpIHtcbiAgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMCAmJiAhdGhpcy5zaGFyZURvYy50eXBlKSB7XG4gICAgdGhpcy5zaGFyZURvYy5jcmVhdGUoJ2pzb24wJywgdmFsdWUsIGNiKTtcbiAgICB0aGlzLl91cGRhdGVDb2xsZWN0aW9uRGF0YSgpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcHJldmlvdXMgPSB0aGlzLl9jcmVhdGVJbXBsaWVkKHNlZ21lbnRzKTtcbiAgdmFyIGxhc3RTZWdtZW50ID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV07XG4gIGlmIChwcmV2aW91cyBpbnN0YW5jZW9mIEltcGxpZWRPcCkge1xuICAgIHByZXZpb3VzLnZhbHVlW2xhc3RTZWdtZW50XSA9IHZhbHVlO1xuICAgIHRoaXMuc2hhcmVEb2Muc3VibWl0T3AocHJldmlvdXMub3AsIGNiKTtcbiAgICB0aGlzLl91cGRhdGVDb2xsZWN0aW9uRGF0YSgpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb3AgPSAoaXNBcnJheUluZGV4KGxhc3RTZWdtZW50KSkgP1xuICAgIChwcmV2aW91cyA9PSBudWxsKSA/XG4gICAgICBbbmV3IExpc3RJbnNlcnRPcChzZWdtZW50cy5zbGljZSgwLCAtMSksIGxhc3RTZWdtZW50LCB2YWx1ZSldIDpcbiAgICAgIFtuZXcgTGlzdFJlcGxhY2VPcChzZWdtZW50cy5zbGljZSgwLCAtMSksIGxhc3RTZWdtZW50LCBwcmV2aW91cywgdmFsdWUpXSA6XG4gICAgKHByZXZpb3VzID09IG51bGwpID9cbiAgICAgIFtuZXcgT2JqZWN0SW5zZXJ0T3Aoc2VnbWVudHMsIHZhbHVlKV0gOlxuICAgICAgW25ldyBPYmplY3RSZXBsYWNlT3Aoc2VnbWVudHMsIHByZXZpb3VzLCB2YWx1ZSldO1xuICB0aGlzLnNoYXJlRG9jLnN1Ym1pdE9wKG9wLCBjYik7XG4gIHRoaXMuX3VwZGF0ZUNvbGxlY3Rpb25EYXRhKCk7XG4gIHJldHVybiBwcmV2aW91cztcbn07XG5cblJlbW90ZURvYy5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24oc2VnbWVudHMsIGNiKSB7XG4gIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB2YXIgcHJldmlvdXMgPSB0aGlzLmdldCgpO1xuICAgIHRoaXMuc2hhcmVEb2MuZGVsKGNiKTtcbiAgICB0aGlzLl91cGRhdGVDb2xsZWN0aW9uRGF0YSgpO1xuICAgIHJldHVybiBwcmV2aW91cztcbiAgfVxuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiB0aGUgdmFsdWUgaXMgYWxyZWFkeSB1bmRlZmluZWQsIHNpbmNlXG4gIC8vIHRoZSBkZWwgbWV0aG9kIHNob3VsZCBub3QgY3JlYXRlIGFueXRoaW5nXG4gIHZhciBwcmV2aW91cyA9IHRoaXMuZ2V0KHNlZ21lbnRzKTtcbiAgaWYgKHByZXZpb3VzID09PSB2b2lkIDApIHtcbiAgICBjYigpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb3AgPSBbbmV3IE9iamVjdERlbGV0ZU9wKHNlZ21lbnRzLCBwcmV2aW91cyldO1xuICB0aGlzLnNoYXJlRG9jLnN1Ym1pdE9wKG9wLCBjYik7XG4gIHRoaXMuX3VwZGF0ZUNvbGxlY3Rpb25EYXRhKCk7XG4gIHJldHVybiBwcmV2aW91cztcbn07XG5cblJlbW90ZURvYy5wcm90b3R5cGUuaW5jcmVtZW50ID0gZnVuY3Rpb24oc2VnbWVudHMsIGJ5TnVtYmVyLCBjYikge1xuICB2YXIgcHJldmlvdXMgPSB0aGlzLl9jcmVhdGVJbXBsaWVkKHNlZ21lbnRzKTtcbiAgaWYgKHByZXZpb3VzIGluc3RhbmNlb2YgSW1wbGllZE9wKSB7XG4gICAgdmFyIGxhc3RTZWdtZW50ID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgcHJldmlvdXMudmFsdWVbbGFzdFNlZ21lbnRdID0gYnlOdW1iZXI7XG4gICAgdGhpcy5zaGFyZURvYy5zdWJtaXRPcChwcmV2aW91cy5vcCwgY2IpO1xuICAgIHRoaXMuX3VwZGF0ZUNvbGxlY3Rpb25EYXRhKCk7XG4gICAgcmV0dXJuIGJ5TnVtYmVyO1xuICB9XG4gIGlmIChwcmV2aW91cyA9PSBudWxsKSB7XG4gICAgdmFyIGxhc3RTZWdtZW50ID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgdmFyIG9wID0gKGlzQXJyYXlJbmRleChsYXN0U2VnbWVudCkpID9cbiAgICAgIFtuZXcgTGlzdEluc2VydE9wKHNlZ21lbnRzLnNsaWNlKDAsIC0xKSwgbGFzdFNlZ21lbnQsIGJ5TnVtYmVyKV0gOlxuICAgICAgW25ldyBPYmplY3RJbnNlcnRPcChzZWdtZW50cywgYnlOdW1iZXIpXTtcbiAgICB0aGlzLnNoYXJlRG9jLnN1Ym1pdE9wKG9wLCBjYik7XG4gICAgdGhpcy5fdXBkYXRlQ29sbGVjdGlvbkRhdGEoKTtcbiAgICByZXR1cm4gYnlOdW1iZXI7XG4gIH1cbiAgdmFyIG9wID0gW25ldyBJbmNyZW1lbnRPcChzZWdtZW50cywgYnlOdW1iZXIpXTtcbiAgdGhpcy5zaGFyZURvYy5zdWJtaXRPcChvcCwgY2IpO1xuICB0aGlzLl91cGRhdGVDb2xsZWN0aW9uRGF0YSgpO1xuICByZXR1cm4gcHJldmlvdXMgKyBieU51bWJlcjtcbn07XG5cblJlbW90ZURvYy5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCB2YWx1ZSwgY2IpIHtcbiAgdmFyIHNoYXJlRG9jID0gdGhpcy5zaGFyZURvYztcbiAgZnVuY3Rpb24gcHVzaChhcnIsIGZuQ2IpIHtcbiAgICB2YXIgb3AgPSBbbmV3IExpc3RJbnNlcnRPcChzZWdtZW50cywgYXJyLmxlbmd0aCwgdmFsdWUpXTtcbiAgICBzaGFyZURvYy5zdWJtaXRPcChvcCwgZm5DYik7XG4gICAgcmV0dXJuIGFyci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FycmF5QXBwbHkoc2VnbWVudHMsIHB1c2gsIGNiKTtcbn07XG5cblJlbW90ZURvYy5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCB2YWx1ZSwgY2IpIHtcbiAgdmFyIHNoYXJlRG9jID0gdGhpcy5zaGFyZURvYztcbiAgZnVuY3Rpb24gdW5zaGlmdChhcnIsIGZuQ2IpIHtcbiAgICB2YXIgb3AgPSBbbmV3IExpc3RJbnNlcnRPcChzZWdtZW50cywgMCwgdmFsdWUpXTtcbiAgICBzaGFyZURvYy5zdWJtaXRPcChvcCwgZm5DYik7XG4gICAgcmV0dXJuIGFyci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FycmF5QXBwbHkoc2VnbWVudHMsIHVuc2hpZnQsIGNiKTtcbn07XG5cblJlbW90ZURvYy5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24oc2VnbWVudHMsIGluZGV4LCB2YWx1ZXMsIGNiKSB7XG4gIHZhciBzaGFyZURvYyA9IHRoaXMuc2hhcmVEb2M7XG4gIGZ1bmN0aW9uIGluc2VydChhcnIsIGZuQ2IpIHtcbiAgICB2YXIgb3AgPSBjcmVhdGVJbnNlcnRPcChzZWdtZW50cywgaW5kZXgsIHZhbHVlcyk7XG4gICAgc2hhcmVEb2Muc3VibWl0T3Aob3AsIGZuQ2IpO1xuICAgIHJldHVybiBhcnIubGVuZ3RoO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJheUFwcGx5KHNlZ21lbnRzLCBpbnNlcnQsIGNiKTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUluc2VydE9wKHNlZ21lbnRzLCBpbmRleCwgdmFsdWVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgcmV0dXJuIFtuZXcgTGlzdEluc2VydE9wKHNlZ21lbnRzLCBpbmRleCwgdmFsdWVzKV07XG4gIH1cbiAgdmFyIG9wID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBvcC5wdXNoKG5ldyBMaXN0SW5zZXJ0T3Aoc2VnbWVudHMsIGluZGV4KyssIHZhbHVlc1tpXSkpO1xuICB9XG4gIHJldHVybiBvcDtcbn1cblxuUmVtb3RlRG9jLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbihzZWdtZW50cywgY2IpIHtcbiAgdmFyIHNoYXJlRG9jID0gdGhpcy5zaGFyZURvYztcbiAgZnVuY3Rpb24gcG9wKGFyciwgZm5DYikge1xuICAgIHZhciBpbmRleCA9IGFyci5sZW5ndGggLSAxO1xuICAgIHZhciB2YWx1ZSA9IGFycltpbmRleF07XG4gICAgdmFyIG9wID0gW25ldyBMaXN0UmVtb3ZlT3Aoc2VnbWVudHMsIGluZGV4LCB2YWx1ZSldO1xuICAgIHNoYXJlRG9jLnN1Ym1pdE9wKG9wLCBmbkNiKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FycmF5QXBwbHkoc2VnbWVudHMsIHBvcCwgY2IpO1xufTtcblxuUmVtb3RlRG9jLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBjYikge1xuICB2YXIgc2hhcmVEb2MgPSB0aGlzLnNoYXJlRG9jO1xuICBmdW5jdGlvbiBzaGlmdChhcnIsIGZuQ2IpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJbMF07XG4gICAgdmFyIG9wID0gW25ldyBMaXN0UmVtb3ZlT3Aoc2VnbWVudHMsIDAsIHZhbHVlKV07XG4gICAgc2hhcmVEb2Muc3VibWl0T3Aob3AsIGZuQ2IpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyYXlBcHBseShzZWdtZW50cywgc2hpZnQsIGNiKTtcbn07XG5cblJlbW90ZURvYy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oc2VnbWVudHMsIGluZGV4LCBob3dNYW55LCBjYikge1xuICB2YXIgc2hhcmVEb2MgPSB0aGlzLnNoYXJlRG9jO1xuICBmdW5jdGlvbiByZW1vdmUoYXJyLCBmbkNiKSB7XG4gICAgdmFyIHZhbHVlcyA9IGFyci5zbGljZShpbmRleCwgaW5kZXggKyBob3dNYW55KTtcbiAgICB2YXIgb3AgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBvcC5wdXNoKG5ldyBMaXN0UmVtb3ZlT3Aoc2VnbWVudHMsIGluZGV4LCB2YWx1ZXNbaV0pKTtcbiAgICB9XG4gICAgc2hhcmVEb2Muc3VibWl0T3Aob3AsIGZuQ2IpO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FycmF5QXBwbHkoc2VnbWVudHMsIHJlbW92ZSwgY2IpO1xufTtcblxuUmVtb3RlRG9jLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24oc2VnbWVudHMsIGZyb20sIHRvLCBob3dNYW55LCBjYikge1xuICB2YXIgc2hhcmVEb2MgPSB0aGlzLnNoYXJlRG9jO1xuICBmdW5jdGlvbiBtb3ZlKGFyciwgZm5DYikge1xuICAgIC8vIEdldCB0aGUgcmV0dXJuIHZhbHVlXG4gICAgdmFyIHZhbHVlcyA9IGFyci5zbGljZShmcm9tLCBmcm9tICsgaG93TWFueSk7XG5cbiAgICAvLyBCdWlsZCBhbiBvcCB0aGF0IG1vdmVzIGVhY2ggaXRlbSBpbmRpdmlkdWFsbHlcbiAgICB2YXIgb3AgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvd01hbnk7IGkrKykge1xuICAgICAgb3AucHVzaChuZXcgTGlzdE1vdmVPcChzZWdtZW50cywgKGZyb20gPCB0bykgPyBmcm9tIDogZnJvbSArIGhvd01hbnkgLSAxLCAoZnJvbSA8IHRvKSA/IHRvICsgaG93TWFueSAtIDEgOiB0bykpO1xuICAgIH1cbiAgICBzaGFyZURvYy5zdWJtaXRPcChvcCwgZm5DYik7XG5cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJheUFwcGx5KHNlZ21lbnRzLCBtb3ZlLCBjYik7XG59O1xuXG5SZW1vdGVEb2MucHJvdG90eXBlLnN0cmluZ0luc2VydCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBpbmRleCwgdmFsdWUsIGNiKSB7XG4gIHZhciBwcmV2aW91cyA9IHRoaXMuX2NyZWF0ZUltcGxpZWQoc2VnbWVudHMpO1xuICBpZiAocHJldmlvdXMgaW5zdGFuY2VvZiBJbXBsaWVkT3ApIHtcbiAgICB2YXIgbGFzdFNlZ21lbnQgPSBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICBwcmV2aW91cy52YWx1ZVtsYXN0U2VnbWVudF0gPSB2YWx1ZTtcbiAgICB0aGlzLnNoYXJlRG9jLnN1Ym1pdE9wKHByZXZpb3VzLm9wLCBjYik7XG4gICAgdGhpcy5fdXBkYXRlQ29sbGVjdGlvbkRhdGEoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHByZXZpb3VzID09IG51bGwpIHtcbiAgICB2YXIgbGFzdFNlZ21lbnQgPSBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICB2YXIgb3AgPSAoaXNBcnJheUluZGV4KGxhc3RTZWdtZW50KSkgP1xuICAgICAgW25ldyBMaXN0SW5zZXJ0T3Aoc2VnbWVudHMuc2xpY2UoMCwgLTEpLCBsYXN0U2VnbWVudCwgdmFsdWUpXSA6XG4gICAgICBbbmV3IE9iamVjdEluc2VydE9wKHNlZ21lbnRzLCB2YWx1ZSldO1xuICAgIHRoaXMuc2hhcmVEb2Muc3VibWl0T3Aob3AsIGNiKTtcbiAgICB0aGlzLl91cGRhdGVDb2xsZWN0aW9uRGF0YSgpO1xuICAgIHJldHVybiBwcmV2aW91cztcbiAgfVxuICB2YXIgb3AgPSBbbmV3IFN0cmluZ0luc2VydE9wKHNlZ21lbnRzLCBpbmRleCwgdmFsdWUpXTtcbiAgdGhpcy5zaGFyZURvYy5zdWJtaXRPcChvcCwgY2IpO1xuICB0aGlzLl91cGRhdGVDb2xsZWN0aW9uRGF0YSgpO1xuICByZXR1cm4gcHJldmlvdXM7XG59O1xuXG5SZW1vdGVEb2MucHJvdG90eXBlLnN0cmluZ1JlbW92ZSA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBpbmRleCwgaG93TWFueSwgY2IpIHtcbiAgdmFyIHByZXZpb3VzID0gdGhpcy5fY3JlYXRlSW1wbGllZChzZWdtZW50cyk7XG4gIGlmIChwcmV2aW91cyBpbnN0YW5jZW9mIEltcGxpZWRPcCkgcmV0dXJuO1xuICBpZiAocHJldmlvdXMgPT0gbnVsbCkgcmV0dXJuIHByZXZpb3VzO1xuICB2YXIgcmVtb3ZlZCA9IHByZXZpb3VzLnNsaWNlKGluZGV4LCBpbmRleCArIGhvd01hbnkpO1xuICB2YXIgb3AgPSBbbmV3IFN0cmluZ1JlbW92ZU9wKHNlZ21lbnRzLCBpbmRleCwgcmVtb3ZlZCldO1xuICB0aGlzLnNoYXJlRG9jLnN1Ym1pdE9wKG9wLCBjYik7XG4gIHRoaXMuX3VwZGF0ZUNvbGxlY3Rpb25EYXRhKCk7XG4gIHJldHVybiBwcmV2aW91cztcbn07XG5cblJlbW90ZURvYy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oc2VnbWVudHMpIHtcbiAgcmV0dXJuIHV0aWwubG9va3VwKHNlZ21lbnRzLCB0aGlzLnNoYXJlRG9jLnNuYXBzaG90KTtcbn07XG5cblJlbW90ZURvYy5wcm90b3R5cGUuX2NyZWF0ZUltcGxpZWQgPSBmdW5jdGlvbihzZWdtZW50cykge1xuICBpZiAoIXRoaXMuc2hhcmVEb2MudHlwZSkge1xuICAgIHRoaXMuc2hhcmVEb2MuY3JlYXRlKCdqc29uMCcpO1xuICB9XG4gIHZhciBwYXJlbnQgPSB0aGlzLnNoYXJlRG9jO1xuICB2YXIga2V5ID0gJ3NuYXBzaG90JztcbiAgdmFyIG5vZGUgPSBwYXJlbnRba2V5XTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbmV4dEtleSA9IHNlZ21lbnRzW2krK107XG4gIHZhciBvcCwgdmFsdWU7XG4gIHdoaWxlIChuZXh0S2V5ICE9IG51bGwpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIGlmIChvcCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlW2tleV0gPSBpc0FycmF5SW5kZXgobmV4dEtleSkgPyBbXSA6IHt9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBpc0FycmF5SW5kZXgobmV4dEtleSkgPyBbXSA6IHt9O1xuICAgICAgICBvcCA9IChBcnJheS5pc0FycmF5KHBhcmVudCkpID9cbiAgICAgICAgICBuZXcgTGlzdEluc2VydE9wKHNlZ21lbnRzLnNsaWNlKDAsIGkgLSAyKSwga2V5LCB2YWx1ZSkgOlxuICAgICAgICAgIG5ldyBPYmplY3RJbnNlcnRPcChzZWdtZW50cy5zbGljZSgwLCBpIC0gMSksIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgcGFyZW50ID0gbm9kZTtcbiAgICBrZXkgPSBuZXh0S2V5O1xuICAgIG5vZGUgPSBwYXJlbnRba2V5XTtcbiAgICBuZXh0S2V5ID0gc2VnbWVudHNbaSsrXTtcbiAgfVxuICBpZiAob3ApIHJldHVybiBuZXcgSW1wbGllZE9wKG9wLCB2YWx1ZSk7XG4gIHJldHVybiBub2RlO1xufTtcblxuZnVuY3Rpb24gSW1wbGllZE9wKG9wLCB2YWx1ZSkge1xuICB0aGlzLm9wID0gb3A7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbn1cblxuUmVtb3RlRG9jLnByb3RvdHlwZS5fYXJyYXlBcHBseSA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBmbiwgY2IpIHtcbiAgdmFyIGFyciA9IHRoaXMuX2NyZWF0ZUltcGxpZWQoc2VnbWVudHMpO1xuICBpZiAoYXJyIGluc3RhbmNlb2YgSW1wbGllZE9wKSB7XG4gICAgdGhpcy5zaGFyZURvYy5zdWJtaXRPcChhcnIub3ApO1xuICAgIGFyciA9IHRoaXMuZ2V0KHNlZ21lbnRzKTtcbiAgfSBlbHNlIGlmIChhcnIgPT0gbnVsbCkge1xuICAgIHZhciBsYXN0U2VnbWVudCA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgIHZhciBvcCA9IChpc0FycmF5SW5kZXgobGFzdFNlZ21lbnQpKSA/XG4gICAgICBbbmV3IExpc3RJbnNlcnRPcChzZWdtZW50cy5zbGljZSgwLCAtMSksIGxhc3RTZWdtZW50LCBbXSldIDpcbiAgICAgIFtuZXcgT2JqZWN0SW5zZXJ0T3Aoc2VnbWVudHMsIFtdKV07XG4gICAgdGhpcy5zaGFyZURvYy5zdWJtaXRPcChvcCk7XG4gICAgYXJyID0gdGhpcy5nZXQoc2VnbWVudHMpO1xuICB9XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICB2YXIgbWVzc2FnZSA9IHRoaXMuX2Vycm9yTWVzc2FnZShmbi5uYW1lICsgJyBvbiBub24tYXJyYXknLCBzZWdtZW50cywgYXJyKTtcbiAgICB2YXIgZXJyID0gbmV3IFR5cGVFcnJvcihtZXNzYWdlKTtcbiAgICByZXR1cm4gY2IoZXJyKTtcbiAgfVxuICB2YXIgb3V0ID0gZm4oYXJyLCBjYik7XG4gIHRoaXMuX3VwZGF0ZUNvbGxlY3Rpb25EYXRhKCk7XG4gIHJldHVybiBvdXQ7XG59O1xuXG5SZW1vdGVEb2MucHJvdG90eXBlLl9vbk9wID0gZnVuY3Rpb24ob3ApIHtcbiAgdmFyIGl0ZW0gPSBvcFswXTtcbiAgdmFyIHNlZ21lbnRzID0gW3RoaXMuY29sbGVjdGlvbk5hbWUsIHRoaXMuaWRdLmNvbmNhdChpdGVtLnApO1xuICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuXG4gIC8vIE9iamVjdFJlcGxhY2VPcCwgT2JqZWN0SW5zZXJ0T3AsIG9yIE9iamVjdERlbGV0ZU9wXG4gIGlmIChkZWZpbmVkKGl0ZW0ub2kpIHx8IGRlZmluZWQoaXRlbS5vZCkpIHtcbiAgICB2YXIgdmFsdWUgPSBpdGVtLm9pO1xuICAgIHZhciBwcmV2aW91cyA9IGl0ZW0ub2Q7XG4gICAgbW9kZWwuZW1pdCgnY2hhbmdlJywgc2VnbWVudHMsIFt2YWx1ZSwgcHJldmlvdXMsIG1vZGVsLl9wYXNzXSk7XG5cbiAgLy8gTGlzdFJlcGxhY2VPcFxuICB9IGVsc2UgaWYgKGRlZmluZWQoaXRlbS5saSkgJiYgZGVmaW5lZChpdGVtLmxkKSkge1xuICAgIHZhciB2YWx1ZSA9IGl0ZW0ubGk7XG4gICAgdmFyIHByZXZpb3VzID0gaXRlbS5sZDtcbiAgICBtb2RlbC5lbWl0KCdjaGFuZ2UnLCBzZWdtZW50cywgW3ZhbHVlLCBwcmV2aW91cywgbW9kZWwuX3Bhc3NdKTtcblxuICAvLyBMaXN0SW5zZXJ0T3BcbiAgfSBlbHNlIGlmIChkZWZpbmVkKGl0ZW0ubGkpKSB7XG4gICAgdmFyIGluZGV4ID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgdmFyIHZhbHVlcyA9IFtpdGVtLmxpXTtcbiAgICBtb2RlbC5lbWl0KCdpbnNlcnQnLCBzZWdtZW50cy5zbGljZSgwLCAtMSksIFtpbmRleCwgdmFsdWVzLCBtb2RlbC5fcGFzc10pO1xuXG4gIC8vIExpc3RSZW1vdmVPcFxuICB9IGVsc2UgaWYgKGRlZmluZWQoaXRlbS5sZCkpIHtcbiAgICB2YXIgaW5kZXggPSBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICB2YXIgcmVtb3ZlZCA9IFtpdGVtLmxkXTtcbiAgICBtb2RlbC5lbWl0KCdyZW1vdmUnLCBzZWdtZW50cy5zbGljZSgwLCAtMSksIFtpbmRleCwgcmVtb3ZlZCwgbW9kZWwuX3Bhc3NdKTtcblxuICAvLyBMaXN0TW92ZU9wXG4gIH0gZWxzZSBpZiAoZGVmaW5lZChpdGVtLmxtKSkge1xuICAgIHZhciBmcm9tID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgdmFyIHRvID0gaXRlbS5sbSAtIDE7XG4gICAgdmFyIGhvd01hbnkgPSAxO1xuICAgIG1vZGVsLmVtaXQoJ21vdmUnLCBzZWdtZW50cy5zbGljZSgwLCAtMSksIFtmcm9tLCB0bywgaG93TWFueSwgbW9kZWwuX3Bhc3NdKTtcblxuICAvLyBTdHJpbmdJbnNlcnRPcFxuICB9IGVsc2UgaWYgKGRlZmluZWQoaXRlbS5zaSkpIHtcbiAgICB2YXIgaW5kZXggPSBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICB2YXIgdGV4dCA9IGl0ZW0uc2k7XG4gICAgc2VnbWVudHMgPSBzZWdtZW50cy5zbGljZSgwLCAtMSk7XG4gICAgbW9kZWwuZW1pdCgnc3RyaW5nSW5zZXJ0Jywgc2VnbWVudHMsIFtpbmRleCwgdGV4dCwgbW9kZWwuX3Bhc3NdKTtcbiAgICB2YXIgdmFsdWUgPSBtb2RlbC5fZ2V0KHNlZ21lbnRzKTtcbiAgICB2YXIgcHJldmlvdXMgPSB2YWx1ZS5zbGljZSgwLCBpbmRleCkgKyB2YWx1ZS5zbGljZShpbmRleCArIHRleHQubGVuZ3RoKTtcbiAgICBtb2RlbC5lbWl0KCdjaGFuZ2UnLCBzZWdtZW50cywgW3ZhbHVlLCBwcmV2aW91cywgdGhpcy5fcGFzc1N0cmluZ0luc2VydF0pO1xuXG4gIC8vIFN0cmluZ1JlbW92ZU9wXG4gIH0gZWxzZSBpZiAoZGVmaW5lZChpdGVtLnNkKSkge1xuICAgIHZhciBpbmRleCA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgIHZhciB0ZXh0ID0gaXRlbS5zZDtcbiAgICB2YXIgaG93TWFueSA9IHRleHQubGVuZ3RoO1xuICAgIHNlZ21lbnRzID0gc2VnbWVudHMuc2xpY2UoMCwgLTEpO1xuICAgIG1vZGVsLmVtaXQoJ3N0cmluZ1JlbW92ZScsIHNlZ21lbnRzLCBbaW5kZXgsIGhvd01hbnksIG1vZGVsLl9wYXNzXSk7XG4gICAgdmFyIHZhbHVlID0gbW9kZWwuX2dldChzZWdtZW50cyk7XG4gICAgdmFyIHByZXZpb3VzID0gdmFsdWUuc2xpY2UoMCwgaW5kZXgpICsgdGV4dCArIHZhbHVlLnNsaWNlKGluZGV4KTtcbiAgICBtb2RlbC5lbWl0KCdjaGFuZ2UnLCBzZWdtZW50cywgW3ZhbHVlLCBwcmV2aW91cywgdGhpcy5fcGFzc1N0cmluZ1JlbW92ZV0pO1xuXG4gIC8vIEluY3JlbWVudE9wXG4gIH0gZWxzZSBpZiAoZGVmaW5lZChpdGVtLm5hKSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KGl0ZW0ucCk7XG4gICAgdmFyIHByZXZpb3VzID0gdmFsdWUgLSBpdGVtLm5hO1xuICAgIG1vZGVsLmVtaXQoJ2NoYW5nZScsIHNlZ21lbnRzLCBbdmFsdWUsIHByZXZpb3VzLCBtb2RlbC5fcGFzc10pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBPYmplY3RSZXBsYWNlT3Aoc2VnbWVudHMsIGJlZm9yZSwgYWZ0ZXIpIHtcbiAgdGhpcy5wID0gY2FzdFNlZ21lbnRzKHNlZ21lbnRzKTtcbiAgdGhpcy5vZCA9IGJlZm9yZTtcbiAgdGhpcy5vaSA9IChhZnRlciA9PT0gdm9pZCAwKSA/IG51bGwgOiBhZnRlcjtcbn1cbmZ1bmN0aW9uIE9iamVjdEluc2VydE9wKHNlZ21lbnRzLCB2YWx1ZSkge1xuICB0aGlzLnAgPSBjYXN0U2VnbWVudHMoc2VnbWVudHMpO1xuICB0aGlzLm9pID0gKHZhbHVlID09PSB2b2lkIDApID8gbnVsbCA6IHZhbHVlO1xufVxuZnVuY3Rpb24gT2JqZWN0RGVsZXRlT3Aoc2VnbWVudHMsIHZhbHVlKSB7XG4gIHRoaXMucCA9IGNhc3RTZWdtZW50cyhzZWdtZW50cyk7XG4gIHRoaXMub2QgPSAodmFsdWUgPT09IHZvaWQgMCkgPyBudWxsIDogdmFsdWU7XG59XG5mdW5jdGlvbiBMaXN0UmVwbGFjZU9wKHNlZ21lbnRzLCBpbmRleCwgYmVmb3JlLCBhZnRlcikge1xuICB0aGlzLnAgPSBjYXN0U2VnbWVudHMoc2VnbWVudHMuY29uY2F0KGluZGV4KSk7XG4gIHRoaXMubGQgPSBiZWZvcmU7XG4gIHRoaXMubGkgPSAoYWZ0ZXIgPT09IHZvaWQgMCkgPyBudWxsIDogYWZ0ZXI7XG59XG5mdW5jdGlvbiBMaXN0SW5zZXJ0T3Aoc2VnbWVudHMsIGluZGV4LCB2YWx1ZSkge1xuICB0aGlzLnAgPSBjYXN0U2VnbWVudHMoc2VnbWVudHMuY29uY2F0KGluZGV4KSk7XG4gIHRoaXMubGkgPSAodmFsdWUgPT09IHZvaWQgMCkgPyBudWxsIDogdmFsdWU7XG59XG5mdW5jdGlvbiBMaXN0UmVtb3ZlT3Aoc2VnbWVudHMsIGluZGV4LCB2YWx1ZSkge1xuICB0aGlzLnAgPSBjYXN0U2VnbWVudHMoc2VnbWVudHMuY29uY2F0KGluZGV4KSk7XG4gIHRoaXMubGQgPSAodmFsdWUgPT09IHZvaWQgMCkgPyBudWxsIDogdmFsdWU7XG59XG5mdW5jdGlvbiBMaXN0TW92ZU9wKHNlZ21lbnRzLCBmcm9tLCB0bykge1xuICB0aGlzLnAgPSBjYXN0U2VnbWVudHMoc2VnbWVudHMuY29uY2F0KGZyb20pKTtcbiAgdGhpcy5sbSA9IHRvO1xufVxuZnVuY3Rpb24gU3RyaW5nSW5zZXJ0T3Aoc2VnbWVudHMsIGluZGV4LCB2YWx1ZSkge1xuICB0aGlzLnAgPSBjYXN0U2VnbWVudHMoc2VnbWVudHMuY29uY2F0KGluZGV4KSk7XG4gIHRoaXMuc2kgPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIFN0cmluZ1JlbW92ZU9wKHNlZ21lbnRzLCBpbmRleCwgdmFsdWUpIHtcbiAgdGhpcy5wID0gY2FzdFNlZ21lbnRzKHNlZ21lbnRzLmNvbmNhdChpbmRleCkpO1xuICB0aGlzLnNkID0gdmFsdWU7XG59XG5mdW5jdGlvbiBJbmNyZW1lbnRPcChzZWdtZW50cywgYnlOdW1iZXIpIHtcbiAgdGhpcy5wID0gY2FzdFNlZ21lbnRzKHNlZ21lbnRzKTtcbiAgdGhpcy5uYSA9IGJ5TnVtYmVyO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBjYXN0U2VnbWVudHMoc2VnbWVudHMpIHtcbiAgLy8gQ2FzdCBudW1iZXIgcGF0aCBzZWdtZW50cyBmcm9tIHN0cmluZ3MgdG8gbnVtYmVyc1xuICBmb3IgKHZhciBpID0gc2VnbWVudHMubGVuZ3RoOyBpLS07KSB7XG4gICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT09ICdzdHJpbmcnICYmIGlzQXJyYXlJbmRleChzZWdtZW50KSkge1xuICAgICAgc2VnbWVudHNbaV0gPSArc2VnbWVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlZ21lbnRzO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5SW5kZXgoc2VnbWVudCkge1xuICByZXR1cm4gKC9eWzAtOV0rJC8pLnRlc3Qoc2VnbWVudCk7XG59XG4iLCJ2YXIgc2hhcmUgPSByZXF1aXJlKCdzaGFyZS9saWIvY2xpZW50Jyk7XG52YXIgQ2hhbm5lbCA9IHJlcXVpcmUoJy4uL0NoYW5uZWwnKTtcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcbnZhciBMb2NhbERvYyA9IHJlcXVpcmUoJy4vTG9jYWxEb2MnKTtcbnZhciBSZW1vdGVEb2MgPSByZXF1aXJlKCcuL1JlbW90ZURvYycpO1xuXG5Nb2RlbC5wcm90b3R5cGUuX2NyZWF0ZUNvbm5lY3Rpb24gPSBmdW5jdGlvbihidW5kbGUpIHtcbiAgLy8gTW9kZWw6Ol9jcmVhdGVTb2NrZXQgc2hvdWxkIGJlIGRlZmluZWQgYnkgdGhlIHNvY2tldCBwbHVnaW5cbiAgdGhpcy5yb290LnNvY2tldCA9IHRoaXMuX2NyZWF0ZVNvY2tldChidW5kbGUpO1xuXG4gIC8vIFRoZSBTaGFyZSBjb25uZWN0aW9uIHdpbGwgYmluZCB0byB0aGUgc29ja2V0IGJ5IGRlZmluaW5nIHRoZSBvbm9wZW4sXG4gIC8vIG9ubWVzc2FnZSwgZXRjLiBtZXRob2RzXG4gIHZhciBzaGFyZUNvbm5lY3Rpb24gPSB0aGlzLnJvb3Quc2hhcmVDb25uZWN0aW9uID0gbmV3IHNoYXJlLkNvbm5lY3Rpb24odGhpcy5yb290LnNvY2tldCk7XG4gIHZhciBzZWdtZW50cyA9IFsnJGNvbm5lY3Rpb24nLCAnc3RhdGUnXTtcbiAgdmFyIHN0YXRlcyA9IFsnY29ubmVjdGluZycsICdjb25uZWN0ZWQnLCAnZGlzY29ubmVjdGVkJywgJ3N0b3BwZWQnXTtcbiAgdmFyIG1vZGVsID0gdGhpcztcbiAgc3RhdGVzLmZvckVhY2goZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBzaGFyZUNvbm5lY3Rpb24ub24oc3RhdGUsIGZ1bmN0aW9uKCkge1xuICAgICAgbW9kZWwuX3NldChzZWdtZW50cywgc3RhdGUpO1xuICAgIH0pO1xuICB9KTtcbiAgdGhpcy5fc2V0KHNlZ21lbnRzLCAnY29ubmVjdGVkJyk7XG5cbiAgLy8gV3JhcCB0aGUgc29ja2V0IG1ldGhvZHMgb24gdG9wIG9mIFNoYXJlJ3MgbWV0aG9kc1xuICB0aGlzLl9jcmVhdGVDaGFubmVsKCk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJvb3Quc29ja2V0Lm9wZW4oKTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJvb3Quc29ja2V0LmNsb3NlKCk7XG59O1xuTW9kZWwucHJvdG90eXBlLnJlY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgdGhpcy5jb25uZWN0KCk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuX2NyZWF0ZUNoYW5uZWwgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yb290LmNoYW5uZWwgPSBuZXcgQ2hhbm5lbCh0aGlzLnJvb3Quc29ja2V0KTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5fZ2V0T3JDcmVhdGVTaGFyZURvYyA9IGZ1bmN0aW9uKGNvbGxlY3Rpb25OYW1lLCBpZCwgZGF0YSkge1xuICB2YXIgc2hhcmVEb2MgPSB0aGlzLnJvb3Quc2hhcmVDb25uZWN0aW9uLmdldChjb2xsZWN0aW9uTmFtZSwgaWQsIGRhdGEpO1xuICBzaGFyZURvYy5pbmNyZW1lbnRhbCA9IHRydWU7XG4gIHJldHVybiBzaGFyZURvYztcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5fZ2V0RG9jQ29uc3RydWN0b3IgPSBmdW5jdGlvbihuYW1lKSB7XG4gIC8vIFdoZXRoZXIgdGhlIGNvbGxlY3Rpb24gaXMgbG9jYWwgb3IgcmVtb3RlIGlzIGRldGVybWluZWQgYnkgaXRzIG5hbWUuXG4gIC8vIENvbGxlY3Rpb25zIHN0YXJ0aW5nIHdpdGggYW4gdW5kZXJzY29yZSAoJ18nKSBhcmUgZm9yIHVzZXItZGVmaW5lZCBsb2NhbFxuICAvLyBjb2xsZWN0aW9ucywgdGhvc2Ugc3RhcnRpbmcgd2l0aCBhIGRvbGxhciBzaWduICgnJCcnKSBhcmUgZm9yXG4gIC8vIGZyYW1ld29yay1kZWZpbmVkIGxvY2FsIGNvbGxlY3Rpb25zLCBhbmQgYWxsIG90aGVycyBhcmUgcmVtb3RlLlxuICB2YXIgZmlyc3RDaGFyY3RlciA9IG5hbWUuY2hhckF0KDApO1xuICB2YXIgaXNMb2NhbCA9IChmaXJzdENoYXJjdGVyID09PSAnXycgfHwgZmlyc3RDaGFyY3RlciA9PT0gJyQnKTtcbiAgcmV0dXJuIChpc0xvY2FsKSA/IExvY2FsRG9jIDogUmVtb3RlRG9jO1xufTtcbiIsIihmdW5jdGlvbigpe1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbi8qKlxuICogdG9TdHJpbmcgcmVmLlxuICovXG5cbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG4vKipcbiAqIFJldHVybiBFVGFnIGZvciBgYm9keWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8QnVmZmVyfSBib2R5XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmV0YWcgPSBmdW5jdGlvbihib2R5KXtcbiAgcmV0dXJuICdcIicgKyBjcmMzMi5zaWduZWQoYm9keSkgKyAnXCInO1xufTtcblxuLyoqXG4gKiBNYWtlIGBsb2NhbHMoKWAgYm91bmQgdG8gdGhlIGdpdmVuIGBvYmpgLlxuICpcbiAqIFRoaXMgaXMgdXNlZCBmb3IgYGFwcC5sb2NhbHNgIGFuZCBgcmVzLmxvY2Fsc2AuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmxvY2FscyA9IGZ1bmN0aW9uKG9iail7XG4gIGZ1bmN0aW9uIGxvY2FscyhvYmope1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGxvY2Fsc1trZXldID0gb2JqW2tleV07XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICByZXR1cm4gbG9jYWxzO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgcGF0aGAgbG9va3MgYWJzb2x1dGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKXtcbiAgaWYgKCcvJyA9PSBwYXRoWzBdKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKCc6JyA9PSBwYXRoWzFdICYmICdcXFxcJyA9PSBwYXRoWzJdKSByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogRmxhdHRlbiB0aGUgZ2l2ZW4gYGFycmAuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZmxhdHRlbiA9IGZ1bmN0aW9uKGFyciwgcmV0KXtcbiAgdmFyIHJldCA9IHJldCB8fCBbXVxuICAgICwgbGVuID0gYXJyLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycltpXSkpIHtcbiAgICAgIGV4cG9ydHMuZmxhdHRlbihhcnJbaV0sIHJldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldC5wdXNoKGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgZ2l2ZW4gYHR5cGVgLCBmb3IgZXhhbXBsZSBcImh0bWxcIiBiZWNvbWVzIFwidGV4dC9odG1sXCIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMubm9ybWFsaXplVHlwZSA9IGZ1bmN0aW9uKHR5cGUpe1xuICByZXR1cm4gfnR5cGUuaW5kZXhPZignLycpXG4gICAgPyBhY2NlcHRQYXJhbXModHlwZSlcbiAgICA6IHsgdmFsdWU6IG1pbWUubG9va3VwKHR5cGUpLCBwYXJhbXM6IHt9IH07XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBgdHlwZXNgLCBmb3IgZXhhbXBsZSBcImh0bWxcIiBiZWNvbWVzIFwidGV4dC9odG1sXCIuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdHlwZXNcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5ub3JtYWxpemVUeXBlcyA9IGZ1bmN0aW9uKHR5cGVzKXtcbiAgdmFyIHJldCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyArK2kpIHtcbiAgICByZXQucHVzaChleHBvcnRzLm5vcm1hbGl6ZVR5cGUodHlwZXNbaV0pKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgYWNjZXB0YWJsZSB0eXBlIGluIGB0eXBlc2AsIGlmIGFueS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5hY2NlcHRzQXJyYXkgPSBmdW5jdGlvbih0eXBlcywgc3RyKXtcbiAgLy8gYWNjZXB0IGFueXRoaW5nIHdoZW4gQWNjZXB0IGlzIG5vdCBwcmVzZW50XG4gIGlmICghc3RyKSByZXR1cm4gdHlwZXNbMF07XG5cbiAgLy8gcGFyc2VcbiAgdmFyIGFjY2VwdGVkID0gZXhwb3J0cy5wYXJzZUFjY2VwdChzdHIpXG4gICAgLCBub3JtYWxpemVkID0gZXhwb3J0cy5ub3JtYWxpemVUeXBlcyh0eXBlcylcbiAgICAsIGxlbiA9IGFjY2VwdGVkLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgZm9yICh2YXIgaiA9IDAsIGpsZW4gPSB0eXBlcy5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcbiAgICAgIGlmIChleHBvcnRzLmFjY2VwdChub3JtYWxpemVkW2pdLCBhY2NlcHRlZFtpXSkpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVzW2pdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgdHlwZShzKWAgYXJlIGFjY2VwdGFibGUgYmFzZWQgb25cbiAqIHRoZSBnaXZlbiBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gdHlwZShzKVxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7Qm9vbGVhbnxTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmFjY2VwdHMgPSBmdW5jdGlvbih0eXBlLCBzdHIpe1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHR5cGUpIHR5cGUgPSB0eXBlLnNwbGl0KC8gKiwgKi8pO1xuICByZXR1cm4gZXhwb3J0cy5hY2NlcHRzQXJyYXkodHlwZSwgc3RyKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYHR5cGVgIGFycmF5IGlzIGFjY2VwdGFibGUgZm9yIGBvdGhlcmAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlclxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuYWNjZXB0ID0gZnVuY3Rpb24odHlwZSwgb3RoZXIpe1xuICB2YXIgdCA9IHR5cGUudmFsdWUuc3BsaXQoJy8nKTtcbiAgcmV0dXJuICh0WzBdID09IG90aGVyLnR5cGUgfHwgJyonID09IG90aGVyLnR5cGUpXG4gICAgJiYgKHRbMV0gPT0gb3RoZXIuc3VidHlwZSB8fCAnKicgPT0gb3RoZXIuc3VidHlwZSlcbiAgICAmJiBwYXJhbXNFcXVhbCh0eXBlLnBhcmFtcywgb3RoZXIucGFyYW1zKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYWNjZXB0IHBhcmFtcyBhcmUgZXF1YWwuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyYW1zRXF1YWwoYSwgYil7XG4gIHJldHVybiAhT2JqZWN0LmtleXMoYSkuc29tZShmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIGFba10gIT0gYltrXTtcbiAgfSk7XG59XG5cbi8qKlxuICogUGFyc2UgYWNjZXB0IGBzdHJgLCByZXR1cm5pbmdcbiAqIGFuIGFycmF5IG9iamVjdHMgY29udGFpbmluZ1xuICogYC50eXBlYCBhbmQgYC5zdWJ0eXBlYCBhbG9uZ1xuICogd2l0aCB0aGUgdmFsdWVzIHByb3ZpZGVkIGJ5XG4gKiBgcGFyc2VRdWFsaXR5KClgLlxuICpcbiAqIEBwYXJhbSB7VHlwZX0gbmFtZVxuICogQHJldHVybiB7VHlwZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMucGFyc2VBY2NlcHQgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gZXhwb3J0c1xuICAgIC5wYXJzZVBhcmFtcyhzdHIpXG4gICAgLm1hcChmdW5jdGlvbihvYmope1xuICAgICAgdmFyIHBhcnRzID0gb2JqLnZhbHVlLnNwbGl0KCcvJyk7XG4gICAgICBvYmoudHlwZSA9IHBhcnRzWzBdO1xuICAgICAgb2JqLnN1YnR5cGUgPSBwYXJ0c1sxXTtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHF1YWxpdHkgYHN0cmAsIHJldHVybmluZyBhblxuICogYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIGAudmFsdWVgLFxuICogYC5xdWFsaXR5YCBhbmQgb3B0aW9uYWwgYC5wYXJhbXNgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnBhcnNlUGFyYW1zID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIHN0clxuICAgIC5zcGxpdCgvICosICovKVxuICAgIC5tYXAoYWNjZXB0UGFyYW1zKVxuICAgIC5maWx0ZXIoZnVuY3Rpb24ob2JqKXtcbiAgICAgIHJldHVybiBvYmoucXVhbGl0eTtcbiAgICB9KVxuICAgIC5zb3J0KGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgaWYgKGEucXVhbGl0eSA9PT0gYi5xdWFsaXR5KSB7XG4gICAgICAgIHJldHVybiBhLm9yaWdpbmFsSW5kZXggLSBiLm9yaWdpbmFsSW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYi5xdWFsaXR5IC0gYS5xdWFsaXR5O1xuICAgICAgfVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBQYXJzZSBhY2NlcHQgcGFyYW1zIGBzdHJgIHJldHVybmluZyBhblxuICogb2JqZWN0IHdpdGggYC52YWx1ZWAsIGAucXVhbGl0eWAgYW5kIGAucGFyYW1zYC5cbiAqIGFsc28gaW5jbHVkZXMgYC5vcmlnaW5hbEluZGV4YCBmb3Igc3RhYmxlIHNvcnRpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBhY2NlcHRQYXJhbXMoc3RyLCBpbmRleCkge1xuICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoLyAqOyAqLyk7XG4gIHZhciByZXQgPSB7IHZhbHVlOiBwYXJ0c1swXSwgcXVhbGl0eTogMSwgcGFyYW1zOiB7fSwgb3JpZ2luYWxJbmRleDogaW5kZXggfTtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBtcyA9IHBhcnRzW2ldLnNwbGl0KC8gKj0gKi8pO1xuICAgIGlmICgncScgPT0gcG1zWzBdKSB7XG4gICAgICByZXQucXVhbGl0eSA9IHBhcnNlRmxvYXQocG1zWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0LnBhcmFtc1twbXNbMF1dID0gcG1zWzFdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogRXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyBpbiB0aGUgZ2l2ZW4gc3RyaW5nIG9mIGh0bWwuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBodG1sXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVzY2FwZSA9IGZ1bmN0aW9uKGh0bWwpIHtcbiAgcmV0dXJuIFN0cmluZyhodG1sKVxuICAgIC5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGdpdmVuIHBhdGggc3RyaW5nLFxuICogcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IHNob3VsZCBiZSBwYXNzZWQsXG4gKiB3aGljaCB3aWxsIGNvbnRhaW4gdGhlIHBsYWNlaG9sZGVyXG4gKiBrZXkgbmFtZXMuIEZvciBleGFtcGxlIFwiL3VzZXIvOmlkXCIgd2lsbFxuICogdGhlbiBjb250YWluIFtcImlkXCJdLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ3xSZWdFeHB8QXJyYXl9IHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSBrZXlzXG4gKiBAcGFyYW0gIHtCb29sZWFufSBzZW5zaXRpdmVcbiAqIEBwYXJhbSAge0Jvb2xlYW59IHN0cmljdFxuICogQHJldHVybiB7UmVnRXhwfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5wYXRoUmVnZXhwID0gZnVuY3Rpb24ocGF0aCwga2V5cywgc2Vuc2l0aXZlLCBzdHJpY3QpIHtcbiAgaWYgKHRvU3RyaW5nLmNhbGwocGF0aCkgPT0gJ1tvYmplY3QgUmVnRXhwXScpIHJldHVybiBwYXRoO1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkgcGF0aCA9ICcoJyArIHBhdGguam9pbignfCcpICsgJyknO1xuICBwYXRoID0gcGF0aFxuICAgIC5jb25jYXQoc3RyaWN0ID8gJycgOiAnLz8nKVxuICAgIC5yZXBsYWNlKC9cXC9cXCgvZywgJyg/Oi8nKVxuICAgIC5yZXBsYWNlKC8oXFwvKT8oXFwuKT86KFxcdyspKD86KFxcKC4qP1xcKSkpPyhcXD8pPyhcXCopPy9nLCBmdW5jdGlvbihfLCBzbGFzaCwgZm9ybWF0LCBrZXksIGNhcHR1cmUsIG9wdGlvbmFsLCBzdGFyKXtcbiAgICAgIGtleXMucHVzaCh7IG5hbWU6IGtleSwgb3B0aW9uYWw6ICEhIG9wdGlvbmFsIH0pO1xuICAgICAgc2xhc2ggPSBzbGFzaCB8fCAnJztcbiAgICAgIHJldHVybiAnJ1xuICAgICAgICArIChvcHRpb25hbCA/ICcnIDogc2xhc2gpXG4gICAgICAgICsgJyg/OidcbiAgICAgICAgKyAob3B0aW9uYWwgPyBzbGFzaCA6ICcnKVxuICAgICAgICArIChmb3JtYXQgfHwgJycpICsgKGNhcHR1cmUgfHwgKGZvcm1hdCAmJiAnKFteLy5dKz8pJyB8fCAnKFteL10rPyknKSkgKyAnKSdcbiAgICAgICAgKyAob3B0aW9uYWwgfHwgJycpXG4gICAgICAgICsgKHN0YXIgPyAnKC8qKT8nIDogJycpO1xuICAgIH0pXG4gICAgLnJlcGxhY2UoLyhbXFwvLl0pL2csICdcXFxcJDEnKVxuICAgIC5yZXBsYWNlKC9cXCovZywgJyguKiknKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoJ14nICsgcGF0aCArICckJywgc2Vuc2l0aXZlID8gJycgOiAnaScpO1xufVxuXG59KSgpIiwidmFyIHV1aWQgPSByZXF1aXJlKCdub2RlLXV1aWQnKTtcblxuTW9kZWwuSU5JVFMgPSBbXTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb2RlbDtcblxuZnVuY3Rpb24gTW9kZWwob3B0aW9ucykge1xuICB0aGlzLnJvb3QgPSB0aGlzO1xuXG4gIHZhciBpbml0cyA9IE1vZGVsLklOSVRTO1xuICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGluaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaW5pdHNbaV0odGhpcywgb3B0aW9ucyk7XG4gIH1cbn1cblxuTW9kZWwucHJvdG90eXBlLmlkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB1dWlkLnY0KCk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuX2NoaWxkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgQ2hpbGRNb2RlbCh0aGlzKTtcbn07XG5cbmZ1bmN0aW9uIENoaWxkTW9kZWwobW9kZWwpIHtcbiAgLy8gU2hhcmVkIHByb3BlcnRpZXMgc2hvdWxkIGJlIGFjY2Vzc2VkIHZpYSB0aGUgcm9vdC4gVGhpcyBtYWtlcyBpbmhlcml0YW5jZVxuICAvLyBjaGVhcCBhbmQgZWFzaWx5IGV4dGVuc2libGVcbiAgdGhpcy5yb290ID0gbW9kZWwucm9vdDtcblxuICAvLyBFdmVudEVtaXR0ZXIgbWV0aG9kcyBhY2Nlc3MgdGhlc2UgcHJvcGVydGllcyBkaXJlY3RseSwgc28gdGhleSBtdXN0IGJlXG4gIC8vIGluaGVyaXRlZCBtYW51YWxseSBpbnN0ZWFkIG9mIHZpYSB0aGUgcm9vdFxuICB0aGlzLl9ldmVudHMgPSBtb2RlbC5fZXZlbnRzO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBtb2RlbC5fbWF4TGlzdGVuZXJzO1xuXG4gIC8vIFByb3BlcnRpZXMgc3BlY2lmaWMgdG8gYSBjaGlsZCBpbnN0YW5jZVxuICB0aGlzLl9jb250ZXh0ID0gbW9kZWwuX2NvbnRleHQ7XG4gIHRoaXMuX2F0ID0gbW9kZWwuX2F0O1xuICB0aGlzLl9wYXNzID0gbW9kZWwuX3Bhc3M7XG4gIHRoaXMuX3NpbGVudCA9IG1vZGVsLl9zaWxlbnQ7XG59XG5DaGlsZE1vZGVsLnByb3RvdHlwZSA9IG5ldyBNb2RlbDtcbiIsIm1vZHVsZS5leHBvcnRzID0gRG9jO1xuXG5mdW5jdGlvbiBEb2MobW9kZWwsIGNvbGxlY3Rpb25OYW1lLCBpZCkge1xuICB0aGlzLmNvbGxlY3Rpb25OYW1lID0gY29sbGVjdGlvbk5hbWU7XG4gIHRoaXMuaWQgPSBpZDtcbiAgdGhpcy5jb2xsZWN0aW9uRGF0YSA9IG1vZGVsICYmIG1vZGVsLmRhdGFbY29sbGVjdGlvbk5hbWVdO1xufVxuXG5Eb2MucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbihzZWdtZW50cykge1xuICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uTmFtZSArICcuJyArIHRoaXMuaWQgKyAnLicgKyBzZWdtZW50cy5qb2luKCcuJyk7XG59O1xuXG5Eb2MucHJvdG90eXBlLl9lcnJvck1lc3NhZ2UgPSBmdW5jdGlvbihkZXNjcmlwdGlvbiwgc2VnbWVudHMsIHZhbHVlKSB7XG4gIHJldHVybiBkZXNjcmlwdGlvbiArICcgYXQgJyArIHRoaXMucGF0aChzZWdtZW50cykgKyAnOiAnICtcbiAgICBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgbnVsbCwgMik7XG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyk7XG52YXIgYXJyYXlEaWZmID0gcmVxdWlyZSgnYXJyYXlkaWZmJyk7XG5cbk1vZGVsLnByb3RvdHlwZS5zZXREaWZmID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWJwYXRoLCB2YWx1ZSwgb3B0aW9ucywgY2I7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFsdWUgPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgdmFsdWUgPSBhcmd1bWVudHNbMV07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgdmFsdWUgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gYXJndW1lbnRzWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0gYXJndW1lbnRzWzJdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzFdO1xuICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMl07XG4gICAgY2IgPSBhcmd1bWVudHNbM107XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fc2V0RGlmZihzZWdtZW50cywgdmFsdWUsIG9wdGlvbnMsIGNiKTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuX3NldERpZmYgPSBmdW5jdGlvbihzZWdtZW50cywgdmFsdWUsIG9wdGlvbnMsIGNiKSB7XG4gIHNlZ21lbnRzID0gdGhpcy5fZGVyZWZlcmVuY2Uoc2VnbWVudHMpO1xuICB2YXIgZXF1YWxGbiA9IChvcHRpb25zICYmIG9wdGlvbnMuZXF1YWwpIHx8IHV0aWwuZXF1YWw7XG4gIHZhciBpc0VhY2ggPSBvcHRpb25zICYmIG9wdGlvbnMuZWFjaDtcbiAgdmFyIG1vZGVsID0gdGhpcztcbiAgZnVuY3Rpb24gc2V0RGlmZihkb2MsIGRvY1NlZ21lbnRzLCBmbkNiKSB7XG4gICAgdmFyIGJlZm9yZSA9IGRvYy5nZXQoZG9jU2VnbWVudHMpO1xuICAgIGlmIChlcXVhbEZuKGJlZm9yZSwgdmFsdWUpKSByZXR1cm4gZm5DYigpO1xuICAgIHZhciBncm91cCA9IHV0aWwuYXN5bmNHcm91cChmbkNiKTtcbiAgICBkb0RpZmYobW9kZWwsIGRvYywgc2VnbWVudHMsIGJlZm9yZSwgdmFsdWUsIGVxdWFsRm4sIGdyb3VwLCBpc0VhY2gpO1xuICB9XG4gIHJldHVybiB0aGlzLl9tdXRhdGUoc2VnbWVudHMsIHNldERpZmYsIGNiKTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuX3NldEFycmF5RGlmZiA9IGZ1bmN0aW9uKHNlZ21lbnRzLCB2YWx1ZSwgY2IpIHtcbiAgc2VnbWVudHMgPSB0aGlzLl9kZXJlZmVyZW5jZShzZWdtZW50cyk7XG4gIHZhciBtb2RlbCA9IHRoaXM7XG4gIGZ1bmN0aW9uIHNldEFycmF5RGlmZihkb2MsIGRvY1NlZ21lbnRzLCBmbkNiKSB7XG4gICAgdmFyIGJlZm9yZSA9IGRvYy5nZXQoZG9jU2VnbWVudHMpO1xuICAgIGlmIChiZWZvcmUgPT09IHZhbHVlKSByZXR1cm4gZm5DYigpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShiZWZvcmUpIHx8ICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgYXBwbHlTZXQobW9kZWwsIGRvYywgc2VnbWVudHMsIHZhbHVlLCBmbkNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGRpZmYgPSBhcnJheURpZmYoYmVmb3JlLCB2YWx1ZSk7XG4gICAgaWYgKCFkaWZmLmxlbmd0aCkgcmV0dXJuIGZuQ2IoKTtcbiAgICB2YXIgZ3JvdXAgPSB1dGlsLmFzeW5jR3JvdXAoZm5DYik7XG4gICAgYXBwbHlBcnJheURpZmYobW9kZWwsIGRvYywgc2VnbWVudHMsIGRpZmYsIGdyb3VwKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fbXV0YXRlKHNlZ21lbnRzLCBzZXRBcnJheURpZmYsIGNiKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGRvY1xuICogQHBhcmFtIHtTdHJpbmd9IGRvYy5jb2xsZWN0aW9uTmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IGRvYy5pZFxuICogQHBhcmFtIHtPYmplY3R9IGRvYy5zbmFwc2hvdFxuICogQHBhcmFtIHtBcnJheX0gc2VnbWVudHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBiZWZvcmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBhZnRlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ3JvdXBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNFYWNoXG4gKi9cbmZ1bmN0aW9uIGRvRGlmZihtb2RlbCwgZG9jLCBzZWdtZW50cywgYmVmb3JlLCBhZnRlciwgZXF1YWxGbiwgZ3JvdXAsIGlzRWFjaCkge1xuICBpZiAodHlwZW9mIGJlZm9yZSAhPT0gJ29iamVjdCcgfHwgIWJlZm9yZSB8fFxuICAgICAgdHlwZW9mIGFmdGVyICE9PSAnb2JqZWN0JyB8fCAhYWZ0ZXIpIHtcbiAgICAvLyBTZXQgdGhlIGVudGlyZSB2YWx1ZSBpZiBub3QgZGlmZmFibGVcbiAgICBhcHBseVNldChtb2RlbCwgZG9jLCBzZWdtZW50cywgYWZ0ZXIsIGdyb3VwKCkpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShiZWZvcmUpICYmIEFycmF5LmlzQXJyYXkoYWZ0ZXIpKSB7XG4gICAgdmFyIGRpZmYgPSBhcnJheURpZmYoYmVmb3JlLCBhZnRlciwgZXF1YWxGbik7XG4gICAgaWYgKCFkaWZmLmxlbmd0aCkgcmV0dXJuIGdyb3VwKCkoKTtcbiAgICAvLyBJZiB0aGUgb25seSBjaGFuZ2UgaXMgYSBzaW5nbGUgaXRlbSByZXBsYWNlbWVudCwgZGlmZiB0aGUgaXRlbSBpbnN0ZWFkXG4gICAgaWYgKFxuICAgICAgZGlmZi5sZW5ndGggPT09IDIgJiZcbiAgICAgIGRpZmZbMF0uaW5kZXggPT09IGRpZmZbMV0uaW5kZXggJiZcbiAgICAgIGRpZmZbMF0gaW5zdGFuY2VvZiBhcnJheURpZmYuUmVtb3ZlRGlmZiAmJlxuICAgICAgZGlmZlswXS5ob3dNYW55ID09PSAxICYmXG4gICAgICBkaWZmWzFdIGluc3RhbmNlb2YgYXJyYXlEaWZmLkluc2VydERpZmYgJiZcbiAgICAgIGRpZmZbMV0udmFsdWVzLmxlbmd0aCA9PT0gMVxuICAgICkge1xuICAgICAgdmFyIGluZGV4ID0gZGlmZlswXS5pbmRleDtcbiAgICAgIHZhciBpdGVtU2VnbWVudHMgPSBzZWdtZW50cy5jb25jYXQoaW5kZXgpO1xuICAgICAgZG9EaWZmKG1vZGVsLCBkb2MsIGl0ZW1TZWdtZW50cywgYmVmb3JlW2luZGV4XSwgYWZ0ZXJbaW5kZXhdLCBlcXVhbEZuLCBncm91cCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFwcGx5QXJyYXlEaWZmKG1vZGVsLCBkb2MsIHNlZ21lbnRzLCBkaWZmLCBncm91cCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghaXNFYWNoKSB7XG4gICAgLy8gRGVsZXRlIGtleXMgdGhhdCB3ZXJlIGluIGJlZm9yZSBidXQgbm90IGFmdGVyXG4gICAgZm9yICh2YXIga2V5IGluIGJlZm9yZSkge1xuICAgICAgaWYgKGtleSBpbiBhZnRlcikgY29udGludWU7XG4gICAgICB2YXIgaXRlbVNlZ21lbnRzID0gc2VnbWVudHMuY29uY2F0KGtleSk7XG4gICAgICB2YXIgZG9jU2VnbWVudHMgPSBpdGVtU2VnbWVudHMuc2xpY2UoMik7XG4gICAgICB2YXIgcHJldmlvdXMgPSBkb2MuZGVsKGRvY1NlZ21lbnRzLCBncm91cCgpKTtcbiAgICAgIG1vZGVsLmVtaXQoJ2NoYW5nZScsIGl0ZW1TZWdtZW50cywgW3ZvaWQgMCwgcHJldmlvdXMsIG1vZGVsLl9wYXNzXSk7XG4gICAgfVxuICB9XG4gIC8vIERpZmYgZWFjaCBwcm9wZXJ0eSBpbiBhZnRlclxuICBmb3IgKHZhciBrZXkgaW4gYWZ0ZXIpIHtcbiAgICBpZiAoZXF1YWxGbihiZWZvcmVba2V5XSwgYWZ0ZXJba2V5XSkpIGNvbnRpbnVlO1xuICAgIHZhciBpdGVtU2VnbWVudHMgPSBzZWdtZW50cy5jb25jYXQoa2V5KTtcbiAgICBkb0RpZmYobW9kZWwsIGRvYywgaXRlbVNlZ21lbnRzLCBiZWZvcmVba2V5XSwgYWZ0ZXJba2V5XSwgZXF1YWxGbiwgZ3JvdXApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5U2V0KG1vZGVsLCBkb2MsIHNlZ21lbnRzLCBhZnRlciwgY2IpIHtcbiAgdmFyIGRvY1NlZ21lbnRzID0gc2VnbWVudHMuc2xpY2UoMik7XG4gIHZhciBwcmV2aW91cyA9IGRvYy5zZXQoZG9jU2VnbWVudHMsIGFmdGVyLCBjYik7XG4gIG1vZGVsLmVtaXQoJ2NoYW5nZScsIHNlZ21lbnRzLCBbYWZ0ZXIsIHByZXZpb3VzLCBtb2RlbC5fcGFzc10pO1xufVxuXG5mdW5jdGlvbiBhcHBseUFycmF5RGlmZihtb2RlbCwgZG9jLCBzZWdtZW50cywgZGlmZiwgZ3JvdXApIHtcbiAgdmFyIGRvY1NlZ21lbnRzID0gc2VnbWVudHMuc2xpY2UoMik7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkaWZmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBkaWZmW2ldO1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgYXJyYXlEaWZmLkluc2VydERpZmYpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgZG9jLmluc2VydChkb2NTZWdtZW50cywgaXRlbS5pbmRleCwgaXRlbS52YWx1ZXMsIGdyb3VwKCkpO1xuICAgICAgbW9kZWwuZW1pdCgnaW5zZXJ0Jywgc2VnbWVudHMsIFtpdGVtLmluZGV4LCBpdGVtLnZhbHVlcywgbW9kZWwuX3Bhc3NdKTtcbiAgICB9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBhcnJheURpZmYuUmVtb3ZlRGlmZikge1xuICAgICAgLy8gUmVtb3ZlXG4gICAgICB2YXIgcmVtb3ZlZCA9IGRvYy5yZW1vdmUoZG9jU2VnbWVudHMsIGl0ZW0uaW5kZXgsIGl0ZW0uaG93TWFueSwgZ3JvdXAoKSk7XG4gICAgICBtb2RlbC5lbWl0KCdyZW1vdmUnLCBzZWdtZW50cywgW2l0ZW0uaW5kZXgsIHJlbW92ZWQsIG1vZGVsLl9wYXNzXSk7XG4gICAgfSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgYXJyYXlEaWZmLk1vdmVEaWZmKSB7XG4gICAgICAvLyBNb3ZlXG4gICAgICB2YXIgbW92ZWQgPSBkb2MubW92ZShkb2NTZWdtZW50cywgaXRlbS5mcm9tLCBpdGVtLnRvLCBpdGVtLmhvd01hbnksIGdyb3VwKCkpO1xuICAgICAgbW9kZWwuZW1pdCgnbW92ZScsIHNlZ21lbnRzLCBbaXRlbS5mcm9tLCBpdGVtLnRvLCBtb3ZlZC5sZW5ndGgsIG1vZGVsLl9wYXNzXSk7XG4gICAgfVxuICB9XG59XG4iLCIoZnVuY3Rpb24ocHJvY2Vzcyl7dmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyk7XG52YXIgYXJyYXlEaWZmID0gcmVxdWlyZSgnYXJyYXlkaWZmJyk7XG52YXIgZGVlcEVxdWFscyA9IHJlcXVpcmUoJ2RlZXAtaXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBRdWVyeTtcblxuTW9kZWwuSU5JVFMucHVzaChmdW5jdGlvbihtb2RlbCkge1xuICBtb2RlbC5yb290Ll9xdWVyaWVzID0gbmV3IFF1ZXJpZXM7XG4gIGlmIChtb2RlbC5yb290LmZldGNoT25seSkgcmV0dXJuO1xuICBtb2RlbC5vbignYWxsJywgZnVuY3Rpb24oc2VnbWVudHMpIHtcbiAgICAvLyBVcGRhdGVkIGFzeW5jLCBzaW5jZSB0aGlzIGlzIGxpa2VseSB0aGUgcmVzdWx0IG9mIGFuIG9wZXJhdGlvbiB0aGF0XG4gICAgLy8gaW5jbHVkZXMgY3JlYXRpbmcgdGhlIGRvYywgYW5kIHdlIHdvdWxkIGxpa2UgdGhhdCB0byBoYXBwZW4gYmVmb3JlXG4gICAgLy8gc2VuZGluZyB0aGUgc3Vic2NyaWJlIG1lc3NhZ2VcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG1hcCA9IG1vZGVsLnJvb3QuX3F1ZXJpZXMubWFwO1xuICAgICAgZm9yICh2YXIgaGFzaCBpbiBtYXApIHtcbiAgICAgICAgdmFyIHF1ZXJ5ID0gbWFwW2hhc2hdO1xuICAgICAgICBpZiAocXVlcnkuaXNQYXRoUXVlcnkgJiYgcXVlcnkuc2hhcmVRdWVyeSAmJiB1dGlsLm1heUltcGFjdChxdWVyeS5leHByZXNzaW9uLCBzZWdtZW50cykpIHtcbiAgICAgICAgICB2YXIgaWRzID0gcGF0aElkcyhtb2RlbCwgcXVlcnkuZXhwcmVzc2lvbik7XG4gICAgICAgICAgdmFyIHByZXZpb3VzSWRzID0gbW9kZWwuX2dldChxdWVyeS5pZFNlZ21lbnRzKTtcbiAgICAgICAgICBxdWVyeS5fb25DaGFuZ2UoaWRzLCBwcmV2aW91c0lkcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sbGVjdGlvbk5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHByZXNzaW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gc291cmNlXG4gKiBAcmV0dXJuIHtRdWVyeX1cbiAqL1xuTW9kZWwucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24oY29sbGVjdGlvbk5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZSkge1xuICBpZiAodHlwZW9mIGV4cHJlc3Npb24ucGF0aCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZXhwcmVzc2lvbiAhPT0gJ29iamVjdCcpIHtcbiAgICBleHByZXNzaW9uID0gdGhpcy5fc3BsaXRQYXRoKGV4cHJlc3Npb24pO1xuICB9XG4gIHZhciBxdWVyeSA9IHRoaXMucm9vdC5fcXVlcmllcy5nZXQoY29sbGVjdGlvbk5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZSk7XG4gIGlmIChxdWVyeSkgcmV0dXJuIHF1ZXJ5O1xuICBxdWVyeSA9IG5ldyBRdWVyeSh0aGlzLCBjb2xsZWN0aW9uTmFtZSwgZXhwcmVzc2lvbiwgc291cmNlKTtcbiAgdGhpcy5yb290Ll9xdWVyaWVzLmFkZChxdWVyeSk7XG4gIHJldHVybiBxdWVyeTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIGR1cmluZyBpbml0aWFsaXphdGlvbiBvZiB0aGUgYnVuZGxlIG9uIHBhZ2UgbG9hZC5cbiAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zXG4gKiBAcGFyYW0ge0FycmF5fSBpdGVtc1sqXVxuICogQHBhcmFtIHtTdHJpbmd9IGl0ZW1zWypdWzBdIGNvbGxlY3Rpb25OYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gaXRlbXNbKl1bMV0gZXhwcmVzc2lvblxuICogQHBhcmFtIHtTdHJpbmd9IGl0ZW1zWypdWzJdIHNvdXJjZVxuICogQHBhcmFtIHtOdW1iZXJ9IGl0ZW1zWypdWzNdIHN1YnNjcmliZUNvdW50XG4gKiBAcGFyYW0ge051bWJlcn0gaXRlbXNbKl1bNF0gZmV0Y2hDb3VudFxuICogQHBhcmFtIHtBcnJheX0gIGl0ZW1zWypdWzVdIGZldGNoSWRzXG4gKi9cbk1vZGVsLnByb3RvdHlwZS5faW5pdFF1ZXJpZXMgPSBmdW5jdGlvbihpdGVtcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICB2YXIgcXVlcnkgPSBuZXcgUXVlcnkodGhpcywgaXRlbVswXSwgaXRlbVsxXSwgaXRlbVsyXSwgaXRlbVszXSwgaXRlbVs0XSwgaXRlbVs1XSk7XG4gICAgdmFyIGNvdW50ID0gcXVlcnkuZmV0Y2hDb3VudDtcbiAgICB3aGlsZSAoY291bnQtLSkgdGhpcy5lbWl0KCdmZXRjaFF1ZXJ5JywgcXVlcnksIHRoaXMuX2NvbnRleHQpO1xuICAgIHZhciBjb3VudCA9IHF1ZXJ5LnN1YnNjcmliZUNvdW50O1xuICAgIHF1ZXJ5LnN1YnNjcmliZUNvdW50ID0gMDtcbiAgICB3aGlsZSAoY291bnQtLSkgcXVlcnkuc3Vic2NyaWJlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFF1ZXJpZXNNYXAoKSB7fVxuXG5mdW5jdGlvbiBRdWVyaWVzKCkge1xuICB0aGlzLm1hcCA9IG5ldyBRdWVyaWVzTWFwO1xufVxuUXVlcmllcy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ocXVlcnkpIHtcbiAgdGhpcy5tYXBbcXVlcnkuaGFzaF0gPSBxdWVyeTtcbn07XG5RdWVyaWVzLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihxdWVyeSkge1xuICBkZWxldGUgdGhpcy5tYXBbcXVlcnkuaGFzaF07XG59O1xuUXVlcmllcy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oY29sbGVjdGlvbk5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZSkge1xuICB2YXIgaGFzaCA9IHF1ZXJ5SGFzaChjb2xsZWN0aW9uTmFtZSwgZXhwcmVzc2lvbiwgc291cmNlKTtcbiAgcmV0dXJuIHRoaXMubWFwW2hhc2hdO1xufTtcblF1ZXJpZXMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3V0ID0gW107XG4gIGZvciAodmFyIGhhc2ggaW4gdGhpcy5tYXApIHtcbiAgICB2YXIgcXVlcnkgPSB0aGlzLm1hcFtoYXNoXTtcbiAgICBpZiAocXVlcnkuc3Vic2NyaWJlQ291bnQgfHwgcXVlcnkuZmV0Y2hDb3VudCkge1xuICAgICAgb3V0LnB1c2gocXVlcnkuc2VyaWFsaXplKCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge01vZGVsfSBtb2RlbFxuICogQHBhcmFtIHtPYmplY3R9IGNvbGxlY3Rpb25OYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gZXhwcmVzc2lvblxuICogQHBhcmFtIHtTdHJpbmd9IHNvdXJjZSAoZS5nLiwgJ3NvbHInKVxuICogQHBhcmFtIHtOdW1iZXJ9IHN1YnNjcmliZUNvdW50XG4gKiBAcGFyYW0ge051bWJlcn0gZmV0Y2hDb3VudFxuICogQHBhcmFtIHtBcnJheTxBcnJheTxTdHJpbmc+Pn0gZmV0Y2hJZHNcbiAqL1xuZnVuY3Rpb24gUXVlcnkobW9kZWwsIGNvbGxlY3Rpb25OYW1lLCBleHByZXNzaW9uLCBzb3VyY2UsIHN1YnNjcmliZUNvdW50LCBmZXRjaENvdW50LCBmZXRjaElkcykge1xuICB0aGlzLm1vZGVsID0gbW9kZWwucGFzcyh7JHF1ZXJ5OiB0aGlzfSk7XG4gIHRoaXMuY29sbGVjdGlvbk5hbWUgPSBjb2xsZWN0aW9uTmFtZTtcbiAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gIHRoaXMuaGFzaCA9IHF1ZXJ5SGFzaChjb2xsZWN0aW9uTmFtZSwgZXhwcmVzc2lvbiwgc291cmNlKTtcbiAgdGhpcy5zZWdtZW50cyA9IFsnJHF1ZXJpZXMnLCB0aGlzLmhhc2hdO1xuICB0aGlzLmlkU2VnbWVudHMgPSBbJyRxdWVyaWVzJywgdGhpcy5oYXNoLCAnaWRzJ107XG4gIHRoaXMuZXh0cmFTZWdtZW50cyA9IFsnJHF1ZXJpZXMnLCB0aGlzLmhhc2gsICdleHRyYSddO1xuICB0aGlzLmlzUGF0aFF1ZXJ5ID0gQXJyYXkuaXNBcnJheShleHByZXNzaW9uKTtcblxuICB0aGlzLl9wZW5kaW5nU3Vic2NyaWJlQ2FsbGJhY2tzID0gW107XG5cbiAgLy8gVGhlc2UgYXJlIHVzZWQgdG8gaGVscCBjbGVhbnVwIGFwcHJvcHJpYXRlbHkgd2hlbiBjYWxsaW5nIHVuc3Vic2NyaWJlIGFuZFxuICAvLyB1bmZldGNoLiBBIHF1ZXJ5IHdvbid0IGJlIGZ1bGx5IGNsZWFuZWQgdXAgdW50aWwgdW5mZXRjaCBhbmQgdW5zdWJzY3JpYmVcbiAgLy8gYXJlIGNhbGxlZCB0aGUgc2FtZSBudW1iZXIgb2YgdGltZXMgdGhhdCBmZXRjaCBhbmQgc3Vic2NyaWJlIHdlcmUgY2FsbGVkLlxuICB0aGlzLnN1YnNjcmliZUNvdW50ID0gc3Vic2NyaWJlQ291bnQgfHwgMDtcbiAgdGhpcy5mZXRjaENvdW50ID0gZmV0Y2hDb3VudCB8fCAwO1xuICAvLyBUaGUgbGlzdCBvZiBpZHMgYXQgdGhlIHRpbWUgb2YgZWFjaCBmZXRjaCBpcyBwdXNoZWQgb250byBmZXRjaElkcywgc29cbiAgLy8gdGhhdCB1bmZldGNoRG9jIGNhbiBiZSBjYWxsZWQgdGhlIHNhbWUgbnVtYmVyIG9mIHRpbWVzIGFzIGZldGNoRG9jXG4gIHRoaXMuZmV0Y2hJZHMgPSBmZXRjaElkcyB8fCBbXTtcblxuICB0aGlzLmNyZWF0ZWQgPSBmYWxzZTtcbiAgdGhpcy5zaGFyZVF1ZXJ5ID0gbnVsbDtcbn1cblxuUXVlcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNyZWF0ZWQgPSB0cnVlO1xuICB0aGlzLm1vZGVsLnJvb3QuX3F1ZXJpZXMuYWRkKHRoaXMpO1xufTtcblxuUXVlcnkucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jcmVhdGVkID0gZmFsc2U7XG4gIGlmICh0aGlzLnNoYXJlUXVlcnkpIHtcbiAgICB0aGlzLnNoYXJlUXVlcnkuZGVzdHJveSgpO1xuICAgIHRoaXMuc2hhcmVRdWVyeSA9IG51bGw7XG4gIH1cbiAgdGhpcy5tb2RlbC5yb290Ll9xdWVyaWVzLnJlbW92ZSh0aGlzKTtcbiAgdGhpcy5tb2RlbC5fZGVsKHRoaXMuc2VnbWVudHMpO1xufTtcblxuUXVlcnkucHJvdG90eXBlLnNvdXJjZVF1ZXJ5ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlzUGF0aFF1ZXJ5KSB7XG4gICAgdmFyIGlkcyA9IHBhdGhJZHModGhpcy5tb2RlbCwgdGhpcy5leHByZXNzaW9uKTtcbiAgICByZXR1cm4ge19pZDogeyRpbjogaWRzfX07XG4gIH1cbiAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbjtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBjYihlcnIpXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uKGNiKSB7XG4gIGlmICghY2IpIGNiID0gdGhpcy5tb2RlbC5yb290Ll9kZWZhdWx0Q2FsbGJhY2s7XG4gIHRoaXMubW9kZWwuZW1pdCgnZmV0Y2hRdWVyeScsIHRoaXMsIHRoaXMubW9kZWwuX2NvbnRleHQpO1xuXG4gIHRoaXMuZmV0Y2hDb3VudCsrO1xuXG4gIGlmICghdGhpcy5jcmVhdGVkKSB0aGlzLmNyZWF0ZSgpO1xuICB2YXIgcXVlcnkgPSB0aGlzO1xuXG4gIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gIHZhciBzaGFyZURvY3MgPSBjb2xsZWN0aW9uU2hhcmVEb2NzKHRoaXMubW9kZWwsIHRoaXMuY29sbGVjdGlvbk5hbWUpO1xuICB2YXIgb3B0aW9ucyA9IHtkb2NNb2RlOiAnZmV0Y2gnLCBrbm93bkRvY3M6IHNoYXJlRG9jc307XG4gIGlmICh0aGlzLnNvdXJjZSkgb3B0aW9ucy5zb3VyY2UgPSB0aGlzLnNvdXJjZTtcblxuICBtb2RlbC5yb290LnNoYXJlQ29ubmVjdGlvbi5jcmVhdGVGZXRjaFF1ZXJ5KFxuICAgIHRoaXMuY29sbGVjdGlvbk5hbWUsIHRoaXMuc291cmNlUXVlcnkoKSwgb3B0aW9ucywgZmV0Y2hRdWVyeUNhbGxiYWNrXG4gICk7XG4gIGZ1bmN0aW9uIGZldGNoUXVlcnlDYWxsYmFjayhlcnIsIHJlc3VsdHMsIGV4dHJhKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgdmFyIGlkcyA9IHJlc3VsdHNJZHMocmVzdWx0cyk7XG5cbiAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBpZHMgYXQgZmV0Y2ggdGltZSBmb3IgdXNlIGluIHVuZmV0Y2hcbiAgICBxdWVyeS5mZXRjaElkcy5wdXNoKGlkcy5zbGljZSgpKTtcbiAgICAvLyBVcGRhdGUgdGhlIHJlc3VsdHMgaWRzIGFuZCBleHRyYVxuICAgIG1vZGVsLl9zZXREaWZmKHF1ZXJ5LmlkU2VnbWVudHMsIGlkcyk7XG4gICAgaWYgKGV4dHJhICE9PSB2b2lkIDApIHtcbiAgICAgIG1vZGVsLl9zZXREaWZmKHF1ZXJ5LmV4dHJhU2VnbWVudHMsIGV4dHJhLCB7ZXF1YWw6IGRlZXBFcXVhbHN9KTtcbiAgICB9XG5cbiAgICBpZiAoIWlkcy5sZW5ndGgpIHJldHVybiBjYigpO1xuXG4gICAgLy8gQ2FsbCBmZXRjaERvYyBmb3IgZWFjaCBkb2N1bWVudCByZXR1cm5lZCBzbyB0aGF0IHRoZSBwcm9wZXIgbG9hZCBldmVudHNcbiAgICAvLyBhbmQgaW50ZXJuYWwgY291bnRzIGFyZSBtYWludGFpbmVkLiBIb3dldmVyLCBzcGVjaWZ5IHRoYXQgd2UgYWxyZWFkeVxuICAgIC8vIGxvYWRlZCB0aGUgZG9jdW1lbnRzIGFzIHBhcnQgb2YgdGhlIHF1ZXJ5LCBzaW5jZSB3ZSBkb24ndCB3YW50IHRvXG4gICAgLy8gYWN0dWFsbHkgZmV0Y2ggdGhlIGRvY3VtZW50cyBhZ2FpblxuICAgIHZhciBhbHJlYWR5TG9hZGVkID0gdHJ1ZTtcbiAgICB2YXIgZ3JvdXAgPSB1dGlsLmFzeW5jR3JvdXAoY2IpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBtb2RlbC5mZXRjaERvYyhxdWVyeS5jb2xsZWN0aW9uTmFtZSwgaWRzW2ldLCBncm91cCgpLCBhbHJlYWR5TG9hZGVkKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdXAgYSBzdWJzY3JpcHRpb24gdG8gYHRoaXNgIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2IoZXJyKVxuICovXG5RdWVyeS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24oY2IpIHtcbiAgaWYgKCFjYikgY2IgPSB0aGlzLm1vZGVsLnJvb3QuX2RlZmF1bHRDYWxsYmFjaztcbiAgdGhpcy5tb2RlbC5lbWl0KCdzdWJzY3JpYmVRdWVyeScsIHRoaXMsIHRoaXMubW9kZWwuX2NvbnRleHQpO1xuXG4gIHZhciBxdWVyeSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuc3Vic2NyaWJlQ291bnQrKykge1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGRhdGEgPSBxdWVyeS5tb2RlbC5fZ2V0KHF1ZXJ5LnNlZ21lbnRzKTtcbiAgICAgIGlmIChkYXRhKSBjYigpO1xuICAgICAgZWxzZSBxdWVyeS5fcGVuZGluZ1N1YnNjcmliZUNhbGxiYWNrcy5wdXNoKGNiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmICghdGhpcy5jcmVhdGVkKSB0aGlzLmNyZWF0ZSgpO1xuXG4gIC8vIFdoZW4gZG9pbmcgc2VydmVyLXNpZGUgcmVuZGVyaW5nLCB3ZSBhY3R1YWxseSBkbyBhIGZldGNoIHRoZSBmaXJzdCB0aW1lXG4gIC8vIHRoYXQgc3Vic2NyaWJlIGlzIGNhbGxlZCwgYnV0IGtlZXAgdHJhY2sgb2YgdGhlIHN0YXRlIGFzIGlmIHN1YnNjcmliZVxuICAvLyB3ZXJlIGNhbGxlZCBmb3IgcHJvcGVyIGluaXRpYWxpemF0aW9uIGluIHRoZSBjbGllbnRcbiAgdmFyIHNoYXJlRG9jcyA9IGNvbGxlY3Rpb25TaGFyZURvY3ModGhpcy5tb2RlbCwgdGhpcy5jb2xsZWN0aW9uTmFtZSk7XG4gIHZhciBvcHRpb25zID0ge2RvY01vZGU6ICdzdWInLCBrbm93bkRvY3M6IHNoYXJlRG9jc307XG4gIGlmICh0aGlzLnNvdXJjZSkgb3B0aW9ucy5zb3VyY2UgPSB0aGlzLnNvdXJjZTtcblxuICBpZiAoIXRoaXMubW9kZWwucm9vdC5mZXRjaE9ubHkpIHtcbiAgICB0aGlzLl9zaGFyZVN1YnNjcmliZShvcHRpb25zLCBjYik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICBvcHRpb25zLmRvY01vZGUgPSAnZmV0Y2gnO1xuICBtb2RlbC5yb290LnNoYXJlQ29ubmVjdGlvbi5jcmVhdGVGZXRjaFF1ZXJ5KFxuICAgIHRoaXMuY29sbGVjdGlvbk5hbWUsIHRoaXMuc291cmNlUXVlcnkoKSwgb3B0aW9ucywgZnVuY3Rpb24oZXJyLCByZXN1bHRzLCBleHRyYSkge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgICB2YXIgaWRzID0gcmVzdWx0c0lkcyhyZXN1bHRzKTtcbiAgICAgIGlmIChleHRyYSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIG1vZGVsLl9zZXREaWZmKHF1ZXJ5LmV4dHJhU2VnbWVudHMsIGV4dHJhLCB7ZXF1YWw6IGRlZXBFcXVhbHN9KTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5Ll9vbkNoYW5nZShpZHMsIG51bGwsIGNiKTtcbiAgICAgIHdoaWxlIChjYiA9IHF1ZXJ5Ll9wZW5kaW5nU3Vic2NyaWJlQ2FsbGJhY2tzLnNoaWZ0KCkpIHtcbiAgICAgICAgcXVlcnkuX29uQ2hhbmdlKGlkcywgbnVsbCwgY2IpO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnNvdXJjZV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucG9sbF1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZG9jTW9kZSA9IGZldGNoIG9yIHN1YnNjcmliZV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiKGVyciwgcmVzdWx0cylcbiAqL1xuUXVlcnkucHJvdG90eXBlLl9zaGFyZVN1YnNjcmliZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNiKSB7XG4gIHZhciBxdWVyeSA9IHRoaXM7XG4gIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gIHRoaXMuc2hhcmVRdWVyeSA9IHRoaXMubW9kZWwucm9vdC5zaGFyZUNvbm5lY3Rpb24uY3JlYXRlU3Vic2NyaWJlUXVlcnkoXG4gICAgdGhpcy5jb2xsZWN0aW9uTmFtZSwgdGhpcy5zb3VyY2VRdWVyeSgpLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyLCByZXN1bHRzLCBleHRyYSkge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgICBpZiAoZXh0cmEgIT09IHZvaWQgMCkge1xuICAgICAgICBtb2RlbC5fc2V0RGlmZihxdWVyeS5leHRyYVNlZ21lbnRzLCBleHRyYSwge2VxdWFsOiBkZWVwRXF1YWxzfSk7XG4gICAgICB9XG4gICAgICAvLyBSZXN1bHRzIGFyZSBub3Qgc2V0IGluIHRoZSBjYWxsYmFjaywgYmVjYXVzZSB0aGUgc2hhcmVRdWVyeSBzaG91bGRcbiAgICAgIC8vIGVtaXQgYSAnY2hhbmdlJyBldmVudCBiZWZvcmUgY2FsbGluZyBiYWNrXG4gICAgICBjYigpO1xuICAgIH1cbiAgKTtcbiAgdmFyIHF1ZXJ5ID0gdGhpcztcbiAgdGhpcy5zaGFyZVF1ZXJ5Lm9uKCdpbnNlcnQnLCBmdW5jdGlvbihzaGFyZURvY3MsIGluZGV4KSB7XG4gICAgcXVlcnkuX29uSW5zZXJ0KHNoYXJlRG9jcywgaW5kZXgpO1xuICB9KTtcbiAgdGhpcy5zaGFyZVF1ZXJ5Lm9uKCdyZW1vdmUnLCBmdW5jdGlvbihzaGFyZURvY3MsIGluZGV4KSB7XG4gICAgcXVlcnkuX29uUmVtb3ZlKHNoYXJlRG9jcywgaW5kZXgpO1xuICB9KTtcbiAgdGhpcy5zaGFyZVF1ZXJ5Lm9uKCdtb3ZlJywgZnVuY3Rpb24oc2hhcmVEb2NzLCBmcm9tLCB0bykge1xuICAgIHF1ZXJ5Ll9vbk1vdmUoc2hhcmVEb2NzLCBmcm9tLCB0byk7XG4gIH0pO1xuICB0aGlzLnNoYXJlUXVlcnkub24oJ2NoYW5nZScsIGZ1bmN0aW9uKHJlc3VsdHMsIHByZXZpb3VzKSB7XG4gICAgLy8gR2V0IHRoZSBuZXcgYW5kIHByZXZpb3VzIGxpc3Qgb2YgaWRzIHdoZW4gdGhlIGVudGlyZSByZXN1bHRzIHNldCBjaGFuZ2VzXG4gICAgdmFyIGlkcyA9IHJlc3VsdHNJZHMocmVzdWx0cyk7XG4gICAgdmFyIHByZXZpb3VzSWRzID0gcHJldmlvdXMgJiYgcmVzdWx0c0lkcyhwcmV2aW91cyk7XG4gICAgcXVlcnkuX29uQ2hhbmdlKGlkcywgcHJldmlvdXNJZHMpO1xuICB9KTtcbiAgdGhpcy5zaGFyZVF1ZXJ5Lm9uKCdleHRyYScsIGZ1bmN0aW9uIChleHRyYSkge1xuICAgIG1vZGVsLl9zZXREaWZmKHF1ZXJ5LmV4dHJhU2VnbWVudHMsIGV4dHJhLCB7ZXF1YWw6IGRlZXBFcXVhbHN9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiKGVyciwgbmV3RmV0Y2hDb3VudClcbiAqL1xuUXVlcnkucHJvdG90eXBlLnVuZmV0Y2ggPSBmdW5jdGlvbihjYikge1xuICBpZiAoIWNiKSBjYiA9IHRoaXMubW9kZWwucm9vdC5fZGVmYXVsdENhbGxiYWNrO1xuICB0aGlzLm1vZGVsLmVtaXQoJ3VuZmV0Y2hRdWVyeScsIHRoaXMsIHRoaXMubW9kZWwuX2NvbnRleHQpO1xuXG4gIC8vIE5vIGVmZmVjdCBpZiB0aGUgcXVlcnkgaXMgbm90IGN1cnJlbnRseSBmZXRjaGVkXG4gIGlmICghdGhpcy5mZXRjaENvdW50KSB7XG4gICAgY2IoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBpZHMgPSB0aGlzLmZldGNoSWRzLnNoaWZ0KCkgfHwgW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5tb2RlbC51bmZldGNoRG9jKHRoaXMuY29sbGVjdGlvbk5hbWUsIGlkc1tpXSk7XG4gIH1cblxuICB2YXIgcXVlcnkgPSB0aGlzO1xuICBpZiAodGhpcy5tb2RlbC5yb290LnVubG9hZERlbGF5KSB7XG4gICAgc2V0VGltZW91dChmaW5pc2hVbmZldGNoUXVlcnksIHRoaXMubW9kZWwucm9vdC51bmxvYWREZWxheSk7XG4gIH0gZWxzZSB7XG4gICAgZmluaXNoVW5mZXRjaFF1ZXJ5KCk7XG4gIH1cbiAgZnVuY3Rpb24gZmluaXNoVW5mZXRjaFF1ZXJ5KCkge1xuICAgIHZhciBjb3VudCA9IC0tcXVlcnkuZmV0Y2hDb3VudDtcbiAgICBpZiAoY291bnQpIHJldHVybiBjYihudWxsLCBjb3VudCk7XG4gICAgLy8gQ2xlYW51cCB3aGVuIG5vIGZldGNoZXMgb3Igc3Vic2NyaWJlcyByZW1haW5cbiAgICBpZiAoIXF1ZXJ5LnN1YnNjcmliZUNvdW50KSBxdWVyeS5kZXN0cm95KCk7XG4gICAgY2IobnVsbCwgMCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5RdWVyeS5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbihjYikge1xuICBpZiAoIWNiKSBjYiA9IHRoaXMubW9kZWwucm9vdC5fZGVmYXVsdENhbGxiYWNrO1xuICB0aGlzLm1vZGVsLmVtaXQoJ3Vuc3Vic2NyaWJlUXVlcnknLCB0aGlzLCB0aGlzLm1vZGVsLl9jb250ZXh0KTtcblxuICAvLyBObyBlZmZlY3QgaWYgdGhlIHF1ZXJ5IGlzIG5vdCBjdXJyZW50bHkgc3Vic2NyaWJlZFxuICBpZiAoIXRoaXMuc3Vic2NyaWJlQ291bnQpIHtcbiAgICBjYigpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIHF1ZXJ5ID0gdGhpcztcbiAgaWYgKHRoaXMubW9kZWwucm9vdC51bmxvYWREZWxheSkge1xuICAgIHNldFRpbWVvdXQoZmluaXNoVW5zdWJzY3JpYmVRdWVyeSwgdGhpcy5tb2RlbC5yb290LnVubG9hZERlbGF5KTtcbiAgfSBlbHNlIHtcbiAgICBmaW5pc2hVbnN1YnNjcmliZVF1ZXJ5KCk7XG4gIH1cbiAgZnVuY3Rpb24gZmluaXNoVW5zdWJzY3JpYmVRdWVyeSgpIHtcbiAgICB2YXIgY291bnQgPSAtLXF1ZXJ5LnN1YnNjcmliZUNvdW50O1xuICAgIGlmIChjb3VudCkgcmV0dXJuIGNiKG51bGwsIGNvdW50KTtcblxuICAgIGlmIChxdWVyeS5zaGFyZVF1ZXJ5KSB7XG4gICAgICB2YXIgaWRzID0gcmVzdWx0c0lkcyhxdWVyeS5zaGFyZVF1ZXJ5LnJlc3VsdHMpO1xuICAgICAgcXVlcnkuc2hhcmVRdWVyeS5kZXN0cm95KCk7XG4gICAgICBxdWVyeS5zaGFyZVF1ZXJ5ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIXF1ZXJ5Lm1vZGVsLnJvb3QuZmV0Y2hPbmx5ICYmIGlkcyAmJiBpZHMubGVuZ3RoKSB7XG4gICAgICAvLyBVbnN1YnNjcmliZSBhbGwgZG9jdW1lbnRzIHRoYXQgdGhpcyBxdWVyeSBjdXJyZW50bHkgaGFzIGluIHJlc3VsdHNcbiAgICAgIHZhciBncm91cCA9IHV0aWwuYXN5bmNHcm91cCh1bnN1YnNjcmliZVF1ZXJ5Q2FsbGJhY2spO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcXVlcnkubW9kZWwudW5zdWJzY3JpYmVEb2MocXVlcnkuY29sbGVjdGlvbk5hbWUsIGlkc1tpXSwgZ3JvdXAoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlUXVlcnlDYWxsYmFjaygpO1xuICB9XG4gIGZ1bmN0aW9uIHVuc3Vic2NyaWJlUXVlcnlDYWxsYmFjayhlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcbiAgICAvLyBDbGVhbnVwIHdoZW4gbm8gZmV0Y2hlcyBvciBzdWJzY3JpYmVzIHJlbWFpblxuICAgIGlmICghcXVlcnkuZmV0Y2hDb3VudCkgcXVlcnkuZGVzdHJveSgpO1xuICAgIGNiKG51bGwsIDApO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuUXVlcnkucHJvdG90eXBlLl9vbkluc2VydCA9IGZ1bmN0aW9uKHNoYXJlRG9jcywgaW5kZXgpIHtcbiAgdmFyIGlkcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNoYXJlRG9jcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpZCA9IHNoYXJlRG9jc1tpXS5uYW1lO1xuICAgIGlkcy5wdXNoKGlkKTtcbiAgICB0aGlzLm1vZGVsLnN1YnNjcmliZURvYyh0aGlzLmNvbGxlY3Rpb25OYW1lLCBpZCk7XG4gIH1cbiAgdGhpcy5tb2RlbC5faW5zZXJ0KHRoaXMuaWRTZWdtZW50cywgaW5kZXgsIGlkcyk7XG59O1xuUXVlcnkucHJvdG90eXBlLl9vblJlbW92ZSA9IGZ1bmN0aW9uKHNoYXJlRG9jcywgaW5kZXgpIHtcbiAgdGhpcy5tb2RlbC5fcmVtb3ZlKHRoaXMuaWRTZWdtZW50cywgaW5kZXgsIHNoYXJlRG9jcy5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNoYXJlRG9jcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMubW9kZWwudW5zdWJzY3JpYmVEb2ModGhpcy5jb2xsZWN0aW9uTmFtZSwgc2hhcmVEb2NzW2ldLm5hbWUpO1xuICB9XG59O1xuUXVlcnkucHJvdG90eXBlLl9vbk1vdmUgPSBmdW5jdGlvbihzaGFyZURvY3MsIGZyb20sIHRvKSB7XG4gIHRoaXMubW9kZWwuX21vdmUodGhpcy5pZFNlZ21lbnRzLCBmcm9tLCB0bywgc2hhcmVEb2NzLmxlbmd0aCk7XG59O1xuXG5RdWVyeS5wcm90b3R5cGUuX29uQ2hhbmdlID0gZnVuY3Rpb24oaWRzLCBwcmV2aW91c0lkcywgY2IpIHtcbiAgLy8gRGlmZiB0aGUgbmV3IGFuZCBwcmV2aW91cyBsaXN0IG9mIGlkcywgc3Vic2NyaWJpbmcgdG8gZG9jdW1lbnRzIGZvclxuICAvLyBpbnNlcnRlZCBpZHMgYW5kIHVuc3Vic2NyaWJpbmcgZnJvbSBkb2N1bWVudHMgZm9yIHJlbW92ZWQgaWRzXG4gIHZhciBkaWZmID0gKHByZXZpb3VzSWRzKSA/XG4gICAgYXJyYXlEaWZmKHByZXZpb3VzSWRzLCBpZHMpIDpcbiAgICBbbmV3IGFycmF5RGlmZi5JbnNlcnREaWZmKDAsIGlkcyldO1xuICB2YXIgcHJldmlvdXNDb3B5ID0gcHJldmlvdXNJZHMgJiYgcHJldmlvdXNJZHMuc2xpY2UoKTtcblxuICAvLyBUaGUgcmVzdWx0cyBhcmUgdXBkYXRlZCB2aWEgYSBkaWZmZXJlbnQgZGlmZiwgc2luY2UgdGhleSBtaWdodCBhbHJlYWR5XG4gIC8vIGhhdmUgYSB2YWx1ZSBmcm9tIGEgZmV0Y2ggb3IgcHJldmlvdXMgc2hhcmVRdWVyeSBpbnN0YW5jZVxuICB0aGlzLm1vZGVsLl9zZXREaWZmKHRoaXMuaWRTZWdtZW50cywgaWRzKTtcblxuICBpZiAoY2IpIHtcbiAgICB2YXIgZ3JvdXAgPSB1dGlsLmFzeW5jR3JvdXAoY2IpO1xuICAgIHZhciBmaW5pc2hlZCA9IGdyb3VwKCk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWZmLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBkaWZmW2ldO1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgYXJyYXlEaWZmLkluc2VydERpZmYpIHtcbiAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgZG9jdW1lbnQgZm9yIGVhY2ggaW5zZXJ0ZWQgaWRcbiAgICAgIHZhciB2YWx1ZXMgPSBpdGVtLnZhbHVlcztcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsdWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHRoaXMubW9kZWwuc3Vic2NyaWJlRG9jKHRoaXMuY29sbGVjdGlvbk5hbWUsIHZhbHVlc1tqXSwgY2IgJiYgZ3JvdXAoKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgYXJyYXlEaWZmLlJlbW92ZURpZmYpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBwcmV2aW91c0NvcHkuc3BsaWNlKGl0ZW0uaW5kZXgsIGl0ZW0uaG93TWFueSk7XG4gICAgICAvLyBVbnN1YnNjcmliZSBmcm9tIHRoZSBkb2N1bWVudCBmb3IgZWFjaCByZW1vdmVkIGlkXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB0aGlzLm1vZGVsLnVuc3Vic2NyaWJlRG9jKHRoaXMuY29sbGVjdGlvbk5hbWUsIHZhbHVlc1tqXSwgY2IgJiYgZ3JvdXAoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIE1vdmluZyBkb2Vzbid0IGNoYW5nZSBkb2N1bWVudCBzdWJzY3JpcHRpb25zLCBzbyB0aGF0IGlzIGlnbm9yZWQuXG4gIH1cbiAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIGNhbGxiYWNrIGdldHMgY2FsbGVkIGlmIHRoZSBkaWZmIGlzIGVtcHR5IG9yIGl0XG4gIC8vIGNvbnRhaW5zIG5vIGluc2VydHMgb3IgcmVtb3Zlc1xuICBmaW5pc2hlZCAmJiBmaW5pc2hlZCgpO1xufTtcblxuUXVlcnkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuICB2YXIgZGF0YSA9IHRoaXMubW9kZWwuX2dldCh0aGlzLnNlZ21lbnRzKTtcbiAgaWYgKCFkYXRhKSB7XG4gICAgY29uc29sZS53YXJuKCdZb3UgbXVzdCBmZXRjaCBvciBzdWJzY3JpYmUgdG8gYSBxdWVyeSBiZWZvcmUgZ2V0dGluZyBpdHMgcmVzdWx0cy4nKTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuICB2YXIgaWRzID0gZGF0YS5pZHM7XG4gIGlmICghaWRzKSByZXR1cm4gcmVzdWx0cztcblxuICB2YXIgY29sbGVjdGlvbiA9IHRoaXMubW9kZWwuZ2V0Q29sbGVjdGlvbih0aGlzLmNvbGxlY3Rpb25OYW1lKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBpZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGlkID0gaWRzW2ldO1xuICAgIHZhciBkb2MgPSBjb2xsZWN0aW9uICYmIGNvbGxlY3Rpb24uZG9jc1tpZF07XG4gICAgcmVzdWx0cy5wdXNoKGRvYyAmJiBkb2MuZ2V0KCkpO1xuICB9XG4gIHJldHVybiAoZGF0YS5leHRyYSA9PT0gdm9pZCAwKSA/XG4gICAgcmVzdWx0cyA6XG4gICAge3Jlc3VsdHM6IHJlc3VsdHMsIGV4dHJhOiBkYXRhLmV4dHJhfTtcbn07XG5cbi8qKlxuICogTGF6aWx5IGNyZWF0ZXMgb3IgZ2V0cyBhIHJlZiB0byBvdXIgcmVzdWx0c2V0J3MgcmVzdWx0cy5cbiAqL1xuUXVlcnkucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKGZyb20pIHtcbiAgdmFyIGlkc1BhdGggPSB0aGlzLmlkU2VnbWVudHMuam9pbignLicpO1xuICByZXR1cm4gdGhpcy5tb2RlbC5yZWZMaXN0KGZyb20sIHRoaXMuY29sbGVjdGlvbk5hbWUsIGlkc1BhdGgpO1xufTtcblxuLyoqXG4gKiBMYXppbHkgY3JlYXRlcyBvciBnZXRzIGEgcmVmIHRvIG91ciByZXN1bHRzZXQncyBleHRyYSBkYXRhLlxuICovXG5RdWVyeS5wcm90b3R5cGUuZXh0cmFSZWYgPSBmdW5jdGlvbihmcm9tLCByZWxQYXRoKSB7XG4gIHZhciBleHRyYVBhdGggPSB0aGlzLmV4dHJhU2VnbWVudHMuam9pbignLicpICsgKHJlbFBhdGggPyAnLicgKyByZWxQYXRoIDogJycpO1xuICByZXR1cm4gdGhpcy5tb2RlbC5yZWYoZnJvbSwgZXh0cmFQYXRoKTtcbn07XG5cblF1ZXJ5LnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFtcbiAgICB0aGlzLmNvbGxlY3Rpb25OYW1lXG4gICwgdGhpcy5leHByZXNzaW9uXG4gICwgdGhpcy5zb3VyY2VcbiAgLCB0aGlzLnN1YnNjcmliZUNvdW50XG4gICwgdGhpcy5mZXRjaENvdW50XG4gICwgdGhpcy5mZXRjaElkc1xuICBdO1xufTtcblxuZnVuY3Rpb24gcXVlcnlIYXNoKGNvbGxlY3Rpb25OYW1lLCBleHByZXNzaW9uLCBzb3VyY2UpIHtcbiAgdmFyIGFyZ3MgPSBbY29sbGVjdGlvbk5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZV07XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzKS5yZXBsYWNlKC9cXC4vZywgJ3wnKTtcbn1cblxuZnVuY3Rpb24gcmVzdWx0c0lkcyhyZXN1bHRzKSB7XG4gIHZhciBpZHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNoYXJlRG9jID0gcmVzdWx0c1tpXTtcbiAgICBpZHMucHVzaChzaGFyZURvYy5uYW1lKTtcbiAgfVxuICByZXR1cm4gaWRzO1xufVxuXG5mdW5jdGlvbiBwYXRoSWRzKG1vZGVsLCBzZWdtZW50cykge1xuICB2YXIgdmFsdWUgPSBtb2RlbC5fZ2V0KHNlZ21lbnRzKTtcbiAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSA/IFt2YWx1ZV0gOlxuICAgIChBcnJheS5pc0FycmF5KHZhbHVlKSkgPyB2YWx1ZS5zbGljZSgpIDogW107XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3Rpb25TaGFyZURvY3MobW9kZWwsIGNvbGxlY3Rpb25OYW1lKSB7XG4gIHZhciBjb2xsZWN0aW9uID0gbW9kZWwuZ2V0Q29sbGVjdGlvbihjb2xsZWN0aW9uTmFtZSk7XG4gIGlmICghY29sbGVjdGlvbikgcmV0dXJuO1xuXG4gIHZhciByZXN1bHRzID0gW107XG4gIGZvciAodmFyIG5hbWUgaW4gY29sbGVjdGlvbi5kb2NzKSB7XG4gICAgcmVzdWx0cy5wdXNoKGNvbGxlY3Rpb24uZG9jc1tuYW1lXS5zaGFyZURvYyk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuXG59KShyZXF1aXJlKFwiX19icm93c2VyaWZ5X3Byb2Nlc3NcIikpIiwicmVxdWlyZT0oZnVuY3Rpb24oZSx0LG4scil7ZnVuY3Rpb24gaShyKXtpZighbltyXSl7aWYoIXRbcl0pe2lmKGUpcmV0dXJuIGUocik7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIityK1wiJ1wiKX12YXIgcz1uW3JdPXtleHBvcnRzOnt9fTt0W3JdWzBdKGZ1bmN0aW9uKGUpe3ZhciBuPXRbcl1bMV1bZV07cmV0dXJuIGkobj9uOmUpfSxzLHMuZXhwb3J0cyl9cmV0dXJuIG5bcl0uZXhwb3J0c31mb3IodmFyIHM9MDtzPHIubGVuZ3RoO3MrKylpKHJbc10pO3JldHVybiBpfSkodHlwZW9mIHJlcXVpcmUhPT1cInVuZGVmaW5lZFwiJiZyZXF1aXJlLHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmV4cG9ydHMucmVhZElFRUU3NTQgPSBmdW5jdGlvbihidWZmZXIsIG9mZnNldCwgaXNCRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIG5CaXRzID0gLTcsXG4gICAgICBpID0gaXNCRSA/IDAgOiAobkJ5dGVzIC0gMSksXG4gICAgICBkID0gaXNCRSA/IDEgOiAtMSxcbiAgICAgIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07XG5cbiAgaSArPSBkO1xuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBzID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gZUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIGUgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7XG59O1xuXG5leHBvcnRzLndyaXRlSUVFRTc1NCA9IGZ1bmN0aW9uKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKSxcbiAgICAgIGkgPSBpc0JFID8gKG5CeXRlcyAtIDEpIDogMCxcbiAgICAgIGQgPSBpc0JFID8gLTEgOiAxLFxuICAgICAgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDtcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn07XG5cbn0se31dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uKCl7Ly8gVVRJTElUWVxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7XG52YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG5mdW5jdGlvbiBvYmplY3RLZXlzKG9iamVjdCkge1xuICBpZiAoT2JqZWN0LmtleXMpIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIG5hbWUpKSB7XG4gICAgICByZXN1bHQucHVzaChuYW1lKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gIHRoaXMuYWN0dWFsID0gb3B0aW9ucy5hY3R1YWw7XG4gIHRoaXMuZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xuICB0aGlzLm9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcjtcbiAgdmFyIHN0YWNrU3RhcnRGdW5jdGlvbiA9IG9wdGlvbnMuc3RhY2tTdGFydEZ1bmN0aW9uIHx8IGZhaWw7XG5cbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgfVxufTtcbnV0aWwuaW5oZXJpdHMoYXNzZXJ0LkFzc2VydGlvbkVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIHJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gJycgKyB2YWx1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAoaXNOYU4odmFsdWUpIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdHJ1bmNhdGUocywgbikge1xuICBpZiAodHlwZW9mIHMgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPCBuID8gcyA6IHMuc2xpY2UoMCwgbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5tZXNzYWdlKSB7XG4gICAgcmV0dXJuIFt0aGlzLm5hbWUgKyAnOicsIHRoaXMubWVzc2FnZV0uam9pbignICcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbXG4gICAgICB0aGlzLm5hbWUgKyAnOicsXG4gICAgICB0cnVuY2F0ZShKU09OLnN0cmluZ2lmeSh0aGlzLmFjdHVhbCwgcmVwbGFjZXIpLCAxMjgpLFxuICAgICAgdGhpcy5vcGVyYXRvcixcbiAgICAgIHRydW5jYXRlKEpTT04uc3RyaW5naWZ5KHRoaXMuZXhwZWN0ZWQsIHJlcGxhY2VyKSwgMTI4KVxuICAgIF0uam9pbignICcpO1xuICB9XG59O1xuXG4vLyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IgaW5zdGFuY2VvZiBFcnJvclxuXG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IuX19wcm90b19fID0gRXJyb3IucHJvdG90eXBlO1xuXG4vLyBBdCBwcmVzZW50IG9ubHkgdGhlIHRocmVlIGtleXMgbWVudGlvbmVkIGFib3ZlIGFyZSB1c2VkIGFuZFxuLy8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzXG4vLyBvdGhlciBrZXlzIHRvIHRoZSBBc3NlcnRpb25FcnJvcidzIGNvbnN0cnVjdG9yIC0gdGhleSB3aWxsIGJlXG4vLyBpZ25vcmVkLlxuXG4vLyAzLiBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiAgQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcbiAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogc3RhY2tTdGFydEZ1bmN0aW9uXG4gIH0pO1xufVxuXG4vLyBFWFRFTlNJT04hIGFsbG93cyBmb3Igd2VsbCBiZWhhdmVkIGVycm9ycyBkZWZpbmVkIGVsc2V3aGVyZS5cbmFzc2VydC5mYWlsID0gZmFpbDtcblxuLy8gNC4gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISFndWFyZC5cbi8vIGFzc2VydC5vayhndWFyZCwgbWVzc2FnZV9vcHQpO1xuLy8gVGhpcyBzdGF0ZW1lbnQgaXMgZXF1aXZhbGVudCB0byBhc3NlcnQuZXF1YWwodHJ1ZSwgZ3VhcmQsXG4vLyBtZXNzYWdlX29wdCk7LiBUbyB0ZXN0IHN0cmljdGx5IGZvciB0aGUgdmFsdWUgdHJ1ZSwgdXNlXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwodHJ1ZSwgZ3VhcmQsIG1lc3NhZ2Vfb3B0KTsuXG5cbmZ1bmN0aW9uIG9rKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghISF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09JywgYXNzZXJ0Lm9rKTtcbn1cbmFzc2VydC5vayA9IG9rO1xuXG4vLyA1LiBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGhcbi8vID09LlxuLy8gYXNzZXJ0LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5lcXVhbCk7XG59O1xuXG4vLyA2LiBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90IGVxdWFsXG4vLyB3aXRoICE9IGFzc2VydC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9JywgYXNzZXJ0Lm5vdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG4vLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoYWN0dWFsKSAmJiBCdWZmZXIuaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgaWYgKGFjdHVhbC5sZW5ndGggIT0gZXhwZWN0ZWQubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdHVhbC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFjdHVhbFtpXSAhPT0gZXhwZWN0ZWRbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICAvLyA3LjIuIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIERhdGUgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIERhdGUgb2JqZWN0IHRoYXQgcmVmZXJzIHRvIHRoZSBzYW1lIHRpbWUuXG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgRGF0ZSAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMy4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICh0eXBlb2YgYWN0dWFsICE9ICdvYmplY3QnICYmIHR5cGVvZiBleHBlY3RlZCAhPSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy40LiBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiKSB7XG4gIGlmIChpc1VuZGVmaW5lZE9yTnVsbChhKSB8fCBpc1VuZGVmaW5lZE9yTnVsbChiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAvL35+fkkndmUgbWFuYWdlZCB0byBicmVhayBPYmplY3Qua2V5cyB0aHJvdWdoIHNjcmV3eSBhcmd1bWVudHMgcGFzc2luZy5cbiAgLy8gICBDb252ZXJ0aW5nIHRvIGFycmF5IHNvbHZlcyB0aGUgcHJvYmxlbS5cbiAgaWYgKGlzQXJndW1lbnRzKGEpKSB7XG4gICAgaWYgKCFpc0FyZ3VtZW50cyhiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBfZGVlcEVxdWFsKGEsIGIpO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgICAga2IgPSBvYmplY3RLZXlzKGIpLFxuICAgICAgICBrZXksIGk7XG4gIH0gY2F0Y2ggKGUpIHsvL2hhcHBlbnMgd2hlbiBvbmUgaXMgYSBzdHJpbmcgbGl0ZXJhbCBhbmQgdGhlIG90aGVyIGlzbid0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIV9kZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIDguIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuLy8gYXNzZXJ0Lm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBFcXVhbCcsIGFzc2VydC5ub3REZWVwRXF1YWwpO1xuICB9XG59O1xuXG4vLyA5LiBUaGUgc3RyaWN0IGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzdHJpY3QgZXF1YWxpdHksIGFzIGRldGVybWluZWQgYnkgPT09LlxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09PScsIGFzc2VydC5zdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDEwLiBUaGUgc3RyaWN0IG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHN0cmljdCBpbmVxdWFsaXR5LCBhc1xuLy8gZGV0ZXJtaW5lZCBieSAhPT0uICBhc3NlcnQubm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT09JywgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoZXhwZWN0ZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gZXhwZWN0ZWQudGVzdChhY3R1YWwpO1xuICB9IGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBfdGhyb3dzKHNob3VsZFRocm93LCBibG9jaywgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGFjdHVhbDtcblxuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJykge1xuICAgIG1lc3NhZ2UgPSBleHBlY3RlZDtcbiAgICBleHBlY3RlZCA9IG51bGw7XG4gIH1cblxuICB0cnkge1xuICAgIGJsb2NrKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBhY3R1YWwgPSBlO1xuICB9XG5cbiAgbWVzc2FnZSA9IChleHBlY3RlZCAmJiBleHBlY3RlZC5uYW1lID8gJyAoJyArIGV4cGVjdGVkLm5hbWUgKyAnKS4nIDogJy4nKSArXG4gICAgICAgICAgICAobWVzc2FnZSA/ICcgJyArIG1lc3NhZ2UgOiAnLicpO1xuXG4gIGlmIChzaG91bGRUaHJvdyAmJiAhYWN0dWFsKSB7XG4gICAgZmFpbCgnTWlzc2luZyBleHBlY3RlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICBpZiAoIXNob3VsZFRocm93ICYmIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbCgnR290IHVud2FudGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICgoc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmIGV4cGVjdGVkICYmXG4gICAgICAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8ICghc2hvdWxkVGhyb3cgJiYgYWN0dWFsKSkge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfVxufVxuXG4vLyAxMS4gRXhwZWN0ZWQgdG8gdGhyb3cgYW4gZXJyb3I6XG4vLyBhc3NlcnQudGhyb3dzKGJsb2NrLCBFcnJvcl9vcHQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzLmFwcGx5KHRoaXMsIFt0cnVlXS5jb25jYXQocFNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xufTtcblxuLy8gRVhURU5TSU9OISBUaGlzIGlzIGFubm95aW5nIHRvIHdyaXRlIG91dHNpZGUgdGhpcyBtb2R1bGUuXG5hc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MuYXBwbHkodGhpcywgW2ZhbHNlXS5jb25jYXQocFNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xufTtcblxuYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbihlcnIpIHsgaWYgKGVycikge3Rocm93IGVycjt9fTtcblxufSkoKVxufSx7XCJ1dGlsXCI6MyxcImJ1ZmZlclwiOjR9XSxcImJ1ZmZlci1icm93c2VyaWZ5XCI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHM9cmVxdWlyZSgncTlUeENDJyk7XG59LHt9XSxcInE5VHhDQ1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbigpe2Z1bmN0aW9uIFNsb3dCdWZmZXIgKHNpemUpIHtcbiAgICB0aGlzLmxlbmd0aCA9IHNpemU7XG59O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MDtcblxuXG5mdW5jdGlvbiB0b0hleChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpO1xufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKylcbiAgICBpZiAoc3RyLmNoYXJDb2RlQXQoaSkgPD0gMHg3RilcbiAgICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBoID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0ci5jaGFyQXQoaSkpLnN1YnN0cigxKS5zcGxpdCgnJScpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoLmxlbmd0aDsgaisrKVxuICAgICAgICBieXRlQXJyYXkucHVzaChwYXJzZUludChoW2pdLCAxNikpO1xuICAgIH1cblxuICByZXR1cm4gYnl0ZUFycmF5O1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKyApXG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goIHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRiApO1xuXG4gIHJldHVybiBieXRlQXJyYXk7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMoc3RyKSB7XG4gIHJldHVybiByZXF1aXJlKFwiYmFzZTY0LWpzXCIpLnRvQnl0ZUFycmF5KHN0cik7XG59XG5cblNsb3dCdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIChzdHIsIGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoZW5jb2RpbmcgfHwgXCJ1dGY4XCIpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIHN0ci5sZW5ndGggLyAyO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoO1xuXG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gc3RyLmxlbmd0aDtcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYmxpdEJ1ZmZlcihzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIHBvcywgaSA9IDA7XG4gIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgaWYgKChpK29mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSlcbiAgICAgIGJyZWFrO1xuXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldO1xuICAgIGkrKztcbiAgfVxuICByZXR1cm4gaTtcbn1cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUudXRmOFdyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGJ5dGVzLCBwb3M7XG4gIHJldHVybiBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSAgYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcpLCB0aGlzLCBvZmZzZXQsIGxlbmd0aCk7XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5hc2NpaVdyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGJ5dGVzLCBwb3M7XG4gIHJldHVybiBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSAgYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgdGhpcywgb2Zmc2V0LCBsZW5ndGgpO1xufTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuYmluYXJ5V3JpdGUgPSBTbG93QnVmZmVyLnByb3RvdHlwZS5hc2NpaVdyaXRlO1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5iYXNlNjRXcml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBieXRlcywgcG9zO1xuICByZXR1cm4gU2xvd0J1ZmZlci5fY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIHRoaXMsIG9mZnNldCwgbGVuZ3RoKTtcbn07XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmJhc2U2NFNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgcmV0dXJuIHJlcXVpcmUoXCJiYXNlNjQtanNcIikuZnJvbUJ5dGVBcnJheShieXRlcyk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKTsgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUudXRmOFNsaWNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdmFyIHJlcyA9IFwiXCI7XG4gIHZhciB0bXAgPSBcIlwiO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgaWYgKGJ5dGVzW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gICAgICB0bXAgPSBcIlwiO1xuICAgIH0gZWxzZVxuICAgICAgdG1wICs9IFwiJVwiICsgYnl0ZXNbaV0udG9TdHJpbmcoMTYpO1xuXG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcCk7XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmFzY2lpU2xpY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBieXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB2YXIgcmV0ID0gXCJcIjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKylcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gIHJldHVybiByZXQ7XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmJpbmFyeVNsaWNlID0gU2xvd0J1ZmZlci5wcm90b3R5cGUuYXNjaWlTbGljZTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3V0ID0gW10sXG4gICAgICBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dFtpXSA9IHRvSGV4KHRoaXNbaV0pO1xuICAgIGlmIChpID09IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMpIHtcbiAgICAgIG91dFtpICsgMV0gPSAnLi4uJztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJzxTbG93QnVmZmVyICcgKyBvdXQuam9pbignICcpICsgJz4nO1xufTtcblxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5oZXhTbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDA7XG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW47XG5cbiAgdmFyIG91dCA9ICcnO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleCh0aGlzW2ldKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKTtcbiAgc3RhcnQgPSArc3RhcnQgfHwgMDtcbiAgaWYgKHR5cGVvZiBlbmQgPT0gJ3VuZGVmaW5lZCcpIGVuZCA9IHRoaXMubGVuZ3RoO1xuXG4gIC8vIEZhc3RwYXRoIGVtcHR5IHN0cmluZ3NcbiAgaWYgKCtlbmQgPT0gc3RhcnQpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiB0aGlzLmhleFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHRoaXMudXRmOFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0dXJuIHRoaXMuYXNjaWlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gdGhpcy5iaW5hcnlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gdGhpcy5iYXNlNjRTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIHJldHVybiB0aGlzLnVjczJTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxufTtcblxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5oZXhXcml0ZSA9IGZ1bmN0aW9uKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gK29mZnNldCB8fCAwO1xuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9ICtsZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoO1xuICBpZiAoc3RyTGVuICUgMikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnl0ZSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNik7XG4gICAgaWYgKGlzTmFOKGJ5dGUpKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpO1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSBieXRlO1xuICB9XG4gIFNsb3dCdWZmZXIuX2NoYXJzV3JpdHRlbiA9IGkgKiAyO1xuICByZXR1cm4gaTtcbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aDtcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGxlbmd0aDtcbiAgICBsZW5ndGggPSBzd2FwO1xuICB9XG5cbiAgb2Zmc2V0ID0gK29mZnNldCB8fCAwO1xuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9ICtsZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG5cbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXR1cm4gdGhpcy5oZXhXcml0ZShzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB0aGlzLnV0ZjhXcml0ZShzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiB0aGlzLmFzY2lpV3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIHRoaXMuYmFzZTY0V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXR1cm4gdGhpcy51Y3MyV3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJyk7XG4gIH1cbn07XG5cblxuLy8gc2xpY2Uoc3RhcnQsIGVuZClcblNsb3dCdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIGVuZCA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignb29iJyk7XG4gIH1cbiAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgQnVmZmVyKHRoaXMsIGVuZCAtIHN0YXJ0LCArc3RhcnQpO1xufTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKHRhcmdldCwgdGFyZ2V0c3RhcnQsIHNvdXJjZXN0YXJ0LCBzb3VyY2VlbmQpIHtcbiAgdmFyIHRlbXAgPSBbXTtcbiAgZm9yICh2YXIgaT1zb3VyY2VzdGFydDsgaTxzb3VyY2VlbmQ7IGkrKykge1xuICAgIGFzc2VydC5vayh0eXBlb2YgdGhpc1tpXSAhPT0gJ3VuZGVmaW5lZCcsIFwiY29weWluZyB1bmRlZmluZWQgYnVmZmVyIGJ5dGVzIVwiKTtcbiAgICB0ZW1wLnB1c2godGhpc1tpXSk7XG4gIH1cblxuICBmb3IgKHZhciBpPXRhcmdldHN0YXJ0OyBpPHRhcmdldHN0YXJ0K3RlbXAubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXRbaV0gPSB0ZW1wW2ktdGFyZ2V0c3RhcnRdO1xuICB9XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24odmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgfVxuICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICB0aGlzW2ldID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29lcmNlKGxlbmd0aCkge1xuICAvLyBDb2VyY2UgbGVuZ3RoIHRvIGEgbnVtYmVyIChwb3NzaWJseSBOYU4pLCByb3VuZCB1cFxuICAvLyBpbiBjYXNlIGl0J3MgZnJhY3Rpb25hbCAoZS5nLiAxMjMuNDU2KSB0aGVuIGRvIGFcbiAgLy8gZG91YmxlIG5lZ2F0ZSB0byBjb2VyY2UgYSBOYU4gdG8gMC4gRWFzeSwgcmlnaHQ/XG4gIGxlbmd0aCA9IH5+TWF0aC5jZWlsKCtsZW5ndGgpO1xuICByZXR1cm4gbGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGg7XG59XG5cblxuLy8gQnVmZmVyXG5cbmZ1bmN0aW9uIEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgb2Zmc2V0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG9mZnNldCk7XG4gIH1cblxuICB2YXIgdHlwZTtcblxuICAvLyBBcmUgd2Ugc2xpY2luZz9cbiAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgdGhpcy5sZW5ndGggPSBjb2VyY2UoZW5jb2RpbmcpO1xuICAgIHRoaXMucGFyZW50ID0gc3ViamVjdDtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgfSBlbHNlIHtcbiAgICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgICBzd2l0Y2ggKHR5cGUgPSB0eXBlb2Ygc3ViamVjdCkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgdGhpcy5sZW5ndGggPSBjb2VyY2Uoc3ViamVjdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICB0aGlzLmxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN1YmplY3QsIGVuY29kaW5nKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6IC8vIEFzc3VtZSBvYmplY3QgaXMgYW4gYXJyYXlcbiAgICAgICAgdGhpcy5sZW5ndGggPSBjb2VyY2Uoc3ViamVjdC5sZW5ndGgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBuZWVkcyB0byBiZSBhIG51bWJlciwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXJyYXkgb3Igc3RyaW5nLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IEJ1ZmZlci5wb29sU2l6ZSkge1xuICAgICAgLy8gQmlnIGJ1ZmZlciwganVzdCBhbGxvYyBvbmUuXG4gICAgICB0aGlzLnBhcmVudCA9IG5ldyBTbG93QnVmZmVyKHRoaXMubGVuZ3RoKTtcbiAgICAgIHRoaXMub2Zmc2V0ID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTbWFsbCBidWZmZXIuXG4gICAgICBpZiAoIXBvb2wgfHwgcG9vbC5sZW5ndGggLSBwb29sLnVzZWQgPCB0aGlzLmxlbmd0aCkgYWxsb2NQb29sKCk7XG4gICAgICB0aGlzLnBhcmVudCA9IHBvb2w7XG4gICAgICB0aGlzLm9mZnNldCA9IHBvb2wudXNlZDtcbiAgICAgIHBvb2wudXNlZCArPSB0aGlzLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXkuXG4gICAgaWYgKGlzQXJyYXlJc2goc3ViamVjdCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3ViamVjdCBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICAgIHRoaXMucGFyZW50W2kgKyB0aGlzLm9mZnNldF0gPSBzdWJqZWN0LnJlYWRVSW50OChpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBhcmVudFtpICsgdGhpcy5vZmZzZXRdID0gc3ViamVjdFtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PSAnc3RyaW5nJykge1xuICAgICAgLy8gV2UgYXJlIGEgc3RyaW5nXG4gICAgICB0aGlzLmxlbmd0aCA9IHRoaXMud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpO1xuICAgIH1cbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlJc2goc3ViamVjdCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShzdWJqZWN0KSB8fCBCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkgfHxcbiAgICAgICAgIHN1YmplY3QgJiYgdHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICAgICB0eXBlb2Ygc3ViamVjdC5sZW5ndGggPT09ICdudW1iZXInO1xufVxuXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyO1xuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXI7XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDggKiAxMDI0O1xudmFyIHBvb2w7XG5cbmZ1bmN0aW9uIGFsbG9jUG9vbCgpIHtcbiAgcG9vbCA9IG5ldyBTbG93QnVmZmVyKEJ1ZmZlci5wb29sU2l6ZSk7XG4gIHBvb2wudXNlZCA9IDA7XG59XG5cblxuLy8gU3RhdGljIG1ldGhvZHNcbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyKGIpIHtcbiAgcmV0dXJuIGIgaW5zdGFuY2VvZiBCdWZmZXIgfHwgYiBpbnN0YW5jZW9mIFNsb3dCdWZmZXI7XG59O1xuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVzYWdlOiBCdWZmZXIuY29uY2F0KGxpc3QsIFt0b3RhbExlbmd0aF0pXFxuIFxcXG4gICAgICBsaXN0IHNob3VsZCBiZSBhbiBBcnJheS5cIik7XG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKTtcbiAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsaXN0WzBdO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0b3RhbExlbmd0aCAhPT0gJ251bWJlcicpIHtcbiAgICB0b3RhbExlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYnVmID0gbGlzdFtpXTtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGJ1Zi5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpO1xuICB2YXIgcG9zID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV07XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpO1xuICAgIHBvcyArPSBidWYubGVuZ3RoO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59O1xuXG4vLyBJbnNwZWN0XG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICB2YXIgb3V0ID0gW10sXG4gICAgICBsZW4gPSB0aGlzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgb3V0W2ldID0gdG9IZXgodGhpcy5wYXJlbnRbaSArIHRoaXMub2Zmc2V0XSk7XG4gICAgaWYgKGkgPT0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUykge1xuICAgICAgb3V0W2kgKyAxXSA9ICcuLi4nO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBvdXQuam9pbignICcpICsgJz4nO1xufTtcblxuXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldChpKSB7XG4gIGlmIChpIDwgMCB8fCBpID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICByZXR1cm4gdGhpcy5wYXJlbnRbdGhpcy5vZmZzZXQgKyBpXTtcbn07XG5cblxuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQoaSwgdikge1xuICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgcmV0dXJuIHRoaXMucGFyZW50W3RoaXMub2Zmc2V0ICsgaV0gPSB2O1xufTtcblxuXG4vLyB3cml0ZShzdHJpbmcsIG9mZnNldCA9IDAsIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgtb2Zmc2V0LCBlbmNvZGluZyA9ICd1dGY4JylcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aDtcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGxlbmd0aDtcbiAgICBsZW5ndGggPSBzd2FwO1xuICB9XG5cbiAgb2Zmc2V0ID0gK29mZnNldCB8fCAwO1xuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9ICtsZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG5cbiAgdmFyIHJldDtcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSB0aGlzLnBhcmVudC5oZXhXcml0ZShzdHJpbmcsIHRoaXMub2Zmc2V0ICsgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB0aGlzLnBhcmVudC51dGY4V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuYXNjaWlXcml0ZShzdHJpbmcsIHRoaXMub2Zmc2V0ICsgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuYmluYXJ5V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICByZXQgPSB0aGlzLnBhcmVudC5iYXNlNjRXcml0ZShzdHJpbmcsIHRoaXMub2Zmc2V0ICsgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXQgPSB0aGlzLnBhcmVudC51Y3MyV3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG5cbiAgQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW47XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cblxuLy8gdG9TdHJpbmcoZW5jb2RpbmcsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKTtcblxuICBpZiAodHlwZW9mIHN0YXJ0ID09ICd1bmRlZmluZWQnIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMDtcbiAgfSBlbHNlIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgc3RhcnQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5kID09ICd1bmRlZmluZWQnIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gIH0gZWxzZSBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCA9IDA7XG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ICsgdGhpcy5vZmZzZXQ7XG4gIGVuZCA9IGVuZCArIHRoaXMub2Zmc2V0O1xuXG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmhleFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnV0ZjhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5hc2NpaVNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5iaW5hcnlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuYmFzZTY0U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQudWNzMlNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG59O1xuXG5cbi8vIGJ5dGVMZW5ndGhcbkJ1ZmZlci5ieXRlTGVuZ3RoID0gU2xvd0J1ZmZlci5ieXRlTGVuZ3RoO1xuXG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICB2YWx1ZSB8fCAodmFsdWUgPSAwKTtcbiAgc3RhcnQgfHwgKHN0YXJ0ID0gMCk7XG4gIGVuZCB8fCAoZW5kID0gdGhpcy5sZW5ndGgpO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5jaGFyQ29kZUF0KDApO1xuICB9XG4gIGlmICghKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHx8IGlzTmFOKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndmFsdWUgaXMgbm90IGEgbnVtYmVyJyk7XG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBFcnJvcignZW5kIDwgc3RhcnQnKTtcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwO1xuICBpZiAodGhpcy5sZW5ndGggPT0gMCkgcmV0dXJuIDA7XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc3RhcnQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZCBvdXQgb2YgYm91bmRzJyk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5wYXJlbnQuZmlsbCh2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgKyB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kICsgdGhpcy5vZmZzZXQpO1xufTtcblxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbih0YXJnZXQsIHRhcmdldF9zdGFydCwgc3RhcnQsIGVuZCkge1xuICB2YXIgc291cmNlID0gdGhpcztcbiAgc3RhcnQgfHwgKHN0YXJ0ID0gMCk7XG4gIGVuZCB8fCAoZW5kID0gdGhpcy5sZW5ndGgpO1xuICB0YXJnZXRfc3RhcnQgfHwgKHRhcmdldF9zdGFydCA9IDApO1xuXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VFbmQgPCBzb3VyY2VTdGFydCcpO1xuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDA7XG4gIGlmICh0YXJnZXQubGVuZ3RoID09IDAgfHwgc291cmNlLmxlbmd0aCA9PSAwKSByZXR1cm4gMDtcblxuICBpZiAodGFyZ2V0X3N0YXJ0IDwgMCB8fCB0YXJnZXRfc3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJyk7XG4gIH1cblxuICBpZiAoZW5kIDwgMCB8fCBlbmQgPiBzb3VyY2UubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMucGFyZW50LmNvcHkodGFyZ2V0LnBhcmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0X3N0YXJ0ICsgdGFyZ2V0Lm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgKyB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kICsgdGhpcy5vZmZzZXQpO1xufTtcblxuXG4vLyBzbGljZShzdGFydCwgZW5kKVxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICBpZiAoc3RhcnQgPiBlbmQpIHRocm93IG5ldyBFcnJvcignb29iJyk7XG5cbiAgcmV0dXJuIG5ldyBCdWZmZXIodGhpcy5wYXJlbnQsIGVuZCAtIHN0YXJ0LCArc3RhcnQgKyB0aGlzLm9mZnNldCk7XG59O1xuXG5cbi8vIExlZ2FjeSBtZXRob2RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblxuQnVmZmVyLnByb3RvdHlwZS51dGY4U2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiB0aGlzLnRvU3RyaW5nKCd1dGY4Jywgc3RhcnQsIGVuZCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmJpbmFyeVNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygnYmluYXJ5Jywgc3RhcnQsIGVuZCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmFzY2lpU2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiB0aGlzLnRvU3RyaW5nKCdhc2NpaScsIHN0YXJ0LCBlbmQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS51dGY4V3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCkge1xuICByZXR1cm4gdGhpcy53cml0ZShzdHJpbmcsIG9mZnNldCwgJ3V0ZjgnKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuYmluYXJ5V3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCkge1xuICByZXR1cm4gdGhpcy53cml0ZShzdHJpbmcsIG9mZnNldCwgJ2JpbmFyeScpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5hc2NpaVdyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMud3JpdGUoc3RyaW5nLCBvZmZzZXQsICdhc2NpaScpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhciBidWZmZXIgPSB0aGlzO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkgcmV0dXJuO1xuXG4gIHJldHVybiBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdO1xufTtcblxuZnVuY3Rpb24gcmVhZFVJbnQxNihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciB2YWwgPSAwO1xuXG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgaWYgKG9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSByZXR1cm4gMDtcblxuICBpZiAoaXNCaWdFbmRpYW4pIHtcbiAgICB2YWwgPSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdIDw8IDg7XG4gICAgaWYgKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbCA9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF07XG4gICAgaWYgKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgODtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gcmVhZFVJbnQzMihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciB2YWwgPSAwO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkgcmV0dXJuIDA7XG5cbiAgaWYgKGlzQmlnRW5kaWFuKSB7XG4gICAgaWYgKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgMTY7XG4gICAgaWYgKG9mZnNldCArIDIgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDJdIDw8IDg7XG4gICAgaWYgKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDNdO1xuICAgIHZhbCA9IHZhbCArIChidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdIDw8IDI0ID4+PiAwKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGJ1ZmZlci5sZW5ndGgpXG4gICAgICB2YWwgPSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAyXSA8PCAxNjtcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgpXG4gICAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgODtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XTtcbiAgICBpZiAob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgpXG4gICAgICB2YWwgPSB2YWwgKyAoYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgM10gPDwgMjQgPj4+IDApO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFNpZ25lZCBpbnRlZ2VyIHR5cGVzLCB5YXkgdGVhbSEgQSByZW1pbmRlciBvbiBob3cgdHdvJ3MgY29tcGxlbWVudCBhY3R1YWxseVxuICogd29ya3MuIFRoZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ25lZCBiaXQsIGkuZS4gdGVsbHMgdXMgd2hldGhlciBvciBub3QgdGhlXG4gKiBudW1iZXIgc2hvdWxkIGJlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLiBJZiB0aGUgdHdvJ3MgY29tcGxlbWVudCB2YWx1ZSBpc1xuICogcG9zaXRpdmUsIHRoZW4gd2UncmUgZG9uZSwgYXMgaXQncyBlcXVpdmFsZW50IHRvIHRoZSB1bnNpZ25lZCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBOb3cgaWYgdGhlIG51bWJlciBpcyBwb3NpdGl2ZSwgeW91J3JlIHByZXR0eSBtdWNoIGRvbmUsIHlvdSBjYW4ganVzdCBsZXZlcmFnZVxuICogdGhlIHVuc2lnbmVkIHRyYW5zbGF0aW9ucyBhbmQgcmV0dXJuIHRob3NlLiBVbmZvcnR1bmF0ZWx5LCBuZWdhdGl2ZSBudW1iZXJzXG4gKiBhcmVuJ3QgcXVpdGUgdGhhdCBzdHJhaWdodGZvcndhcmQuXG4gKlxuICogQXQgZmlyc3QgZ2xhbmNlLCBvbmUgbWlnaHQgYmUgaW5jbGluZWQgdG8gdXNlIHRoZSB0cmFkaXRpb25hbCBmb3JtdWxhIHRvXG4gKiB0cmFuc2xhdGUgYmluYXJ5IG51bWJlcnMgYmV0d2VlbiB0aGUgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcyBpbiB0d28nc1xuICogY29tcGxlbWVudC4gKFRob3VnaCBpdCBkb2Vzbid0IHF1aXRlIHdvcmsgZm9yIHRoZSBtb3N0IG5lZ2F0aXZlIHZhbHVlKVxuICogTWFpbmx5OlxuICogIC0gaW52ZXJ0IGFsbCB0aGUgYml0c1xuICogIC0gYWRkIG9uZSB0byB0aGUgcmVzdWx0XG4gKlxuICogT2YgY291cnNlLCB0aGlzIGRvZXNuJ3QgcXVpdGUgd29yayBpbiBKYXZhc2NyaXB0LiBUYWtlIGZvciBleGFtcGxlIHRoZSB2YWx1ZVxuICogb2YgLTEyOC4gVGhpcyBjb3VsZCBiZSByZXByZXNlbnRlZCBpbiAxNiBiaXRzIChiaWctZW5kaWFuKSBhcyAweGZmODAuIEJ1dCBvZlxuICogY291cnNlLCBKYXZhc2NyaXB0IHdpbGwgZG8gdGhlIGZvbGxvd2luZzpcbiAqXG4gKiA+IH4weGZmODBcbiAqIC02NTQwOVxuICpcbiAqIFdob2ggdGhlcmUsIEphdmFzY3JpcHQsIHRoYXQncyBub3QgcXVpdGUgcmlnaHQuIEJ1dCB3YWl0LCBhY2NvcmRpbmcgdG9cbiAqIEphdmFzY3JpcHQgdGhhdCdzIHBlcmZlY3RseSBjb3JyZWN0LiBXaGVuIEphdmFzY3JpcHQgZW5kcyB1cCBzZWVpbmcgdGhlXG4gKiBjb25zdGFudCAweGZmODAsIGl0IGhhcyBubyBub3Rpb24gdGhhdCBpdCBpcyBhY3R1YWxseSBhIHNpZ25lZCBudW1iZXIuIEl0XG4gKiBhc3N1bWVzIHRoYXQgd2UndmUgaW5wdXQgdGhlIHVuc2lnbmVkIHZhbHVlIDB4ZmY4MC4gVGh1cywgd2hlbiBpdCBkb2VzIHRoZVxuICogYmluYXJ5IG5lZ2F0aW9uLCBpdCBjYXN0cyBpdCBpbnRvIGEgc2lnbmVkIHZhbHVlLCAocG9zaXRpdmUgMHhmZjgwKS4gVGhlblxuICogd2hlbiB5b3UgcGVyZm9ybSBiaW5hcnkgbmVnYXRpb24gb24gdGhhdCwgaXQgdHVybnMgaXQgaW50byBhIG5lZ2F0aXZlIG51bWJlci5cbiAqXG4gKiBJbnN0ZWFkLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIHVzZSB0aGUgZm9sbG93aW5nIGdlbmVyYWwgZm9ybXVsYSwgdGhhdCB3b3Jrc1xuICogaW4gYSByYXRoZXIgSmF2YXNjcmlwdCBmcmllbmRseSB3YXkuIEknbSBnbGFkIHdlIGRvbid0IHN1cHBvcnQgdGhpcyBraW5kIG9mXG4gKiB3ZWlyZCBudW1iZXJpbmcgc2NoZW1lIGluIHRoZSBrZXJuZWwuXG4gKlxuICogKEJJVC1NQVggLSAodW5zaWduZWQpdmFsICsgMSkgKiAtMVxuICpcbiAqIFRoZSBhc3R1dGUgb2JzZXJ2ZXIsIG1heSB0aGluayB0aGF0IHRoaXMgZG9lc24ndCBtYWtlIHNlbnNlIGZvciA4LWJpdCBudW1iZXJzXG4gKiAocmVhbGx5IGl0IGlzbid0IG5lY2Vzc2FyeSBmb3IgdGhlbSkuIEhvd2V2ZXIsIHdoZW4geW91IGdldCAxNi1iaXQgbnVtYmVycyxcbiAqIHlvdSBkby4gTGV0J3MgZ28gYmFjayB0byBvdXIgcHJpb3IgZXhhbXBsZSBhbmQgc2VlIGhvdyB0aGlzIHdpbGwgbG9vazpcbiAqXG4gKiAoMHhmZmZmIC0gMHhmZjgwICsgMSkgKiAtMVxuICogKDB4MDA3ZiArIDEpICogLTFcbiAqICgweDAwODApICogLTFcbiAqL1xuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG4gIHZhciBuZWc7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgaWYgKG9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSByZXR1cm47XG5cbiAgbmVnID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSAmIDB4ODA7XG4gIGlmICghbmVnKSB7XG4gICAgcmV0dXJuIChidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdKTtcbiAgfVxuXG4gIHJldHVybiAoKDB4ZmYgLSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdICsgMSkgKiAtMSk7XG59O1xuXG5mdW5jdGlvbiByZWFkSW50MTYoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YXIgbmVnLCB2YWw7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgdmFsID0gcmVhZFVJbnQxNihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgbmVnID0gdmFsICYgMHg4MDAwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICByZXR1cm4gKDB4ZmZmZiAtIHZhbCArIDEpICogLTE7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRJbnQzMihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciBuZWcsIHZhbDtcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICB2YWwgPSByZWFkVUludDMyKGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICBuZWcgPSB2YWwgJiAweDgwMDAwMDAwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiAodmFsKTtcbiAgfVxuXG4gIHJldHVybiAoMHhmZmZmZmZmZiAtIHZhbCArIDEpICogLTE7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRGbG9hdChidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLnJlYWRJRUVFNzU0KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDIzLCA0KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gcmVhZERvdWJsZShidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyA3IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLnJlYWRJRUVFNzU0KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDUyLCA4KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaW50ZWdlci4gVGhpcyBtZWFucyB0aGF0IGl0IGlzXG4gKiBub24tbmVnYXRpdmUuIEl0IGhhcyBubyBmcmFjdGlvbmFsIGNvbXBvbmVudCBhbmQgdGhhdCBpdCBkb2VzIG5vdCBleGNlZWQgdGhlXG4gKiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUuXG4gKlxuICogICAgICB2YWx1ZSAgICAgICAgICAgVGhlIG51bWJlciB0byBjaGVjayBmb3IgdmFsaWRpdHlcbiAqXG4gKiAgICAgIG1heCAgICAgICAgICAgICBUaGUgbWF4aW11bSB2YWx1ZVxuICovXG5mdW5jdGlvbiB2ZXJpZnVpbnQodmFsdWUsIG1heCkge1xuICBhc3NlcnQub2sodHlwZW9mICh2YWx1ZSkgPT0gJ251bWJlcicsXG4gICAgICAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA+PSAwLFxuICAgICAgJ3NwZWNpZmllZCBhIG5lZ2F0aXZlIHZhbHVlIGZvciB3cml0aW5nIGFuIHVuc2lnbmVkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGlzIGxhcmdlciB0aGFuIG1heGltdW0gdmFsdWUgZm9yIHR5cGUnKTtcblxuICBhc3NlcnQub2soTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmKTtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSA9IHZhbHVlO1xuICB9XG59O1xuXG5mdW5jdGlvbiB3cml0ZVVJbnQxNihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZik7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGgubWluKGJ1ZmZlci5sZW5ndGggLSBvZmZzZXQsIDIpOyBpKyspIHtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGlzQmlnRW5kaWFuID8gMSAtIGkgOiBpKSkpKSA+Pj5cbiAgICAgICAgICAgIChpc0JpZ0VuZGlhbiA/IDEgLSBpIDogaSkgKiA4O1xuICB9XG5cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlVUludDMyKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmZmZmZik7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGgubWluKGJ1ZmZlci5sZW5ndGggLSBvZmZzZXQsIDQpOyBpKyspIHtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSA+Pj4gKGlzQmlnRW5kaWFuID8gMyAtIGkgOiBpKSAqIDgpICYgMHhmZjtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuXG4vKlxuICogV2Ugbm93IG1vdmUgb250byBvdXIgZnJpZW5kcyBpbiB0aGUgc2lnbmVkIG51bWJlciBjYXRlZ29yeS4gVW5saWtlIHVuc2lnbmVkXG4gKiBudW1iZXJzLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIHdvcnJ5IGEgYml0IG1vcmUgYWJvdXQgaG93IHdlIHB1dCB2YWx1ZXMgaW50b1xuICogYXJyYXlzLiBTaW5jZSB3ZSBhcmUgb25seSB3b3JyeWluZyBhYm91dCBzaWduZWQgMzItYml0IHZhbHVlcywgd2UncmUgaW5cbiAqIHNsaWdodGx5IGJldHRlciBzaGFwZS4gVW5mb3J0dW5hdGVseSwgd2UgcmVhbGx5IGNhbid0IGRvIG91ciBmYXZvcml0ZSBiaW5hcnlcbiAqICYgaW4gdGhpcyBzeXN0ZW0uIEl0IHJlYWxseSBzZWVtcyB0byBkbyB0aGUgd3JvbmcgdGhpbmcuIEZvciBleGFtcGxlOlxuICpcbiAqID4gLTMyICYgMHhmZlxuICogMjI0XG4gKlxuICogV2hhdCdzIGhhcHBlbmluZyBhYm92ZSBpcyByZWFsbHk6IDB4ZTAgJiAweGZmID0gMHhlMC4gSG93ZXZlciwgdGhlIHJlc3VsdHMgb2ZcbiAqIHRoaXMgYXJlbid0IHRyZWF0ZWQgYXMgYSBzaWduZWQgbnVtYmVyLiBVbHRpbWF0ZWx5IGEgYmFkIHRoaW5nLlxuICpcbiAqIFdoYXQgd2UncmUgZ29pbmcgdG8gd2FudCB0byBkbyBpcyBiYXNpY2FsbHkgY3JlYXRlIHRoZSB1bnNpZ25lZCBlcXVpdmFsZW50IG9mXG4gKiBvdXIgcmVwcmVzZW50YXRpb24gYW5kIHBhc3MgdGhhdCBvZmYgdG8gdGhlIHd1aW50KiBmdW5jdGlvbnMuIFRvIGRvIHRoYXRcbiAqIHdlJ3JlIGdvaW5nIHRvIGRvIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogIC0gaWYgdGhlIHZhbHVlIGlzIHBvc2l0aXZlXG4gKiAgICAgIHdlIGNhbiBwYXNzIGl0IGRpcmVjdGx5IG9mZiB0byB0aGUgZXF1aXZhbGVudCB3dWludFxuICogIC0gaWYgdGhlIHZhbHVlIGlzIG5lZ2F0aXZlXG4gKiAgICAgIHdlIGRvIHRoZSBmb2xsb3dpbmcgY29tcHV0YXRpb246XG4gKiAgICAgICAgIG1iICsgdmFsICsgMSwgd2hlcmVcbiAqICAgICAgICAgbWIgICBpcyB0aGUgbWF4aW11bSB1bnNpZ25lZCB2YWx1ZSBpbiB0aGF0IGJ5dGUgc2l6ZVxuICogICAgICAgICB2YWwgIGlzIHRoZSBKYXZhc2NyaXB0IG5lZ2F0aXZlIGludGVnZXJcbiAqXG4gKlxuICogQXMgYSBjb25jcmV0ZSB2YWx1ZSwgdGFrZSAtMTI4LiBJbiBzaWduZWQgMTYgYml0cyB0aGlzIHdvdWxkIGJlIDB4ZmY4MC4gSWZcbiAqIHlvdSBkbyBvdXQgdGhlIGNvbXB1dGF0aW9uczpcbiAqXG4gKiAweGZmZmYgLSAxMjggKyAxXG4gKiAweGZmZmYgLSAxMjdcbiAqIDB4ZmY4MFxuICpcbiAqIFlvdSBjYW4gdGhlbiBlbmNvZGUgdGhpcyB2YWx1ZSBhcyB0aGUgc2lnbmVkIHZlcnNpb24uIFRoaXMgaXMgcmVhbGx5IHJhdGhlclxuICogaGFja3ksIGJ1dCBpdCBzaG91bGQgd29yayBhbmQgZ2V0IHRoZSBqb2IgZG9uZSB3aGljaCBpcyBvdXIgZ29hbCBoZXJlLlxuICovXG5cbi8qXG4gKiBBIHNlcmllcyBvZiBjaGVja3MgdG8gbWFrZSBzdXJlIHdlIGFjdHVhbGx5IGhhdmUgYSBzaWduZWQgMzItYml0IG51bWJlclxuICovXG5mdW5jdGlvbiB2ZXJpZnNpbnQodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydC5vayh0eXBlb2YgKHZhbHVlKSA9PSAnbnVtYmVyJyxcbiAgICAgICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSwgJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50Jyk7XG59XG5cbmZ1bmN0aW9uIHZlcmlmSUVFRTc1NCh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0Lm9rKHR5cGVvZiAodmFsdWUpID09ICdudW1iZXInLFxuICAgICAgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKTtcblxuICBhc3NlcnQub2sodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YXIgYnVmZmVyID0gdGhpcztcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2YsIC0weDgwKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgYnVmZmVyLndyaXRlVUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpO1xuICB9IGVsc2Uge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KDB4ZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbm9Bc3NlcnQpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB3cml0ZUludDE2KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmLCAtMHg4MDAwKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgd3JpdGVVSW50MTYoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9IGVsc2Uge1xuICAgIHdyaXRlVUludDE2KGJ1ZmZlciwgMHhmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCk7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVJbnQzMihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgd3JpdGVVSW50MzIoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9IGVsc2Uge1xuICAgIHdyaXRlVUludDMyKGJ1ZmZlciwgMHhmZmZmZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOCk7XG4gIH1cblxuICByZXF1aXJlKCcuL2J1ZmZlcl9pZWVlNzU0Jykud3JpdGVJRUVFNzU0KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sXG4gICAgICAyMywgNCk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgNyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCk7XG4gIH1cblxuICByZXF1aXJlKCcuL2J1ZmZlcl9pZWVlNzU0Jykud3JpdGVJRUVFNzU0KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sXG4gICAgICA1MiwgOCk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50ODtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4O1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDg7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDg7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRTtcblxufSkoKVxufSx7XCJhc3NlcnRcIjoyLFwiLi9idWZmZXJfaWVlZTc1NFwiOjEsXCJiYXNlNjQtanNcIjo1fV0sMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5leHBvcnRzLmlzRGF0ZSA9IGZ1bmN0aW9uKG9iail7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBEYXRlXSd9O1xuZXhwb3J0cy5pc1JlZ0V4cCA9IGZ1bmN0aW9uKG9iail7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBSZWdFeHBdJ307XG5cblxuZXhwb3J0cy5wcmludCA9IGZ1bmN0aW9uICgpIHt9O1xuZXhwb3J0cy5wdXRzID0gZnVuY3Rpb24gKCkge307XG5leHBvcnRzLmRlYnVnID0gZnVuY3Rpb24oKSB7fTtcblxuZXhwb3J0cy5pbnNwZWN0ID0gZnVuY3Rpb24ob2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKSB7XG4gIHZhciBzZWVuID0gW107XG5cbiAgdmFyIHN0eWxpemUgPSBmdW5jdGlvbihzdHIsIHN0eWxlVHlwZSkge1xuICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuICAgIHZhciBzdHlsZXMgPVxuICAgICAgICB7ICdib2xkJyA6IFsxLCAyMl0sXG4gICAgICAgICAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAgICAgICAgICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgICAgICAgICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAgICAgICAgICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgICAgICAgICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgICAgICAgICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICAgICAgICAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICAgICAgICAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICAgICAgICAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAgICAgICAgICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAgICAgICAgICdyZWQnIDogWzMxLCAzOV0sXG4gICAgICAgICAgJ3llbGxvdycgOiBbMzMsIDM5XSB9O1xuXG4gICAgdmFyIHN0eWxlID1cbiAgICAgICAgeyAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgICAgICAgICAnbnVtYmVyJzogJ2JsdWUnLFxuICAgICAgICAgICdib29sZWFuJzogJ3llbGxvdycsXG4gICAgICAgICAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgICAgICAgICAnbnVsbCc6ICdib2xkJyxcbiAgICAgICAgICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgICAgICAgICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgICAgICAgICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAgICAgICAgICdyZWdleHAnOiAncmVkJyB9W3N0eWxlVHlwZV07XG5cbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIHJldHVybiAnXFwwMzNbJyArIHN0eWxlc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAgICdcXDAzM1snICsgc3R5bGVzW3N0eWxlXVsxXSArICdtJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH07XG4gIGlmICghIGNvbG9ycykge1xuICAgIHN0eWxpemUgPSBmdW5jdGlvbihzdHIsIHN0eWxlVHlwZSkgeyByZXR1cm4gc3RyOyB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0KHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gICAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5pbnNwZWN0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgICB2YWx1ZSAhPT0gZXhwb3J0cyAmJlxuICAgICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzKTtcbiAgICB9XG5cbiAgICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgICAgICByZXR1cm4gc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcblxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuXG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgICB9XG4gICAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xuICAgIH1cblxuICAgIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgICB2YXIgdmlzaWJsZV9rZXlzID0gT2JqZWN0X2tleXModmFsdWUpO1xuICAgIHZhciBrZXlzID0gc2hvd0hpZGRlbiA/IE9iamVjdF9nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKSA6IHZpc2libGVfa2V5cztcblxuICAgIC8vIEZ1bmN0aW9ucyB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYga2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJycgKyB2YWx1ZSwgJ3JlZ2V4cCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERhdGVzIHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWRcbiAgICBpZiAoaXNEYXRlKHZhbHVlKSAmJiBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHN0eWxpemUodmFsdWUudG9VVENTdHJpbmcoKSwgJ2RhdGUnKTtcbiAgICB9XG5cbiAgICB2YXIgYmFzZSwgdHlwZSwgYnJhY2VzO1xuICAgIC8vIERldGVybWluZSB0aGUgb2JqZWN0IHR5cGVcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHR5cGUgPSAnQXJyYXknO1xuICAgICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZSA9ICdPYmplY3QnO1xuICAgICAgYnJhY2VzID0gWyd7JywgJ30nXTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgYmFzZSA9IChpc1JlZ0V4cCh2YWx1ZSkpID8gJyAnICsgdmFsdWUgOiAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlID0gJyc7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIGJhc2UgPSAnICcgKyB2YWx1ZS50b1VUQ1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gICAgfVxuXG4gICAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJycgKyB2YWx1ZSwgJ3JlZ2V4cCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWVuLnB1c2godmFsdWUpO1xuXG4gICAgdmFyIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIG5hbWUsIHN0cjtcbiAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cEdldHRlcl9fKSB7XG4gICAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cEdldHRlcl9fKGtleSkpIHtcbiAgICAgICAgICBpZiAodmFsdWUuX19sb29rdXBTZXR0ZXJfXyhrZXkpKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHIgPSBzdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cFNldHRlcl9fKGtleSkpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh2aXNpYmxlX2tleXMuaW5kZXhPZihrZXkpIDwgMCkge1xuICAgICAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHIpIHtcbiAgICAgICAgaWYgKHNlZW4uaW5kZXhPZih2YWx1ZVtrZXldKSA8IDApIHtcbiAgICAgICAgICBpZiAocmVjdXJzZVRpbWVzID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdHIgPSBmb3JtYXQodmFsdWVba2V5XSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ciA9IGZvcm1hdCh2YWx1ZVtrZXldLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9IHN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnQXJyYXknICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgICAgIG5hbWUgPSBzdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgICAgICBuYW1lID0gc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xuICAgIH0pO1xuXG4gICAgc2Vlbi5wb3AoKTtcblxuICAgIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgICBudW1MaW5lc0VzdCsrO1xuICAgICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgICAgcmV0dXJuIHByZXYgKyBjdXIubGVuZ3RoICsgMTtcbiAgICB9LCAwKTtcblxuICAgIGlmIChsZW5ndGggPiA1MCkge1xuICAgICAgb3V0cHV0ID0gYnJhY2VzWzBdICtcbiAgICAgICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgICAgYnJhY2VzWzFdO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dCA9IGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG4gIHJldHVybiBmb3JtYXQob2JqLCAodHlwZW9mIGRlcHRoID09PSAndW5kZWZpbmVkJyA/IDIgOiBkZXB0aCkpO1xufTtcblxuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBhciBpbnN0YW5jZW9mIEFycmF5IHx8XG4gICAgICAgICBBcnJheS5pc0FycmF5KGFyKSB8fFxuICAgICAgICAgKGFyICYmIGFyICE9PSBPYmplY3QucHJvdG90eXBlICYmIGlzQXJyYXkoYXIuX19wcm90b19fKSk7XG59XG5cblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIHJlIGluc3RhbmNlb2YgUmVnRXhwIHx8XG4gICAgKHR5cGVvZiByZSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXScpO1xufVxuXG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIGlmIChkIGluc3RhbmNlb2YgRGF0ZSkgcmV0dXJuIHRydWU7XG4gIGlmICh0eXBlb2YgZCAhPT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcbiAgdmFyIHByb3BlcnRpZXMgPSBEYXRlLnByb3RvdHlwZSAmJiBPYmplY3RfZ2V0T3duUHJvcGVydHlOYW1lcyhEYXRlLnByb3RvdHlwZSk7XG4gIHZhciBwcm90byA9IGQuX19wcm90b19fICYmIE9iamVjdF9nZXRPd25Qcm9wZXJ0eU5hbWVzKGQuX19wcm90b19fKTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHByb3RvKSA9PT0gSlNPTi5zdHJpbmdpZnkocHJvcGVydGllcyk7XG59XG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uIChtc2cpIHt9O1xuXG5leHBvcnRzLnB1bXAgPSBudWxsO1xuXG52YXIgT2JqZWN0X2tleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHJlcy5wdXNoKGtleSk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbnZhciBPYmplY3RfZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcblxudmFyIE9iamVjdF9jcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIChwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAvLyBmcm9tIGVzNS1zaGltXG4gICAgdmFyIG9iamVjdDtcbiAgICBpZiAocHJvdG90eXBlID09PSBudWxsKSB7XG4gICAgICAgIG9iamVjdCA9IHsgJ19fcHJvdG9fXycgOiBudWxsIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIHByb3RvdHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgJ3R5cGVvZiBwcm90b3R5cGVbJyArICh0eXBlb2YgcHJvdG90eXBlKSArICddICE9IFxcJ29iamVjdFxcJydcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFR5cGUgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgVHlwZS5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgICAgIG9iamVjdCA9IG5ldyBUeXBlKCk7XG4gICAgICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvcGVydGllcyAhPT0gJ3VuZGVmaW5lZCcgJiYgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMob2JqZWN0LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn07XG5cbmV4cG9ydHMuaW5oZXJpdHMgPSBmdW5jdGlvbihjdG9yLCBzdXBlckN0b3IpIHtcbiAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gIGN0b3IucHJvdG90eXBlID0gT2JqZWN0X2NyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAodHlwZW9mIGYgIT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGV4cG9ydHMuaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6IHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSl7XG4gICAgaWYgKHggPT09IG51bGwgfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGV4cG9ydHMuaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cbn0se1wiZXZlbnRzXCI6Nn1dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5KGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyO1xuXHRcblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyAnSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCc7XG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHBsYWNlSG9sZGVycyA9IGI2NC5pbmRleE9mKCc9Jyk7XG5cdFx0cGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSBwbGFjZUhvbGRlcnMgOiAwO1xuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gW107Ly9uZXcgVWludDhBcnJheShiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpO1xuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGxvb2t1cC5pbmRleE9mKGI2NFtpXSkgPDwgMTgpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pIDw8IDEyKSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDJdKSA8PCA2KSB8IGxvb2t1cC5pbmRleE9mKGI2NFtpICsgM10pO1xuXHRcdFx0YXJyLnB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNik7XG5cdFx0XHRhcnIucHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KTtcblx0XHRcdGFyci5wdXNoKHRtcCAmIDB4RkYpO1xuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChsb29rdXAuaW5kZXhPZihiNjRbaV0pIDw8IDIpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pID4+IDQpO1xuXHRcdFx0YXJyLnB1c2godG1wICYgMHhGRik7XG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChsb29rdXAuaW5kZXhPZihiNjRbaV0pIDw8IDEwKSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDFdKSA8PCA0KSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDJdKSA+PiAyKTtcblx0XHRcdGFyci5wdXNoKCh0bXAgPj4gOCkgJiAweEZGKTtcblx0XHRcdGFyci5wdXNoKHRtcCAmIDB4RkYpO1xuXHRcdH1cblxuXHRcdHJldHVybiBhcnI7XG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0KHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGg7XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdO1xuXHRcdH07XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKTtcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcCk7XG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbdGVtcCA+PiAyXTtcblx0XHRcdFx0b3V0cHV0ICs9IGxvb2t1cFsodGVtcCA8PCA0KSAmIDB4M0ZdO1xuXHRcdFx0XHRvdXRwdXQgKz0gJz09Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwW3RlbXAgPj4gMTBdO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwWyh0ZW1wID4+IDQpICYgMHgzRl07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbKHRlbXAgPDwgMikgJiAweDNGXTtcblx0XHRcdFx0b3V0cHV0ICs9ICc9Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXk7XG5cdG1vZHVsZS5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0O1xufSgpKTtcblxufSx7fV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5leHBvcnRzLnJlYWRJRUVFNzU0ID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGlzQkUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBuQml0cyA9IC03LFxuICAgICAgaSA9IGlzQkUgPyAwIDogKG5CeXRlcyAtIDEpLFxuICAgICAgZCA9IGlzQkUgPyAxIDogLTEsXG4gICAgICBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG4gIGkgKz0gZDtcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgcyA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IGVMZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pO1xufTtcblxuZXhwb3J0cy53cml0ZUlFRUU3NTQgPSBmdW5jdGlvbihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQkUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgYyxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCksXG4gICAgICBpID0gaXNCRSA/IChuQnl0ZXMgLSAxKSA6IDAsXG4gICAgICBkID0gaXNCRSA/IC0xIDogMSxcbiAgICAgIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7XG59O1xuXG59LHt9XSw4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBpZiAoZXYuc291cmNlID09PSB3aW5kb3cgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1cblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG59LHt9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbihwcm9jZXNzKXtpZiAoIXByb2Nlc3MuRXZlbnRFbWl0dGVyKSBwcm9jZXNzLkV2ZW50RW1pdHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuXG52YXIgRXZlbnRFbWl0dGVyID0gZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBwcm9jZXNzLkV2ZW50RW1pdHRlcjtcbnZhciBpc0FycmF5ID0gdHlwZW9mIEFycmF5LmlzQXJyYXkgPT09ICdmdW5jdGlvbidcbiAgICA/IEFycmF5LmlzQXJyYXlcbiAgICA6IGZ1bmN0aW9uICh4cykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgIH1cbjtcbmZ1bmN0aW9uIGluZGV4T2YgKHhzLCB4KSB7XG4gICAgaWYgKHhzLmluZGV4T2YpIHJldHVybiB4cy5pbmRleE9mKHgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHggPT09IHhzW2ldKSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuXG4vLyAxMCBsaXN0ZW5lcnMgYXJlIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2hcbi8vIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuLy9cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSB7fTtcbiAgdGhpcy5fZXZlbnRzLm1heExpc3RlbmVycyA9IG47XG59O1xuXG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzQXJyYXkodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpXG4gICAge1xuICAgICAgaWYgKGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGFyZ3VtZW50c1sxXTsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuY2F1Z2h0LCB1bnNwZWNpZmllZCAnZXJyb3InIGV2ZW50LlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRoaXMuX2V2ZW50cykgcmV0dXJuIGZhbHNlO1xuICB2YXIgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgaWYgKCFoYW5kbGVyKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09ICdmdW5jdGlvbicpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKGlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gRXZlbnRFbWl0dGVyIGlzIGRlZmluZWQgaW4gc3JjL25vZGVfZXZlbnRzLmNjXG4vLyBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQoKSBpcyBhbHNvIGRlZmluZWQgdGhlcmUuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBsaXN0ZW5lcikge1xuICAgIHRocm93IG5ldyBFcnJvcignYWRkTGlzdGVuZXIgb25seSB0YWtlcyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09IFwibmV3TGlzdGVuZXJzXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyc1wiLlxuICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIH0gZWxzZSBpZiAoaXNBcnJheSh0aGlzLl9ldmVudHNbdHlwZV0pKSB7XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgICAgdmFyIG07XG4gICAgICBpZiAodGhpcy5fZXZlbnRzLm1heExpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG0gPSB0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbSA9IGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgICB9XG5cbiAgICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLm9uKHR5cGUsIGZ1bmN0aW9uIGcoKSB7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcbiAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGxpc3RlbmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmVMaXN0ZW5lciBvbmx5IHRha2VzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpO1xuICB9XG5cbiAgLy8gZG9lcyBub3QgdXNlIGxpc3RlbmVycygpLCBzbyBubyBzaWRlIGVmZmVjdCBvZiBjcmVhdGluZyBfZXZlbnRzW3R5cGVdXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pIHJldHVybiB0aGlzO1xuXG4gIHZhciBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0FycmF5KGxpc3QpKSB7XG4gICAgdmFyIGkgPSBpbmRleE9mKGxpc3QsIGxpc3RlbmVyKTtcbiAgICBpZiAoaSA8IDApIHJldHVybiB0aGlzO1xuICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgIGlmIChsaXN0Lmxlbmd0aCA9PSAwKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgfSBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0gPT09IGxpc3RlbmVyKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBkb2VzIG5vdCB1c2UgbGlzdGVuZXJzKCksIHNvIG5vIHNpZGUgZWZmZWN0IG9mIGNyZWF0aW5nIF9ldmVudHNbdHlwZV1cbiAgaWYgKHR5cGUgJiYgdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1t0eXBlXSkgdGhpcy5fZXZlbnRzW3R5cGVdID0gbnVsbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMpIHRoaXMuX2V2ZW50cyA9IHt9O1xuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSkgdGhpcy5fZXZlbnRzW3R5cGVdID0gW107XG4gIGlmICghaXNBcnJheSh0aGlzLl9ldmVudHNbdHlwZV0pKSB7XG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2V2ZW50c1t0eXBlXTtcbn07XG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfcHJvY2Vzc1wiKSlcbn0se1wiX19icm93c2VyaWZ5X3Byb2Nlc3NcIjo4fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24oKXtmdW5jdGlvbiBTbG93QnVmZmVyIChzaXplKSB7XG4gICAgdGhpcy5sZW5ndGggPSBzaXplO1xufTtcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTA7XG5cblxuZnVuY3Rpb24gdG9IZXgobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNik7XG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KTtcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspXG4gICAgaWYgKHN0ci5jaGFyQ29kZUF0KGkpIDw9IDB4N0YpXG4gICAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSk7XG4gICAgZWxzZSB7XG4gICAgICB2YXIgaCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHIuY2hhckF0KGkpKS5zdWJzdHIoMSkuc3BsaXQoJyUnKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaC5sZW5ndGg7IGorKylcbiAgICAgICAgYnl0ZUFycmF5LnB1c2gocGFyc2VJbnQoaFtqXSwgMTYpKTtcbiAgICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheTtcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKysgKVxuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKCBzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYgKTtcblxuICByZXR1cm4gYnl0ZUFycmF5O1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzKHN0cikge1xuICByZXR1cm4gcmVxdWlyZShcImJhc2U2NC1qc1wiKS50b0J5dGVBcnJheShzdHIpO1xufVxuXG5TbG93QnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xuICBzd2l0Y2ggKGVuY29kaW5nIHx8IFwidXRmOFwiKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiBzdHIubGVuZ3RoIC8gMjtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aDtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiBzdHIubGVuZ3RoO1xuXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cikubGVuZ3RoO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBibGl0QnVmZmVyKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgcG9zLCBpID0gMDtcbiAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICBpZiAoKGkrb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKVxuICAgICAgYnJlYWs7XG5cbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV07XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiBpO1xufVxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS51dGY4V3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgYnl0ZXMsIHBvcztcbiAgcmV0dXJuIFNsb3dCdWZmZXIuX2NoYXJzV3JpdHRlbiA9ICBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZyksIHRoaXMsIG9mZnNldCwgbGVuZ3RoKTtcbn07XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmFzY2lpV3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgYnl0ZXMsIHBvcztcbiAgcmV0dXJuIFNsb3dCdWZmZXIuX2NoYXJzV3JpdHRlbiA9ICBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCB0aGlzLCBvZmZzZXQsIGxlbmd0aCk7XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5iYXNlNjRXcml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBieXRlcywgcG9zO1xuICByZXR1cm4gU2xvd0J1ZmZlci5fY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIHRoaXMsIG9mZnNldCwgbGVuZ3RoKTtcbn07XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmJhc2U2NFNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgcmV0dXJuIHJlcXVpcmUoXCJiYXNlNjQtanNcIikuZnJvbUJ5dGVBcnJheShieXRlcyk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKTsgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUudXRmOFNsaWNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdmFyIHJlcyA9IFwiXCI7XG4gIHZhciB0bXAgPSBcIlwiO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgaWYgKGJ5dGVzW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gICAgICB0bXAgPSBcIlwiO1xuICAgIH0gZWxzZVxuICAgICAgdG1wICs9IFwiJVwiICsgYnl0ZXNbaV0udG9TdHJpbmcoMTYpO1xuXG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcCk7XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmFzY2lpU2xpY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBieXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB2YXIgcmV0ID0gXCJcIjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKylcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gIHJldHVybiByZXQ7XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG91dCA9IFtdLFxuICAgICAgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBvdXRbaV0gPSB0b0hleCh0aGlzW2ldKTtcbiAgICBpZiAoaSA9PSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTKSB7XG4gICAgICBvdXRbaSArIDFdID0gJy4uLic7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICc8U2xvd0J1ZmZlciAnICsgb3V0LmpvaW4oJyAnKSArICc+Jztcbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuaGV4U2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwO1xuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuO1xuXG4gIHZhciBvdXQgPSAnJztcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgodGhpc1tpXSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG4gIHN0YXJ0ID0gK3N0YXJ0IHx8IDA7XG4gIGlmICh0eXBlb2YgZW5kID09ICd1bmRlZmluZWQnKSBlbmQgPSB0aGlzLmxlbmd0aDtcblxuICAvLyBGYXN0cGF0aCBlbXB0eSBzdHJpbmdzXG4gIGlmICgrZW5kID09IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXR1cm4gdGhpcy5oZXhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB0aGlzLnV0ZjhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiB0aGlzLmFzY2lpU2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIHRoaXMuYmFzZTY0U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXR1cm4gdGhpcy51Y3MyU2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJyk7XG4gIH1cbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuaGV4V3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9ICtvZmZzZXQgfHwgMDtcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSArbGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgaWYgKHN0ckxlbiAlIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpO1xuICB9XG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMjtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ5dGUgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpO1xuICAgIGlmIChpc05hTihieXRlKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKTtcbiAgICB0aGlzW29mZnNldCArIGldID0gYnl0ZTtcbiAgfVxuICBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSBpICogMjtcbiAgcmV0dXJuIGk7XG59O1xuXG5cblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gU3VwcG9ydCBib3RoIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZylcbiAgLy8gYW5kIHRoZSBsZWdhY3kgKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICBsZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG9mZnNldDtcbiAgICBvZmZzZXQgPSBsZW5ndGg7XG4gICAgbGVuZ3RoID0gc3dhcDtcbiAgfVxuXG4gIG9mZnNldCA9ICtvZmZzZXQgfHwgMDtcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSArbGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIHRoaXMuaGV4V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXR1cm4gdGhpcy51dGY4V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXR1cm4gdGhpcy5hc2NpaVdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldHVybiB0aGlzLmJpbmFyeVdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldHVybiB0aGlzLmJhc2U2NFdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgICAgcmV0dXJuIHRoaXMudWNzMldyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG59O1xuXG5cbi8vIHNsaWNlKHN0YXJ0LCBlbmQpXG5TbG93QnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSBlbmQgPSB0aGlzLmxlbmd0aDtcblxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICB9XG4gIGlmIChzdGFydCA+IGVuZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignb29iJyk7XG4gIH1cblxuICByZXR1cm4gbmV3IEJ1ZmZlcih0aGlzLCBlbmQgLSBzdGFydCwgK3N0YXJ0KTtcbn07XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbih0YXJnZXQsIHRhcmdldHN0YXJ0LCBzb3VyY2VzdGFydCwgc291cmNlZW5kKSB7XG4gIHZhciB0ZW1wID0gW107XG4gIGZvciAodmFyIGk9c291cmNlc3RhcnQ7IGk8c291cmNlZW5kOyBpKyspIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIHRoaXNbaV0gIT09ICd1bmRlZmluZWQnLCBcImNvcHlpbmcgdW5kZWZpbmVkIGJ1ZmZlciBieXRlcyFcIik7XG4gICAgdGVtcC5wdXNoKHRoaXNbaV0pO1xuICB9XG5cbiAgZm9yICh2YXIgaT10YXJnZXRzdGFydDsgaTx0YXJnZXRzdGFydCt0ZW1wLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFyZ2V0W2ldID0gdGVtcFtpLXRhcmdldHN0YXJ0XTtcbiAgfVxufTtcblxuZnVuY3Rpb24gY29lcmNlKGxlbmd0aCkge1xuICAvLyBDb2VyY2UgbGVuZ3RoIHRvIGEgbnVtYmVyIChwb3NzaWJseSBOYU4pLCByb3VuZCB1cFxuICAvLyBpbiBjYXNlIGl0J3MgZnJhY3Rpb25hbCAoZS5nLiAxMjMuNDU2KSB0aGVuIGRvIGFcbiAgLy8gZG91YmxlIG5lZ2F0ZSB0byBjb2VyY2UgYSBOYU4gdG8gMC4gRWFzeSwgcmlnaHQ/XG4gIGxlbmd0aCA9IH5+TWF0aC5jZWlsKCtsZW5ndGgpO1xuICByZXR1cm4gbGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGg7XG59XG5cblxuLy8gQnVmZmVyXG5cbmZ1bmN0aW9uIEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgb2Zmc2V0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG9mZnNldCk7XG4gIH1cblxuICB2YXIgdHlwZTtcblxuICAvLyBBcmUgd2Ugc2xpY2luZz9cbiAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgdGhpcy5sZW5ndGggPSBjb2VyY2UoZW5jb2RpbmcpO1xuICAgIHRoaXMucGFyZW50ID0gc3ViamVjdDtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgfSBlbHNlIHtcbiAgICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgICBzd2l0Y2ggKHR5cGUgPSB0eXBlb2Ygc3ViamVjdCkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgdGhpcy5sZW5ndGggPSBjb2VyY2Uoc3ViamVjdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICB0aGlzLmxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN1YmplY3QsIGVuY29kaW5nKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6IC8vIEFzc3VtZSBvYmplY3QgaXMgYW4gYXJyYXlcbiAgICAgICAgdGhpcy5sZW5ndGggPSBjb2VyY2Uoc3ViamVjdC5sZW5ndGgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBuZWVkcyB0byBiZSBhIG51bWJlciwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXJyYXkgb3Igc3RyaW5nLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IEJ1ZmZlci5wb29sU2l6ZSkge1xuICAgICAgLy8gQmlnIGJ1ZmZlciwganVzdCBhbGxvYyBvbmUuXG4gICAgICB0aGlzLnBhcmVudCA9IG5ldyBTbG93QnVmZmVyKHRoaXMubGVuZ3RoKTtcbiAgICAgIHRoaXMub2Zmc2V0ID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTbWFsbCBidWZmZXIuXG4gICAgICBpZiAoIXBvb2wgfHwgcG9vbC5sZW5ndGggLSBwb29sLnVzZWQgPCB0aGlzLmxlbmd0aCkgYWxsb2NQb29sKCk7XG4gICAgICB0aGlzLnBhcmVudCA9IHBvb2w7XG4gICAgICB0aGlzLm9mZnNldCA9IHBvb2wudXNlZDtcbiAgICAgIHBvb2wudXNlZCArPSB0aGlzLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXkuXG4gICAgaWYgKGlzQXJyYXlJc2goc3ViamVjdCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnBhcmVudFtpICsgdGhpcy5vZmZzZXRdID0gc3ViamVjdFtpXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFdlIGFyZSBhIHN0cmluZ1xuICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLndyaXRlKHN1YmplY3QsIDAsIGVuY29kaW5nKTtcbiAgICB9XG4gIH1cblxufVxuXG5mdW5jdGlvbiBpc0FycmF5SXNoKHN1YmplY3QpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoc3ViamVjdCkgfHwgQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpIHx8XG4gICAgICAgICBzdWJqZWN0ICYmIHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgdHlwZW9mIHN1YmplY3QubGVuZ3RoID09PSAnbnVtYmVyJztcbn1cblxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlcjtcbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyO1xuXG5CdWZmZXIucG9vbFNpemUgPSA4ICogMTAyNDtcbnZhciBwb29sO1xuXG5mdW5jdGlvbiBhbGxvY1Bvb2woKSB7XG4gIHBvb2wgPSBuZXcgU2xvd0J1ZmZlcihCdWZmZXIucG9vbFNpemUpO1xuICBwb29sLnVzZWQgPSAwO1xufVxuXG5cbi8vIFN0YXRpYyBtZXRob2RzXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlcihiKSB7XG4gIHJldHVybiBiIGluc3RhbmNlb2YgQnVmZmVyIHx8IGIgaW5zdGFuY2VvZiBTbG93QnVmZmVyO1xufTtcblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2FnZTogQnVmZmVyLmNvbmNhdChsaXN0LCBbdG90YWxMZW5ndGhdKVxcbiBcXFxuICAgICAgbGlzdCBzaG91bGQgYmUgYW4gQXJyYXkuXCIpO1xuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMCk7XG4gIH0gZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbGlzdFswXTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdG90YWxMZW5ndGggIT09ICdudW1iZXInKSB7XG4gICAgdG90YWxMZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGJ1ZiA9IGxpc3RbaV07XG4gICAgICB0b3RhbExlbmd0aCArPSBidWYubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKHRvdGFsTGVuZ3RoKTtcbiAgdmFyIHBvcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBidWYgPSBsaXN0W2ldO1xuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKTtcbiAgICBwb3MgKz0gYnVmLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gYnVmZmVyO1xufTtcblxuLy8gSW5zcGVjdFxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgdmFyIG91dCA9IFtdLFxuICAgICAgbGVuID0gdGhpcy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dFtpXSA9IHRvSGV4KHRoaXMucGFyZW50W2kgKyB0aGlzLm9mZnNldF0pO1xuICAgIGlmIChpID09IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMpIHtcbiAgICAgIG91dFtpICsgMV0gPSAnLi4uJztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgb3V0LmpvaW4oJyAnKSArICc+Jztcbn07XG5cblxuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQoaSkge1xuICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgcmV0dXJuIHRoaXMucGFyZW50W3RoaXMub2Zmc2V0ICsgaV07XG59O1xuXG5cbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KGksIHYpIHtcbiAgaWYgKGkgPCAwIHx8IGkgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignb29iJyk7XG4gIHJldHVybiB0aGlzLnBhcmVudFt0aGlzLm9mZnNldCArIGldID0gdjtcbn07XG5cblxuLy8gd3JpdGUoc3RyaW5nLCBvZmZzZXQgPSAwLCBsZW5ndGggPSBidWZmZXIubGVuZ3RoLW9mZnNldCwgZW5jb2RpbmcgPSAndXRmOCcpXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gU3VwcG9ydCBib3RoIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZylcbiAgLy8gYW5kIHRoZSBsZWdhY3kgKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICBsZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG9mZnNldDtcbiAgICBvZmZzZXQgPSBsZW5ndGg7XG4gICAgbGVuZ3RoID0gc3dhcDtcbiAgfVxuXG4gIG9mZnNldCA9ICtvZmZzZXQgfHwgMDtcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSArbGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHZhciByZXQ7XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuaGV4V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQudXRmOFdyaXRlKHN0cmluZywgdGhpcy5vZmZzZXQgKyBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IHRoaXMucGFyZW50LmFzY2lpV3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IHRoaXMucGFyZW50LmJpbmFyeVdyaXRlKHN0cmluZywgdGhpcy5vZmZzZXQgKyBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuYmFzZTY0V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQudWNzMldyaXRlKHN0cmluZywgdGhpcy5vZmZzZXQgKyBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxuXG4gIEJ1ZmZlci5fY2hhcnNXcml0dGVuID0gU2xvd0J1ZmZlci5fY2hhcnNXcml0dGVuO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5cbi8vIHRvU3RyaW5nKGVuY29kaW5nLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKHR5cGVvZiBzdGFydCA9PSAndW5kZWZpbmVkJyB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDA7XG4gIH0gZWxzZSBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHN0YXJ0ID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuZCA9PSAndW5kZWZpbmVkJyB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICB9IGVsc2UgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgPSAwO1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCArIHRoaXMub2Zmc2V0O1xuICBlbmQgPSBlbmQgKyB0aGlzLm9mZnNldDtcblxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5oZXhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC51dGY4U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuYXNjaWlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuYmluYXJ5U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmJhc2U2NFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnVjczJTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxufTtcblxuXG4vLyBieXRlTGVuZ3RoXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IFNsb3dCdWZmZXIuYnl0ZUxlbmd0aDtcblxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgdmFsdWUgfHwgKHZhbHVlID0gMCk7XG4gIHN0YXJ0IHx8IChzdGFydCA9IDApO1xuICBlbmQgfHwgKGVuZCA9IHRoaXMubGVuZ3RoKTtcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gdmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgfVxuICBpZiAoISh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB8fCBpc05hTih2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbHVlIGlzIG5vdCBhIG51bWJlcicpO1xuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgRXJyb3IoJ2VuZCA8IHN0YXJ0Jyk7XG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMDtcbiAgaWYgKHRoaXMubGVuZ3RoID09IDApIHJldHVybiAwO1xuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0IG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbmQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMucGFyZW50LmZpbGwodmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ICsgdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCArIHRoaXMub2Zmc2V0KTtcbn07XG5cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24odGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gIHN0YXJ0IHx8IChzdGFydCA9IDApO1xuICBlbmQgfHwgKGVuZCA9IHRoaXMubGVuZ3RoKTtcbiAgdGFyZ2V0X3N0YXJ0IHx8ICh0YXJnZXRfc3RhcnQgPSAwKTtcblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBFcnJvcignc291cmNlRW5kIDwgc291cmNlU3RhcnQnKTtcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwO1xuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PSAwIHx8IHNvdXJjZS5sZW5ndGggPT0gMCkgcmV0dXJuIDA7XG5cbiAgaWYgKHRhcmdldF9zdGFydCA8IDAgfHwgdGFyZ2V0X3N0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gc291cmNlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gc291cmNlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgKyBzdGFydDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLnBhcmVudC5jb3B5KHRhcmdldC5wYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldF9zdGFydCArIHRhcmdldC5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ICsgdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCArIHRoaXMub2Zmc2V0KTtcbn07XG5cblxuLy8gc2xpY2Uoc3RhcnQsIGVuZClcbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkgZW5kID0gdGhpcy5sZW5ndGg7XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgaWYgKHN0YXJ0ID4gZW5kKSB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuXG4gIHJldHVybiBuZXcgQnVmZmVyKHRoaXMucGFyZW50LCBlbmQgLSBzdGFydCwgK3N0YXJ0ICsgdGhpcy5vZmZzZXQpO1xufTtcblxuXG4vLyBMZWdhY3kgbWV0aG9kcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5cbkJ1ZmZlci5wcm90b3R5cGUudXRmOFNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygndXRmOCcsIHN0YXJ0LCBlbmQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5iaW5hcnlTbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHRoaXMudG9TdHJpbmcoJ2JpbmFyeScsIHN0YXJ0LCBlbmQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5hc2NpaVNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygnYXNjaWknLCBzdGFydCwgZW5kKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUudXRmOFdyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMud3JpdGUoc3RyaW5nLCBvZmZzZXQsICd1dGY4Jyk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmJpbmFyeVdyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMud3JpdGUoc3RyaW5nLCBvZmZzZXQsICdiaW5hcnknKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuYXNjaWlXcml0ZSA9IGZ1bmN0aW9uKHN0cmluZywgb2Zmc2V0KSB7XG4gIHJldHVybiB0aGlzLndyaXRlKHN0cmluZywgb2Zmc2V0LCAnYXNjaWknKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YXIgYnVmZmVyID0gdGhpcztcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRVSW50MTYoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YXIgdmFsID0gMDtcblxuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIGlmIChpc0JpZ0VuZGlhbikge1xuICAgIHZhbCA9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPDwgODtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV07XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XTtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgODtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQxNih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MTYodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiByZWFkVUludDMyKGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFyIHZhbCA9IDA7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgaWYgKGlzQmlnRW5kaWFuKSB7XG4gICAgdmFsID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgMTY7XG4gICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDJdIDw8IDg7XG4gICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDNdO1xuICAgIHZhbCA9IHZhbCArIChidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdIDw8IDI0ID4+PiAwKTtcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAyXSA8PCAxNjtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgODtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XTtcbiAgICB2YWwgPSB2YWwgKyAoYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgM10gPDwgMjQgPj4+IDApO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFNpZ25lZCBpbnRlZ2VyIHR5cGVzLCB5YXkgdGVhbSEgQSByZW1pbmRlciBvbiBob3cgdHdvJ3MgY29tcGxlbWVudCBhY3R1YWxseVxuICogd29ya3MuIFRoZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ25lZCBiaXQsIGkuZS4gdGVsbHMgdXMgd2hldGhlciBvciBub3QgdGhlXG4gKiBudW1iZXIgc2hvdWxkIGJlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLiBJZiB0aGUgdHdvJ3MgY29tcGxlbWVudCB2YWx1ZSBpc1xuICogcG9zaXRpdmUsIHRoZW4gd2UncmUgZG9uZSwgYXMgaXQncyBlcXVpdmFsZW50IHRvIHRoZSB1bnNpZ25lZCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBOb3cgaWYgdGhlIG51bWJlciBpcyBwb3NpdGl2ZSwgeW91J3JlIHByZXR0eSBtdWNoIGRvbmUsIHlvdSBjYW4ganVzdCBsZXZlcmFnZVxuICogdGhlIHVuc2lnbmVkIHRyYW5zbGF0aW9ucyBhbmQgcmV0dXJuIHRob3NlLiBVbmZvcnR1bmF0ZWx5LCBuZWdhdGl2ZSBudW1iZXJzXG4gKiBhcmVuJ3QgcXVpdGUgdGhhdCBzdHJhaWdodGZvcndhcmQuXG4gKlxuICogQXQgZmlyc3QgZ2xhbmNlLCBvbmUgbWlnaHQgYmUgaW5jbGluZWQgdG8gdXNlIHRoZSB0cmFkaXRpb25hbCBmb3JtdWxhIHRvXG4gKiB0cmFuc2xhdGUgYmluYXJ5IG51bWJlcnMgYmV0d2VlbiB0aGUgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcyBpbiB0d28nc1xuICogY29tcGxlbWVudC4gKFRob3VnaCBpdCBkb2Vzbid0IHF1aXRlIHdvcmsgZm9yIHRoZSBtb3N0IG5lZ2F0aXZlIHZhbHVlKVxuICogTWFpbmx5OlxuICogIC0gaW52ZXJ0IGFsbCB0aGUgYml0c1xuICogIC0gYWRkIG9uZSB0byB0aGUgcmVzdWx0XG4gKlxuICogT2YgY291cnNlLCB0aGlzIGRvZXNuJ3QgcXVpdGUgd29yayBpbiBKYXZhc2NyaXB0LiBUYWtlIGZvciBleGFtcGxlIHRoZSB2YWx1ZVxuICogb2YgLTEyOC4gVGhpcyBjb3VsZCBiZSByZXByZXNlbnRlZCBpbiAxNiBiaXRzIChiaWctZW5kaWFuKSBhcyAweGZmODAuIEJ1dCBvZlxuICogY291cnNlLCBKYXZhc2NyaXB0IHdpbGwgZG8gdGhlIGZvbGxvd2luZzpcbiAqXG4gKiA+IH4weGZmODBcbiAqIC02NTQwOVxuICpcbiAqIFdob2ggdGhlcmUsIEphdmFzY3JpcHQsIHRoYXQncyBub3QgcXVpdGUgcmlnaHQuIEJ1dCB3YWl0LCBhY2NvcmRpbmcgdG9cbiAqIEphdmFzY3JpcHQgdGhhdCdzIHBlcmZlY3RseSBjb3JyZWN0LiBXaGVuIEphdmFzY3JpcHQgZW5kcyB1cCBzZWVpbmcgdGhlXG4gKiBjb25zdGFudCAweGZmODAsIGl0IGhhcyBubyBub3Rpb24gdGhhdCBpdCBpcyBhY3R1YWxseSBhIHNpZ25lZCBudW1iZXIuIEl0XG4gKiBhc3N1bWVzIHRoYXQgd2UndmUgaW5wdXQgdGhlIHVuc2lnbmVkIHZhbHVlIDB4ZmY4MC4gVGh1cywgd2hlbiBpdCBkb2VzIHRoZVxuICogYmluYXJ5IG5lZ2F0aW9uLCBpdCBjYXN0cyBpdCBpbnRvIGEgc2lnbmVkIHZhbHVlLCAocG9zaXRpdmUgMHhmZjgwKS4gVGhlblxuICogd2hlbiB5b3UgcGVyZm9ybSBiaW5hcnkgbmVnYXRpb24gb24gdGhhdCwgaXQgdHVybnMgaXQgaW50byBhIG5lZ2F0aXZlIG51bWJlci5cbiAqXG4gKiBJbnN0ZWFkLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIHVzZSB0aGUgZm9sbG93aW5nIGdlbmVyYWwgZm9ybXVsYSwgdGhhdCB3b3Jrc1xuICogaW4gYSByYXRoZXIgSmF2YXNjcmlwdCBmcmllbmRseSB3YXkuIEknbSBnbGFkIHdlIGRvbid0IHN1cHBvcnQgdGhpcyBraW5kIG9mXG4gKiB3ZWlyZCBudW1iZXJpbmcgc2NoZW1lIGluIHRoZSBrZXJuZWwuXG4gKlxuICogKEJJVC1NQVggLSAodW5zaWduZWQpdmFsICsgMSkgKiAtMVxuICpcbiAqIFRoZSBhc3R1dGUgb2JzZXJ2ZXIsIG1heSB0aGluayB0aGF0IHRoaXMgZG9lc24ndCBtYWtlIHNlbnNlIGZvciA4LWJpdCBudW1iZXJzXG4gKiAocmVhbGx5IGl0IGlzbid0IG5lY2Vzc2FyeSBmb3IgdGhlbSkuIEhvd2V2ZXIsIHdoZW4geW91IGdldCAxNi1iaXQgbnVtYmVycyxcbiAqIHlvdSBkby4gTGV0J3MgZ28gYmFjayB0byBvdXIgcHJpb3IgZXhhbXBsZSBhbmQgc2VlIGhvdyB0aGlzIHdpbGwgbG9vazpcbiAqXG4gKiAoMHhmZmZmIC0gMHhmZjgwICsgMSkgKiAtMVxuICogKDB4MDA3ZiArIDEpICogLTFcbiAqICgweDAwODApICogLTFcbiAqL1xuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG4gIHZhciBuZWc7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgbmVnID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSAmIDB4ODA7XG4gIGlmICghbmVnKSB7XG4gICAgcmV0dXJuIChidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdKTtcbiAgfVxuXG4gIHJldHVybiAoKDB4ZmYgLSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdICsgMSkgKiAtMSk7XG59O1xuXG5mdW5jdGlvbiByZWFkSW50MTYoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YXIgbmVnLCB2YWw7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgdmFsID0gcmVhZFVJbnQxNihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgbmVnID0gdmFsICYgMHg4MDAwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICByZXR1cm4gKDB4ZmZmZiAtIHZhbCArIDEpICogLTE7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRJbnQzMihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciBuZWcsIHZhbDtcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICB2YWwgPSByZWFkVUludDMyKGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICBuZWcgPSB2YWwgJiAweDgwMDAwMDAwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiAodmFsKTtcbiAgfVxuXG4gIHJldHVybiAoMHhmZmZmZmZmZiAtIHZhbCArIDEpICogLTE7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRGbG9hdChidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLnJlYWRJRUVFNzU0KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDIzLCA0KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gcmVhZERvdWJsZShidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyA3IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLnJlYWRJRUVFNzU0KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDUyLCA4KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaW50ZWdlci4gVGhpcyBtZWFucyB0aGF0IGl0IGlzXG4gKiBub24tbmVnYXRpdmUuIEl0IGhhcyBubyBmcmFjdGlvbmFsIGNvbXBvbmVudCBhbmQgdGhhdCBpdCBkb2VzIG5vdCBleGNlZWQgdGhlXG4gKiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUuXG4gKlxuICogICAgICB2YWx1ZSAgICAgICAgICAgVGhlIG51bWJlciB0byBjaGVjayBmb3IgdmFsaWRpdHlcbiAqXG4gKiAgICAgIG1heCAgICAgICAgICAgICBUaGUgbWF4aW11bSB2YWx1ZVxuICovXG5mdW5jdGlvbiB2ZXJpZnVpbnQodmFsdWUsIG1heCkge1xuICBhc3NlcnQub2sodHlwZW9mICh2YWx1ZSkgPT0gJ251bWJlcicsXG4gICAgICAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA+PSAwLFxuICAgICAgJ3NwZWNpZmllZCBhIG5lZ2F0aXZlIHZhbHVlIGZvciB3cml0aW5nIGFuIHVuc2lnbmVkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGlzIGxhcmdlciB0aGFuIG1heGltdW0gdmFsdWUgZm9yIHR5cGUnKTtcblxuICBhc3NlcnQub2soTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmKTtcbiAgfVxuXG4gIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSB2YWx1ZTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlVUludDE2KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmKTtcbiAgfVxuXG4gIGlmIChpc0JpZ0VuZGlhbikge1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSAodmFsdWUgJiAweGZmMDApID4+PiA4O1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDFdID0gdmFsdWUgJiAweDAwZmY7XG4gIH0gZWxzZSB7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmMDApID4+PiA4O1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSB2YWx1ZSAmIDB4MDBmZjtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVVSW50MzIoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmZmZmZmKTtcbiAgfVxuXG4gIGlmIChpc0JpZ0VuZGlhbikge1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSAodmFsdWUgPj4+IDI0KSAmIDB4ZmY7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpICYgMHhmZjtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAzXSA9IHZhbHVlICYgMHhmZjtcbiAgfSBlbHNlIHtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpICYgMHhmZjtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpICYgMHhmZjtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCkgJiAweGZmO1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSB2YWx1ZSAmIDB4ZmY7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFdlIG5vdyBtb3ZlIG9udG8gb3VyIGZyaWVuZHMgaW4gdGhlIHNpZ25lZCBudW1iZXIgY2F0ZWdvcnkuIFVubGlrZSB1bnNpZ25lZFxuICogbnVtYmVycywgd2UncmUgZ29pbmcgdG8gaGF2ZSB0byB3b3JyeSBhIGJpdCBtb3JlIGFib3V0IGhvdyB3ZSBwdXQgdmFsdWVzIGludG9cbiAqIGFycmF5cy4gU2luY2Ugd2UgYXJlIG9ubHkgd29ycnlpbmcgYWJvdXQgc2lnbmVkIDMyLWJpdCB2YWx1ZXMsIHdlJ3JlIGluXG4gKiBzbGlnaHRseSBiZXR0ZXIgc2hhcGUuIFVuZm9ydHVuYXRlbHksIHdlIHJlYWxseSBjYW4ndCBkbyBvdXIgZmF2b3JpdGUgYmluYXJ5XG4gKiAmIGluIHRoaXMgc3lzdGVtLiBJdCByZWFsbHkgc2VlbXMgdG8gZG8gdGhlIHdyb25nIHRoaW5nLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiA+IC0zMiAmIDB4ZmZcbiAqIDIyNFxuICpcbiAqIFdoYXQncyBoYXBwZW5pbmcgYWJvdmUgaXMgcmVhbGx5OiAweGUwICYgMHhmZiA9IDB4ZTAuIEhvd2V2ZXIsIHRoZSByZXN1bHRzIG9mXG4gKiB0aGlzIGFyZW4ndCB0cmVhdGVkIGFzIGEgc2lnbmVkIG51bWJlci4gVWx0aW1hdGVseSBhIGJhZCB0aGluZy5cbiAqXG4gKiBXaGF0IHdlJ3JlIGdvaW5nIHRvIHdhbnQgdG8gZG8gaXMgYmFzaWNhbGx5IGNyZWF0ZSB0aGUgdW5zaWduZWQgZXF1aXZhbGVudCBvZlxuICogb3VyIHJlcHJlc2VudGF0aW9uIGFuZCBwYXNzIHRoYXQgb2ZmIHRvIHRoZSB3dWludCogZnVuY3Rpb25zLiBUbyBkbyB0aGF0XG4gKiB3ZSdyZSBnb2luZyB0byBkbyB0aGUgZm9sbG93aW5nOlxuICpcbiAqICAtIGlmIHRoZSB2YWx1ZSBpcyBwb3NpdGl2ZVxuICogICAgICB3ZSBjYW4gcGFzcyBpdCBkaXJlY3RseSBvZmYgdG8gdGhlIGVxdWl2YWxlbnQgd3VpbnRcbiAqICAtIGlmIHRoZSB2YWx1ZSBpcyBuZWdhdGl2ZVxuICogICAgICB3ZSBkbyB0aGUgZm9sbG93aW5nIGNvbXB1dGF0aW9uOlxuICogICAgICAgICBtYiArIHZhbCArIDEsIHdoZXJlXG4gKiAgICAgICAgIG1iICAgaXMgdGhlIG1heGltdW0gdW5zaWduZWQgdmFsdWUgaW4gdGhhdCBieXRlIHNpemVcbiAqICAgICAgICAgdmFsICBpcyB0aGUgSmF2YXNjcmlwdCBuZWdhdGl2ZSBpbnRlZ2VyXG4gKlxuICpcbiAqIEFzIGEgY29uY3JldGUgdmFsdWUsIHRha2UgLTEyOC4gSW4gc2lnbmVkIDE2IGJpdHMgdGhpcyB3b3VsZCBiZSAweGZmODAuIElmXG4gKiB5b3UgZG8gb3V0IHRoZSBjb21wdXRhdGlvbnM6XG4gKlxuICogMHhmZmZmIC0gMTI4ICsgMVxuICogMHhmZmZmIC0gMTI3XG4gKiAweGZmODBcbiAqXG4gKiBZb3UgY2FuIHRoZW4gZW5jb2RlIHRoaXMgdmFsdWUgYXMgdGhlIHNpZ25lZCB2ZXJzaW9uLiBUaGlzIGlzIHJlYWxseSByYXRoZXJcbiAqIGhhY2t5LCBidXQgaXQgc2hvdWxkIHdvcmsgYW5kIGdldCB0aGUgam9iIGRvbmUgd2hpY2ggaXMgb3VyIGdvYWwgaGVyZS5cbiAqL1xuXG4vKlxuICogQSBzZXJpZXMgb2YgY2hlY2tzIHRvIG1ha2Ugc3VyZSB3ZSBhY3R1YWxseSBoYXZlIGEgc2lnbmVkIDMyLWJpdCBudW1iZXJcbiAqL1xuZnVuY3Rpb24gdmVyaWZzaW50KHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQub2sodHlwZW9mICh2YWx1ZSkgPT0gJ251bWJlcicsXG4gICAgICAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKTtcblxuICBhc3NlcnQub2sodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpO1xuXG4gIGFzc2VydC5vayhNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpO1xufVxuXG5mdW5jdGlvbiB2ZXJpZklFRUU3NTQodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydC5vayh0eXBlb2YgKHZhbHVlKSA9PSAnbnVtYmVyJyxcbiAgICAgICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJyk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmLCAtMHg4MCk7XG4gIH1cblxuICBpZiAodmFsdWUgPj0gMCkge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KTtcbiAgfSBlbHNlIHtcbiAgICBidWZmZXIud3JpdGVVSW50OCgweGZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIG5vQXNzZXJ0KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gd3JpdGVJbnQxNihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZiwgLTB4ODAwMCk7XG4gIH1cblxuICBpZiAodmFsdWUgPj0gMCkge1xuICAgIHdyaXRlVUludDE2KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgfSBlbHNlIHtcbiAgICB3cml0ZVVJbnQxNihidWZmZXIsIDB4ZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlSW50MzIoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMCk7XG4gIH1cblxuICBpZiAodmFsdWUgPj0gMCkge1xuICAgIHdyaXRlVUludDMyKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgfSBlbHNlIHtcbiAgICB3cml0ZVVJbnQzMihidWZmZXIsIDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUZsb2F0KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpO1xuICB9XG5cbiAgcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLndyaXRlSUVFRTc1NChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLFxuICAgICAgMjMsIDQpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZURvdWJsZShidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDcgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpO1xuICB9XG5cbiAgcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLndyaXRlSUVFRTc1NChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLFxuICAgICAgNTIsIDgpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDg7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50ODtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4O1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4O1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkU7XG5cbn0pKClcbn0se1wiYXNzZXJ0XCI6MixcIi4vYnVmZmVyX2llZWU3NTRcIjo3LFwiYmFzZTY0LWpzXCI6OX1dLDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5KGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyO1xuXHRcblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyAnSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCc7XG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHBsYWNlSG9sZGVycyA9IGI2NC5pbmRleE9mKCc9Jyk7XG5cdFx0cGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSBwbGFjZUhvbGRlcnMgOiAwO1xuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gW107Ly9uZXcgVWludDhBcnJheShiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpO1xuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGxvb2t1cC5pbmRleE9mKGI2NFtpXSkgPDwgMTgpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pIDw8IDEyKSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDJdKSA8PCA2KSB8IGxvb2t1cC5pbmRleE9mKGI2NFtpICsgM10pO1xuXHRcdFx0YXJyLnB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNik7XG5cdFx0XHRhcnIucHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KTtcblx0XHRcdGFyci5wdXNoKHRtcCAmIDB4RkYpO1xuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChsb29rdXAuaW5kZXhPZihiNjRbaV0pIDw8IDIpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pID4+IDQpO1xuXHRcdFx0YXJyLnB1c2godG1wICYgMHhGRik7XG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChsb29rdXAuaW5kZXhPZihiNjRbaV0pIDw8IDEwKSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDFdKSA8PCA0KSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDJdKSA+PiAyKTtcblx0XHRcdGFyci5wdXNoKCh0bXAgPj4gOCkgJiAweEZGKTtcblx0XHRcdGFyci5wdXNoKHRtcCAmIDB4RkYpO1xuXHRcdH1cblxuXHRcdHJldHVybiBhcnI7XG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0KHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGg7XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdO1xuXHRcdH07XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKTtcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcCk7XG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbdGVtcCA+PiAyXTtcblx0XHRcdFx0b3V0cHV0ICs9IGxvb2t1cFsodGVtcCA8PCA0KSAmIDB4M0ZdO1xuXHRcdFx0XHRvdXRwdXQgKz0gJz09Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwW3RlbXAgPj4gMTBdO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwWyh0ZW1wID4+IDQpICYgMHgzRl07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbKHRlbXAgPDwgMikgJiAweDNGXTtcblx0XHRcdFx0b3V0cHV0ICs9ICc9Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXk7XG5cdG1vZHVsZS5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0O1xufSgpKTtcblxufSx7fV19LHt9LFtdKVxuOzttb2R1bGUuZXhwb3J0cz1yZXF1aXJlKFwiYnVmZmVyLWJyb3dzZXJpZnlcIilcbiIsIihmdW5jdGlvbihCdWZmZXIpey8vICAgICB1dWlkLmpzXG4vL1xuLy8gICAgIENvcHlyaWdodCAoYykgMjAxMC0yMDEyIFJvYmVydCBLaWVmZmVyXG4vLyAgICAgTUlUIExpY2Vuc2UgLSBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIF9nbG9iYWwgPSB0aGlzO1xuXG4gIC8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuICBXZSBmZWF0dXJlXG4gIC8vIGRldGVjdCB0byBkZXRlcm1pbmUgdGhlIGJlc3QgUk5HIHNvdXJjZSwgbm9ybWFsaXppbmcgdG8gYSBmdW5jdGlvbiB0aGF0XG4gIC8vIHJldHVybnMgMTI4LWJpdHMgb2YgcmFuZG9tbmVzcywgc2luY2UgdGhhdCdzIHdoYXQncyB1c3VhbGx5IHJlcXVpcmVkXG4gIHZhciBfcm5nO1xuXG4gIC8vIE5vZGUuanMgY3J5cHRvLWJhc2VkIFJORyAtIGh0dHA6Ly9ub2RlanMub3JnL2RvY3MvdjAuNi4yL2FwaS9jcnlwdG8uaHRtbFxuICAvL1xuICAvLyBNb2RlcmF0ZWx5IGZhc3QsIGhpZ2ggcXVhbGl0eVxuICBpZiAodHlwZW9mKHJlcXVpcmUpID09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIF9yYiA9IHJlcXVpcmUoJ2NyeXB0bycpLnJhbmRvbUJ5dGVzO1xuICAgICAgX3JuZyA9IF9yYiAmJiBmdW5jdGlvbigpIHtyZXR1cm4gX3JiKDE2KTt9O1xuICAgIH0gY2F0Y2goZSkge31cbiAgfVxuXG4gIGlmICghX3JuZyAmJiBfZ2xvYmFsLmNyeXB0byAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gV0hBVFdHIGNyeXB0by1iYXNlZCBSTkcgLSBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvQ3J5cHRvXG4gICAgLy9cbiAgICAvLyBNb2RlcmF0ZWx5IGZhc3QsIGhpZ2ggcXVhbGl0eVxuICAgIHZhciBfcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgX3JuZyA9IGZ1bmN0aW9uIHdoYXR3Z1JORygpIHtcbiAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoX3JuZHM4KTtcbiAgICAgIHJldHVybiBfcm5kczg7XG4gICAgfTtcbiAgfVxuXG4gIGlmICghX3JuZykge1xuICAgIC8vIE1hdGgucmFuZG9tKCktYmFzZWQgKFJORylcbiAgICAvL1xuICAgIC8vIElmIGFsbCBlbHNlIGZhaWxzLCB1c2UgTWF0aC5yYW5kb20oKS4gIEl0J3MgZmFzdCwgYnV0IGlzIG9mIHVuc3BlY2lmaWVkXG4gICAgLy8gcXVhbGl0eS5cbiAgICB2YXIgIF9ybmRzID0gbmV3IEFycmF5KDE2KTtcbiAgICBfcm5nID0gZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgcjsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgaWYgKChpICYgMHgwMykgPT09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICAgIF9ybmRzW2ldID0gciA+Pj4gKChpICYgMHgwMykgPDwgMykgJiAweGZmO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3JuZHM7XG4gICAgfTtcbiAgfVxuXG4gIC8vIEJ1ZmZlciBjbGFzcyB0byB1c2VcbiAgdmFyIEJ1ZmZlckNsYXNzID0gdHlwZW9mKEJ1ZmZlcikgPT0gJ2Z1bmN0aW9uJyA/IEJ1ZmZlciA6IEFycmF5O1xuXG4gIC8vIE1hcHMgZm9yIG51bWJlciA8LT4gaGV4IHN0cmluZyBjb252ZXJzaW9uXG4gIHZhciBfYnl0ZVRvSGV4ID0gW107XG4gIHZhciBfaGV4VG9CeXRlID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICBfYnl0ZVRvSGV4W2ldID0gKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKTtcbiAgICBfaGV4VG9CeXRlW19ieXRlVG9IZXhbaV1dID0gaTtcbiAgfVxuXG4gIC8vICoqYHBhcnNlKClgIC0gUGFyc2UgYSBVVUlEIGludG8gaXQncyBjb21wb25lbnQgYnl0ZXMqKlxuICBmdW5jdGlvbiBwYXJzZShzLCBidWYsIG9mZnNldCkge1xuICAgIHZhciBpID0gKGJ1ZiAmJiBvZmZzZXQpIHx8IDAsIGlpID0gMDtcblxuICAgIGJ1ZiA9IGJ1ZiB8fCBbXTtcbiAgICBzLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWzAtOWEtZl17Mn0vZywgZnVuY3Rpb24ob2N0KSB7XG4gICAgICBpZiAoaWkgPCAxNikgeyAvLyBEb24ndCBvdmVyZmxvdyFcbiAgICAgICAgYnVmW2kgKyBpaSsrXSA9IF9oZXhUb0J5dGVbb2N0XTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFplcm8gb3V0IHJlbWFpbmluZyBieXRlcyBpZiBzdHJpbmcgd2FzIHNob3J0XG4gICAgd2hpbGUgKGlpIDwgMTYpIHtcbiAgICAgIGJ1ZltpICsgaWkrK10gPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBidWY7XG4gIH1cblxuICAvLyAqKmB1bnBhcnNlKClgIC0gQ29udmVydCBVVUlEIGJ5dGUgYXJyYXkgKGFsYSBwYXJzZSgpKSBpbnRvIGEgc3RyaW5nKipcbiAgZnVuY3Rpb24gdW5wYXJzZShidWYsIG9mZnNldCkge1xuICAgIHZhciBpID0gb2Zmc2V0IHx8IDAsIGJ0aCA9IF9ieXRlVG9IZXg7XG4gICAgcmV0dXJuICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXTtcbiAgfVxuXG4gIC8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbiAgLy9cbiAgLy8gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL0xpb3NLL1VVSUQuanNcbiAgLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcblxuICAvLyByYW5kb20gIydzIHdlIG5lZWQgdG8gaW5pdCBub2RlIGFuZCBjbG9ja3NlcVxuICB2YXIgX3NlZWRCeXRlcyA9IF9ybmcoKTtcblxuICAvLyBQZXIgNC41LCBjcmVhdGUgYW5kIDQ4LWJpdCBub2RlIGlkLCAoNDcgcmFuZG9tIGJpdHMgKyBtdWx0aWNhc3QgYml0ID0gMSlcbiAgdmFyIF9ub2RlSWQgPSBbXG4gICAgX3NlZWRCeXRlc1swXSB8IDB4MDEsXG4gICAgX3NlZWRCeXRlc1sxXSwgX3NlZWRCeXRlc1syXSwgX3NlZWRCeXRlc1szXSwgX3NlZWRCeXRlc1s0XSwgX3NlZWRCeXRlc1s1XVxuICBdO1xuXG4gIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gIHZhciBfY2xvY2tzZXEgPSAoX3NlZWRCeXRlc1s2XSA8PCA4IHwgX3NlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG5cbiAgLy8gUHJldmlvdXMgdXVpZCBjcmVhdGlvbiB0aW1lXG4gIHZhciBfbGFzdE1TZWNzID0gMCwgX2xhc3ROU2VjcyA9IDA7XG5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9icm9vZmEvbm9kZS11dWlkIGZvciBBUEkgZGV0YWlsc1xuICBmdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICAgIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICAgIHZhciBiID0gYnVmIHx8IFtdO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9IG51bGwgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxO1xuXG4gICAgLy8gVVVJRCB0aW1lc3RhbXBzIGFyZSAxMDAgbmFuby1zZWNvbmQgdW5pdHMgc2luY2UgdGhlIEdyZWdvcmlhbiBlcG9jaCxcbiAgICAvLyAoMTU4Mi0xMC0xNSAwMDowMCkuICBKU051bWJlcnMgYXJlbid0IHByZWNpc2UgZW5vdWdoIGZvciB0aGlzLCBzb1xuICAgIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAgIC8vICgxMDAtbmFub3NlY29uZHMgb2Zmc2V0IGZyb20gbXNlY3MpIHNpbmNlIHVuaXggZXBvY2gsIDE5NzAtMDEtMDEgMDA6MDAuXG4gICAgdmFyIG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPSBudWxsID8gb3B0aW9ucy5tc2VjcyA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgLy8gUGVyIDQuMi4xLjIsIHVzZSBjb3VudCBvZiB1dWlkJ3MgZ2VuZXJhdGVkIGR1cmluZyB0aGUgY3VycmVudCBjbG9ja1xuICAgIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG4gICAgdmFyIG5zZWNzID0gb3B0aW9ucy5uc2VjcyAhPSBudWxsID8gb3B0aW9ucy5uc2VjcyA6IF9sYXN0TlNlY3MgKyAxO1xuXG4gICAgLy8gVGltZSBzaW5jZSBsYXN0IHV1aWQgY3JlYXRpb24gKGluIG1zZWNzKVxuICAgIHZhciBkdCA9IChtc2VjcyAtIF9sYXN0TVNlY3MpICsgKG5zZWNzIC0gX2xhc3ROU2VjcykvMTAwMDA7XG5cbiAgICAvLyBQZXIgNC4yLjEuMiwgQnVtcCBjbG9ja3NlcSBvbiBjbG9jayByZWdyZXNzaW9uXG4gICAgaWYgKGR0IDwgMCAmJiBvcHRpb25zLmNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICAgIH1cblxuICAgIC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gICAgLy8gdGltZSBpbnRlcnZhbFxuICAgIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PSBudWxsKSB7XG4gICAgICBuc2VjcyA9IDA7XG4gICAgfVxuXG4gICAgLy8gUGVyIDQuMi4xLjIgVGhyb3cgZXJyb3IgaWYgdG9vIG1hbnkgdXVpZHMgYXJlIHJlcXVlc3RlZFxuICAgIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1dWlkLnYxKCk6IENhblxcJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjJyk7XG4gICAgfVxuXG4gICAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICAgIF9sYXN0TlNlY3MgPSBuc2VjcztcbiAgICBfY2xvY2tzZXEgPSBjbG9ja3NlcTtcblxuICAgIC8vIFBlciA0LjEuNCAtIENvbnZlcnQgZnJvbSB1bml4IGVwb2NoIHRvIEdyZWdvcmlhbiBlcG9jaFxuICAgIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwO1xuXG4gICAgLy8gYHRpbWVfbG93YFxuICAgIHZhciB0bCA9ICgobXNlY3MgJiAweGZmZmZmZmYpICogMTAwMDAgKyBuc2VjcykgJSAweDEwMDAwMDAwMDtcbiAgICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICAgIGJbaSsrXSA9IHRsID4+PiAxNiAmIDB4ZmY7XG4gICAgYltpKytdID0gdGwgPj4+IDggJiAweGZmO1xuICAgIGJbaSsrXSA9IHRsICYgMHhmZjtcblxuICAgIC8vIGB0aW1lX21pZGBcbiAgICB2YXIgdG1oID0gKG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCkgJiAweGZmZmZmZmY7XG4gICAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgICBiW2krK10gPSB0bWggJiAweGZmO1xuXG4gICAgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcbiAgICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG4gICAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7XG5cbiAgICAvLyBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGAgKFBlciA0LjIuMiAtIGluY2x1ZGUgdmFyaWFudClcbiAgICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7XG5cbiAgICAvLyBgY2xvY2tfc2VxX2xvd2BcbiAgICBiW2krK10gPSBjbG9ja3NlcSAmIDB4ZmY7XG5cbiAgICAvLyBgbm9kZWBcbiAgICB2YXIgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgNjsgbisrKSB7XG4gICAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZiA/IGJ1ZiA6IHVucGFyc2UoYik7XG4gIH1cblxuICAvLyAqKmB2NCgpYCAtIEdlbmVyYXRlIHJhbmRvbSBVVUlEKipcblxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWQgZm9yIEFQSSBkZXRhaWxzXG4gIGZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgLy8gRGVwcmVjYXRlZCAtICdmb3JtYXQnIGFyZ3VtZW50LCBhcyBzdXBwb3J0ZWQgaW4gdjEuMlxuICAgIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuXG4gICAgaWYgKHR5cGVvZihvcHRpb25zKSA9PSAnc3RyaW5nJykge1xuICAgICAgYnVmID0gb3B0aW9ucyA9PSAnYmluYXJ5JyA/IG5ldyBCdWZmZXJDbGFzcygxNikgOiBudWxsO1xuICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgX3JuZykoKTtcblxuICAgIC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcbiAgICBybmRzWzZdID0gKHJuZHNbNl0gJiAweDBmKSB8IDB4NDA7XG4gICAgcm5kc1s4XSA9IChybmRzWzhdICYgMHgzZikgfCAweDgwO1xuXG4gICAgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG4gICAgaWYgKGJ1Zikge1xuICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IDE2OyBpaSsrKSB7XG4gICAgICAgIGJ1ZltpICsgaWldID0gcm5kc1tpaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZiB8fCB1bnBhcnNlKHJuZHMpO1xuICB9XG5cbiAgLy8gRXhwb3J0IHB1YmxpYyBBUElcbiAgdmFyIHV1aWQgPSB2NDtcbiAgdXVpZC52MSA9IHYxO1xuICB1dWlkLnY0ID0gdjQ7XG4gIHV1aWQucGFyc2UgPSBwYXJzZTtcbiAgdXVpZC51bnBhcnNlID0gdW5wYXJzZTtcbiAgdXVpZC5CdWZmZXJDbGFzcyA9IEJ1ZmZlckNsYXNzO1xuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBQdWJsaXNoIGFzIEFNRCBtb2R1bGVcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7cmV0dXJuIHV1aWQ7fSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mKG1vZHVsZSkgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAvLyBQdWJsaXNoIGFzIG5vZGUuanMgbW9kdWxlXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB1dWlkO1xuICB9IGVsc2Uge1xuICAgIC8vIFB1Ymxpc2ggYXMgZ2xvYmFsIChpbiBicm93c2VycylcbiAgICB2YXIgX3ByZXZpb3VzUm9vdCA9IF9nbG9iYWwudXVpZDtcblxuICAgIC8vICoqYG5vQ29uZmxpY3QoKWAgLSAoYnJvd3NlciBvbmx5KSB0byByZXNldCBnbG9iYWwgJ3V1aWQnIHZhcioqXG4gICAgdXVpZC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBfZ2xvYmFsLnV1aWQgPSBfcHJldmlvdXNSb290O1xuICAgICAgcmV0dXJuIHV1aWQ7XG4gICAgfTtcblxuICAgIF9nbG9iYWwudXVpZCA9IHV1aWQ7XG4gIH1cbn0pLmNhbGwodGhpcyk7XG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfYnVmZmVyXCIpLkJ1ZmZlcikiLCJtb2R1bGUuZXhwb3J0cyA9IGFycmF5RGlmZjtcblxuLy8gQmFzZWQgb24gc29tZSByb3VnaCBiZW5jaG1hcmtpbmcsIHRoaXMgYWxnb3JpdGhtIGlzIGFib3V0IE8oMm4pIHdvcnN0IGNhc2UsXG4vLyBhbmQgaXQgY2FuIGNvbXB1dGUgZGlmZnMgb24gcmFuZG9tIGFycmF5cyBvZiBsZW5ndGggMTAyNCBpbiBhYm91dCAzNG1zLFxuLy8gdGhvdWdoIGp1c3QgYSBmZXcgY2hhbmdlcyBvbiBhbiBhcnJheSBvZiBsZW5ndGggMTAyNCB0YWtlcyBhYm91dCAwLjVtc1xuXG5hcnJheURpZmYuSW5zZXJ0RGlmZiA9IEluc2VydERpZmY7XG5hcnJheURpZmYuUmVtb3ZlRGlmZiA9IFJlbW92ZURpZmY7XG5hcnJheURpZmYuTW92ZURpZmYgPSBNb3ZlRGlmZjtcblxuZnVuY3Rpb24gSW5zZXJ0RGlmZihpbmRleCwgdmFsdWVzKSB7XG4gIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG59XG5JbnNlcnREaWZmLnByb3RvdHlwZS50eXBlID0gJ2luc2VydCc7XG5JbnNlcnREaWZmLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0aGlzLnR5cGVcbiAgLCBpbmRleDogdGhpcy5pbmRleFxuICAsIHZhbHVlczogdGhpcy52YWx1ZXNcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIFJlbW92ZURpZmYoaW5kZXgsIGhvd01hbnkpIHtcbiAgdGhpcy5pbmRleCA9IGluZGV4O1xuICB0aGlzLmhvd01hbnkgPSBob3dNYW55O1xufVxuUmVtb3ZlRGlmZi5wcm90b3R5cGUudHlwZSA9ICdyZW1vdmUnO1xuUmVtb3ZlRGlmZi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdGhpcy50eXBlXG4gICwgaW5kZXg6IHRoaXMuaW5kZXhcbiAgLCBob3dNYW55OiB0aGlzLmhvd01hbnlcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIE1vdmVEaWZmKGZyb20sIHRvLCBob3dNYW55KSB7XG4gIHRoaXMuZnJvbSA9IGZyb207XG4gIHRoaXMudG8gPSB0bztcbiAgdGhpcy5ob3dNYW55ID0gaG93TWFueTtcbn1cbk1vdmVEaWZmLnByb3RvdHlwZS50eXBlID0gJ21vdmUnO1xuTW92ZURpZmYucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHRoaXMudHlwZVxuICAsIGZyb206IHRoaXMuZnJvbVxuICAsIHRvOiB0aGlzLnRvXG4gICwgaG93TWFueTogdGhpcy5ob3dNYW55XG4gIH07XG59O1xuXG5mdW5jdGlvbiBzdHJpY3RFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufVxuXG5mdW5jdGlvbiBhcnJheURpZmYoYmVmb3JlLCBhZnRlciwgZXF1YWxGbikge1xuICBpZiAoIWVxdWFsRm4pIGVxdWFsRm4gPSBzdHJpY3RFcXVhbDtcblxuICAvLyBGaW5kIGFsbCBpdGVtcyBpbiBib3RoIHRoZSBiZWZvcmUgYW5kIGFmdGVyIGFycmF5LCBhbmQgcmVwcmVzZW50IHRoZW1cbiAgLy8gYXMgbW92ZXMuIE1hbnkgb2YgdGhlc2UgXCJtb3Zlc1wiIG1heSBlbmQgdXAgYmVpbmcgZGlzY2FyZGVkIGluIHRoZSBsYXN0XG4gIC8vIHBhc3MgaWYgdGhleSBhcmUgZnJvbSBhbiBpbmRleCB0byB0aGUgc2FtZSBpbmRleCwgYnV0IHdlIGRvbid0IGtub3cgdGhpc1xuICAvLyB1cCBmcm9udCwgc2luY2Ugd2UgaGF2ZW4ndCB5ZXQgb2Zmc2V0IHRoZSBpbmRpY2VzLlxuICAvLyBcbiAgLy8gQWxzbyBrZWVwIGEgbWFwIG9mIGFsbCB0aGUgaW5kaWNpZXMgYWNjb3VudGVkIGZvciBpbiB0aGUgYmVmb3JlIGFuZCBhZnRlclxuICAvLyBhcnJheXMuIFRoZXNlIG1hcHMgYXJlIHVzZWQgbmV4dCB0byBjcmVhdGUgaW5zZXJ0IGFuZCByZW1vdmUgZGlmZnMuXG4gIHZhciBiZWZvcmVMZW5ndGggPSBiZWZvcmUubGVuZ3RoO1xuICB2YXIgYWZ0ZXJMZW5ndGggPSBhZnRlci5sZW5ndGg7XG4gIHZhciBtb3ZlcyA9IFtdO1xuICB2YXIgYmVmb3JlTWFya2VkID0ge307XG4gIHZhciBhZnRlck1hcmtlZCA9IHt9O1xuICBmb3IgKHZhciBiZWZvcmVJbmRleCA9IDA7IGJlZm9yZUluZGV4IDwgYmVmb3JlTGVuZ3RoOyBiZWZvcmVJbmRleCsrKSB7XG4gICAgdmFyIGJlZm9yZUl0ZW0gPSBiZWZvcmVbYmVmb3JlSW5kZXhdO1xuICAgIGZvciAodmFyIGFmdGVySW5kZXggPSAwOyBhZnRlckluZGV4IDwgYWZ0ZXJMZW5ndGg7IGFmdGVySW5kZXgrKykge1xuICAgICAgaWYgKGFmdGVyTWFya2VkW2FmdGVySW5kZXhdKSBjb250aW51ZTtcbiAgICAgIGlmICghZXF1YWxGbihiZWZvcmVJdGVtLCBhZnRlclthZnRlckluZGV4XSkpIGNvbnRpbnVlO1xuICAgICAgdmFyIGZyb20gPSBiZWZvcmVJbmRleDtcbiAgICAgIHZhciB0byA9IGFmdGVySW5kZXg7XG4gICAgICB2YXIgaG93TWFueSA9IDA7XG4gICAgICBkbyB7XG4gICAgICAgIGJlZm9yZU1hcmtlZFtiZWZvcmVJbmRleCsrXSA9IGFmdGVyTWFya2VkW2FmdGVySW5kZXgrK10gPSB0cnVlO1xuICAgICAgICBob3dNYW55Kys7XG4gICAgICB9IHdoaWxlIChcbiAgICAgICAgYmVmb3JlSW5kZXggPCBiZWZvcmVMZW5ndGggJiZcbiAgICAgICAgYWZ0ZXJJbmRleCA8IGFmdGVyTGVuZ3RoICYmXG4gICAgICAgIGVxdWFsRm4oYmVmb3JlW2JlZm9yZUluZGV4XSwgYWZ0ZXJbYWZ0ZXJJbmRleF0pICYmXG4gICAgICAgICFhZnRlck1hcmtlZFthZnRlckluZGV4XVxuICAgICAgKTtcbiAgICAgIG1vdmVzLnB1c2gobmV3IE1vdmVEaWZmKGZyb20sIHRvLCBob3dNYW55KSk7XG4gICAgICBiZWZvcmVJbmRleC0tO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlIGEgcmVtb3ZlIGZvciBhbGwgb2YgdGhlIGl0ZW1zIGluIHRoZSBiZWZvcmUgYXJyYXkgdGhhdCB3ZXJlXG4gIC8vIG5vdCBtYXJrZWQgYXMgYmVpbmcgbWF0Y2hlZCBpbiB0aGUgYWZ0ZXIgYXJyYXkgYXMgd2VsbFxuICB2YXIgcmVtb3ZlcyA9IFtdO1xuICBmb3IgKGJlZm9yZUluZGV4ID0gMDsgYmVmb3JlSW5kZXggPCBiZWZvcmVMZW5ndGg7KSB7XG4gICAgaWYgKGJlZm9yZU1hcmtlZFtiZWZvcmVJbmRleF0pIHtcbiAgICAgIGJlZm9yZUluZGV4Kys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gYmVmb3JlSW5kZXg7XG4gICAgdmFyIGhvd01hbnkgPSAwO1xuICAgIHdoaWxlIChiZWZvcmVJbmRleCA8IGJlZm9yZUxlbmd0aCAmJiAhYmVmb3JlTWFya2VkW2JlZm9yZUluZGV4KytdKSB7XG4gICAgICBob3dNYW55Kys7XG4gICAgfVxuICAgIHJlbW92ZXMucHVzaChuZXcgUmVtb3ZlRGlmZihpbmRleCwgaG93TWFueSkpO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGFuIGluc2VydCBmb3IgYWxsIG9mIHRoZSBpdGVtcyBpbiB0aGUgYWZ0ZXIgYXJyYXkgdGhhdCB3ZXJlXG4gIC8vIG5vdCBtYXJrZWQgYXMgYmVpbmcgbWF0Y2hlZCBpbiB0aGUgYmVmb3JlIGFycmF5IGFzIHdlbGxcbiAgdmFyIGluc2VydHMgPSBbXTtcbiAgZm9yIChhZnRlckluZGV4ID0gMDsgYWZ0ZXJJbmRleCA8IGFmdGVyTGVuZ3RoOykge1xuICAgIGlmIChhZnRlck1hcmtlZFthZnRlckluZGV4XSkge1xuICAgICAgYWZ0ZXJJbmRleCsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpbmRleCA9IGFmdGVySW5kZXg7XG4gICAgdmFyIGhvd01hbnkgPSAwO1xuICAgIHdoaWxlIChhZnRlckluZGV4IDwgYWZ0ZXJMZW5ndGggJiYgIWFmdGVyTWFya2VkW2FmdGVySW5kZXgrK10pIHtcbiAgICAgIGhvd01hbnkrKztcbiAgICB9XG4gICAgdmFyIHZhbHVlcyA9IGFmdGVyLnNsaWNlKGluZGV4LCBpbmRleCArIGhvd01hbnkpO1xuICAgIGluc2VydHMucHVzaChuZXcgSW5zZXJ0RGlmZihpbmRleCwgdmFsdWVzKSk7XG4gIH1cblxuICB2YXIgaW5zZXJ0c0xlbmd0aCA9IGluc2VydHMubGVuZ3RoO1xuICB2YXIgcmVtb3Zlc0xlbmd0aCA9IHJlbW92ZXMubGVuZ3RoO1xuICB2YXIgbW92ZXNMZW5ndGggPSBtb3Zlcy5sZW5ndGg7XG4gIHZhciBpLCBqO1xuXG4gIC8vIE9mZnNldCBzdWJzZXF1ZW50IHJlbW92ZXMgYW5kIG1vdmVzIGJ5IHJlbW92ZXNcbiAgdmFyIGNvdW50ID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IHJlbW92ZXNMZW5ndGg7IGkrKykge1xuICAgIHZhciByZW1vdmUgPSByZW1vdmVzW2ldO1xuICAgIHJlbW92ZS5pbmRleCAtPSBjb3VudDtcbiAgICBjb3VudCArPSByZW1vdmUuaG93TWFueTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW92ZXNMZW5ndGg7IGorKykge1xuICAgICAgdmFyIG1vdmUgPSBtb3Zlc1tqXTtcbiAgICAgIGlmIChtb3ZlLmZyb20gPj0gcmVtb3ZlLmluZGV4KSBtb3ZlLmZyb20gLT0gcmVtb3ZlLmhvd01hbnk7XG4gICAgfVxuICB9XG5cbiAgLy8gT2Zmc2V0IG1vdmVzIGJ5IGluc2VydHNcbiAgZm9yIChpID0gaW5zZXJ0c0xlbmd0aDsgaS0tOykge1xuICAgIHZhciBpbnNlcnQgPSBpbnNlcnRzW2ldO1xuICAgIHZhciBob3dNYW55ID0gaW5zZXJ0LnZhbHVlcy5sZW5ndGg7XG4gICAgZm9yIChqID0gbW92ZXNMZW5ndGg7IGotLTspIHtcbiAgICAgIHZhciBtb3ZlID0gbW92ZXNbal07XG4gICAgICBpZiAobW92ZS50byA+PSBpbnNlcnQuaW5kZXgpIG1vdmUudG8gLT0gaG93TWFueTtcbiAgICB9XG4gIH1cblxuICAvLyBPZmZzZXQgdGhlIHRvIG9mIG1vdmVzIGJ5IGxhdGVyIG1vdmVzXG4gIGZvciAoaSA9IG1vdmVzTGVuZ3RoOyBpLS0gPiAxOykge1xuICAgIHZhciBtb3ZlID0gbW92ZXNbaV07XG4gICAgaWYgKG1vdmUudG8gPT09IG1vdmUuZnJvbSkgY29udGludWU7XG4gICAgZm9yIChqID0gaTsgai0tOykge1xuICAgICAgdmFyIGVhcmxpZXIgPSBtb3Zlc1tqXTtcbiAgICAgIGlmIChlYXJsaWVyLnRvID49IG1vdmUudG8pIGVhcmxpZXIudG8gLT0gbW92ZS5ob3dNYW55O1xuICAgICAgaWYgKGVhcmxpZXIudG8gPj0gbW92ZS5mcm9tKSBlYXJsaWVyLnRvICs9IG1vdmUuaG93TWFueTtcbiAgICB9XG4gIH1cblxuICAvLyBPbmx5IG91dHB1dCBtb3ZlcyB0aGF0IGVuZCB1cCBoYXZpbmcgYW4gZWZmZWN0IGFmdGVyIG9mZnNldHRpbmdcbiAgdmFyIG91dHB1dE1vdmVzID0gW107XG5cbiAgLy8gT2Zmc2V0IHRoZSBmcm9tIG9mIG1vdmVzIGJ5IGVhcmxpZXIgbW92ZXNcbiAgZm9yIChpID0gMDsgaSA8IG1vdmVzTGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbW92ZSA9IG1vdmVzW2ldO1xuICAgIGlmIChtb3ZlLnRvID09PSBtb3ZlLmZyb20pIGNvbnRpbnVlO1xuICAgIG91dHB1dE1vdmVzLnB1c2gobW92ZSk7XG4gICAgZm9yIChqID0gaSArIDE7IGogPCBtb3Zlc0xlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgbGF0ZXIgPSBtb3Zlc1tqXTtcbiAgICAgIGlmIChsYXRlci5mcm9tID49IG1vdmUuZnJvbSkgbGF0ZXIuZnJvbSAtPSBtb3ZlLmhvd01hbnk7XG4gICAgICBpZiAobGF0ZXIuZnJvbSA+PSBtb3ZlLnRvKSBsYXRlci5mcm9tICs9IG1vdmUuaG93TWFueTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVtb3Zlcy5jb25jYXQob3V0cHV0TW92ZXMsIGluc2VydHMpO1xufVxuIiwidmFyIHFzID0gcmVxdWlyZSgncXMnKVxudmFyIG5vZGVVcmwgPSByZXF1aXJlKCd1cmwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlbmRlcjogcmVuZGVyXG4sIGlzVHJhbnNpdGlvbmFsOiBpc1RyYW5zaXRpb25hbFxuLCBtYXBSb3V0ZTogbWFwUm91dGVcbn1cblxuZnVuY3Rpb24gaXNUcmFuc2l0aW9uYWwocGF0dGVybikge1xuICByZXR1cm4gcGF0dGVybi5oYXNPd25Qcm9wZXJ0eSgnZnJvbScpICYmIHBhdHRlcm4uaGFzT3duUHJvcGVydHkoJ3RvJylcbn1cblxuZnVuY3Rpb24gbWFwUm91dGUoZnJvbSwgcGFyYW1zKSB7XG4gIHZhciBpID0gcGFyYW1zLnVybC5pbmRleE9mKCc/JylcbiAgdmFyIHF1ZXJ5U3RyaW5nID0gKH5pKSA/IHBhcmFtcy51cmwuc2xpY2UoaSkgOiAnJ1xuICAvLyBJZiB0aGUgcm91dGUgbG9va3MgbGlrZSAvOmEvOmI/LzpjLzpkP1xuICAvLyBhbmQgOmIgYW5kIDpkIGFyZSBtaXNzaW5nLCByZXR1cm4gL2EvY1xuICAvLyBUaHVzLCBza2lwIHRoZSAvIGlmIHRoZSB2YWx1ZSBpcyBtaXNzaW5nXG4gIHZhciBpID0gMFxuICB2YXIgcGF0aCA9IGZyb20ucmVwbGFjZSgvXFwvKD86KD86XFw6KFteP1xcLzoqXSspKXxcXCopKFxcPyk/L2csIG9uTWF0Y2gpXG4gIGZ1bmN0aW9uIG9uTWF0Y2gobWF0Y2gsIGtleSwgb3B0aW9uYWwpIHtcbiAgICB2YXIgdmFsdWUgPSBrZXkgPyBwYXJhbXNba2V5XSA6IHBhcmFtc1tpKytdXG4gICAgcmV0dXJuIChvcHRpb25hbCAmJiB2YWx1ZSA9PT0gdm9pZCAwKSA/ICcnIDogJy8nICsgdmFsdWVcbiAgfVxuICByZXR1cm4gcGF0aCArIHF1ZXJ5U3RyaW5nXG59XG5cbmZ1bmN0aW9uIHJlbmRlcihwYWdlLCBvcHRpb25zLCBlKSB7XG4gIHZhciByZXEgPSBuZXcgUmVuZGVyUmVxKHBhZ2UsIG9wdGlvbnMsIGUpXG4gIHJlcS5yb3V0ZVRyYW5zaXRpb25hbCgwLCBmdW5jdGlvbigpIHtcbiAgICByZXEucm91dGVRdWV1ZSgwLCBmdW5jdGlvbigpIHtcbiAgICAgIHJlcS5yb3V0ZUFuZFRyYW5zaXRpb24oMCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIENhbmNlbCByZW5kZXJpbmcgYnkgdGhpcyBhcHAgaWYgbm8gcm91dGVzIG1hdGNoXG4gICAgICAgIHJlcS5jYW5jZWwoKVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBSZW5kZXJSZXEocGFnZSwgb3B0aW9ucywgZSkge1xuICB0aGlzLnBhZ2UgPSBwYWdlXG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgdGhpcy5lID0gZVxuICB0aGlzLnNldFVybChvcHRpb25zLnVybC5yZXBsYWNlKC8jLiovLCAnJykpXG4gIHZhciBxdWVyeVN0cmluZyA9IG5vZGVVcmwucGFyc2UodGhpcy51cmwpLnF1ZXJ5O1xuICB0aGlzLnF1ZXJ5ID0gcXVlcnlTdHJpbmcgPyBxcy5wYXJzZShxdWVyeVN0cmluZykgOiB7fVxuICB0aGlzLm1ldGhvZCA9IG9wdGlvbnMubWV0aG9kXG4gIHRoaXMuYm9keSA9IG9wdGlvbnMuYm9keSB8fCB7fVxuICB0aGlzLnByZXZpb3VzID0gb3B0aW9ucy5wcmV2aW91c1xuICB2YXIgcm91dGVzID0gcGFnZS5fcm91dGVzXG4gIHRoaXMudHJhbnNpdGlvbmFsID0gcm91dGVzLnRyYW5zaXRpb25hbFt0aGlzLm1ldGhvZF1cbiAgdGhpcy5xdWV1ZSA9IHJvdXRlcy5xdWV1ZVt0aGlzLm1ldGhvZF1cbiAgdGhpcy5vblJvdXRlID0gcm91dGVzLm9uUm91dGVcbn1cblxuUmVuZGVyUmVxLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgdGhpcyBpcyB0aGUgcmVzdWx0IG9mIGFuIGV2ZW50LCBzaW5jZSB0aGVcbiAgLy8gYXBwcm9wcmlhdGUgYWN0aW9uIHdpbGwgaGFwcGVuIGJ5IGRlZmF1bHRcbiAgaWYgKHRoaXMuZSB8fCBvcHRpb25zLm5vTmF2aWdhdGUpIHJldHVyblxuICAvLyBPdGhlcndpc2UsIG1hbnVhbGx5IHBlcmZvcm0gYXBwcm9wcmlhdGUgYWN0aW9uXG4gIGlmIChvcHRpb25zLmZvcm0pIHtcbiAgICBvcHRpb25zLmZvcm0uc2V0QXR0cmlidXRlKCdkYXRhLXJvdXRlci1pZ25vcmUnLCAnJylcbiAgICBvcHRpb25zLmZvcm0uc3VibWl0KClcbiAgfSBlbHNlIGlmIChvcHRpb25zLmxpbmspIHtcbiAgICBvcHRpb25zLmxpbmsuc2V0QXR0cmlidXRlKCdkYXRhLXJvdXRlci1pZ25vcmUnLCAnJylcbiAgICBvcHRpb25zLmxpbmsuY2xpY2soKVxuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24ob3B0aW9ucy51cmwpXG4gIH1cbn1cblxuUmVuZGVyUmVxLnByb3RvdHlwZS5zZXRVcmwgPSBmdW5jdGlvbih1cmwpIHtcbiAgdGhpcy51cmwgPSB1cmxcbiAgdGhpcy5wYXRoID0gdGhpcy51cmwucmVwbGFjZSgvXFw/LiovLCAnJylcbn1cblxuUmVuZGVyUmVxLnByb3RvdHlwZS5yb3V0ZVRyYW5zaXRpb25hbCA9IGZ1bmN0aW9uKGksIG5leHQpIHtcbiAgaSB8fCAoaSA9IDApXG4gIHZhciBpdGVtXG4gIHdoaWxlIChpdGVtID0gdGhpcy50cmFuc2l0aW9uYWxbaSsrXSkge1xuICAgIGlmICghaXRlbS50by5tYXRjaCh0aGlzLnBhdGgpIHx8ICFpdGVtLmZyb20ubWF0Y2godGhpcy5wcmV2aW91cykpIGNvbnRpbnVlXG4gICAgdmFyIHJlcSA9IHRoaXNcbiAgICB2YXIgb3RoZXJQYXJhbXMgPSB0aGlzLnJvdXRlUGFyYW1zKGl0ZW0uZnJvbSlcbiAgICB2YXIgcGFyYW1zID0gdGhpcy5yb3V0ZVBhcmFtcyhpdGVtLnRvLCBvdGhlclBhcmFtcylcbiAgICAvLyBFdmVuIHRob3VnaCB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nIGFmdGVyIGEgZG9uZSwgcGFzcyBhXG4gICAgLy8gbm8gb3AgZnVuY3Rpb24sIHNvIHRoYXQgcm91dGVzIGNhbiBleHBlY3QgaXQgdG8gYmUgZGVmaW5lZFxuICAgIGZ1bmN0aW9uIGRvbmUoKSB7fVxuICAgIHRoaXMub25NYXRjaChpdGVtLnRvLCBwYXJhbXMsIGZ1bmN0aW9uKGVycikge1xuICAgICAgaWYgKGVycikgcmV0dXJuIHJlcS5jYW5jZWwoKVxuICAgICAgcmVxLnJvdXRlVHJhbnNpdGlvbmFsKGksIG5leHQpXG4gICAgfSwgZG9uZSlcbiAgICByZXR1cm5cbiAgfVxuICBuZXh0KClcbn1cblxuUmVuZGVyUmVxLnByb3RvdHlwZS5yb3V0ZVF1ZXVlID0gZnVuY3Rpb24oaSwgbmV4dCkge1xuICBpIHx8IChpID0gMClcbiAgdmFyIHJvdXRlXG4gIHdoaWxlIChyb3V0ZSA9IHRoaXMucXVldWVbaSsrXSkge1xuICAgIGlmICghcm91dGUubWF0Y2godGhpcy5wYXRoKSkgY29udGludWVcbiAgICB2YXIgcmVxID0gdGhpc1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLnJvdXRlUGFyYW1zKHJvdXRlKVxuICAgIHRoaXMub25NYXRjaChyb3V0ZSwgcGFyYW1zLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiByZXEuY2FuY2VsKClcbiAgICAgIHJlcS5yb3V0ZVF1ZXVlKGksIG5leHQpXG4gICAgfSlcbiAgICByZXR1cm5cbiAgfVxuICBuZXh0KClcbn1cblxuUmVuZGVyUmVxLnByb3RvdHlwZS5yb3V0ZUFuZFRyYW5zaXRpb24gPSBmdW5jdGlvbihpLCBuZXh0KSB7XG4gIGkgfHwgKGkgPSAwKVxuICB2YXIgcmVuZGVyID0gdGhpcy5wYWdlLnJlbmRlclxuICB2YXIgaXRlbVxuICB3aGlsZSAoaXRlbSA9IHRoaXMudHJhbnNpdGlvbmFsW2krK10pIHtcbiAgICBpZiAoIWl0ZW0udG8ubWF0Y2godGhpcy5wYXRoKSkgY29udGludWVcbiAgICB2YXIgdXJsID0gdGhpcy51cmxcbiAgICB2YXIgcGFyYW1zID0gdGhpcy5yb3V0ZVBhcmFtcyhpdGVtLnRvKVxuICAgIHRoaXMuc2V0VXJsKG1hcFJvdXRlKGl0ZW0uZnJvbS5wYXRoLCBwYXJhbXMpKVxuICAgIHZhciByZXEgPSB0aGlzXG4gICAgdmFyIHNraXBwZWQgPSBmYWxzZVxuICAgIGZ1bmN0aW9uIGNvbnRpbnVlTmV4dCgpIHtcbiAgICAgIHNraXBwZWQgPSB0cnVlXG4gICAgICByZXEuc2V0VXJsKHVybClcbiAgICAgIHJlcS5wYWdlLnJlbmRlciA9IHJlbmRlclxuICAgICAgcmVxLnJvdXRlQW5kVHJhbnNpdGlvbihpLCBuZXh0KVxuICAgIH1cbiAgICB0aGlzLnBhZ2UucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVuZGVyQXJndW1lbnRzID0gYXJndW1lbnRzXG4gICAgICBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgICBpZiAoc2tpcHBlZCkgcmV0dXJuXG4gICAgICAgIHJlcS5wYWdlLnJlbmRlciA9IHJlbmRlclxuICAgICAgICByZW5kZXIuYXBwbHkocmVxLnBhZ2UsIHJlbmRlckFyZ3VtZW50cylcbiAgICAgIH1cbiAgICAgIHJlcS5zZXRVcmwodXJsKVxuICAgICAgdmFyIGlzQXN5bmMgPSByZXEub25NYXRjaChpdGVtLnRvLCBwYXJhbXMsIGNvbnRpbnVlTmV4dCwgZG9uZSlcbiAgICAgIGlmIChpc0FzeW5jKSByZXR1cm5cbiAgICAgIGRvbmUoKVxuICAgIH1cbiAgICB0aGlzLnJvdXRlUXVldWUoMCwgY29udGludWVOZXh0KVxuICAgIHJldHVyblxuICB9XG4gIG5leHQoKVxufVxuXG5SZW5kZXJSZXEucHJvdG90eXBlLm9uTWF0Y2ggPSBmdW5jdGlvbihyb3V0ZSwgcGFyYW1zLCBuZXh0LCBkb25lKSB7XG4gIC8vIFN0b3AgdGhlIGRlZmF1bHQgYnJvd3NlciBhY3Rpb24sIHN1Y2ggYXMgY2xpY2tpbmcgYSBsaW5rIG9yIHN1Ym1pdHRpbmcgYSBmb3JtXG4gIGlmICh0aGlzLmUpIHtcbiAgICB0aGlzLmUucHJldmVudERlZmF1bHQoKVxuICAgIHRoaXMuZSA9IG51bGxcbiAgfVxuICB0aGlzLnBhZ2UucGFyYW1zID0gcGFyYW1zXG4gIHJldHVybiB0aGlzLm9uUm91dGUoXG4gICAgcm91dGUuY2FsbGJhY2tzXG4gICwgdGhpcy5wYWdlXG4gICwgdGhpcy5wYWdlLnBhcmFtc1xuICAsIG5leHRcbiAgLCByb3V0ZS5pc1RyYW5zaXRpb25hbFxuICAsIGRvbmVcbiAgKVxufVxuXG5SZW5kZXJSZXEucHJvdG90eXBlLnJvdXRlUGFyYW1zID0gZnVuY3Rpb24ocm91dGUsIG90aGVyUGFyYW1zKSB7XG4gIHZhciByb3V0ZVBhcmFtcyA9IHJvdXRlLnBhcmFtc1xuICB2YXIgcGFyYW1zID0gcm91dGVQYXJhbXMuc2xpY2UoKVxuICBpZiAob3RoZXJQYXJhbXMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb3RoZXJQYXJhbXMpIHtcbiAgICAgIHBhcmFtc1trZXldID0gb3RoZXJQYXJhbXNba2V5XVxuICAgIH1cbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gcm91dGVQYXJhbXMpIHtcbiAgICBwYXJhbXNba2V5XSA9IHJvdXRlUGFyYW1zW2tleV1cbiAgfVxuICBwYXJhbXMucHJldmlvdXMgPSB0aGlzLnByZXZpb3VzXG4gIHBhcmFtcy51cmwgPSB0aGlzLnVybFxuICBwYXJhbXMuYm9keSA9IHRoaXMuYm9keVxuICBwYXJhbXMucXVlcnkgPSB0aGlzLnF1ZXJ5XG4gIHBhcmFtcy5tZXRob2QgPSB0aGlzLm1ldGhvZFxuICByZXR1cm4gcGFyYW1zXG59XG4iLCIoZnVuY3Rpb24oKXtcclxuICB2YXIgY3J5cHQgPSByZXF1aXJlKCdjcnlwdCcpLFxyXG4gICAgICB1dGY4ID0gcmVxdWlyZSgnY2hhcmVuYycpLnV0ZjgsXHJcbiAgICAgIGJpbiA9IHJlcXVpcmUoJ2NoYXJlbmMnKS5iaW4sXHJcblxyXG4gIC8vIFRoZSBjb3JlXHJcbiAgbWQ1ID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgIC8vIENvbnZlcnQgdG8gYnl0ZSBhcnJheVxyXG4gICAgaWYgKG1lc3NhZ2UuY29uc3RydWN0b3IgPT0gU3RyaW5nKVxyXG4gICAgICBtZXNzYWdlID0gdXRmOC5zdHJpbmdUb0J5dGVzKG1lc3NhZ2UpO1xyXG4gICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZSkpXHJcbiAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnRvU3RyaW5nKCk7XHJcbiAgICAvLyBlbHNlLCBhc3N1bWUgYnl0ZSBhcnJheSBhbHJlYWR5XHJcblxyXG4gICAgdmFyIG0gPSBjcnlwdC5ieXRlc1RvV29yZHMobWVzc2FnZSksXHJcbiAgICAgICAgbCA9IG1lc3NhZ2UubGVuZ3RoICogOCxcclxuICAgICAgICBhID0gIDE3MzI1ODQxOTMsXHJcbiAgICAgICAgYiA9IC0yNzE3MzM4NzksXHJcbiAgICAgICAgYyA9IC0xNzMyNTg0MTk0LFxyXG4gICAgICAgIGQgPSAgMjcxNzMzODc4O1xyXG5cclxuICAgIC8vIFN3YXAgZW5kaWFuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG0ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgbVtpXSA9ICgobVtpXSA8PCAgOCkgfCAobVtpXSA+Pj4gMjQpKSAmIDB4MDBGRjAwRkYgfFxyXG4gICAgICAgICAgICAgKChtW2ldIDw8IDI0KSB8IChtW2ldID4+PiAgOCkpICYgMHhGRjAwRkYwMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQYWRkaW5nXHJcbiAgICBtW2wgPj4+IDVdIHw9IDB4ODAgPDwgKGwgJSAzMik7XHJcbiAgICBtWygoKGwgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gbDtcclxuXHJcbiAgICAvLyBNZXRob2Qgc2hvcnRjdXRzXHJcbiAgICB2YXIgRkYgPSBtZDUuX2ZmLFxyXG4gICAgICAgIEdHID0gbWQ1Ll9nZyxcclxuICAgICAgICBISCA9IG1kNS5faGgsXHJcbiAgICAgICAgSUkgPSBtZDUuX2lpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkgKz0gMTYpIHtcclxuXHJcbiAgICAgIHZhciBhYSA9IGEsXHJcbiAgICAgICAgICBiYiA9IGIsXHJcbiAgICAgICAgICBjYyA9IGMsXHJcbiAgICAgICAgICBkZCA9IGQ7XHJcblxyXG4gICAgICBhID0gRkYoYSwgYiwgYywgZCwgbVtpKyAwXSwgIDcsIC02ODA4NzY5MzYpO1xyXG4gICAgICBkID0gRkYoZCwgYSwgYiwgYywgbVtpKyAxXSwgMTIsIC0zODk1NjQ1ODYpO1xyXG4gICAgICBjID0gRkYoYywgZCwgYSwgYiwgbVtpKyAyXSwgMTcsICA2MDYxMDU4MTkpO1xyXG4gICAgICBiID0gRkYoYiwgYywgZCwgYSwgbVtpKyAzXSwgMjIsIC0xMDQ0NTI1MzMwKTtcclxuICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIG1baSsgNF0sICA3LCAtMTc2NDE4ODk3KTtcclxuICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIG1baSsgNV0sIDEyLCAgMTIwMDA4MDQyNik7XHJcbiAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBtW2krIDZdLCAxNywgLTE0NzMyMzEzNDEpO1xyXG4gICAgICBiID0gRkYoYiwgYywgZCwgYSwgbVtpKyA3XSwgMjIsIC00NTcwNTk4Myk7XHJcbiAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBtW2krIDhdLCAgNywgIDE3NzAwMzU0MTYpO1xyXG4gICAgICBkID0gRkYoZCwgYSwgYiwgYywgbVtpKyA5XSwgMTIsIC0xOTU4NDE0NDE3KTtcclxuICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIG1baSsxMF0sIDE3LCAtNDIwNjMpO1xyXG4gICAgICBiID0gRkYoYiwgYywgZCwgYSwgbVtpKzExXSwgMjIsIC0xOTkwNDA0MTYyKTtcclxuICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIG1baSsxMl0sICA3LCAgMTgwNDYwMzY4Mik7XHJcbiAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBtW2krMTNdLCAxMiwgLTQwMzQxMTAxKTtcclxuICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIG1baSsxNF0sIDE3LCAtMTUwMjAwMjI5MCk7XHJcbiAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBtW2krMTVdLCAyMiwgIDEyMzY1MzUzMjkpO1xyXG5cclxuICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIG1baSsgMV0sICA1LCAtMTY1Nzk2NTEwKTtcclxuICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIG1baSsgNl0sICA5LCAtMTA2OTUwMTYzMik7XHJcbiAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBtW2krMTFdLCAxNCwgIDY0MzcxNzcxMyk7XHJcbiAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBtW2krIDBdLCAyMCwgLTM3Mzg5NzMwMik7XHJcbiAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBtW2krIDVdLCAgNSwgLTcwMTU1ODY5MSk7XHJcbiAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBtW2krMTBdLCAgOSwgIDM4MDE2MDgzKTtcclxuICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIG1baSsxNV0sIDE0LCAtNjYwNDc4MzM1KTtcclxuICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIG1baSsgNF0sIDIwLCAtNDA1NTM3ODQ4KTtcclxuICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIG1baSsgOV0sICA1LCAgNTY4NDQ2NDM4KTtcclxuICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIG1baSsxNF0sICA5LCAtMTAxOTgwMzY5MCk7XHJcbiAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBtW2krIDNdLCAxNCwgLTE4NzM2Mzk2MSk7XHJcbiAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBtW2krIDhdLCAyMCwgIDExNjM1MzE1MDEpO1xyXG4gICAgICBhID0gR0coYSwgYiwgYywgZCwgbVtpKzEzXSwgIDUsIC0xNDQ0NjgxNDY3KTtcclxuICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIG1baSsgMl0sICA5LCAtNTE0MDM3ODQpO1xyXG4gICAgICBjID0gR0coYywgZCwgYSwgYiwgbVtpKyA3XSwgMTQsICAxNzM1MzI4NDczKTtcclxuICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIG1baSsxMl0sIDIwLCAtMTkyNjYwNzczNCk7XHJcblxyXG4gICAgICBhID0gSEgoYSwgYiwgYywgZCwgbVtpKyA1XSwgIDQsIC0zNzg1NTgpO1xyXG4gICAgICBkID0gSEgoZCwgYSwgYiwgYywgbVtpKyA4XSwgMTEsIC0yMDIyNTc0NDYzKTtcclxuICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIG1baSsxMV0sIDE2LCAgMTgzOTAzMDU2Mik7XHJcbiAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBtW2krMTRdLCAyMywgLTM1MzA5NTU2KTtcclxuICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIG1baSsgMV0sICA0LCAtMTUzMDk5MjA2MCk7XHJcbiAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBtW2krIDRdLCAxMSwgIDEyNzI4OTMzNTMpO1xyXG4gICAgICBjID0gSEgoYywgZCwgYSwgYiwgbVtpKyA3XSwgMTYsIC0xNTU0OTc2MzIpO1xyXG4gICAgICBiID0gSEgoYiwgYywgZCwgYSwgbVtpKzEwXSwgMjMsIC0xMDk0NzMwNjQwKTtcclxuICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIG1baSsxM10sICA0LCAgNjgxMjc5MTc0KTtcclxuICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIG1baSsgMF0sIDExLCAtMzU4NTM3MjIyKTtcclxuICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIG1baSsgM10sIDE2LCAtNzIyNTIxOTc5KTtcclxuICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIG1baSsgNl0sIDIzLCAgNzYwMjkxODkpO1xyXG4gICAgICBhID0gSEgoYSwgYiwgYywgZCwgbVtpKyA5XSwgIDQsIC02NDAzNjQ0ODcpO1xyXG4gICAgICBkID0gSEgoZCwgYSwgYiwgYywgbVtpKzEyXSwgMTEsIC00MjE4MTU4MzUpO1xyXG4gICAgICBjID0gSEgoYywgZCwgYSwgYiwgbVtpKzE1XSwgMTYsICA1MzA3NDI1MjApO1xyXG4gICAgICBiID0gSEgoYiwgYywgZCwgYSwgbVtpKyAyXSwgMjMsIC05OTUzMzg2NTEpO1xyXG5cclxuICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIG1baSsgMF0sICA2LCAtMTk4NjMwODQ0KTtcclxuICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIG1baSsgN10sIDEwLCAgMTEyNjg5MTQxNSk7XHJcbiAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBtW2krMTRdLCAxNSwgLTE0MTYzNTQ5MDUpO1xyXG4gICAgICBiID0gSUkoYiwgYywgZCwgYSwgbVtpKyA1XSwgMjEsIC01NzQzNDA1NSk7XHJcbiAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBtW2krMTJdLCAgNiwgIDE3MDA0ODU1NzEpO1xyXG4gICAgICBkID0gSUkoZCwgYSwgYiwgYywgbVtpKyAzXSwgMTAsIC0xODk0OTg2NjA2KTtcclxuICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIG1baSsxMF0sIDE1LCAtMTA1MTUyMyk7XHJcbiAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBtW2krIDFdLCAyMSwgLTIwNTQ5MjI3OTkpO1xyXG4gICAgICBhID0gSUkoYSwgYiwgYywgZCwgbVtpKyA4XSwgIDYsICAxODczMzEzMzU5KTtcclxuICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIG1baSsxNV0sIDEwLCAtMzA2MTE3NDQpO1xyXG4gICAgICBjID0gSUkoYywgZCwgYSwgYiwgbVtpKyA2XSwgMTUsIC0xNTYwMTk4MzgwKTtcclxuICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIG1baSsxM10sIDIxLCAgMTMwOTE1MTY0OSk7XHJcbiAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBtW2krIDRdLCAgNiwgLTE0NTUyMzA3MCk7XHJcbiAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBtW2krMTFdLCAxMCwgLTExMjAyMTAzNzkpO1xyXG4gICAgICBjID0gSUkoYywgZCwgYSwgYiwgbVtpKyAyXSwgMTUsICA3MTg3ODcyNTkpO1xyXG4gICAgICBiID0gSUkoYiwgYywgZCwgYSwgbVtpKyA5XSwgMjEsIC0zNDM0ODU1NTEpO1xyXG5cclxuICAgICAgYSA9IChhICsgYWEpID4+PiAwO1xyXG4gICAgICBiID0gKGIgKyBiYikgPj4+IDA7XHJcbiAgICAgIGMgPSAoYyArIGNjKSA+Pj4gMDtcclxuICAgICAgZCA9IChkICsgZGQpID4+PiAwO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjcnlwdC5lbmRpYW4oW2EsIGIsIGMsIGRdKTtcclxuICB9O1xyXG5cclxuICAvLyBBdXhpbGlhcnkgZnVuY3Rpb25zXHJcbiAgbWQ1Ll9mZiAgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgeCwgcywgdCkge1xyXG4gICAgdmFyIG4gPSBhICsgKGIgJiBjIHwgfmIgJiBkKSArICh4ID4+PiAwKSArIHQ7XHJcbiAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xyXG4gIH07XHJcbiAgbWQ1Ll9nZyAgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgeCwgcywgdCkge1xyXG4gICAgdmFyIG4gPSBhICsgKGIgJiBkIHwgYyAmIH5kKSArICh4ID4+PiAwKSArIHQ7XHJcbiAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xyXG4gIH07XHJcbiAgbWQ1Ll9oaCAgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgeCwgcywgdCkge1xyXG4gICAgdmFyIG4gPSBhICsgKGIgXiBjIF4gZCkgKyAoeCA+Pj4gMCkgKyB0O1xyXG4gICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcclxuICB9O1xyXG4gIG1kNS5faWkgID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcclxuICAgIHZhciBuID0gYSArIChjIF4gKGIgfCB+ZCkpICsgKHggPj4+IDApICsgdDtcclxuICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XHJcbiAgfTtcclxuXHJcbiAgLy8gUGFja2FnZSBwcml2YXRlIGJsb2Nrc2l6ZVxyXG4gIG1kNS5fYmxvY2tzaXplID0gMTY7XHJcbiAgbWQ1Ll9kaWdlc3RzaXplID0gMTY7XHJcblxyXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG9wdGlvbnMpIHtcclxuICAgIHZhciBkaWdlc3RieXRlcyA9IGNyeXB0LndvcmRzVG9CeXRlcyhtZDUobWVzc2FnZSkpO1xyXG4gICAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5hc0J5dGVzID8gZGlnZXN0Ynl0ZXMgOlxyXG4gICAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5hc1N0cmluZyA/IGJpbi5ieXRlc1RvU3RyaW5nKGRpZ2VzdGJ5dGVzKSA6XHJcbiAgICAgICAgY3J5cHQuYnl0ZXNUb0hleChkaWdlc3RieXRlcyk7XHJcbiAgfTtcclxuXHJcbn0pKCk7XHJcbiIsInZhciBxcyA9IHJlcXVpcmUoJ3FzJylcbnZhciBwYXJzZVVybCA9IHJlcXVpcmUoJ3VybCcpLnBhcnNlXG52YXIgcmVzb2x2ZVVybCA9IHJlcXVpcmUoJ3VybCcpLnJlc29sdmVcbnZhciByZW5kZXJSb3V0ZSA9IHJlcXVpcmUoJy4vcm91dGVyJykucmVuZGVyXG52YXIgY3VycmVudFBhdGggPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoXG5cbi8vIFJlcGxhY2UgdGhlIGluaXRpYWwgc3RhdGUgd2l0aCB0aGUgY3VycmVudCBVUkwgaW1tZWRpYXRlbHksXG4vLyBzbyB0aGF0IGl0IHdpbGwgYmUgcmVuZGVyZWQgaWYgdGhlIHN0YXRlIGlzIGxhdGVyIHBvcHBlZFxuaWYgKHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSkge1xuICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoe1xuICAgICRyZW5kZXI6IHRydWUsXG4gICAgJG1ldGhvZDogJ2dldCdcbiAgfSwgbnVsbCwgd2luZG93LmxvY2F0aW9uLmhyZWYpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gSGlzdG9yeVxuXG5mdW5jdGlvbiBIaXN0b3J5KGNyZWF0ZVBhZ2UsIHJvdXRlcykge1xuICB0aGlzLl9jcmVhdGVQYWdlID0gY3JlYXRlUGFnZVxuICB0aGlzLl9yb3V0ZXMgPSByb3V0ZXNcblxuICBpZiAod2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKSB7XG4gICAgYWRkTGlzdGVuZXJzKHRoaXMpXG4gICAgcmV0dXJuXG4gIH1cbiAgdGhpcy5wdXNoID0gZnVuY3Rpb24odXJsKSB7XG4gICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbih1cmwpXG4gIH1cbiAgdGhpcy5yZXBsYWNlID0gZnVuY3Rpb24odXJsKSB7XG4gICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UodXJsKVxuICB9XG4gIHRoaXMucmVmcmVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICB9XG59XG5cbkhpc3RvcnkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbih1cmwsIHJlbmRlciwgc3RhdGUsIGUpIHtcbiAgdGhpcy5fdXBkYXRlKCdwdXNoU3RhdGUnLCB1cmwsIHJlbmRlciwgc3RhdGUsIGUpXG59XG5cbkhpc3RvcnkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbih1cmwsIHJlbmRlciwgc3RhdGUsIGUpIHtcbiAgdGhpcy5fdXBkYXRlKCdyZXBsYWNlU3RhdGUnLCB1cmwsIHJlbmRlciwgc3RhdGUsIGUpXG59XG5cbi8vIFJlcmVuZGVyIHRoZSBjdXJyZW50IHVybCBsb2NhbGx5XG5IaXN0b3J5LnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRoID0gcm91dGVQYXRoKHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICByZW5kZXJSb3V0ZSh0aGlzLnBhZ2UoKSwge3VybDogcGF0aCwgcHJldmlvdXM6IHBhdGgsIG1ldGhvZDogJ2dldCd9KVxufVxuXG5IaXN0b3J5LnByb3RvdHlwZS5iYWNrID0gZnVuY3Rpb24oKSB7XG4gIHdpbmRvdy5oaXN0b3J5LmJhY2soKVxufVxuXG5IaXN0b3J5LnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24oKSB7XG4gIHdpbmRvdy5oaXN0b3J5LmZvcndhcmQoKVxufVxuXG5IaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uKGkpIHtcbiAgd2luZG93Lmhpc3RvcnkuZ28oaSlcbn1cblxuSGlzdG9yeS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uKGhpc3RvcnlNZXRob2QsIHJlbGF0aXZlVXJsLCByZW5kZXIsIHN0YXRlLCBlKSB7XG4gIHZhciB1cmwgPSByZXNvbHZlVXJsKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCByZWxhdGl2ZVVybClcbiAgdmFyIHBhdGggPSByb3V0ZVBhdGgodXJsKVxuXG4gIC8vIFRPRE86IGhpc3RvcnkucHVzaCBzaG91bGQgc2V0IHRoZSB3aW5kb3cubG9jYXRpb24gd2l0aCBleHRlcm5hbCB1cmxzXG4gIGlmICghcGF0aCkgcmV0dXJuXG4gIGlmIChyZW5kZXIgPT0gbnVsbCkgcmVuZGVyID0gdHJ1ZVxuICBpZiAoc3RhdGUgPT0gbnVsbCkgc3RhdGUgPSB7fVxuXG4gIC8vIFVwZGF0ZSB0aGUgVVJMXG4gIHZhciBvcHRpb25zID0gcmVuZGVyT3B0aW9ucyhlLCBwYXRoKVxuICBzdGF0ZS4kcmVuZGVyID0gdHJ1ZVxuICBzdGF0ZS4kbWV0aG9kID0gb3B0aW9ucy5tZXRob2RcbiAgd2luZG93Lmhpc3RvcnlbaGlzdG9yeU1ldGhvZF0oc3RhdGUsIG51bGwsIG9wdGlvbnMudXJsKVxuICBjdXJyZW50UGF0aCA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2hcbiAgaWYgKHJlbmRlcikgcmVuZGVyUm91dGUodGhpcy5wYWdlKCksIG9wdGlvbnMsIGUpXG59XG5cbkhpc3RvcnkucHJvdG90eXBlLnBhZ2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3BhZ2UpIHJldHVybiB0aGlzLl9wYWdlXG5cbiAgdmFyIHBhZ2UgPSB0aGlzLl9wYWdlID0gdGhpcy5fY3JlYXRlUGFnZSgpXG4gIHZhciBoaXN0b3J5ID0gdGhpc1xuXG4gIGZ1bmN0aW9uIHJlZGlyZWN0KHVybCkge1xuICAgIGlmICh1cmwgPT09ICdiYWNrJykgcmV0dXJuIGhpc3RvcnkuYmFjaygpXG4gICAgLy8gVE9ETzogQWRkIHN1cHBvcnQgZm9yIGBiYXNlcGF0aGAgb3B0aW9uIGxpa2UgRXhwcmVzc1xuICAgIGlmICh1cmwgPT09ICdob21lJykgdXJsID0gJ1xcXFwnXG4gICAgaGlzdG9yeS5yZXBsYWNlKHVybCwgdHJ1ZSlcbiAgfVxuXG4gIHBhZ2UucmVkaXJlY3QgPSByZWRpcmVjdFxuICBwYWdlLl9yb3V0ZXMgPSB0aGlzLl9yb3V0ZXNcbiAgcmV0dXJuIHBhZ2Vcbn1cblxuLy8gR2V0IHRoZSBwYXRobmFtZSBpZiBpdCBpcyBvbiB0aGUgc2FtZSBwcm90b2NvbCBhbmQgZG9tYWluXG5mdW5jdGlvbiByb3V0ZVBhdGgodXJsKSB7XG4gIHZhciBtYXRjaCA9IHBhcnNlVXJsKHVybClcbiAgcmV0dXJuIG1hdGNoICYmXG4gICAgbWF0Y2gucHJvdG9jb2wgPT09IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCAmJlxuICAgIG1hdGNoLmhvc3QgPT09IHdpbmRvdy5sb2NhdGlvbi5ob3N0ICYmXG4gICAgbWF0Y2gucGF0aG5hbWUgKyAobWF0Y2guc2VhcmNoIHx8ICcnKVxufVxuXG5mdW5jdGlvbiByZW5kZXJPcHRpb25zKGUsIHBhdGgpIHtcbiAgLy8gSWYgdGhpcyBpcyBhIGZvcm0gc3VibWlzc2lvbiwgZXh0cmFjdCB0aGUgZm9ybSBkYXRhIGFuZFxuICAvLyBhcHBlbmQgaXQgdG8gdGhlIHVybCBmb3IgYSBnZXQgb3IgcGFyYW1zLmJvZHkgZm9yIGEgcG9zdFxuICBpZiAoZSAmJiBlLnR5cGUgPT09ICdzdWJtaXQnKSB7XG4gICAgdmFyIGZvcm0gPSBlLnRhcmdldFxuICAgIHZhciBlbGVtZW50cyA9IGZvcm0uZWxlbWVudHNcbiAgICB2YXIgcXVlcnkgPSBbXVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbGVtZW50cy5sZW5ndGgsIGVsOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGVsID0gZWxlbWVudHNbaV1cbiAgICAgIHZhciBuYW1lID0gZWwubmFtZVxuICAgICAgaWYgKCFuYW1lKSBjb250aW51ZVxuICAgICAgdmFyIHZhbHVlID0gZWwudmFsdWVcbiAgICAgIHF1ZXJ5LnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSlcbiAgICAgIGlmIChuYW1lID09PSAnX21ldGhvZCcpIHtcbiAgICAgICAgdmFyIG92ZXJyaWRlID0gdmFsdWUudG9Mb3dlckNhc2UoKVxuICAgICAgICBpZiAob3ZlcnJpZGUgPT09ICdkZWxldGUnKSBvdmVycmlkZSA9ICdkZWwnXG4gICAgICB9XG4gICAgfVxuICAgIHF1ZXJ5ID0gcXVlcnkuam9pbignJicpXG4gICAgaWYgKGZvcm0ubWV0aG9kLnRvTG93ZXJDYXNlKCkgPT09ICdwb3N0Jykge1xuICAgICAgdmFyIG1ldGhvZCA9IG92ZXJyaWRlIHx8ICdwb3N0J1xuICAgICAgdmFyIGJvZHkgPSBxcy5wYXJzZShxdWVyeSlcbiAgICB9IGVsc2Uge1xuICAgICAgbWV0aG9kID0gJ2dldCdcbiAgICAgIHBhdGggKz0gJz8nICsgcXVlcnlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWV0aG9kID0gJ2dldCdcbiAgfVxuICByZXR1cm4ge1xuICAgIG1ldGhvZDogbWV0aG9kXG4gICwgdXJsOiBwYXRoXG4gICwgcHJldmlvdXM6IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2hcbiAgLCBib2R5OiBib2R5XG4gICwgZm9ybTogZm9ybVxuICAsIGxpbms6IGUgJiYgZS5fdHJhY2tzTGlua1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZExpc3RlbmVycyhoaXN0b3J5KSB7XG5cbiAgLy8gRGV0ZWN0IGNsaWNrcyBvbiBsaW5rc1xuICBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICB2YXIgZWwgPSBlLnRhcmdldFxuXG4gICAgLy8gSWdub3JlIGNvbW1hbmQgY2xpY2ssIGNvbnRyb2wgY2xpY2ssIGFuZCBub24tbGVmdCBjbGlja1xuICAgIGlmIChlLm1ldGFLZXkgfHwgZS53aGljaCAhPT0gMSkgcmV0dXJuXG5cbiAgICAvLyBJZ25vcmUgaWYgYWxyZWFkeSBwcmV2ZW50ZWRcbiAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkIHx8IGUucmV0dXJuVmFsdWUgPT09IGZhbHNlKSByZXR1cm5cblxuICAgIC8vIEFsc28gbG9vayB1cCBmb3IgcGFyZW50IGxpbmtzICg8YT48aW1nPjwvYT4pXG4gICAgd2hpbGUgKGVsKSB7XG4gICAgICB2YXIgdXJsID0gZWwuaHJlZlxuICAgICAgaWYgKHVybCkge1xuXG4gICAgICAgIC8vIElnbm9yZSBpZiBjcmVhdGVkIGJ5IFRyYWNrc1xuICAgICAgICBpZiAoZWwuaGFzQXR0cmlidXRlICYmIGVsLmhhc0F0dHJpYnV0ZSgnZGF0YS1yb3V0ZXItaWdub3JlJykpIHJldHVyblxuXG4gICAgICAgIC8vIElnbm9yZSBsaW5rcyBtZWFudCB0byBvcGVuIGluIGEgZGlmZmVyZW50IHdpbmRvdyBvciBmcmFtZVxuICAgICAgICBpZiAoZWwudGFyZ2V0ICYmIGVsLnRhcmdldCAhPT0gJ19zZWxmJykgcmV0dXJuXG5cbiAgICAgICAgLy8gSWdub3JlIGhhc2ggbGlua3MgdG8gdGhlIHNhbWUgcGFnZVxuICAgICAgICB2YXIgaGFzaEluZGV4ID0gdXJsLmluZGV4T2YoJyMnKVxuICAgICAgICBpZiAofmhhc2hJbmRleCAmJiB1cmwuc2xpY2UoMCwgaGFzaEluZGV4KSA9PT0gd2luZG93LmxvY2F0aW9uLmhyZWYucmVwbGFjZSgvIy4qLywgJycpKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBlLl90cmFja3NMaW5rID0gZWxcbiAgICAgICAgaGlzdG9yeS5wdXNoKHVybCwgdHJ1ZSwgbnVsbCwgZSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGVsID0gZWwucGFyZW50Tm9kZVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uU3VibWl0KGUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXRcblxuICAgIC8vIElnbm9yZSBpZiBhbHJlYWR5IHByZXZlbnRlZFxuICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQgfHwgZS5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UpIHJldHVyblxuXG4gICAgLy8gT25seSBoYW5kbGUgaWYgZW1pdHRlZCBvbiBhIGZvcm0gZWxlbWVudCB0aGF0IGlzbid0IG11bHRpcGFydFxuICAgIGlmICh0YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnZm9ybScpIHJldHVyblxuICAgIGlmICh0YXJnZXQuZW5jdHlwZSA9PT0gJ211bHRpcGFydC9mb3JtLWRhdGEnKSByZXR1cm5cblxuICAgIC8vIElnbm9yZSBpZiBjcmVhdGVkIGJ5IFRyYWNrc1xuICAgIGlmICh0YXJnZXQuaGFzQXR0cmlidXRlICYmIHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2RhdGEtcm91dGVyLWlnbm9yZScpKSByZXR1cm5cblxuICAgIC8vIFVzZSB0aGUgdXJsIGZyb20gdGhlIGZvcm0gYWN0aW9uLCBkZWZhdWx0aW5nIHRvIHRoZSBjdXJyZW50IHVybFxuICAgIHZhciB1cmwgPSB0YXJnZXQuYWN0aW9uIHx8IHdpbmRvdy5sb2NhdGlvbi5ocmVmXG4gICAgaGlzdG9yeS5wdXNoKHVybCwgdHJ1ZSwgbnVsbCwgZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUG9wU3RhdGUoZSkge1xuICAgIHZhciBwcmV2aW91cyA9IGN1cnJlbnRQYXRoXG4gICAgdmFyIHN0YXRlID0gZS5zdGF0ZVxuICAgIGN1cnJlbnRQYXRoID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaFxuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBwcmV2aW91czogcHJldmlvdXNcbiAgICAsIHVybDogY3VycmVudFBhdGhcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIGlmICghc3RhdGUuJHJlbmRlcikgcmV0dXJuXG4gICAgICBvcHRpb25zLm1ldGhvZCA9IHN0YXRlLiRtZXRob2RcbiAgICAgIC8vIE5vdGUgdGhhdCB0aGUgcG9zdCBib2R5IGlzIG9ubHkgc2VudCBvbiB0aGUgaW5pdGlhbCByZXFlc3RcbiAgICAgIC8vIGFuZCBpdCBpcyBlbXB0eSBpZiB0aGUgc3RhdGUgaXMgbGF0ZXIgcG9wcGVkXG4gICAgICByZXR1cm4gcmVuZGVyUm91dGUoaGlzdG9yeS5wYWdlKCksIG9wdGlvbnMpXG4gICAgfVxuXG4gICAgLy8gVGhlIHN0YXRlIG9iamVjdCB3aWxsIGJlIG51bGwgZm9yIHN0YXRlcyBjcmVhdGVkIGJ5IGp1bXAgbGlua3MuXG4gICAgLy8gd2luZG93LmxvY2F0aW9uLmhhc2ggY2Fubm90IGJlIHVzZWQsIGJlY2F1c2UgaXQgcmV0dXJucyBub3RoaW5nXG4gICAgLy8gaWYgdGhlIHVybCBlbmRzIGluIGp1c3QgYSBoYXNoIGNoYXJhY3RlclxuICAgIHZhciB1cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZlxuICAgICAgLCBoYXNoSW5kZXggPSB1cmwuaW5kZXhPZignIycpXG4gICAgICAsIGVsLCBpZFxuICAgIGlmICh+aGFzaEluZGV4ICYmIGN1cnJlbnRQYXRoICE9PSBwcmV2aW91cykge1xuICAgICAgb3B0aW9ucy5tZXRob2QgPSAnZ2V0J1xuICAgICAgcmVuZGVyUm91dGUoaGlzdG9yeS5wYWdlKCksIG9wdGlvbnMpXG4gICAgICBpZCA9IHVybC5zbGljZShoYXNoSW5kZXggKyAxKVxuICAgICAgaWYgKGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKGlkKVswXSkge1xuICAgICAgICBlbC5zY3JvbGxJbnRvVmlldygpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbkNsaWNrLCBmYWxzZSlcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc3VibWl0Jywgb25TdWJtaXQsIGZhbHNlKVxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBvblBvcFN0YXRlLCBmYWxzZSlcbn1cbiIsIlxuZXhwb3J0cy5Db25uZWN0aW9uID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uJykuQ29ubmVjdGlvbjtcbmV4cG9ydHMuRG9jID0gcmVxdWlyZSgnLi9kb2MnKS5Eb2M7XG4iLCIvKipcbiAqIE9iamVjdCN0b1N0cmluZygpIHJlZiBmb3Igc3RyaW5naWZ5KCkuXG4gKi9cblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBPYmplY3QjaGFzT3duUHJvcGVydHkgcmVmXG4gKi9cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBcnJheSNpbmRleE9mIHNoaW0uXG4gKi9cblxudmFyIGluZGV4T2YgPSB0eXBlb2YgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbidcbiAgPyBmdW5jdGlvbihhcnIsIGVsKSB7IHJldHVybiBhcnIuaW5kZXhPZihlbCk7IH1cbiAgOiBmdW5jdGlvbihhcnIsIGVsKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYXJyW2ldID09PSBlbCkgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcblxuLyoqXG4gKiBBcnJheS5pc0FycmF5IHNoaW0uXG4gKi9cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG4vKipcbiAqIE9iamVjdC5rZXlzIHNoaW0uXG4gKi9cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbihvYmopIHtcbiAgdmFyIHJldCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSByZXQucHVzaChrZXkpO1xuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBBcnJheSNmb3JFYWNoIHNoaW0uXG4gKi9cblxudmFyIGZvckVhY2ggPSB0eXBlb2YgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggPT09ICdmdW5jdGlvbidcbiAgPyBmdW5jdGlvbihhcnIsIGZuKSB7IHJldHVybiBhcnIuZm9yRWFjaChmbik7IH1cbiAgOiBmdW5jdGlvbihhcnIsIGZuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgZm4oYXJyW2ldKTtcbiAgICB9O1xuXG4vKipcbiAqIEFycmF5I3JlZHVjZSBzaGltLlxuICovXG5cbnZhciByZWR1Y2UgPSBmdW5jdGlvbihhcnIsIGZuLCBpbml0aWFsKSB7XG4gIGlmICh0eXBlb2YgYXJyLnJlZHVjZSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGFyci5yZWR1Y2UoZm4sIGluaXRpYWwpO1xuICB2YXIgcmVzID0gaW5pdGlhbDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHJlcyA9IGZuKHJlcywgYXJyW2ldKTtcbiAgcmV0dXJuIHJlcztcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbnVsbGFyeSBvYmplY3QgaWYgcG9zc2libGVcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVPYmplY3QoKSB7XG4gIHJldHVybiBPYmplY3QuY3JlYXRlXG4gICAgPyBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgOiB7fTtcbn1cblxuLyoqXG4gKiBDYWNoZSBub24taW50ZWdlciB0ZXN0IHJlZ2V4cC5cbiAqL1xuXG52YXIgaXNpbnQgPSAvXlswLTldKyQvO1xuXG5mdW5jdGlvbiBwcm9tb3RlKHBhcmVudCwga2V5KSB7XG4gIGlmIChwYXJlbnRba2V5XS5sZW5ndGggPT0gMCkgcmV0dXJuIHBhcmVudFtrZXldID0gY3JlYXRlT2JqZWN0KCk7XG4gIHZhciB0ID0gY3JlYXRlT2JqZWN0KCk7XG4gIGZvciAodmFyIGkgaW4gcGFyZW50W2tleV0pIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwYXJlbnRba2V5XSwgaSkpIHtcbiAgICAgIHRbaV0gPSBwYXJlbnRba2V5XVtpXTtcbiAgICB9XG4gIH1cbiAgcGFyZW50W2tleV0gPSB0O1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gcGFyc2UocGFydHMsIHBhcmVudCwga2V5LCB2YWwpIHtcbiAgdmFyIHBhcnQgPSBwYXJ0cy5zaGlmdCgpO1xuICAvLyBlbmRcbiAgaWYgKCFwYXJ0KSB7XG4gICAgaWYgKGlzQXJyYXkocGFyZW50W2tleV0pKSB7XG4gICAgICBwYXJlbnRba2V5XS5wdXNoKHZhbCk7XG4gICAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PSB0eXBlb2YgcGFyZW50W2tleV0pIHtcbiAgICAgIHBhcmVudFtrZXldID0gdmFsO1xuICAgIH0gZWxzZSBpZiAoJ3VuZGVmaW5lZCcgPT0gdHlwZW9mIHBhcmVudFtrZXldKSB7XG4gICAgICBwYXJlbnRba2V5XSA9IHZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50W2tleV0gPSBbcGFyZW50W2tleV0sIHZhbF07XG4gICAgfVxuICAgIC8vIGFycmF5XG4gIH0gZWxzZSB7XG4gICAgdmFyIG9iaiA9IHBhcmVudFtrZXldID0gcGFyZW50W2tleV0gfHwgW107XG4gICAgaWYgKCddJyA9PSBwYXJ0KSB7XG4gICAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICAgIGlmICgnJyAhPSB2YWwpIG9iai5wdXNoKHZhbCk7XG4gICAgICB9IGVsc2UgaWYgKCdvYmplY3QnID09IHR5cGVvZiBvYmopIHtcbiAgICAgICAgb2JqW29iamVjdEtleXMob2JqKS5sZW5ndGhdID0gdmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqID0gcGFyZW50W2tleV0gPSBbcGFyZW50W2tleV0sIHZhbF07XG4gICAgICB9XG4gICAgICAvLyBwcm9wXG4gICAgfSBlbHNlIGlmICh+aW5kZXhPZihwYXJ0LCAnXScpKSB7XG4gICAgICBwYXJ0ID0gcGFydC5zdWJzdHIoMCwgcGFydC5sZW5ndGggLSAxKTtcbiAgICAgIGlmICghaXNpbnQudGVzdChwYXJ0KSAmJiBpc0FycmF5KG9iaikpIG9iaiA9IHByb21vdGUocGFyZW50LCBrZXkpO1xuICAgICAgcGFyc2UocGFydHMsIG9iaiwgcGFydCwgdmFsKTtcbiAgICAgIC8vIGtleVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWlzaW50LnRlc3QocGFydCkgJiYgaXNBcnJheShvYmopKSBvYmogPSBwcm9tb3RlKHBhcmVudCwga2V5KTtcbiAgICAgIHBhcnNlKHBhcnRzLCBvYmosIHBhcnQsIHZhbCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgcGFyZW50IGtleS92YWwgcGFpci5cbiAqL1xuXG5mdW5jdGlvbiBtZXJnZShwYXJlbnQsIGtleSwgdmFsKXtcbiAgaWYgKH5pbmRleE9mKGtleSwgJ10nKSkge1xuICAgIHZhciBwYXJ0cyA9IGtleS5zcGxpdCgnWycpXG4gICAgICAsIGxlbiA9IHBhcnRzLmxlbmd0aFxuICAgICAgLCBsYXN0ID0gbGVuIC0gMTtcbiAgICBwYXJzZShwYXJ0cywgcGFyZW50LCAnYmFzZScsIHZhbCk7XG4gICAgLy8gb3B0aW1pemVcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWlzaW50LnRlc3Qoa2V5KSAmJiBpc0FycmF5KHBhcmVudC5iYXNlKSkge1xuICAgICAgdmFyIHQgPSBjcmVhdGVPYmplY3QoKTtcbiAgICAgIGZvciAodmFyIGsgaW4gcGFyZW50LmJhc2UpIHRba10gPSBwYXJlbnQuYmFzZVtrXTtcbiAgICAgIHBhcmVudC5iYXNlID0gdDtcbiAgICB9XG4gICAgc2V0KHBhcmVudC5iYXNlLCBrZXksIHZhbCk7XG4gIH1cblxuICByZXR1cm4gcGFyZW50O1xufVxuXG4vKipcbiAqIENvbXBhY3Qgc3BhcnNlIGFycmF5cy5cbiAqL1xuXG5mdW5jdGlvbiBjb21wYWN0KG9iaikge1xuICBpZiAoJ29iamVjdCcgIT0gdHlwZW9mIG9iaikgcmV0dXJuIG9iajtcblxuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgdmFyIHJldCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIHtcbiAgICAgICAgcmV0LnB1c2gob2JqW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIG9ialtrZXldID0gY29tcGFjdChvYmpba2V5XSk7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIFJlc3RvcmUgT2JqZWN0LnByb3RvdHlwZS5cbiAqIHNlZSBwdWxsLXJlcXVlc3QgIzU4XG4gKi9cblxuZnVuY3Rpb24gcmVzdG9yZVByb3RvKG9iaikge1xuICBpZiAoIU9iamVjdC5jcmVhdGUpIHJldHVybiBvYmo7XG4gIGlmIChpc0FycmF5KG9iaikpIHJldHVybiBvYmo7XG4gIGlmIChvYmogJiYgJ29iamVjdCcgIT0gdHlwZW9mIG9iaikgcmV0dXJuIG9iajtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICBvYmpba2V5XSA9IHJlc3RvcmVQcm90byhvYmpba2V5XSk7XG4gICAgfVxuICB9XG5cbiAgb2JqLl9fcHJvdG9fXyA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIG9iai5cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZU9iamVjdChvYmope1xuICB2YXIgcmV0ID0geyBiYXNlOiB7fSB9O1xuXG4gIGZvckVhY2gob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihuYW1lKXtcbiAgICBtZXJnZShyZXQsIG5hbWUsIG9ialtuYW1lXSk7XG4gIH0pO1xuXG4gIHJldHVybiBjb21wYWN0KHJldC5iYXNlKTtcbn1cblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gc3RyLlxuICovXG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0cil7XG4gIHZhciByZXQgPSByZWR1Y2UoU3RyaW5nKHN0cikuc3BsaXQoJyYnKSwgZnVuY3Rpb24ocmV0LCBwYWlyKXtcbiAgICB2YXIgZXFsID0gaW5kZXhPZihwYWlyLCAnPScpXG4gICAgICAsIGJyYWNlID0gbGFzdEJyYWNlSW5LZXkocGFpcilcbiAgICAgICwga2V5ID0gcGFpci5zdWJzdHIoMCwgYnJhY2UgfHwgZXFsKVxuICAgICAgLCB2YWwgPSBwYWlyLnN1YnN0cihicmFjZSB8fCBlcWwsIHBhaXIubGVuZ3RoKVxuICAgICAgLCB2YWwgPSB2YWwuc3Vic3RyKGluZGV4T2YodmFsLCAnPScpICsgMSwgdmFsLmxlbmd0aCk7XG5cbiAgICAvLyA/Zm9vXG4gICAgaWYgKCcnID09IGtleSkga2V5ID0gcGFpciwgdmFsID0gJyc7XG4gICAgaWYgKCcnID09IGtleSkgcmV0dXJuIHJldDtcblxuICAgIHJldHVybiBtZXJnZShyZXQsIGRlY29kZShrZXkpLCBkZWNvZGUodmFsKSk7XG4gIH0sIHsgYmFzZTogY3JlYXRlT2JqZWN0KCkgfSkuYmFzZTtcblxuICByZXR1cm4gcmVzdG9yZVByb3RvKGNvbXBhY3QocmV0KSk7XG59XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIHF1ZXJ5IGBzdHJgIG9yIGBvYmpgLCByZXR1cm5pbmcgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgfCB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uKHN0cil7XG4gIGlmIChudWxsID09IHN0ciB8fCAnJyA9PSBzdHIpIHJldHVybiB7fTtcbiAgcmV0dXJuICdvYmplY3QnID09IHR5cGVvZiBzdHJcbiAgICA/IHBhcnNlT2JqZWN0KHN0cilcbiAgICA6IHBhcnNlU3RyaW5nKHN0cik7XG59O1xuXG4vKipcbiAqIFR1cm4gdGhlIGdpdmVuIGBvYmpgIGludG8gYSBxdWVyeSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnZhciBzdHJpbmdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uKG9iaiwgcHJlZml4KSB7XG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5QXJyYXkob2JqLCBwcmVmaXgpO1xuICB9IGVsc2UgaWYgKCdbb2JqZWN0IE9iamVjdF0nID09IHRvU3RyaW5nLmNhbGwob2JqKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlPYmplY3Qob2JqLCBwcmVmaXgpO1xuICB9IGVsc2UgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBvYmopIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5U3RyaW5nKG9iaiwgcHJlZml4KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJlZml4ICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhvYmopKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTdHJpbmdpZnkgdGhlIGdpdmVuIGBzdHJgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXhcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVN0cmluZyhzdHIsIHByZWZpeCkge1xuICBpZiAoIXByZWZpeCkgdGhyb3cgbmV3IFR5cGVFcnJvcignc3RyaW5naWZ5IGV4cGVjdHMgYW4gb2JqZWN0Jyk7XG4gIHJldHVybiBwcmVmaXggKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyKTtcbn1cblxuLyoqXG4gKiBTdHJpbmdpZnkgdGhlIGdpdmVuIGBhcnJgLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc3RyaW5naWZ5QXJyYXkoYXJyLCBwcmVmaXgpIHtcbiAgdmFyIHJldCA9IFtdO1xuICBpZiAoIXByZWZpeCkgdGhyb3cgbmV3IFR5cGVFcnJvcignc3RyaW5naWZ5IGV4cGVjdHMgYW4gb2JqZWN0Jyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgcmV0LnB1c2goc3RyaW5naWZ5KGFycltpXSwgcHJlZml4ICsgJ1snICsgaSArICddJykpO1xuICB9XG4gIHJldHVybiByZXQuam9pbignJicpO1xufVxuXG4vKipcbiAqIFN0cmluZ2lmeSB0aGUgZ2l2ZW4gYG9iamAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0KG9iaiwgcHJlZml4KSB7XG4gIHZhciByZXQgPSBbXVxuICAgICwga2V5cyA9IG9iamVjdEtleXMob2JqKVxuICAgICwga2V5O1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoJycgPT0ga2V5KSBjb250aW51ZTtcbiAgICBpZiAobnVsbCA9PSBvYmpba2V5XSkge1xuICAgICAgcmV0LnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXQucHVzaChzdHJpbmdpZnkob2JqW2tleV0sIHByZWZpeFxuICAgICAgICA/IHByZWZpeCArICdbJyArIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJ10nXG4gICAgICAgIDogZW5jb2RlVVJJQ29tcG9uZW50KGtleSkpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0LmpvaW4oJyYnKTtcbn1cblxuLyoqXG4gKiBTZXQgYG9iamAncyBga2V5YCB0byBgdmFsYCByZXNwZWN0aW5nXG4gKiB0aGUgd2VpcmQgYW5kIHdvbmRlcmZ1bCBzeW50YXggb2YgYSBxcyxcbiAqIHdoZXJlIFwiZm9vPWJhciZmb289YmF6XCIgYmVjb21lcyBhbiBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZXQob2JqLCBrZXksIHZhbCkge1xuICB2YXIgdiA9IG9ialtrZXldO1xuICBpZiAodW5kZWZpbmVkID09PSB2KSB7XG4gICAgb2JqW2tleV0gPSB2YWw7XG4gIH0gZWxzZSBpZiAoaXNBcnJheSh2KSkge1xuICAgIHYucHVzaCh2YWwpO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gW3YsIHZhbF07XG4gIH1cbn1cblxuLyoqXG4gKiBMb2NhdGUgbGFzdCBicmFjZSBpbiBgc3RyYCB3aXRoaW4gdGhlIGtleS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsYXN0QnJhY2VJbktleShzdHIpIHtcbiAgdmFyIGxlbiA9IHN0ci5sZW5ndGhcbiAgICAsIGJyYWNlXG4gICAgLCBjO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgYyA9IHN0cltpXTtcbiAgICBpZiAoJ10nID09IGMpIGJyYWNlID0gZmFsc2U7XG4gICAgaWYgKCdbJyA9PSBjKSBicmFjZSA9IHRydWU7XG4gICAgaWYgKCc9JyA9PSBjICYmICFicmFjZSkgcmV0dXJuIGk7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWNvZGUgYHN0cmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgYmFzZTY0bWFwXG4gICAgICA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJyxcblxuICBjcnlwdCA9IHtcbiAgICAvLyBCaXQtd2lzZSByb3RhdGlvbiBsZWZ0XG4gICAgcm90bDogZnVuY3Rpb24obiwgYikge1xuICAgICAgcmV0dXJuIChuIDw8IGIpIHwgKG4gPj4+ICgzMiAtIGIpKTtcbiAgICB9LFxuXG4gICAgLy8gQml0LXdpc2Ugcm90YXRpb24gcmlnaHRcbiAgICByb3RyOiBmdW5jdGlvbihuLCBiKSB7XG4gICAgICByZXR1cm4gKG4gPDwgKDMyIC0gYikpIHwgKG4gPj4+IGIpO1xuICAgIH0sXG5cbiAgICAvLyBTd2FwIGJpZy1lbmRpYW4gdG8gbGl0dGxlLWVuZGlhbiBhbmQgdmljZSB2ZXJzYVxuICAgIGVuZGlhbjogZnVuY3Rpb24obikge1xuICAgICAgLy8gSWYgbnVtYmVyIGdpdmVuLCBzd2FwIGVuZGlhblxuICAgICAgaWYgKG4uY29uc3RydWN0b3IgPT0gTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBjcnlwdC5yb3RsKG4sIDgpICYgMHgwMEZGMDBGRiB8IGNyeXB0LnJvdGwobiwgMjQpICYgMHhGRjAwRkYwMDtcbiAgICAgIH1cblxuICAgICAgLy8gRWxzZSwgYXNzdW1lIGFycmF5IGFuZCBzd2FwIGFsbCBpdGVtc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuLmxlbmd0aDsgaSsrKVxuICAgICAgICBuW2ldID0gY3J5cHQuZW5kaWFuKG5baV0pO1xuICAgICAgcmV0dXJuIG47XG4gICAgfSxcblxuICAgIC8vIEdlbmVyYXRlIGFuIGFycmF5IG9mIGFueSBsZW5ndGggb2YgcmFuZG9tIGJ5dGVzXG4gICAgcmFuZG9tQnl0ZXM6IGZ1bmN0aW9uKG4pIHtcbiAgICAgIGZvciAodmFyIGJ5dGVzID0gW107IG4gPiAwOyBuLS0pXG4gICAgICAgIGJ5dGVzLnB1c2goTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KSk7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBieXRlIGFycmF5IHRvIGJpZy1lbmRpYW4gMzItYml0IHdvcmRzXG4gICAgYnl0ZXNUb1dvcmRzOiBmdW5jdGlvbihieXRlcykge1xuICAgICAgZm9yICh2YXIgd29yZHMgPSBbXSwgaSA9IDAsIGIgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyssIGIgKz0gOClcbiAgICAgICAgd29yZHNbYiA+Pj4gNV0gfD0gYnl0ZXNbaV0gPDwgKDI0IC0gYiAlIDMyKTtcbiAgICAgIHJldHVybiB3b3JkcztcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBiaWctZW5kaWFuIDMyLWJpdCB3b3JkcyB0byBhIGJ5dGUgYXJyYXlcbiAgICB3b3Jkc1RvQnl0ZXM6IGZ1bmN0aW9uKHdvcmRzKSB7XG4gICAgICBmb3IgKHZhciBieXRlcyA9IFtdLCBiID0gMDsgYiA8IHdvcmRzLmxlbmd0aCAqIDMyOyBiICs9IDgpXG4gICAgICAgIGJ5dGVzLnB1c2goKHdvcmRzW2IgPj4+IDVdID4+PiAoMjQgLSBiICUgMzIpKSAmIDB4RkYpO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBhIGhleCBzdHJpbmdcbiAgICBieXRlc1RvSGV4OiBmdW5jdGlvbihieXRlcykge1xuICAgICAgZm9yICh2YXIgaGV4ID0gW10sIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4LnB1c2goKGJ5dGVzW2ldID4+PiA0KS50b1N0cmluZygxNikpO1xuICAgICAgICBoZXgucHVzaCgoYnl0ZXNbaV0gJiAweEYpLnRvU3RyaW5nKDE2KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGV4LmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgaGV4IHN0cmluZyB0byBhIGJ5dGUgYXJyYXlcbiAgICBoZXhUb0J5dGVzOiBmdW5jdGlvbihoZXgpIHtcbiAgICAgIGZvciAodmFyIGJ5dGVzID0gW10sIGMgPSAwOyBjIDwgaGV4Lmxlbmd0aDsgYyArPSAyKVxuICAgICAgICBieXRlcy5wdXNoKHBhcnNlSW50KGhleC5zdWJzdHIoYywgMiksIDE2KSk7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBieXRlIGFycmF5IHRvIGEgYmFzZS02NCBzdHJpbmdcbiAgICBieXRlc1RvQmFzZTY0OiBmdW5jdGlvbihieXRlcykge1xuICAgICAgZm9yICh2YXIgYmFzZTY0ID0gW10sIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdmFyIHRyaXBsZXQgPSAoYnl0ZXNbaV0gPDwgMTYpIHwgKGJ5dGVzW2kgKyAxXSA8PCA4KSB8IGJ5dGVzW2kgKyAyXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA0OyBqKyspXG4gICAgICAgICAgaWYgKGkgKiA4ICsgaiAqIDYgPD0gYnl0ZXMubGVuZ3RoICogOClcbiAgICAgICAgICAgIGJhc2U2NC5wdXNoKGJhc2U2NG1hcC5jaGFyQXQoKHRyaXBsZXQgPj4+IDYgKiAoMyAtIGopKSAmIDB4M0YpKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBiYXNlNjQucHVzaCgnPScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2U2NC5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIGJhc2UtNjQgc3RyaW5nIHRvIGEgYnl0ZSBhcnJheVxuICAgIGJhc2U2NFRvQnl0ZXM6IGZ1bmN0aW9uKGJhc2U2NCkge1xuICAgICAgLy8gUmVtb3ZlIG5vbi1iYXNlLTY0IGNoYXJhY3RlcnNcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5yZXBsYWNlKC9bXkEtWjAtOStcXC9dL2lnLCAnJyk7XG5cbiAgICAgIGZvciAodmFyIGJ5dGVzID0gW10sIGkgPSAwLCBpbW9kNCA9IDA7IGkgPCBiYXNlNjQubGVuZ3RoO1xuICAgICAgICAgIGltb2Q0ID0gKytpICUgNCkge1xuICAgICAgICBpZiAoaW1vZDQgPT0gMCkgY29udGludWU7XG4gICAgICAgIGJ5dGVzLnB1c2goKChiYXNlNjRtYXAuaW5kZXhPZihiYXNlNjQuY2hhckF0KGkgLSAxKSlcbiAgICAgICAgICAgICYgKE1hdGgucG93KDIsIC0yICogaW1vZDQgKyA4KSAtIDEpKSA8PCAoaW1vZDQgKiAyKSlcbiAgICAgICAgICAgIHwgKGJhc2U2NG1hcC5pbmRleE9mKGJhc2U2NC5jaGFyQXQoaSkpID4+PiAoNiAtIGltb2Q0ICogMikpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBjcnlwdDtcbn0pKCk7XG4iLCJ2YXIgY2hhcmVuYyA9IHtcbiAgLy8gVVRGLTggZW5jb2RpbmdcbiAgdXRmODoge1xuICAgIC8vIENvbnZlcnQgYSBzdHJpbmcgdG8gYSBieXRlIGFycmF5XG4gICAgc3RyaW5nVG9CeXRlczogZnVuY3Rpb24oc3RyKSB7XG4gICAgICByZXR1cm4gY2hhcmVuYy5iaW4uc3RyaW5nVG9CeXRlcyh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSkpO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBhIHN0cmluZ1xuICAgIGJ5dGVzVG9TdHJpbmc6IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShjaGFyZW5jLmJpbi5ieXRlc1RvU3RyaW5nKGJ5dGVzKSkpO1xuICAgIH1cbiAgfSxcblxuICAvLyBCaW5hcnkgZW5jb2RpbmdcbiAgYmluOiB7XG4gICAgLy8gQ29udmVydCBhIHN0cmluZyB0byBhIGJ5dGUgYXJyYXlcbiAgICBzdHJpbmdUb0J5dGVzOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIGZvciAodmFyIGJ5dGVzID0gW10sIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKVxuICAgICAgICBieXRlcy5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRik7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBieXRlIGFycmF5IHRvIGEgc3RyaW5nXG4gICAgYnl0ZXNUb1N0cmluZzogZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGZvciAodmFyIHN0ciA9IFtdLCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICBzdHIucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKSk7XG4gICAgICByZXR1cm4gc3RyLmpvaW4oJycpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjaGFyZW5jO1xuIiwiLy8gVGhpcyBpcyBhIHNpbXBsZSByZXdyaXRlIG9mIG1pY3JvZXZlbnQuanMuIEkndmUgY2hhbmdlZCB0aGVcbi8vIGZ1bmN0aW9uIG5hbWVzIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBub2RlLmpzIEV2ZW50RW1pdHRlci5cbi8vXG4vLyBtaWNyb2V2ZW50LmpzIGlzIGNvcHlyaWdodCBKZXJvbWUgRXRpZW5uZSwgYW5kIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qZXJvbWVldGllbm5lL21pY3JvZXZlbnQuanNcblxudmFyIE1pY3JvRXZlbnQgPSBmdW5jdGlvbigpIHt9O1xuXG5NaWNyb0V2ZW50LnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2ZW50LCBmbikge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICAoZXZlbnRzW2V2ZW50XSA9IGV2ZW50c1tldmVudF0gfHwgW10pLnB1c2goZm4pO1xufTtcblxuTWljcm9FdmVudC5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdmFyIGxpc3RlbmVycyA9IGV2ZW50c1tldmVudF0gPSBldmVudHNbZXZlbnRdIHx8IFtdO1xuXG4gIC8vIFNhZGx5LCBubyBJRTggc3VwcG9ydCBmb3IgaW5kZXhPZi5cbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoaSA8IGxpc3RlbmVycy5sZW5ndGgpIHtcbiAgICBpZiAobGlzdGVuZXJzW2ldID09PSBmbikge1xuICAgICAgbGlzdGVuZXJzW2ldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpKys7XG4gIH1cblxuICAvLyBDb21wYWN0IHRoZSBsaXN0IHdoZW4gbm8gZXZlbnQgaGFuZGxlciBpcyBhY3R1YWxseSBydW5uaW5nLlxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGV2ZW50c1tldmVudF0gPSBbXTtcbiAgICB2YXIgZm47XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIE9ubHkgYWRkIGJhY2sgZXZlbnQgaGFuZGxlcnMgd2hpY2ggZXhpc3QuXG4gICAgICBpZiAoKGZuID0gbGlzdGVuZXJzW2ldKSkgZXZlbnRzW2V2ZW50XS5wdXNoKGZuKTtcbiAgICB9XG4gIH0sIDApO1xufTtcblxuTWljcm9FdmVudC5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgaWYgKCFldmVudHMgfHwgIWV2ZW50c1tldmVudF0pIHtcbiAgICBpZiAoZXZlbnQgPT0gJ2Vycm9yJykge1xuICAgICAgaWYgKGNvbnNvbGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IGV2ZW50c1tldmVudF07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxpc3RlbmVyc1tpXSkge1xuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxufTtcblxuTWljcm9FdmVudC5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbikge1xuICB2YXIgbGlzdGVuZXIsIF90aGlzID0gdGhpcztcbiAgdGhpcy5vbihldmVudCwgbGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcbiAgICBfdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICAgIGZuLmFwcGx5KF90aGlzLCBhcmd1bWVudHMpO1xuICB9KTtcbn07XG5cbk1pY3JvRXZlbnQubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIHByb3RvID0gb2JqLnByb3RvdHlwZSB8fCBvYmo7XG4gIHByb3RvLm9uID0gTWljcm9FdmVudC5wcm90b3R5cGUub247XG4gIHByb3RvLnJlbW92ZUxpc3RlbmVyID0gTWljcm9FdmVudC5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG4gIHByb3RvLmVtaXQgPSBNaWNyb0V2ZW50LnByb3RvdHlwZS5lbWl0O1xuICBwcm90by5vbmNlID0gTWljcm9FdmVudC5wcm90b3R5cGUub25jZTtcbiAgcmV0dXJuIG9iajtcbn07XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiKSBtb2R1bGUuZXhwb3J0cyA9IE1pY3JvRXZlbnQ7XG5cbiIsInZhciBEb2M7XG5pZiAodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSB7XG4gIERvYyA9IHJlcXVpcmUoJy4vZG9jJykuRG9jO1xufVxuXG4vLyBRdWVyaWVzIGFyZSBsaXZlIHJlcXVlc3RzIHRvIHRoZSBkYXRhYmFzZSBmb3IgcGFydGljdWxhciBzZXRzIG9mIGZpZWxkcy5cbi8vXG4vLyBUaGUgc2VydmVyIGFjdGl2ZWx5IHRlbGxzIHRoZSBjbGllbnQgd2hlbiB0aGVyZSdzIG5ldyBkYXRhIHRoYXQgbWF0Y2hlc1xuLy8gYSBzZXQgb2YgY29uZGl0aW9ucy5cbnZhciBRdWVyeSA9IGV4cG9ydHMuUXVlcnkgPSBmdW5jdGlvbih0eXBlLCBjb25uZWN0aW9uLCBpZCwgY29sbGVjdGlvbiwgcXVlcnksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIC8vICdmZXRjaCcgb3IgJ3N1YidcbiAgdGhpcy50eXBlID0gdHlwZTtcblxuICB0aGlzLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICB0aGlzLmlkID0gaWQ7XG4gIHRoaXMuY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG5cbiAgLy8gVGhlIHF1ZXJ5IGl0c2VsZi4gRm9yIG1vbmdvLCB0aGlzIHNob3VsZCBsb29rIHNvbWV0aGluZyBsaWtlIHtcImRhdGEueFwiOjV9XG4gIHRoaXMucXVlcnkgPSBxdWVyeTtcblxuICAvLyBSZXN1bHRhbnQgZG9jdW1lbnQgYWN0aW9uIGZvciB0aGUgc2VydmVyLiBGZXRjaCBtb2RlIHdpbGwgYXV0b21hdGljYWxseVxuICAvLyBmZXRjaCBhbGwgcmVzdWx0cy4gU3Vic2NyaWJlIG1vZGUgd2lsbCBhdXRvbWF0aWNhbGx5IHN1YnNjcmliZSBhbGxcbiAgLy8gcmVzdWx0cy4gUmVzdWx0cyBhcmUgbmV2ZXIgdW5zdWJzY3JpYmVkLlxuICB0aGlzLmRvY01vZGUgPSBvcHRpb25zLmRvY01vZGU7IC8vIHVuZGVmaW5lZCwgJ2ZldGNoJyBvciAnc3ViJy5cbiAgaWYgKHRoaXMuZG9jTW9kZSA9PT0gJ3N1YnNjcmliZScpIHRoaXMuZG9jTW9kZSA9ICdzdWInO1xuXG4gIC8vIERvIHdlIHJlcG9sbCB0aGUgZW50aXJlIHF1ZXJ5IHdoZW5ldmVyIGFueXRoaW5nIGNoYW5nZXM/IChBcyBvcHBvc2VkIHRvXG4gIC8vIGp1c3QgcG9sbGluZyB0aGUgY2hhbmdlZCBpdGVtKS4gVGhpcyBuZWVkcyB0byBiZSBlbmFibGVkIHRvIGJlIGFibGUgdG8gdXNlXG4gIC8vIG9yZGVyZWQgcXVlcmllcyAoc29ydGJ5OikgYW5kIHBhZ2luYXRlZCBxdWVyaWVzLiBTZXQgdG8gdW5kZWZpbmVkLCBpdCB3aWxsXG4gIC8vIGJlIGVuYWJsZWQgLyBkaXNhYmxlZCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIHRoZSBxdWVyeSdzIHByb3BlcnRpZXMuXG4gIHRoaXMucG9sbCA9IG9wdGlvbnMucG9sbDtcblxuICAvLyBUaGUgYmFja2VuZCB3ZSBhY3R1YWxseSBoaXQuIElmIHRoaXMgaXNuJ3QgZGVmaW5lZCwgaXQgaGl0cyB0aGUgc25hcHNob3RcbiAgLy8gZGF0YWJhc2UuIE90aGVyd2lzZSB0aGlzIGNhbiBiZSB1c2VkIHRvIGhpdCBhbm90aGVyIGNvbmZpZ3VyZWQgcXVlcnlcbiAgLy8gaW5kZXguXG4gIHRoaXMuYmFja2VuZCA9IG9wdGlvbnMuYmFja2VuZCB8fCBvcHRpb25zLnNvdXJjZTtcblxuICAvLyBBIGxpc3Qgb2YgcmVzdWx0aW5nIGRvY3VtZW50cy4gVGhlc2UgYXJlIGFjdHVhbCBkb2N1bWVudHMsIGNvbXBsZXRlIHdpdGhcbiAgLy8gZGF0YSBhbmQgYWxsIHRoZSByZXN0LiBJZiBmZXRjaCBpcyBmYWxzZSwgdGhlc2UgZG9jdW1lbnRzIHdpbGwgbm90XG4gIC8vIGhhdmUgYW55IGRhdGEuIFlvdSBzaG91bGQgbWFudWFsbHkgY2FsbCBmZXRjaCgpIG9yIHN1YnNjcmliZSgpIG9uIHRoZW0uXG4gIC8vXG4gIC8vIENhbGxpbmcgc3Vic2NyaWJlKCkgbWlnaHQgYmUgYSBnb29kIGlkZWEgYW55d2F5LCBhcyB5b3Ugd29uJ3QgYmVcbiAgLy8gc3Vic2NyaWJlZCB0byB0aGUgZG9jdW1lbnRzIGJ5IGRlZmF1bHQuXG4gIHRoaXMua25vd25Eb2NzID0gb3B0aW9ucy5rbm93bkRvY3MgfHwgW107XG4gIHRoaXMucmVzdWx0cyA9IFtdO1xuXG4gIC8vIERvIHdlIGhhdmUgc29tZSBpbml0aWFsIGRhdGE/XG4gIHRoaXMucmVhZHkgPSBmYWxzZTtcblxuICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG59O1xuUXVlcnkucHJvdG90eXBlLmFjdGlvbiA9ICdxc3ViJztcblxuLy8gSGVscGVyIGZvciBzdWJzY3JpYmUgJiBmZXRjaCwgc2luY2UgdGhleSBzaGFyZSB0aGUgc2FtZSBtZXNzYWdlIGZvcm1hdC5cbi8vXG4vLyBUaGlzIGZ1bmN0aW9uIGFjdHVhbGx5IGlzc3VlcyB0aGUgcXVlcnkuXG5RdWVyeS5wcm90b3R5cGUuX2V4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmNvbm5lY3Rpb24uY2FuU2VuZCkgcmV0dXJuO1xuXG4gIGlmICh0aGlzLmRvY01vZGUpIHtcbiAgICB2YXIgY29sbGVjdGlvblZlcnNpb25zID0ge307XG4gICAgLy8gQ29sbGVjdCB0aGUgdmVyc2lvbiBvZiBhbGwgdGhlIGRvY3VtZW50cyBpbiB0aGUgY3VycmVudCByZXN1bHQgc2V0IHNvIHdlXG4gICAgLy8gZG9uJ3QgbmVlZCB0byBiZSBzZW50IHRoZWlyIHNuYXBzaG90cyBhZ2Fpbi5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMua25vd25Eb2NzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZG9jID0gdGhpcy5rbm93bkRvY3NbaV07XG4gICAgICB2YXIgYyA9IGNvbGxlY3Rpb25WZXJzaW9uc1tkb2MuY29sbGVjdGlvbl0gPSBjb2xsZWN0aW9uVmVyc2lvbnNbZG9jLmNvbGxlY3Rpb25dIHx8IHt9O1xuICAgICAgY1tkb2MubmFtZV0gPSBkb2MudmVyc2lvbjtcbiAgICB9XG4gIH1cblxuICB2YXIgbXNnID0ge1xuICAgIGE6ICdxJyArIHRoaXMudHlwZSxcbiAgICBpZDogdGhpcy5pZCxcbiAgICBjOiB0aGlzLmNvbGxlY3Rpb24sXG4gICAgbzoge30sXG4gICAgcTogdGhpcy5xdWVyeSxcbiAgfTtcblxuICBpZiAodGhpcy5kb2NNb2RlKSB7XG4gICAgbXNnLm8ubSA9IHRoaXMuZG9jTW9kZTtcbiAgICAvLyBUaGlzIHNob3VsZCBiZSBvbWl0dGVkIGlmIGVtcHR5LCBidXQgd2hhdGV2ZXIuXG4gICAgbXNnLm8udnMgPSBjb2xsZWN0aW9uVmVyc2lvbnM7XG4gIH1cbiAgaWYgKHRoaXMuYmFja2VuZCAhPSBudWxsKSBtc2cuby5iID0gdGhpcy5iYWNrZW5kO1xuICBpZiAodGhpcy5wb2xsICE9PSB1bmRlZmluZWQpIG1zZy5vLnAgPSB0aGlzLnBvbGw7XG5cbiAgdGhpcy5jb25uZWN0aW9uLnNlbmQobXNnKTtcbn07XG5cbi8vIE1ha2UgYSBsaXN0IG9mIGRvY3VtZW50cyBmcm9tIHRoZSBsaXN0IG9mIHNlcnZlci1yZXR1cm5lZCBkYXRhIG9iamVjdHNcblF1ZXJ5LnByb3RvdHlwZS5fZGF0YVRvRG9jcyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgdmFyIGxhc3RUeXBlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZG9jRGF0YSA9IGRhdGFbaV07XG5cbiAgICAvLyBUeXBlcyBhcmUgb25seSBwdXQgaW4gZm9yIHRoZSBmaXJzdCByZXN1bHQgaW4gdGhlIHNldCBhbmQgZXZlcnkgdGltZSB0aGUgdHlwZSBjaGFuZ2VzIGluIHRoZSBsaXN0LlxuICAgIGlmIChkb2NEYXRhLnR5cGUpIHtcbiAgICAgIGxhc3RUeXBlID0gZG9jRGF0YS50eXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb2NEYXRhLnR5cGUgPSBsYXN0VHlwZTtcbiAgICB9XG5cbiAgICB2YXIgZG9jID0gdGhpcy5jb25uZWN0aW9uLmdldChkb2NEYXRhLmMgfHwgdGhpcy5jb2xsZWN0aW9uLCBkb2NEYXRhLmQsIGRvY0RhdGEpO1xuICAgIC8vIEZvcmNlIHRoZSBkb2N1bWVudCB0byBrbm93IGl0cyBzdWJzY3JpYmVkIGlmIHdlJ3JlIGluIGRvY21vZGU6c3Vic2NyaWJlLlxuICAgIGlmICh0aGlzLmRvY01vZGUgPT09ICdzdWInKSB7XG4gICAgICBkb2Muc3Vic2NyaWJlZCA9IHRydWU7IC8vIFNldCBiZWZvcmUgc2V0V2FudFN1YnNjcmliZSgpIHNvIGZsdXNoIGRvZXNuJ3Qgc2VuZCBhIHN1YnNjcmliZSByZXF1ZXN0LlxuICAgICAgZG9jLl9zZXRXYW50U3Vic2NyaWJlKHRydWUpOyAvLyB0aGlzIHdpbGwgY2FsbCBhbnkgc3Vic2NyaWJlIGNhbGxiYWNrcyBvciB3aGF0ZXZlci5cbiAgICAgIGRvYy5lbWl0KCdzdWJzY3JpYmUnKTtcbiAgICAgIGRvYy5fZmluaXNoU3ViKHRydWUpOyAvLyB0aGlzIGRvZXNuJ3QgYWN0dWFsbHkgZG8gYW55dGhpbmcgaGVyZSwgYnV0IGl0cyBtb3JlIGNvcnJlY3QgdG8gaGF2ZSBpdC5cbiAgICB9XG4gICAgcmVzdWx0cy5wdXNoKGRvYyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBEZXN0cm95IHRoZSBxdWVyeSBvYmplY3QuIEFueSBzdWJzZXF1ZW50IG1lc3NhZ2VzIGZvciB0aGUgcXVlcnkgd2lsbCBiZVxuLy8gaWdub3JlZCBieSB0aGUgY29ubmVjdGlvbi4gWW91IHNob3VsZCB1bnN1YnNjcmliZSBmcm9tIHRoZSBxdWVyeSBiZWZvcmVcbi8vIGRlc3Ryb3lpbmcgaXQuXG5RdWVyeS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5jb25uZWN0aW9uLmNhblNlbmQgJiYgdGhpcy50eXBlID09PSAnc3ViJykge1xuICAgIHRoaXMuY29ubmVjdGlvbi5zZW5kKHthOidxdW5zdWInLCBpZDp0aGlzLmlkfSk7XG4gIH1cblxuICB0aGlzLmNvbm5lY3Rpb24uX2Rlc3Ryb3lRdWVyeSh0aGlzKTtcbn07XG5cblF1ZXJ5LnByb3RvdHlwZS5fb25Db25uZWN0aW9uU3RhdGVDaGFuZ2VkID0gZnVuY3Rpb24oc3RhdGUsIHJlYXNvbikge1xuICBpZiAodGhpcy5jb25uZWN0aW9uLnN0YXRlID09PSAnY29ubmVjdGluZycpIHtcbiAgICB0aGlzLl9leGVjdXRlKCk7XG4gIH1cbn07XG5cbi8vIEludGVybmFsIG1ldGhvZCBjYWxsZWQgZnJvbSBjb25uZWN0aW9uIHRvIHBhc3Mgc2VydmVyIG1lc3NhZ2VzIHRvIHRoZSBxdWVyeS5cblF1ZXJ5LnByb3RvdHlwZS5fb25NZXNzYWdlID0gZnVuY3Rpb24obXNnKSB7XG4gIGlmICgobXNnLmEgPT09ICdxZmV0Y2gnKSAhPT0gKHRoaXMudHlwZSA9PT0gJ2ZldGNoJykpIHtcbiAgICBpZiAoY29uc29sZSkgY29uc29sZS53YXJuKCdJbnZhbGlkIG1lc3NhZ2Ugc2VudCB0byBxdWVyeScsIG1zZywgdGhpcyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG1zZy5lcnJvcikgdGhpcy5lbWl0KCdlcnJvcicsIG1zZy5lcnJvcik7XG5cbiAgc3dpdGNoIChtc2cuYSkge1xuICAgIGNhc2UgJ3FmZXRjaCc6XG4gICAgICB2YXIgcmVzdWx0cyA9IG1zZy5kYXRhID8gdGhpcy5fZGF0YVRvRG9jcyhtc2cuZGF0YSkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAodGhpcy5jYWxsYmFjaykgdGhpcy5jYWxsYmFjayhtc2cuZXJyb3IsIHJlc3VsdHMsIG1zZy5leHRyYSk7XG4gICAgICAvLyBPbmNlIGEgZmV0Y2ggcXVlcnkgZ2V0cyBpdHMgZGF0YSwgaXQgaXMgZGVzdHJveWVkLlxuICAgICAgdGhpcy5jb25uZWN0aW9uLl9kZXN0cm95UXVlcnkodGhpcyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3EnOlxuICAgICAgLy8gUXVlcnkgZGlmZiBkYXRhIChpbnNlcnRzIGFuZCByZW1vdmVzKVxuICAgICAgaWYgKG1zZy5kaWZmKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZ28gdGhyb3VnaCB0aGUgbGlzdCB0d2ljZS4gRmlyc3QsIHdlJ2xsIGluamVzdCBhbGwgdGhlXG4gICAgICAgIC8vIG5ldyBkb2N1bWVudHMgYW5kIHNldCB0aGVtIGFzIHN1YnNjcmliZWQuICBBZnRlciB0aGF0IHdlJ2xsIGVtaXRcbiAgICAgICAgLy8gZXZlbnRzIGFuZCBhY3R1YWxseSB1cGRhdGUgb3VyIGxpc3QuIFRoaXMgYXZvaWRzIHJhY2UgY29uZGl0aW9uc1xuICAgICAgICAvLyBhcm91bmQgc2V0dGluZyBkb2N1bWVudHMgdG8gYmUgc3Vic2NyaWJlZCAmIHVuc3Vic2NyaWJpbmcgZG9jdW1lbnRzXG4gICAgICAgIC8vIGluIGV2ZW50IGNhbGxiYWNrcy5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cuZGlmZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBkID0gbXNnLmRpZmZbaV07XG4gICAgICAgICAgaWYgKGQudHlwZSA9PT0gJ2luc2VydCcpIGQudmFsdWVzID0gdGhpcy5fZGF0YVRvRG9jcyhkLnZhbHVlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5kaWZmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGQgPSBtc2cuZGlmZltpXTtcbiAgICAgICAgICBzd2l0Y2ggKGQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnaW5zZXJ0JzpcbiAgICAgICAgICAgICAgdmFyIG5ld0RvY3MgPSBkLnZhbHVlcztcbiAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZS5hcHBseSh0aGlzLnJlc3VsdHMsIFtkLmluZGV4LCAwXS5jb25jYXQobmV3RG9jcykpO1xuICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2luc2VydCcsIG5ld0RvY3MsIGQuaW5kZXgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JlbW92ZSc6XG4gICAgICAgICAgICAgIHZhciBob3dNYW55ID0gZC5ob3dNYW55IHx8IDE7XG4gICAgICAgICAgICAgIHZhciByZW1vdmVkID0gdGhpcy5yZXN1bHRzLnNwbGljZShkLmluZGV4LCBob3dNYW55KTtcbiAgICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmUnLCByZW1vdmVkLCBkLmluZGV4KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb3ZlJzpcbiAgICAgICAgICAgICAgdmFyIGhvd01hbnkgPSBkLmhvd01hbnkgfHwgMTtcbiAgICAgICAgICAgICAgdmFyIGRvY3MgPSB0aGlzLnJlc3VsdHMuc3BsaWNlKGQuZnJvbSwgaG93TWFueSk7XG4gICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuYXBwbHkodGhpcy5yZXN1bHRzLCBbZC50bywgMF0uY29uY2F0KGRvY3MpKTtcbiAgICAgICAgICAgICAgdGhpcy5lbWl0KCdtb3ZlJywgZG9jcywgZC5mcm9tLCBkLnRvKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtc2cuZXh0cmEpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdleHRyYScsIG1zZy5leHRyYSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdxc3ViJzpcbiAgICAgIC8vIFRoaXMgbWVzc2FnZSByZXBsYWNlcyB0aGUgZW50aXJlIHJlc3VsdCBzZXQgd2l0aCB0aGUgc2V0IHBhc3NlZC5cbiAgICAgIGlmICghbXNnLmVycm9yKSB7XG4gICAgICAgIHZhciBwcmV2aW91cyA9IHRoaXMucmVzdWx0cztcblxuICAgICAgICAvLyBUaGVuIGFkZCBldmVyeXRoaW5nIGluIHRoZSBuZXcgcmVzdWx0IHNldC5cbiAgICAgICAgdGhpcy5yZXN1bHRzID0gdGhpcy5rbm93bkRvY3MgPSB0aGlzLl9kYXRhVG9Eb2NzKG1zZy5kYXRhKTtcbiAgICAgICAgdGhpcy5leHRyYSA9IG1zZy5leHRyYTtcblxuICAgICAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnLCB0aGlzLnJlc3VsdHMsIHByZXZpb3VzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sobXNnLmVycm9yLCB0aGlzLnJlc3VsdHMsIHRoaXMuZXh0cmEpO1xuICAgICAgICBkZWxldGUgdGhpcy5jYWxsYmFjaztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vLyBDaGFuZ2UgdGhlIHRoaW5nIHdlJ3JlIHNlYXJjaGluZyBmb3IuIFRoaXMgaXNuJ3QgZnVsbHkgc3VwcG9ydGVkIG9uIHRoZVxuLy8gYmFja2VuZCAoaXQgZGVzdHJveXMgdGhlIG9sZCBxdWVyeSBhbmQgbWFrZXMgYSBuZXcgb25lKSAtIGJ1dCBpdHNcbi8vIHByb2dyYW1hdGljYWxseSB1c2VmdWwgYW5kIEkgbWlnaHQgYWRkIGJhY2tlbmQgc3VwcG9ydCBhdCBzb21lIHBvaW50LlxuUXVlcnkucHJvdG90eXBlLnNldFF1ZXJ5ID0gZnVuY3Rpb24ocSkge1xuICBpZiAodGhpcy50eXBlICE9PSAnc3ViJykgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY2hhbmdlIGEgZmV0Y2ggcXVlcnknKTtcblxuICB0aGlzLnF1ZXJ5ID0gcTtcbiAgaWYgKHRoaXMuY29ubmVjdGlvbi5jYW5TZW5kKSB7XG4gICAgLy8gVGhlcmUncyBubyAnY2hhbmdlJyBtZXNzYWdlIHRvIHNlbmQgdG8gdGhlIHNlcnZlci4gSnVzdCByZXN1YnNjcmliZS5cbiAgICB0aGlzLmNvbm5lY3Rpb24uc2VuZCh7YToncXVuc3ViJywgaWQ6dGhpcy5pZH0pO1xuICAgIHRoaXMuX2V4ZWN1dGUoKTtcbiAgfVxufTtcblxudmFyIE1pY3JvRXZlbnQ7XG5pZiAodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSB7XG4gIE1pY3JvRXZlbnQgPSByZXF1aXJlKCcuL21pY3JvZXZlbnQnKTtcbn1cblxuTWljcm9FdmVudC5taXhpbihRdWVyeSk7XG5cbiIsIi8vIEEgQ29ubmVjdGlvbiB3cmFwcyBhIHBlcnNpc3RhbnQgQkMgY29ubmVjdGlvbiB0byBhIHNoYXJlanMgc2VydmVyLlxuLy9cbi8vIFRoaXMgY2xhc3MgaW1wbGVtZW50cyB0aGUgY2xpZW50IHNpZGUgb2YgdGhlIHByb3RvY29sIGRlZmluZWQgaGVyZTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3NlcGhnL1NoYXJlSlMvd2lraS9XaXJlLVByb3RvY29sXG4vL1xuLy8gVGhlIGVxdWl2YWxlbnQgc2VydmVyIGNvZGUgaXMgaW4gc3JjL3NlcnZlci9zZXNzaW9uLlxuLy9cbi8vIFRoaXMgZmlsZSBpcyBhIGJpdCBvZiBhIG1lc3MuIEknbSBkcmVhZGZ1bGx5IHNvcnJ5IGFib3V0IHRoYXQuIEl0IHBhc3NlcyBhbGwgdGhlIHRlc3RzLFxuLy8gc28gSSBoYXZlIGhvcGUgdGhhdCBpdHMgKmNvcnJlY3QqIGV2ZW4gaWYgaXRzIG5vdCBjbGVhbi5cbi8vXG4vLyBUbyBtYWtlIGEgY29ubmVjdGlvbiwgdXNlOlxuLy8gIG5ldyBzaGFyZWpzLkNvbm5lY3Rpb24oc29ja2V0KVxuLy9cbi8vIFRoZSBzb2NrZXQgc2hvdWxkIGxvb2sgbGlrZSBhIHdlYnNvY2tldCBjb25uZWN0aW9uLiBJdCBzaG91bGQgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4vLyAgc2VuZChtc2cpOiBTZW5kIHRoZSBnaXZlbiBtZXNzYWdlLiBtc2cgbWF5IGJlIGFuIG9iamVjdCAtIGlmIHNvLCB5b3UgbWlnaHQgbmVlZCB0byBKU09OLnN0cmluZ2lmeSBpdC5cbi8vICBjbG9zZSgpOiBEaXNjb25uZWN0IHRoZSBzZXNzaW9uXG4vL1xuLy8gIG9ubWVzc2FnZSA9IGZ1bmN0aW9uKG1zZyl7fTogRXZlbnQgaGFuZGxlciB3aGljaCBpcyBjYWxsZWQgd2hlbmV2ZXIgYSBtZXNzYWdlIGlzIHJlY2VpdmVkLiBUaGUgbWVzc2FnZVxuLy8gICAgIHBhc3NlZCBpbiBzaG91bGQgYWxyZWFkeSBiZSBhbiBvYmplY3QuIChJdCBtYXkgbmVlZCB0byBiZSBKU09OLnBhcnNlZClcbi8vICBvbmNsb3NlXG4vLyAgb25lcnJvclxuLy8gIG9ub3BlblxuLy8gIG9uY29ubmVjdGluZ1xuLy9cbi8vIFRoZSBzb2NrZXQgc2hvdWxkIHByb2JhYmx5IGF1dG9tYXRpY2FsbHkgcmVjb25uZWN0LiBJZiBzbywgaXQgc2hvdWxkIGVtaXQgdGhlIGFwcHJvcHJpYXRlIGV2ZW50cyBhcyBpdFxuLy8gZGlzY29ubmVjdHMgJiByZWNvbm5lY3RzLiAob25jbG9zZSgpLCBvbmNvbm5lY3RpbmcoKSwgb25vcGVuKCkpLlxuXG52YXIgdHlwZXMsIERvYztcbmlmICh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgdHlwZXMgPSByZXF1aXJlKCdvdHR5cGVzJyk7XG4gIERvYyA9IHJlcXVpcmUoJy4vZG9jJykuRG9jO1xuICBRdWVyeSA9IHJlcXVpcmUoJy4vcXVlcnknKS5RdWVyeTtcbn0gZWxzZSB7XG4gIHR5cGVzID0gd2luZG93Lm90dHlwZXM7XG4gIERvYyA9IGV4cG9ydHMuRG9jO1xufVxuXG52YXIgQ29ubmVjdGlvbiA9IGV4cG9ydHMuQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIChzb2NrZXQpIHtcbiAgdGhpcy5zb2NrZXQgPSBzb2NrZXQ7XG5cbiAgLy8gTWFwIG9mIGNvbGxlY3Rpb24gLT4gZG9jTmFtZSAtPiBkb2Mgb2JqZWN0IGZvciBjcmVhdGVkIGRvY3VtZW50cy5cbiAgLy8gKGNyZWF0ZWQgZG9jdW1lbnRzIE1VU1QgQkUgVU5JUVVFKVxuICB0aGlzLmNvbGxlY3Rpb25zID0ge307XG5cbiAgLy8gRWFjaCBxdWVyeSBpcyBjcmVhdGVkIHdpdGggYW4gaWQgdGhhdCB0aGUgc2VydmVyIHVzZXMgd2hlbiBpdCBzZW5kcyB1c1xuICAvLyBpbmZvIGFib3V0IHRoZSBxdWVyeSAodXBkYXRlcywgZXRjKS5cbiAgLy90aGlzLm5leHRRdWVyeUlkID0gKE1hdGgucmFuZG9tKCkgKiAxMDAwKSB8MDtcbiAgdGhpcy5uZXh0UXVlcnlJZCA9IDE7XG5cbiAgLy8gTWFwIGZyb20gcXVlcnkgSUQgLT4gcXVlcnkgb2JqZWN0LlxuICB0aGlzLnF1ZXJpZXMgPSB7fTtcblxuICAvLyBDb25uZWN0aW9uIHN0YXRlLlxuICAvLyBcbiAgLy8gU3RhdGVzOlxuICAvLyAtICdjb25uZWN0aW5nJzogVGhlIGNvbm5lY3Rpb24gaGFzIGJlZW4gZXN0YWJsaXNoZWQsIGJ1dCB3ZSBkb24ndCBoYXZlIG91ciBjbGllbnQgSUQgeWV0XG4gIC8vIC0gJ2Nvbm5lY3RlZCc6IFdlIGhhdmUgY29ubmVjdGVkIGFuZCByZWNpZXZlZCBvdXIgY2xpZW50IElELiBSZWFkeSBmb3IgZGF0YS5cbiAgLy8gLSAnZGlzY29ubmVjdGVkJzogVGhlIGNvbm5lY3Rpb24gaXMgY2xvc2VkLCBidXQgaXQgd2lsbCByZWNvbm5lY3QgYXV0b21hdGljYWxseS5cbiAgLy8gLSAnc3RvcHBlZCc6IFRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZCwgYW5kIHNob3VsZCBub3QgcmVjb25uZWN0LlxuICB0aGlzLnN0YXRlID0gKHNvY2tldC5yZWFkeVN0YXRlID09PSAwIHx8IHNvY2tldC5yZWFkeVN0YXRlID09PSAxKSA/ICdjb25uZWN0aW5nJyA6ICdkaXNjb25uZWN0ZWQnO1xuXG4gIC8vIFRoaXMgaXMgYSBoZWxwZXIgdmFyaWFibGUgdGhlIGRvY3VtZW50IHVzZXMgdG8gc2VlIHdoZXRoZXIgd2UncmUgY3VycmVudGx5XG4gIC8vIGluIGEgJ2xpdmUnIHN0YXRlLiBJdCBpcyB0cnVlIGlmIHRoZSBzdGF0ZSBpcyAnY29ubmVjdGluZycgb3IgJ2Nvbm5lY3RlZCcuXG4gIHRoaXMuY2FuU2VuZCA9IHRoaXMuc3RhdGUgPT09ICdjb25uZWN0aW5nJztcblxuICAvLyBSZXNldCBzb21lIG1vcmUgc3RhdGUgdmFyaWFibGVzLlxuICB0aGlzLnJlc2V0KCk7XG5cbiAgdGhpcy5kZWJ1ZyA9IGZhbHNlO1xuICAvLyBJJ2xsIHN0b3JlIHRoZSBtb3N0IHJlY2VudCAxMDAgbWVzc2FnZXMgc28gd2hlbiBlcnJvcnMgb2NjdXIgd2UgY2FuIHNlZSB3aGF0IGhhcHBlbmVkLlxuICB0aGlzLm1lc3NhZ2VCdWZmZXIgPSBbXTtcblxuICB2YXIgY29ubmVjdGlvbiA9IHRoaXM7XG5cbiAgdmFyIGhhbmRsZU1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpIHtcbiAgICAvLyBTd2l0Y2ggb24gdGhlIG1lc3NhZ2UgYWN0aW9uLiBNb3N0IG1lc3NhZ2VzIGFyZSBmb3IgZG9jdW1lbnRzIGFuZCBhcmVcbiAgICAvLyBoYW5kbGVkIGluIHRoZSBkb2MgY2xhc3MuXG4gICAgc3dpdGNoIChtc2cuYSkge1xuICAgICAgY2FzZSAnaW5pdCc6XG4gICAgICAgIC8vIENsaWVudCBpbml0aWFsaXphdGlvbiBwYWNrZXQuIFRoaXMgYnVuZGxlIG9mIGpveSBjb250YWlucyBvdXIgY2xpZW50XG4gICAgICAgIC8vIElELlxuICAgICAgICBpZiAobXNnLnByb3RvY29sICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJvdG9jb2wgdmVyc2lvbicpO1xuICAgICAgICBpZiAodHlwZW9mIG1zZy5pZCAhPSAnc3RyaW5nJykgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNsaWVudCBpZCcpO1xuXG4gICAgICAgIGNvbm5lY3Rpb24uaWQgPSBtc2cuaWQ7XG4gICAgICAgIGNvbm5lY3Rpb24uX3NldFN0YXRlKCdjb25uZWN0ZWQnKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3FmZXRjaCc6XG4gICAgICBjYXNlICdxc3ViJzpcbiAgICAgIGNhc2UgJ3EnOlxuICAgICAgY2FzZSAncXVuc3ViJzpcbiAgICAgICAgLy8gUXVlcnkgbWVzc2FnZS4gUGFzcyB0aGlzIHRvIHRoZSBhcHByb3ByaWF0ZSBxdWVyeSBvYmplY3QuXG4gICAgICAgIHZhciBxdWVyeSA9IGNvbm5lY3Rpb24ucXVlcmllc1ttc2cuaWRdO1xuICAgICAgICBpZiAocXVlcnkpIHF1ZXJ5Ll9vbk1lc3NhZ2UobXNnKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2JzJzpcbiAgICAgICAgLy8gQnVsayBzdWJzY3JpYmUgcmVzcG9uc2UuIFRoZSByZXNwb25zZXMgZm9yIGVhY2ggZG9jdW1lbnQgYXJlIGNvbnRhaW5lZCB3aXRoaW4uXG4gICAgICAgIHZhciByZXN1bHQgPSBtc2cucztcbiAgICAgICAgZm9yICh2YXIgY05hbWUgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgZm9yICh2YXIgZG9jTmFtZSBpbiByZXN1bHRbY05hbWVdKSB7XG4gICAgICAgICAgICB2YXIgZG9jID0gY29ubmVjdGlvbi5nZXQoY05hbWUsIGRvY05hbWUpO1xuICAgICAgICAgICAgaWYgKCFkb2MpIHtcbiAgICAgICAgICAgICAgaWYgKGNvbnNvbGUpIGNvbnNvbGUuZXJyb3IoJ01lc3NhZ2UgZm9yIHVua25vd24gZG9jLiBJZ25vcmluZy4nLCBtc2cpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG1zZyA9IHJlc3VsdFtjTmFtZV1bZG9jTmFtZV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1zZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgZG9jLl9oYW5kbGVTdWJzY3JpYmUobXNnLmVycm9yLCBtc2cuZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBUaGUgbXNnIHdpbGwgYmUgdHJ1ZSBpZiB3ZSBzaW1wbHkgcmVzdWJzY3JpYmVkLlxuICAgICAgICAgICAgICBkb2MuX2hhbmRsZVN1YnNjcmliZShudWxsLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIERvY3VtZW50IG1lc3NhZ2UuIFB1bGwgb3V0IHRoZSByZWZlcmVuY2VkIGRvY3VtZW50IGFuZCBmb3J3YXJkIHRoZVxuICAgICAgICAvLyBtZXNzYWdlLlxuICAgICAgICB2YXIgY29sbGVjdGlvbiwgZG9jTmFtZSwgZG9jO1xuICAgICAgICBpZiAobXNnLmQpIHtcbiAgICAgICAgICBjb2xsZWN0aW9uID0gY29ubmVjdGlvbi5fbGFzdFJlY2VpdmVkQ29sbGVjdGlvbiA9IG1zZy5jO1xuICAgICAgICAgIGRvY05hbWUgPSBjb25uZWN0aW9uLl9sYXN0UmVjZWl2ZWREb2MgPSBtc2cuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2xsZWN0aW9uID0gbXNnLmMgPSBjb25uZWN0aW9uLl9sYXN0UmVjZWl2ZWRDb2xsZWN0aW9uO1xuICAgICAgICAgIGRvY05hbWUgPSBtc2cuZCA9IGNvbm5lY3Rpb24uX2xhc3RSZWNlaXZlZERvYztcbiAgICAgICAgfVxuXG4gICAgICAgIGRvYyA9IGNvbm5lY3Rpb24uZ2V0KGNvbGxlY3Rpb24sIGRvY05hbWUpO1xuICAgICAgICBpZiAoIWRvYykge1xuICAgICAgICAgIGlmIChjb25zb2xlKSBjb25zb2xlLmVycm9yKCdNZXNzYWdlIGZvciB1bmtub3duIGRvYy4gSWdub3JpbmcuJywgbXNnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkb2MuX29uTWVzc2FnZShtc2cpO1xuICAgIH1cbiAgfTtcblxuICAvLyBBdHRhY2ggZXZlbnQgaGFuZGxlcnMgdG8gdGhlIHNvY2tldC5cbiAgc29ja2V0Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uKG1zZykge1xuICAgIGlmIChjb25uZWN0aW9uLmRlYnVnKSBjb25zb2xlLmxvZygnUkVDVicsIEpTT04uc3RyaW5naWZ5KG1zZykpO1xuICAgIGNvbm5lY3Rpb24ubWVzc2FnZUJ1ZmZlci5wdXNoKHt0OihuZXcgRGF0ZSgpKS50b1RpbWVTdHJpbmcoKSwgcmVjdjpKU09OLnN0cmluZ2lmeShtc2cpfSk7XG4gICAgd2hpbGUgKGNvbm5lY3Rpb24ubWVzc2FnZUJ1ZmZlci5sZW5ndGggPiAxMDApIHtcbiAgICAgIGNvbm5lY3Rpb24ubWVzc2FnZUJ1ZmZlci5zaGlmdCgpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBoYW5kbGVNZXNzYWdlKG1zZyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29ubmVjdGlvbi5lbWl0KCdlcnJvcicsIGUpO1xuICAgICAgLy8gV2UgY291bGQgYWxzbyByZXN0YXJ0IHRoZSBjb25uZWN0aW9uIGhlcmUsIGFsdGhvdWdoIHRoYXQgbWlnaHQgcmVzdWx0XG4gICAgICAvLyBpbiBpbmZpbml0ZSByZWNvbm5lY3Rpb24gYnVncy5cbiAgICB9XG4gIH1cblxuICBzb2NrZXQub25vcGVuID0gZnVuY3Rpb24oKSB7XG4gICAgY29ubmVjdGlvbi5fc2V0U3RhdGUoJ2Nvbm5lY3RpbmcnKTtcbiAgfTtcblxuICBzb2NrZXQub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAvLyBUaGlzIGlzbid0IHRoZSBzYW1lIGFzIGEgcmVndWxhciBlcnJvciwgYmVjYXVzZSBpdCB3aWxsIGhhcHBlbiBub3JtYWxseVxuICAgIC8vIGZyb20gdGltZSB0byB0aW1lLiBZb3VyIGNvbm5lY3Rpb24gc2hvdWxkIHByb2JhYmx5IGF1dG9tYXRpY2FsbHlcbiAgICAvLyByZWNvbm5lY3QgYW55d2F5LCBidXQgdGhhdCBzaG91bGQgYmUgdHJpZ2dlcmVkIG9mZiBvbmNsb3NlIG5vdCBvbmVycm9yLlxuICAgIC8vIChvbmNsb3NlIGhhcHBlbnMgd2hlbiBvbmVycm9yIGdldHMgY2FsbGVkIGFueXdheSkuXG4gICAgY29ubmVjdGlvbi5lbWl0KCdjb25uZWN0aW9uIGVycm9yJywgZSk7XG4gIH07XG5cbiAgc29ja2V0Lm9uY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pIHtcbiAgICBjb25uZWN0aW9uLl9zZXRTdGF0ZSgnZGlzY29ubmVjdGVkJywgcmVhc29uKTtcbiAgICBpZiAocmVhc29uID09PSAnQ2xvc2VkJyB8fCByZWFzb24gPT09ICdTdG9wcGVkIGJ5IHNlcnZlcicpIHtcbiAgICAgIGNvbm5lY3Rpb24uX3NldFN0YXRlKCdzdG9wcGVkJywgcmVhc29uKTtcbiAgICB9XG4gIH07XG59XG5cbi8qIFdoeSBkb2VzIHRoaXMgZnVuY3Rpb24gZXhpc3Q/IElzIGl0IGltcG9ydGFudD9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgdGhpcy5fc2V0U3RhdGUoJ3N0b3BwZWQnLCBlKTtcbiAgcmV0dXJuIHRoaXMuZGlzY29ubmVjdChlKTtcbn07XG4qL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmlkID0gdGhpcy5sYXN0RXJyb3IgPVxuICAgIHRoaXMuX2xhc3RSZWNlaXZlZENvbGxlY3Rpb24gPSB0aGlzLl9sYXN0UmVjZWl2ZWREb2MgPVxuICAgIHRoaXMuX2xhc3RTZW50Q29sbGVjdGlvbiA9IHRoaXMuX2xhc3RTZW50RG9jID0gbnVsbDtcblxuICB0aGlzLnNlcSA9IDE7XG59O1xuXG4vLyBTZXQgdGhlIGNvbm5lY3Rpb24ncyBzdGF0ZS4gVGhlIGNvbm5lY3Rpb24gaXMgYmFzaWNhbGx5IGEgc3RhdGUgbWFjaGluZS5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLl9zZXRTdGF0ZSA9IGZ1bmN0aW9uKG5ld1N0YXRlLCBkYXRhKSB7XG4gIGlmICh0aGlzLnN0YXRlID09PSBuZXdTdGF0ZSkgcmV0dXJuO1xuXG4gIC8vIEkgbWFkZSBhIHN0YXRlIGRpYWdyYW0uIFRoZSBvbmx5IGludmFsaWQgdHJhbnNpdGlvbnMgYXJlIGdldHRpbmcgdG9cbiAgLy8gJ2Nvbm5lY3RpbmcnIGZyb20gYW55d2hlcmUgb3RoZXIgdGhhbiAnZGlzY29ubmVjdGVkJyBhbmQgZ2V0dGluZyB0b1xuICAvLyAnY29ubmVjdGVkJyBmcm9tIGFueXdoZXJlIG90aGVyIHRoYW4gJ2Nvbm5lY3RpbmcnLlxuICBpZiAoKG5ld1N0YXRlID09PSAnY29ubmVjdGluZycgJiYgKHRoaXMuc3RhdGUgIT09ICdkaXNjb25uZWN0ZWQnICYmIHRoaXMuc3RhdGUgIT09ICdzdG9wcGVkJykpXG4gICAgICB8fCAobmV3U3RhdGUgPT09ICdjb25uZWN0ZWQnICYmIHRoaXMuc3RhdGUgIT09ICdjb25uZWN0aW5nJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdHJhbnNpdGlvbiBkaXJlY3RseSBmcm9tIFwiICsgdGhpcy5zdGF0ZSArIFwiIHRvIFwiICsgbmV3U3RhdGUpO1xuICB9XG5cbiAgdGhpcy5zdGF0ZSA9IG5ld1N0YXRlO1xuICB0aGlzLmNhblNlbmQgPSBuZXdTdGF0ZSA9PT0gJ2Nvbm5lY3RpbmcnIHx8IG5ld1N0YXRlID09PSAnY29ubmVjdGVkJztcblxuICBpZiAobmV3U3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnKSB0aGlzLnJlc2V0KCk7XG5cbiAgdGhpcy5lbWl0KG5ld1N0YXRlLCBkYXRhKTtcblxuICAvLyAmIEVtaXQgdGhlIGV2ZW50IHRvIGFsbCBkb2N1bWVudHMgJiBxdWVyaWVzLiBJdCBtaWdodCBtYWtlIHNlbnNlIGZvclxuICAvLyBkb2N1bWVudHMgdG8ganVzdCByZWdpc3RlciBmb3IgdGhpcyBzdHVmZiB1c2luZyBldmVudHMsIGJ1dCB0aGF0IGNvdXBsZXNcbiAgLy8gY29ubmVjdGlvbnMgYW5kIGRvY3VtZW50cyBhIGJpdCBtdWNoLiBJdHMgbm90IGEgYmlnIGRlYWwgZWl0aGVyIHdheS5cbiAgdGhpcy5vcFF1ZXVlID0gW107XG4gIHRoaXMuc3Vic2NyaWJlRGF0YSA9IHt9O1xuICBmb3IgKHZhciBjIGluIHRoaXMuY29sbGVjdGlvbnMpIHtcbiAgICB2YXIgY29sbGVjdGlvbiA9IHRoaXMuY29sbGVjdGlvbnNbY107XG4gICAgZm9yICh2YXIgZG9jTmFtZSBpbiBjb2xsZWN0aW9uKSB7XG4gICAgICBjb2xsZWN0aW9uW2RvY05hbWVdLl9vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQobmV3U3RhdGUsIGRhdGEpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gSXRzIGltcG9ydGFudCB0aGF0IG9wZXJhdGlvbnMgYXJlIHJlc2VudCBpbiB0aGUgc2FtZSBvcmRlciB0aGF0IHRoZXkgd2VyZVxuICAvLyBvcmlnaW5hbGx5IHNlbnQuIElmIHdlIGRvbid0IHNvcnQsIGFuIG9wIHdpdGggYSBoaWdoIHNlcXVlbmNlIG51bWJlciB3aWxsXG4gIC8vIGNvbnZpbmNlIHRoZSBzZXJ2ZXIgbm90IHRvIGFjY2VwdCBhbnkgb3BzIHdpdGggZWFybGllciBzZXF1ZW5jZSBudW1iZXJzLlxuICB0aGlzLm9wUXVldWUuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhLnNlcSAtIGIuc2VxOyB9KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9wUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnNlbmQodGhpcy5vcFF1ZXVlW2ldKTtcbiAgfVxuXG4gIC8vIE9ubHkgc2VuZCBidWxrIHN1YnNjcmliZSBpZiBub3QgZW1wdHkuIEl0cyB3ZWlyZCB1c2luZyBhIGZvciBsb29wIGZvclxuICAvLyB0aGlzLCBidXQgaXQgd29ya3MgcHJldHR5IHdlbGwuXG4gIGZvciAodmFyIF9fdW51c2VkIGluIHRoaXMuc3Vic2NyaWJlRGF0YSkgeyBcbiAgICB0aGlzLnNlbmQoe2E6J2JzJywgczp0aGlzLnN1YnNjcmliZURhdGF9KTtcbiAgICBicmVhaztcbiAgfVxuXG4gIHRoaXMub3BRdWV1ZSA9IG51bGw7XG4gIHRoaXMuc3Vic2NyaWJlRGF0YSA9IG51bGw7XG4gIFxuICAvLyBObyBidWxrIHN1YnNjcmliZSBmb3IgcXVlcmllcyB5ZXQuXG4gIGZvciAodmFyIGlkIGluIHRoaXMucXVlcmllcykge1xuICAgIHRoaXMucXVlcmllc1tpZF0uX29uQ29ubmVjdGlvblN0YXRlQ2hhbmdlZChuZXdTdGF0ZSwgZGF0YSk7XG4gIH1cbn07XG5cbi8vIFNvLCB0aGVyZSdzIGFuIGF3ZnVsIGVycm9yIGNhc2Ugd2hlcmUgdGhlIGNsaWVudCBzZW5kcyB0d28gcmVxdWVzdHMgKHdoaWNoXG4vLyBmYWlsKSwgdGhlbiByZWNvbm5lY3RzLiBUaGUgZG9jdW1lbnRzIGNvdWxkIGhhdmUgX29uQ29ubmVjdGlvblN0YXRlQ2hhbmdlZFxuLy8gY2FsbGVkIGluIHRoZSB3cm9uZyBvcmRlciBhbmQgdGhlIG9wZXJhdGlvbnMgdGhlbiBnZXQgc2VudCB3aXRoIHJldmVyc2VkXG4vLyBzZXF1ZW5jZSBudW1iZXJzLiBUaGlzIGNhdXNlcyB0aGUgc2VydmVyIHRvIGluY29ycmVjdGx5IHJlamVjdCB0aGUgc2Vjb25kXG4vLyBzZW50IG9wLiBTbyB3ZSBuZWVkIHRvIHF1ZXVlIHRoZSBvcGVyYXRpb25zIHdoaWxlIHdlJ3JlIHJlY29ubmVjdGluZyBhbmRcbi8vIHJlc2VuZCB0aGVtIGluIHRoZSBjb3JyZWN0IG9yZGVyLlxuQ29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZE9wID0gZnVuY3Rpb24oZGF0YSkge1xuICBpZiAodGhpcy5vcFF1ZXVlKSB7XG4gICAgdGhpcy5vcFF1ZXVlLnB1c2goZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zZW5kKGRhdGEpO1xuICB9XG59O1xuXG4vLyBUaGlzIGlzIGNhbGxlZCBieSB0aGUgZG9jdW1lbnQgY2xhc3Mgd2hlbiB0aGUgZG9jdW1lbnQgd2FudHMgdG8gc3Vic2NyaWJlLlxuLy8gV2UgY291bGQganVzdCBzZW5kIGEgc3Vic2NyaWJlIG1lc3NhZ2UsIGJ1dCBkdXJpbmcgcmVjb25uZWN0IHRoYXQgY2F1c2VzIGFcbi8vIGJhamlsbGlvbiBtZXNzYWdlcyBvdmVyIGJyb3dzZXJjaGFubmVsLiBEdXJpbmcgcmVjb25uZWN0IHdlJ2xsIGFnZ3JlZ2F0ZSxcbi8vIHNpbWlsYXIgdG8gc2VuZE9wLlxuQ29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZFN1YnNjcmliZSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIG5hbWUsIHYpIHtcbiAgaWYgKHRoaXMuc3Vic2NyaWJlRGF0YSkge1xuICAgIHZhciBkYXRhID0gdGhpcy5zdWJzY3JpYmVEYXRhO1xuICAgIGlmICghZGF0YVtjb2xsZWN0aW9uXSkgZGF0YVtjb2xsZWN0aW9uXSA9IHt9O1xuXG4gICAgZGF0YVtjb2xsZWN0aW9uXVtuYW1lXSA9IHYgfHwgbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbXNnID0ge2E6J3N1YicsIGM6Y29sbGVjdGlvbiwgZDpuYW1lfTtcbiAgICBpZiAodiAhPSBudWxsKSBtc2cudiA9IHY7XG4gICAgdGhpcy5zZW5kKG1zZyk7XG4gIH1cbn07XG5cbi8vIFNlbmQgYSBtZXNzYWdlIHRvIHRoZSBjb25uZWN0aW9uLlxuQ29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG1zZykge1xuICBpZiAodGhpcy5kZWJ1ZykgY29uc29sZS5sb2coXCJTRU5EXCIsIEpTT04uc3RyaW5naWZ5KG1zZykpO1xuICB0aGlzLm1lc3NhZ2VCdWZmZXIucHVzaCh7dDpEYXRlLm5vdygpLCBzZW5kOkpTT04uc3RyaW5naWZ5KG1zZyl9KTtcbiAgd2hpbGUgKHRoaXMubWVzc2FnZUJ1ZmZlci5sZW5ndGggPiAxMDApIHtcbiAgICB0aGlzLm1lc3NhZ2VCdWZmZXIuc2hpZnQoKTtcbiAgfVxuXG4gIGlmIChtc2cuZCkgeyAvLyBUaGUgZG9jdW1lbnQgdGhlIG1lc3NhZ2UgcmVmZXJzIHRvLiBOb3Qgc2V0IGZvciBxdWVyaWVzLlxuICAgIHZhciBjb2xsZWN0aW9uID0gbXNnLmM7XG4gICAgdmFyIGRvY05hbWUgPSBtc2cuZDtcbiAgICBpZiAoY29sbGVjdGlvbiA9PT0gdGhpcy5fbGFzdFNlbnRDb2xsZWN0aW9uICYmIGRvY05hbWUgPT09IHRoaXMuX2xhc3RTZW50RG9jKSB7XG4gICAgICBkZWxldGUgbXNnLmM7XG4gICAgICBkZWxldGUgbXNnLmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xhc3RTZW50Q29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgICB0aGlzLl9sYXN0U2VudERvYyA9IGRvY05hbWU7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5zb2NrZXQuc2VuZChtc2cpO1xufTtcblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICAvLyBUaGlzIHdpbGwgY2FsbCBAc29ja2V0Lm9uY2xvc2UoKSwgd2hpY2ggaW4gdHVybiB3aWxsIGVtaXQgdGhlICdkaXNjb25uZWN0ZWQnIGV2ZW50LlxuICB0aGlzLnNvY2tldC5jbG9zZSgpO1xufTtcblxuXG4vLyAqKioqKiBEb2N1bWVudCBtYW5hZ2VtZW50XG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmdldEV4aXN0aW5nID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgbmFtZSkge1xuICBpZiAodGhpcy5jb2xsZWN0aW9uc1tjb2xsZWN0aW9uXSkgcmV0dXJuIHRoaXMuY29sbGVjdGlvbnNbY29sbGVjdGlvbl1bbmFtZV07XG59O1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5nZXRPckNyZWF0ZSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIG5hbWUsIGRhdGEpIHtcbiAgY29uc29sZS50cmFjZSgnZ2V0T3JDcmVhdGUgaXMgZGVwcmVjYXRlZC4gVXNlIGdldCgpIGluc3RlYWQnKTtcbiAgcmV0dXJuIHRoaXMuZ2V0KGNvbGxlY3Rpb24sIG5hbWUsIGRhdGEpO1xufTtcblxuLy8gQ3JlYXRlIGEgZG9jdW1lbnQgaWYgaXQgZG9lc24ndCBleGlzdC4gUmV0dXJucyB0aGUgZG9jdW1lbnQgc3luY2hyb25vdXNseS5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIG5hbWUsIGRhdGEpIHtcbiAgdmFyIGRvYyA9IHRoaXMuZ2V0RXhpc3RpbmcoY29sbGVjdGlvbiwgbmFtZSk7XG5cbiAgaWYgKCFkb2MpIHtcbiAgICAvLyBDcmVhdGUgaXQuXG4gICAgZG9jID0gbmV3IERvYyh0aGlzLCBjb2xsZWN0aW9uLCBuYW1lKTtcblxuICAgIHZhciBjb2xsZWN0aW9uT2JqZWN0ID0gdGhpcy5jb2xsZWN0aW9uc1tjb2xsZWN0aW9uXSA9XG4gICAgICAodGhpcy5jb2xsZWN0aW9uc1tjb2xsZWN0aW9uXSB8fCB7fSk7XG4gICAgY29sbGVjdGlvbk9iamVjdFtuYW1lXSA9IGRvYztcbiAgfVxuXG4gIC8vIEV2ZW4gaWYgdGhlIGRvY3VtZW50IGlzbid0IG5ldywgaXRzIHBvc3NpYmxlIHRoZSBkb2N1bWVudCB3YXMgY3JlYXRlZFxuICAvLyBtYW51YWxseSBhbmQgdGhlbiB0cmllZCB0byBiZSByZS1jcmVhdGVkIHdpdGggZGF0YSAoc3VwcG9zZSBhIHF1ZXJ5XG4gIC8vIHJldHVybnMgd2l0aCBkYXRhIGZvciB0aGUgZG9jdW1lbnQpLiBXZSBzaG91bGQgaHlkcmF0ZSB0aGUgZG9jdW1lbnRcbiAgLy8gaW1tZWRpYXRlbHkgaWYgd2UgY2FuIGJlY2F1c2UgdGhlIHF1ZXJ5IGNhbGxiYWNrIHdpbGwgZXhwZWN0IHRoZSBkb2N1bWVudFxuICAvLyB0byBoYXZlIGRhdGEuXG4gIGlmIChkYXRhICYmIGRhdGEuZGF0YSAhPT0gdW5kZWZpbmVkICYmICFkb2Muc3RhdGUpIHtcbiAgICBkb2MuaW5qZXN0RGF0YShkYXRhKTtcbiAgfVxuXG4gIHJldHVybiBkb2M7XG59O1xuXG4vLyBDYWxsIGRvYy5kZXN0cm95KClcbkNvbm5lY3Rpb24ucHJvdG90eXBlLl9kZXN0cm95RG9jID0gZnVuY3Rpb24oZG9jKSB7XG4gIHZhciBjb2xsZWN0aW9uT2JqZWN0ID0gdGhpcy5jb2xsZWN0aW9uc1tkb2MuY29sbGVjdGlvbl07XG4gIGlmICghY29sbGVjdGlvbk9iamVjdCkgcmV0dXJuO1xuXG4gIGRlbGV0ZSBjb2xsZWN0aW9uT2JqZWN0W2RvYy5uYW1lXTtcblxuICAvLyBEZWxldGUgdGhlIGNvbGxlY3Rpb24gY29udGFpbmVyIGlmIGl0cyBlbXB0eS4gVGhpcyBjb3VsZCBiZSBhIHNvdXJjZSBvZlxuICAvLyBtZW1vcnkgbGVha3MgaWYgeW91IHNsb3dseSBtYWtlIGEgYmlsbGlvbiBjb2xsZWN0aW9ucywgd2hpY2ggeW91IHByb2JhYmx5XG4gIC8vIHdvbid0IGRvIGFueXdheSwgYnV0IHdoYXRldmVyLlxuICBpZiAoIWhhc0tleXMoY29sbGVjdGlvbk9iamVjdCkpXG4gICAgZGVsZXRlIHRoaXMuY29sbGVjdGlvbnNbZG9jLmNvbGxlY3Rpb25dO1xufTtcbiBcbmZ1bmN0aW9uIGhhc0tleXMob2JqZWN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyAqKioqIFF1ZXJpZXMuXG5cbi8vIEhlbHBlciBmb3IgY3JlYXRlRmV0Y2hRdWVyeSBhbmQgY3JlYXRlU3Vic2NyaWJlUXVlcnksIGJlbG93LlxuQ29ubmVjdGlvbi5wcm90b3R5cGUuX2NyZWF0ZVF1ZXJ5ID0gZnVuY3Rpb24odHlwZSwgY29sbGVjdGlvbiwgcSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGUgIT09ICdmZXRjaCcgJiYgdHlwZSAhPT0gJ3N1YicpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHF1ZXJ5IHR5cGU6ICcgKyB0eXBlKTtcblxuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGlkID0gdGhpcy5uZXh0UXVlcnlJZCsrO1xuICB2YXIgcXVlcnkgPSBuZXcgUXVlcnkodHlwZSwgdGhpcywgaWQsIGNvbGxlY3Rpb24sIHEsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgdGhpcy5xdWVyaWVzW2lkXSA9IHF1ZXJ5O1xuICBxdWVyeS5fZXhlY3V0ZSgpO1xuICByZXR1cm4gcXVlcnk7XG59O1xuXG4vLyBJbnRlcm5hbCBmdW5jdGlvbi4gVXNlIHF1ZXJ5LmRlc3Ryb3koKSB0byByZW1vdmUgcXVlcmllcy5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLl9kZXN0cm95UXVlcnkgPSBmdW5jdGlvbihxdWVyeSkge1xuICBkZWxldGUgdGhpcy5xdWVyaWVzW3F1ZXJ5LmlkXTtcbn07XG5cbi8vIFRoZSBxdWVyeSBvcHRpb25zIG9iamVjdCBjYW4gY29udGFpbiB0aGUgZm9sbG93aW5nIGZpZWxkczpcbi8vXG4vLyBkb2NNb2RlOiBXaGF0IHRvIGRvIHdpdGggZG9jdW1lbnRzIHRoYXQgYXJlIGluIHRoZSByZXN1bHQgc2V0LiBDYW4gYmVcbi8vICAgbnVsbC91bmRlZmluZWQgKGRlZmF1bHQpLCAnZmV0Y2gnIG9yICdzdWJzY3JpYmUnLiBGZXRjaCBtb2RlIGluZGljYXRlc1xuLy8gICB0aGF0IHRoZSBzZXJ2ZXIgc2hvdWxkIHNlbmQgZG9jdW1lbnQgc25hcHNob3RzIHRvIHRoZSBjbGllbnQgZm9yIGFsbCBxdWVyeVxuLy8gICByZXN1bHRzLiBUaGVzZSB3aWxsIGJlIGh5ZHJhdGVkIGludG8gdGhlIGRvY3VtZW50IG9iamVjdHMgYmVmb3JlIHRoZSBxdWVyeVxuLy8gICByZXN1bHQgY2FsbGJhY2tzIGFyZSByZXR1cm5lZC4gU3Vic2NyaWJlIG1vZGUgZ2V0cyBkb2N1bWVudCBzbmFwc2hvdHMgYW5kXG4vLyAgIGF1dG9tYXRpY2FsbHkgc3Vic2NyaWJlcyB0aGUgY2xpZW50IHRvIGFsbCByZXN1bHRzLiBOb3RlIHRoYXQgdGhlXG4vLyAgIGRvY3VtZW50cyAqV0lMTCBOT1QqIGJlIGF1dG9tYXRpY2FsbHkgdW5zdWJzY3JpYmVkIHdoZW4gdGhlIHF1ZXJ5IGlzXG4vLyAgIGRlc3Ryb3llZC4gKFNoYXJlSlMgZG9lc24ndCBoYXZlIGVub3VnaCBpbmZvcm1hdGlvbiB0byBkbyB0aGF0IHNhZmVseSkuXG4vLyAgIEJld2FyZSBvZiBtZW1vcnkgbGVha3Mgd2hlbiB1c2luZyB0aGlzIG9wdGlvbi5cbi8vXG4vLyBwb2xsOiBGb3JjYWJseSBlbmFibGUgb3IgZGlzYWJsZSBwb2xsaW5nIG1vZGUuIFBvbGxpbmcgbW9kZSB3aWxsIHJlaXNzdWUgdGhlIHF1ZXJ5XG4vLyAgIGV2ZXJ5IHRpbWUgYW55dGhpbmcgaW4gdGhlIGNvbGxlY3Rpb24gY2hhbmdlcyAoISEpIHNvLCBpdHMgcXVpdGVcbi8vICAgZXhwZW5zaXZlLiAgSXQgaXMgYXV0b21hdGljYWxseSBlbmFibGVkIGZvciBwYWdpbmF0ZWQgYW5kIHNvcnRlZCBxdWVyaWVzLlxuLy8gICBCeSBkZWZhdWx0IHF1ZXJpZXMgcnVuIHdpdGggcG9sbGluZyBtb2RlIGRpc2FibGVkOyB3aGljaCB3aWxsIG9ubHkgY2hlY2tcbi8vICAgY2hhbmdlZCBkb2N1bWVudHMgdG8gdGVzdCBpZiB0aGV5IG5vdyBtYXRjaCB0aGUgc3BlY2lmaWVkIHF1ZXJ5LlxuLy8gICBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBwb2xsaW5nIG1vZGUsIG9yIHRydWUgdG8gZW5hYmxlIGl0LiBJZiB5b3UgZG9uJ3Rcbi8vICAgc3BlY2lmeSBhIHBvbGwgb3B0aW9uLCBwb2xsaW5nIG1vZGUgaXMgZW5hYmxlZCBvciBkaXNhYmxlZCBhdXRvbWF0aWNhbGx5XG4vLyAgIGJ5IHRoZSBxdWVyeSdzIGJhY2tlbmQuXG4vL1xuLy8gYmFja2VuZDogU2V0IHRoZSBiYWNrZW5kIHNvdXJjZSBmb3IgdGhlIHF1ZXJ5LiBZb3UgY2FuIGF0dGFjaCBkaWZmZXJlbnRcbi8vICAgcXVlcnkgYmFja2VuZHMgdG8gbGl2ZWRiIGFuZCBwaWNrIHdoaWNoIG9uZSB0aGUgcXVlcnkgc2hvdWxkIGhpdCB1c2luZ1xuLy8gICB0aGlzIHBhcmFtZXRlci5cbi8vXG4vLyByZXN1bHRzOiAoZXhwZXJpbWVudGFsKSBJbml0aWFsIGxpc3Qgb2YgcmVzdWx0YW50IGRvY3VtZW50cy4gVGhpcyBpc1xuLy8gICB1c2VmdWwgZm9yIHJlaHlkcmF0aW5nIHF1ZXJpZXMgd2hlbiB5b3UncmUgdXNpbmcgYXV0b0ZldGNoIC8gYXV0b1N1YnNjcmliZVxuLy8gICBzbyB0aGUgc2VydmVyIGRvZXNuJ3QgaGF2ZSB0byBzZW5kIG92ZXIgc25hcHNob3RzIGZvciBkb2N1bWVudHMgdGhlIGNsaWVudFxuLy8gICBhbHJlYWR5IGtub3dzIGFib3V0LiBUaGlzIGlzIGV4cGVyaW1lbnRhbCAtIHRoZSBBUEkgbWF5IGNoYW5nZSBpbiB1cGNvbWluZ1xuLy8gICB2ZXJzaW9ucy5cblxuLy8gQ3JlYXRlIGEgZmV0Y2ggcXVlcnkuIEZldGNoIHF1ZXJpZXMgYXJlIG9ubHkgaXNzdWVkIG9uY2UsIHJldHVybmluZyB0aGVcbi8vIHJlc3VsdHMgZGlyZWN0bHkgaW50byB0aGUgY2FsbGJhY2suXG4vL1xuLy8gVGhlIGluZGV4IGlzIHNwZWNpZmljIHRvIHRoZSBzb3VyY2UsIGJ1dCBpZiB5b3UncmUgdXNpbmcgbW9uZ29kYiBpdCdsbCBiZVxuLy8gdGhlIGNvbGxlY3Rpb24gdG8gd2hpY2ggdGhlIHF1ZXJ5IGlzIG1hZGUuXG4vLyBUaGUgY2FsbGJhY2sgc2hvdWxkIGhhdmUgdGhlIHNpZ25hdHVyZSBmdW5jdGlvbihlcnJvciwgcmVzdWx0cywgZXh0cmFEYXRhKVxuLy8gd2hlcmUgcmVzdWx0cyBpcyBhIGxpc3Qgb2YgRG9jIG9iamVjdHMuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVGZXRjaFF1ZXJ5ID0gZnVuY3Rpb24oaW5kZXgsIHEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9jcmVhdGVRdWVyeSgnZmV0Y2gnLCBpbmRleCwgcSwgb3B0aW9ucywgY2FsbGJhY2spO1xufTtcblxuLy8gQ3JlYXRlIGEgc3Vic2NyaWJlIHF1ZXJ5LiBTdWJzY3JpYmUgcXVlcmllcyByZXR1cm4gd2l0aCB0aGUgaW5pdGlhbCBkYXRhXG4vLyB0aHJvdWdoIHRoZSBjYWxsYmFjaywgdGhlbiB1cGRhdGUgdGhlbXNlbHZlcyB3aGVuZXZlciB0aGUgcXVlcnkgcmVzdWx0IHNldFxuLy8gY2hhbmdlcyB2aWEgdGhlaXIgb3duIGV2ZW50IGVtaXR0ZXIuXG4vL1xuLy8gSWYgcHJlc2VudCwgdGhlIGNhbGxiYWNrIHNob3VsZCBoYXZlIHRoZSBzaWduYXR1cmUgZnVuY3Rpb24oZXJyb3IsIHJlc3VsdHMsIGV4dHJhRGF0YSlcbi8vIHdoZXJlIHJlc3VsdHMgaXMgYSBsaXN0IG9mIERvYyBvYmplY3RzLlxuQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlU3Vic2NyaWJlUXVlcnkgPSBmdW5jdGlvbihpbmRleCwgcSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZVF1ZXJ5KCdzdWInLCBpbmRleCwgcSwgb3B0aW9ucywgY2FsbGJhY2spO1xufTtcblxuaWYgKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykge1xuICBNaWNyb0V2ZW50ID0gcmVxdWlyZSgnLi9taWNyb2V2ZW50Jyk7XG59XG5cbk1pY3JvRXZlbnQubWl4aW4oQ29ubmVjdGlvbik7XG5cbiIsInZhciB0eXBlcywgTWljcm9FdmVudDtcblxuaWYgKHR5cGVvZiByZXF1aXJlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHR5cGVzID0gcmVxdWlyZSgnb3R0eXBlcycpO1xuICBNaWNyb0V2ZW50ID0gcmVxdWlyZSgnLi9taWNyb2V2ZW50Jyk7XG59IGVsc2Uge1xuICB0eXBlcyA9IHdpbmRvdy5vdHR5cGVzO1xufVxuXG4vKlxuICogQSBEb2MgaXMgYSBjbGllbnQncyB2aWV3IG9uIGEgc2hhcmVqcyBkb2N1bWVudC5cbiAqXG4gKiBEb2N1bWVudHMgc2hvdWxkIG5vdCBiZSBjcmVhdGVkIGRpcmVjdGx5LiBDcmVhdGUgdGhlbSBieSBjYWxsaW5nIHRoZVxuICogZG9jdW1lbnQgZ2V0dGluZyBmdW5jdGlvbnMgaW4gY29ubmVjdGlvbi5cbiAqXG4gKiBEb2N1bWVudHMgYXJlIGV2ZW50IGVtaXR0ZXJzLiBVc2UgZG9jLm9uKGV2ZW50bmFtZSwgZm4pIHRvIHN1YnNjcmliZS5cbiAqXG4gKiBEb2N1bWVudHMgY3VycmVudGx5IGdldCBtaXhlZCBpbiB3aXRoIHRoZWlyIHR5cGUncyBBUEkgbWV0aG9kcy4gU28sIHlvdSBjYW5cbiAqIC5pbnNlcnQoJ2ZvbycsIDApIGludG8gYSB0ZXh0IGRvY3VtZW50IGFuZCBzdHVmZiBsaWtlIHRoYXQuXG4gKlxuICogRXZlbnRzOlxuICogLSBiZWZvcmUgb3AgKG9wLCBsb2NhbFNpdGUpOiBGaXJlZCBiZWZvcmUgYW4gb3BlcmF0aW9uIGlzIGFwcGxpZWQgdG8gdGhlXG4gKiAgIGRvY3VtZW50LlxuICogLSBvcCAob3AsIGxvY2FsU2l0ZSk6IEZpcmVkIHJpZ2h0IGFmdGVyIGFuIG9wZXJhdGlvbiAob3IgcGFydCBvZiBhblxuICogICBvcGVyYXRpb24pIGhhcyBiZWVuIGFwcGxpZWQgdG8gdGhlIGRvY3VtZW50LiBTdWJtaXR0aW5nIGFub3RoZXIgb3AgaGVyZSBpc1xuICogICBpbnZhbGlkIC0gd2FpdCB1bnRpbCAnYWZ0ZXIgb3AnIGlmIHlvdSB3YW50IHRvIHN1Ym1pdCBtb3JlIG9wZXJhdGlvbnMuICAtXG4gKiAgIGNoYW5nZWQgKG9wKVxuICogLSBhZnRlciBvcCAob3AsIGxvY2FsU2l0ZSk6IEZpcmVkIGFmdGVyIGFuIG9wZXJhdGlvbiBoYXMgYmVlbiBhcHBsaWVkLiBZb3VcbiAqICAgY2FuIHN1Ym1pdCBtb3JlIG9wcyBoZXJlLlxuICogLSBzdWJzY3JpYmVkIChlcnJvcik6IFRoZSBkb2N1bWVudCB3YXMgc3Vic2NyaWJlZFxuICogLSB1bnN1YnNjcmliZWQgKGVycm9yKTogVGhlIGRvY3VtZW50IHdhcyB1bnN1YnNjcmliZWRcbiAqIC0gY3JlYXRlZDogVGhlIGRvY3VtZW50IHdhcyBjcmVhdGVkLiBUaGF0IG1lYW5zIGl0cyB0eXBlIHdhcyBzZXQgYW5kIGl0IGhhc1xuICogICBzb21lIGluaXRpYWwgZGF0YS5cbiAqIC0gZXJyb3JcbiAqL1xudmFyIERvYyA9IGV4cG9ydHMuRG9jID0gZnVuY3Rpb24oY29ubmVjdGlvbiwgY29sbGVjdGlvbiwgbmFtZSkge1xuICB0aGlzLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuXG4gIHRoaXMuY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gIHRoaXMubmFtZSA9IG5hbWU7XG5cbiAgdGhpcy52ZXJzaW9uID0gdGhpcy50eXBlID0gbnVsbDtcblxuICAvLyAqKioqIFN0YXRlIGluIGRvY3VtZW50OlxuIFxuICAvLyBBY3Rpb24uIFRoaXMgaXMgZWl0aGVyIG51bGwsIG9yIG9uZSBvZiB0aGUgYWN0aW9ucyAoc3Vic2NyaWJlLFxuICAvLyB1bnN1YnNjcmliZSwgZmV0Y2gsIHN1Ym1pdCkuIE9ubHkgb25lIGFjdGlvbiBjYW4gYmUgaGFwcGVuaW5nIGF0IGEgdGltZSB0b1xuICAvLyBwcmV2ZW50IG1lIGZyb20gZ29pbmcgbWFkLlxuICAvL1xuICAvLyBQb3NzaWJsZSB2YWx1ZXM6XG4gIC8vIC0gc3Vic2NyaWJlXG4gIC8vIC0gdW5zdWJzY3JpYmVcbiAgLy8gLSBmZXRjaFxuICAvLyAtIHN1Ym1pdFxuICB0aGlzLmFjdGlvbiA9IG51bGw7XG4gXG4gIC8vIFRoZSBkYXRhIHRoZSBkb2N1bWVudCBvYmplY3Qgc3RvcmVzIGNhbiBiZSBpbiBvbmUgb2YgdGhlIGZvbGxvd2luZyB0aHJlZSBzdGF0ZXM6XG4gIC8vICAgLSBObyBkYXRhLiAobnVsbCkgV2UgaG9uZXN0bHkgZG9uJ3Qga25vdyB3aGF0cyBnb2luZyBvbi5cbiAgLy8gICAtIEZsb2F0aW5nICgnZmxvYXRpbmcnKTogd2UgaGF2ZSBhIGxvY2FsbHkgY3JlYXRlZCBkb2N1bWVudCB0aGF0IGhhc24ndFxuICAvLyAgICAgYmVlbiBjcmVhdGVkIG9uIHRoZSBzZXJ2ZXIgeWV0KVxuICAvLyAgIC0gTGl2ZSAoJ3JlYWR5JykgKHdlIGhhdmUgZGF0YSB0aGF0cyBjdXJyZW50IG9uIHRoZSBzZXJ2ZXIgYXQgc29tZSB2ZXJzaW9uKS5cbiAgdGhpcy5zdGF0ZSA9IG51bGw7XG5cbiAgLy8gT3VyIHN1YnNjcmlwdGlvbiBzdGF0dXMuIEVpdGhlciB3ZSdyZSBzdWJzY3JpYmVkIG9uIHRoZSBzZXJ2ZXIsIG9yIHdlIGFyZW4ndC5cbiAgdGhpcy5zdWJzY3JpYmVkID0gZmFsc2U7XG4gIC8vIEVpdGhlciB3ZSB3YW50IHRvIGJlIHN1YnNjcmliZWQgKHRydWUpLCB3ZSB3YW50IGEgbmV3IHNuYXBzaG90IGZyb20gdGhlXG4gIC8vIHNlcnZlciAoJ2ZldGNoJyksIG9yIHdlIGRvbid0IGNhcmUgKGZhbHNlKS4gIFRoaXMgaXMgYWxzbyB1c2VkIHdoZW4gd2VcbiAgLy8gZGlzY29ubmVjdCAmIHJlY29ubmVjdCB0byBkZWNpZGUgd2hhdCB0byBkby5cbiAgdGhpcy53YW50U3Vic2NyaWJlID0gZmFsc2U7XG4gIC8vIFRoaXMgbGlzdCBpcyB1c2VkIGZvciBzdWJzY3JpYmUgYW5kIHVuc3Vic2NyaWJlLCBzaW5jZSB3ZSdsbCBvbmx5IHdhbnQgdG9cbiAgLy8gZG8gb25lIHRoaW5nIGF0IGEgdGltZS5cbiAgdGhpcy5fc3Vic2NyaWJlQ2FsbGJhY2tzID0gW107XG5cblxuICAvLyAqKiogZW5kIHN0YXRlIHN0dWZmLlxuXG4gIC8vIFRoaXMgZG9lc24ndCBwcm92aWRlIGFueSBzdGFuZGFyZCBBUEkgYWNjZXNzIHJpZ2h0IG5vdy5cbiAgdGhpcy5wcm92aWRlcyA9IHt9O1xuXG4gIC8vIFRoZSBlZGl0aW5nIGNvbnRleHRzLiBUaGVzZSBhcmUgdXN1YWxseSBpbnN0YW5jZXMgb2YgdGhlIHR5cGUgQVBJIHdoZW4gdGhlXG4gIC8vIGRvY3VtZW50IGlzIHJlYWR5IGZvciBlZGl0cy5cbiAgdGhpcy5lZGl0aW5nQ29udGV4dHMgPSBbXTtcbiAgXG4gIC8vIFRoZSBvcCB0aGF0IGlzIGN1cnJlbnRseSByb3VuZHRyaXBwaW5nIHRvIHRoZSBzZXJ2ZXIsIG9yIG51bGwuXG4gIC8vXG4gIC8vIFdoZW4gdGhlIGNvbm5lY3Rpb24gcmVjb25uZWN0cywgdGhlIGluZmxpZ2h0IG9wIGlzIHJlc3VibWl0dGVkLlxuICAvL1xuICAvLyBUaGlzIGhhcyB0aGUgc2FtZSBmb3JtYXQgYXMgYW4gZW50cnkgaW4gcGVuZGluZ0RhdGEsIHdoaWNoIGlzOlxuICAvLyB7W2NyZWF0ZTp7Li4ufV0sIFtkZWw6dHJ1ZV0sIFtvcDouLi5dLCBjYWxsYmFja3M6Wy4uLl0sIHNyYzosIHNlcTp9XG4gIHRoaXMuaW5mbGlnaHREYXRhID0gbnVsbDtcblxuICAvLyBBbGwgb3BzIHRoYXQgYXJlIHdhaXRpbmcgZm9yIHRoZSBzZXJ2ZXIgdG8gYWNrbm93bGVkZ2UgQGluZmxpZ2h0RGF0YVxuICAvLyBUaGlzIHVzZWQgdG8ganVzdCBiZSBhIHNpbmdsZSBvcGVyYXRpb24sIGJ1dCBjcmVhdGVzICYgZGVsZXRlcyBjYW4ndCBiZSBjb21wb3NlZCB3aXRoXG4gIC8vIHJlZ3VsYXIgb3BlcmF0aW9ucy5cbiAgLy9cbiAgLy8gVGhpcyBpcyBhIGxpc3Qgb2Yge1tjcmVhdGU6ey4uLn1dLCBbZGVsOnRydWVdLCBbb3A6Li4uXSwgY2FsbGJhY2tzOlsuLi5dfVxuICB0aGlzLnBlbmRpbmdEYXRhID0gW107XG59O1xuXG5NaWNyb0V2ZW50Lm1peGluKERvYyk7XG5cbkRvYy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBkb2MgPSB0aGlzO1xuICB0aGlzLnVuc3Vic2NyaWJlKGZ1bmN0aW9uKCkge1xuICAgIC8vIERvbid0IGNhcmUgaWYgdGhlcmUncyBhbiBlcnJvciB1bnN1YnNjcmliaW5nLlxuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIC8vIFRoZXJlJ2xsIHByb2JhYmx5IGJlIG5vdGhpbmcgaGVyZSBzZWVpbmcgYXMgaG93IHdlIGp1c3QgdW5zdWJzY3JpYmVkLlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2MuX3N1YnNjcmliZUNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBkb2MuX3N1YnNjcmliZUNhbGxiYWNrc1tpXSgnRG9jdW1lbnQgZGVzdHJveWVkJyk7XG4gICAgICB9XG4gICAgICBkb2MuX3N1YnNjcmliZUNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgIH0sIDApO1xuXG4gICAgZG9jLmNvbm5lY3Rpb24uX2Rlc3Ryb3lEb2MoZG9jKTtcbiAgICBkb2MucmVtb3ZlQ29udGV4dHMoKTtcbiAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gIH0pO1xufTtcblxuXG4vLyAqKioqKiogTWFuaXB1bGF0aW5nIHRoZSBkb2N1bWVudCBzbmFwc2hvdCwgdmVyc2lvbiBhbmQgdHlwZS5cblxuLy8gU2V0IHRoZSBkb2N1bWVudCdzIHR5cGUsIGFuZCBhc3NvY2lhdGVkIHByb3BlcnRpZXMuIE1vc3Qgb2YgdGhlIGxvZ2ljIGluXG4vLyB0aGlzIGZ1bmN0aW9uIGV4aXN0cyB0byB1cGRhdGUgdGhlIGRvY3VtZW50IGJhc2VkIG9uIGFueSBhZGRlZCAmIHJlbW92ZWQgQVBJXG4vLyBtZXRob2RzLlxuRG9jLnByb3RvdHlwZS5fc2V0VHlwZSA9IGZ1bmN0aW9uKG5ld1R5cGUpIHtcbiAgaWYgKHR5cGVvZiBuZXdUeXBlID09PSAnc3RyaW5nJykge1xuICAgIGlmICghdHlwZXNbbmV3VHlwZV0pIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdHlwZSBcIiArIG5ld1R5cGUpO1xuICAgIG5ld1R5cGUgPSB0eXBlc1tuZXdUeXBlXTtcbiAgfVxuICB0aGlzLnJlbW92ZUNvbnRleHRzKCk7XG5cbiAgLy8gU2V0IHRoZSBuZXcgdHlwZVxuICB0aGlzLnR5cGUgPSBuZXdUeXBlO1xuXG4gIC8vIElmIHdlIHJlbW92ZWQgdGhlIHR5cGUgZnJvbSB0aGUgb2JqZWN0LCBhbHNvIHJlbW92ZSBpdHMgc25hcHNob3QuXG4gIGlmICghbmV3VHlwZSkge1xuICAgIHRoaXMucHJvdmlkZXMgPSB7fTtcbiAgfSBlbHNlIGlmIChuZXdUeXBlLmFwaSkge1xuICAgIC8vIFJlZ2lzdGVyIHRoZSBuZXcgdHlwZSdzIEFQSS5cbiAgICB0aGlzLnByb3ZpZGVzID0gbmV3VHlwZS5hcGkucHJvdmlkZXM7XG4gIH1cbn07XG5cbi8vIEluamVzdCBzbmFwc2hvdCBkYXRhLiBUaGlzIGRhdGEgbXVzdCBpbmNsdWRlIGEgdmVyc2lvbiwgc25hcHNob3QgYW5kIHR5cGUuXG4vLyBUaGlzIGlzIHVzZWQgYm90aCB0byBpbmplc3QgZGF0YSB0aGF0IHdhcyBleHBvcnRlZCB3aXRoIGEgd2VicGFnZSBhbmQgZGF0YVxuLy8gdGhhdCB3YXMgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyIGR1cmluZyBhIGZldGNoLlxuRG9jLnByb3RvdHlwZS5pbmplc3REYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICBpZiAodGhpcy5zdGF0ZSkge1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikgY29uc29sZS53YXJuKCdJZ25vcmluZyBhdHRlbXB0IHRvIGluamVzdCBkYXRhIGluIHN0YXRlJywgdGhpcy5zdGF0ZSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2YgZGF0YS52ICE9PSAnbnVtYmVyJykgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHZlcnNpb24gaW4gaW5qZXN0ZWQgZGF0YScpO1xuXG5cbiAgdGhpcy52ZXJzaW9uID0gZGF0YS52O1xuICAvLyBkYXRhLmRhdGEgaXMgd2hhdCB0aGUgc2VydmVyIHdpbGwgYWN0dWFsbHkgc2VuZC4gZGF0YS5zbmFwc2hvdCBpcyB0aGUgb2xkXG4gIC8vIGZpZWxkIG5hbWUgLSBzdXBwb3J0ZWQgbm93IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgdGhpcy5zbmFwc2hvdCA9IGRhdGEuZGF0YSB8fCBkYXRhLnNuYXBzaG90O1xuICB0aGlzLl9zZXRUeXBlKGRhdGEudHlwZSk7XG5cbiAgdGhpcy5zdGF0ZSA9ICdyZWFkeSc7XG4gIHRoaXMuZW1pdCgncmVhZHknKTtcbn07XG5cbi8vIEdldCBhbmQgcmV0dXJuIHRoZSBjdXJyZW50IGRvY3VtZW50IHNuYXBzaG90LlxuRG9jLnByb3RvdHlwZS5nZXRTbmFwc2hvdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zbmFwc2hvdDtcbn07XG5cbi8vIFRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhdCBhIHRpbWUgd2hlbiB0aGUgZG9jdW1lbnQgaGFzIGEgc25hcHNob3QgYW5kXG4vLyB5b3UgY2FuIHN0YXJ0IGFwcGx5aW5nIG9wZXJhdGlvbnMuIFRoaXMgbWF5IGJlIGltbWVkaWF0ZWx5LlxuRG9jLnByb3RvdHlwZS53aGVuUmVhZHkgPSBmdW5jdGlvbihmbikge1xuICBpZiAodGhpcy5zdGF0ZSA9PT0gJ3JlYWR5Jykge1xuICAgIGZuKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vbigncmVhZHknLCBmbik7XG4gIH1cbn07XG5cbkRvYy5wcm90b3R5cGUuaGFzUGVuZGluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5pbmZsaWdodERhdGEgIT0gbnVsbCB8fCAhIXRoaXMucGVuZGluZ0RhdGEubGVuZ3RoO1xufTtcblxuXG4vLyAqKioqIEhlbHBlcnMgZm9yIG5ldHdvcmsgbWVzc2FnZXNcblxuLy8gU2VuZCBhIG1lc3NhZ2UgdG8gdGhlIGNvbm5lY3Rpb24gZnJvbSB0aGlzIGRvY3VtZW50LlxuRG9jLnByb3RvdHlwZS5fc2VuZCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgbWVzc2FnZS5jID0gdGhpcy5jb2xsZWN0aW9uO1xuICBtZXNzYWdlLmQgPSB0aGlzLm5hbWU7XG4gIHRoaXMuY29ubmVjdGlvbi5zZW5kKG1lc3NhZ2UpO1xufTtcblxuLy8gVGhpcyBmdW5jdGlvbiBleGlzdHMgc28gY29ubmVjdGlvbiBjYW4gY2FsbCBpdCBkaXJlY3RseSBmb3IgYnVsayBzdWJzY3JpYmVzLlxuLy8gSXQgY291bGQganVzdCBtYWtlIGEgdGVtcG9yYXJ5IG9iamVjdCBsaXRlcmFsLCB0aGF0cyBwcmV0dHkgc2xvdy5cbkRvYy5wcm90b3R5cGUuX2hhbmRsZVN1YnNjcmliZSA9IGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICBpZiAoZXJyICYmIGVyciAhPT0gJ0FscmVhZHkgc3Vic2NyaWJlZCcpIHtcbiAgICBpZiAoY29uc29sZSkgY29uc29sZS5lcnJvcihcIkNvdWxkIG5vdCBzdWJzY3JpYmU6IFwiICsgZXJyKTtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAvLyBUaGVyZSdzIHByb2JhYmx5IGEgcmVhc29uIHdlIGNvdWxkbid0IHN1YnNjcmliZS4gRG9uJ3QgcmV0cnkuXG4gICAgdGhpcy5fc2V0V2FudFN1YnNjcmliZShmYWxzZSwgbnVsbCwgZXJyKVxuICB9IGVsc2Uge1xuICAgIGlmIChkYXRhKSB0aGlzLmluamVzdERhdGEoZGF0YSk7XG4gICAgdGhpcy5zdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoJ3N1YnNjcmliZScpO1xuICAgIHRoaXMuX2ZpbmlzaFN1Yih0cnVlKTtcbiAgfVxuXG4gIHRoaXMuX2NsZWFyQWN0aW9uKCdzdWJzY3JpYmUnKTtcbn07XG5cbi8vIFRoaXMgaXMgY2FsbGVkIGJ5IHRoZSBjb25uZWN0aW9uIHdoZW4gaXQgcmVjZWl2ZXMgYSBtZXNzYWdlIGZvciB0aGUgZG9jdW1lbnQuXG5Eb2MucHJvdG90eXBlLl9vbk1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpIHtcbiAgaWYgKCEobXNnLmMgPT09IHRoaXMuY29sbGVjdGlvbiAmJiBtc2cuZCA9PT0gdGhpcy5uYW1lKSkge1xuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiAtIGl0cyBhIHNhbml0eSBjaGVjayBmb3IgYnVncyBpbiB0aGUgY29ubmVjdGlvbiBjb2RlLlxuICAgIHRocm93IG5ldyBFcnJvcihcIkdvdCBtZXNzYWdlIGZvciB3cm9uZyBkb2N1bWVudC5cIik7XG4gIH1cblxuICAvLyBtc2cuYSA9IHRoZSBhY3Rpb24uXG4gIHN3aXRjaCAobXNnLmEpIHtcbiAgICBjYXNlICdmZXRjaCc6XG4gICAgICAvLyBXZSdyZSBkb25lIGZldGNoaW5nLiBUaGlzIG1lc3NhZ2UgaGFzIG5vIG90aGVyIGluZm9ybWF0aW9uLlxuICAgICAgaWYgKG1zZy5kYXRhKSB0aGlzLmluamVzdERhdGEobXNnLmRhdGEpO1xuICAgICAgdGhpcy5fZmluaXNoU3ViKCdmZXRjaCcsIG1zZy5lcnJvcik7XG4gICAgICBpZiAodGhpcy53YW50U3Vic2NyaWJlID09PSAnZmV0Y2gnKSB0aGlzLndhbnRTdWJzY3JpYmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2NsZWFyQWN0aW9uKCdmZXRjaCcpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdzdWInOlxuICAgICAgLy8gU3Vic2NyaWJlIHJlcGx5LlxuICAgICAgdGhpcy5faGFuZGxlU3Vic2NyaWJlKG1zZy5lcnJvciwgbXNnLmRhdGEpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd1bnN1Yic6XG4gICAgICAvLyBVbnN1YnNjcmliZSByZXBseVxuICAgICAgdGhpcy5zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICB0aGlzLmVtaXQoJ3Vuc3Vic2NyaWJlJyk7XG5cbiAgICAgIHRoaXMuX2ZpbmlzaFN1YihmYWxzZSwgbXNnLmVycm9yKTtcbiAgICAgIHRoaXMuX2NsZWFyQWN0aW9uKCd1bnN1YnNjcmliZScpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdhY2snOlxuICAgICAgLy8gQWNrbm93bGVkZ2UgYSBsb2NhbGx5IHN1Ym1pdHRlZCBvcGVyYXRpb24uXG4gICAgICAvL1xuICAgICAgLy8gVXN1YWxseSB3ZSBkbyBub3RoaW5nIGhlcmUgLSBhbGwgdGhlIGludGVyZXN0aW5nIGxvZ2ljIGhhcHBlbnMgd2hlbiB3ZVxuICAgICAgLy8gZ2V0IHNlbnQgb3VyIG9wIGJhY2sgaW4gdGhlIG9wIHN0cmVhbSAod2hpY2ggaGFwcGVucyBldmVuIGlmIHdlIGFyZW4ndFxuICAgICAgLy8gc3Vic2NyaWJlZCkuIEhvd2V2ZXIsIGlmIHRoZSBvcCBkb2Vzbid0IGdldCBhY2NlcHRlZCwgd2Ugc3RpbGwgbmVlZCB0b1xuICAgICAgLy8gY2xlYXIgc29tZSBzdGF0ZS5cbiAgICAgIC8vXG4gICAgICAvLyBJZiB0aGUgbWVzc2FnZSBlcnJvciBpcyAnT3AgYWxyZWFkeSBzdWJtaXR0ZWQnLCB0aGF0IG1lYW5zIHdlJ3ZlXG4gICAgICAvLyByZXNlbnQgYW4gb3AgdGhhdCB0aGUgc2VydmVyIGFscmVhZHkgZ290LiBJdCB3aWxsIGFsc28gYmUgY29uZmlybWVkXG4gICAgICAvLyBub3JtYWxseS5cbiAgICAgIGlmIChtc2cuZXJyb3IgJiYgbXNnLmVycm9yICE9PSAnT3AgYWxyZWFkeSBzdWJtaXR0ZWQnKSB7XG4gICAgICAgIC8vIFRoZSBzZXJ2ZXIgaGFzIHJlamVjdGVkIGFuIG9wIGZyb20gdGhlIGNsaWVudCBmb3Igc29tZSByZWFzb24uXG4gICAgICAgIC8vIFdlJ2xsIHNlbmQgdGhlIGVycm9yIG1lc3NhZ2UgdG8gdGhlIHVzZXIgYW5kIHRyeSB0byByb2xsIGJhY2sgdGhlIGNoYW5nZS5cbiAgICAgICAgaWYgKHRoaXMuaW5mbGlnaHREYXRhKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdPcGVyYXRpb24gd2FzIHJlamVjdGVkICgnICsgbXNnLmVycm9yICsgJykuIFRyeWluZyB0byByb2xsYmFjayBjaGFuZ2UgbG9jYWxseS4nKTtcbiAgICAgICAgICB0aGlzLl90cnlSb2xsYmFjayh0aGlzLmluZmxpZ2h0RGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSSBtYW5hZ2VkIHRvIGdldCBpbnRvIHRoaXMgc3RhdGUgb25jZS4gSSdtIG5vdCBzdXJlIGhvdyBpdCBoYXBwZW5lZC5cbiAgICAgICAgICAvLyBUaGUgb3Agd2FzIG1heWJlIGRvdWJsZS1hY2tub3dsZWRnZWQ/XG4gICAgICAgICAgaWYgKGNvbnNvbGUpIGNvbnNvbGUud2FybignU2Vjb25kIGFja25vd2xlZGdlbWVudCBtZXNzYWdlIChlcnJvcikgcmVjZWl2ZWQnLCBtc2csIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgIHRoaXMuX2NsZWFySW5mbGlnaHRPcChtc2cuZXJyb3IpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdvcCc6XG4gICAgICBpZiAodGhpcy5pbmZsaWdodERhdGEgJiZcbiAgICAgICAgICBtc2cuc3JjID09PSB0aGlzLmluZmxpZ2h0RGF0YS5zcmMgJiZcbiAgICAgICAgICBtc2cuc2VxID09PSB0aGlzLmluZmxpZ2h0RGF0YS5zZXEpIHtcbiAgICAgICAgLy8gVGhpcyBvbmUgaXMgbWluZS4gQWNjZXB0IGl0IGFzIGFja25vd2xlZGdlZC5cbiAgICAgICAgdGhpcy5fb3BBY2tub3dsZWRnZWQobXNnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChtc2cudiAhPT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBoYXBwZW4gbmF0dXJhbGx5IGluIHRoZSBmb2xsb3dpbmcgKG9yIHNpbWlsYXIpIGNhc2VzOlxuICAgICAgICAvL1xuICAgICAgICAvLyBDbGllbnQgaXMgbm90IHN1YnNjcmliZWQgdG8gZG9jdW1lbnQuXG4gICAgICAgIC8vIC0+IGNsaWVudCBzdWJtaXRzIGFuIG9wZXJhdGlvbiAodj0xMClcbiAgICAgICAgLy8gLT4gY2xpZW50IHN1YnNjcmliZXMgdG8gYSBxdWVyeSB3aGljaCBtYXRjaGVzIHRoaXMgZG9jdW1lbnQuIFNheXMgd2VcbiAgICAgICAgLy8gICAgaGF2ZSB2PTEwIG9mIHRoZSBkb2MuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIDwtIHNlcnZlciBhY2tub3dsZWRnZXMgdGhlIG9wZXJhdGlvbiAodj0xMSkuIFNlcnZlciBhY2tub3dsZWRnZXMgdGhlXG4gICAgICAgIC8vICAgIG9wZXJhdGlvbiBiZWNhdXNlIHRoZSBkb2MgaXNuJ3Qgc3Vic2NyaWJlZFxuICAgICAgICAvLyA8LSBzZXJ2ZXIgcHJvY2Vzc2VzIHRoZSBxdWVyeSwgd2hpY2ggc2F5cyB0aGUgY2xpZW50IG9ubHkgaGFzIHY9MTAuXG4gICAgICAgIC8vICAgIFNlcnZlciBzdWJzY3JpYmVzIGF0IHY9MTAgbm90IHY9MTEsIHNvIHdlIGdldCBhbm90aGVyIGNvcHkgb2YgdGhlXG4gICAgICAgIC8vICAgIHY9MTAgb3BlcmF0aW9uLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHdlIGNhbiBzYWZlbHkgaWdub3JlIHRoZSBvbGQgKGR1cGxpY2F0ZSkgb3BlcmF0aW9uLlxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaW5mbGlnaHREYXRhKSB4Zih0aGlzLmluZmxpZ2h0RGF0YSwgbXNnKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBlbmRpbmdEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHhmKHRoaXMucGVuZGluZ0RhdGFbaV0sIG1zZyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudmVyc2lvbisrO1xuICAgICAgdGhpcy5fb3RBcHBseShtc2csIGZhbHNlKTtcbiAgICAgIHRoaXMuX2FmdGVyT3RBcHBseShtc2csIGZhbHNlKTtcbiAgICAgIC8vY29uc29sZS5sb2coJ2FwcGxpZWQnLCBKU09OLnN0cmluZ2lmeShtc2cpKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnbWV0YSc6XG4gICAgICBpZiAoY29uc29sZSkgY29uc29sZS53YXJuKCdVbmhhbmRsZWQgbWV0YSBvcDonLCBtc2cpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKGNvbnNvbGUpIGNvbnNvbGUud2FybignVW5oYW5kbGVkIGRvY3VtZW50IG1lc3NhZ2U6JywgbXNnKTtcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vLyBDYWxsZWQgd2hlbmV2ZXIgKHlvdSBndWVzc2VkIGl0ISkgdGhlIGNvbm5lY3Rpb24gc3RhdGUgY2hhbmdlcy4gVGhpcyB3aWxsXG4vLyBoYXBwZW4gd2hlbiB3ZSBnZXQgZGlzY29ubmVjdGVkICYgcmVjb25uZWN0LlxuRG9jLnByb3RvdHlwZS5fb25Db25uZWN0aW9uU3RhdGVDaGFuZ2VkID0gZnVuY3Rpb24oc3RhdGUsIHJlYXNvbikge1xuICBpZiAoc3RhdGUgPT09ICdjb25uZWN0aW5nJykge1xuICAgIGlmICh0aGlzLmluZmxpZ2h0RGF0YSkge1xuICAgICAgdGhpcy5fc2VuZE9wRGF0YSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgIC8vIFdlIGdvIGludG8gdGhlIGNvbm5lY3RlZCBzdGF0ZSBvbmNlIHdlIGhhdmUgYSBzZXNzaW9uSUQuIFdlIGNhbid0IHNlbmRcbiAgICAvLyBuZXcgb3BzIHVudGlsIHRoZW4sIHNvIHdlIG5lZWQgdG8gZmx1c2ggYWdhaW4uXG4gICAgdGhpcy5mbHVzaCgpO1xuICB9IGVsc2UgaWYgKHN0YXRlID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgIHRoaXMuYWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLnN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5zdWJzY3JpYmVkKSB0aGlzLmVtaXQoJ3Vuc3Vic2NyaWJlZCcpO1xuICB9XG59O1xuXG5cblxuXG4vLyAqKioqKiogRGVhbGluZyB3aXRoIGFjdGlvbnNcblxuRG9jLnByb3RvdHlwZS5fY2xlYXJBY3Rpb24gPSBmdW5jdGlvbihleHBlY3RlZEFjdGlvbikge1xuICBpZiAodGhpcy5hY3Rpb24gIT09IGV4cGVjdGVkQWN0aW9uKSB7XG4gICAgY29uc29sZS53YXJuKCdVbmV4cGVjdGVkIGFjdGlvbiAnICsgdGhpcy5hY3Rpb24gKyAnIGV4cGVjdGVkOiAnICsgZXhwZWN0ZWRBY3Rpb24pO1xuICB9XG4gIHRoaXMuYWN0aW9uID0gbnVsbDtcbiAgdGhpcy5mbHVzaCgpO1xufTtcblxuXG5cbi8vIFNlbmQgdGhlIG5leHQgcGVuZGluZyBvcCB0byB0aGUgc2VydmVyLCBpZiB3ZSBjYW4uXG4vL1xuLy8gT25seSBvbmUgb3BlcmF0aW9uIGNhbiBiZSBpbi1mbGlnaHQgYXQgYSB0aW1lLiBJZiBhbiBvcGVyYXRpb24gaXMgYWxyZWFkeSBvblxuLy8gaXRzIHdheSwgb3Igd2UncmUgbm90IGN1cnJlbnRseSBjb25uZWN0ZWQsIHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZy5cbkRvYy5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmNvbm5lY3Rpb24uY2FuU2VuZCB8fCB0aGlzLmFjdGlvbikgcmV0dXJuO1xuXG4gIHZhciBvcERhdGE7XG4gIC8vIFB1bXAgYW5kIGR1bXAgYW55IG5vLW9wcyBmcm9tIHRoZSBmcm9udCBvZiB0aGUgcGVuZGluZyBvcCBsaXN0LlxuICB3aGlsZSAodGhpcy5wZW5kaW5nRGF0YS5sZW5ndGggJiYgaXNOb09wKG9wRGF0YSA9IHRoaXMucGVuZGluZ0RhdGFbMF0pKSB7XG4gICAgdmFyIGNhbGxiYWNrcyA9IG9wRGF0YS5jYWxsYmFja3M7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNhbGxiYWNrc1tpXShvcERhdGEuZXJyb3IpO1xuICAgIH1cbiAgICB0aGlzLnBlbmRpbmdEYXRhLnNoaWZ0KCk7XG4gIH1cblxuICAvLyBGaXJzdCBjb25zaWRlciBjaGFuZ2luZyBzdGF0ZVxuICBpZiAodGhpcy5zdWJzY3JpYmVkICYmICF0aGlzLndhbnRTdWJzY3JpYmUpIHtcbiAgICB0aGlzLmFjdGlvbiA9ICd1bnN1YnNjcmliZSc7XG4gICAgdGhpcy5fc2VuZCh7YTondW5zdWInfSk7XG4gIH0gZWxzZSBpZiAoIXRoaXMuc3Vic2NyaWJlZCAmJiB0aGlzLndhbnRTdWJzY3JpYmUgPT09ICdmZXRjaCcpIHtcbiAgICB0aGlzLmFjdGlvbiA9ICdmZXRjaCc7XG4gICAgdGhpcy5fc2VuZCh0aGlzLnN0YXRlID09PSAncmVhZHknID8ge2E6J2ZldGNoJywgdjp0aGlzLnZlcnNpb259IDoge2E6J2ZldGNoJ30pO1xuICB9IGVsc2UgaWYgKCF0aGlzLnN1YnNjcmliZWQgJiYgdGhpcy53YW50U3Vic2NyaWJlKSB7XG4gICAgdGhpcy5hY3Rpb24gPSAnc3Vic2NyaWJlJztcbiAgICAvLyBTcGVjaWFsIHNlbmQgbWV0aG9kIG5lZWRlZCBmb3IgYnVsayBzdWJzY3JpYmVzIG9uIHJlY29ubmVjdC5cbiAgICB0aGlzLmNvbm5lY3Rpb24uc2VuZFN1YnNjcmliZSh0aGlzLmNvbGxlY3Rpb24sIHRoaXMubmFtZSwgdGhpcy5zdGF0ZSA9PT0gJ3JlYWR5JyA/IHRoaXMudmVyc2lvbiA6IG51bGwpO1xuICB9IGVsc2UgaWYgKCF0aGlzLnBhdXNlZCAmJiB0aGlzLnBlbmRpbmdEYXRhLmxlbmd0aCAmJiB0aGlzLmNvbm5lY3Rpb24uc3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgLy8gVHJ5IGFuZCBzZW5kIGFueSBwZW5kaW5nIG9wcy4gV2UgY2FuJ3Qgc2VuZCBvcHMgd2hpbGUgaW4gXG4gICAgdGhpcy5pbmZsaWdodERhdGEgPSB0aGlzLnBlbmRpbmdEYXRhLnNoaWZ0KCk7XG5cbiAgICAvLyBEZWxheSBmb3IgZGVidWdnaW5nLlxuICAgIC8vdmFyIHRoYXQgPSB0aGlzO1xuICAgIC8vc2V0VGltZW91dChmdW5jdGlvbigpIHsgdGhhdC5fc2VuZE9wRGF0YSgpOyB9LCAxMDAwKTtcblxuICAgIC8vIFRoaXMgYWxzbyBzZXRzIGFjdGlvbiB0byAnc3VibWl0Jy5cbiAgICB0aGlzLl9zZW5kT3BEYXRhKCk7XG4gIH1cbn07XG5cblxuLy8gKioqKioqIFN1YnNjcmliaW5nLCB1bnN1YnNjcmliaW5nIGFuZCBmZXRjaGluZ1xuXG4vLyBUaGVzZSBmdW5jdGlvbnMgaWFyZSBjb3BpZWQgaW50byB0aGUgcXVlcnkgY2xhc3MgYXMgd2VsbCwgc28gYmUgY2FyZWZ1bCBtYWtpbmdcbi8vIGNoYW5nZXMgaGVyZS5cblxuLy8gVmFsdWUgaXMgdHJ1ZSwgZmFsc2Ugb3IgJ2ZldGNoJy5cbkRvYy5wcm90b3R5cGUuX3NldFdhbnRTdWJzY3JpYmUgPSBmdW5jdGlvbih2YWx1ZSwgY2FsbGJhY2ssIGVycikge1xuICBpZiAodGhpcy5zdWJzY3JpYmVkID09PSB0aGlzLndhbnRTdWJzY3JpYmUgJiZcbiAgICAgICh0aGlzLnN1YnNjcmliZWQgPT09IHZhbHVlIHx8IHZhbHVlID09PSAnZmV0Y2gnICYmIHRoaXMuc3Vic2NyaWJlZCkpIHtcbiAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVycik7XG4gICAgcmV0dXJuO1xuICB9XG4gIFxuICBpZiAoIXRoaXMud2FudFN1YnNjcmliZSAhPT0gIXZhbHVlKSB7XG4gICAgLy8gQ2FsbCBhbGwgdGhlIGN1cnJlbnQgc3Vic2NyaWJlL3Vuc3Vic2NyaWJlIGNhbGxiYWNrcy5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3N1YnNjcmliZUNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gU2hvdWxkIEkgcmV0dXJuIGFuIGVycm9yIGhlcmU/IFdoYXQgaGFwcGVuZWQgaXMgdGhlIHVzZXIgdW5zdWJjcmliZWRcbiAgICAgIC8vIHdpdGggYSBjYWxsYmFjayB0aGVuIHJlc3Vic2NyaWJlZCBzdHJhaWdodCBhZnRlci4gRG9lcyB0aGF0IG1lYW4gdGhlXG4gICAgICAvLyB1bnN1YnNjcmliZSBmYWlsZWQ/XG4gICAgICB0aGlzLl9zdWJzY3JpYmVDYWxsYmFja3NbaV0oZXJyKTtcbiAgICB9XG4gICAgdGhpcy5fc3Vic2NyaWJlQ2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gIH1cblxuICAvLyBJZiB3ZSB3YW50IHRvIHN1YnNjcmliZSwgZG9uJ3Qgd2Vha2VuIGl0IHRvIGEgZmV0Y2guXG4gIGlmICh2YWx1ZSAhPT0gJ2ZldGNoJyB8fCB0aGlzLndhbnRTdWJzY3JpYmUgIT09IHRydWUpXG4gICAgdGhpcy53YW50U3Vic2NyaWJlID0gdmFsdWU7XG5cbiAgaWYgKGNhbGxiYWNrKSB0aGlzLl9zdWJzY3JpYmVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gIHRoaXMuZmx1c2goKTtcbn07XG5cbi8vIE9wZW4gdGhlIGRvY3VtZW50LiBUaGVyZSBpcyBubyBjYWxsYmFjayBhbmQgbm8gZXJyb3IgaGFuZGxpbmcgaWYgeW91J3JlXG4vLyBhbHJlYWR5IGNvbm5lY3RlZC5cbi8vXG4vLyBPbmx5IGNhbGwgdGhpcyBvbmNlIHBlciBkb2N1bWVudC5cbkRvYy5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdGhpcy5fc2V0V2FudFN1YnNjcmliZSh0cnVlLCBjYWxsYmFjayk7XG59O1xuXG4vLyBVbnN1YnNjcmliZS4gVGhlIGRhdGEgd2lsbCBzdGF5IGFyb3VuZCBpbiBsb2NhbCBtZW1vcnksIGJ1dCB3ZSdsbCBzdG9wXG4vLyByZWNlaXZpbmcgdXBkYXRlcy5cbkRvYy5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB0aGlzLl9zZXRXYW50U3Vic2NyaWJlKGZhbHNlLCBjYWxsYmFjayk7XG59O1xuXG4vLyBDYWxsIHRvIHJlcXVlc3QgZnJlc2ggZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXG5Eb2MucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdGhpcy5fc2V0V2FudFN1YnNjcmliZSgnZmV0Y2gnLCBjYWxsYmFjayk7XG59O1xuXG4vLyBDYWxsZWQgd2hlbiBvdXIgc3Vic2NyaWJlLCBmZXRjaCBvciB1bnN1YnNjcmliZSBtZXNzYWdlcyBhcmUgYWNrbm93bGVkZ2VkLlxuRG9jLnByb3RvdHlwZS5fZmluaXNoU3ViID0gZnVuY3Rpb24odmFsdWUsIGVycm9yKSB7XG4gIGlmICh2YWx1ZSA9PT0gdGhpcy53YW50U3Vic2NyaWJlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zdWJzY3JpYmVDYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX3N1YnNjcmliZUNhbGxiYWNrc1tpXShlcnJvcik7XG4gICAgfVxuICAgIHRoaXMuX3N1YnNjcmliZUNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICB9XG59O1xuXG5cbi8vIE9wZXJhdGlvbnNcblxuXG4vLyAqKioqKioqKioqKiogRGVhbGluZyB3aXRoIG9wZXJhdGlvbnMuXG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBzZXQgb3BEYXRhIHRvIGNvbnRhaW4gYSBuby1vcC5cbnZhciBzZXROb09wID0gZnVuY3Rpb24ob3BEYXRhKSB7XG4gIGRlbGV0ZSBvcERhdGEub3A7XG4gIGRlbGV0ZSBvcERhdGEuY3JlYXRlO1xuICBkZWxldGUgb3BEYXRhLmRlbDtcbn07XG5cbnZhciBpc05vT3AgPSBmdW5jdGlvbihvcERhdGEpIHtcbiAgcmV0dXJuICFvcERhdGEub3AgJiYgIW9wRGF0YS5jcmVhdGUgJiYgIW9wRGF0YS5kZWw7XG59XG5cbi8vIFRyeSB0byBjb21wb3NlIGRhdGEyIGludG8gZGF0YTEuIFJldHVybnMgdHJ1dGh5IGlmIGl0IHN1Y2NlZWRzLCBvdGhlcndpc2UgZmFsc3kuXG52YXIgdHJ5Q29tcG9zZSA9IGZ1bmN0aW9uKHR5cGUsIGRhdGExLCBkYXRhMikge1xuICBpZiAoZGF0YTEuY3JlYXRlICYmIGRhdGEyLmRlbCkge1xuICAgIHNldE5vT3AoZGF0YTEpO1xuICB9IGVsc2UgaWYgKGRhdGExLmNyZWF0ZSAmJiBkYXRhMi5vcCkge1xuICAgIC8vIENvbXBvc2UgdGhlIGRhdGEgaW50byB0aGUgY3JlYXRlIGRhdGEuXG4gICAgdmFyIGRhdGEgPSAoZGF0YTEuY3JlYXRlLmRhdGEgPT09IHVuZGVmaW5lZCkgPyB0eXBlLmNyZWF0ZSgpIDogZGF0YTEuY3JlYXRlLmRhdGE7XG4gICAgZGF0YTEuY3JlYXRlLmRhdGEgPSB0eXBlLmFwcGx5KGRhdGEsIGRhdGEyLm9wKTtcbiAgfSBlbHNlIGlmIChpc05vT3AoZGF0YTEpKSB7XG4gICAgZGF0YTEuY3JlYXRlID0gZGF0YTIuY3JlYXRlO1xuICAgIGRhdGExLmRlbCA9IGRhdGEyLmRlbDtcbiAgICBkYXRhMS5vcCA9IGRhdGEyLm9wO1xuICB9IGVsc2UgaWYgKGRhdGExLm9wICYmIGRhdGEyLm9wICYmIHR5cGUuY29tcG9zZSkge1xuICAgIGRhdGExLm9wID0gdHlwZS5jb21wb3NlKGRhdGExLm9wLCBkYXRhMi5vcCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gVHJhbnNmb3JtIHNlcnZlciBvcCBkYXRhIGJ5IGEgY2xpZW50IG9wLCBhbmQgdmljZSB2ZXJzYS4gT3BzIGFyZSBlZGl0ZWQgaW4gcGxhY2UuXG52YXIgeGYgPSBmdW5jdGlvbihjbGllbnQsIHNlcnZlcikge1xuICAvLyBJbiB0aGlzIGNhc2UsIHdlJ3JlIGluIGZvciBzb21lIGZ1bi4gVGhlcmUgYXJlIHNvbWUgbG9jYWwgb3BlcmF0aW9uc1xuICAvLyB3aGljaCBhcmUgdG90YWxseSBpbnZhbGlkIC0gZWl0aGVyIHRoZSBjbGllbnQgY29udGludWVkIGVkaXRpbmcgYVxuICAvLyBkb2N1bWVudCB0aGF0IHNvbWVvbmUgZWxzZSBkZWxldGVkIG9yIGEgZG9jdW1lbnQgd2FzIGNyZWF0ZWQgYm90aCBvbiB0aGVcbiAgLy8gY2xpZW50IGFuZCBvbiB0aGUgc2VydmVyLiBJbiBlaXRoZXIgY2FzZSwgdGhlIGxvY2FsIGRvY3VtZW50IGlzIHdheVxuICAvLyBpbnZhbGlkIGFuZCB0aGUgY2xpZW50J3Mgb3BzIGFyZSB1c2VsZXNzLlxuICAvL1xuICAvLyBUaGUgY2xpZW50IGJlY29tZXMgYSBuby1vcCwgYW5kIHdlIGtlZXAgdGhlIHNlcnZlciBvcCBlbnRpcmVseS5cbiAgaWYgKHNlcnZlci5jcmVhdGUgfHwgc2VydmVyLmRlbCkgcmV0dXJuIHNldE5vT3AoY2xpZW50KTtcbiAgaWYgKGNsaWVudC5jcmVhdGUpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZS4gVGhpcyBpcyBhIGJ1Zy4nKTtcblxuICAvLyBUaGUgY2xpZW50IGhhcyBkZWxldGVkIHRoZSBkb2N1bWVudCB3aGlsZSB0aGUgc2VydmVyIGVkaXRlZCBpdC4gS2lsbCB0aGVcbiAgLy8gc2VydmVyJ3Mgb3AuXG4gIGlmIChjbGllbnQuZGVsKSByZXR1cm4gc2V0Tm9PcChzZXJ2ZXIpO1xuXG4gIC8vIFdlIG9ubHkgZ2V0IGhlcmUgaWYgZWl0aGVyIHRoZSBzZXJ2ZXIgb3IgY2xpZW50IG9wcyBhcmUgbm8tb3AuIENhcnJ5IG9uLFxuICAvLyBub3RoaW5nIHRvIHNlZSBoZXJlLlxuICBpZiAoIXNlcnZlci5vcCB8fCAhY2xpZW50Lm9wKSByZXR1cm47XG5cbiAgLy8gVGhleSBib3RoIGVkaXRlZCB0aGUgZG9jdW1lbnQuIFRoaXMgaXMgdGhlIG5vcm1hbCBjYXNlIGZvciB0aGlzIGZ1bmN0aW9uIC1cbiAgLy8gYXMgaW4sIG1vc3Qgb2YgdGhlIHRpbWUgd2UnbGwgZW5kIHVwIGRvd24gaGVyZS5cbiAgLy9cbiAgLy8gWW91IHNob3VsZCBiZSB3b25kZXJpbmcgd2h5IEknbSB1c2luZyBjbGllbnQudHlwZSBpbnN0ZWFkIG9mIHRoaXMudHlwZS5cbiAgLy8gVGhlIHJlYXNvbiBpcywgaWYgd2UgZ2V0IG9wcyBhdCBhbiBvbGQgdmVyc2lvbiBvZiB0aGUgZG9jdW1lbnQsIHRoaXMudHlwZVxuICAvLyBtaWdodCBiZSB1bmRlZmluZWQgb3IgYSB0b3RhbGx5IGRpZmZlcmVudCB0eXBlLiBCeSBwaW5uaW5nIHRoZSB0eXBlIHRvIHRoZVxuICAvLyBvcCBkYXRhLCB3ZSBtYWtlIHN1cmUgdGhlIHJpZ2h0IHR5cGUgaGFzIGl0cyB0cmFuc2Zvcm0gZnVuY3Rpb24gY2FsbGVkLlxuICBpZiAoY2xpZW50LnR5cGUudHJhbnNmb3JtWCkge1xuICAgIHZhciByZXN1bHQgPSBjbGllbnQudHlwZS50cmFuc2Zvcm1YKGNsaWVudC5vcCwgc2VydmVyLm9wKTtcbiAgICBjbGllbnQub3AgPSByZXN1bHRbMF07XG4gICAgc2VydmVyLm9wID0gcmVzdWx0WzFdO1xuICB9IGVsc2Uge1xuICAgIC8vY29uc29sZS5sb2coJ3hmJywgSlNPTi5zdHJpbmdpZnkoY2xpZW50Lm9wKSwgSlNPTi5zdHJpbmdpZnkoc2VydmVyLm9wKSk7XG4gICAgdmFyIF9jID0gY2xpZW50LnR5cGUudHJhbnNmb3JtKGNsaWVudC5vcCwgc2VydmVyLm9wLCAnbGVmdCcpO1xuICAgIHZhciBfcyA9IGNsaWVudC50eXBlLnRyYW5zZm9ybShzZXJ2ZXIub3AsIGNsaWVudC5vcCwgJ3JpZ2h0Jyk7XG4gICAgY2xpZW50Lm9wID0gX2M7IHNlcnZlci5vcCA9IF9zO1xuICAgIC8vY29uc29sZS5sb2coJy0+JywgSlNPTi5zdHJpbmdpZnkoY2xpZW50Lm9wKSwgSlNPTi5zdHJpbmdpZnkoc2VydmVyLm9wKSk7XG4gIH1cbn07XG5cbi8vIEludGVybmFsIG1ldGhvZCB0byBhY3R1YWxseSBhcHBseSB0aGUgZ2l2ZW4gb3AgZGF0YSB0byBvdXIgbG9jYWwgbW9kZWwuXG4vL1xuLy8gX2FmdGVyT3RBcHBseSgpIHNob3VsZCBhbHdheXMgYmUgY2FsbGVkIHN5bmNocm9ub3VzbHkgYWZ0ZXJ3YXJkcy5cbkRvYy5wcm90b3R5cGUuX290QXBwbHkgPSBmdW5jdGlvbihvcERhdGEsIGNvbnRleHQpIHtcbiAgLy8gTG9jayB0aGUgZG9jdW1lbnQuIE5vYm9keSBpcyBhbGxvd2VkIHRvIGNhbGwgc3VibWl0T3AoKSB1bnRpbCBfYWZ0ZXJPdEFwcGx5IGlzIGNhbGxlZC5cbiAgdGhpcy5sb2NrZWQgPSB0cnVlO1xuXG4gIGlmIChvcERhdGEuY3JlYXRlKSB7XG4gICAgLy8gSWYgdGhlIHR5cGUgaXMgY3VycmVudGx5IHNldCwgaXQgbWVhbnMgd2UgdHJpZWQgY3JlYXRpbmcgdGhlIGRvY3VtZW50XG4gICAgLy8gYW5kIHNvbWVvbmUgZWxzZSB3b24uIGNsaWVudCBjcmVhdGUgeCBzZXJ2ZXIgY3JlYXRlID0gc2VydmVyIGNyZWF0ZS5cbiAgICB2YXIgY3JlYXRlID0gb3BEYXRhLmNyZWF0ZTtcbiAgICB0aGlzLl9zZXRUeXBlKGNyZWF0ZS50eXBlKTtcbiAgICB0aGlzLnNuYXBzaG90ID0gdGhpcy50eXBlLmNyZWF0ZShjcmVhdGUuZGF0YSk7XG5cbiAgICAvLyBUaGlzIGlzIGEgYml0IGhlYXZ5d2VpZ2h0LCBidXQgSSB3YW50IHRoZSBjcmVhdGVkIGV2ZW50IHRvIGZpcmUgb3V0c2lkZSBvZiB0aGUgbG9jay5cbiAgICB0aGlzLm9uY2UoJ3VubG9jaycsIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5lbWl0KCdjcmVhdGUnLCBjb250ZXh0KTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChvcERhdGEuZGVsKSB7XG4gICAgLy8gVGhlIHR5cGUgc2hvdWxkIGFsd2F5cyBleGlzdCBpbiB0aGlzIGNhc2UuIGRlbCB4IF8gPSBkZWxcbiAgICB2YXIgb2xkU25hcHNob3QgPSB0aGlzLnNuYXBzaG90O1xuICAgIHRoaXMuX3NldFR5cGUobnVsbCk7XG4gICAgdGhpcy5vbmNlKCd1bmxvY2snLCBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZW1pdCgnZGVsJywgY29udGV4dCwgb2xkU25hcHNob3QpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKG9wRGF0YS5vcCkge1xuICAgIGlmICghdGhpcy50eXBlKSB0aHJvdyBuZXcgRXJyb3IoJ0RvY3VtZW50IGRvZXMgbm90IGV4aXN0Jyk7XG5cbiAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuICAgIHZhciBvcCA9IG9wRGF0YS5vcDtcbiAgICBcbiAgICAvLyBUaGUgY29udGV4dCBuZWVkcyB0byBiZSB0b2xkIHdlJ3JlIGFib3V0IHRvIGVkaXQsIGp1c3QgaW4gY2FzZSBpdCBuZWVkc1xuICAgIC8vIHRvIHN0b3JlIGFueSBleHRyYSBkYXRhLiAodGV4dC10cDIgaGFzIHRoaXMgY29uc3RyYWludC4pXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVkaXRpbmdDb250ZXh0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSB0aGlzLmVkaXRpbmdDb250ZXh0c1tpXTtcbiAgICAgIGlmIChjICE9IGNvbnRleHQgJiYgYy5fYmVmb3JlT3ApIGMuX2JlZm9yZU9wKG9wRGF0YS5vcCk7XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KCdiZWZvcmUgb3AnLCBvcCwgY29udGV4dCk7XG5cbiAgICAvLyBUaGlzIGV4aXN0cyBzbyBjbGllbnRzIGNhbiBwdWxsIGFueSBuZWNlc3NhcnkgZGF0YSBvdXQgb2YgdGhlIHNuYXBzaG90XG4gICAgLy8gYmVmb3JlIGl0IGdldHMgY2hhbmdlZC4gIFByZXZpb3VzbHkgd2Uga2VwdCB0aGUgb2xkIHNuYXBzaG90IG9iamVjdCBhbmRcbiAgICAvLyBwYXNzZWQgaXQgdG8gdGhlIG9wIGV2ZW50IGhhbmRsZXIuIEhvd2V2ZXIsIGFwcGx5IG5vIGxvbmdlciBndWFyYW50ZWVzXG4gICAgLy8gdGhlIG9sZCBvYmplY3QgaXMgc3RpbGwgdmFsaWQuXG4gICAgLy9cbiAgICAvLyBCZWNhdXNlIHRoaXMgY291bGQgYmUgdG90YWxseSB1bm5lY2Vzc2FyeSB3b3JrLCBpdHMgYmVoaW5kIGEgZmxhZy4gc2V0XG4gICAgLy8gZG9jLmluY3JlbWVudGFsIHRvIGVuYWJsZS5cbiAgICBpZiAodGhpcy5pbmNyZW1lbnRhbCAmJiB0eXBlLmluY3JlbWVudGFsQXBwbHkpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB0eXBlLmluY3JlbWVudGFsQXBwbHkodGhpcy5zbmFwc2hvdCwgb3AsIGZ1bmN0aW9uKG8sIHNuYXBzaG90KSB7XG4gICAgICAgIF90aGlzLnNuYXBzaG90ID0gc25hcHNob3Q7XG4gICAgICAgIF90aGlzLmVtaXQoJ29wJywgbywgY29udGV4dCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyB0aGUgbW9zdCBjb21tb24gY2FzZSwgc2ltcGx5IGFwcGx5aW5nIHRoZSBvcGVyYXRpb24gdG8gdGhlIGxvY2FsIHNuYXBzaG90LlxuICAgICAgdGhpcy5zbmFwc2hvdCA9IHR5cGUuYXBwbHkodGhpcy5zbmFwc2hvdCwgb3ApO1xuICAgICAgdGhpcy5lbWl0KCdvcCcsIG9wLCBjb250ZXh0KTtcbiAgICB9XG4gIH1cbiAgLy8gSXRzIHBvc3NpYmxlIGZvciBub25lIG9mIHRoZSBhYm92ZSBjYXNlcyB0byBtYXRjaCwgaW4gd2hpY2ggY2FzZSB0aGUgb3AgaXNcbiAgLy8gYSBuby1vcC4gVGhpcyB3aWxsIGhhcHBlbiB3aGVuIGEgZG9jdW1lbnQgaGFzIGJlZW4gZGVsZXRlZCBsb2NhbGx5IGFuZFxuICAvLyByZW1vdGUgb3BzIGVkaXQgdGhlIGRvY3VtZW50LlxufTtcblxuLy8gVGhpcyBzaG91bGQgYmUgY2FsbGVkIHJpZ2h0IGFmdGVyIF9vdEFwcGx5LlxuRG9jLnByb3RvdHlwZS5fYWZ0ZXJPdEFwcGx5ID0gZnVuY3Rpb24ob3BEYXRhLCBjb250ZXh0KSB7XG4gIHRoaXMubG9ja2VkID0gZmFsc2U7XG4gIHRoaXMuZW1pdCgndW5sb2NrJyk7XG4gIGlmIChvcERhdGEub3ApIHtcbiAgICB2YXIgY29udGV4dHMgPSB0aGlzLmVkaXRpbmdDb250ZXh0cztcbiAgICAvLyBOb3RpZnkgYWxsIHRoZSBjb250ZXh0cyBhYm91dCB0aGUgb3AgKHdlbGwsIGFsbCB0aGUgY29udGV4dHMgZXhjZXB0XG4gICAgLy8gdGhlIG9uZSB3aGljaCBpbml0aWF0ZWQgdGhlIHN1Ym1pdCBpbiB0aGUgZmlyc3QgcGxhY2UpLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGV4dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gY29udGV4dHNbaV07XG4gICAgICBpZiAoYyAhPSBjb250ZXh0ICYmIGMuX29uT3ApIGMuX29uT3Aob3BEYXRhLm9wKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZXh0cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGNvbnRleHRzLnJlbW92ZSkgY29udGV4dHMuc3BsaWNlKGktLSwgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnYWZ0ZXIgb3AnLCBvcERhdGEub3AsIGNvbnRleHQpO1xuICB9XG59O1xuXG5cblxuLy8gKioqKiogU2VuZGluZyBvcGVyYXRpb25zXG5cblxuLy8gQWN0dWFsbHkgc2VuZCBvcCBkYXRhIHRvIHRoZSBzZXJ2ZXIuXG5Eb2MucHJvdG90eXBlLl9zZW5kT3BEYXRhID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkID0gdGhpcy5pbmZsaWdodERhdGE7XG5cbiAgaWYgKHRoaXMuYWN0aW9uKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc3RhdGUgJyArIHRoaXMuYWN0aW9uICsgJyBmb3Igc2VuZE9wRGF0YScpO1xuICB0aGlzLmFjdGlvbiA9ICdzdWJtaXQnO1xuXG4gIHZhciBtc2cgPSB7YTonb3AnLCB2OnRoaXMudmVyc2lvbn07XG4gIGlmIChkLnNyYykge1xuICAgIG1zZy5zcmMgPSBkLnNyYztcbiAgICBtc2cuc2VxID0gZC5zZXE7XG4gIH1cblxuICAvLyBUaGUgc2VydmVyIGF1dG9kZXRlY3RzIHRoaXMuXG4gIC8vaWYgKHRoaXMuc3RhdGUgPT09ICd1bnN1YnNjcmliZWQnKSBtc2cuZiA9IHRydWU7IC8vIGZldGNoIGludGVybWVkaWF0ZSBvcHNcblxuICBpZiAoZC5vcCkgbXNnLm9wID0gZC5vcDtcbiAgaWYgKGQuY3JlYXRlKSBtc2cuY3JlYXRlID0gZC5jcmVhdGU7XG4gIGlmIChkLmRlbCkgbXNnLmRlbCA9IGQuZGVsO1xuXG4gIG1zZy5jID0gdGhpcy5jb2xsZWN0aW9uO1xuICBtc2cuZCA9IHRoaXMubmFtZTtcblxuICB0aGlzLmNvbm5lY3Rpb24uc2VuZE9wKG1zZyk7XG4gICBcbiAgLy8gVGhlIGZpcnN0IHRpbWUgd2Ugc2VuZCBhbiBvcCwgaXRzIGlkIGFuZCBzZXF1ZW5jZSBudW1iZXIgaXMgaW1wbGljaXQuXG4gIGlmICghZC5zcmMpIHtcbiAgICBkLnNyYyA9IHRoaXMuY29ubmVjdGlvbi5pZDtcbiAgICBkLnNlcSA9IHRoaXMuY29ubmVjdGlvbi5zZXErKztcbiAgfVxufTtcblxuXG4vLyBJbnRlcm5hbCBtZXRob2QgY2FsbGVkIHRvIGRvIHRoZSBhY3R1YWwgd29yayBmb3Igc3VibWl0T3AoKSwgY3JlYXRlKCkgYW5kIGRlbCgpLlxuLy9cbi8vIGNvbnRleHQgaXMgb3B0aW9uYWwuXG5Eb2MucHJvdG90eXBlLl9zdWJtaXRPcERhdGEgPSBmdW5jdGlvbihvcERhdGEsIGNvbnRleHQsIGNhbGxiYWNrKSB7XG4gIC8vY29uc29sZS5sb2coJ3N1Ym1pdCcsIEpTT04uc3RyaW5naWZ5KG9wRGF0YSksICd2PScsIHRoaXMudmVyc2lvbik7XG5cbiAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBjb250ZXh0O1xuICAgIGNvbnRleHQgPSB0cnVlOyAvLyBUaGUgZGVmYXVsdCBjb250ZXh0IGlzIHRydWUuXG4gIH1cbiAgaWYgKGNvbnRleHQgPT0gbnVsbCkgY29udGV4dCA9IHRydWU7XG5cbiAgdmFyIGVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIpO1xuICAgIGVsc2UgaWYgKGNvbnNvbGUpIGNvbnNvbGUud2FybignRmFpbGVkIGF0dGVtcHQgdG8gc3VibWl0T3A6JywgZXJyKTtcbiAgfTtcblxuICBpZiAodGhpcy5sb2NrZWQpIHtcbiAgICByZXR1cm4gZXJyb3IoXCJDYW5ub3QgY2FsbCBzdWJtaXRPcCBmcm9tIGluc2lkZSBhbiAnb3AnIGV2ZW50IGhhbmRsZXJcIik7XG4gIH1cblxuICAvLyBUaGUgb3BEYXRhIGNvbnRhaW5zIGVpdGhlciBvcCwgY3JlYXRlLCBkZWxldGUsIG9yIG5vbmUgb2YgdGhlIGFib3ZlIChhIG5vLW9wKS5cblxuICBpZiAob3BEYXRhLm9wKSB7XG4gICAgaWYgKCF0aGlzLnR5cGUpIHJldHVybiBlcnJvcignRG9jdW1lbnQgaGFzIG5vdCBiZWVuIGNyZWF0ZWQnKTtcblxuICAgIC8vIFRyeSB0byBub3JtYWxpemUgdGhlIG9wLiBUaGlzIHJlbW92ZXMgdHJhaWxpbmcgc2tpcDowJ3MgYW5kIHRoaW5ncyBsaWtlIHRoYXQuXG4gICAgaWYgKHRoaXMudHlwZS5ub3JtYWxpemUpIG9wRGF0YS5vcCA9IHRoaXMudHlwZS5ub3JtYWxpemUob3BEYXRhLm9wKTtcbiAgfVxuXG4gIGlmICghdGhpcy5zdGF0ZSkge1xuICAgIHRoaXMuc3RhdGUgPSAnZmxvYXRpbmcnO1xuICB9XG5cbiAgLy8gQWN0dWFsbHkgYXBwbHkgdGhlIG9wZXJhdGlvbiBsb2NhbGx5LlxuICB0aGlzLl9vdEFwcGx5KG9wRGF0YSwgY29udGV4dCk7XG5cbiAgLy8gSWYgdGhlIHR5cGUgc3VwcG9ydHMgY29tcG9zZXMsIHRyeSB0byBjb21wb3NlIHRoZSBvcGVyYXRpb24gb250byB0aGUgZW5kXG4gIC8vIG9mIHRoZSBsYXN0IHBlbmRpbmcgb3BlcmF0aW9uLlxuICB2YXIgZW50cnkgPSB0aGlzLnBlbmRpbmdEYXRhW3RoaXMucGVuZGluZ0RhdGEubGVuZ3RoIC0gMV07XG5cbiAgaWYgKHRoaXMucGVuZGluZ0RhdGEubGVuZ3RoICYmXG4gICAgICAoZW50cnkgPSB0aGlzLnBlbmRpbmdEYXRhW3RoaXMucGVuZGluZ0RhdGEubGVuZ3RoIC0gMV0sXG4gICAgICAgdHJ5Q29tcG9zZSh0aGlzLnR5cGUsIGVudHJ5LCBvcERhdGEpKSkge1xuICB9IGVsc2Uge1xuICAgIGVudHJ5ID0gb3BEYXRhO1xuICAgIG9wRGF0YS50eXBlID0gdGhpcy50eXBlO1xuICAgIG9wRGF0YS5jYWxsYmFja3MgPSBbXTtcbiAgICB0aGlzLnBlbmRpbmdEYXRhLnB1c2gob3BEYXRhKTtcbiAgfVxuXG4gIGlmIChjYWxsYmFjaykgZW50cnkuY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXG4gIHRoaXMuX2FmdGVyT3RBcHBseShvcERhdGEsIGNvbnRleHQpO1xuXG4gIC8vIFRoZSBjYWxsIHRvIGZsdXNoIGlzIGluIGEgdGltZW91dCBzbyBpZiBzdWJtaXRPcCgpIGlzIGNhbGxlZCBtdWx0aXBsZVxuICAvLyB0aW1lcyBpbiBhIGNsb3N1cmUgYWxsIHRoZSBvcHMgYXJlIGNvbWJpbmVkIGJlZm9yZSBiZWluZyBzZW50IHRvIHRoZVxuICAvLyBzZXJ2ZXIuIEl0IGRvZXNuJ3QgbWF0dGVyIGlmIGZsdXNoIGlzIGNhbGxlZCBhIGJ1bmNoIG9mIHRpbWVzLlxuICB2YXIgX3RoaXMgPSB0aGlzO1xuICBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHsgX3RoaXMuZmx1c2goKTsgfSksIDApO1xufTtcblxuXG4vLyAqKiogQ2xpZW50IE9UIGVudHJ5cG9pbnRzLlxuXG4vLyBTdWJtaXQgYW4gb3BlcmF0aW9uIHRvIHRoZSBkb2N1bWVudC4gVGhlIG9wIG11c3QgYmUgdmFsaWQgZ2l2ZW4gdGhlIGN1cnJlbnQgT1QgdHlwZS5cbkRvYy5wcm90b3R5cGUuc3VibWl0T3AgPSBmdW5jdGlvbihvcCwgY29udGV4dCwgY2FsbGJhY2spIHtcbiAgdGhpcy5fc3VibWl0T3BEYXRhKHtvcDogb3B9LCBjb250ZXh0LCBjYWxsYmFjayk7XG59O1xuXG4vLyBDcmVhdGUgdGhlIGRvY3VtZW50LCB3aGljaCBpbiBTaGFyZUpTIHNlbWFudGljcyBtZWFucyB0byBzZXQgaXRzIHR5cGUuIEV2ZXJ5XG4vLyBvYmplY3QgaW1wbGljaXRseSBleGlzdHMgaW4gdGhlIGRhdGFiYXNlIGJ1dCBoYXMgbm8gZGF0YSBhbmQgbm8gdHlwZS4gQ3JlYXRlXG4vLyBzZXRzIHRoZSB0eXBlIG9mIHRoZSBvYmplY3QgYW5kIGNhbiBvcHRpb25hbGx5IHNldCBzb21lIGluaXRpYWwgZGF0YSBvbiB0aGVcbi8vIG9iamVjdCwgZGVwZW5kaW5nIG9uIHRoZSB0eXBlLlxuRG9jLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbih0eXBlLCBkYXRhLCBjb250ZXh0LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBTZXR0aW5nIHRoZSBjb250ZXh0IHRvIGJlIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpbiB0aGlzIGNhc2Ugc28gX3N1Ym1pdE9wRGF0YVxuICAgIC8vIGNhbiBoYW5kbGUgdGhlIGRlZmF1bHQgdmFsdWUgdGhpbmcuXG4gICAgY29udGV4dCA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodGhpcy50eXBlKSB7XG4gICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygnRG9jdW1lbnQgYWxyZWFkeSBleGlzdHMnKTtcbiAgICByZXR1cm4gXG4gIH1cblxuICB0aGlzLl9zdWJtaXRPcERhdGEoe2NyZWF0ZToge3R5cGU6dHlwZSwgZGF0YTpkYXRhfX0sIGNvbnRleHQsIGNhbGxiYWNrKTtcbn07XG5cbi8vIERlbGV0ZSB0aGUgZG9jdW1lbnQuIFRoaXMgY3JlYXRlcyBhbmQgc3VibWl0cyBhIGRlbGV0ZSBvcGVyYXRpb24gdG8gdGhlXG4vLyBzZXJ2ZXIuIERlbGV0aW5nIHJlc2V0cyB0aGUgb2JqZWN0J3MgdHlwZSB0byBudWxsIGFuZCBkZWxldGVzIGl0cyBkYXRhLiBUaGVcbi8vIGRvY3VtZW50IHN0aWxsIGV4aXN0cywgYW5kIHN0aWxsIGhhcyB0aGUgdmVyc2lvbiBpdCB1c2VkIHRvIGhhdmUgYmVmb3JlIHlvdVxuLy8gZGVsZXRlZCBpdCAod2VsbCwgb2xkIHZlcnNpb24gKzEpLlxuRG9jLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbihjb250ZXh0LCBjYWxsYmFjaykge1xuICBpZiAoIXRoaXMudHlwZSkge1xuICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soJ0RvY3VtZW50IGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fc3VibWl0T3BEYXRhKHtkZWw6IHRydWV9LCBjb250ZXh0LCBjYWxsYmFjayk7XG59O1xuXG5cbi8vIFBhdXNpbmcgc3RvcHMgdGhlIGRvY3VtZW50IGZyb20gc2VuZGluZyBhbnkgb3BlcmF0aW9ucyB0byB0aGUgc2VydmVyLlxuRG9jLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnBhdXNlZCA9IHRydWU7XG59O1xuXG5Eb2MucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuICB0aGlzLmZsdXNoKCk7XG59O1xuXG5cbi8vICoqKiBSZWNlaXZpbmcgb3BlcmF0aW9uc1xuXG5cbi8vIFRoaXMgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgc2VydmVyIHJlamVjdHMgb3VyIG9wZXJhdGlvbnMgZm9yIHNvbWUgcmVhc29uLlxuLy8gVGhlcmUncyBub3QgbXVjaCB3ZSBjYW4gZG8gaGVyZSBpZiB0aGUgT1QgdHlwZSBpcyBub25pbnZlcnRhYmxlLCBidXQgdGhhdFxuLy8gc2hvdWxkbid0IGhhcHBlbiB0b28gbXVjaCBpbiByZWFsIGxpZmUgYmVjYXVzZSByZWFkb25seSBkb2N1bWVudHMgc2hvdWxkIGJlXG4vLyBmbGFnZ2VkIGFzIHN1Y2guIChJIHNob3VsZCBwcm9iYWJseSBmaWd1cmUgb3V0IGEgZmxhZyBmb3IgdGhhdCkuXG4vL1xuLy8gVGhpcyBkb2VzIE5PVCBnZXQgY2FsbGVkIGlmIG91ciBvcCBmYWlscyB0byByZWFjaCB0aGUgc2VydmVyIGZvciBzb21lIHJlYXNvblxuLy8gLSB3ZSBvcHRpbWlzdGljYWxseSBhc3N1bWUgaXQnbGwgbWFrZSBpdCB0aGVyZSBldmVudHVhbGx5LlxuRG9jLnByb3RvdHlwZS5fdHJ5Um9sbGJhY2sgPSBmdW5jdGlvbihvcERhdGEpIHtcbiAgLy8gVGhpcyBpcyBwcm9iYWJseSBob3JyaWJseSBicm9rZW4uXG4gIGlmIChvcERhdGEuY3JlYXRlKSB7XG4gICAgdGhpcy5fc2V0VHlwZShudWxsKTtcblxuICAgIC8vIEkgZG9uJ3QgdGhpbmsgaXRzIHBvc3NpYmxlIHRvIGdldCBoZXJlIGlmIHdlIGFyZW4ndCBpbiBhIGZsb2F0aW5nIHN0YXRlLlxuICAgIGlmICh0aGlzLnN0YXRlID09PSAnZmxvYXRpbmcnKVxuICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgZWxzZVxuICAgICAgY29uc29sZS53YXJuKCdSb2xsYmFjayBhIGNyZWF0ZSBmcm9tIHN0YXRlICcgKyB0aGlzLnN0YXRlKTtcblxuICB9IGVsc2UgaWYgKG9wRGF0YS5vcCAmJiBvcERhdGEudHlwZS5pbnZlcnQpIHtcbiAgICBvcERhdGEub3AgPSBvcERhdGEudHlwZS5pbnZlcnQob3BEYXRhLm9wKTtcblxuICAgIC8vIFRyYW5zZm9ybSB0aGUgdW5kbyBvcGVyYXRpb24gYnkgYW55IHBlbmRpbmcgb3BzLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wZW5kaW5nRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgeGYodGhpcy5wZW5kaW5nRGF0YVtpXSwgb3BEYXRhKTtcbiAgICB9XG5cbiAgICAvLyAuLi4gYW5kIGFwcGx5IGl0IGxvY2FsbHksIHJldmVydGluZyB0aGUgY2hhbmdlcy5cbiAgICAvLyBcbiAgICAvLyBUaGlzIG9wZXJhdGlvbiBpcyBhcHBsaWVkIHRvIGxvb2sgbGlrZSBpdCBjb21lcyBmcm9tIGEgcmVtb3RlIGNvbnRleHQuXG4gICAgLy8gSSdtIHN0aWxsIG5vdCAxMDAlIHN1cmUgYWJvdXQgdGhpcyBmdW5jdGlvbmFsaXR5LCBiZWNhdXNlIGl0cyByZWFsbHkgYVxuICAgIC8vIGxvY2FsIG9wLiBCYXNpY2FsbHksIHRoZSBwcm9ibGVtIGlzIHRoYXQgaWYgdGhlIGNsaWVudCdzIG9wIGlzIHJlamVjdGVkXG4gICAgLy8gYnkgdGhlIHNlcnZlciwgdGhlIGVkaXRvciB3aW5kb3cgc2hvdWxkIHVwZGF0ZSB0byByZWZsZWN0IHRoZSB1bmRvLlxuICAgIHRoaXMuX290QXBwbHkob3BEYXRhLCBmYWxzZSk7XG4gICAgdGhpcy5fYWZ0ZXJPdEFwcGx5KG9wRGF0YSwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKG9wRGF0YS5vcCB8fCBvcERhdGEuZGVsKSB7XG4gICAgLy8gVGhpcyBpcyB3aGVyZSBhbiB1bmRvIHN0YWNrIHdvdWxkIGNvbWUgaW4gaGFuZHkuXG4gICAgdGhpcy5fc2V0VHlwZShudWxsKTtcbiAgICB0aGlzLnZlcnNpb24gPSBudWxsO1xuICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgIHRoaXMuc3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBcIk9wIGFwcGx5IGZhaWxlZCBhbmQgdGhlIG9wZXJhdGlvbiBjb3VsZCBub3QgYmUgcmV2ZXJ0ZWRcIik7XG5cbiAgICAvLyBUcmlnZ2VyIGEgZmV0Y2guIEluIG91ciBpbnZhbGlkIHN0YXRlLCB3ZSBjYW4ndCByZWFsbHkgZG8gYW55dGhpbmcuXG4gICAgdGhpcy5mZXRjaCgpO1xuICAgIHRoaXMuZmx1c2goKTtcbiAgfVxufTtcblxuRG9jLnByb3RvdHlwZS5fY2xlYXJJbmZsaWdodE9wID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuaW5mbGlnaHREYXRhLmNhbGxiYWNrcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICBjYWxsYmFja3NbaV0oZXJyb3IgfHwgdGhpcy5pbmZsaWdodERhdGEuZXJyb3IpO1xuICB9XG5cbiAgdGhpcy5pbmZsaWdodERhdGEgPSBudWxsO1xuICB0aGlzLl9jbGVhckFjdGlvbignc3VibWl0Jyk7XG5cbiAgaWYgKCF0aGlzLnBlbmRpbmdEYXRhLmxlbmd0aCkge1xuICAgIC8vIFRoaXMgaXNuJ3QgYSB2ZXJ5IGdvb2QgbmFtZS5cbiAgICB0aGlzLmVtaXQoJ25vdGhpbmcgcGVuZGluZycpO1xuICB9XG59O1xuXG4vLyBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBzZXJ2ZXIgYWNrbm93bGVkZ2VzIGFuIG9wZXJhdGlvbiBmcm9tIHRoZSBjbGllbnQuXG5Eb2MucHJvdG90eXBlLl9vcEFja25vd2xlZGdlZCA9IGZ1bmN0aW9uKG1zZykge1xuICAvLyBPdXIgaW5mbGlnaHQgb3AgaGFzIGJlZW4gYWNrbm93bGVkZ2VkLCBzbyB3ZSBjYW4gdGhyb3cgYXdheSB0aGUgaW5mbGlnaHQgZGF0YS5cbiAgLy8gKFdlIHdlcmUgb25seSBob2xkaW5nIG9uIHRvIGl0IGluY2FzZSB3ZSBuZWVkZWQgdG8gcmVzZW5kIHRoZSBvcC4pXG4gIGlmICghdGhpcy5zdGF0ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignb3BBY2tub3dsZWRnZWQgY2FsbGVkIGZyb20gYSBudWxsIHN0YXRlLiBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uJyk7XG4gIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gJ2Zsb2F0aW5nJykge1xuICAgIGlmICghdGhpcy5pbmZsaWdodERhdGEuY3JlYXRlKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhY2tub3dsZWRnZSBhbiBvcC4nKTtcblxuICAgIC8vIE91ciBjcmVhdGUgaGFzIGJlZW4gYWNrbm93bGVkZ2VkLiBUaGlzIGlzIHRoZSBzYW1lIGFzIGluamVzdGluZyBzb21lIGRhdGEuXG4gICAgdGhpcy52ZXJzaW9uID0gbXNnLnY7XG4gICAgdGhpcy5zdGF0ZSA9ICdyZWFkeSc7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBfdGhpcy5lbWl0KCdyZWFkeScpOyB9LCAwKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBhbHJlYWR5IGhhdmUgYSBzbmFwc2hvdC4gVGhlIHNuYXBzaG90IHNob3VsZCBiZSBhdCB0aGUgYWNrbm93bGVkZ2VkXG4gICAgLy8gdmVyc2lvbiwgYmVjYXVzZSB0aGUgc2VydmVyIGhhcyBzZW50IHVzIGFsbCB0aGUgb3BzIHRoYXQgaGF2ZSBoYXBwZW5lZFxuICAgIC8vIGJlZm9yZSBhY2tub3dsZWRnaW5nIG91ciBvcC5cblxuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiAtIHNvbWV0aGluZyBpcyBvdXQgb2Ygb3JkZXIuXG4gICAgaWYgKG1zZy52ICE9PSB0aGlzLnZlcnNpb24pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmVyc2lvbiBmcm9tIHNlcnZlci4gVGhpcyBjYW4gaGFwcGVuIHdoZW4geW91IHN1Ym1pdCBvcHMgaW4gYSBzdWJtaXRPcCBjYWxsYmFjay4nKTtcbiAgfVxuICBcbiAgLy8gVGhlIG9wIHdhcyBjb21taXR0ZWQgc3VjY2Vzc2Z1bGx5LiBJbmNyZW1lbnQgdGhlIHZlcnNpb24gbnVtYmVyXG4gIHRoaXMudmVyc2lvbisrO1xuXG4gIHRoaXMuX2NsZWFySW5mbGlnaHRPcCgpO1xufTtcblxuXG4vLyBBUEkgQ29udGV4dHNcblxuLy8gVGhpcyBjcmVhdGVzIGFuZCByZXR1cm5zIGFuIGVkaXRpbmcgY29udGV4dCB1c2luZyB0aGUgY3VycmVudCBPVCB0eXBlLlxuRG9jLnByb3RvdHlwZS5jcmVhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0eXBlID0gdGhpcy50eXBlO1xuICBpZiAoIXR5cGUpIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB0eXBlJyk7XG5cbiAgLy8gSSBjb3VsZCB1c2UgdGhlIHByb3RvdHlwZSBjaGFpbiB0byBkbyB0aGlzIGluc3RlYWQsIGJ1dCBPYmplY3QuY3JlYXRlXG4gIC8vIGlzbid0IGRlZmluZWQgb24gb2xkIGJyb3dzZXJzLiBUaGlzIHdpbGwgYmUgZmluZS5cbiAgdmFyIGRvYyA9IHRoaXM7XG4gIHZhciBjb250ZXh0ID0ge1xuICAgIGdldFNuYXBzaG90OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkb2Muc25hcHNob3Q7XG4gICAgfSxcbiAgICBzdWJtaXRPcDogZnVuY3Rpb24ob3AsIGNhbGxiYWNrKSB7XG4gICAgICBkb2Muc3VibWl0T3Aob3AsIGNvbnRleHQsIGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZGV0YWNoKSB7XG4gICAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgICAgIC8vIERvbid0IGRvdWJsZS1kZXRhY2guXG4gICAgICAgIGRlbGV0ZSB0aGlzLmRldGFjaDtcbiAgICAgIH1cbiAgICAgIC8vIEl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBhY3R1YWwgZWRpdGluZ0NvbnRleHRzIGxpc3QgbmV4dCB0aW1lXG4gICAgICAvLyB3ZSByZWNlaXZlIGFuIG9wIG9uIHRoZSBkb2N1bWVudCAoYW5kIHRoZSBsaXN0IGlzIGl0ZXJhdGVkIHRocm91Z2gpLlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgaXMgcG90ZW50aWFsbHkgZG9kZ3ksIGFsbG93aW5nIGEgbWVtb3J5IGxlYWsgaWYgeW91IGNyZWF0ZSAmXG4gICAgICAvLyBkZXN0cm95IGEgd2hvbGUgYnVuY2ggb2YgY29udGV4dHMgd2l0aG91dCByZWNlaXZpbmcgb3Igc2VuZGluZyBhbnkgb3BzXG4gICAgICAvLyB0byB0aGUgZG9jdW1lbnQuXG4gICAgICBkZWxldGUgdGhpcy5fb25PcDtcbiAgICAgIHRoaXMucmVtb3ZlID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLy8gVGhpcyBpcyBkYW5nZXJvdXMsIGJ1dCByZWFsbHkgcmVhbGx5IHVzZWZ1bCBmb3IgZGVidWdnaW5nLiBJIGhvcGUgcGVvcGxlXG4gICAgLy8gZG9uJ3QgZGVwZW5kIG9uIGl0LlxuICAgIF9kb2M6IHRoaXMsXG4gIH07XG5cbiAgaWYgKHR5cGUuYXBpKSB7XG4gICAgLy8gQ29weSBldmVyeXRoaW5nIGVsc2UgZnJvbSB0aGUgdHlwZSdzIEFQSSBpbnRvIHRoZSBlZGl0aW5nIGNvbnRleHQuXG4gICAgZm9yICh2YXIgayBpbiB0eXBlLmFwaSkge1xuICAgICAgY29udGV4dFtrXSA9IHR5cGUuYXBpW2tdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LnByb3ZpZGVzID0ge307XG4gIH1cblxuICB0aGlzLmVkaXRpbmdDb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuXG4gIHJldHVybiBjb250ZXh0O1xufTtcblxuRG9jLnByb3RvdHlwZS5yZW1vdmVDb250ZXh0cyA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZWRpdGluZ0NvbnRleHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5lZGl0aW5nQ29udGV4dHNbaV0uZGVzdHJveSgpO1xuICB9XG4gIHRoaXMuZWRpdGluZ0NvbnRleHRzLmxlbmd0aCA9IDA7XG59O1xuXG4iLCJ2YXIgc2hhID0gcmVxdWlyZSgnLi9zaGEnKVxudmFyIHJuZyA9IHJlcXVpcmUoJy4vcm5nJylcbnZhciBtZDUgPSByZXF1aXJlKCcuL21kNScpXG5cbnZhciBhbGdvcml0aG1zID0ge1xuICBzaGExOiB7XG4gICAgaGV4OiBzaGEuaGV4X3NoYTEsXG4gICAgYmluYXJ5OiBzaGEuYjY0X3NoYTEsXG4gICAgYXNjaWk6IHNoYS5zdHJfc2hhMVxuICB9LFxuICBtZDU6IHtcbiAgICBoZXg6IG1kNS5oZXhfbWQ1LFxuICAgIGJpbmFyeTogbWQ1LmI2NF9tZDUsXG4gICAgYXNjaWk6IG1kNS5hbnlfbWQ1XG4gIH1cbn1cblxuZnVuY3Rpb24gZXJyb3IgKCkge1xuICB2YXIgbSA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKCcgJylcbiAgdGhyb3cgbmV3IEVycm9yKFtcbiAgICBtLFxuICAgICd3ZSBhY2NlcHQgcHVsbCByZXF1ZXN0cycsXG4gICAgJ2h0dHA6Ly9naXRodWIuY29tL2RvbWluaWN0YXJyL2NyeXB0by1icm93c2VyaWZ5J1xuICAgIF0uam9pbignXFxuJykpXG59XG5cbmV4cG9ydHMuY3JlYXRlSGFzaCA9IGZ1bmN0aW9uIChhbGcpIHtcbiAgYWxnID0gYWxnIHx8ICdzaGExJ1xuICBpZighYWxnb3JpdGhtc1thbGddKVxuICAgIGVycm9yKCdhbGdvcml0aG06JywgYWxnLCAnaXMgbm90IHlldCBzdXBwb3J0ZWQnKVxuICB2YXIgcyA9ICcnXG4gIHZhciBfYWxnID0gYWxnb3JpdGhtc1thbGddXG4gIHJldHVybiB7XG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgcyArPSBkYXRhXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgZGlnZXN0OiBmdW5jdGlvbiAoZW5jKSB7XG4gICAgICBlbmMgPSBlbmMgfHwgJ2JpbmFyeSdcbiAgICAgIHZhciBmblxuICAgICAgaWYoIShmbiA9IF9hbGdbZW5jXSkpXG4gICAgICAgIGVycm9yKCdlbmNvZGluZzonLCBlbmMgLCAnaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIGFsZ29yaXRobScsIGFsZylcbiAgICAgIHZhciByID0gZm4ocylcbiAgICAgIHMgPSBudWxsIC8vbm90IG1lYW50IHRvIHVzZSB0aGUgaGFzaCBhZnRlciB5b3UndmUgY2FsbGVkIGRpZ2VzdC5cbiAgICAgIHJldHVybiByXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBmdW5jdGlvbihzaXplLCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2sgJiYgY2FsbGJhY2suY2FsbCkge1xuICAgIHRyeSB7XG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIHVuZGVmaW5lZCwgcm5nKHNpemUpKTtcbiAgICB9IGNhdGNoIChlcnIpIHsgY2FsbGJhY2soZXJyKTsgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBybmcoc2l6ZSk7XG4gIH1cbn1cblxuLy8gdGhlIGxlYXN0IEkgY2FuIGRvIGlzIG1ha2UgZXJyb3IgbWVzc2FnZXMgZm9yIHRoZSByZXN0IG9mIHRoZSBub2RlLmpzL2NyeXB0byBhcGkuXG47WydjcmVhdGVDcmVkZW50aWFscydcbiwgJ2NyZWF0ZUhtYWMnXG4sICdjcmVhdGVDeXBoZXInXG4sICdjcmVhdGVDeXBoZXJpdidcbiwgJ2NyZWF0ZURlY2lwaGVyJ1xuLCAnY3JlYXRlRGVjaXBoZXJpdidcbiwgJ2NyZWF0ZVNpZ24nXG4sICdjcmVhdGVWZXJpZnknXG4sICdjcmVhdGVEZWZmaWVIZWxsbWFuJ1xuLCAncGJrZGYyJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBleHBvcnRzW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIGVycm9yKCdzb3JyeSwnLCBuYW1lLCAnaXMgbm90IGltcGxlbWVudGVkIHlldCcpXG4gIH1cbn0pXG4iLCJcbnZhciByZWdpc3RlciA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgZXhwb3J0c1t0eXBlLm5hbWVdID0gdHlwZTtcbiAgaWYgKHR5cGUudXJpKSB7XG4gICAgcmV0dXJuIGV4cG9ydHNbdHlwZS51cmldID0gdHlwZTtcbiAgfVxufTtcblxuLy8gSW1wb3J0IGFsbCB0aGUgYnVpbHQtaW4gdHlwZXMuIFJlcXVpcmluZyBkaXJlY3RseSByYXRoZXIgdGhhbiBpbiByZWdpc3RlcigpXG4vLyBzbyBicm93c2VyaWZ5IHdvcmtzLlxucmVnaXN0ZXIocmVxdWlyZSgnLi9zaW1wbGUnKSk7XG5cbnJlZ2lzdGVyKHJlcXVpcmUoJy4vdGV4dCcpKTtcbnJlZ2lzdGVyKHJlcXVpcmUoJy4vdGV4dC10cDInKSk7XG5cbnJlZ2lzdGVyKHJlcXVpcmUoJy4vanNvbjAnKSk7XG5cbiIsIi8vIE9yaWdpbmFsIGNvZGUgYWRhcHRlZCBmcm9tIFJvYmVydCBLaWVmZmVyLlxuLy8gZGV0YWlscyBhdCBodHRwczovL2dpdGh1Yi5jb20vYnJvb2ZhL25vZGUtdXVpZFxuKGZ1bmN0aW9uKCkge1xuICB2YXIgX2dsb2JhbCA9IHRoaXM7XG5cbiAgdmFyIG1hdGhSTkcsIHdoYXR3Z1JORztcblxuICAvLyBOT1RFOiBNYXRoLnJhbmRvbSgpIGRvZXMgbm90IGd1YXJhbnRlZSBcImNyeXB0b2dyYXBoaWMgcXVhbGl0eVwiXG4gIG1hdGhSTkcgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IEFycmF5KHNpemUpO1xuICAgIHZhciByO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIHI7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgIGlmICgoaSAmIDB4MDMpID09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICBieXRlc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gYnl0ZXM7XG4gIH1cblxuICAvLyBjdXJyZW50bHkgb25seSBhdmFpbGFibGUgaW4gd2Via2l0LWJhc2VkIGJyb3dzZXJzLlxuICBpZiAoX2dsb2JhbC5jcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIHZhciBfcm5kcyA9IG5ldyBVaW50MzJBcnJheSg0KTtcbiAgICB3aGF0d2dSTkcgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKF9ybmRzKTtcblxuICAgICAgZm9yICh2YXIgYyA9IDAgOyBjIDwgc2l6ZTsgYysrKSB7XG4gICAgICAgIGJ5dGVzW2NdID0gX3JuZHNbYyA+PiAyXSA+Pj4gKChjICYgMHgwMykgKiA4KSAmIDB4ZmY7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICB9XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSB3aGF0d2dSTkcgfHwgbWF0aFJORztcblxufSgpKSIsIi8vIFRoaXMgaXMgYSByZWFsbHkgc2ltcGxlIE9UIHR5cGUuIEl0cyBub3QgY29tcGlsZWQgd2l0aCB0aGUgd2ViIGNsaWVudCwgYnV0IGl0IGNvdWxkIGJlLlxuLy9cbi8vIEl0cyBtb3N0bHkgaW5jbHVkZWQgZm9yIGRlbW9uc3RyYXRpb24gcHVycG9zZXMgYW5kIGl0cyB1c2VkIGluIHRoZSBtZXRhIHVuaXQgdGVzdHMuXG4vL1xuLy8gVGhpcyBkZWZpbmVzIGEgcmVhbGx5IHNpbXBsZSB0ZXh0IE9UIHR5cGUgd2hpY2ggb25seSBhbGxvd3MgaW5zZXJ0cy4gKE5vIGRlbGV0ZXMpLlxuLy9cbi8vIE9wcyBsb29rIGxpa2U6XG4vLyAgIHtwb3NpdGlvbjojLCB0ZXh0OlwiYXNkZlwifVxuLy9cbi8vIERvY3VtZW50IHNuYXBzaG90cyBsb29rIGxpa2U6XG4vLyAgIHtzdHI6c3RyaW5nfVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gVGhlIG5hbWUgb2YgdGhlIE9UIHR5cGUuIFRoZSB0eXBlIGl0c2VsZiBpcyBleHBvc2VkIHRvIG90dHlwZXNbdHlwZS5uYW1lXSBhbmQgb3R0eXBlc1t0eXBlLnVyaV0uXG4gIC8vIFRoZSBuYW1lIGNhbiBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGFjdHVhbCB0eXBlIGluIGFsbCBBUEkgbWV0aG9kcyBpbiBTaGFyZUpTLlxuICBuYW1lOiAnc2ltcGxlJyxcblxuICAvLyBDYW5vbmljYWwgbmFtZS5cbiAgdXJpOiAnaHR0cDovL3NoYXJlanMub3JnL3R5cGVzL3NpbXBsZScsXG5cbiAgLy8gQ3JlYXRlIGEgbmV3IGRvY3VtZW50IHNuYXBzaG90LiBJbml0aWFsIGRhdGEgY2FuIGJlIHBhc3NlZCBpbi5cbiAgY3JlYXRlOiBmdW5jdGlvbihpbml0aWFsKSB7XG4gICAgaWYgKGluaXRpYWwgPT0gbnVsbClcbiAgICAgIGluaXRpYWwgPSAnJztcblxuICAgIHJldHVybiB7c3RyOiBpbml0aWFsfTtcbiAgfSxcblxuICAvLyBBcHBseSB0aGUgZ2l2ZW4gb3AgdG8gdGhlIGRvY3VtZW50IHNuYXBzaG90LiBSZXR1cm5zIHRoZSBuZXcgc25hcHNob3QuXG4gIGFwcGx5OiBmdW5jdGlvbihzbmFwc2hvdCwgb3ApIHtcbiAgICBpZiAob3AucG9zaXRpb24gPCAwIHx8IG9wLnBvc2l0aW9uID4gc25hcHNob3Quc3RyLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwb3NpdGlvbicpO1xuXG4gICAgdmFyIHN0ciA9IHNuYXBzaG90LnN0cjtcbiAgICBzdHIgPSBzdHIuc2xpY2UoMCwgb3AucG9zaXRpb24pICsgb3AudGV4dCArIHN0ci5zbGljZShvcC5wb3NpdGlvbik7XG4gICAgcmV0dXJuIHtzdHI6IHN0cn07XG4gIH0sXG5cbiAgLy8gVHJhbnNmb3JtIG9wMSBieSBvcDIuIFJldHVybnMgdHJhbnNmb3JtZWQgdmVyc2lvbiBvZiBvcDEuXG4gIC8vIFN5bSBkZXNjcmliZXMgdGhlIHN5bW1ldHJ5IG9mIHRoZSBvcGVyYXRpb24uIEl0cyBlaXRoZXIgJ2xlZnQnIG9yICdyaWdodCdcbiAgLy8gZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIG9wIGJlaW5nIHRyYW5zZm9ybWVkIGNvbWVzIGZyb20gdGhlIGNsaWVudCBvciB0aGVcbiAgLy8gc2VydmVyLlxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uKG9wMSwgb3AyLCBzeW0pIHtcbiAgICB2YXIgcG9zID0gb3AxLnBvc2l0aW9uO1xuXG4gICAgaWYgKG9wMi5wb3NpdGlvbiA8IHBvcyB8fCAob3AyLnBvc2l0aW9uID09PSBwb3MgJiYgc3ltID09PSAnbGVmdCcpKSB7XG4gICAgICBwb3MgKz0gb3AyLnRleHQubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiB7cG9zaXRpb246IHBvcywgdGV4dDogb3AxLnRleHR9O1xuICB9XG59O1xuXG4iLCIvKiBUZXh0IE9UIVxuICpcbiAqIFRoaXMgaXMgYW4gT1QgaW1wbGVtZW50YXRpb24gZm9yIHRleHQuIEl0IGlzIHRoZSBzdGFuZGFyZCBpbXBsZW1lbnRhdGlvbiBvZlxuICogdGV4dCB1c2VkIGJ5IFNoYXJlSlMuXG4gKlxuICogVGhpcyB0eXBlIGlzIGNvbXBvc2FibGUgYnV0IG5vbi1pbnZlcnRhYmxlLiBJdHMgc2ltaWxhciB0byBTaGFyZUpTJ3Mgb2xkXG4gKiB0ZXh0LWNvbXBvc2FibGUgdHlwZSwgYnV0IGl0cyBub3QgaW52ZXJ0YWJsZSBhbmQgaXRzIHZlcnkgc2ltaWxhciB0byB0aGVcbiAqIHRleHQtdHAyIGltcGxlbWVudGF0aW9uIGJ1dCBpdCBkb2Vzbid0IHN1cHBvcnQgdG9tYnN0b25lcyBvciBwdXJnaW5nLlxuICpcbiAqIE9wcyBhcmUgbGlzdHMgb2YgY29tcG9uZW50cyB3aGljaCBpdGVyYXRlIG92ZXIgdGhlIGRvY3VtZW50LlxuICogQ29tcG9uZW50cyBhcmUgZWl0aGVyOlxuICogICBBIG51bWJlciBOOiBTa2lwIE4gY2hhcmFjdGVycyBpbiB0aGUgb3JpZ2luYWwgZG9jdW1lbnRcbiAqICAgXCJzdHJcIiAgICAgOiBJbnNlcnQgXCJzdHJcIiBhdCB0aGUgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnRcbiAqICAge2Q6J3N0cid9IDogRGVsZXRlICdzdHInLCB3aGljaCBhcHBlYXJzIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudFxuICpcbiAqIEVnOiBbMywgJ2hpJywgNSwge2Q6OH1dXG4gKlxuICogVGhlIG9wZXJhdGlvbiBkb2VzIG5vdCBoYXZlIHRvIHNraXAgdGhlIGxhc3QgY2hhcmFjdGVycyBpbiB0aGUgZG9jdW1lbnQuXG4gKlxuICogU25hcHNob3RzIGFyZSBzdHJpbmdzLlxuICpcbiAqIEN1cnNvcnMgYXJlIGVpdGhlciBhIHNpbmdsZSBudW1iZXIgKHdoaWNoIGlzIHRoZSBjdXJzb3IgcG9zaXRpb24pIG9yIGEgcGFpciBvZlxuICogW2FuY2hvciwgZm9jdXNdIChha2EgW3N0YXJ0LCBlbmRdKS4gQmUgYXdhcmUgdGhhdCBlbmQgY2FuIGJlIGJlZm9yZSBzdGFydC5cbiAqL1xuXG4vKiogQG1vZHVsZSB0ZXh0ICovXG5cbmV4cG9ydHMubmFtZSA9ICd0ZXh0JztcbmV4cG9ydHMudXJpID0gJ2h0dHA6Ly9zaGFyZWpzLm9yZy90eXBlcy90ZXh0djEnO1xuXG4vKiogQ3JlYXRlIGEgbmV3IHRleHQgc25hcHNob3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGluaXRpYWwgLSBpbml0aWFsIHNuYXBzaG90IGRhdGEuIE9wdGlvbmFsLiBEZWZhdWx0cyB0byAnJy5cbiAqL1xuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbihpbml0aWFsKSB7XG4gIGlmICgoaW5pdGlhbCAhPSBudWxsKSAmJiB0eXBlb2YgaW5pdGlhbCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0luaXRpYWwgZGF0YSBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gIH1cbiAgcmV0dXJuIGluaXRpYWwgfHwgJyc7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xufTtcblxuLyoqIENoZWNrIHRoZSBvcGVyYXRpb24gaXMgdmFsaWQuIFRocm93cyBpZiBub3QgdmFsaWQuICovXG52YXIgY2hlY2tPcCA9IGZ1bmN0aW9uKG9wKSB7XG4gIGlmICghaXNBcnJheShvcCkpIHRocm93IG5ldyBFcnJvcignT3AgbXVzdCBiZSBhbiBhcnJheSBvZiBjb21wb25lbnRzJyk7XG5cbiAgdmFyIGxhc3QgPSBudWxsO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGMgPSBvcFtpXTtcbiAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAvLyBUaGUgb25seSB2YWxpZCBvYmplY3RzIGFyZSB7ZDpYfSBmb3IgK2l2ZSB2YWx1ZXMgb2YgWC5cbiAgICAgICAgaWYgKCEodHlwZW9mIGMuZCA9PT0gJ251bWJlcicgJiYgYy5kID4gMCkpIHRocm93IG5ldyBFcnJvcignT2JqZWN0IGNvbXBvbmVudHMgbXVzdCBiZSBkZWxldGVzIG9mIHNpemUgPiAwJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgLy8gU3RyaW5ncyBhcmUgaW5zZXJ0cy5cbiAgICAgICAgaWYgKCEoYy5sZW5ndGggPiAwKSkgdGhyb3cgbmV3IEVycm9yKCdJbnNlcnRzIGNhbm5vdCBiZSBlbXB0eScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIC8vIE51bWJlcnMgbXVzdCBiZSBza2lwcy4gVGhleSBoYXZlIHRvIGJlICtpdmUgbnVtYmVycy5cbiAgICAgICAgaWYgKCEoYyA+IDApKSB0aHJvdyBuZXcgRXJyb3IoJ1NraXAgY29tcG9uZW50cyBtdXN0IGJlID4wJyk7XG4gICAgICAgIGlmICh0eXBlb2YgbGFzdCA9PT0gJ251bWJlcicpIHRocm93IG5ldyBFcnJvcignQWRqYWNlbnQgc2tpcCBjb21wb25lbnRzIHNob3VsZCBiZSBjb21iaW5lZCcpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgbGFzdCA9IGM7XG4gIH1cblxuICBpZiAodHlwZW9mIGxhc3QgPT09ICdudW1iZXInKSB0aHJvdyBuZXcgRXJyb3IoJ09wIGhhcyBhIHRyYWlsaW5nIHNraXAnKTtcbn07XG5cbi8qKiBNYWtlIGEgZnVuY3Rpb24gdGhhdCBhcHBlbmRzIHRvIHRoZSBnaXZlbiBvcGVyYXRpb24uICovXG52YXIgbWFrZUFwcGVuZCA9IGZ1bmN0aW9uKG9wKSB7XG4gIHJldHVybiBmdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICBpZiAoIWNvbXBvbmVudCB8fCBjb21wb25lbnQuZCA9PT0gMCkge1xuICAgICAgLy8gVGhlIGNvbXBvbmVudCBpcyBhIG5vLW9wLiBJZ25vcmUhXG4gXG4gICAgfSBlbHNlIGlmIChvcC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBvcC5wdXNoKGNvbXBvbmVudCk7XG5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb21wb25lbnQgPT09IHR5cGVvZiBvcFtvcC5sZW5ndGggLSAxXSkge1xuICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBvcFtvcC5sZW5ndGggLSAxXS5kICs9IGNvbXBvbmVudC5kO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9wW29wLmxlbmd0aCAtIDFdICs9IGNvbXBvbmVudDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9wLnB1c2goY29tcG9uZW50KTtcbiAgICB9XG4gIH07XG59O1xuXG4vKiogTWFrZXMgYW5kIHJldHVybnMgdXRpbGl0eSBmdW5jdGlvbnMgdGFrZSBhbmQgcGVlay4gKi9cbnZhciBtYWtlVGFrZSA9IGZ1bmN0aW9uKG9wKSB7XG4gIC8vIFRoZSBpbmRleCBvZiB0aGUgbmV4dCBjb21wb25lbnQgdG8gdGFrZVxuICB2YXIgaWR4ID0gMDtcbiAgLy8gVGhlIG9mZnNldCBpbnRvIHRoZSBjb21wb25lbnRcbiAgdmFyIG9mZnNldCA9IDA7XG5cbiAgLy8gVGFrZSB1cCB0byBsZW5ndGggbiBmcm9tIHRoZSBmcm9udCBvZiBvcC4gSWYgbiBpcyAtMSwgdGFrZSB0aGUgZW50aXJlIG5leHRcbiAgLy8gb3AgY29tcG9uZW50LiBJZiBpbmRpdmlzYWJsZUZpZWxkID09ICdkJywgZGVsZXRlIGNvbXBvbmVudHMgd29uJ3QgYmUgc2VwYXJhdGVkLlxuICAvLyBJZiBpbmRpdmlzYWJsZUZpZWxkID09ICdpJywgaW5zZXJ0IGNvbXBvbmVudHMgd29uJ3QgYmUgc2VwYXJhdGVkLlxuICB2YXIgdGFrZSA9IGZ1bmN0aW9uKG4sIGluZGl2aXNhYmxlRmllbGQpIHtcbiAgICAvLyBXZSdyZSBhdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb24uIFRoZSBvcCBoYXMgc2tpcHMsIGZvcmV2ZXIuIEluZmluaXR5XG4gICAgLy8gbWlnaHQgbWFrZSBtb3JlIHNlbnNlIHRoYW4gbnVsbCBoZXJlLlxuICAgIGlmIChpZHggPT09IG9wLmxlbmd0aClcbiAgICAgIHJldHVybiBuID09PSAtMSA/IG51bGwgOiBuO1xuXG4gICAgdmFyIHBhcnQ7XG4gICAgdmFyIGMgPSBvcFtpZHhdO1xuICAgIGlmICh0eXBlb2YgYyA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFNraXBcbiAgICAgIGlmIChuID09PSAtMSB8fCBjIC0gb2Zmc2V0IDw9IG4pIHtcbiAgICAgICAgcGFydCA9IGMgLSBvZmZzZXQ7XG4gICAgICAgICsraWR4O1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCArPSBuO1xuICAgICAgICByZXR1cm4gbjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICBpZiAobiA9PT0gLTEgfHwgaW5kaXZpc2FibGVGaWVsZCA9PT0gJ2knIHx8IGMubGVuZ3RoIC0gb2Zmc2V0IDw9IG4pIHtcbiAgICAgICAgcGFydCA9IGMuc2xpY2Uob2Zmc2V0KTtcbiAgICAgICAgKytpZHg7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydCA9IGMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBuKTtcbiAgICAgICAgb2Zmc2V0ICs9IG47XG4gICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWxldGVcbiAgICAgIGlmIChuID09PSAtMSB8fCBpbmRpdmlzYWJsZUZpZWxkID09PSAnZCcgfHwgYy5kIC0gb2Zmc2V0IDw9IG4pIHtcbiAgICAgICAgcGFydCA9IHtkOiBjLmQgLSBvZmZzZXR9O1xuICAgICAgICArK2lkeDtcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgKz0gbjtcbiAgICAgICAgcmV0dXJuIHtkOiBufTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gUGVlayBhdCB0aGUgbmV4dCBvcCB0aGF0IHdpbGwgYmUgcmV0dXJuZWQuXG4gIHZhciBwZWVrVHlwZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gb3BbaWR4XTsgfTtcblxuICByZXR1cm4gW3Rha2UsIHBlZWtUeXBlXTtcbn07XG5cbi8qKiBHZXQgdGhlIGxlbmd0aCBvZiBhIGNvbXBvbmVudCAqL1xudmFyIGNvbXBvbmVudExlbmd0aCA9IGZ1bmN0aW9uKGMpIHtcbiAgLy8gVWdsaWZ5IHdpbGwgY29tcHJlc3MgdGhpcyBkb3duIGludG8gYSB0ZXJuYXJ5XG4gIGlmICh0eXBlb2YgYyA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gYztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYy5sZW5ndGggfHwgYy5kO1xuICB9XG59O1xuXG4vKiogVHJpbSBhbnkgZXhjZXNzIHNraXBzIGZyb20gdGhlIGVuZCBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogVGhlcmUgc2hvdWxkIG9ubHkgYmUgYXQgbW9zdCBvbmUsIGJlY2F1c2UgdGhlIG9wZXJhdGlvbiB3YXMgbWFkZSB3aXRoIGFwcGVuZC5cbiAqL1xudmFyIHRyaW0gPSBmdW5jdGlvbihvcCkge1xuICBpZiAob3AubGVuZ3RoID4gMCAmJiB0eXBlb2Ygb3Bbb3AubGVuZ3RoIC0gMV0gPT09ICdudW1iZXInKSB7XG4gICAgb3AucG9wKCk7XG4gIH1cbiAgcmV0dXJuIG9wO1xufTtcblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihvcCkge1xuICB2YXIgbmV3T3AgPSBbXTtcbiAgdmFyIGFwcGVuZCA9IG1ha2VBcHBlbmQobmV3T3ApO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSsrKSB7XG4gICAgYXBwZW5kKG9wW2ldKTtcbiAgfVxuICByZXR1cm4gdHJpbShuZXdPcCk7XG59O1xuXG4vKiogQXBwbHkgYW4gb3BlcmF0aW9uIHRvIGEgZG9jdW1lbnQgc25hcHNob3QgKi9cbmV4cG9ydHMuYXBwbHkgPSBmdW5jdGlvbihzdHIsIG9wKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignU25hcHNob3Qgc2hvdWxkIGJlIGEgc3RyaW5nJyk7XG4gIH1cbiAgY2hlY2tPcChvcCk7XG5cbiAgLy8gV2UnbGwgZ2F0aGVyIHRoZSBuZXcgZG9jdW1lbnQgaGVyZSBhbmQgam9pbiBhdCB0aGUgZW5kLlxuICB2YXIgbmV3RG9jID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb21wb25lbnQgPSBvcFtpXTtcbiAgICBzd2l0Y2ggKHR5cGVvZiBjb21wb25lbnQpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGlmIChjb21wb25lbnQgPiBzdHIubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBvcCBpcyB0b28gbG9uZyBmb3IgdGhpcyBkb2N1bWVudCcpO1xuXG4gICAgICAgIG5ld0RvYy5wdXNoKHN0ci5zbGljZSgwLCBjb21wb25lbnQpKTtcbiAgICAgICAgLy8gVGhpcyBtaWdodCBiZSBzbG93IGZvciBiaWcgc3RyaW5ncy4gQ29uc2lkZXIgc3RvcmluZyB0aGUgb2Zmc2V0IGluXG4gICAgICAgIC8vIHN0ciBpbnN0ZWFkIG9mIHJld3JpdGluZyBpdCBlYWNoIHRpbWUuXG4gICAgICAgIHN0ciA9IHN0ci5zbGljZShjb21wb25lbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIG5ld0RvYy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgc3RyID0gc3RyLnNsaWNlKGNvbXBvbmVudC5kKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0RvYy5qb2luKCcnKSArIHN0cjtcbn07XG5cbi8qKiBUcmFuc2Zvcm0gb3AgYnkgb3RoZXJPcC5cbiAqXG4gKiBAcGFyYW0gb3AgLSBUaGUgb3BlcmF0aW9uIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIG90aGVyT3AgLSBPcGVyYXRpb24gdG8gdHJhbnNmb3JtIGl0IGJ5XG4gKiBAcGFyYW0gc2lkZSAtIEVpdGhlciAnbGVmdCcgb3IgJ3JpZ2h0J1xuICovXG5leHBvcnRzLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKG9wLCBvdGhlck9wLCBzaWRlKSB7XG4gIGlmIChzaWRlICE9ICdsZWZ0JyAmJiBzaWRlICE9ICdyaWdodCcpIHRocm93IG5ldyBFcnJvcihcInNpZGUgKFwiICsgc2lkZSArIFwiKSBtdXN0IGJlICdsZWZ0JyBvciAncmlnaHQnXCIpO1xuXG4gIGNoZWNrT3Aob3ApO1xuICBjaGVja09wKG90aGVyT3ApO1xuXG4gIHZhciBuZXdPcCA9IFtdO1xuICB2YXIgYXBwZW5kID0gbWFrZUFwcGVuZChuZXdPcCk7XG5cbiAgdmFyIF9mbnMgPSBtYWtlVGFrZShvcCk7XG4gIHZhciB0YWtlID0gX2Zuc1swXSxcbiAgICAgIHBlZWsgPSBfZm5zWzFdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3RoZXJPcC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb21wb25lbnQgPSBvdGhlck9wW2ldO1xuXG4gICAgdmFyIGxlbmd0aCwgY2h1bms7XG4gICAgc3dpdGNoICh0eXBlb2YgY29tcG9uZW50KSB7XG4gICAgICBjYXNlICdudW1iZXInOiAvLyBTa2lwXG4gICAgICAgIGxlbmd0aCA9IGNvbXBvbmVudDtcbiAgICAgICAgd2hpbGUgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjaHVuayA9IHRha2UobGVuZ3RoLCAnaScpO1xuICAgICAgICAgIGFwcGVuZChjaHVuayk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGxlbmd0aCAtPSBjb21wb25lbnRMZW5ndGgoY2h1bmspO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc3RyaW5nJzogLy8gSW5zZXJ0XG4gICAgICAgIGlmIChzaWRlID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAvLyBUaGUgbGVmdCBpbnNlcnQgc2hvdWxkIGdvIGZpcnN0LlxuICAgICAgICAgIGlmICh0eXBlb2YgcGVlaygpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYXBwZW5kKHRha2UoLTEpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPdGhlcndpc2Ugc2tpcCB0aGUgaW5zZXJ0ZWQgdGV4dC5cbiAgICAgICAgYXBwZW5kKGNvbXBvbmVudC5sZW5ndGgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnb2JqZWN0JzogLy8gRGVsZXRlXG4gICAgICAgIGxlbmd0aCA9IGNvbXBvbmVudC5kO1xuICAgICAgICB3aGlsZSAobGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNodW5rID0gdGFrZShsZW5ndGgsICdpJyk7XG4gICAgICAgICAgc3dpdGNoICh0eXBlb2YgY2h1bmspIHtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgIGxlbmd0aCAtPSBjaHVuaztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICBhcHBlbmQoY2h1bmspO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgIC8vIFRoZSBkZWxldGUgaXMgdW5uZWNlc3Nhcnkgbm93IC0gdGhlIHRleHQgaGFzIGFscmVhZHkgYmVlbiBkZWxldGVkLlxuICAgICAgICAgICAgICBsZW5ndGggLT0gY2h1bmsuZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIFxuICAvLyBBcHBlbmQgYW55IGV4dHJhIGRhdGEgaW4gb3AxLlxuICB3aGlsZSAoKGNvbXBvbmVudCA9IHRha2UoLTEpKSlcbiAgICBhcHBlbmQoY29tcG9uZW50KTtcbiAgXG4gIHJldHVybiB0cmltKG5ld09wKTtcbn07XG5cbi8qKiBDb21wb3NlIG9wMSBhbmQgb3AyIHRvZ2V0aGVyIGFuZCByZXR1cm4gdGhlIHJlc3VsdCAqL1xuZXhwb3J0cy5jb21wb3NlID0gZnVuY3Rpb24ob3AxLCBvcDIpIHtcbiAgY2hlY2tPcChvcDEpO1xuICBjaGVja09wKG9wMik7XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgYXBwZW5kID0gbWFrZUFwcGVuZChyZXN1bHQpO1xuICB2YXIgdGFrZSA9IG1ha2VUYWtlKG9wMSlbMF07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcDIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29tcG9uZW50ID0gb3AyW2ldO1xuICAgIHZhciBsZW5ndGgsIGNodW5rO1xuICAgIHN3aXRjaCAodHlwZW9mIGNvbXBvbmVudCkge1xuICAgICAgY2FzZSAnbnVtYmVyJzogLy8gU2tpcFxuICAgICAgICBsZW5ndGggPSBjb21wb25lbnQ7XG4gICAgICAgIHdoaWxlIChsZW5ndGggPiAwKSB7XG4gICAgICAgICAgY2h1bmsgPSB0YWtlKGxlbmd0aCwgJ2QnKTtcbiAgICAgICAgICBhcHBlbmQoY2h1bmspO1xuICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBsZW5ndGggLT0gY29tcG9uZW50TGVuZ3RoKGNodW5rKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3N0cmluZyc6IC8vIEluc2VydFxuICAgICAgICBhcHBlbmQoY29tcG9uZW50KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6IC8vIERlbGV0ZVxuICAgICAgICBsZW5ndGggPSBjb21wb25lbnQuZDtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNodW5rID0gdGFrZShsZW5ndGgsICdkJyk7XG5cbiAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjaHVuaykge1xuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgYXBwZW5kKHtkOiBjaHVua30pO1xuICAgICAgICAgICAgICBsZW5ndGggLT0gY2h1bms7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgbGVuZ3RoIC09IGNodW5rLmxlbmd0aDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICBhcHBlbmQoY2h1bmspO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB3aGlsZSAoKGNvbXBvbmVudCA9IHRha2UoLTEpKSlcbiAgICBhcHBlbmQoY29tcG9uZW50KTtcblxuICByZXR1cm4gdHJpbShyZXN1bHQpO1xufTtcblxudmFyIHRyYW5zZm9ybVBvc2l0aW9uID0gZnVuY3Rpb24oY3Vyc29yLCBvcCkge1xuICB2YXIgcG9zID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjID0gb3BbaV07XG4gICAgaWYgKGN1cnNvciA8PSBwb3MpIGJyZWFrO1xuXG4gICAgLy8gSSBjb3VsZCBhY3R1YWxseSB1c2UgdGhlIG9wX2l0ZXIgc3R1ZmYgYWJvdmUgLSBidXQgSSB0aGluayBpdHMgc2ltcGxlclxuICAgIC8vIGxpa2UgdGhpcy5cbiAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpZiAoY3Vyc29yIDw9IHBvcyArIGMpXG4gICAgICAgICAgcmV0dXJuIGN1cnNvcjtcbiAgICAgICAgcG9zICs9IGM7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICBwb3MgKz0gYy5sZW5ndGg7XG4gICAgICAgIGN1cnNvciArPSBjLmxlbmd0aDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGN1cnNvciAtPSBNYXRoLm1pbihjLmQsIGN1cnNvciAtIHBvcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY3Vyc29yO1xufTtcblxuZXhwb3J0cy50cmFuc2Zvcm1DdXJzb3IgPSBmdW5jdGlvbihjdXJzb3IsIG9wLCBpc093bk9wKSB7XG4gIHZhciBwb3MgPSAwO1xuICBpZiAoaXNPd25PcCkge1xuICAgIC8vIEp1c3QgdHJhY2sgdGhlIHBvc2l0aW9uLiBXZSdsbCB0ZWxlcG9ydCB0aGUgY3Vyc29yIHRvIHRoZSBlbmQgYW55d2F5LlxuICAgIC8vIFRoaXMgd29ya3MgYmVjYXVzZSB0ZXh0IG9wcyBkb24ndCBoYXZlIGFueSB0cmFpbGluZyBza2lwcyBhdCB0aGUgZW5kIC0gc28gdGhlIGxhc3RcbiAgICAvLyBjb21wb25lbnQgaXMgdGhlIGxhc3QgdGhpbmcuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBvcFtpXTtcbiAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICBwb3MgKz0gYztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICBwb3MgKz0gYy5sZW5ndGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIEp1c3QgZWF0IGRlbGV0ZXMuXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbcG9zLCBwb3NdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbdHJhbnNmb3JtUG9zaXRpb24oY3Vyc29yWzBdLCBvcCksIHRyYW5zZm9ybVBvc2l0aW9uKGN1cnNvclsxXSwgb3ApXTtcbiAgfVxufTtcbiIsIi8qXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTEsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgUFVCIDE4MC0xXG4gKiBWZXJzaW9uIDIuMWEgQ29weXJpZ2h0IFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDIuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBkZXRhaWxzLlxuICovXG5cbmV4cG9ydHMuaGV4X3NoYTEgPSBoZXhfc2hhMTtcbmV4cG9ydHMuYjY0X3NoYTEgPSBiNjRfc2hhMTtcbmV4cG9ydHMuc3RyX3NoYTEgPSBzdHJfc2hhMTtcbmV4cG9ydHMuaGV4X2htYWNfc2hhMSA9IGhleF9obWFjX3NoYTE7XG5leHBvcnRzLmI2NF9obWFjX3NoYTEgPSBiNjRfaG1hY19zaGExO1xuZXhwb3J0cy5zdHJfaG1hY19zaGExID0gc3RyX2htYWNfc2hhMTtcblxuLypcbiAqIENvbmZpZ3VyYWJsZSB2YXJpYWJsZXMuIFlvdSBtYXkgbmVlZCB0byB0d2VhayB0aGVzZSB0byBiZSBjb21wYXRpYmxlIHdpdGhcbiAqIHRoZSBzZXJ2ZXItc2lkZSwgYnV0IHRoZSBkZWZhdWx0cyB3b3JrIGluIG1vc3QgY2FzZXMuXG4gKi9cbnZhciBoZXhjYXNlID0gMDsgIC8qIGhleCBvdXRwdXQgZm9ybWF0LiAwIC0gbG93ZXJjYXNlOyAxIC0gdXBwZXJjYXNlICAgICAgICAqL1xudmFyIGI2NHBhZCAgPSBcIlwiOyAvKiBiYXNlLTY0IHBhZCBjaGFyYWN0ZXIuIFwiPVwiIGZvciBzdHJpY3QgUkZDIGNvbXBsaWFuY2UgICAqL1xudmFyIGNocnN6ICAgPSA4OyAgLyogYml0cyBwZXIgaW5wdXQgY2hhcmFjdGVyLiA4IC0gQVNDSUk7IDE2IC0gVW5pY29kZSAgICAgICovXG5cbi8qXG4gKiBUaGVzZSBhcmUgdGhlIGZ1bmN0aW9ucyB5b3UnbGwgdXN1YWxseSB3YW50IHRvIGNhbGxcbiAqIFRoZXkgdGFrZSBzdHJpbmcgYXJndW1lbnRzIGFuZCByZXR1cm4gZWl0aGVyIGhleCBvciBiYXNlLTY0IGVuY29kZWQgc3RyaW5nc1xuICovXG5mdW5jdGlvbiBoZXhfc2hhMShzKXtyZXR1cm4gYmluYjJoZXgoY29yZV9zaGExKHN0cjJiaW5iKHMpLHMubGVuZ3RoICogY2hyc3opKTt9XG5mdW5jdGlvbiBiNjRfc2hhMShzKXtyZXR1cm4gYmluYjJiNjQoY29yZV9zaGExKHN0cjJiaW5iKHMpLHMubGVuZ3RoICogY2hyc3opKTt9XG5mdW5jdGlvbiBzdHJfc2hhMShzKXtyZXR1cm4gYmluYjJzdHIoY29yZV9zaGExKHN0cjJiaW5iKHMpLHMubGVuZ3RoICogY2hyc3opKTt9XG5mdW5jdGlvbiBoZXhfaG1hY19zaGExKGtleSwgZGF0YSl7IHJldHVybiBiaW5iMmhleChjb3JlX2htYWNfc2hhMShrZXksIGRhdGEpKTt9XG5mdW5jdGlvbiBiNjRfaG1hY19zaGExKGtleSwgZGF0YSl7IHJldHVybiBiaW5iMmI2NChjb3JlX2htYWNfc2hhMShrZXksIGRhdGEpKTt9XG5mdW5jdGlvbiBzdHJfaG1hY19zaGExKGtleSwgZGF0YSl7IHJldHVybiBiaW5iMnN0cihjb3JlX2htYWNfc2hhMShrZXksIGRhdGEpKTt9XG5cbi8qXG4gKiBQZXJmb3JtIGEgc2ltcGxlIHNlbGYtdGVzdCB0byBzZWUgaWYgdGhlIFZNIGlzIHdvcmtpbmdcbiAqL1xuZnVuY3Rpb24gc2hhMV92bV90ZXN0KClcbntcbiAgcmV0dXJuIGhleF9zaGExKFwiYWJjXCIpID09IFwiYTk5OTNlMzY0NzA2ODE2YWJhM2UyNTcxNzg1MGMyNmM5Y2QwZDg5ZFwiO1xufVxuXG4vKlxuICogQ2FsY3VsYXRlIHRoZSBTSEEtMSBvZiBhbiBhcnJheSBvZiBiaWctZW5kaWFuIHdvcmRzLCBhbmQgYSBiaXQgbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGNvcmVfc2hhMSh4LCBsZW4pXG57XG4gIC8qIGFwcGVuZCBwYWRkaW5nICovXG4gIHhbbGVuID4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbGVuICUgMzIpO1xuICB4WygobGVuICsgNjQgPj4gOSkgPDwgNCkgKyAxNV0gPSBsZW47XG5cbiAgdmFyIHcgPSBBcnJheSg4MCk7XG4gIHZhciBhID0gIDE3MzI1ODQxOTM7XG4gIHZhciBiID0gLTI3MTczMzg3OTtcbiAgdmFyIGMgPSAtMTczMjU4NDE5NDtcbiAgdmFyIGQgPSAgMjcxNzMzODc4O1xuICB2YXIgZSA9IC0xMDA5NTg5Nzc2O1xuXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNilcbiAge1xuICAgIHZhciBvbGRhID0gYTtcbiAgICB2YXIgb2xkYiA9IGI7XG4gICAgdmFyIG9sZGMgPSBjO1xuICAgIHZhciBvbGRkID0gZDtcbiAgICB2YXIgb2xkZSA9IGU7XG5cbiAgICBmb3IodmFyIGogPSAwOyBqIDwgODA7IGorKylcbiAgICB7XG4gICAgICBpZihqIDwgMTYpIHdbal0gPSB4W2kgKyBqXTtcbiAgICAgIGVsc2Ugd1tqXSA9IHJvbCh3W2otM10gXiB3W2otOF0gXiB3W2otMTRdIF4gd1tqLTE2XSwgMSk7XG4gICAgICB2YXIgdCA9IHNhZmVfYWRkKHNhZmVfYWRkKHJvbChhLCA1KSwgc2hhMV9mdChqLCBiLCBjLCBkKSksXG4gICAgICAgICAgICAgICAgICAgICAgIHNhZmVfYWRkKHNhZmVfYWRkKGUsIHdbal0pLCBzaGExX2t0KGopKSk7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgYyA9IHJvbChiLCAzMCk7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0O1xuICAgIH1cblxuICAgIGEgPSBzYWZlX2FkZChhLCBvbGRhKTtcbiAgICBiID0gc2FmZV9hZGQoYiwgb2xkYik7XG4gICAgYyA9IHNhZmVfYWRkKGMsIG9sZGMpO1xuICAgIGQgPSBzYWZlX2FkZChkLCBvbGRkKTtcbiAgICBlID0gc2FmZV9hZGQoZSwgb2xkZSk7XG4gIH1cbiAgcmV0dXJuIEFycmF5KGEsIGIsIGMsIGQsIGUpO1xuXG59XG5cbi8qXG4gKiBQZXJmb3JtIHRoZSBhcHByb3ByaWF0ZSB0cmlwbGV0IGNvbWJpbmF0aW9uIGZ1bmN0aW9uIGZvciB0aGUgY3VycmVudFxuICogaXRlcmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHNoYTFfZnQodCwgYiwgYywgZClcbntcbiAgaWYodCA8IDIwKSByZXR1cm4gKGIgJiBjKSB8ICgofmIpICYgZCk7XG4gIGlmKHQgPCA0MCkgcmV0dXJuIGIgXiBjIF4gZDtcbiAgaWYodCA8IDYwKSByZXR1cm4gKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpO1xuICByZXR1cm4gYiBeIGMgXiBkO1xufVxuXG4vKlxuICogRGV0ZXJtaW5lIHRoZSBhcHByb3ByaWF0ZSBhZGRpdGl2ZSBjb25zdGFudCBmb3IgdGhlIGN1cnJlbnQgaXRlcmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHNoYTFfa3QodClcbntcbiAgcmV0dXJuICh0IDwgMjApID8gIDE1MTg1MDAyNDkgOiAodCA8IDQwKSA/ICAxODU5Nzc1MzkzIDpcbiAgICAgICAgICh0IDwgNjApID8gLTE4OTQwMDc1ODggOiAtODk5NDk3NTE0O1xufVxuXG4vKlxuICogQ2FsY3VsYXRlIHRoZSBITUFDLVNIQTEgb2YgYSBrZXkgYW5kIHNvbWUgZGF0YVxuICovXG5mdW5jdGlvbiBjb3JlX2htYWNfc2hhMShrZXksIGRhdGEpXG57XG4gIHZhciBia2V5ID0gc3RyMmJpbmIoa2V5KTtcbiAgaWYoYmtleS5sZW5ndGggPiAxNikgYmtleSA9IGNvcmVfc2hhMShia2V5LCBrZXkubGVuZ3RoICogY2hyc3opO1xuXG4gIHZhciBpcGFkID0gQXJyYXkoMTYpLCBvcGFkID0gQXJyYXkoMTYpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgMTY7IGkrKylcbiAge1xuICAgIGlwYWRbaV0gPSBia2V5W2ldIF4gMHgzNjM2MzYzNjtcbiAgICBvcGFkW2ldID0gYmtleVtpXSBeIDB4NUM1QzVDNUM7XG4gIH1cblxuICB2YXIgaGFzaCA9IGNvcmVfc2hhMShpcGFkLmNvbmNhdChzdHIyYmluYihkYXRhKSksIDUxMiArIGRhdGEubGVuZ3RoICogY2hyc3opO1xuICByZXR1cm4gY29yZV9zaGExKG9wYWQuY29uY2F0KGhhc2gpLCA1MTIgKyAxNjApO1xufVxuXG4vKlxuICogQWRkIGludGVnZXJzLCB3cmFwcGluZyBhdCAyXjMyLiBUaGlzIHVzZXMgMTYtYml0IG9wZXJhdGlvbnMgaW50ZXJuYWxseVxuICogdG8gd29yayBhcm91bmQgYnVncyBpbiBzb21lIEpTIGludGVycHJldGVycy5cbiAqL1xuZnVuY3Rpb24gc2FmZV9hZGQoeCwgeSlcbntcbiAgdmFyIGxzdyA9ICh4ICYgMHhGRkZGKSArICh5ICYgMHhGRkZGKTtcbiAgdmFyIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xuICByZXR1cm4gKG1zdyA8PCAxNikgfCAobHN3ICYgMHhGRkZGKTtcbn1cblxuLypcbiAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cbiAqL1xuZnVuY3Rpb24gcm9sKG51bSwgY250KVxue1xuICByZXR1cm4gKG51bSA8PCBjbnQpIHwgKG51bSA+Pj4gKDMyIC0gY250KSk7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGFuIDgtYml0IG9yIDE2LWJpdCBzdHJpbmcgdG8gYW4gYXJyYXkgb2YgYmlnLWVuZGlhbiB3b3Jkc1xuICogSW4gOC1iaXQgZnVuY3Rpb24sIGNoYXJhY3RlcnMgPjI1NSBoYXZlIHRoZWlyIGhpLWJ5dGUgc2lsZW50bHkgaWdub3JlZC5cbiAqL1xuZnVuY3Rpb24gc3RyMmJpbmIoc3RyKVxue1xuICB2YXIgYmluID0gQXJyYXkoKTtcbiAgdmFyIG1hc2sgPSAoMSA8PCBjaHJzeikgLSAxO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aCAqIGNocnN6OyBpICs9IGNocnN6KVxuICAgIGJpbltpPj41XSB8PSAoc3RyLmNoYXJDb2RlQXQoaSAvIGNocnN6KSAmIG1hc2spIDw8ICgzMiAtIGNocnN6IC0gaSUzMik7XG4gIHJldHVybiBiaW47XG59XG5cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IG9mIGJpZy1lbmRpYW4gd29yZHMgdG8gYSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gYmluYjJzdHIoYmluKVxue1xuICB2YXIgc3RyID0gXCJcIjtcbiAgdmFyIG1hc2sgPSAoMSA8PCBjaHJzeikgLSAxO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYmluLmxlbmd0aCAqIDMyOyBpICs9IGNocnN6KVxuICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChiaW5baT4+NV0gPj4+ICgzMiAtIGNocnN6IC0gaSUzMikpICYgbWFzayk7XG4gIHJldHVybiBzdHI7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IG9mIGJpZy1lbmRpYW4gd29yZHMgdG8gYSBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiaW5iMmhleChiaW5hcnJheSlcbntcbiAgdmFyIGhleF90YWIgPSBoZXhjYXNlID8gXCIwMTIzNDU2Nzg5QUJDREVGXCIgOiBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbiAgdmFyIHN0ciA9IFwiXCI7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBiaW5hcnJheS5sZW5ndGggKiA0OyBpKyspXG4gIHtcbiAgICBzdHIgKz0gaGV4X3RhYi5jaGFyQXQoKGJpbmFycmF5W2k+PjJdID4+ICgoMyAtIGklNCkqOCs0KSkgJiAweEYpICtcbiAgICAgICAgICAgaGV4X3RhYi5jaGFyQXQoKGJpbmFycmF5W2k+PjJdID4+ICgoMyAtIGklNCkqOCAgKSkgJiAweEYpO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IG9mIGJpZy1lbmRpYW4gd29yZHMgdG8gYSBiYXNlLTY0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBiaW5iMmI2NChiaW5hcnJheSlcbntcbiAgdmFyIHRhYiA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xuICB2YXIgc3RyID0gXCJcIjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGJpbmFycmF5Lmxlbmd0aCAqIDQ7IGkgKz0gMylcbiAge1xuICAgIHZhciB0cmlwbGV0ID0gKCgoYmluYXJyYXlbaSAgID4+IDJdID4+IDggKiAoMyAtICBpICAgJTQpKSAmIDB4RkYpIDw8IDE2KVxuICAgICAgICAgICAgICAgIHwgKCgoYmluYXJyYXlbaSsxID4+IDJdID4+IDggKiAoMyAtIChpKzEpJTQpKSAmIDB4RkYpIDw8IDggKVxuICAgICAgICAgICAgICAgIHwgICgoYmluYXJyYXlbaSsyID4+IDJdID4+IDggKiAoMyAtIChpKzIpJTQpKSAmIDB4RkYpO1xuICAgIGZvcih2YXIgaiA9IDA7IGogPCA0OyBqKyspXG4gICAge1xuICAgICAgaWYoaSAqIDggKyBqICogNiA+IGJpbmFycmF5Lmxlbmd0aCAqIDMyKSBzdHIgKz0gYjY0cGFkO1xuICAgICAgZWxzZSBzdHIgKz0gdGFiLmNoYXJBdCgodHJpcGxldCA+PiA2KigzLWopKSAmIDB4M0YpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufVxuXG4iLCIoZnVuY3Rpb24oKXsvLyBBIFRQMiBpbXBsZW1lbnRhdGlvbiBvZiB0ZXh0LCBmb2xsb3dpbmcgdGhpcyBzcGVjOlxuLy8gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2xpZ2h0d2F2ZS9zb3VyY2UvYnJvd3NlL3RydW5rL2V4cGVyaW1lbnRhbC9vdC9SRUFETUVcbi8vXG4vLyBBIGRvY3VtZW50IGlzIG1hZGUgdXAgb2YgYSBzdHJpbmcgYW5kIGEgc2V0IG9mIHRvbWJzdG9uZXMgaW5zZXJ0ZWQgdGhyb3VnaG91dFxuLy8gdGhlIHN0cmluZy4gRm9yIGV4YW1wbGUsICdzb21lICcsICgyIHRvbWJzdG9uZXMpLCAnc3RyaW5nJy5cbi8vXG4vLyBUaGlzIGlzIGVuY29kZWQgaW4gYSBkb2N1bWVudCBhczoge3M6J3NvbWUgc3RyaW5nJywgdDpbNSwgLTIsIDZdfVxuLy9cbi8vIE9wcyBhcmUgbGlzdHMgb2YgY29tcG9uZW50cyB3aGljaCBpdGVyYXRlIG92ZXIgdGhlIHdob2xlIGRvY3VtZW50LiAoSSBtaWdodFxuLy8gY2hhbmdlIHRoaXMgYXQgc29tZSBwb2ludCwgYnV0IGEgdmVyc2lvbiB0aGF0cyBsZXNzIHN0cmljdCBpcyBiYWNrd2FyZHNcbi8vIGNvbXBhdGlibGUuKVxuLy9cbi8vIENvbXBvbmVudHMgYXJlIGVpdGhlcjpcbi8vICAgTjogICAgICAgICBTa2lwIE4gY2hhcmFjdGVycyBpbiB0aGUgb3JpZ2luYWwgZG9jdW1lbnRcbi8vICAge2k6J3N0cid9OiBJbnNlcnQgJ3N0cicgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50XG4vLyAgIHtpOk59OiAgICAgSW5zZXJ0IE4gdG9tYnN0b25lcyBhdCB0aGUgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnRcbi8vICAge2Q6Tn06ICAgICBEZWxldGUgKHRvbWJzdG9uZSkgTiBjaGFyYWN0ZXJzIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudFxuLy9cbi8vIEVnOiBbMywge2k6J2hpJ30sIDUsIHtkOjh9XVxuLy9cbi8vIFNuYXBzaG90cyBhcmUgbGlzdHMgd2l0aCBjaGFyYWN0ZXJzIGFuZCB0b21ic3RvbmVzLiBDaGFyYWN0ZXJzIGFyZSBzdG9yZWQgaW4gc3RyaW5nc1xuLy8gYW5kIGFkamFjZW50IHRvbWJzdG9uZXMgYXJlIGZsYXR0ZW5lZCBpbnRvIG51bWJlcnMuXG4vL1xuLy8gRWcsIHRoZSBkb2N1bWVudDogJ0hlbGxvIC4uLi4ud29ybGQnICgnLicgZGVub3RlcyB0b21ic3RvbmVkIChkZWxldGVkKSBjaGFyYWN0ZXJzKVxuLy8gd291bGQgYmUgcmVwcmVzZW50ZWQgYnkgYSBkb2N1bWVudCBzbmFwc2hvdCBvZiBbJ0hlbGxvICcsIDUsICd3b3JsZCddXG5cbi8vdmFyIGFwcGVuZCwgYXBwZW5kRG9jLCBjb21wb25lbnRMZW5ndGgsIG1ha2VUYWtlLCB0YWtlRG9jLCB0cmFuc2Zvcm1lcjtcblxudmFyIHR5cGUgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgbmFtZTogJ3RleHQtdHAyJyxcbiAgdHAyOiB0cnVlLFxuICB1cmk6ICdodHRwOi8vc2hhcmVqcy5vcmcvdHlwZXMvdGV4dC10cDJ2MScsXG4gIGNyZWF0ZTogZnVuY3Rpb24oaW5pdGlhbCkge1xuICAgIGlmIChpbml0aWFsID09IG51bGwpIHtcbiAgICAgIGluaXRpYWwgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBpbml0aWFsICE9ICdzdHJpbmcnKSB0aHJvdyBuZXcgRXJyb3IoJ0luaXRpYWwgZGF0YSBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNoYXJMZW5ndGg6IGluaXRpYWwubGVuZ3RoLFxuICAgICAgdG90YWxMZW5ndGg6IGluaXRpYWwubGVuZ3RoLFxuICAgICAgZGF0YTogaW5pdGlhbC5sZW5ndGggPyBbaW5pdGlhbF0gOiBbXVxuICAgIH07XG4gIH0sXG5cbiAgc2VyaWFsaXplOiBmdW5jdGlvbihkb2MpIHtcbiAgICBpZiAoIWRvYy5kYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZG9jIHNuYXBzaG90Jyk7XG4gICAgfVxuICAgIHJldHVybiBkb2MuZGF0YTtcbiAgfSxcblxuICBkZXNlcmlhbGl6ZTogZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciBkb2MgPSB0eXBlLmNyZWF0ZSgpO1xuICAgIGRvYy5kYXRhID0gZGF0YTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNvbXBvbmVudCA9IGRhdGFbaV07XG5cbiAgICAgIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICBkb2MuY2hhckxlbmd0aCArPSBjb21wb25lbnQubGVuZ3RoO1xuICAgICAgICBkb2MudG90YWxMZW5ndGggKz0gY29tcG9uZW50Lmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvYy50b3RhbExlbmd0aCArPSBjb21wb25lbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvYztcbiAgfVxufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbnZhciBjaGVja09wID0gZnVuY3Rpb24ob3ApIHtcbiAgaWYgKCFpc0FycmF5KG9wKSkgdGhyb3cgbmV3IEVycm9yKCdPcCBtdXN0IGJlIGFuIGFycmF5IG9mIGNvbXBvbmVudHMnKTtcblxuICB2YXIgbGFzdCA9IG51bGw7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3AubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYyA9IG9wW2ldO1xuICAgIGlmICh0eXBlb2YgYyA9PSAnb2JqZWN0Jykge1xuICAgICAgLy8gVGhlIGNvbXBvbmVudCBpcyBhbiBpbnNlcnQgb3IgYSBkZWxldGUuXG4gICAgICBpZiAoYy5pICE9PSB1bmRlZmluZWQpIHsgLy8gSW5zZXJ0LlxuICAgICAgICBpZiAoISgodHlwZW9mIGMuaSA9PT0gJ3N0cmluZycgJiYgYy5pLmxlbmd0aCA+IDApIC8vIFN0cmluZyBpbnNlcnRzXG4gICAgICAgICAgICAgIHx8ICh0eXBlb2YgYy5pID09PSAnbnVtYmVyJyAmJiBjLmkgPiAwKSkpIC8vIFRvbWJzdG9uZSBpbnNlcnRzXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnNlcnRzIG11c3QgaW5zZXJ0IGEgc3RyaW5nIG9yIGEgK2l2ZSBudW1iZXInKTtcblxuICAgICAgfSBlbHNlIGlmIChjLmQgIT09IHVuZGVmaW5lZCkgeyAvLyBEZWxldGVcbiAgICAgICAgaWYgKCEodHlwZW9mIGMuZCA9PT0gJ251bWJlcicgJiYgYy5kID4gMCkpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWxldGVzIG11c3QgYmUgYSAraXZlIG51bWJlcicpO1xuXG4gICAgICB9IGVsc2UgdGhyb3cgbmV3IEVycm9yKCdPcGVyYXRpb24gY29tcG9uZW50IG11c3QgZGVmaW5lIC5pIG9yIC5kJyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIGNvbXBvbmVudCBtdXN0IGJlIGEgc2tpcC5cbiAgICAgIGlmICh0eXBlb2YgYyAhPSAnbnVtYmVyJykgdGhyb3cgbmV3IEVycm9yKCdPcCBjb21wb25lbnRzIG11c3QgYmUgb2JqZWN0cyBvciBudW1iZXJzJyk7XG5cbiAgICAgIGlmIChjIDw9IDApIHRocm93IG5ldyBFcnJvcignU2tpcCBjb21wb25lbnRzIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgICAgIGlmICh0eXBlb2YgbGFzdCA9PT0gJ251bWJlcicpIHRocm93IG5ldyBFcnJvcignQWRqYWNlbnQgc2tpcCBjb21wb25lbnRzIHNob3VsZCBiZSBjb21iaW5lZCcpO1xuICAgIH1cblxuICAgIGxhc3QgPSBjO1xuICB9XG59O1xuXG4vLyBUYWtlIHRoZSBuZXh0IHBhcnQgZnJvbSB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uIGluIGEgZG9jdW1lbnQgc25hcHNob3QuXG4vLyBwb3NpdGlvbiA9IHtpbmRleCwgb2Zmc2V0fS4gSXQgd2lsbCBiZSB1cGRhdGVkLlxudmFyIHRha2VEb2MgPSB0eXBlLl90YWtlRG9jID0gZnVuY3Rpb24oZG9jLCBwb3NpdGlvbiwgbWF4bGVuZ3RoLCB0b21ic0luZGl2aXNpYmxlKSB7XG4gIGlmIChwb3NpdGlvbi5pbmRleCA+PSBkb2MuZGF0YS5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdPcGVyYXRpb24gZ29lcyBwYXN0IHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50Jyk7XG5cbiAgdmFyIHBhcnQgPSBkb2MuZGF0YVtwb3NpdGlvbi5pbmRleF07XG5cbiAgLy8gVGhpcyBjYW4gYmUgd3JpdHRlbiBhcyBhbiB1Z2x5LWFyc2VkIGdpYW50IHRlcm5hcnkgc3RhdGVtZW50LCBidXQgaXRzIG11Y2hcbiAgLy8gbW9yZSByZWFkYWJsZSBsaWtlIHRoaXMuIFVnbGlmeSB3aWxsIGNvbnZlcnQgaXQgaW50byBzYWlkIHRlcm5hcnkgYW55d2F5LlxuICB2YXIgcmVzdWx0O1xuICBpZiAodHlwZW9mIHBhcnQgPT0gJ3N0cmluZycpIHtcbiAgICBpZiAobWF4bGVuZ3RoICE9IG51bGwpIHtcbiAgICAgIHJlc3VsdCA9IHBhcnQuc2xpY2UocG9zaXRpb24ub2Zmc2V0LCBwb3NpdGlvbi5vZmZzZXQgKyBtYXhsZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBwYXJ0LnNsaWNlKHBvc2l0aW9uLm9mZnNldCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChtYXhsZW5ndGggPT0gbnVsbCB8fCB0b21ic0luZGl2aXNpYmxlKSB7XG4gICAgICByZXN1bHQgPSBwYXJ0IC0gcG9zaXRpb24ub2Zmc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBNYXRoLm1pbihtYXhsZW5ndGgsIHBhcnQgLSBwb3NpdGlvbi5vZmZzZXQpO1xuICAgIH1cbiAgfVxuXG4gIHZhciByZXN1bHRMZW4gPSByZXN1bHQubGVuZ3RoIHx8IHJlc3VsdDtcblxuICBpZiAoKHBhcnQubGVuZ3RoIHx8IHBhcnQpIC0gcG9zaXRpb24ub2Zmc2V0ID4gcmVzdWx0TGVuKSB7XG4gICAgcG9zaXRpb24ub2Zmc2V0ICs9IHJlc3VsdExlbjtcbiAgfSBlbHNlIHtcbiAgICBwb3NpdGlvbi5pbmRleCsrO1xuICAgIHBvc2l0aW9uLm9mZnNldCA9IDA7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gQXBwZW5kIGEgcGFydCB0byB0aGUgZW5kIG9mIGEgZG9jdW1lbnRcbnZhciBhcHBlbmREb2MgPSB0eXBlLl9hcHBlbmREb2MgPSBmdW5jdGlvbihkb2MsIHApIHtcbiAgaWYgKHAgPT09IDAgfHwgcCA9PT0gJycpIHJldHVybjtcblxuICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKSB7XG4gICAgZG9jLmNoYXJMZW5ndGggKz0gcC5sZW5ndGg7XG4gICAgZG9jLnRvdGFsTGVuZ3RoICs9IHAubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIGRvYy50b3RhbExlbmd0aCArPSBwO1xuICB9XG5cbiAgdmFyIGRhdGEgPSBkb2MuZGF0YTtcbiAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgZGF0YS5wdXNoKHApO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhW2RhdGEubGVuZ3RoIC0gMV0gPT09IHR5cGVvZiBwKSB7XG4gICAgZGF0YVtkYXRhLmxlbmd0aCAtIDFdICs9IHA7XG4gIH0gZWxzZSB7XG4gICAgZGF0YS5wdXNoKHApO1xuICB9XG59O1xuXG4vLyBBcHBseSB0aGUgb3AgdG8gdGhlIGRvY3VtZW50LiBUaGUgZG9jdW1lbnQgaXMgbm90IG1vZGlmaWVkIGluIHRoZSBwcm9jZXNzLlxudHlwZS5hcHBseSA9IGZ1bmN0aW9uKGRvYywgb3ApIHtcbiAgaWYgKGRvYy50b3RhbExlbmd0aCA9PSBudWxsIHx8IGRvYy5jaGFyTGVuZ3RoID09IG51bGwgfHwgIWlzQXJyYXkoZG9jLmRhdGEpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTbmFwc2hvdCBpcyBpbnZhbGlkJyk7XG4gIH1cbiAgY2hlY2tPcChvcCk7XG5cbiAgdmFyIG5ld0RvYyA9IHR5cGUuY3JlYXRlKCk7XG4gIHZhciBwb3NpdGlvbiA9IHtpbmRleDogMCwgb2Zmc2V0OiAwfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IG9wW2ldO1xuICAgIHZhciByZW1haW5kZXIsIHBhcnQ7XG5cbiAgICBpZiAodHlwZW9mIGNvbXBvbmVudCA9PSAnbnVtYmVyJykgeyAvLyBTa2lwXG4gICAgICByZW1haW5kZXIgPSBjb21wb25lbnQ7XG4gICAgICB3aGlsZSAocmVtYWluZGVyID4gMCkge1xuICAgICAgICBwYXJ0ID0gdGFrZURvYyhkb2MsIHBvc2l0aW9uLCByZW1haW5kZXIpO1xuICAgICAgICBhcHBlbmREb2MobmV3RG9jLCBwYXJ0KTtcbiAgICAgICAgcmVtYWluZGVyIC09IHBhcnQubGVuZ3RoIHx8IHBhcnQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKGNvbXBvbmVudC5pICE9PSB1bmRlZmluZWQpIHsgLy8gSW5zZXJ0XG4gICAgICBhcHBlbmREb2MobmV3RG9jLCBjb21wb25lbnQuaSk7XG5cbiAgICB9IGVsc2UgaWYgKGNvbXBvbmVudC5kICE9PSB1bmRlZmluZWQpIHsgLy8gRGVsZXRlXG4gICAgICByZW1haW5kZXIgPSBjb21wb25lbnQuZDtcbiAgICAgIHdoaWxlIChyZW1haW5kZXIgPiAwKSB7XG4gICAgICAgIHBhcnQgPSB0YWtlRG9jKGRvYywgcG9zaXRpb24sIHJlbWFpbmRlcik7XG4gICAgICAgIHJlbWFpbmRlciAtPSBwYXJ0Lmxlbmd0aCB8fCBwYXJ0O1xuICAgICAgfVxuICAgICAgYXBwZW5kRG9jKG5ld0RvYywgY29tcG9uZW50LmQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3RG9jO1xufTtcblxuLy8gQXBwZW5kIGFuIG9wIGNvbXBvbmVudCB0byB0aGUgZW5kIG9mIHRoZSBzcGVjaWZpZWQgb3AuICBFeHBvcnRlZCBmb3IgdGhlXG4vLyByYW5kb21PcEdlbmVyYXRvci5cbnZhciBhcHBlbmQgPSB0eXBlLl9hcHBlbmQgPSBmdW5jdGlvbihvcCwgY29tcG9uZW50KSB7XG4gIHZhciBsYXN0O1xuXG4gIGlmIChjb21wb25lbnQgPT09IDAgfHwgY29tcG9uZW50LmkgPT09ICcnIHx8IGNvbXBvbmVudC5pID09PSAwIHx8IGNvbXBvbmVudC5kID09PSAwKSB7XG4gICAgLy8gRHJvcCB0aGUgbmV3IGNvbXBvbmVudC5cbiAgfSBlbHNlIGlmIChvcC5sZW5ndGggPT09IDApIHtcbiAgICBvcC5wdXNoKGNvbXBvbmVudCk7XG4gIH0gZWxzZSB7XG4gICAgbGFzdCA9IG9wW29wLmxlbmd0aCAtIDFdO1xuICAgIGlmICh0eXBlb2YgY29tcG9uZW50ID09ICdudW1iZXInICYmIHR5cGVvZiBsYXN0ID09ICdudW1iZXInKSB7XG4gICAgICBvcFtvcC5sZW5ndGggLSAxXSArPSBjb21wb25lbnQ7XG4gICAgfSBlbHNlIGlmIChjb21wb25lbnQuaSAhPSBudWxsICYmIChsYXN0LmkgIT0gbnVsbCkgJiYgdHlwZW9mIGxhc3QuaSA9PT0gdHlwZW9mIGNvbXBvbmVudC5pKSB7XG4gICAgICBsYXN0LmkgKz0gY29tcG9uZW50Lmk7XG4gICAgfSBlbHNlIGlmIChjb21wb25lbnQuZCAhPSBudWxsICYmIChsYXN0LmQgIT0gbnVsbCkpIHtcbiAgICAgIGxhc3QuZCArPSBjb21wb25lbnQuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3AucHVzaChjb21wb25lbnQpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gTWFrZXMgMiBmdW5jdGlvbnMgZm9yIHRha2luZyBjb21wb25lbnRzIGZyb20gdGhlIHN0YXJ0IG9mIGFuIG9wLCBhbmQgZm9yXG4vLyBwZWVraW5nIGF0IHRoZSBuZXh0IG9wIHRoYXQgY291bGQgYmUgdGFrZW4uXG52YXIgbWFrZVRha2UgPSBmdW5jdGlvbihvcCkge1xuICAvLyBUaGUgaW5kZXggb2YgdGhlIG5leHQgY29tcG9uZW50IHRvIHRha2VcbiAgdmFyIGluZGV4ID0gMDtcbiAgLy8gVGhlIG9mZnNldCBpbnRvIHRoZSBjb21wb25lbnRcbiAgdmFyIG9mZnNldCA9IDA7XG5cbiAgdmFyIHRha2UgPSBmdW5jdGlvbihtYXhsZW5ndGgsIGluc2VydHNJbmRpdmlzaWJsZSkge1xuICAgIGlmIChpbmRleCA9PT0gb3AubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgZSA9IG9wW2luZGV4XTtcbiAgICB2YXIgY3VycmVudDtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgLy8gaWYgdGhlIGN1cnJlbnQgZWxlbWVudCBpcyBhIHNraXAsIGFuIGluc2VydCBvZiBhIG51bWJlciBvciBhIGRlbGV0ZVxuICAgIGlmICh0eXBlb2YgKGN1cnJlbnQgPSBlKSA9PSAnbnVtYmVyJyB8fCB0eXBlb2YgKGN1cnJlbnQgPSBlLmkpID09ICdudW1iZXInIHx8IChjdXJyZW50ID0gZS5kKSAhPSBudWxsKSB7XG4gICAgICB2YXIgYztcbiAgICAgIGlmICgobWF4bGVuZ3RoID09IG51bGwpIHx8IGN1cnJlbnQgLSBvZmZzZXQgPD0gbWF4bGVuZ3RoIHx8IChpbnNlcnRzSW5kaXZpc2libGUgJiYgZS5pICE9IG51bGwpKSB7XG4gICAgICAgIC8vIFJldHVybiB0aGUgcmVzdCBvZiB0aGUgY3VycmVudCBlbGVtZW50LlxuICAgICAgICBjID0gY3VycmVudCAtIG9mZnNldDtcbiAgICAgICAgKytpbmRleDtcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCArPSBtYXhsZW5ndGg7XG4gICAgICAgIGMgPSBtYXhsZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIC8vIFBhY2thZ2UgdGhlIGNvbXBvbmVudCBiYWNrIHVwLlxuICAgICAgaWYgKGUuaSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7aTogY307XG4gICAgICB9IGVsc2UgaWYgKGUuZCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7ZDogY307XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBJbnNlcnQgb2YgYSBzdHJpbmcuXG4gICAgICBpZiAoKG1heGxlbmd0aCA9PSBudWxsKSB8fCBlLmkubGVuZ3RoIC0gb2Zmc2V0IDw9IG1heGxlbmd0aCB8fCBpbnNlcnRzSW5kaXZpc2libGUpIHtcbiAgICAgICAgcmVzdWx0ID0ge2k6IGUuaS5zbGljZShvZmZzZXQpfTtcbiAgICAgICAgKytpbmRleDtcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHtpOiBlLmkuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBtYXhsZW5ndGgpfTtcbiAgICAgICAgb2Zmc2V0ICs9IG1heGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9O1xuXG4gIHZhciBwZWVrVHlwZSA9IGZ1bmN0aW9uKCkge3JldHVybiBvcFtpbmRleF07fTtcbiAgcmV0dXJuIFt0YWtlLCBwZWVrVHlwZV07XG59O1xuXG4vLyBGaW5kIGFuZCByZXR1cm4gdGhlIGxlbmd0aCBvZiBhbiBvcCBjb21wb25lbnRcbnZhciBjb21wb25lbnRMZW5ndGggPSBmdW5jdGlvbihjb21wb25lbnQpIHtcbiAgaWYgKHR5cGVvZiBjb21wb25lbnQgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY29tcG9uZW50LmkgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudC5pLmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29tcG9uZW50LmQgfHwgY29tcG9uZW50Lmk7XG4gIH1cbn07XG5cbi8vIE5vcm1hbGl6ZSBhbiBvcCwgcmVtb3ZpbmcgYWxsIGVtcHR5IHNraXBzIGFuZCBlbXB0eSBpbnNlcnRzIC8gZGVsZXRlcy5cbi8vIENvbmNhdGVuYXRlIGFkamFjZW50IGluc2VydHMgYW5kIGRlbGV0ZXMuXG50eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG9wKSB7XG4gIHZhciBuZXdPcCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSsrKSB7XG4gICAgYXBwZW5kKG5ld09wLCBvcFtpXSk7XG4gIH1cbiAgcmV0dXJuIG5ld09wO1xufTtcblxuLy8gVGhpcyBpcyBhIGhlbHBlciBtZXRob2QgdG8gdHJhbnNmb3JtIGFuZCBwcnVuZS4gZ29Gb3J3YXJkcyBpcyB0cnVlIGZvciB0cmFuc2Zvcm0sIGZhbHNlIGZvciBwcnVuZS5cbnZhciB0cmFuc2Zvcm1lciA9IGZ1bmN0aW9uKG9wLCBvdGhlck9wLCBnb0ZvcndhcmRzLCBzaWRlKSB7XG4gIGNoZWNrT3Aob3ApO1xuICBjaGVja09wKG90aGVyT3ApO1xuXG4gIHZhciBuZXdPcCA9IFtdO1xuXG4gIHZhciBmbnMgPSBtYWtlVGFrZShvcCksXG4gICAgICB0YWtlID0gZm5zWzBdLFxuICAgICAgcGVlayA9IGZuc1sxXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG90aGVyT3AubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29tcG9uZW50ID0gb3RoZXJPcFtpXTtcbiAgICB2YXIgbGVuID0gY29tcG9uZW50TGVuZ3RoKGNvbXBvbmVudCk7XG4gICAgdmFyIGNodW5rO1xuXG4gICAgaWYgKGNvbXBvbmVudC5pICE9IG51bGwpIHsgLy8gSW5zZXJ0IHRleHQgb3IgdG9tYnNcbiAgICAgIGlmIChnb0ZvcndhcmRzKSB7IC8vIFRyYW5zZm9ybSAtIGluc2VydCBza2lwcyBvdmVyIGRlbGV0ZWQgcGFydHMuXG4gICAgICAgIGlmIChzaWRlID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAvLyBUaGUgbGVmdCBzaWRlIGluc2VydCBzaG91bGQgZ28gZmlyc3QuXG4gICAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgICAgd2hpbGUgKChuZXh0ID0gcGVlaygpKSAmJiBuZXh0LmkgIT0gbnVsbCkge1xuICAgICAgICAgICAgYXBwZW5kKG5ld09wLCB0YWtlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJbiBhbnkgY2FzZSwgc2tpcCB0aGUgaW5zZXJ0ZWQgdGV4dC5cbiAgICAgICAgYXBwZW5kKG5ld09wLCBsZW4pO1xuXG4gICAgICB9IGVsc2UgeyAvLyBQcnVuZS4gUmVtb3ZlIHNraXBzIGZvciBpbnNlcnRzLlxuICAgICAgICB3aGlsZSAobGVuID4gMCkge1xuICAgICAgICAgIGNodW5rID0gdGFrZShsZW4sIHRydWUpO1xuXG4gICAgICAgICAgLy8gVGhlIGNodW5rIHdpbGwgYmUgbnVsbCBpZiB3ZSBydW4gb3V0IG9mIGNvbXBvbmVudHMgaW4gdGhlIG90aGVyIG9wLlxuICAgICAgICAgIGlmIChjaHVuayA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCdUaGUgdHJhbnNmb3JtZWQgb3AgaXMgaW52YWxpZCcpO1xuICAgICAgICAgIGlmIChjaHVuay5kICE9IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB0cmFuc2Zvcm1lZCBvcCBkZWxldGVzIGxvY2FsbHkgaW5zZXJ0ZWQgY2hhcmFjdGVycyAtIGl0IGNhbm5vdCBiZSBwdXJnZWQgb2YgdGhlIGluc2VydC4nKTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT0gJ251bWJlcicpXG4gICAgICAgICAgICBsZW4gLT0gY2h1bms7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYXBwZW5kKG5ld09wLCBjaHVuayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBTa2lwcyBvciBkZWxldGVzLlxuICAgICAgd2hpbGUgKGxlbiA+IDApIHtcbiAgICAgICAgY2h1bmsgPSB0YWtlKGxlbiwgdHJ1ZSk7XG4gICAgICAgIGlmIChjaHVuayA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCdUaGUgb3AgdHJhdmVyc2VzIG1vcmUgZWxlbWVudHMgdGhhbiB0aGUgZG9jdW1lbnQgaGFzJyk7XG5cbiAgICAgICAgYXBwZW5kKG5ld09wLCBjaHVuayk7XG4gICAgICAgIGlmICghY2h1bmsuaSkgbGVuIC09IGNvbXBvbmVudExlbmd0aChjaHVuayk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQXBwZW5kIGV4dHJhcyBmcm9tIG9wMS5cbiAgdmFyIGNvbXBvbmVudDtcbiAgd2hpbGUgKChjb21wb25lbnQgPSB0YWtlKCkpKSB7XG4gICAgaWYgKGNvbXBvbmVudC5pID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlbWFpbmluZyBmcmFnbWVudHMgaW4gdGhlIG9wOiBcIiArIGNvbXBvbmVudCk7XG4gICAgfVxuICAgIGFwcGVuZChuZXdPcCwgY29tcG9uZW50KTtcbiAgfVxuICByZXR1cm4gbmV3T3A7XG59O1xuXG4vLyB0cmFuc2Zvcm0gb3AxIGJ5IG9wMi4gUmV0dXJuIHRyYW5zZm9ybWVkIHZlcnNpb24gb2Ygb3AxLiBvcDEgYW5kIG9wMiBhcmVcbi8vIHVuY2hhbmdlZCBieSB0cmFuc2Zvcm0uIFNpZGUgc2hvdWxkIGJlICdsZWZ0JyBvciAncmlnaHQnLCBkZXBlbmRpbmcgb24gaWZcbi8vIG9wMS5pZCA8PiBvcDIuaWQuXG4vL1xuLy8gJ2xlZnQnID09IGNsaWVudCBvcCBmb3IgU2hhcmVKUy5cbnR5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24ob3AsIG90aGVyT3AsIHNpZGUpIHtcbiAgaWYgKHNpZGUgIT0gJ2xlZnQnICYmIHNpZGUgIT0gJ3JpZ2h0JylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJzaWRlIChcIiArIHNpZGUgKyBcIikgc2hvdWxkIGJlICdsZWZ0JyBvciAncmlnaHQnXCIpO1xuXG4gIHJldHVybiB0cmFuc2Zvcm1lcihvcCwgb3RoZXJPcCwgdHJ1ZSwgc2lkZSk7XG59O1xuXG50eXBlLnBydW5lID0gZnVuY3Rpb24ob3AsIG90aGVyT3ApIHtcbiAgcmV0dXJuIHRyYW5zZm9ybWVyKG9wLCBvdGhlck9wLCBmYWxzZSk7XG59O1xuXG50eXBlLmNvbXBvc2UgPSBmdW5jdGlvbihvcDEsIG9wMikge1xuICAvL3ZhciBjaHVuaywgY2h1bmtMZW5ndGgsIGNvbXBvbmVudCwgbGVuZ3RoLCByZXN1bHQsIHRha2UsIF8sIF9pLCBfbGVuLCBfcmVmO1xuICBpZiAob3AxID09IG51bGwpIHJldHVybiBvcDI7XG5cbiAgY2hlY2tPcChvcDEpO1xuICBjaGVja09wKG9wMik7XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgdGFrZSA9IG1ha2VUYWtlKG9wMSlbMF07XG4gIHZhciBjb21wb25lbnQ7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcDIubGVuZ3RoOyBpKyspIHtcbiAgICBjb21wb25lbnQgPSBvcDJbaV07XG4gICAgdmFyIGxlbiwgY2h1bms7XG5cbiAgICBpZiAodHlwZW9mIGNvbXBvbmVudCA9PT0gJ251bWJlcicpIHsgLy8gU2tpcFxuICAgICAgLy8gSnVzdCBjb3B5IGZyb20gb3AxLlxuICAgICAgbGVuID0gY29tcG9uZW50O1xuICAgICAgd2hpbGUgKGxlbiA+IDApIHtcbiAgICAgICAgY2h1bmsgPSB0YWtlKGxlbik7XG4gICAgICAgIGlmIChjaHVuayA9PT0gbnVsbClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBvcCB0cmF2ZXJzZXMgbW9yZSBlbGVtZW50cyB0aGFuIHRoZSBkb2N1bWVudCBoYXMnKTtcblxuICAgICAgICBhcHBlbmQocmVzdWx0LCBjaHVuayk7XG4gICAgICAgIGxlbiAtPSBjb21wb25lbnRMZW5ndGgoY2h1bmspO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChjb21wb25lbnQuaSAhPT0gdW5kZWZpbmVkKSB7IC8vIEluc2VydFxuICAgICAgYXBwZW5kKHJlc3VsdCwge2k6IGNvbXBvbmVudC5pfSk7XG5cbiAgICB9IGVsc2UgeyAvLyBEZWxldGVcbiAgICAgIGxlbiA9IGNvbXBvbmVudC5kO1xuICAgICAgd2hpbGUgKGxlbiA+IDApIHtcbiAgICAgICAgY2h1bmsgPSB0YWtlKGxlbik7XG4gICAgICAgIGlmIChjaHVuayA9PT0gbnVsbClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBvcCB0cmF2ZXJzZXMgbW9yZSBlbGVtZW50cyB0aGFuIHRoZSBkb2N1bWVudCBoYXMnKTtcblxuICAgICAgICB2YXIgY2h1bmtMZW5ndGggPSBjb21wb25lbnRMZW5ndGgoY2h1bmspO1xuXG4gICAgICAgIGlmIChjaHVuay5pICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgYXBwZW5kKHJlc3VsdCwge2k6IGNodW5rTGVuZ3RofSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBhcHBlbmQocmVzdWx0LCB7ZDogY2h1bmtMZW5ndGh9KTtcblxuICAgICAgICBsZW4gLT0gY2h1bmtMZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQXBwZW5kIGV4dHJhcyBmcm9tIG9wMS5cbiAgd2hpbGUgKChjb21wb25lbnQgPSB0YWtlKCkpKSB7XG4gICAgaWYgKGNvbXBvbmVudC5pID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlbWFpbmluZyBmcmFnbWVudHMgaW4gb3AxOiBcIiArIGNvbXBvbmVudCk7XG4gICAgfVxuICAgIGFwcGVuZChyZXN1bHQsIGNvbXBvbmVudCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxufSkoKSIsIi8qXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFJTQSBEYXRhIFNlY3VyaXR5LCBJbmMuIE1ENSBNZXNzYWdlXG4gKiBEaWdlc3QgQWxnb3JpdGhtLCBhcyBkZWZpbmVkIGluIFJGQyAxMzIxLlxuICogVmVyc2lvbiAyLjIgQ29weXJpZ2h0IChDKSBQYXVsIEpvaG5zdG9uIDE5OTkgLSAyMDA5XG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBtb3JlIGluZm8uXG4gKi9cblxuLypcbiAqIENvbmZpZ3VyYWJsZSB2YXJpYWJsZXMuIFlvdSBtYXkgbmVlZCB0byB0d2VhayB0aGVzZSB0byBiZSBjb21wYXRpYmxlIHdpdGhcbiAqIHRoZSBzZXJ2ZXItc2lkZSwgYnV0IHRoZSBkZWZhdWx0cyB3b3JrIGluIG1vc3QgY2FzZXMuXG4gKi9cbnZhciBoZXhjYXNlID0gMDsgICAvKiBoZXggb3V0cHV0IGZvcm1hdC4gMCAtIGxvd2VyY2FzZTsgMSAtIHVwcGVyY2FzZSAgICAgICAgKi9cbnZhciBiNjRwYWQgID0gXCJcIjsgIC8qIGJhc2UtNjQgcGFkIGNoYXJhY3Rlci4gXCI9XCIgZm9yIHN0cmljdCBSRkMgY29tcGxpYW5jZSAgICovXG5cbi8qXG4gKiBUaGVzZSBhcmUgdGhlIGZ1bmN0aW9ucyB5b3UnbGwgdXN1YWxseSB3YW50IHRvIGNhbGxcbiAqIFRoZXkgdGFrZSBzdHJpbmcgYXJndW1lbnRzIGFuZCByZXR1cm4gZWl0aGVyIGhleCBvciBiYXNlLTY0IGVuY29kZWQgc3RyaW5nc1xuICovXG5mdW5jdGlvbiBoZXhfbWQ1KHMpICAgIHsgcmV0dXJuIHJzdHIyaGV4KHJzdHJfbWQ1KHN0cjJyc3RyX3V0ZjgocykpKTsgfVxuZnVuY3Rpb24gYjY0X21kNShzKSAgICB7IHJldHVybiByc3RyMmI2NChyc3RyX21kNShzdHIycnN0cl91dGY4KHMpKSk7IH1cbmZ1bmN0aW9uIGFueV9tZDUocywgZSkgeyByZXR1cm4gcnN0cjJhbnkocnN0cl9tZDUoc3RyMnJzdHJfdXRmOChzKSksIGUpOyB9XG5mdW5jdGlvbiBoZXhfaG1hY19tZDUoaywgZClcbiAgeyByZXR1cm4gcnN0cjJoZXgocnN0cl9obWFjX21kNShzdHIycnN0cl91dGY4KGspLCBzdHIycnN0cl91dGY4KGQpKSk7IH1cbmZ1bmN0aW9uIGI2NF9obWFjX21kNShrLCBkKVxuICB7IHJldHVybiByc3RyMmI2NChyc3RyX2htYWNfbWQ1KHN0cjJyc3RyX3V0ZjgoayksIHN0cjJyc3RyX3V0ZjgoZCkpKTsgfVxuZnVuY3Rpb24gYW55X2htYWNfbWQ1KGssIGQsIGUpXG4gIHsgcmV0dXJuIHJzdHIyYW55KHJzdHJfaG1hY19tZDUoc3RyMnJzdHJfdXRmOChrKSwgc3RyMnJzdHJfdXRmOChkKSksIGUpOyB9XG5cbi8qXG4gKiBQZXJmb3JtIGEgc2ltcGxlIHNlbGYtdGVzdCB0byBzZWUgaWYgdGhlIFZNIGlzIHdvcmtpbmdcbiAqL1xuZnVuY3Rpb24gbWQ1X3ZtX3Rlc3QoKVxue1xuICByZXR1cm4gaGV4X21kNShcImFiY1wiKS50b0xvd2VyQ2FzZSgpID09IFwiOTAwMTUwOTgzY2QyNGZiMGQ2OTYzZjdkMjhlMTdmNzJcIjtcbn1cblxuLypcbiAqIENhbGN1bGF0ZSB0aGUgTUQ1IG9mIGEgcmF3IHN0cmluZ1xuICovXG5mdW5jdGlvbiByc3RyX21kNShzKVxue1xuICByZXR1cm4gYmlubDJyc3RyKGJpbmxfbWQ1KHJzdHIyYmlubChzKSwgcy5sZW5ndGggKiA4KSk7XG59XG5cbi8qXG4gKiBDYWxjdWxhdGUgdGhlIEhNQUMtTUQ1LCBvZiBhIGtleSBhbmQgc29tZSBkYXRhIChyYXcgc3RyaW5ncylcbiAqL1xuZnVuY3Rpb24gcnN0cl9obWFjX21kNShrZXksIGRhdGEpXG57XG4gIHZhciBia2V5ID0gcnN0cjJiaW5sKGtleSk7XG4gIGlmKGJrZXkubGVuZ3RoID4gMTYpIGJrZXkgPSBiaW5sX21kNShia2V5LCBrZXkubGVuZ3RoICogOCk7XG5cbiAgdmFyIGlwYWQgPSBBcnJheSgxNiksIG9wYWQgPSBBcnJheSgxNik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICB7XG4gICAgaXBhZFtpXSA9IGJrZXlbaV0gXiAweDM2MzYzNjM2O1xuICAgIG9wYWRbaV0gPSBia2V5W2ldIF4gMHg1QzVDNUM1QztcbiAgfVxuXG4gIHZhciBoYXNoID0gYmlubF9tZDUoaXBhZC5jb25jYXQocnN0cjJiaW5sKGRhdGEpKSwgNTEyICsgZGF0YS5sZW5ndGggKiA4KTtcbiAgcmV0dXJuIGJpbmwycnN0cihiaW5sX21kNShvcGFkLmNvbmNhdChoYXNoKSwgNTEyICsgMTI4KSk7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGEgcmF3IHN0cmluZyB0byBhIGhleCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gcnN0cjJoZXgoaW5wdXQpXG57XG4gIHRyeSB7IGhleGNhc2UgfSBjYXRjaChlKSB7IGhleGNhc2U9MDsgfVxuICB2YXIgaGV4X3RhYiA9IGhleGNhc2UgPyBcIjAxMjM0NTY3ODlBQkNERUZcIiA6IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgdmFyIHg7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKylcbiAge1xuICAgIHggPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xuICAgIG91dHB1dCArPSBoZXhfdGFiLmNoYXJBdCgoeCA+Pj4gNCkgJiAweDBGKVxuICAgICAgICAgICArICBoZXhfdGFiLmNoYXJBdCggeCAgICAgICAgJiAweDBGKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKlxuICogQ29udmVydCBhIHJhdyBzdHJpbmcgdG8gYSBiYXNlLTY0IHN0cmluZ1xuICovXG5mdW5jdGlvbiByc3RyMmI2NChpbnB1dClcbntcbiAgdHJ5IHsgYjY0cGFkIH0gY2F0Y2goZSkgeyBiNjRwYWQ9Jyc7IH1cbiAgdmFyIHRhYiA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xuICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgdmFyIGxlbiA9IGlucHV0Lmxlbmd0aDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAzKVxuICB7XG4gICAgdmFyIHRyaXBsZXQgPSAoaW5wdXQuY2hhckNvZGVBdChpKSA8PCAxNilcbiAgICAgICAgICAgICAgICB8IChpICsgMSA8IGxlbiA/IGlucHV0LmNoYXJDb2RlQXQoaSsxKSA8PCA4IDogMClcbiAgICAgICAgICAgICAgICB8IChpICsgMiA8IGxlbiA/IGlucHV0LmNoYXJDb2RlQXQoaSsyKSAgICAgIDogMCk7XG4gICAgZm9yKHZhciBqID0gMDsgaiA8IDQ7IGorKylcbiAgICB7XG4gICAgICBpZihpICogOCArIGogKiA2ID4gaW5wdXQubGVuZ3RoICogOCkgb3V0cHV0ICs9IGI2NHBhZDtcbiAgICAgIGVsc2Ugb3V0cHV0ICs9IHRhYi5jaGFyQXQoKHRyaXBsZXQgPj4+IDYqKDMtaikpICYgMHgzRik7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGEgcmF3IHN0cmluZyB0byBhbiBhcmJpdHJhcnkgc3RyaW5nIGVuY29kaW5nXG4gKi9cbmZ1bmN0aW9uIHJzdHIyYW55KGlucHV0LCBlbmNvZGluZylcbntcbiAgdmFyIGRpdmlzb3IgPSBlbmNvZGluZy5sZW5ndGg7XG4gIHZhciBpLCBqLCBxLCB4LCBxdW90aWVudDtcblxuICAvKiBDb252ZXJ0IHRvIGFuIGFycmF5IG9mIDE2LWJpdCBiaWctZW5kaWFuIHZhbHVlcywgZm9ybWluZyB0aGUgZGl2aWRlbmQgKi9cbiAgdmFyIGRpdmlkZW5kID0gQXJyYXkoTWF0aC5jZWlsKGlucHV0Lmxlbmd0aCAvIDIpKTtcbiAgZm9yKGkgPSAwOyBpIDwgZGl2aWRlbmQubGVuZ3RoOyBpKyspXG4gIHtcbiAgICBkaXZpZGVuZFtpXSA9IChpbnB1dC5jaGFyQ29kZUF0KGkgKiAyKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQoaSAqIDIgKyAxKTtcbiAgfVxuXG4gIC8qXG4gICAqIFJlcGVhdGVkbHkgcGVyZm9ybSBhIGxvbmcgZGl2aXNpb24uIFRoZSBiaW5hcnkgYXJyYXkgZm9ybXMgdGhlIGRpdmlkZW5kLFxuICAgKiB0aGUgbGVuZ3RoIG9mIHRoZSBlbmNvZGluZyBpcyB0aGUgZGl2aXNvci4gT25jZSBjb21wdXRlZCwgdGhlIHF1b3RpZW50XG4gICAqIGZvcm1zIHRoZSBkaXZpZGVuZCBmb3IgdGhlIG5leHQgc3RlcC4gQWxsIHJlbWFpbmRlcnMgYXJlIHN0b3JlZCBmb3IgbGF0ZXJcbiAgICogdXNlLlxuICAgKi9cbiAgdmFyIGZ1bGxfbGVuZ3RoID0gTWF0aC5jZWlsKGlucHV0Lmxlbmd0aCAqIDggL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKE1hdGgubG9nKGVuY29kaW5nLmxlbmd0aCkgLyBNYXRoLmxvZygyKSkpO1xuICB2YXIgcmVtYWluZGVycyA9IEFycmF5KGZ1bGxfbGVuZ3RoKTtcbiAgZm9yKGogPSAwOyBqIDwgZnVsbF9sZW5ndGg7IGorKylcbiAge1xuICAgIHF1b3RpZW50ID0gQXJyYXkoKTtcbiAgICB4ID0gMDtcbiAgICBmb3IoaSA9IDA7IGkgPCBkaXZpZGVuZC5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICB4ID0gKHggPDwgMTYpICsgZGl2aWRlbmRbaV07XG4gICAgICBxID0gTWF0aC5mbG9vcih4IC8gZGl2aXNvcik7XG4gICAgICB4IC09IHEgKiBkaXZpc29yO1xuICAgICAgaWYocXVvdGllbnQubGVuZ3RoID4gMCB8fCBxID4gMClcbiAgICAgICAgcXVvdGllbnRbcXVvdGllbnQubGVuZ3RoXSA9IHE7XG4gICAgfVxuICAgIHJlbWFpbmRlcnNbal0gPSB4O1xuICAgIGRpdmlkZW5kID0gcXVvdGllbnQ7XG4gIH1cblxuICAvKiBDb252ZXJ0IHRoZSByZW1haW5kZXJzIHRvIHRoZSBvdXRwdXQgc3RyaW5nICovXG4gIHZhciBvdXRwdXQgPSBcIlwiO1xuICBmb3IoaSA9IHJlbWFpbmRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgb3V0cHV0ICs9IGVuY29kaW5nLmNoYXJBdChyZW1haW5kZXJzW2ldKTtcblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKlxuICogRW5jb2RlIGEgc3RyaW5nIGFzIHV0Zi04LlxuICogRm9yIGVmZmljaWVuY3ksIHRoaXMgYXNzdW1lcyB0aGUgaW5wdXQgaXMgdmFsaWQgdXRmLTE2LlxuICovXG5mdW5jdGlvbiBzdHIycnN0cl91dGY4KGlucHV0KVxue1xuICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgdmFyIGkgPSAtMTtcbiAgdmFyIHgsIHk7XG5cbiAgd2hpbGUoKytpIDwgaW5wdXQubGVuZ3RoKVxuICB7XG4gICAgLyogRGVjb2RlIHV0Zi0xNiBzdXJyb2dhdGUgcGFpcnMgKi9cbiAgICB4ID0gaW5wdXQuY2hhckNvZGVBdChpKTtcbiAgICB5ID0gaSArIDEgPCBpbnB1dC5sZW5ndGggPyBpbnB1dC5jaGFyQ29kZUF0KGkgKyAxKSA6IDA7XG4gICAgaWYoMHhEODAwIDw9IHggJiYgeCA8PSAweERCRkYgJiYgMHhEQzAwIDw9IHkgJiYgeSA8PSAweERGRkYpXG4gICAge1xuICAgICAgeCA9IDB4MTAwMDAgKyAoKHggJiAweDAzRkYpIDw8IDEwKSArICh5ICYgMHgwM0ZGKTtcbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICAvKiBFbmNvZGUgb3V0cHV0IGFzIHV0Zi04ICovXG4gICAgaWYoeCA8PSAweDdGKVxuICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoeCk7XG4gICAgZWxzZSBpZih4IDw9IDB4N0ZGKVxuICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhDMCB8ICgoeCA+Pj4gNiApICYgMHgxRiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKCB4ICAgICAgICAgJiAweDNGKSk7XG4gICAgZWxzZSBpZih4IDw9IDB4RkZGRilcbiAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RTAgfCAoKHggPj4+IDEyKSAmIDB4MEYpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoeCA+Pj4gNiApICYgMHgzRiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKCB4ICAgICAgICAgJiAweDNGKSk7XG4gICAgZWxzZSBpZih4IDw9IDB4MUZGRkZGKVxuICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGMCB8ICgoeCA+Pj4gMTgpICYgMHgwNyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKCh4ID4+PiAxMikgJiAweDNGKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKHggPj4+IDYgKSAmIDB4M0YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICggeCAgICAgICAgICYgMHgzRikpO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qXG4gKiBFbmNvZGUgYSBzdHJpbmcgYXMgdXRmLTE2XG4gKi9cbmZ1bmN0aW9uIHN0cjJyc3RyX3V0ZjE2bGUoaW5wdXQpXG57XG4gIHZhciBvdXRwdXQgPSBcIlwiO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspXG4gICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoIGlucHV0LmNoYXJDb2RlQXQoaSkgICAgICAgICYgMHhGRixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaW5wdXQuY2hhckNvZGVBdChpKSA+Pj4gOCkgJiAweEZGKTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gc3RyMnJzdHJfdXRmMTZiZShpbnB1dClcbntcbiAgdmFyIG91dHB1dCA9IFwiXCI7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKylcbiAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoaW5wdXQuY2hhckNvZGVBdChpKSA+Pj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5jaGFyQ29kZUF0KGkpICAgICAgICAmIDB4RkYpO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKlxuICogQ29udmVydCBhIHJhdyBzdHJpbmcgdG8gYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3Jkc1xuICogQ2hhcmFjdGVycyA+MjU1IGhhdmUgdGhlaXIgaGlnaC1ieXRlIHNpbGVudGx5IGlnbm9yZWQuXG4gKi9cbmZ1bmN0aW9uIHJzdHIyYmlubChpbnB1dClcbntcbiAgdmFyIG91dHB1dCA9IEFycmF5KGlucHV0Lmxlbmd0aCA+PiAyKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IG91dHB1dC5sZW5ndGg7IGkrKylcbiAgICBvdXRwdXRbaV0gPSAwO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoICogODsgaSArPSA4KVxuICAgIG91dHB1dFtpPj41XSB8PSAoaW5wdXQuY2hhckNvZGVBdChpIC8gOCkgJiAweEZGKSA8PCAoaSUzMik7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMgdG8gYSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gYmlubDJyc3RyKGlucHV0KVxue1xuICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aCAqIDMyOyBpICs9IDgpXG4gICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGlucHV0W2k+PjVdID4+PiAoaSAlIDMyKSkgJiAweEZGKTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLypcbiAqIENhbGN1bGF0ZSB0aGUgTUQ1IG9mIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIGJpbmxfbWQ1KHgsIGxlbilcbntcbiAgLyogYXBwZW5kIHBhZGRpbmcgKi9cbiAgeFtsZW4gPj4gNV0gfD0gMHg4MCA8PCAoKGxlbikgJSAzMik7XG4gIHhbKCgobGVuICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IGxlbjtcblxuICB2YXIgYSA9ICAxNzMyNTg0MTkzO1xuICB2YXIgYiA9IC0yNzE3MzM4Nzk7XG4gIHZhciBjID0gLTE3MzI1ODQxOTQ7XG4gIHZhciBkID0gIDI3MTczMzg3ODtcblxuICBmb3IodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkgKz0gMTYpXG4gIHtcbiAgICB2YXIgb2xkYSA9IGE7XG4gICAgdmFyIG9sZGIgPSBiO1xuICAgIHZhciBvbGRjID0gYztcbiAgICB2YXIgb2xkZCA9IGQ7XG5cbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsgMF0sIDcgLCAtNjgwODc2OTM2KTtcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsgMV0sIDEyLCAtMzg5NTY0NTg2KTtcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsgMl0sIDE3LCAgNjA2MTA1ODE5KTtcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsgM10sIDIyLCAtMTA0NDUyNTMzMCk7XG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krIDRdLCA3ICwgLTE3NjQxODg5Nyk7XG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krIDVdLCAxMiwgIDEyMDAwODA0MjYpO1xuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKyA2XSwgMTcsIC0xNDczMjMxMzQxKTtcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsgN10sIDIyLCAtNDU3MDU5ODMpO1xuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKyA4XSwgNyAsICAxNzcwMDM1NDE2KTtcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsgOV0sIDEyLCAtMTk1ODQxNDQxNyk7XG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krMTBdLCAxNywgLTQyMDYzKTtcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsxMV0sIDIyLCAtMTk5MDQwNDE2Mik7XG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krMTJdLCA3ICwgIDE4MDQ2MDM2ODIpO1xuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKzEzXSwgMTIsIC00MDM0MTEwMSk7XG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krMTRdLCAxNywgLTE1MDIwMDIyOTApO1xuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKzE1XSwgMjIsICAxMjM2NTM1MzI5KTtcblxuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKyAxXSwgNSAsIC0xNjU3OTY1MTApO1xuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKyA2XSwgOSAsIC0xMDY5NTAxNjMyKTtcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsxMV0sIDE0LCAgNjQzNzE3NzEzKTtcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsgMF0sIDIwLCAtMzczODk3MzAyKTtcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsgNV0sIDUgLCAtNzAxNTU4NjkxKTtcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsxMF0sIDkgLCAgMzgwMTYwODMpO1xuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKzE1XSwgMTQsIC02NjA0NzgzMzUpO1xuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyA0XSwgMjAsIC00MDU1Mzc4NDgpO1xuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKyA5XSwgNSAsICA1Njg0NDY0MzgpO1xuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKzE0XSwgOSAsIC0xMDE5ODAzNjkwKTtcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsgM10sIDE0LCAtMTg3MzYzOTYxKTtcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsgOF0sIDIwLCAgMTE2MzUzMTUwMSk7XG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krMTNdLCA1ICwgLTE0NDQ2ODE0NjcpO1xuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKyAyXSwgOSAsIC01MTQwMzc4NCk7XG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krIDddLCAxNCwgIDE3MzUzMjg0NzMpO1xuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKzEyXSwgMjAsIC0xOTI2NjA3NzM0KTtcblxuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyA1XSwgNCAsIC0zNzg1NTgpO1xuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKyA4XSwgMTEsIC0yMDIyNTc0NDYzKTtcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsxMV0sIDE2LCAgMTgzOTAzMDU2Mik7XG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krMTRdLCAyMywgLTM1MzA5NTU2KTtcbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsgMV0sIDQgLCAtMTUzMDk5MjA2MCk7XG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krIDRdLCAxMSwgIDEyNzI4OTMzNTMpO1xuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKyA3XSwgMTYsIC0xNTU0OTc2MzIpO1xuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKzEwXSwgMjMsIC0xMDk0NzMwNjQwKTtcbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsxM10sIDQgLCAgNjgxMjc5MTc0KTtcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsgMF0sIDExLCAtMzU4NTM3MjIyKTtcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsgM10sIDE2LCAtNzIyNTIxOTc5KTtcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsgNl0sIDIzLCAgNzYwMjkxODkpO1xuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyA5XSwgNCAsIC02NDAzNjQ0ODcpO1xuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKzEyXSwgMTEsIC00MjE4MTU4MzUpO1xuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKzE1XSwgMTYsICA1MzA3NDI1MjApO1xuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKyAyXSwgMjMsIC05OTUzMzg2NTEpO1xuXG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krIDBdLCA2ICwgLTE5ODYzMDg0NCk7XG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krIDddLCAxMCwgIDExMjY4OTE0MTUpO1xuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKzE0XSwgMTUsIC0xNDE2MzU0OTA1KTtcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsgNV0sIDIxLCAtNTc0MzQwNTUpO1xuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKzEyXSwgNiAsICAxNzAwNDg1NTcxKTtcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsgM10sIDEwLCAtMTg5NDk4NjYwNik7XG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krMTBdLCAxNSwgLTEwNTE1MjMpO1xuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKyAxXSwgMjEsIC0yMDU0OTIyNzk5KTtcbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsgOF0sIDYgLCAgMTg3MzMxMzM1OSk7XG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krMTVdLCAxMCwgLTMwNjExNzQ0KTtcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsgNl0sIDE1LCAtMTU2MDE5ODM4MCk7XG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krMTNdLCAyMSwgIDEzMDkxNTE2NDkpO1xuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKyA0XSwgNiAsIC0xNDU1MjMwNzApO1xuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKzExXSwgMTAsIC0xMTIwMjEwMzc5KTtcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsgMl0sIDE1LCAgNzE4Nzg3MjU5KTtcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsgOV0sIDIxLCAtMzQzNDg1NTUxKTtcblxuICAgIGEgPSBzYWZlX2FkZChhLCBvbGRhKTtcbiAgICBiID0gc2FmZV9hZGQoYiwgb2xkYik7XG4gICAgYyA9IHNhZmVfYWRkKGMsIG9sZGMpO1xuICAgIGQgPSBzYWZlX2FkZChkLCBvbGRkKTtcbiAgfVxuICByZXR1cm4gQXJyYXkoYSwgYiwgYywgZCk7XG59XG5cbi8qXG4gKiBUaGVzZSBmdW5jdGlvbnMgaW1wbGVtZW50IHRoZSBmb3VyIGJhc2ljIG9wZXJhdGlvbnMgdGhlIGFsZ29yaXRobSB1c2VzLlxuICovXG5mdW5jdGlvbiBtZDVfY21uKHEsIGEsIGIsIHgsIHMsIHQpXG57XG4gIHJldHVybiBzYWZlX2FkZChiaXRfcm9sKHNhZmVfYWRkKHNhZmVfYWRkKGEsIHEpLCBzYWZlX2FkZCh4LCB0KSksIHMpLGIpO1xufVxuZnVuY3Rpb24gbWQ1X2ZmKGEsIGIsIGMsIGQsIHgsIHMsIHQpXG57XG4gIHJldHVybiBtZDVfY21uKChiICYgYykgfCAoKH5iKSAmIGQpLCBhLCBiLCB4LCBzLCB0KTtcbn1cbmZ1bmN0aW9uIG1kNV9nZyhhLCBiLCBjLCBkLCB4LCBzLCB0KVxue1xuICByZXR1cm4gbWQ1X2NtbigoYiAmIGQpIHwgKGMgJiAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG59XG5mdW5jdGlvbiBtZDVfaGgoYSwgYiwgYywgZCwgeCwgcywgdClcbntcbiAgcmV0dXJuIG1kNV9jbW4oYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTtcbn1cbmZ1bmN0aW9uIG1kNV9paShhLCBiLCBjLCBkLCB4LCBzLCB0KVxue1xuICByZXR1cm4gbWQ1X2NtbihjIF4gKGIgfCAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG59XG5cbi8qXG4gKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XG4gKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLlxuICovXG5mdW5jdGlvbiBzYWZlX2FkZCh4LCB5KVxue1xuICB2YXIgbHN3ID0gKHggJiAweEZGRkYpICsgKHkgJiAweEZGRkYpO1xuICB2YXIgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gIHJldHVybiAobXN3IDw8IDE2KSB8IChsc3cgJiAweEZGRkYpO1xufVxuXG4vKlxuICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxuICovXG5mdW5jdGlvbiBiaXRfcm9sKG51bSwgY250KVxue1xuICByZXR1cm4gKG51bSA8PCBjbnQpIHwgKG51bSA+Pj4gKDMyIC0gY250KSk7XG59XG5cblxuZXhwb3J0cy5oZXhfbWQ1ID0gaGV4X21kNTtcbmV4cG9ydHMuYjY0X21kNSA9IGI2NF9tZDU7XG5leHBvcnRzLmFueV9tZDUgPSBhbnlfbWQ1O1xuIiwiLypcbiBUaGlzIGlzIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgSlNPTiBPVCB0eXBlLlxuXG4gU3BlYyBpcyBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vam9zZXBoZy9TaGFyZUpTL3dpa2kvSlNPTi1PcGVyYXRpb25zXG5cbiBOb3RlOiBUaGlzIGlzIGJlaW5nIG1hZGUgb2Jzb2xldGUuIEl0IHdpbGwgc29vbiBiZSByZXBsYWNlZCBieSB0aGUgSlNPTjIgdHlwZS5cbiovXG5cbi8qKlxuICogVVRJTElUWSBGVU5DVElPTlNcbiAqL1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcGFzc2VkIG9iamVjdCBpcyBhbiBBcnJheSBpbnN0YW5jZS4gQ2FuJ3QgdXNlIEFycmF5LmlzQXJyYXlcbiAqIHlldCBiZWNhdXNlIGl0cyBub3Qgc3VwcG9ydGVkIG9uIElFOC5cbiAqXG4gKiBAcGFyYW0gb2JqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xudmFyIGlzQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG4vKipcbiAqIENsb25lcyB0aGUgcGFzc2VkIG9iamVjdCB1c2luZyBKU09OIHNlcmlhbGl6YXRpb24gKHdoaWNoIGlzIHNsb3cpLlxuICpcbiAqIGhheCwgY29waWVkIGZyb20gdGVzdC90eXBlcy9qc29uLiBBcHBhcmVudGx5IHRoaXMgaXMgc3RpbGwgdGhlIGZhc3Rlc3Qgd2F5XG4gKiB0byBkZWVwIGNsb25lIGFuIG9iamVjdCwgYXNzdW1pbmcgd2UgaGF2ZSBicm93c2VyIHN1cHBvcnQgZm9yIEpTT04uICBAc2VlXG4gKiBodHRwOi8vanNwZXJmLmNvbS9jbG9uaW5nLWFuLW9iamVjdC8xMlxuICovXG52YXIgY2xvbmUgPSBmdW5jdGlvbihvKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG8pKTtcbn07XG5cblxuXG4vKipcbiAqIFJlZmVyZW5jZSB0byB0aGUgVGV4dCBPVCB0eXBlLiBUaGlzIGlzIHVzZWQgZm9yIHRoZSBKU09OIFN0cmluZyBvcGVyYXRpb25zLlxuICogQHR5cGUgeyp9XG4gKi9cbnZhciB0ZXh0ID0gdHlwZW9mIHJlcXVpcmUgIT09IFwidW5kZWZpbmVkXCIgPyByZXF1aXJlKCcuL3RleHQtb2xkJykgOiB3aW5kb3cub3R0eXBlcy50ZXh0O1xuXG5cblxuLyoqXG4gKiBKU09OIE9UIFR5cGVcbiAqIEB0eXBlIHsqfVxuICovXG52YXIganNvbiA9IHsgXG4gIG5hbWU6ICdqc29uMCcsXG4gIHVyaTogJ2h0dHA6Ly9zaGFyZWpzLm9yZy90eXBlcy9KU09OdjAnXG59O1xuXG5qc29uLmNyZWF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgLy8gTnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZCBpZiB5b3UgZG9uJ3QgcGFzcyBhbiBhcmd1bWVudC5cbiAgcmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkYXRhO1xufTtcblxuanNvbi5pbnZlcnRDb21wb25lbnQgPSBmdW5jdGlvbihjKSB7XG4gIHZhciBjXyA9IHtwOiBjLnB9O1xuXG4gIGlmIChjLnNpICE9PSB2b2lkIDApIGNfLnNkID0gYy5zaTtcbiAgaWYgKGMuc2QgIT09IHZvaWQgMCkgY18uc2kgPSBjLnNkO1xuICBpZiAoYy5vaSAhPT0gdm9pZCAwKSBjXy5vZCA9IGMub2k7XG4gIGlmIChjLm9kICE9PSB2b2lkIDApIGNfLm9pID0gYy5vZDtcbiAgaWYgKGMubGkgIT09IHZvaWQgMCkgY18ubGQgPSBjLmxpO1xuICBpZiAoYy5sZCAhPT0gdm9pZCAwKSBjXy5saSA9IGMubGQ7XG4gIGlmIChjLm5hICE9PSB2b2lkIDApIGNfLm5hID0gLWMubmE7XG5cbiAgaWYgKGMubG0gIT09IHZvaWQgMCkge1xuICAgIGNfLmxtID0gYy5wW2MucC5sZW5ndGgtMV07XG4gICAgY18ucCA9IGMucC5zbGljZSgwLGMucC5sZW5ndGgtMSkuY29uY2F0KFtjLmxtXSk7XG4gIH1cblxuICByZXR1cm4gY187XG59O1xuXG5qc29uLmludmVydCA9IGZ1bmN0aW9uKG9wKSB7XG4gIHZhciBvcF8gPSBvcC5zbGljZSgpLnJldmVyc2UoKTtcbiAgdmFyIGlvcCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wXy5sZW5ndGg7IGkrKykge1xuICAgIGlvcC5wdXNoKGpzb24uaW52ZXJ0Q29tcG9uZW50KG9wX1tpXSkpO1xuICB9XG4gIHJldHVybiBpb3A7XG59O1xuXG5qc29uLmNoZWNrVmFsaWRPcCA9IGZ1bmN0aW9uKG9wKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3AubGVuZ3RoOyBpKyspIHtcbiAgaWYgKCFpc0FycmF5KG9wW2ldLnApKVxuICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwYXRoJyk7XG4gIH1cbn07XG5cbmpzb24uY2hlY2tMaXN0ID0gZnVuY3Rpb24oZWxlbSkge1xuICBpZiAoIWlzQXJyYXkoZWxlbSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZWZlcmVuY2VkIGVsZW1lbnQgbm90IGEgbGlzdCcpO1xufTtcblxuanNvbi5jaGVja09iaiA9IGZ1bmN0aW9uKGVsZW0pIHtcbiAgaWYgKGVsZW0uY29uc3RydWN0b3IgIT09IE9iamVjdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlJlZmVyZW5jZWQgZWxlbWVudCBub3QgYW4gb2JqZWN0IChpdCB3YXMgXCIgKyBKU09OLnN0cmluZ2lmeShlbGVtKSArIFwiKVwiKTtcbiAgfVxufTtcblxuanNvbi5hcHBseSA9IGZ1bmN0aW9uKHNuYXBzaG90LCBvcCkge1xuICBqc29uLmNoZWNrVmFsaWRPcChvcCk7XG5cbiAgb3AgPSBjbG9uZShvcCk7XG5cbiAgdmFyIGNvbnRhaW5lciA9IHtcbiAgICBkYXRhOiBzbmFwc2hvdFxuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3AubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYyA9IG9wW2ldO1xuXG4gICAgdmFyIHBhcmVudCA9IG51bGw7XG4gICAgdmFyIHBhcmVudEtleSA9IG51bGw7XG4gICAgdmFyIGVsZW0gPSBjb250YWluZXI7XG4gICAgdmFyIGtleSA9ICdkYXRhJztcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYy5wLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcCA9IGMucFtqXTtcblxuICAgICAgcGFyZW50ID0gZWxlbTtcbiAgICAgIHBhcmVudEtleSA9IGtleTtcbiAgICAgIGVsZW0gPSBlbGVtW2tleV07XG4gICAgICBrZXkgPSBwO1xuXG4gICAgICBpZiAocGFyZW50ID09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGF0aCBpbnZhbGlkJyk7XG4gICAgfVxuXG4gICAgLy8gTnVtYmVyIGFkZFxuICAgIGlmIChjLm5hICE9PSB2b2lkIDApIHtcbiAgICAgIGlmICh0eXBlb2YgZWxlbVtrZXldICE9ICdudW1iZXInKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZmVyZW5jZWQgZWxlbWVudCBub3QgYSBudW1iZXInKTtcblxuICAgICAgZWxlbVtrZXldICs9IGMubmE7XG4gICAgfVxuXG4gICAgLy8gU3RyaW5nIGluc2VydFxuICAgIGVsc2UgaWYgKGMuc2kgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHR5cGVvZiBlbGVtICE9ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZmVyZW5jZWQgZWxlbWVudCBub3QgYSBzdHJpbmcgKGl0IHdhcyAnK0pTT04uc3RyaW5naWZ5KGVsZW0pKycpJyk7XG5cbiAgICAgIHBhcmVudFtwYXJlbnRLZXldID0gZWxlbS5zbGljZSgwLGtleSkgKyBjLnNpICsgZWxlbS5zbGljZShrZXkpO1xuICAgIH1cblxuICAgIC8vIFN0cmluZyBkZWxldGVcbiAgICBlbHNlIGlmIChjLnNkICE9PSB2b2lkIDApIHtcbiAgICAgIGlmICh0eXBlb2YgZWxlbSAhPSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWZlcmVuY2VkIGVsZW1lbnQgbm90IGEgc3RyaW5nJyk7XG5cbiAgICAgIGlmIChlbGVtLnNsaWNlKGtleSxrZXkgKyBjLnNkLmxlbmd0aCkgIT09IGMuc2QpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVsZXRlZCBzdHJpbmcgZG9lcyBub3QgbWF0Y2gnKTtcblxuICAgICAgcGFyZW50W3BhcmVudEtleV0gPSBlbGVtLnNsaWNlKDAsa2V5KSArIGVsZW0uc2xpY2Uoa2V5ICsgYy5zZC5sZW5ndGgpO1xuICAgIH1cblxuICAgIC8vIExpc3QgcmVwbGFjZVxuICAgIGVsc2UgaWYgKGMubGkgIT09IHZvaWQgMCAmJiBjLmxkICE9PSB2b2lkIDApIHtcbiAgICAgIGpzb24uY2hlY2tMaXN0KGVsZW0pO1xuICAgICAgLy8gU2hvdWxkIGNoZWNrIHRoZSBsaXN0IGVsZW1lbnQgbWF0Y2hlcyBjLmxkXG4gICAgICBlbGVtW2tleV0gPSBjLmxpO1xuICAgIH1cblxuICAgIC8vIExpc3QgaW5zZXJ0XG4gICAgZWxzZSBpZiAoYy5saSAhPT0gdm9pZCAwKSB7XG4gICAgICBqc29uLmNoZWNrTGlzdChlbGVtKTtcbiAgICAgIGVsZW0uc3BsaWNlKGtleSwwLCBjLmxpKTtcbiAgICB9XG5cbiAgICAvLyBMaXN0IGRlbGV0ZVxuICAgIGVsc2UgaWYgKGMubGQgIT09IHZvaWQgMCkge1xuICAgICAganNvbi5jaGVja0xpc3QoZWxlbSk7XG4gICAgICAvLyBTaG91bGQgY2hlY2sgdGhlIGxpc3QgZWxlbWVudCBtYXRjaGVzIGMubGQgaGVyZSB0b28uXG4gICAgICBlbGVtLnNwbGljZShrZXksMSk7XG4gICAgfVxuXG4gICAgLy8gTGlzdCBtb3ZlXG4gICAgZWxzZSBpZiAoYy5sbSAhPT0gdm9pZCAwKSB7XG4gICAgICBqc29uLmNoZWNrTGlzdChlbGVtKTtcbiAgICAgIGlmIChjLmxtICE9IGtleSkge1xuICAgICAgICB2YXIgZSA9IGVsZW1ba2V5XTtcbiAgICAgICAgLy8gUmVtb3ZlIGl0Li4uXG4gICAgICAgIGVsZW0uc3BsaWNlKGtleSwxKTtcbiAgICAgICAgLy8gQW5kIGluc2VydCBpdCBiYWNrLlxuICAgICAgICBlbGVtLnNwbGljZShjLmxtLDAsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT2JqZWN0IGluc2VydCAvIHJlcGxhY2VcbiAgICBlbHNlIGlmIChjLm9pICE9PSB2b2lkIDApIHtcbiAgICAgIGpzb24uY2hlY2tPYmooZWxlbSk7XG5cbiAgICAgIC8vIFNob3VsZCBjaGVjayB0aGF0IGVsZW1ba2V5XSA9PSBjLm9kXG4gICAgICBlbGVtW2tleV0gPSBjLm9pO1xuICAgIH1cblxuICAgIC8vIE9iamVjdCBkZWxldGVcbiAgICBlbHNlIGlmIChjLm9kICE9PSB2b2lkIDApIHtcbiAgICAgIGpzb24uY2hlY2tPYmooZWxlbSk7XG5cbiAgICAgIC8vIFNob3VsZCBjaGVjayB0aGF0IGVsZW1ba2V5XSA9PSBjLm9kXG4gICAgICBkZWxldGUgZWxlbVtrZXldO1xuICAgIH1cblxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIC8gbWlzc2luZyBpbnN0cnVjdGlvbiBpbiBvcCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb250YWluZXIuZGF0YTtcbn07XG5cbi8vIEhlbHBlciBmb3IgaW5jcmVtZW50YWxseSBhcHBseWluZyBhbiBvcGVyYXRpb24gdG8gYSBzbmFwc2hvdC4gQ2FsbHMgeWllbGRcbi8vIGFmdGVyIGVhY2ggb3AgY29tcG9uZW50IGhhcyBiZWVuIGFwcGxpZWQuXG5qc29uLmluY3JlbWVudGFsQXBwbHkgPSBmdW5jdGlvbihzbmFwc2hvdCwgb3AsIF95aWVsZCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNtYWxsT3AgPSBbb3BbaV1dO1xuICAgIHNuYXBzaG90ID0ganNvbi5hcHBseShzbmFwc2hvdCwgc21hbGxPcCk7XG4gICAgLy8gSSdkIGp1c3QgY2FsbCB0aGlzIHlpZWxkLCBidXQgdGhhdHMgYSByZXNlcnZlZCBrZXl3b3JkLiBCYWghXG4gICAgX3lpZWxkKHNtYWxsT3AsIHNuYXBzaG90KTtcbiAgfVxuICBcbiAgcmV0dXJuIHNuYXBzaG90O1xufTtcblxuLy8gQ2hlY2tzIGlmIHR3byBwYXRocywgcDEgYW5kIHAyIG1hdGNoLlxudmFyIHBhdGhNYXRjaGVzID0ganNvbi5wYXRoTWF0Y2hlcyA9IGZ1bmN0aW9uKHAxLCBwMiwgaWdub3JlTGFzdCkge1xuICBpZiAocDEubGVuZ3RoICE9IHAyLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwMS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwMVtpXSAhPT0gcDJbaV0gJiYgKCFpZ25vcmVMYXN0IHx8IGkgIT09IHAxLmxlbmd0aCAtIDEpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgX2NvbnZlcnRUb1RleHRDb21wb25lbnQgPSBmdW5jdGlvbihjb21wb25lbnQpIHtcbiAgdmFyIG5ld0MgPSB7cDogY29tcG9uZW50LnBbY29tcG9uZW50LnAubGVuZ3RoIC0gMV19O1xuICBpZiAoY29tcG9uZW50LnNpICE9IG51bGwpIHtcbiAgICBuZXdDLmkgPSBjb21wb25lbnQuc2k7XG4gIH0gZWxzZSB7XG4gICAgbmV3Qy5kID0gY29tcG9uZW50LnNkO1xuICB9XG4gIHJldHVybiBuZXdDO1xufTtcblxuanNvbi5hcHBlbmQgPSBmdW5jdGlvbihkZXN0LGMpIHtcbiAgYyA9IGNsb25lKGMpO1xuXG4gIHZhciBsYXN0O1xuXG4gIGlmIChkZXN0Lmxlbmd0aCAhPSAwICYmIHBhdGhNYXRjaGVzKGMucCwgKGxhc3QgPSBkZXN0W2Rlc3QubGVuZ3RoIC0gMV0pLnApKSB7XG4gICAgaWYgKGxhc3QubmEgIT0gbnVsbCAmJiBjLm5hICE9IG51bGwpIHtcbiAgICAgIGRlc3RbZGVzdC5sZW5ndGggLSAxXSA9IHtwOiBsYXN0LnAsIG5hOiBsYXN0Lm5hICsgYy5uYX07XG4gICAgfSBlbHNlIGlmIChsYXN0LmxpICE9PSB1bmRlZmluZWQgJiYgYy5saSA9PT0gdW5kZWZpbmVkICYmIGMubGQgPT09IGxhc3QubGkpIHtcbiAgICAgIC8vIGluc2VydCBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBkZWxldGUgYmVjb21lcyBhIG5vb3AuXG4gICAgICBpZiAobGFzdC5sZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGxlYXZlIHRoZSBkZWxldGUgcGFydCBvZiB0aGUgcmVwbGFjZVxuICAgICAgICBkZWxldGUgbGFzdC5saTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlc3QucG9wKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsYXN0Lm9kICE9PSB1bmRlZmluZWQgJiYgbGFzdC5vaSA9PT0gdW5kZWZpbmVkICYmIGMub2kgIT09IHVuZGVmaW5lZCAmJiBjLm9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxhc3Qub2kgPSBjLm9pO1xuICAgIH0gZWxzZSBpZiAobGFzdC5vaSAhPT0gdW5kZWZpbmVkICYmIGMub2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gVGhlIGxhc3QgcGF0aCBjb21wb25lbnQgaW5zZXJ0ZWQgc29tZXRoaW5nIHRoYXQgdGhlIG5ldyBjb21wb25lbnQgZGVsZXRlcyAob3IgcmVwbGFjZXMpLlxuICAgICAgLy8gSnVzdCBtZXJnZSB0aGVtLlxuICAgICAgaWYgKGMub2kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsYXN0Lm9pID0gYy5vaTtcbiAgICAgIH0gZWxzZSBpZiAobGFzdC5vZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlbGV0ZSBsYXN0Lm9pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQW4gaW5zZXJ0IGRpcmVjdGx5IGZvbGxvd2VkIGJ5IGEgZGVsZXRlIHR1cm5zIGludG8gYSBuby1vcCBhbmQgY2FuIGJlIHJlbW92ZWQuXG4gICAgICAgIGRlc3QucG9wKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjLmxtICE9PSB1bmRlZmluZWQgJiYgYy5wW2MucC5sZW5ndGggLSAxXSA9PT0gYy5sbSkge1xuICAgICAgLy8gZG9uJ3QgZG8gYW55dGhpbmdcbiAgICB9IGVsc2Uge1xuICAgICAgZGVzdC5wdXNoKGMpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkZXN0Lmxlbmd0aCAhPSAwICYmIHBhdGhNYXRjaGVzKGMucCwgbGFzdC5wLCB0cnVlKSkge1xuICAgIGlmICgoYy5zaSAhPSBudWxsIHx8IGMuc2QgIT0gbnVsbCkgJiYgKGxhc3Quc2kgIT0gbnVsbCB8fCBsYXN0LnNkICE9IG51bGwpKSB7XG4gICAgICAvLyBUcnkgdG8gY29tcG9zZSB0aGUgc3RyaW5nIG9wcyB0b2dldGhlciB1c2luZyB0ZXh0J3MgZXF1aXZhbGVudCBtZXRob2RzXG4gICAgICB2YXIgdGV4dE9wID0gW19jb252ZXJ0VG9UZXh0Q29tcG9uZW50KGxhc3QpXTtcbiAgICAgIHRleHQuX2FwcGVuZCh0ZXh0T3AsIF9jb252ZXJ0VG9UZXh0Q29tcG9uZW50KGMpKTtcbiAgICAgIFxuICAgICAgLy8gVGhlbiBjb252ZXJ0IGJhY2suXG4gICAgICBpZiAodGV4dE9wLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICBkZXN0LnB1c2goYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGV4dEMgPSB0ZXh0T3BbMF07XG4gICAgICAgIGxhc3QucFtsYXN0LnAubGVuZ3RoIC0gMV0gPSB0ZXh0Qy5wO1xuICAgICAgICBpZiAodGV4dEMuaSAhPSBudWxsKVxuICAgICAgICAgIGxhc3Quc2kgPSB0ZXh0Qy5pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgbGFzdC5zZCA9IHRleHRDLmQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlc3QucHVzaChjKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGVzdC5wdXNoKGMpO1xuICB9XG59O1xuXG5qc29uLmNvbXBvc2UgPSBmdW5jdGlvbihvcDEsb3AyKSB7XG4gIGpzb24uY2hlY2tWYWxpZE9wKG9wMSk7XG4gIGpzb24uY2hlY2tWYWxpZE9wKG9wMik7XG5cbiAgdmFyIG5ld09wID0gY2xvbmUob3AxKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wMi5sZW5ndGg7IGkrKykge1xuICAgIGpzb24uYXBwZW5kKG5ld09wLG9wMltpXSk7XG4gIH1cblxuICByZXR1cm4gbmV3T3A7XG59O1xuXG5qc29uLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG9wKSB7XG4gIHZhciBuZXdPcCA9IFtdO1xuXG4gIG9wID0gaXNBcnJheShvcCkgPyBvcCA6IFtvcF07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjID0gb3BbaV07XG4gICAgaWYgKGMucCA9PSBudWxsKSBjLnAgPSBbXTtcblxuICAgIGpzb24uYXBwZW5kKG5ld09wLGMpO1xuICB9XG5cbiAgcmV0dXJuIG5ld09wO1xufTtcblxuLy8gUmV0dXJucyB0cnVlIGlmIGFuIG9wIGF0IG90aGVyUGF0aCBtYXkgYWZmZWN0IGFuIG9wIGF0IHBhdGhcbmpzb24uY2FuT3BBZmZlY3RPcCA9IGZ1bmN0aW9uKG90aGVyUGF0aCxwYXRoKSB7XG4gIGlmIChvdGhlclBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgcGF0aCA9IHBhdGguc2xpY2UoMCxwYXRoLmxlbmd0aCAtIDEpO1xuICBvdGhlclBhdGggPSBvdGhlclBhdGguc2xpY2UoMCxvdGhlclBhdGgubGVuZ3RoIC0gMSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdGhlclBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcCA9IG90aGVyUGF0aFtpXTtcbiAgICBpZiAoaSA+PSBwYXRoLmxlbmd0aCB8fCBwICE9IHBhdGhbaV0pIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFNhbWVcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyB0cmFuc2Zvcm0gYyBzbyBpdCBhcHBsaWVzIHRvIGEgZG9jdW1lbnQgd2l0aCBvdGhlckMgYXBwbGllZC5cbmpzb24udHJhbnNmb3JtQ29tcG9uZW50ID0gZnVuY3Rpb24oZGVzdCwgYywgb3RoZXJDLCB0eXBlKSB7XG4gIGMgPSBjbG9uZShjKTtcblxuICBpZiAoYy5uYSAhPT0gdm9pZCAwKVxuICAgIGMucC5wdXNoKDApO1xuXG4gIGlmIChvdGhlckMubmEgIT09IHZvaWQgMClcbiAgICBvdGhlckMucC5wdXNoKDApO1xuXG4gIHZhciBjb21tb247XG4gIGlmIChqc29uLmNhbk9wQWZmZWN0T3Aob3RoZXJDLnAsIGMucCkpXG4gICAgY29tbW9uID0gb3RoZXJDLnAubGVuZ3RoIC0gMTtcblxuICB2YXIgY29tbW9uMjtcbiAgaWYgKGpzb24uY2FuT3BBZmZlY3RPcChjLnAsb3RoZXJDLnApKVxuICAgIGNvbW1vbjIgPSBjLnAubGVuZ3RoIC0gMTtcblxuICB2YXIgY3BsZW5ndGggPSBjLnAubGVuZ3RoO1xuICB2YXIgb3RoZXJDcGxlbmd0aCA9IG90aGVyQy5wLmxlbmd0aDtcblxuICBpZiAoYy5uYSAhPT0gdm9pZCAwKSAvLyBoYXhcbiAgICBjLnAucG9wKCk7XG5cbiAgaWYgKG90aGVyQy5uYSAhPT0gdm9pZCAwKVxuICAgIG90aGVyQy5wLnBvcCgpO1xuXG4gIGlmIChvdGhlckMubmEpIHtcbiAgICBpZiAoY29tbW9uMiAhPSBudWxsICYmIG90aGVyQ3BsZW5ndGggPj0gY3BsZW5ndGggJiYgb3RoZXJDLnBbY29tbW9uMl0gPT0gYy5wW2NvbW1vbjJdKSB7XG4gICAgICBpZiAoYy5sZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHZhciBvYyA9IGNsb25lKG90aGVyQyk7XG4gICAgICAgIG9jLnAgPSBvYy5wLnNsaWNlKGNwbGVuZ3RoKTtcbiAgICAgICAgYy5sZCA9IGpzb24uYXBwbHkoY2xvbmUoYy5sZCksW29jXSk7XG4gICAgICB9IGVsc2UgaWYgKGMub2QgIT09IHZvaWQgMCkge1xuICAgICAgICB2YXIgb2MgPSBjbG9uZShvdGhlckMpO1xuICAgICAgICBvYy5wID0gb2MucC5zbGljZShjcGxlbmd0aCk7XG4gICAgICAgIGMub2QgPSBqc29uLmFwcGx5KGNsb25lKGMub2QpLFtvY10pO1xuICAgICAgfVxuICAgIH1cbiAgICBqc29uLmFwcGVuZChkZXN0LGMpO1xuICAgIHJldHVybiBkZXN0O1xuICB9XG5cbiAgLy8gaWYgYyBpcyBkZWxldGluZyBzb21ldGhpbmcsIGFuZCB0aGF0IHRoaW5nIGlzIGNoYW5nZWQgYnkgb3RoZXJDLCB3ZSBuZWVkIHRvXG4gIC8vIHVwZGF0ZSBjIHRvIHJlZmxlY3QgdGhhdCBjaGFuZ2UgZm9yIGludmVydGliaWxpdHkuXG4gIC8vIFRPRE8gdGhpcyBpcyBwcm9iYWJseSBub3QgbmVlZGVkIHNpbmNlIHdlIGRvbid0IGhhdmUgaW52ZXJ0aWJpbGl0eVxuICBpZiAoY29tbW9uMiAhPSBudWxsICYmIG90aGVyQ3BsZW5ndGggPiBjcGxlbmd0aCAmJiBjLnBbY29tbW9uMl0gPT0gb3RoZXJDLnBbY29tbW9uMl0pIHtcbiAgICBpZiAoYy5sZCAhPT0gdm9pZCAwKSB7XG4gICAgICB2YXIgb2MgPSBjbG9uZShvdGhlckMpO1xuICAgICAgb2MucCA9IG9jLnAuc2xpY2UoY3BsZW5ndGgpO1xuICAgICAgYy5sZCA9IGpzb24uYXBwbHkoY2xvbmUoYy5sZCksW29jXSk7XG4gICAgfSBlbHNlIGlmIChjLm9kICE9PSB2b2lkIDApIHtcbiAgICAgIHZhciBvYyA9IGNsb25lKG90aGVyQyk7XG4gICAgICBvYy5wID0gb2MucC5zbGljZShjcGxlbmd0aCk7XG4gICAgICBjLm9kID0ganNvbi5hcHBseShjbG9uZShjLm9kKSxbb2NdKTtcbiAgICB9XG4gIH1cblxuICBpZiAoY29tbW9uICE9IG51bGwpIHtcbiAgICB2YXIgY29tbW9uT3BlcmFuZCA9IGNwbGVuZ3RoID09IG90aGVyQ3BsZW5ndGg7XG5cbiAgICAvLyB0cmFuc2Zvcm0gYmFzZWQgb24gb3RoZXJDXG4gICAgaWYgKG90aGVyQy5uYSAhPT0gdm9pZCAwKSB7XG4gICAgICAvLyB0aGlzIGNhc2UgaXMgaGFuZGxlZCBhYm92ZSBkdWUgdG8gaWNreSBwYXRoIGhheFxuICAgIH0gZWxzZSBpZiAob3RoZXJDLnNpICE9PSB2b2lkIDAgfHwgb3RoZXJDLnNkICE9PSB2b2lkIDApIHtcbiAgICAgIC8vIFN0cmluZyBvcCB2cyBzdHJpbmcgb3AgLSBwYXNzIHRocm91Z2ggdG8gdGV4dCB0eXBlXG4gICAgICBpZiAoYy5zaSAhPT0gdm9pZCAwIHx8IGMuc2QgIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoIWNvbW1vbk9wZXJhbmQpIHRocm93IG5ldyBFcnJvcignbXVzdCBiZSBhIHN0cmluZz8nKTtcblxuICAgICAgICAvLyBDb252ZXJ0IGFuIG9wIGNvbXBvbmVudCB0byBhIHRleHQgb3AgY29tcG9uZW50IHNvIHdlIGNhbiB1c2UgdGhlXG4gICAgICAgIC8vIHRleHQgdHlwZSdzIHRyYW5zZm9ybSBmdW5jdGlvblxuICAgICAgICB2YXIgdGMxID0gX2NvbnZlcnRUb1RleHRDb21wb25lbnQoYyk7XG4gICAgICAgIHZhciB0YzIgPSBfY29udmVydFRvVGV4dENvbXBvbmVudChvdGhlckMpO1xuXG4gICAgICAgIHZhciByZXMgPSBbXTtcblxuICAgICAgICAvLyBhY3R1YWxseSB0cmFuc2Zvcm1cbiAgICAgICAgdGV4dC5fdGMocmVzLCB0YzEsIHRjMiwgdHlwZSk7XG4gICAgICAgIFxuICAgICAgICAvLyAuLi4uIHRoZW4gY29udmVydCB0aGUgcmVzdWx0IGJhY2sgaW50byBhIEpTT04gb3AgYWdhaW4uXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgLy8gVGV4dCBjb21wb25lbnRcbiAgICAgICAgICB2YXIgdGMgPSByZXNbaV07XG4gICAgICAgICAgLy8gSlNPTiBjb21wb25lbnRcbiAgICAgICAgICB2YXIgamMgPSB7cDogYy5wLnNsaWNlKDAsIGNvbW1vbil9O1xuICAgICAgICAgIGpjLnAucHVzaCh0Yy5wKTtcblxuICAgICAgICAgIGlmICh0Yy5pICE9IG51bGwpIGpjLnNpID0gdGMuaTtcbiAgICAgICAgICBpZiAodGMuZCAhPSBudWxsKSBqYy5zZCA9IHRjLmQ7XG4gICAgICAgICAganNvbi5hcHBlbmQoZGVzdCwgamMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3RoZXJDLmxpICE9PSB2b2lkIDAgJiYgb3RoZXJDLmxkICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChvdGhlckMucFtjb21tb25dID09PSBjLnBbY29tbW9uXSkge1xuICAgICAgICAvLyBub29wXG5cbiAgICAgICAgaWYgKCFjb21tb25PcGVyYW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgIH0gZWxzZSBpZiAoYy5sZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgLy8gd2UncmUgdHJ5aW5nIHRvIGRlbGV0ZSB0aGUgc2FtZSBlbGVtZW50LCAtPiBub29wXG4gICAgICAgICAgaWYgKGMubGkgIT09IHZvaWQgMCAmJiB0eXBlID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIC8vIHdlJ3JlIGJvdGggcmVwbGFjaW5nIG9uZSBlbGVtZW50IHdpdGggYW5vdGhlci4gb25seSBvbmUgY2FuIHN1cnZpdmVcbiAgICAgICAgICAgIGMubGQgPSBjbG9uZShvdGhlckMubGkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG90aGVyQy5saSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAoYy5saSAhPT0gdm9pZCAwICYmIGMubGQgPT09IHVuZGVmaW5lZCAmJiBjb21tb25PcGVyYW5kICYmIGMucFtjb21tb25dID09PSBvdGhlckMucFtjb21tb25dKSB7XG4gICAgICAgIC8vIGluIGxpIHZzLiBsaSwgbGVmdCB3aW5zLlxuICAgICAgICBpZiAodHlwZSA9PT0gJ3JpZ2h0JylcbiAgICAgICAgICBjLnBbY29tbW9uXSsrO1xuICAgICAgfSBlbHNlIGlmIChvdGhlckMucFtjb21tb25dIDw9IGMucFtjb21tb25dKSB7XG4gICAgICAgIGMucFtjb21tb25dKys7XG4gICAgICB9XG5cbiAgICAgIGlmIChjLmxtICE9PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKGNvbW1vbk9wZXJhbmQpIHtcbiAgICAgICAgICAvLyBvdGhlckMgZWRpdHMgdGhlIHNhbWUgbGlzdCB3ZSBlZGl0XG4gICAgICAgICAgaWYgKG90aGVyQy5wW2NvbW1vbl0gPD0gYy5sbSlcbiAgICAgICAgICAgIGMubG0rKztcbiAgICAgICAgICAvLyBjaGFuZ2luZyBjLmZyb20gaXMgaGFuZGxlZCBhYm92ZS5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3RoZXJDLmxkICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChjLmxtICE9PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKGNvbW1vbk9wZXJhbmQpIHtcbiAgICAgICAgICBpZiAob3RoZXJDLnBbY29tbW9uXSA9PT0gYy5wW2NvbW1vbl0pIHtcbiAgICAgICAgICAgIC8vIHRoZXkgZGVsZXRlZCB0aGUgdGhpbmcgd2UncmUgdHJ5aW5nIHRvIG1vdmVcbiAgICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBvdGhlckMgZWRpdHMgdGhlIHNhbWUgbGlzdCB3ZSBlZGl0XG4gICAgICAgICAgdmFyIHAgPSBvdGhlckMucFtjb21tb25dO1xuICAgICAgICAgIHZhciBmcm9tID0gYy5wW2NvbW1vbl07XG4gICAgICAgICAgdmFyIHRvID0gYy5sbTtcbiAgICAgICAgICBpZiAocCA8IHRvIHx8IChwID09PSB0byAmJiBmcm9tIDwgdG8pKVxuICAgICAgICAgICAgYy5sbS0tO1xuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG90aGVyQy5wW2NvbW1vbl0gPCBjLnBbY29tbW9uXSkge1xuICAgICAgICBjLnBbY29tbW9uXS0tO1xuICAgICAgfSBlbHNlIGlmIChvdGhlckMucFtjb21tb25dID09PSBjLnBbY29tbW9uXSkge1xuICAgICAgICBpZiAob3RoZXJDcGxlbmd0aCA8IGNwbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gd2UncmUgYmVsb3cgdGhlIGRlbGV0ZWQgZWxlbWVudCwgc28gLT4gbm9vcFxuICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICB9IGVsc2UgaWYgKGMubGQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGlmIChjLmxpICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIC8vIHdlJ3JlIHJlcGxhY2luZywgdGhleSdyZSBkZWxldGluZy4gd2UgYmVjb21lIGFuIGluc2VydC5cbiAgICAgICAgICAgIGRlbGV0ZSBjLmxkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSdyZSB0cnlpbmcgdG8gZGVsZXRlIHRoZSBzYW1lIGVsZW1lbnQsIC0+IG5vb3BcbiAgICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChvdGhlckMubG0gIT09IHZvaWQgMCkge1xuICAgICAgaWYgKGMubG0gIT09IHZvaWQgMCAmJiBjcGxlbmd0aCA9PT0gb3RoZXJDcGxlbmd0aCkge1xuICAgICAgICAvLyBsbSB2cyBsbSwgaGVyZSB3ZSBnbyFcbiAgICAgICAgdmFyIGZyb20gPSBjLnBbY29tbW9uXTtcbiAgICAgICAgdmFyIHRvID0gYy5sbTtcbiAgICAgICAgdmFyIG90aGVyRnJvbSA9IG90aGVyQy5wW2NvbW1vbl07XG4gICAgICAgIHZhciBvdGhlclRvID0gb3RoZXJDLmxtO1xuICAgICAgICBpZiAob3RoZXJGcm9tICE9PSBvdGhlclRvKSB7XG4gICAgICAgICAgLy8gaWYgb3RoZXJGcm9tID09IG90aGVyVG8sIHdlIGRvbid0IG5lZWQgdG8gY2hhbmdlIG91ciBvcC5cblxuICAgICAgICAgIC8vIHdoZXJlIGRpZCBteSB0aGluZyBnbz9cbiAgICAgICAgICBpZiAoZnJvbSA9PT0gb3RoZXJGcm9tKSB7XG4gICAgICAgICAgICAvLyB0aGV5IG1vdmVkIGl0ISB0aWUgYnJlYWsuXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICAgIGMucFtjb21tb25dID0gb3RoZXJUbztcbiAgICAgICAgICAgICAgaWYgKGZyb20gPT09IHRvKSAvLyB1Z2hcbiAgICAgICAgICAgICAgICBjLmxtID0gb3RoZXJUbztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGV5IG1vdmVkIGFyb3VuZCBpdFxuICAgICAgICAgICAgaWYgKGZyb20gPiBvdGhlckZyb20pIGMucFtjb21tb25dLS07XG4gICAgICAgICAgICBpZiAoZnJvbSA+IG90aGVyVG8pIGMucFtjb21tb25dKys7XG4gICAgICAgICAgICBlbHNlIGlmIChmcm9tID09PSBvdGhlclRvKSB7XG4gICAgICAgICAgICAgIGlmIChvdGhlckZyb20gPiBvdGhlclRvKSB7XG4gICAgICAgICAgICAgICAgYy5wW2NvbW1vbl0rKztcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIC8vIHVnaCwgYWdhaW5cbiAgICAgICAgICAgICAgICAgIGMubG0rKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzdGVwIDI6IHdoZXJlIGFtIGkgZ29pbmcgdG8gcHV0IGl0P1xuICAgICAgICAgICAgaWYgKHRvID4gb3RoZXJGcm9tKSB7XG4gICAgICAgICAgICAgIGMubG0tLTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG8gPT09IG90aGVyRnJvbSkge1xuICAgICAgICAgICAgICBpZiAodG8gPiBmcm9tKVxuICAgICAgICAgICAgICAgIGMubG0tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0byA+IG90aGVyVG8pIHtcbiAgICAgICAgICAgICAgYy5sbSsrO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0byA9PT0gb3RoZXJUbykge1xuICAgICAgICAgICAgICAvLyBpZiB3ZSdyZSBib3RoIG1vdmluZyBpbiB0aGUgc2FtZSBkaXJlY3Rpb24sIHRpZSBicmVha1xuICAgICAgICAgICAgICBpZiAoKG90aGVyVG8gPiBvdGhlckZyb20gJiYgdG8gPiBmcm9tKSB8fFxuICAgICAgICAgICAgICAgICAgKG90aGVyVG8gPCBvdGhlckZyb20gJiYgdG8gPCBmcm9tKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAncmlnaHQnKSBjLmxtKys7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvID4gZnJvbSkgYy5sbSsrO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRvID09PSBvdGhlckZyb20pIGMubG0tLTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjLmxpICE9PSB2b2lkIDAgJiYgYy5sZCA9PT0gdW5kZWZpbmVkICYmIGNvbW1vbk9wZXJhbmQpIHtcbiAgICAgICAgLy8gbGlcbiAgICAgICAgdmFyIGZyb20gPSBvdGhlckMucFtjb21tb25dO1xuICAgICAgICB2YXIgdG8gPSBvdGhlckMubG07XG4gICAgICAgIHAgPSBjLnBbY29tbW9uXTtcbiAgICAgICAgaWYgKHAgPiBmcm9tKSBjLnBbY29tbW9uXS0tO1xuICAgICAgICBpZiAocCA+IHRvKSBjLnBbY29tbW9uXSsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbGQsIGxkK2xpLCBzaSwgc2QsIG5hLCBvaSwgb2QsIG9pK29kLCBhbnkgbGkgb24gYW4gZWxlbWVudCBiZW5lYXRoXG4gICAgICAgIC8vIHRoZSBsbVxuICAgICAgICAvL1xuICAgICAgICAvLyBpLmUuIHRoaW5ncyBjYXJlIGFib3V0IHdoZXJlIHRoZWlyIGl0ZW0gaXMgYWZ0ZXIgdGhlIG1vdmUuXG4gICAgICAgIHZhciBmcm9tID0gb3RoZXJDLnBbY29tbW9uXTtcbiAgICAgICAgdmFyIHRvID0gb3RoZXJDLmxtO1xuICAgICAgICBwID0gYy5wW2NvbW1vbl07XG4gICAgICAgIGlmIChwID09PSBmcm9tKSB7XG4gICAgICAgICAgYy5wW2NvbW1vbl0gPSB0bztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocCA+IGZyb20pIGMucFtjb21tb25dLS07XG4gICAgICAgICAgaWYgKHAgPiB0bykgYy5wW2NvbW1vbl0rKztcbiAgICAgICAgICBlbHNlIGlmIChwID09PSB0byAmJiBmcm9tID4gdG8pIGMucFtjb21tb25dKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAob3RoZXJDLm9pICE9PSB2b2lkIDAgJiYgb3RoZXJDLm9kICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChjLnBbY29tbW9uXSA9PT0gb3RoZXJDLnBbY29tbW9uXSkge1xuICAgICAgICBpZiAoYy5vaSAhPT0gdm9pZCAwICYmIGNvbW1vbk9wZXJhbmQpIHtcbiAgICAgICAgICAvLyB3ZSBpbnNlcnRlZCB3aGVyZSBzb21lb25lIGVsc2UgcmVwbGFjZWRcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgLy8gbGVmdCB3aW5zXG4gICAgICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gd2Ugd2luLCBtYWtlIG91ciBvcCByZXBsYWNlIHdoYXQgdGhleSBpbnNlcnRlZFxuICAgICAgICAgICAgYy5vZCA9IG90aGVyQy5vaTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gLT4gbm9vcCBpZiB0aGUgb3RoZXIgY29tcG9uZW50IGlzIGRlbGV0aW5nIHRoZSBzYW1lIG9iamVjdCAob3IgYW55IHBhcmVudClcbiAgICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3RoZXJDLm9pICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChjLm9pICE9PSB2b2lkIDAgJiYgYy5wW2NvbW1vbl0gPT09IG90aGVyQy5wW2NvbW1vbl0pIHtcbiAgICAgICAgLy8gbGVmdCB3aW5zIGlmIHdlIHRyeSB0byBpbnNlcnQgYXQgdGhlIHNhbWUgcGxhY2VcbiAgICAgICAgaWYgKHR5cGUgPT09ICdsZWZ0Jykge1xuICAgICAgICAgIGpzb24uYXBwZW5kKGRlc3Qse3A6IGMucCwgb2Q6b3RoZXJDLm9pfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG90aGVyQy5vZCAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAoYy5wW2NvbW1vbl0gPT0gb3RoZXJDLnBbY29tbW9uXSkge1xuICAgICAgICBpZiAoIWNvbW1vbk9wZXJhbmQpXG4gICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgIGlmIChjLm9pICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBkZWxldGUgYy5vZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGpzb24uYXBwZW5kKGRlc3QsYyk7XG4gIHJldHVybiBkZXN0O1xufTtcblxuaWYgKHR5cGVvZiByZXF1aXJlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHJlcXVpcmUoJy4vaGVscGVycycpLl9ib290c3RyYXBUcmFuc2Zvcm0oanNvbiwganNvbi50cmFuc2Zvcm1Db21wb25lbnQsIGpzb24uY2hlY2tWYWxpZE9wLCBqc29uLmFwcGVuZCk7XG59IGVsc2Uge1xuICAvLyBUaGlzIGlzIGtpbmQgb2YgYXdmdWwgLSBjb21lIHVwIHdpdGggYSBiZXR0ZXIgd2F5IHRvIGhvb2sgdGhpcyBoZWxwZXIgY29kZSB1cC5cbiAgZXhwb3J0cy5fYm9vdHN0cmFwVHJhbnNmb3JtKGpzb24sIGpzb24udHJhbnNmb3JtQ29tcG9uZW50LCBqc29uLmNoZWNrVmFsaWRPcCwganNvbi5hcHBlbmQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGpzb247XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNi4yXG5leHBvcnRzLl9ib290c3RyYXBUcmFuc2Zvcm0gPSBmdW5jdGlvbih0eXBlLCB0cmFuc2Zvcm1Db21wb25lbnQsIGNoZWNrVmFsaWRPcCwgYXBwZW5kKSB7XG4gIHZhciB0cmFuc2Zvcm1Db21wb25lbnRYLCB0cmFuc2Zvcm1YO1xuXG4gIHRyYW5zZm9ybUNvbXBvbmVudFggPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgZGVzdExlZnQsIGRlc3RSaWdodCkge1xuICAgIHRyYW5zZm9ybUNvbXBvbmVudChkZXN0TGVmdCwgbGVmdCwgcmlnaHQsICdsZWZ0Jyk7XG4gICAgcmV0dXJuIHRyYW5zZm9ybUNvbXBvbmVudChkZXN0UmlnaHQsIHJpZ2h0LCBsZWZ0LCAncmlnaHQnKTtcbiAgfTtcbiAgdHlwZS50cmFuc2Zvcm1YID0gdHlwZS50cmFuc2Zvcm1YID0gdHJhbnNmb3JtWCA9IGZ1bmN0aW9uKGxlZnRPcCwgcmlnaHRPcCkge1xuICAgIHZhciBrLCBsLCBsXywgbmV3TGVmdE9wLCBuZXdSaWdodE9wLCBuZXh0Qywgciwgcl8sIHJpZ2h0Q29tcG9uZW50LCBfaSwgX2osIF9rLCBfbCwgX2xlbiwgX2xlbjEsIF9sZW4yLCBfbGVuMywgX3JlZiwgX3JlZjE7XG5cbiAgICBjaGVja1ZhbGlkT3AobGVmdE9wKTtcbiAgICBjaGVja1ZhbGlkT3AocmlnaHRPcCk7XG4gICAgbmV3UmlnaHRPcCA9IFtdO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gcmlnaHRPcC5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgcmlnaHRDb21wb25lbnQgPSByaWdodE9wW19pXTtcbiAgICAgIG5ld0xlZnRPcCA9IFtdO1xuICAgICAgayA9IDA7XG4gICAgICB3aGlsZSAoayA8IGxlZnRPcC5sZW5ndGgpIHtcbiAgICAgICAgbmV4dEMgPSBbXTtcbiAgICAgICAgdHJhbnNmb3JtQ29tcG9uZW50WChsZWZ0T3Bba10sIHJpZ2h0Q29tcG9uZW50LCBuZXdMZWZ0T3AsIG5leHRDKTtcbiAgICAgICAgaysrO1xuICAgICAgICBpZiAobmV4dEMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmlnaHRDb21wb25lbnQgPSBuZXh0Q1swXTtcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0Qy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBfcmVmID0gbGVmdE9wLnNsaWNlKGspO1xuICAgICAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IF9yZWYubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgICAgICBsID0gX3JlZltfal07XG4gICAgICAgICAgICBhcHBlbmQobmV3TGVmdE9wLCBsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmlnaHRDb21wb25lbnQgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9yZWYxID0gdHJhbnNmb3JtWChsZWZ0T3Auc2xpY2UoayksIG5leHRDKSwgbF8gPSBfcmVmMVswXSwgcl8gPSBfcmVmMVsxXTtcbiAgICAgICAgICBmb3IgKF9rID0gMCwgX2xlbjIgPSBsXy5sZW5ndGg7IF9rIDwgX2xlbjI7IF9rKyspIHtcbiAgICAgICAgICAgIGwgPSBsX1tfa107XG4gICAgICAgICAgICBhcHBlbmQobmV3TGVmdE9wLCBsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChfbCA9IDAsIF9sZW4zID0gcl8ubGVuZ3RoOyBfbCA8IF9sZW4zOyBfbCsrKSB7XG4gICAgICAgICAgICByID0gcl9bX2xdO1xuICAgICAgICAgICAgYXBwZW5kKG5ld1JpZ2h0T3AsIHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByaWdodENvbXBvbmVudCA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyaWdodENvbXBvbmVudCAhPSBudWxsKSB7XG4gICAgICAgIGFwcGVuZChuZXdSaWdodE9wLCByaWdodENvbXBvbmVudCk7XG4gICAgICB9XG4gICAgICBsZWZ0T3AgPSBuZXdMZWZ0T3A7XG4gICAgfVxuICAgIHJldHVybiBbbGVmdE9wLCBuZXdSaWdodE9wXTtcbiAgfTtcbiAgcmV0dXJuIHR5cGUudHJhbnNmb3JtID0gdHlwZVsndHJhbnNmb3JtJ10gPSBmdW5jdGlvbihvcCwgb3RoZXJPcCwgdHlwZSkge1xuICAgIGlmICghKHR5cGUgPT09ICdsZWZ0JyB8fCB0eXBlID09PSAncmlnaHQnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHlwZSBtdXN0IGJlICdsZWZ0JyBvciAncmlnaHQnXCIpO1xuICAgIH1cbiAgICBpZiAob3RoZXJPcC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBvcDtcbiAgICB9XG4gICAgaWYgKG9wLmxlbmd0aCA9PT0gMSAmJiBvdGhlck9wLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybUNvbXBvbmVudChbXSwgb3BbMF0sIG90aGVyT3BbMF0sIHR5cGUpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ2xlZnQnKSB7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtWChvcCwgb3RoZXJPcClbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1YKG90aGVyT3AsIG9wKVsxXTtcbiAgICB9XG4gIH07XG59O1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjYuMlxudmFyIGFwcGVuZCwgY2hlY2tWYWxpZENvbXBvbmVudCwgY2hlY2tWYWxpZE9wLCBpbnZlcnRDb21wb25lbnQsIHN0ckluamVjdCwgdGV4dCwgdHJhbnNmb3JtQ29tcG9uZW50LCB0cmFuc2Zvcm1Qb3NpdGlvbjtcblxudGV4dCA9IHtcbiAgbmFtZTogJ3RleHQtb2xkJyxcbiAgdXJpOiAnaHR0cDovL3NoYXJlanMub3JnL3R5cGVzL3RleHR2MCcsXG4gIGNyZWF0ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5zdHJJbmplY3QgPSBmdW5jdGlvbihzMSwgcG9zLCBzMikge1xuICByZXR1cm4gczEuc2xpY2UoMCwgcG9zKSArIHMyICsgczEuc2xpY2UocG9zKTtcbn07XG5cbmNoZWNrVmFsaWRDb21wb25lbnQgPSBmdW5jdGlvbihjKSB7XG4gIHZhciBkX3R5cGUsIGlfdHlwZTtcblxuICBpZiAodHlwZW9mIGMucCAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbXBvbmVudCBtaXNzaW5nIHBvc2l0aW9uIGZpZWxkJyk7XG4gIH1cbiAgaV90eXBlID0gdHlwZW9mIGMuaTtcbiAgZF90eXBlID0gdHlwZW9mIGMuZDtcbiAgaWYgKCEoKGlfdHlwZSA9PT0gJ3N0cmluZycpIF4gKGRfdHlwZSA9PT0gJ3N0cmluZycpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignY29tcG9uZW50IG5lZWRzIGFuIGkgb3IgZCBmaWVsZCcpO1xuICB9XG4gIGlmICghKGMucCA+PSAwKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncG9zaXRpb24gY2Fubm90IGJlIG5lZ2F0aXZlJyk7XG4gIH1cbn07XG5cbmNoZWNrVmFsaWRPcCA9IGZ1bmN0aW9uKG9wKSB7XG4gIHZhciBjLCBfaSwgX2xlbjtcblxuICBmb3IgKF9pID0gMCwgX2xlbiA9IG9wLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgYyA9IG9wW19pXTtcbiAgICBjaGVja1ZhbGlkQ29tcG9uZW50KGMpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxudGV4dC5hcHBseSA9IGZ1bmN0aW9uKHNuYXBzaG90LCBvcCkge1xuICB2YXIgY29tcG9uZW50LCBkZWxldGVkLCBfaSwgX2xlbjtcblxuICBjaGVja1ZhbGlkT3Aob3ApO1xuICBmb3IgKF9pID0gMCwgX2xlbiA9IG9wLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgY29tcG9uZW50ID0gb3BbX2ldO1xuICAgIGlmIChjb21wb25lbnQuaSAhPSBudWxsKSB7XG4gICAgICBzbmFwc2hvdCA9IHN0ckluamVjdChzbmFwc2hvdCwgY29tcG9uZW50LnAsIGNvbXBvbmVudC5pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlZCA9IHNuYXBzaG90LnNsaWNlKGNvbXBvbmVudC5wLCBjb21wb25lbnQucCArIGNvbXBvbmVudC5kLmxlbmd0aCk7XG4gICAgICBpZiAoY29tcG9uZW50LmQgIT09IGRlbGV0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVsZXRlIGNvbXBvbmVudCAnXCIgKyBjb21wb25lbnQuZCArIFwiJyBkb2VzIG5vdCBtYXRjaCBkZWxldGVkIHRleHQgJ1wiICsgZGVsZXRlZCArIFwiJ1wiKTtcbiAgICAgIH1cbiAgICAgIHNuYXBzaG90ID0gc25hcHNob3Quc2xpY2UoMCwgY29tcG9uZW50LnApICsgc25hcHNob3Quc2xpY2UoY29tcG9uZW50LnAgKyBjb21wb25lbnQuZC5sZW5ndGgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc25hcHNob3Q7XG59O1xuXG50ZXh0Ll9hcHBlbmQgPSBhcHBlbmQgPSBmdW5jdGlvbihuZXdPcCwgYykge1xuICB2YXIgbGFzdCwgX3JlZiwgX3JlZjE7XG5cbiAgaWYgKGMuaSA9PT0gJycgfHwgYy5kID09PSAnJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobmV3T3AubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ld09wLnB1c2goYyk7XG4gIH0gZWxzZSB7XG4gICAgbGFzdCA9IG5ld09wW25ld09wLmxlbmd0aCAtIDFdO1xuICAgIGlmICgobGFzdC5pICE9IG51bGwpICYmIChjLmkgIT0gbnVsbCkgJiYgKGxhc3QucCA8PSAoX3JlZiA9IGMucCkgJiYgX3JlZiA8PSAobGFzdC5wICsgbGFzdC5pLmxlbmd0aCkpKSB7XG4gICAgICByZXR1cm4gbmV3T3BbbmV3T3AubGVuZ3RoIC0gMV0gPSB7XG4gICAgICAgIGk6IHN0ckluamVjdChsYXN0LmksIGMucCAtIGxhc3QucCwgYy5pKSxcbiAgICAgICAgcDogbGFzdC5wXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoKGxhc3QuZCAhPSBudWxsKSAmJiAoYy5kICE9IG51bGwpICYmIChjLnAgPD0gKF9yZWYxID0gbGFzdC5wKSAmJiBfcmVmMSA8PSAoYy5wICsgYy5kLmxlbmd0aCkpKSB7XG4gICAgICByZXR1cm4gbmV3T3BbbmV3T3AubGVuZ3RoIC0gMV0gPSB7XG4gICAgICAgIGQ6IHN0ckluamVjdChjLmQsIGxhc3QucCAtIGMucCwgbGFzdC5kKSxcbiAgICAgICAgcDogYy5wXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3T3AucHVzaChjKTtcbiAgICB9XG4gIH1cbn07XG5cbnRleHQuY29tcG9zZSA9IGZ1bmN0aW9uKG9wMSwgb3AyKSB7XG4gIHZhciBjLCBuZXdPcCwgX2ksIF9sZW47XG5cbiAgY2hlY2tWYWxpZE9wKG9wMSk7XG4gIGNoZWNrVmFsaWRPcChvcDIpO1xuICBuZXdPcCA9IG9wMS5zbGljZSgpO1xuICBmb3IgKF9pID0gMCwgX2xlbiA9IG9wMi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgIGMgPSBvcDJbX2ldO1xuICAgIGFwcGVuZChuZXdPcCwgYyk7XG4gIH1cbiAgcmV0dXJuIG5ld09wO1xufTtcblxudGV4dC5jb21wcmVzcyA9IGZ1bmN0aW9uKG9wKSB7XG4gIHJldHVybiB0ZXh0LmNvbXBvc2UoW10sIG9wKTtcbn07XG5cbnRleHQubm9ybWFsaXplID0gZnVuY3Rpb24ob3ApIHtcbiAgdmFyIGMsIG5ld09wLCBfaSwgX2xlbiwgX3JlZjtcblxuICBuZXdPcCA9IFtdO1xuICBpZiAoKG9wLmkgIT0gbnVsbCkgfHwgKG9wLnAgIT0gbnVsbCkpIHtcbiAgICBvcCA9IFtvcF07XG4gIH1cbiAgZm9yIChfaSA9IDAsIF9sZW4gPSBvcC5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgIGMgPSBvcFtfaV07XG4gICAgaWYgKChfcmVmID0gYy5wKSA9PSBudWxsKSB7XG4gICAgICBjLnAgPSAwO1xuICAgIH1cbiAgICBhcHBlbmQobmV3T3AsIGMpO1xuICB9XG4gIHJldHVybiBuZXdPcDtcbn07XG5cbnRyYW5zZm9ybVBvc2l0aW9uID0gZnVuY3Rpb24ocG9zLCBjLCBpbnNlcnRBZnRlcikge1xuICBpZiAoYy5pICE9IG51bGwpIHtcbiAgICBpZiAoYy5wIDwgcG9zIHx8IChjLnAgPT09IHBvcyAmJiBpbnNlcnRBZnRlcikpIHtcbiAgICAgIHJldHVybiBwb3MgKyBjLmkubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocG9zIDw9IGMucCkge1xuICAgICAgcmV0dXJuIHBvcztcbiAgICB9IGVsc2UgaWYgKHBvcyA8PSBjLnAgKyBjLmQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYy5wO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcG9zIC0gYy5kLmxlbmd0aDtcbiAgICB9XG4gIH1cbn07XG5cbnRleHQudHJhbnNmb3JtQ3Vyc29yID0gZnVuY3Rpb24ocG9zaXRpb24sIG9wLCBzaWRlKSB7XG4gIHZhciBjLCBpbnNlcnRBZnRlciwgX2ksIF9sZW47XG5cbiAgaW5zZXJ0QWZ0ZXIgPSBzaWRlID09PSAncmlnaHQnO1xuICBmb3IgKF9pID0gMCwgX2xlbiA9IG9wLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgYyA9IG9wW19pXTtcbiAgICBwb3NpdGlvbiA9IHRyYW5zZm9ybVBvc2l0aW9uKHBvc2l0aW9uLCBjLCBpbnNlcnRBZnRlcik7XG4gIH1cbiAgcmV0dXJuIHBvc2l0aW9uO1xufTtcblxudGV4dC5fdGMgPSB0cmFuc2Zvcm1Db21wb25lbnQgPSBmdW5jdGlvbihkZXN0LCBjLCBvdGhlckMsIHNpZGUpIHtcbiAgdmFyIGNJbnRlcnNlY3QsIGludGVyc2VjdEVuZCwgaW50ZXJzZWN0U3RhcnQsIG5ld0MsIG90aGVySW50ZXJzZWN0LCBzO1xuXG4gIGNoZWNrVmFsaWRPcChbY10pO1xuICBjaGVja1ZhbGlkT3AoW290aGVyQ10pO1xuICBpZiAoYy5pICE9IG51bGwpIHtcbiAgICBhcHBlbmQoZGVzdCwge1xuICAgICAgaTogYy5pLFxuICAgICAgcDogdHJhbnNmb3JtUG9zaXRpb24oYy5wLCBvdGhlckMsIHNpZGUgPT09ICdyaWdodCcpXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG90aGVyQy5pICE9IG51bGwpIHtcbiAgICAgIHMgPSBjLmQ7XG4gICAgICBpZiAoYy5wIDwgb3RoZXJDLnApIHtcbiAgICAgICAgYXBwZW5kKGRlc3QsIHtcbiAgICAgICAgICBkOiBzLnNsaWNlKDAsIG90aGVyQy5wIC0gYy5wKSxcbiAgICAgICAgICBwOiBjLnBcbiAgICAgICAgfSk7XG4gICAgICAgIHMgPSBzLnNsaWNlKG90aGVyQy5wIC0gYy5wKTtcbiAgICAgIH1cbiAgICAgIGlmIChzICE9PSAnJykge1xuICAgICAgICBhcHBlbmQoZGVzdCwge1xuICAgICAgICAgIGQ6IHMsXG4gICAgICAgICAgcDogYy5wICsgb3RoZXJDLmkubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYy5wID49IG90aGVyQy5wICsgb3RoZXJDLmQubGVuZ3RoKSB7XG4gICAgICAgIGFwcGVuZChkZXN0LCB7XG4gICAgICAgICAgZDogYy5kLFxuICAgICAgICAgIHA6IGMucCAtIG90aGVyQy5kLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoYy5wICsgYy5kLmxlbmd0aCA8PSBvdGhlckMucCkge1xuICAgICAgICBhcHBlbmQoZGVzdCwgYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdDID0ge1xuICAgICAgICAgIGQ6ICcnLFxuICAgICAgICAgIHA6IGMucFxuICAgICAgICB9O1xuICAgICAgICBpZiAoYy5wIDwgb3RoZXJDLnApIHtcbiAgICAgICAgICBuZXdDLmQgPSBjLmQuc2xpY2UoMCwgb3RoZXJDLnAgLSBjLnApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjLnAgKyBjLmQubGVuZ3RoID4gb3RoZXJDLnAgKyBvdGhlckMuZC5sZW5ndGgpIHtcbiAgICAgICAgICBuZXdDLmQgKz0gYy5kLnNsaWNlKG90aGVyQy5wICsgb3RoZXJDLmQubGVuZ3RoIC0gYy5wKTtcbiAgICAgICAgfVxuICAgICAgICBpbnRlcnNlY3RTdGFydCA9IE1hdGgubWF4KGMucCwgb3RoZXJDLnApO1xuICAgICAgICBpbnRlcnNlY3RFbmQgPSBNYXRoLm1pbihjLnAgKyBjLmQubGVuZ3RoLCBvdGhlckMucCArIG90aGVyQy5kLmxlbmd0aCk7XG4gICAgICAgIGNJbnRlcnNlY3QgPSBjLmQuc2xpY2UoaW50ZXJzZWN0U3RhcnQgLSBjLnAsIGludGVyc2VjdEVuZCAtIGMucCk7XG4gICAgICAgIG90aGVySW50ZXJzZWN0ID0gb3RoZXJDLmQuc2xpY2UoaW50ZXJzZWN0U3RhcnQgLSBvdGhlckMucCwgaW50ZXJzZWN0RW5kIC0gb3RoZXJDLnApO1xuICAgICAgICBpZiAoY0ludGVyc2VjdCAhPT0gb3RoZXJJbnRlcnNlY3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlbGV0ZSBvcHMgZGVsZXRlIGRpZmZlcmVudCB0ZXh0IGluIHRoZSBzYW1lIHJlZ2lvbiBvZiB0aGUgZG9jdW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3Qy5kICE9PSAnJykge1xuICAgICAgICAgIG5ld0MucCA9IHRyYW5zZm9ybVBvc2l0aW9uKG5ld0MucCwgb3RoZXJDKTtcbiAgICAgICAgICBhcHBlbmQoZGVzdCwgbmV3Qyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5pbnZlcnRDb21wb25lbnQgPSBmdW5jdGlvbihjKSB7XG4gIGlmIChjLmkgIT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICBkOiBjLmksXG4gICAgICBwOiBjLnBcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBpOiBjLmQsXG4gICAgICBwOiBjLnBcbiAgICB9O1xuICB9XG59O1xuXG50ZXh0LmludmVydCA9IGZ1bmN0aW9uKG9wKSB7XG4gIHZhciBjLCBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG5cbiAgX3JlZiA9IG9wLnNsaWNlKCkucmV2ZXJzZSgpO1xuICBfcmVzdWx0cyA9IFtdO1xuICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICBjID0gX3JlZltfaV07XG4gICAgX3Jlc3VsdHMucHVzaChpbnZlcnRDb21wb25lbnQoYykpO1xuICB9XG4gIHJldHVybiBfcmVzdWx0cztcbn07XG5cbmlmICh0eXBlb2YgcmVxdWlyZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgZXhwb3J0cy5fYm9vdHN0cmFwVHJhbnNmb3JtKHRleHQsIHRleHQudHJhbnNmb3JtQ29tcG9uZW50LCB0ZXh0LmNoZWNrVmFsaWRPcCwgdGV4dC5hcHBlbmQpO1xufSBlbHNlIHtcbiAgcmVxdWlyZSgnLi9oZWxwZXJzJykuX2Jvb3RzdHJhcFRyYW5zZm9ybSh0ZXh0LCB0ZXh0LnRyYW5zZm9ybUNvbXBvbmVudCwgdGV4dC5jaGVja1ZhbGlkT3AsIHRleHQuYXBwZW5kKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0ZXh0O1xuIl19
;
(function() {
var view = require("derby").app.view;
view._makeAll({
  "app/403.html:body": "<div class=\"container\"><div class=\"page-header\"><h1>403</h1></div><p class=\"lead\">We're sorry, page is forbidden.</p></div>",
  "app/403.html:title": "403",
  "app/404.html:body": "<div class=\"container\"><div class=\"page-header\"><h1>404</h1></div><p class=\"lead\">We're sorry, page not found.</p></div>",
  "app/404.html:title": "404",
  "app/500.html:body": "<div class=\"container\"><div class=\"page-header\"><h1>500</h1></div><p class=\"lead\">We're sorry, something went wrong.</p></div>",
  "app/500.html:title": "500",
  "app/forgot.html:body": "<div class=\"container\"><div class=\"page-header\"><h1>Forgotten password?</h1></div>{#with _page.form}{#if .success}<p class=\"alert alert-success\"><i class=\"fa fa-check-circle\"></i> Password reset instructions were sent to your address.</p>{/}<form role=\"form\" x-bind=\"submit: user.forgotPassword\"><div class=\"form-group\"><label class=\"control-label\" for=\"usernameOrEmail\">Username or email</label><div class=\"input-group\"><span class=\"input-group-addon\"><i class=\"fa fa-user\"></i></span><input id=\"usernameOrEmail\" class=\"form-control\" autofocus placeholder=\"Username or email\" type=\"text\" value=\"{.usernameOrEmail}\"></div></div><div class=\"form-group\"><button class=\"btn btn-primary\" type=\"submit\"><i class=\"fa fa-envelope\"></i> Send</button></div></form>{/}</div>",
  "app/forgot.html:title": "Forgotten password?",
  "app/home.html:body": "<div class=\"jumbotron\"><div class=\"container\"><h1><i class=\"fa fa-user\"></i> Derby User</h1><p>A user management system for <a href=\"http://derbyjs.com\">Derby JS</a>.</p><p><a class=\"btn btn-primary btn-lg\" role=\"button\" href=\"{{$config.repository.url}}\"><i class=\"fa fa-github\"></i> View on GitHub</a></p><ghbtns:button count=\"true\" giturl=\"{{$config.repository.url}}\" type=\"watch\" width=\"90\"><ghbtns:button count=\"true\" giturl=\"{{$config.repository.url}}\" type=\"fork\" width=\"90\"><ghbtns:button count=\"true\" giturl=\"{{$config.repository.url}}\" type=\"follow\" width=\"180\"></div></div>",
  "app/home.html:title": "Derby User",
  "app/index.html:footer": "<hr><div class=\"container\"><div id=\"footer\"><p class=\"text-muted credit\">Derby User {{$config.version}}  <a href=\"{{$config.repository.url}}\"><i class=\"fa fa-github\"></i> GitHub Project</a></p></div></div>",
  "app/index.html:header": "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><link href=\"/shared/bower_components/bootstrap/dist/css/bootstrap.min.css\" rel=\"stylesheet\"><link href=\"/shared/bower_components/bootstrap/examples/jumbotron/jumbotron.css\" rel=\"stylesheet\"><link href=\"/shared/bower_components/font-awesome/css/font-awesome.min.css\" rel=\"stylesheet\"><ui:connectionAlert><header class=\"navbar navbar-inverse navbar-fixed-top\" role=\"navigation\"><div class=\"container\"><div class=\"navbar-header\"><button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\".navbar-collapse\"><span class=\"sr-only\">Toggle navigation</span><span class=\"icon-bar\"></span><span class=\"icon-bar\"></span><span class=\"icon-bar\"></span></button><a class=\"navbar-brand\" href=\"/\"><i class=\"fa fa-user\"></i> Derby User</a></div><div class=\"navbar-collapse collapse\"><ul class=\"nav navbar-nav\"><app:navitem href=\"/\" title=\"Home\">{#if _page.user.public.isRegistered}<app:navitem href=\"/settings\" title=\"Settings\"><li><a x-bind=\"click: user.signout\">Sign out</a></li>{else}<app:navitem href=\"/signup\" title=\"Sign up\"><app:navitem href=\"/signin\" title=\"Sign in\"><app:navitem href=\"/forgot\" title=\"Forgot\">{/}</ul>{#if _page.user.public.isRegistered}<ul class=\"nav navbar-nav navbar-right dropdown\"><li class=\"dropdown\"><a class=\"dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\">{#if user.photoUrl(_page.user.public)}<img alt=\"\" height=\"20\" src=\"{user.photoUrl(_page.user.public)}\" width=\"20\">{else}<i class=\"fa fa-user\"></i>{/}&nbsp;{user.displayName(_page.user.public)} <i class=\"fa fa-caret-down\"></i></a><ul class=\"dropdown-menu\"><li><a href=\"/settings\">Settings</a></li><li class=\"divider\"></li><li><a x-bind=\"click: user.signout\"><i class=\"fa fa-sign-out\"></i> Sign out</a></li></ul></li></ul>{else}{#with _page.form.navbar}<form class=\"navbar-form navbar-right\" x-bind=\"submit: user.signin\"><div class=\"form-group\"><label class=\"sr-only\" for=\"navUsernameOrEmail\">Username or email</label><input id=\"navUsernameOrEmail\" class=\"form-control\" placeholder=\"Username or email\" type=\"text\" value=\"{.usernameOrEmail}\"></div>&nbsp;<div class=\"form-group\"><label class=\"sr-only\" for=\"navPassword\">Password</label><input id=\"navPassword\" class=\"form-control\" placeholder=\"Password\" type=\"password\" value=\"{.password}\"></div>&nbsp;<div class=\"form-group\"><button class=\"btn btn-primary\" type=\"submit\"><i class=\"fa fa-sign-in\"></i> Sign in</button>&nbsp;<div class=\"btn-group\"><a class=\"btn btn-primary\" x-bind=\"click: user.connect.facebook\"><i class=\"fa fa-facebook\"></i></a><a class=\"btn btn-primary\" x-bind=\"click: user.connect.google\"><i class=\"fa fa-google-plus\"></i></a><a class=\"btn btn-primary\" x-bind=\"click: user.connect.twitter\"><i class=\"fa fa-twitter\"></i></a></div></div></form>{/}{/}</div></div></header>{#if _page.user.public.isRegistered}{#if not(_page.user.private.local.emails.0.value)}<div class=\"container\"><div class=\"alert alert-warning\"><p><i class=\"fa fa-exclamation-circle\"></i> <a href=\"/settings\">Please set your email address</a>.</p></div></div>{else if not(_page.user.private.local.emails.0.verified)}<div class=\"container\"><div class=\"alert alert-warning\"><p>Please confirm your email address. A confirmation message was sent to <strong>{_page.user.private.local.emails.0.value}</strong>.</p>{#with _page.form.verifyEmail}<p><a class=\"btn btn-default\" x-bind=\"click: user.verifyEmail\"><i class=\"fa fa-repeat\"></i> Resend confirmation</a> <a href=\"/settings\">Update email address</a>.</p>{/}</div></div>{/}{/}",
  "app/index.html:navitem": "<li class=\"{{#if equal($url, @href)}}active{{/}}\"><a href=\"{{@href}}\">{{@title}}</a></li>",
  "app/index.html:scripts": "<script src=\"/shared/bower_components/jquery/jquery.min.js\"></script><script src=\"/shared/bower_components/bootstrap/dist/js/bootstrap.min.js\"></script><script src=\"/shared/bower_components/jquery-popupwindow/jquery.popupwindow.js\"></script>",
  "app/reset.html:body": "<div class=\"container\"><div class=\"page-header\"><h1>Reset your password</h1></div>{#with _page.form}<form role=\"form\" x-bind=\"submit: user.resetPassword\"><div class=\"form-group\"><label class=\"control-label\" for=\"password\">Password</label><div class=\"input-group\"><span class=\"input-group-addon\"><i class=\"fa fa-key\"></i></span><input id=\"password\" class=\"form-control\" autofocus placeholder=\"Password\" type=\"password\" value=\"{.password}\"></div></div><div class=\"form-group\"><label class=\"control-label\" for=\"confirmPassword\">Confirm password</label><div class=\"input-group\"><span class=\"input-group-addon\"><i class=\"fa fa-key\"></i></span><input id=\"confirmPassword\" class=\"form-control\" placeholder=\"Confirm password\" type=\"password\" value=\"{.confirmPassword}\"></div></div><div class=\"form-group\"><button class=\"btn btn-primary\" type=\"submit\">Reset</button></div><input name=\"token\" type=\"hidden\" value=\"{{.token}}\"><input name=\"userId\" type=\"hidden\" value=\"{{.userId}}\"></form>{/}</div>",
  "app/reset.html:title": "Reset your password",
  "app/settings.html:body": "<div class=\"container\"><div class=\"page-header\"><h1>Settings</h1></div>{#with _page.form.username}<form role=\"form\" x-bind=\"submit: user.changeUsername\"><legend>Change username</legend><div class=\"form-group\"><label class=\"control-label\" for=\"username\">Username</label><div class=\"input-group\"><span class=\"input-group-addon\"><i class=\"fa fa-user\"></i></span><input id=\"username\" class=\"form-control\" placeholder=\"Username\" type=\"text\" value=\"{.username}\"></div></div><div class=\"form-group\"><button class=\"btn btn-primary\" type=\"submit\">Change</button></div></form>{/}{#with _page.form.email}<form role=\"form\" x-bind=\"submit: user.changeEmail\"><legend>Change email</legend><div class=\"form-group\"><label class=\"control-label\" for=\"email\">Email</label><div class=\"input-group\"><span class=\"input-group-addon\"><i class=\"fa fa-envelope\"></i></span><input id=\"email\" class=\"form-control\" placeholder=\"Email\" type=\"text\" value=\"{.email}\"></div><p class=\"help-block\">Change your avatar at <i class=\"fa fa-external-link-square\"></i> <a href=\"http:http://www.gravatar.com\">Gravatar.com</a>.</p></div><div class=\"form-group\"><button class=\"btn btn-primary\" type=\"submit\">Change</button></div></form>{/}{#with _page.form.password}<form role=\"form\" x-bind=\"submit: user.changePassword\"><legend>Change password</legend><div class=\"form-group\"><label class=\"control-label\" for=\"password\">Password</label><div class=\"input-group\"><span class=\"input-group-addon\"><i class=\"fa fa-key\"></i></span><input id=\"password\" class=\"form-control\" placeholder=\"Password\" type=\"password\" value=\"{.password}\"></div></div><div class=\"form-group\"><label class=\"control-label\" for=\"confirmPassword\">Confirm password</label><div class=\"input-group\"><span class=\"input-group-addon\"><i class=\"fa fa-key\"></i></span><input id=\"confirmPassword\" class=\"form-control\" placeholder=\"Confirm password\" type=\"password\" value=\"{.confirmPassword}\"></div></div><div class=\"form-group\"><button class=\"btn btn-primary\" type=\"submit\">Change</button></div></form>{/}</div>",
  "app/settings.html:title": "Settings",
  "app/signin.html:body": "<div class=\"container\"><div class=\"page-header\"><h1>Sign in</h1></div>{#with _page.form}<form role=\"form\" x-bind=\"submit: user.signin\"><div class=\"form-group\"><label class=\"control-label\" for=\"usernameOrEmail\">Username or email</label><div class=\"input-group\"><span class=\"input-group-addon\"><i class=\"fa fa-user\"></i></span><input id=\"usernameOrEmail\" class=\"form-control\" autofocus placeholder=\"Username or email\" type=\"text\" value=\"{.usernameOrEmail}\"></div></div><div class=\"form-group\"><label class=\"control-label\" for=\"password\">Password</label><div class=\"input-group\"><span class=\"input-group-addon\"><i class=\"fa fa-key\"></i></span><input id=\"password\" class=\"form-control\" placeholder=\"Password\" type=\"password\" value=\"{.password}\"></div></div><div class=\"form-group\"><button class=\"btn btn-primary\" type=\"submit\"><i class=\"fa fa-sign-in\"></i> Sign in</button> <a href=\"/forgot\">Forgot your password?</a></div></form>{/}<hr><p class=\"lead\">Or sign up using</p><div class=\"visible-xs\"><a class=\"btn btn-default\" x-bind=\"click: user.connect.facebook\"><i class=\"fa fa-facebook fa-lg\"></i></a> <a class=\"btn btn-default\" x-bind=\"click: user.connect.google\"><i class=\"fa fa-google-plus fa-lg\"></i></a> <a class=\"btn btn-default\" x-bind=\"click: user.connect.twitter\"><i class=\"fa fa-twitter fa-lg\"></i></a></div><div class=\"hidden-xs\"><a class=\"btn btn-default\" x-bind=\"click: user.connect.facebook\"><i class=\"fa fa-facebook-square\"></i> Facebook</a> <a class=\"btn btn-default\" x-bind=\"click: user.connect.google\"><i class=\"fa fa-google-plus-square\"></i> Google+</a> <a class=\"btn btn-default\" x-bind=\"click: user.connect.twitter\"><i class=\"fa fa-twitter-square\"></i> Twitter</a></div></div>",
  "app/signin.html:title": "Sign in",
  "app/signup.html:body": "<div class=\"container\"><div class=\"page-header\"><h1>Sign up</h1></div>{#with _page.form}<form role=\"form\" x-bind=\"submit: user.signup\"><div class=\"form-group\"><label class=\"control-label\" for=\"username\">Username</label><div class=\"input-group\"><span class=\"input-group-addon\"><i class=\"fa fa-user\"></i></span><input id=\"username\" class=\"form-control\" autofocus placeholder=\"Username\" type=\"text\" value=\"{.username}\"></div></div><div class=\"form-group\"><label class=\"control-label\" for=\"email\">Email</label><div class=\"input-group\"><span class=\"input-group-addon\"><i class=\"fa fa-envelope\"></i></span><input id=\"email\" class=\"form-control\" placeholder=\"Email\" type=\"email\" value=\"{.email}\"></div></div><div class=\"form-group\"><label class=\"control-label\" for=\"password\">Password</label><div class=\"input-group\"><span class=\"input-group-addon\"><i class=\"fa fa-key\"></i></span><input id=\"password\" class=\"form-control\" placeholder=\"Password\" type=\"password\" value=\"{.password}\"></div></div><button class=\"btn btn-primary\" type=\"submit\">Sign up</button></form>{/}<hr><p class=\"lead\">Or sign up using</p><div class=\"visible-xs\"><a class=\"btn btn-default\" x-bind=\"click: user.connect.facebook\"><i class=\"fa fa-facebook fa-lg\"></i></a> <a class=\"btn btn-default\" x-bind=\"click: user.connect.google\"><i class=\"fa fa-google-plus fa-lg\"></i></a> <a class=\"btn btn-default\" x-bind=\"click: user.connect.twitter\"><i class=\"fa fa-twitter fa-lg\"></i></a></div><div class=\"hidden-xs\"><a class=\"btn btn-default\" x-bind=\"click: user.connect.facebook\"><i class=\"fa fa-facebook-square\"></i> Facebook</a> <a class=\"btn btn-default\" x-bind=\"click: user.connect.google\"><i class=\"fa fa-google-plus-square\"></i> Google+</a> <a class=\"btn btn-default\" x-bind=\"click: user.connect.twitter\"><i class=\"fa fa-twitter-square\"></i> Twitter</a></div></div>",
  "app/signup.html:title": "Sign up"
}, {
  "403:body": [
  "app/403.html:body",
  {}
],
  "403:title": [
  "app/403.html:title",
  {}
],
  "404:body": [
  "app/404.html:body",
  {}
],
  "404:title": [
  "app/404.html:title",
  {}
],
  "500:body": [
  "app/500.html:body",
  {}
],
  "500:title": [
  "app/500.html:title",
  {}
],
  "footer": [
  "app/index.html:footer",
  {}
],
  "forgot:body": [
  "app/forgot.html:body",
  {}
],
  "forgot:title": [
  "app/forgot.html:title",
  {}
],
  "header": [
  "app/index.html:header",
  {}
],
  "home:body": [
  "app/home.html:body",
  {}
],
  "home:title": [
  "app/home.html:title",
  {}
],
  "navitem": [
  "app/index.html:navitem",
  {}
],
  "reset:body": [
  "app/reset.html:body",
  {}
],
  "reset:title": [
  "app/reset.html:title",
  {}
],
  "scripts": [
  "app/index.html:scripts",
  {}
],
  "settings:body": [
  "app/settings.html:body",
  {}
],
  "settings:title": [
  "app/settings.html:title",
  {}
],
  "signin:body": [
  "app/signin.html:body",
  {}
],
  "signin:title": [
  "app/signin.html:title",
  {}
],
  "signup:body": [
  "app/signup.html:body",
  {}
],
  "signup:title": [
  "app/signup.html:title",
  {}
]
});
view._makeComponents({
  "ghbtns": {
  "instances": {
  "button": [
  "button/index.html:button",
  {}
]
},
  "templates": {
  "button/index.html:button": "{#if :self.show}<iframe allowtransparency=\"true\" frameborder=\"0\" height=\"{:self.height}\" scrolling=\"0\" src=\"{:self.fileurl}?user={:self.user}&repo={:self.repo}&type={@type}{#if @count}&count={@count}{/}{#if @size}&size={@size}{/}\" width=\"{@width}\"></iframe>{/}"
}
},
  "ui": {
  "instances": {
  "connectionalert": [
  "connectionAlert/index.html:connectionalert",
  {}
]
},
  "templates": {
  "connectionAlert/index.html:connectionalert": "{#unless equal($connection.state, 'connected')}<div class=\"alert alert-warning\"><div class=\"container\">{#if equal($connection.state, 'stopped')}Unable to reconnect  <a x-bind=\"click: reload\"><i class=\"fa fa-refresh\"></i> Reload</a>{else}{sentenceCase($connection.state)}  {#if :self.hideReconnect}<i class=\"fa fa-refresh fa-spin\"></i> Reconnecting{else}<a x-bind=\"click: reconnect\"><i class=\"fa fa-refresh\"></i> Reconnect</a>{/}{/}</div></div>{/}"
}
}
});
})();