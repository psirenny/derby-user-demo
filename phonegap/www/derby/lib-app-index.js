require=(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module '"+n+"'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({"racer":[function(require,module,exports){
module.exports=require('CsQUzZ');
},{}],"CsQUzZ":[function(require,module,exports){
var Racer = require('./Racer');
module.exports = new Racer;

},{"./Racer":1}],"derby":[function(require,module,exports){
module.exports=require('9UpRLI');
},{}],"9UpRLI":[function(require,module,exports){
(function(__dirname){var racer = require('racer');
var derby = module.exports = Object.create(racer);

var derbyPlugin = (racer.util.isServer) ?
  __dirname + '/derby.server' :
  require('./derby.browser');

// TODO: Remove or implement
derby.get = function() {}

derby
  // Server-side or browser-side methods
  .use(derbyPlugin);

})("/node_modules/derby/lib")
},{"racer":"CsQUzZ","./derby.browser":2}],3:[function(require,module,exports){
module.exports = function (app) {
  app.fn('user', {
    changeEmail: function (e) {
      var origin = this.model.get('$config.origin');
      $.post(origin + '/user/changeEmail', e.at().get());
    },
    changePassword: function (e) {
      var origin = this.model.get('$config.origin');
      $.post(origin + '/user/changePassword', e.at().get(), function () {
        e.at().del();
      });
    },
    changeUsername: function (e) {
      var origin = this.model.get('$config.origin');
      $.post(origin + '/user/changeUsername', e.at().get());
    },
    connect: {
      facebook: function (e) {
        var origin = this.model.get('$config.origin');
        $.popupWindow(origin + '/user/auth/facebook');
      },
      google: function (e) {
        var origin = this.model.get('$config.origin');
        $.popupWindow(origin + '/user/auth/google');
      },
      twitter: function (e) {
        var origin = this.model.get('$config.origin');
        $.popupWindow(origin + '/user/auth/twitter');
      }
    },
    forgotPassword: function (e) {
      var origin = this.model.get('$config.origin');
      $.post(origin + '/user/forgotPassword', e.at().get(), function () {
        e.at().del();
        e.at().set('success', true);
      });
    },
    resetPassword: function (e) {
      var self = this, origin = this.model.get('$config.origin');
      $.post(origin + '/user/resetPassword', e.at().get(), function (data) {
        self.model.set('_session.user.id', e.at().get('userId'));
        self.model.set('_session.user.isRegistered', true);
      });
    },
    signin: function (e) {
      var self = this, origin = this.model.get('$config.origin');
      $.post(origin + '/user/signin', e.at().get(), function (data) {
        self.model.set('_session.user.id', data.user.id);
        self.model.set('_session.user.isRegistered', true);
      });
    },
    signout: function (e) {
      var self = this, origin = this.model.get('$config.origin');
      $.post(origin + '/user/signout', function (data) {
        self.model.set('_session.user.id', data.user.id);
        self.model.set('_session.user.isRegistered', false);
      });
    },
    signup: function (e) {
      var self = this, origin = this.model.get('$config.origin');
      $.post(origin + '/user/signup', e.at().get(), function () {
        self.model.set('_session.user.isRegistered', true);
      });
    },
    verifyEmail: function (e) {
      var self = this, origin = this.model.get('$config.origin');
      $.post(origin + '/user/verifyEmail', e.at().get());
    }
  });
};
},{}],4:[function(require,module,exports){
module.exports = function (app) {
  app.ready(function (model) {
    model.on('change', '$connection.state', function (state) {
      if (state !== 'connected') return;
      if (model.get('_session.user.id')) return;
      var origin = model.get('$config.origin');
      $.ajax({type: 'POST', url: origin + '/user/sessionize'}).done(function (data) {
        model.set('_session.user.id', data.user.id);
        model.set('_session.user.registered', data.user.registered);
      });
    });

    model.on('change', '_session.user.id', function (userId) {
      if (!userId) return;
      var $private = model.at('usersPrivate.' + userId);
      var $public = model.at('usersPublic.' + userId);
      model.subscribe($private, $public, function (err) {
        if (err) return console.error(err);
        model.ref('_page.user.private', $private);
        model.ref('_page.user.public', $public);
        var isRegistered = $public.get('isRegistered');
        if (model.get('_page.private') && !isRegistered) return app.history.push('/');
        if (model.get('_page.public') && isRegistered) app.history.push('/settings');
      });
    });

    model.on('change', '_session.user.isRegistered', function (isRegistered) {
      if (model.get('_page.private') && !isRegistered) return app.history.push('/');
      if (model.get('_page.public') && isRegistered) app.history.push('/settings');
    });
  });
};
},{}],5:[function(require,module,exports){
module.exports = function (app) {
  app.get('*', function (page, model, params, next) {
    var userId = model.get('_session.user.id');
    if (!userId) return next();
    var $private = model.at('usersPrivate.' + userId);
    var $public = model.at('usersPublic.' + userId);
    model.subscribe($private, $public, function (err) {
      if (err) return next(err);
      model.ref('_page.user.private', $private);
      model.ref('_page.user.public', $public);
      next();
    });
  });
};
},{}],6:[function(require,module,exports){
module.exports = function (app) {
  app.get('/', function (page) {
    page.render('home');
  });

  app.get('/403', function (page) {
    page.render('403');
  });

  app.get('/404', function (page) {
    page.render('404');
  });

  app.get('/404', function (page) {
    page.render('404');
  });

  app.get('/500', function (page) {
    page.render('500');
  });

  app.get('/forgot', function (page, model) {
    model.set('_page.public', true);
    page.render('forgot');
  });

  app.get('/reset/:userId/:token', function (page, model) {
    model.set('_page.form.token', page.params.token);
    model.set('_page.form.userId', page.params.userId);
    model.set('_page.public', true);
    page.render('reset');
  });

  app.get('/settings', function (page, model) {
    model.setNull('_page.form.username.username', model.get('_page.user.public.local.username'));
    model.setNull('_page.form.email.email', model.get('_page.user.private.local.emails.0.value'));
    model.set('_page.private', true);
    page.render('settings');
  });

  app.get('/signin', function (page, model) {
    model.set('_page.public', true);
    page.render('signin');
  });

  app.get('/signup', function (page, model) {
    model.set('_page.public', true);
    page.render('signup');
  });

  app.get('/user/auth/:provider/done', function (page, model) {
    page.render('home');
  });

  app.enter('/user/auth/:provider/done', function (model) {
    if (!window.opener) return;
    var userId = model.get('_session.user.id');
    window.opener.DERBY.app.model.set('_session.user.id', userId);
    window.opener.DERBY.app.model.set('_session.user.registered', true);
    window.close();
  });
};
},{}],7:[function(require,module,exports){
var url = require('url');

module.exports = function (app) {
  app.view.fn('user.displayName', function (public) {
    if (public.local) return public.local.username;
    if (public.facebook) return public.facebook.displayName;
    if (public.google) return public.google.displayName;
    if (public.twitter) return public.twitter.displayName;
  });

  app.view.fn('user.photoUrl', function (public) {
    if (public.facebook) return 'https://graph.facebook.com/' + public.facebook.username + '/picture';
    if (public.google && public.google.photos && public.google.photos[0]) return public.google.photos[0].value;
    if (public.twitter && public.twitter.photos && public.twitter.photos[0]) return public.twitter.photos[0].value;
    if (public.gravatar && public.gravatar.thumbnailUrl) return public.gravatar.thumbnailUrl;
  });
};
},{"url":8}],9:[function(require,module,exports){
var racer = require('racer');
var BCSocket = require('browserchannel/dist/bcsocket-uncompressed').BCSocket;

racer.Model.prototype._createSocket = function(bundle) {
  var options = bundle.racerBrowserChannel;
  var base = options.base || 'http://localhost:3000/channel';
  if (bundle.mount) base = bundle.mount + base;
  return new BCSocket(base, options);
};

},{"racer":"CsQUzZ","browserchannel/dist/bcsocket-uncompressed":10}],11:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],12:[function(require,module,exports){
(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};

var EventEmitter = exports.EventEmitter = process.EventEmitter;
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]'
    }
;
function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (x === xs[i]) return i;
    }
    return -1;
}

// By default EventEmitters will print a warning if more than
// 10 listeners are added to it. This is a useful default which
// helps finding memory leaks.
//
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!this._events) this._events = {};
  this._events.maxListeners = n;
};


EventEmitter.prototype.emit = function(type) {
  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events || !this._events.error ||
        (isArray(this._events.error) && !this._events.error.length))
    {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }
  }

  if (!this._events) return false;
  var handler = this._events[type];
  if (!handler) return false;

  if (typeof handler == 'function') {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        var args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
    return true;

  } else if (isArray(handler)) {
    var args = Array.prototype.slice.call(arguments, 1);

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i].apply(this, args);
    }
    return true;

  } else {
    return false;
  }
};

// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('addListener only takes instances of Function');
  }

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  } else if (isArray(this._events[type])) {

    // Check for listener leak
    if (!this._events[type].warned) {
      var m;
      if (this._events.maxListeners !== undefined) {
        m = this._events.maxListeners;
      } else {
        m = defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }

    // If we've already got an array, just append.
    this._events[type].push(listener);
  } else {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  var self = this;
  self.on(type, function g() {
    self.removeListener(type, g);
    listener.apply(this, arguments);
  });

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('removeListener only takes instances of Function');
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (!this._events || !this._events[type]) return this;

  var list = this._events[type];

  if (isArray(list)) {
    var i = indexOf(list, listener);
    if (i < 0) return this;
    list.splice(i, 1);
    if (list.length == 0)
      delete this._events[type];
  } else if (this._events[type] === listener) {
    delete this._events[type];
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  if (arguments.length === 0) {
    this._events = {};
    return this;
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (type && this._events && this._events[type]) this._events[type] = null;
  return this;
};

EventEmitter.prototype.listeners = function(type) {
  if (!this._events) this._events = {};
  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
};

})(require("__browserify_process"))
},{"__browserify_process":11}],8:[function(require,module,exports){
var punycode = { encode : function (s) { return s } };

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

function arrayIndexOf(array, subject) {
    for (var i = 0, j = array.length; i < j; i++) {
        if(array[i] == subject) return i;
    }
    return -1;
}

var objectKeys = Object.keys || function objectKeys(object) {
    if (object !== Object(object)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in object) if (object.hasOwnProperty(key)) keys[keys.length] = key;
    return keys;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]+$/,
    // RFC 2396: characters reserved for delimiting URLs.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '~', '[', ']', '`'].concat(delims),
    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''],
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#']
      .concat(unwise).concat(autoEscape),
    nonAuthChars = ['/', '@', '?', '#'].concat(delims),
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-zA-Z0-9][a-z0-9A-Z_-]{0,62}$/,
    hostnamePartStart = /^([a-zA-Z0-9][a-z0-9A-Z_-]{0,62})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always have a path component.
    pathedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && typeof(url) === 'object' && url.href) return url;

  if (typeof url !== 'string') {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var out = {},
      rest = url;

  // cut off any delimiters.
  // This is to support parse stuff like "<http://foo.com>"
  for (var i = 0, l = rest.length; i < l; i++) {
    if (arrayIndexOf(delims, rest.charAt(i)) === -1) break;
  }
  if (i !== 0) rest = rest.substr(i);


  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    out.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      out.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {
    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    // don't enforce full RFC correctness, just be unstupid about it.

    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the first @ sign, unless some non-auth character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    var atSign = arrayIndexOf(rest, '@');
    if (atSign !== -1) {
      // there *may be* an auth
      var hasAuth = true;
      for (var i = 0, l = nonAuthChars.length; i < l; i++) {
        var index = arrayIndexOf(rest, nonAuthChars[i]);
        if (index !== -1 && index < atSign) {
          // not a valid auth.  Something like http://foo.com/bar@baz/
          hasAuth = false;
          break;
        }
      }
      if (hasAuth) {
        // pluck off the auth portion.
        out.auth = rest.substr(0, atSign);
        rest = rest.substr(atSign + 1);
      }
    }

    var firstNonHost = -1;
    for (var i = 0, l = nonHostChars.length; i < l; i++) {
      var index = arrayIndexOf(rest, nonHostChars[i]);
      if (index !== -1 &&
          (firstNonHost < 0 || index < firstNonHost)) firstNonHost = index;
    }

    if (firstNonHost !== -1) {
      out.host = rest.substr(0, firstNonHost);
      rest = rest.substr(firstNonHost);
    } else {
      out.host = rest;
      rest = '';
    }

    // pull out port.
    var p = parseHost(out.host);
    var keys = objectKeys(p);
    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      out[key] = p[key];
    }

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    out.hostname = out.hostname || '';

    // validate a little.
    if (out.hostname.length > hostnameMaxLen) {
      out.hostname = '';
    } else {
      var hostparts = out.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            out.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    // hostnames are always lower case.
    out.hostname = out.hostname.toLowerCase();

    // IDNA Support: Returns a puny coded representation of "domain".
    // It only converts the part of the domain name that
    // has non ASCII characters. I.e. it dosent matter if
    // you call it with a domain that already is in ASCII.
    var domainArray = out.hostname.split('.');
    var newOut = [];
    for (var i = 0; i < domainArray.length; ++i) {
      var s = domainArray[i];
      newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
          'xn--' + punycode.encode(s) : s);
    }
    out.hostname = newOut.join('.');

    out.host = (out.hostname || '') +
        ((out.port) ? ':' + out.port : '');
    out.href += out.host;
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }

    // Now make sure that delims never appear in a url.
    var chop = rest.length;
    for (var i = 0, l = delims.length; i < l; i++) {
      var c = arrayIndexOf(rest, delims[i]);
      if (c !== -1) {
        chop = Math.min(c, chop);
      }
    }
    rest = rest.substr(0, chop);
  }


  // chop off from the tail first.
  var hash = arrayIndexOf(rest, '#');
  if (hash !== -1) {
    // got a fragment string.
    out.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = arrayIndexOf(rest, '?');
  if (qm !== -1) {
    out.search = rest.substr(qm);
    out.query = rest.substr(qm + 1);
    if (parseQueryString) {
      out.query = querystring.parse(out.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    out.search = '';
    out.query = {};
  }
  if (rest) out.pathname = rest;
  if (slashedProtocol[proto] &&
      out.hostname && !out.pathname) {
    out.pathname = '/';
  }

  //to support http.request
  if (out.pathname || out.search) {
    out.path = (out.pathname ? out.pathname : '') +
               (out.search ? out.search : '');
  }

  // finally, reconstruct the href based on what has been validated.
  out.href = urlFormat(out);
  return out;
}

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (typeof(obj) === 'string') obj = urlParse(obj);

  var auth = obj.auth || '';
  if (auth) {
    auth = auth.split('@').join('%40');
    for (var i = 0, l = nonAuthChars.length; i < l; i++) {
      var nAC = nonAuthChars[i];
      auth = auth.split(nAC).join(encodeURIComponent(nAC));
    }
    auth += '@';
  }

  var protocol = obj.protocol || '',
      host = (obj.host !== undefined) ? auth + obj.host :
          obj.hostname !== undefined ? (
              auth + obj.hostname +
              (obj.port ? ':' + obj.port : '')
          ) :
          false,
      pathname = obj.pathname || '',
      query = obj.query &&
              ((typeof obj.query === 'object' &&
                objectKeys(obj.query).length) ?
                 querystring.stringify(obj.query) :
                 '') || '',
      search = obj.search || (query && ('?' + query)) || '',
      hash = obj.hash || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (obj.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  return protocol + host + pathname + search + hash;
}

function urlResolve(source, relative) {
  return urlFormat(urlResolveObject(source, relative));
}

function urlResolveObject(source, relative) {
  if (!source) return relative;

  source = urlParse(urlFormat(source), false, true);
  relative = urlParse(urlFormat(relative), false, true);

  // hash is always overridden, no matter what.
  source.hash = relative.hash;

  if (relative.href === '') {
    source.href = urlFormat(source);
    return source;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    relative.protocol = source.protocol;
    //urlParse appends trailing / to urls like http:http://www.example.com
    if (slashedProtocol[relative.protocol] &&
        relative.hostname && !relative.pathname) {
      relative.path = relative.pathname = '/';
    }
    relative.href = urlFormat(relative);
    return relative;
  }

  if (relative.protocol && relative.protocol !== source.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      relative.href = urlFormat(relative);
      return relative;
    }
    source.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      relative.pathname = relPath.join('/');
    }
    source.pathname = relative.pathname;
    source.search = relative.search;
    source.query = relative.query;
    source.host = relative.host || '';
    source.auth = relative.auth;
    source.hostname = relative.hostname || relative.host;
    source.port = relative.port;
    //to support http.request
    if (source.pathname !== undefined || source.search !== undefined) {
      source.path = (source.pathname ? source.pathname : '') +
                    (source.search ? source.search : '');
    }
    source.slashes = source.slashes || relative.slashes;
    source.href = urlFormat(source);
    return source;
  }

  var isSourceAbs = (source.pathname && source.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host !== undefined ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (source.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = source.pathname && source.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = source.protocol &&
          !slashedProtocol[source.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // source.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {

    delete source.hostname;
    delete source.port;
    if (source.host) {
      if (srcPath[0] === '') srcPath[0] = source.host;
      else srcPath.unshift(source.host);
    }
    delete source.host;
    if (relative.protocol) {
      delete relative.hostname;
      delete relative.port;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      delete relative.host;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    source.host = (relative.host || relative.host === '') ?
                      relative.host : source.host;
    source.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : source.hostname;
    source.search = relative.search;
    source.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    source.search = relative.search;
    source.query = relative.query;
  } else if ('search' in relative) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      source.hostname = source.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = source.host && arrayIndexOf(source.host, '@') > 0 ?
                       source.host.split('@') : false;
      if (authInHost) {
        source.auth = authInHost.shift();
        source.host = source.hostname = authInHost.shift();
      }
    }
    source.search = relative.search;
    source.query = relative.query;
    //to support http.request
    if (source.pathname !== undefined || source.search !== undefined) {
      source.path = (source.pathname ? source.pathname : '') +
                    (source.search ? source.search : '');
    }
    source.href = urlFormat(source);
    return source;
  }
  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    delete source.pathname;
    //to support http.request
    if (!source.search) {
      source.path = '/' + source.search;
    } else {
      delete source.path;
    }
    source.href = urlFormat(source);
    return source;
  }
  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (source.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    source.hostname = source.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = source.host && arrayIndexOf(source.host, '@') > 0 ?
                     source.host.split('@') : false;
    if (authInHost) {
      source.auth = authInHost.shift();
      source.host = source.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (source.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  source.pathname = srcPath.join('/');
  //to support request.http
  if (source.pathname !== undefined || source.search !== undefined) {
    source.path = (source.pathname ? source.pathname : '') +
                  (source.search ? source.search : '');
  }
  source.auth = relative.auth || source.auth;
  source.slashes = source.slashes || relative.slashes;
  source.href = urlFormat(source);
  return source;
}

function parseHost(host) {
  var out = {};
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    out.port = port.substr(1);
    host = host.substr(0, host.length - port.length);
  }
  if (host) out.hostname = host;
  return out;
}

},{"querystring":13}],10:[function(require,module,exports){
(function(){
function e() {
  return function() {
  }
}
function m(a) {
  return function(b) {
    this[a] = b
  }
}
function aa(a) {
  return function() {
    return this[a]
  }
}
function ba(a) {
  return function() {
    return a
  }
}
var p, ca = ca || {}, q = this;
function da(a) {
  a = a.split(".");
  for(var b = q, c;c = a.shift();) {
    if(null != b[c]) {
      b = b[c]
    }else {
      return null
    }
  }
  return b
}
function ea() {
}
function fa(a) {
  var b = typeof a;
  if("object" == b) {
    if(a) {
      if(a instanceof Array) {
        return"array"
      }
      if(a instanceof Object) {
        return b
      }
      var c = Object.prototype.toString.call(a);
      if("[object Window]" == c) {
        return"object"
      }
      if("[object Array]" == c || "number" == typeof a.length && "undefined" != typeof a.splice && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("splice")) {
        return"array"
      }
      if("[object Function]" == c || "undefined" != typeof a.call && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("call")) {
        return"function"
      }
    }else {
      return"null"
    }
  }else {
    if("function" == b && "undefined" == typeof a.call) {
      return"object"
    }
  }
  return b
}
function s(a) {
  return"array" == fa(a)
}
function ga(a) {
  var b = fa(a);
  return"array" == b || "object" == b && "number" == typeof a.length
}
function u(a) {
  return"string" == typeof a
}
function ha(a) {
  return"function" == fa(a)
}
function v(a) {
  return a[ia] || (a[ia] = ++ja)
}
var ia = "closure_uid_" + (1E9 * Math.random() >>> 0), ja = 0;
function ka(a, b, c) {
  return a.call.apply(a.bind, arguments)
}
function la(a, b, c) {
  if(!a) {
    throw Error();
  }
  if(2 < arguments.length) {
    var d = Array.prototype.slice.call(arguments, 2);
    return function() {
      var c = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(c, d);
      return a.apply(b, c)
    }
  }
  return function() {
    return a.apply(b, arguments)
  }
}
function w(a, b, c) {
  w = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? ka : la;
  return w.apply(null, arguments)
}
var x = Date.now || function() {
  return+new Date
};
function y(a, b) {
  function c() {
  }
  c.prototype = b.prototype;
  a.ra = b.prototype;
  a.prototype = new c
}
;function ma(a, b) {
  for(var c = 1;c < arguments.length;c++) {
    var d = String(arguments[c]).replace(/\$/g, "$$$$");
    a = a.replace(/\%s/, d)
  }
  return a
}
function na(a) {
  if(!oa.test(a)) {
    return a
  }
  -1 != a.indexOf("&") && (a = a.replace(pa, "&amp;"));
  -1 != a.indexOf("<") && (a = a.replace(qa, "&lt;"));
  -1 != a.indexOf(">") && (a = a.replace(ra, "&gt;"));
  -1 != a.indexOf('"') && (a = a.replace(sa, "&quot;"));
  return a
}
var pa = /&/g, qa = /</g, ra = />/g, sa = /\"/g, oa = /[&<>\"]/;
var z, ta, ua, va;
function wa() {
  return q.navigator ? q.navigator.userAgent : null
}
va = ua = ta = z = !1;
var xa;
if(xa = wa()) {
  var ya = q.navigator;
  z = 0 == xa.indexOf("Opera");
  ta = !z && -1 != xa.indexOf("MSIE");
  ua = !z && -1 != xa.indexOf("WebKit");
  va = !z && !ua && "Gecko" == ya.product
}
var za = z, A = ta, Aa = va, B = ua, Ba = q.navigator, Ca = -1 != (Ba && Ba.platform || "").indexOf("Mac");
function Da() {
  var a = q.document;
  return a ? a.documentMode : void 0
}
var Ea;
a: {
  var Fa = "", Ga;
  if(za && q.opera) {
    var Ha = q.opera.version, Fa = "function" == typeof Ha ? Ha() : Ha
  }else {
    if(Aa ? Ga = /rv\:([^\);]+)(\)|;)/ : A ? Ga = /MSIE\s+([^\);]+)(\)|;)/ : B && (Ga = /WebKit\/(\S+)/), Ga) {
      var Ia = Ga.exec(wa()), Fa = Ia ? Ia[1] : ""
    }
  }
  if(A) {
    var Ja = Da();
    if(Ja > parseFloat(Fa)) {
      Ea = String(Ja);
      break a
    }
  }
  Ea = Fa
}
var Ka = {};
function C(a) {
  var b;
  if(!(b = Ka[a])) {
    b = 0;
    for(var c = String(Ea).replace(/^[\s\xa0]+|[\s\xa0]+$/g, "").split("."), d = String(a).replace(/^[\s\xa0]+|[\s\xa0]+$/g, "").split("."), f = Math.max(c.length, d.length), g = 0;0 == b && g < f;g++) {
      var h = c[g] || "", n = d[g] || "", k = RegExp("(\\d*)(\\D*)", "g"), t = RegExp("(\\d*)(\\D*)", "g");
      do {
        var l = k.exec(h) || ["", "", ""], r = t.exec(n) || ["", "", ""];
        if(0 == l[0].length && 0 == r[0].length) {
          break
        }
        b = ((0 == l[1].length ? 0 : parseInt(l[1], 10)) < (0 == r[1].length ? 0 : parseInt(r[1], 10)) ? -1 : (0 == l[1].length ? 0 : parseInt(l[1], 10)) > (0 == r[1].length ? 0 : parseInt(r[1], 10)) ? 1 : 0) || ((0 == l[2].length) < (0 == r[2].length) ? -1 : (0 == l[2].length) > (0 == r[2].length) ? 1 : 0) || (l[2] < r[2] ? -1 : l[2] > r[2] ? 1 : 0)
      }while(0 == b)
    }
    b = Ka[a] = 0 <= b
  }
  return b
}
var La = q.document, Ma = La && A ? Da() || ("CSS1Compat" == La.compatMode ? parseInt(Ea, 10) : 5) : void 0;
function Na(a) {
  Error.captureStackTrace ? Error.captureStackTrace(this, Na) : this.stack = Error().stack || "";
  a && (this.message = String(a))
}
y(Na, Error);
Na.prototype.name = "CustomError";
function Oa(a, b) {
  b.unshift(a);
  Na.call(this, ma.apply(null, b));
  b.shift();
  this.Jc = a
}
y(Oa, Na);
Oa.prototype.name = "AssertionError";
function Pa(a, b) {
  throw new Oa("Failure" + (a ? ": " + a : ""), Array.prototype.slice.call(arguments, 1));
}
;var Qa = RegExp("^(?:([^:/?#.]+):)?(?://(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#(.*))?$");
function Ra(a) {
  var b = Sa, c;
  for(c in b) {
    a.call(void 0, b[c], c, b)
  }
}
function Ta(a) {
  var b = [], c = 0, d;
  for(d in a) {
    b[c++] = a[d]
  }
  return b
}
function Ua(a) {
  var b = [], c = 0, d;
  for(d in a) {
    b[c++] = d
  }
  return b
}
var Va = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
function Wa(a, b) {
  for(var c, d, f = 1;f < arguments.length;f++) {
    d = arguments[f];
    for(c in d) {
      a[c] = d[c]
    }
    for(var g = 0;g < Va.length;g++) {
      c = Va[g], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c])
    }
  }
}
;var D = Array.prototype, Xa = D.indexOf ? function(a, b, c) {
  return D.indexOf.call(a, b, c)
} : function(a, b, c) {
  c = null == c ? 0 : 0 > c ? Math.max(0, a.length + c) : c;
  if(u(a)) {
    return u(b) && 1 == b.length ? a.indexOf(b, c) : -1
  }
  for(;c < a.length;c++) {
    if(c in a && a[c] === b) {
      return c
    }
  }
  return-1
}, Ya = D.forEach ? function(a, b, c) {
  D.forEach.call(a, b, c)
} : function(a, b, c) {
  for(var d = a.length, f = u(a) ? a.split("") : a, g = 0;g < d;g++) {
    g in f && b.call(c, f[g], g, a)
  }
};
function Za(a) {
  return D.concat.apply(D, arguments)
}
function $a(a) {
  var b = a.length;
  if(0 < b) {
    for(var c = Array(b), d = 0;d < b;d++) {
      c[d] = a[d]
    }
    return c
  }
  return[]
}
;function ab(a) {
  if("function" == typeof a.N) {
    return a.N()
  }
  if(u(a)) {
    return a.split("")
  }
  if(ga(a)) {
    for(var b = [], c = a.length, d = 0;d < c;d++) {
      b.push(a[d])
    }
    return b
  }
  return Ta(a)
}
function E(a, b, c) {
  if("function" == typeof a.forEach) {
    a.forEach(b, c)
  }else {
    if(ga(a) || u(a)) {
      Ya(a, b, c)
    }else {
      var d;
      if("function" == typeof a.ka) {
        d = a.ka()
      }else {
        if("function" != typeof a.N) {
          if(ga(a) || u(a)) {
            d = [];
            for(var f = a.length, g = 0;g < f;g++) {
              d.push(g)
            }
          }else {
            d = Ua(a)
          }
        }else {
          d = void 0
        }
      }
      for(var f = ab(a), g = f.length, h = 0;h < g;h++) {
        b.call(c, f[h], d && d[h], a)
      }
    }
  }
}
;function bb(a, b) {
  this.O = {};
  this.j = [];
  var c = arguments.length;
  if(1 < c) {
    if(c % 2) {
      throw Error("Uneven number of arguments");
    }
    for(var d = 0;d < c;d += 2) {
      this.set(arguments[d], arguments[d + 1])
    }
  }else {
    if(a) {
      a instanceof bb ? (c = a.ka(), d = a.N()) : (c = Ua(a), d = Ta(a));
      for(var f = 0;f < c.length;f++) {
        this.set(c[f], d[f])
      }
    }
  }
}
p = bb.prototype;
p.f = 0;
p.bc = 0;
p.N = function() {
  cb(this);
  for(var a = [], b = 0;b < this.j.length;b++) {
    a.push(this.O[this.j[b]])
  }
  return a
};
p.ka = function() {
  cb(this);
  return this.j.concat()
};
p.ia = function(a) {
  return db(this.O, a)
};
p.remove = function(a) {
  return db(this.O, a) ? (delete this.O[a], this.f--, this.bc++, this.j.length > 2 * this.f && cb(this), !0) : !1
};
function cb(a) {
  if(a.f != a.j.length) {
    for(var b = 0, c = 0;b < a.j.length;) {
      var d = a.j[b];
      db(a.O, d) && (a.j[c++] = d);
      b++
    }
    a.j.length = c
  }
  if(a.f != a.j.length) {
    for(var f = {}, c = b = 0;b < a.j.length;) {
      d = a.j[b], db(f, d) || (a.j[c++] = d, f[d] = 1), b++
    }
    a.j.length = c
  }
}
p.get = function(a, b) {
  return db(this.O, a) ? this.O[a] : b
};
p.set = function(a, b) {
  db(this.O, a) || (this.f++, this.j.push(a), this.bc++);
  this.O[a] = b
};
p.n = function() {
  return new bb(this)
};
function db(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b)
}
;function F(a, b) {
  var c;
  if(a instanceof F) {
    this.D = void 0 !== b ? b : a.D, eb(this, a.qa), c = a.ab, H(this), this.ab = c, fb(this, a.ja), gb(this, a.Ba), hb(this, a.H), ib(this, a.R.n()), c = a.Ma, H(this), this.Ma = c
  }else {
    if(a && (c = String(a).match(Qa))) {
      this.D = !!b;
      eb(this, c[1] || "", !0);
      var d = c[2] || "";
      H(this);
      this.ab = d ? decodeURIComponent(d) : "";
      fb(this, c[3] || "", !0);
      gb(this, c[4]);
      hb(this, c[5] || "", !0);
      ib(this, c[6] || "", !0);
      c = c[7] || "";
      H(this);
      this.Ma = c ? decodeURIComponent(c) : ""
    }else {
      this.D = !!b, this.R = new jb(null, 0, this.D)
    }
  }
}
p = F.prototype;
p.qa = "";
p.ab = "";
p.ja = "";
p.Ba = null;
p.H = "";
p.Ma = "";
p.mc = !1;
p.D = !1;
p.toString = function() {
  var a = [], b = this.qa;
  b && a.push(kb(b, lb), ":");
  if(b = this.ja) {
    a.push("//");
    var c = this.ab;
    c && a.push(kb(c, lb), "@");
    a.push(encodeURIComponent(String(b)));
    b = this.Ba;
    null != b && a.push(":", String(b))
  }
  if(b = this.H) {
    this.ja && "/" != b.charAt(0) && a.push("/"), a.push(kb(b, "/" == b.charAt(0) ? mb : nb))
  }
  (b = this.R.toString()) && a.push("?", b);
  (b = this.Ma) && a.push("#", kb(b, ob));
  return a.join("")
};
p.n = function() {
  return new F(this)
};
function eb(a, b, c) {
  H(a);
  a.qa = c ? b ? decodeURIComponent(b) : "" : b;
  a.qa && (a.qa = a.qa.replace(/:$/, ""))
}
function fb(a, b, c) {
  H(a);
  a.ja = c ? b ? decodeURIComponent(b) : "" : b
}
function gb(a, b) {
  H(a);
  if(b) {
    b = Number(b);
    if(isNaN(b) || 0 > b) {
      throw Error("Bad port number " + b);
    }
    a.Ba = b
  }else {
    a.Ba = null
  }
}
function hb(a, b, c) {
  H(a);
  a.H = c ? b ? decodeURIComponent(b) : "" : b
}
function ib(a, b, c) {
  H(a);
  b instanceof jb ? (a.R = b, a.R.qb(a.D)) : (c || (b = kb(b, pb)), a.R = new jb(b, 0, a.D))
}
function I(a, b, c) {
  H(a);
  a.R.set(b, c)
}
function qb(a, b, c) {
  H(a);
  s(c) || (c = [String(c)]);
  rb(a.R, b, c)
}
function J(a) {
  H(a);
  I(a, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ x()).toString(36));
  return a
}
function H(a) {
  if(a.mc) {
    throw Error("Tried to modify a read-only Uri");
  }
}
p.qb = function(a) {
  this.D = a;
  this.R && this.R.qb(a);
  return this
};
function sb(a, b, c, d) {
  var f = new F(null, void 0);
  a && eb(f, a);
  b && fb(f, b);
  c && gb(f, c);
  d && hb(f, d);
  return f
}
function kb(a, b) {
  return u(a) ? encodeURI(a).replace(b, tb) : null
}
function tb(a) {
  a = a.charCodeAt(0);
  return"%" + (a >> 4 & 15).toString(16) + (a & 15).toString(16)
}
var lb = /[#\/\?@]/g, nb = /[\#\?:]/g, mb = /[\#\?]/g, pb = /[\#\?@]/g, ob = /#/g;
function jb(a, b, c) {
  this.C = a || null;
  this.D = !!c
}
function K(a) {
  if(!a.i && (a.i = new bb, a.f = 0, a.C)) {
    for(var b = a.C.split("&"), c = 0;c < b.length;c++) {
      var d = b[c].indexOf("="), f = null, g = null;
      0 <= d ? (f = b[c].substring(0, d), g = b[c].substring(d + 1)) : f = b[c];
      f = decodeURIComponent(f.replace(/\+/g, " "));
      f = L(a, f);
      a.add(f, g ? decodeURIComponent(g.replace(/\+/g, " ")) : "")
    }
  }
}
p = jb.prototype;
p.i = null;
p.f = null;
p.add = function(a, b) {
  K(this);
  this.C = null;
  a = L(this, a);
  var c = this.i.get(a);
  c || this.i.set(a, c = []);
  c.push(b);
  this.f++;
  return this
};
p.remove = function(a) {
  K(this);
  a = L(this, a);
  return this.i.ia(a) ? (this.C = null, this.f -= this.i.get(a).length, this.i.remove(a)) : !1
};
p.ia = function(a) {
  K(this);
  a = L(this, a);
  return this.i.ia(a)
};
p.ka = function() {
  K(this);
  for(var a = this.i.N(), b = this.i.ka(), c = [], d = 0;d < b.length;d++) {
    for(var f = a[d], g = 0;g < f.length;g++) {
      c.push(b[d])
    }
  }
  return c
};
p.N = function(a) {
  K(this);
  var b = [];
  if(a) {
    this.ia(a) && (b = Za(b, this.i.get(L(this, a))))
  }else {
    a = this.i.N();
    for(var c = 0;c < a.length;c++) {
      b = Za(b, a[c])
    }
  }
  return b
};
p.set = function(a, b) {
  K(this);
  this.C = null;
  a = L(this, a);
  this.ia(a) && (this.f -= this.i.get(a).length);
  this.i.set(a, [b]);
  this.f++;
  return this
};
p.get = function(a, b) {
  var c = a ? this.N(a) : [];
  return 0 < c.length ? String(c[0]) : b
};
function rb(a, b, c) {
  a.remove(b);
  0 < c.length && (a.C = null, a.i.set(L(a, b), $a(c)), a.f += c.length)
}
p.toString = function() {
  if(this.C) {
    return this.C
  }
  if(!this.i) {
    return""
  }
  for(var a = [], b = this.i.ka(), c = 0;c < b.length;c++) {
    for(var d = b[c], f = encodeURIComponent(String(d)), d = this.N(d), g = 0;g < d.length;g++) {
      var h = f;
      "" !== d[g] && (h += "=" + encodeURIComponent(String(d[g])));
      a.push(h)
    }
  }
  return this.C = a.join("&")
};
p.n = function() {
  var a = new jb;
  a.C = this.C;
  this.i && (a.i = this.i.n(), a.f = this.f);
  return a
};
function L(a, b) {
  var c = String(b);
  a.D && (c = c.toLowerCase());
  return c
}
p.qb = function(a) {
  a && !this.D && (K(this), this.C = null, E(this.i, function(a, c) {
    var d = c.toLowerCase();
    c != d && (this.remove(c), rb(this, d, a))
  }, this));
  this.D = a
};
function ub() {
}
ub.prototype.Ga = null;
var vb;
function wb() {
}
y(wb, ub);
function xb(a) {
  return(a = yb(a)) ? new ActiveXObject(a) : new XMLHttpRequest
}
function zb(a) {
  var b = {};
  yb(a) && (b[0] = !0, b[1] = !0);
  return b
}
function yb(a) {
  if(!a.Gb && "undefined" == typeof XMLHttpRequest && "undefined" != typeof ActiveXObject) {
    for(var b = ["MSXML2.XMLHTTP.6.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP"], c = 0;c < b.length;c++) {
      var d = b[c];
      try {
        return new ActiveXObject(d), a.Gb = d
      }catch(f) {
      }
    }
    throw Error("Could not create ActiveXObject. ActiveX might be disabled, or MSXML might not be installed");
  }
  return a.Gb
}
vb = new wb;
function M() {
  0 != Ab && (this.Gc = Error().stack, Bb[v(this)] = this)
}
var Ab = 0, Bb = {};
M.prototype.yb = !1;
M.prototype.Ia = function() {
  if(!this.yb && (this.yb = !0, this.u(), 0 != Ab)) {
    var a = v(this);
    delete Bb[a]
  }
};
M.prototype.u = function() {
  if(this.Nb) {
    for(;this.Nb.length;) {
      this.Nb.shift()()
    }
  }
};
function N(a, b) {
  this.type = a;
  this.currentTarget = this.target = b
}
p = N.prototype;
p.u = e();
p.Ia = e();
p.na = !1;
p.defaultPrevented = !1;
p.Wa = !0;
p.preventDefault = function() {
  this.defaultPrevented = !0;
  this.Wa = !1
};
var Cb = 0;
function Db() {
}
p = Db.prototype;
p.key = 0;
p.ea = !1;
p.Ha = !1;
p.Oa = function(a, b, c, d, f, g) {
  if(ha(a)) {
    this.Ib = !0
  }else {
    if(a && a.handleEvent && ha(a.handleEvent)) {
      this.Ib = !1
    }else {
      throw Error("Invalid listener argument");
    }
  }
  this.W = a;
  this.Ub = b;
  this.src = c;
  this.type = d;
  this.capture = !!f;
  this.lb = g;
  this.Ha = !1;
  this.key = ++Cb;
  this.ea = !1
};
p.handleEvent = function(a) {
  return this.Ib ? this.W.call(this.lb || this.src, a) : this.W.handleEvent.call(this.W, a)
};
var Eb = !A || A && 9 <= Ma, Fb = A && !C("9");
!B || C("528");
Aa && C("1.9b") || A && C("8") || za && C("9.5") || B && C("528");
Aa && !C("8") || A && C("9");
function Gb(a) {
  Gb[" "](a);
  return a
}
Gb[" "] = ea;
function Hb(a, b) {
  a && this.Oa(a, b)
}
y(Hb, N);
p = Hb.prototype;
p.target = null;
p.relatedTarget = null;
p.offsetX = 0;
p.offsetY = 0;
p.clientX = 0;
p.clientY = 0;
p.screenX = 0;
p.screenY = 0;
p.button = 0;
p.keyCode = 0;
p.charCode = 0;
p.ctrlKey = !1;
p.altKey = !1;
p.shiftKey = !1;
p.metaKey = !1;
p.yc = !1;
p.zb = null;
p.Oa = function(a, b) {
  var c = this.type = a.type;
  N.call(this, c);
  this.target = a.target || a.srcElement;
  this.currentTarget = b;
  var d = a.relatedTarget;
  if(d) {
    if(Aa) {
      var f;
      a: {
        try {
          Gb(d.nodeName);
          f = !0;
          break a
        }catch(g) {
        }
        f = !1
      }
      f || (d = null)
    }
  }else {
    "mouseover" == c ? d = a.fromElement : "mouseout" == c && (d = a.toElement)
  }
  this.relatedTarget = d;
  this.offsetX = B || void 0 !== a.offsetX ? a.offsetX : a.layerX;
  this.offsetY = B || void 0 !== a.offsetY ? a.offsetY : a.layerY;
  this.clientX = void 0 !== a.clientX ? a.clientX : a.pageX;
  this.clientY = void 0 !== a.clientY ? a.clientY : a.pageY;
  this.screenX = a.screenX || 0;
  this.screenY = a.screenY || 0;
  this.button = a.button;
  this.keyCode = a.keyCode || 0;
  this.charCode = a.charCode || ("keypress" == c ? a.keyCode : 0);
  this.ctrlKey = a.ctrlKey;
  this.altKey = a.altKey;
  this.shiftKey = a.shiftKey;
  this.metaKey = a.metaKey;
  this.yc = Ca ? a.metaKey : a.ctrlKey;
  this.state = a.state;
  this.zb = a;
  a.defaultPrevented && this.preventDefault();
  delete this.na
};
p.preventDefault = function() {
  Hb.ra.preventDefault.call(this);
  var a = this.zb;
  if(a.preventDefault) {
    a.preventDefault()
  }else {
    if(a.returnValue = !1, Fb) {
      try {
        if(a.ctrlKey || 112 <= a.keyCode && 123 >= a.keyCode) {
          a.keyCode = -1
        }
      }catch(b) {
      }
    }
  }
};
p.u = e();
var Sa = {}, O = {}, P = {}, Ib = {};
function Jb(a, b, c, d, f) {
  if(s(b)) {
    for(var g = 0;g < b.length;g++) {
      Jb(a, b[g], c, d, f)
    }
    return null
  }
  a: {
    if(!b) {
      throw Error("Invalid event type");
    }
    d = !!d;
    var h = O;
    b in h || (h[b] = {f:0, t:0});
    h = h[b];
    d in h || (h[d] = {f:0, t:0}, h.f++);
    var h = h[d], g = v(a), n;
    h.t++;
    if(h[g]) {
      n = h[g];
      for(var k = 0;k < n.length;k++) {
        if(h = n[k], h.W == c && h.lb == f) {
          if(h.ea) {
            break
          }
          n[k].Ha = !1;
          a = n[k];
          break a
        }
      }
    }else {
      n = h[g] = [], h.f++
    }
    k = Kb();
    h = new Db;
    h.Oa(c, k, a, b, d, f);
    h.Ha = !1;
    k.src = a;
    k.W = h;
    n.push(h);
    P[g] || (P[g] = []);
    P[g].push(h);
    a.addEventListener ? a != q && a.wb || a.addEventListener(b, k, d) : a.attachEvent(b in Ib ? Ib[b] : Ib[b] = "on" + b, k);
    a = h
  }
  b = a.key;
  Sa[b] = a;
  return b
}
function Kb() {
  var a = Lb, b = Eb ? function(c) {
    return a.call(b.src, b.W, c)
  } : function(c) {
    c = a.call(b.src, b.W, c);
    if(!c) {
      return c
    }
  };
  return b
}
function Mb(a, b, c, d, f) {
  if(s(b)) {
    for(var g = 0;g < b.length;g++) {
      Mb(a, b[g], c, d, f)
    }
  }else {
    d = !!d;
    a: {
      g = O;
      if(b in g && (g = g[b], d in g && (g = g[d], a = v(a), g[a]))) {
        a = g[a];
        break a
      }
      a = null
    }
    if(a) {
      for(g = 0;g < a.length;g++) {
        if(a[g].W == c && a[g].capture == d && a[g].lb == f) {
          Nb(a[g].key);
          break
        }
      }
    }
  }
}
function Nb(a) {
  var b = Sa[a];
  if(!b || b.ea) {
    return!1
  }
  var c = b.src, d = b.type, f = b.Ub, g = b.capture;
  c.removeEventListener ? c != q && c.wb || c.removeEventListener(d, f, g) : c.detachEvent && c.detachEvent(d in Ib ? Ib[d] : Ib[d] = "on" + d, f);
  c = v(c);
  if(P[c]) {
    var f = P[c], h = Xa(f, b);
    0 <= h && D.splice.call(f, h, 1);
    0 == f.length && delete P[c]
  }
  b.ea = !0;
  if(b = O[d][g][c]) {
    b.Mb = !0, Ob(d, g, c, b)
  }
  delete Sa[a];
  return!0
}
function Ob(a, b, c, d) {
  if(!d.Qa && d.Mb) {
    for(var f = 0, g = 0;f < d.length;f++) {
      d[f].ea ? d[f].Ub.src = null : (f != g && (d[g] = d[f]), g++)
    }
    d.length = g;
    d.Mb = !1;
    0 == g && (delete O[a][b][c], O[a][b].f--, 0 == O[a][b].f && (delete O[a][b], O[a].f--), 0 == O[a].f && delete O[a])
  }
}
function Pb(a) {
  var b = 0;
  if(null != a) {
    if(a = v(a), P[a]) {
      a = P[a];
      for(var c = a.length - 1;0 <= c;c--) {
        Nb(a[c].key), b++
      }
    }
  }else {
    Ra(function(a, c) {
      Nb(c);
      b++
    })
  }
}
function Qb(a, b, c, d, f) {
  var g = 1;
  b = v(b);
  if(a[b]) {
    var h = --a.t, n = a[b];
    n.Qa ? n.Qa++ : n.Qa = 1;
    try {
      for(var k = n.length, t = 0;t < k;t++) {
        var l = n[t];
        l && !l.ea && (g &= !1 !== Rb(l, f))
      }
    }finally {
      a.t = Math.max(h, a.t), n.Qa--, Ob(c, d, b, n)
    }
  }
  return Boolean(g)
}
function Rb(a, b) {
  a.Ha && Nb(a.key);
  return a.handleEvent(b)
}
function Lb(a, b) {
  if(a.ea) {
    return!0
  }
  var c = a.type, d = O;
  if(!(c in d)) {
    return!0
  }
  var d = d[c], f, g;
  if(!Eb) {
    f = b || da("window.event");
    var h = !0 in d, n = !1 in d;
    if(h) {
      if(0 > f.keyCode || void 0 != f.returnValue) {
        return!0
      }
      a: {
        var k = !1;
        if(0 == f.keyCode) {
          try {
            f.keyCode = -1;
            break a
          }catch(t) {
            k = !0
          }
        }
        if(k || void 0 == f.returnValue) {
          f.returnValue = !0
        }
      }
    }
    k = new Hb;
    k.Oa(f, this);
    f = !0;
    try {
      if(h) {
        for(var l = [], r = k.currentTarget;r;r = r.parentNode) {
          l.push(r)
        }
        g = d[!0];
        g.t = g.f;
        for(var G = l.length - 1;!k.na && 0 <= G && g.t;G--) {
          k.currentTarget = l[G], f &= Qb(g, l[G], c, !0, k)
        }
        if(n) {
          for(g = d[!1], g.t = g.f, G = 0;!k.na && G < l.length && g.t;G++) {
            k.currentTarget = l[G], f &= Qb(g, l[G], c, !1, k)
          }
        }
      }else {
        f = Rb(a, k)
      }
    }finally {
      l && (l.length = 0)
    }
    return f
  }
  c = new Hb(b, this);
  return f = Rb(a, c)
}
;function Sb() {
  M.call(this)
}
y(Sb, M);
p = Sb.prototype;
p.wb = !0;
p.pb = null;
p.addEventListener = function(a, b, c, d) {
  Jb(this, a, b, c, d)
};
p.removeEventListener = function(a, b, c, d) {
  Mb(this, a, b, c, d)
};
p.dispatchEvent = function(a) {
  var b = a.type || a, c = O;
  if(b in c) {
    if(u(a)) {
      a = new N(a, this)
    }else {
      if(a instanceof N) {
        a.target = a.target || this
      }else {
        var d = a;
        a = new N(b, this);
        Wa(a, d)
      }
    }
    var d = 1, f, c = c[b], b = !0 in c, g;
    if(b) {
      f = [];
      for(g = this;g;g = g.pb) {
        f.push(g)
      }
      g = c[!0];
      g.t = g.f;
      for(var h = f.length - 1;!a.na && 0 <= h && g.t;h--) {
        a.currentTarget = f[h], d &= Qb(g, f[h], a.type, !0, a) && !1 != a.Wa
      }
    }
    if(!1 in c) {
      if(g = c[!1], g.t = g.f, b) {
        for(h = 0;!a.na && h < f.length && g.t;h++) {
          a.currentTarget = f[h], d &= Qb(g, f[h], a.type, !1, a) && !1 != a.Wa
        }
      }else {
        for(f = this;!a.na && f && g.t;f = f.pb) {
          a.currentTarget = f, d &= Qb(g, f, a.type, !1, a) && !1 != a.Wa
        }
      }
    }
    a = Boolean(d)
  }else {
    a = !0
  }
  return a
};
p.u = function() {
  Sb.ra.u.call(this);
  Pb(this);
  this.pb = null
};
function Tb(a, b) {
  M.call(this);
  this.da = a || 1;
  this.Ea = b || q;
  this.eb = w(this.Ec, this);
  this.ob = x()
}
y(Tb, Sb);
p = Tb.prototype;
p.enabled = !1;
p.r = null;
p.setInterval = function(a) {
  this.da = a;
  this.r && this.enabled ? (this.stop(), this.start()) : this.r && this.stop()
};
p.Ec = function() {
  if(this.enabled) {
    var a = x() - this.ob;
    0 < a && a < 0.8 * this.da ? this.r = this.Ea.setTimeout(this.eb, this.da - a) : (this.dispatchEvent(Ub), this.enabled && (this.r = this.Ea.setTimeout(this.eb, this.da), this.ob = x()))
  }
};
p.start = function() {
  this.enabled = !0;
  this.r || (this.r = this.Ea.setTimeout(this.eb, this.da), this.ob = x())
};
p.stop = function() {
  this.enabled = !1;
  this.r && (this.Ea.clearTimeout(this.r), this.r = null)
};
p.u = function() {
  Tb.ra.u.call(this);
  this.stop();
  delete this.Ea
};
var Ub = "tick";
function Vb(a) {
  M.call(this);
  this.e = a;
  this.j = []
}
y(Vb, M);
var Wb = [];
function Xb(a, b, c, d) {
  s(c) || (Wb[0] = c, c = Wb);
  for(var f = 0;f < c.length;f++) {
    var g = Jb(b, c[f], d || a, !1, a.e || a);
    a.j.push(g)
  }
}
Vb.prototype.u = function() {
  Vb.ra.u.call(this);
  Ya(this.j, Nb);
  this.j.length = 0
};
Vb.prototype.handleEvent = function() {
  throw Error("EventHandler.handleEvent not implemented");
};
function Yb(a, b, c) {
  M.call(this);
  this.nc = a;
  this.da = b;
  this.e = c;
  this.hc = w(this.tc, this)
}
y(Yb, M);
p = Yb.prototype;
p.Xa = !1;
p.Tb = 0;
p.r = null;
p.stop = function() {
  this.r && (q.clearTimeout(this.r), this.r = null, this.Xa = !1)
};
p.u = function() {
  Yb.ra.u.call(this);
  this.stop()
};
p.tc = function() {
  this.r = null;
  this.Xa && !this.Tb && (this.Xa = !1, Zb(this))
};
function Zb(a) {
  var b;
  b = a.hc;
  var c = a.da;
  if(!ha(b)) {
    if(b && "function" == typeof b.handleEvent) {
      b = w(b.handleEvent, b)
    }else {
      throw Error("Invalid listener argument");
    }
  }
  b = 2147483647 < c ? -1 : q.setTimeout(b, c || 0);
  a.r = b;
  a.nc.call(a.e)
}
;function Q(a, b, c, d, f) {
  this.b = a;
  this.a = b;
  this.Z = c;
  this.B = d;
  this.Ca = f || 1;
  this.Da = $b;
  this.jb = new Vb(this);
  this.Sa = new Tb;
  this.Sa.setInterval(ac)
}
p = Q.prototype;
p.v = null;
p.J = !1;
p.ua = null;
p.sb = null;
p.pa = null;
p.sa = null;
p.T = null;
p.w = null;
p.X = null;
p.l = null;
p.Fa = 0;
p.K = null;
p.ta = null;
p.p = null;
p.h = -1;
p.Xb = !0;
p.aa = !1;
p.oa = 0;
p.Ta = null;
var $b = 45E3, ac = 250;
function bc(a, b) {
  switch(a) {
    case 0:
      return"Non-200 return code (" + b + ")";
    case 1:
      return"XMLHTTP failure (no data)";
    case 2:
      return"HttpConnection timeout";
    default:
      return"Unknown error"
  }
}
var cc = {}, dc = {};
function ec() {
  return!A || A && 10 <= Ma
}
p = Q.prototype;
p.Y = m("v");
p.setTimeout = m("Da");
p.$b = m("oa");
function fc(a, b, c) {
  a.sa = 1;
  a.T = J(b.n());
  a.X = c;
  a.xb = !0;
  gc(a, null)
}
function hc(a, b, c, d, f) {
  a.sa = 1;
  a.T = J(b.n());
  a.X = null;
  a.xb = c;
  f && (a.Xb = !1);
  gc(a, d)
}
function gc(a, b) {
  a.pa = x();
  ic(a);
  a.w = a.T.n();
  qb(a.w, "t", a.Ca);
  a.Fa = 0;
  a.l = a.b.hb(a.b.Ya() ? b : null);
  0 < a.oa && (a.Ta = new Yb(w(a.dc, a, a.l), a.oa));
  Xb(a.jb, a.l, "readystatechange", a.Ac);
  var c;
  if(a.v) {
    c = a.v;
    var d = {}, f;
    for(f in c) {
      d[f] = c[f]
    }
    c = d
  }else {
    c = {}
  }
  a.X ? (a.ta = "POST", c["Content-Type"] = "application/x-www-form-urlencoded", a.l.send(a.w, a.ta, a.X, c)) : (a.ta = "GET", a.Xb && !B && (c.Connection = "close"), a.l.send(a.w, a.ta, null, c));
  a.b.G(jc);
  if(d = a.X) {
    for(c = "", d = d.split("&"), f = 0;f < d.length;f++) {
      var g = d[f].split("=");
      if(1 < g.length) {
        var h = g[0], g = g[1], n = h.split("_");
        c = 2 <= n.length && "type" == n[1] ? c + (h + "=" + g + "&") : c + (h + "=redacted&")
      }
    }
  }else {
    c = null
  }
  a.a.info("XMLHTTP REQ (" + a.B + ") [attempt " + a.Ca + "]: " + a.ta + "\n" + a.w + "\n" + c)
}
p.Ac = function(a) {
  a = a.target;
  var b = this.Ta;
  b && 3 == R(a) ? (this.a.debug("Throttling readystatechange."), b.r || b.Tb ? b.Xa = !0 : Zb(b)) : this.dc(a)
};
p.dc = function(a) {
  try {
    if(a == this.l) {
      a: {
        var b = R(this.l), c = this.l.la, d = kc(this.l);
        if(!ec() || B && !C("420+")) {
          if(4 > b) {
            break a
          }
        }else {
          if(3 > b || 3 == b && !za && !lc(this.l)) {
            break a
          }
        }
        this.aa || (4 != b || c == mc) || (c == nc || 0 >= d ? this.b.G(oc) : this.b.G(pc));
        qc(this);
        var f = kc(this.l);
        this.h = f;
        var g = lc(this.l);
        g || this.a.debug("No response text for uri " + this.w + " status " + f);
        this.J = 200 == f;
        this.a.info("XMLHTTP RESP (" + this.B + ") [ attempt " + this.Ca + "]: " + this.ta + "\n" + this.w + "\n" + b + " " + f);
        this.J ? (4 == b && S(this), this.xb ? (rc(this, b, g), za && 3 == b && (Xb(this.jb, this.Sa, Ub, this.zc), this.Sa.start())) : (sc(this.a, this.B, g, null), tc(this, g)), this.J && !this.aa && (4 == b ? this.b.ma(this) : (this.J = !1, ic(this)))) : (400 == f && 0 < g.indexOf("Unknown SID") ? (this.p = 3, T(uc), this.a.$("XMLHTTP Unknown SID (" + this.B + ")")) : (this.p = 0, T(vc), this.a.$("XMLHTTP Bad status " + f + " (" + this.B + ")")), S(this), wc(this))
      }
    }else {
      this.a.$("Called back with an unexpected xmlhttp")
    }
  }catch(h) {
    this.a.debug("Failed call to OnXmlHttpReadyStateChanged_"), this.l && lc(this.l) ? xc(this.a, h, "ResponseText: " + lc(this.l)) : xc(this.a, h, "No response text")
  }finally {
  }
};
function rc(a, b, c) {
  for(var d = !0;!a.aa && a.Fa < c.length;) {
    var f = yc(a, c);
    if(f == dc) {
      4 == b && (a.p = 4, T(zc), d = !1);
      sc(a.a, a.B, null, "[Incomplete Response]");
      break
    }else {
      if(f == cc) {
        a.p = 4;
        T(Ac);
        sc(a.a, a.B, c, "[Invalid Chunk]");
        d = !1;
        break
      }else {
        sc(a.a, a.B, f, null), tc(a, f)
      }
    }
  }
  4 == b && 0 == c.length && (a.p = 1, T(Bc), d = !1);
  a.J = a.J && d;
  d || (sc(a.a, a.B, c, "[Invalid Chunked Response]"), S(a), wc(a))
}
p.zc = function() {
  var a = R(this.l), b = lc(this.l);
  this.Fa < b.length && (qc(this), rc(this, a, b), this.J && 4 != a && ic(this))
};
function yc(a, b) {
  var c = a.Fa, d = b.indexOf("\n", c);
  if(-1 == d) {
    return dc
  }
  c = Number(b.substring(c, d));
  if(isNaN(c)) {
    return cc
  }
  d += 1;
  if(d + c > b.length) {
    return dc
  }
  var f = b.substr(d, c);
  a.Fa = d + c;
  return f
}
function Cc(a, b) {
  a.pa = x();
  ic(a);
  var c = b ? window.location.hostname : "";
  a.w = a.T.n();
  I(a.w, "DOMAIN", c);
  I(a.w, "t", a.Ca);
  try {
    a.K = new ActiveXObject("htmlfile")
  }catch(d) {
    a.a.I("ActiveX blocked");
    S(a);
    a.p = 7;
    T(Dc);
    wc(a);
    return
  }
  var f = "<html><body>";
  b && (f += '<script>document.domain="' + c + '"\x3c/script>');
  f += "</body></html>";
  a.K.open();
  a.K.write(f);
  a.K.close();
  a.K.parentWindow.m = w(a.wc, a);
  a.K.parentWindow.d = w(a.Sb, a, !0);
  a.K.parentWindow.rpcClose = w(a.Sb, a, !1);
  c = a.K.createElement("div");
  a.K.parentWindow.document.body.appendChild(c);
  c.innerHTML = '<iframe src="' + a.w + '"></iframe>';
  a.a.info("TRIDENT REQ (" + a.B + ") [ attempt " + a.Ca + "]: GET\n" + a.w);
  a.b.G(jc)
}
p.wc = function(a) {
  U(w(this.vc, this, a), 0)
};
p.vc = function(a) {
  if(!this.aa) {
    var b = this.a;
    b.info("TRIDENT TEXT (" + this.B + "): " + Ec(b, a));
    qc(this);
    tc(this, a);
    ic(this)
  }
};
p.Sb = function(a) {
  U(w(this.uc, this, a), 0)
};
p.uc = function(a) {
  this.aa || (this.a.info("TRIDENT TEXT (" + this.B + "): " + a ? "success" : "failure"), S(this), this.J = a, this.b.ma(this), this.b.G(Fc))
};
p.lc = function() {
  qc(this);
  this.b.ma(this)
};
p.cancel = function() {
  this.aa = !0;
  S(this)
};
function ic(a) {
  a.sb = x() + a.Da;
  Gc(a, a.Da)
}
function Gc(a, b) {
  if(null != a.ua) {
    throw Error("WatchDog timer not null");
  }
  a.ua = U(w(a.xc, a), b)
}
function qc(a) {
  a.ua && (q.clearTimeout(a.ua), a.ua = null)
}
p.xc = function() {
  this.ua = null;
  var a = x();
  0 <= a - this.sb ? (this.J && this.a.I("Received watchdog timeout even though request loaded successfully"), this.a.info("TIMEOUT: " + this.w), 2 != this.sa && this.b.G(oc), S(this), this.p = 2, T(Hc), wc(this)) : (this.a.$("WatchDog timer called too early"), Gc(this, this.sb - a))
};
function wc(a) {
  a.b.Hb() || a.aa || a.b.ma(a)
}
function S(a) {
  qc(a);
  var b = a.Ta;
  b && "function" == typeof b.Ia && b.Ia();
  a.Ta = null;
  a.Sa.stop();
  b = a.jb;
  Ya(b.j, Nb);
  b.j.length = 0;
  a.l && (b = a.l, a.l = null, b.abort(), b.Ia());
  a.K && (a.K = null)
}
p.Eb = aa("p");
function tc(a, b) {
  try {
    a.b.Pb(a, b), a.b.G(Fc)
  }catch(c) {
    xc(a.a, c, "Error in httprequest callback")
  }
}
;function Ic(a) {
  a = String(a);
  if(/^\s*$/.test(a) ? 0 : /^[\],:{}\s\u2028\u2029]*$/.test(a.replace(/\\["\\\/bfnrtu]/g, "@").replace(/"[^"\\\n\r\u2028\u2029\x00-\x08\x0a-\x1f]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:[\s\u2028\u2029]*\[)+/g, ""))) {
    try {
      return eval("(" + a + ")")
    }catch(b) {
    }
  }
  throw Error("Invalid JSON string: " + a);
}
function Jc(a) {
  return eval("(" + a + ")")
}
function Kc(a) {
  var b = [];
  Lc(new Mc(void 0), a, b);
  return b.join("")
}
function Mc(a) {
  this.Va = a
}
function Lc(a, b, c) {
  switch(typeof b) {
    case "string":
      Nc(b, c);
      break;
    case "number":
      c.push(isFinite(b) && !isNaN(b) ? b : "null");
      break;
    case "boolean":
      c.push(b);
      break;
    case "undefined":
      c.push("null");
      break;
    case "object":
      if(null == b) {
        c.push("null");
        break
      }
      if(s(b)) {
        var d = b.length;
        c.push("[");
        for(var f = "", g = 0;g < d;g++) {
          c.push(f), f = b[g], Lc(a, a.Va ? a.Va.call(b, String(g), f) : f, c), f = ","
        }
        c.push("]");
        break
      }
      c.push("{");
      d = "";
      for(g in b) {
        Object.prototype.hasOwnProperty.call(b, g) && (f = b[g], "function" != typeof f && (c.push(d), Nc(g, c), c.push(":"), Lc(a, a.Va ? a.Va.call(b, g, f) : f, c), d = ","))
      }
      c.push("}");
      break;
    case "function":
      break;
    default:
      throw Error("Unknown type: " + typeof b);
  }
}
var Oc = {'"':'\\"', "\\":"\\\\", "/":"\\/", "\b":"\\b", "\f":"\\f", "\n":"\\n", "\r":"\\r", "\t":"\\t", "\x0B":"\\u000b"}, Pc = /\uffff/.test("\uffff") ? /[\\\"\x00-\x1f\x7f-\uffff]/g : /[\\\"\x00-\x1f\x7f-\xff]/g;
function Nc(a, b) {
  b.push('"', a.replace(Pc, function(a) {
    if(a in Oc) {
      return Oc[a]
    }
    var b = a.charCodeAt(0), f = "\\u";
    16 > b ? f += "000" : 256 > b ? f += "00" : 4096 > b && (f += "0");
    return Oc[a] = f + b.toString(16)
  }), '"')
}
;function Qc(a) {
  return Rc(a || arguments.callee.caller, [])
}
function Rc(a, b) {
  var c = [];
  if(0 <= Xa(b, a)) {
    c.push("[...circular reference...]")
  }else {
    if(a && 50 > b.length) {
      c.push(Sc(a) + "(");
      for(var d = a.arguments, f = 0;f < d.length;f++) {
        0 < f && c.push(", ");
        var g;
        g = d[f];
        switch(typeof g) {
          case "object":
            g = g ? "object" : "null";
            break;
          case "string":
            break;
          case "number":
            g = String(g);
            break;
          case "boolean":
            g = g ? "true" : "false";
            break;
          case "function":
            g = (g = Sc(g)) ? g : "[fn]";
            break;
          default:
            g = typeof g
        }
        40 < g.length && (g = g.substr(0, 40) + "...");
        c.push(g)
      }
      b.push(a);
      c.push(")\n");
      try {
        c.push(Rc(a.caller, b))
      }catch(h) {
        c.push("[exception trying to get caller]\n")
      }
    }else {
      a ? c.push("[...long stack...]") : c.push("[end]")
    }
  }
  return c.join("")
}
function Sc(a) {
  if(Tc[a]) {
    return Tc[a]
  }
  a = String(a);
  if(!Tc[a]) {
    var b = /function ([^\(]+)/.exec(a);
    Tc[a] = b ? b[1] : "[Anonymous]"
  }
  return Tc[a]
}
var Tc = {};
function Uc(a, b, c, d, f) {
  this.reset(a, b, c, d, f)
}
Uc.prototype.Cc = 0;
Uc.prototype.Bb = null;
Uc.prototype.Ab = null;
var Vc = 0;
Uc.prototype.reset = function(a, b, c, d, f) {
  this.Cc = "number" == typeof f ? f : Vc++;
  this.Qc = d || x();
  this.za = a;
  this.oc = b;
  this.Ic = c;
  delete this.Bb;
  delete this.Ab
};
Uc.prototype.Yb = m("za");
function V(a) {
  this.pc = a
}
V.prototype.Ra = null;
V.prototype.za = null;
V.prototype.fb = null;
V.prototype.Fb = null;
function Wc(a, b) {
  this.name = a;
  this.value = b
}
Wc.prototype.toString = aa("name");
var Xc = new Wc("SEVERE", 1E3), Yc = new Wc("WARNING", 900), Zc = new Wc("INFO", 800), $c = new Wc("CONFIG", 700), ad = new Wc("FINE", 500);
p = V.prototype;
p.getParent = aa("Ra");
p.Yb = m("za");
function bd(a) {
  if(a.za) {
    return a.za
  }
  if(a.Ra) {
    return bd(a.Ra)
  }
  Pa("Root logger has no level set.");
  return null
}
p.log = function(a, b, c) {
  if(a.value >= bd(this).value) {
    for(a = this.kc(a, b, c), b = "log:" + a.oc, q.console && (q.console.timeStamp ? q.console.timeStamp(b) : q.console.markTimeline && q.console.markTimeline(b)), q.msWriteProfilerMark && q.msWriteProfilerMark(b), b = this;b;) {
      c = b;
      var d = a;
      if(c.Fb) {
        for(var f = 0, g = void 0;g = c.Fb[f];f++) {
          g(d)
        }
      }
      b = b.getParent()
    }
  }
};
p.kc = function(a, b, c) {
  var d = new Uc(a, String(b), this.pc);
  if(c) {
    d.Bb = c;
    var f;
    var g = arguments.callee.caller;
    try {
      var h;
      var n = da("window.location.href");
      if(u(c)) {
        h = {message:c, name:"Unknown error", lineNumber:"Not available", fileName:n, stack:"Not available"}
      }else {
        var k, t, l = !1;
        try {
          k = c.lineNumber || c.Hc || "Not available"
        }catch(r) {
          k = "Not available", l = !0
        }
        try {
          t = c.fileName || c.filename || c.sourceURL || q.$googDebugFname || n
        }catch(G) {
          t = "Not available", l = !0
        }
        h = !l && c.lineNumber && c.fileName && c.stack ? c : {message:c.message, name:c.name, lineNumber:k, fileName:t, stack:c.stack || "Not available"}
      }
      f = "Message: " + na(h.message) + '\nUrl: <a href="view-source:' + h.fileName + '" target="_new">' + h.fileName + "</a>\nLine: " + h.lineNumber + "\n\nBrowser stack:\n" + na(h.stack + "-> ") + "[end]\n\nJS stack traversal:\n" + na(Qc(g) + "-> ")
    }catch(Sd) {
      f = "Exception trying to expose exception! You win, we lose. " + Sd
    }
    d.Ab = f
  }
  return d
};
p.I = function(a, b) {
  this.log(Xc, a, b)
};
p.$ = function(a, b) {
  this.log(Yc, a, b)
};
p.info = function(a, b) {
  this.log(Zc, a, b)
};
function W(a, b) {
  a.log(ad, b, void 0)
}
var cd = {}, dd = null;
function ed(a) {
  dd || (dd = new V(""), cd[""] = dd, dd.Yb($c));
  var b;
  if(!(b = cd[a])) {
    b = new V(a);
    var c = a.lastIndexOf("."), d = a.substr(c + 1), c = ed(a.substr(0, c));
    c.fb || (c.fb = {});
    c.fb[d] = b;
    b.Ra = c;
    cd[a] = b
  }
  return b
}
;function X() {
  this.q = ed("goog.net.BrowserChannel")
}
function sc(a, b, c, d) {
  a.info("XMLHTTP TEXT (" + b + "): " + Ec(a, c) + (d ? " " + d : ""))
}
X.prototype.debug = function(a) {
  this.info(a)
};
function xc(a, b, c) {
  a.I((c || "Exception") + b)
}
X.prototype.info = function(a) {
  this.q.info(a)
};
X.prototype.$ = function(a) {
  this.q.$(a)
};
X.prototype.I = function(a) {
  this.q.I(a)
};
function Ec(a, b) {
  if(!b || b == fd) {
    return b
  }
  try {
    var c = Jc(b);
    if(c) {
      for(var d = 0;d < c.length;d++) {
        if(s(c[d])) {
          var f = c[d];
          if(!(2 > f.length)) {
            var g = f[1];
            if(s(g) && !(1 > g.length)) {
              var h = g[0];
              if("noop" != h && "stop" != h) {
                for(var n = 1;n < g.length;n++) {
                  g[n] = ""
                }
              }
            }
          }
        }
      }
    }
    return Kc(c)
  }catch(k) {
    return a.debug("Exception parsing expected JS array - probably was not JS"), b
  }
}
;function gd(a, b) {
  this.Oc = new Mc(a);
  this.P = b ? Jc : Ic
}
gd.prototype.parse = function(a) {
  return this.P(a)
};
var mc = 7, nc = 8;
function hd(a) {
  M.call(this);
  this.headers = new bb;
  this.va = a || null
}
y(hd, Sb);
hd.prototype.q = ed("goog.net.XhrIo");
var id = /^https?$/i;
p = hd.prototype;
p.S = !1;
p.g = null;
p.bb = null;
p.Pa = "";
p.Jb = "";
p.la = 0;
p.p = "";
p.ib = !1;
p.Na = !1;
p.mb = !1;
p.ca = !1;
p.$a = 0;
p.fa = null;
p.Wb = "";
p.cc = !1;
p.send = function(a, b, c, d) {
  if(this.g) {
    throw Error("[goog.net.XhrIo] Object is active with another request=" + this.Pa + "; newUri=" + a);
  }
  b = b ? b.toUpperCase() : "GET";
  this.Pa = a;
  this.p = "";
  this.la = 0;
  this.Jb = b;
  this.ib = !1;
  this.S = !0;
  this.g = this.va ? xb(this.va) : xb(vb);
  this.bb = this.va ? this.va.Ga || (this.va.Ga = zb(this.va)) : vb.Ga || (vb.Ga = zb(vb));
  this.g.onreadystatechange = w(this.Ob, this);
  try {
    W(this.q, Y(this, "Opening Xhr")), this.mb = !0, this.g.open(b, a, !0), this.mb = !1
  }catch(f) {
    W(this.q, Y(this, "Error opening Xhr: " + f.message));
    jd(this, f);
    return
  }
  a = c || "";
  var g = this.headers.n();
  d && E(d, function(a, b) {
    g.set(b, a)
  });
  d = q.FormData && a instanceof q.FormData;
  "POST" != b || (g.ia("Content-Type") || d) || g.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
  E(g, function(a, b) {
    this.g.setRequestHeader(b, a)
  }, this);
  this.Wb && (this.g.responseType = this.Wb);
  "withCredentials" in this.g && (this.g.withCredentials = this.cc);
  try {
    this.fa && (q.clearTimeout(this.fa), this.fa = null), 0 < this.$a && (W(this.q, Y(this, "Will abort after " + this.$a + "ms if incomplete")), this.fa = q.setTimeout(w(this.Da, this), this.$a)), W(this.q, Y(this, "Sending request")), this.Na = !0, this.g.send(a), this.Na = !1
  }catch(h) {
    W(this.q, Y(this, "Send error: " + h.message)), jd(this, h)
  }
};
p.Da = function() {
  "undefined" != typeof ca && this.g && (this.p = "Timed out after " + this.$a + "ms, aborting", this.la = nc, W(this.q, Y(this, this.p)), this.dispatchEvent("timeout"), this.abort(nc))
};
function jd(a, b) {
  a.S = !1;
  a.g && (a.ca = !0, a.g.abort(), a.ca = !1);
  a.p = b;
  a.la = 5;
  kd(a);
  ld(a)
}
function kd(a) {
  a.ib || (a.ib = !0, a.dispatchEvent("complete"), a.dispatchEvent("error"))
}
p.abort = function(a) {
  this.g && this.S && (W(this.q, Y(this, "Aborting")), this.S = !1, this.ca = !0, this.g.abort(), this.ca = !1, this.la = a || mc, this.dispatchEvent("complete"), this.dispatchEvent("abort"), ld(this))
};
p.u = function() {
  this.g && (this.S && (this.S = !1, this.ca = !0, this.g.abort(), this.ca = !1), ld(this, !0));
  hd.ra.u.call(this)
};
p.Ob = function() {
  this.mb || this.Na || this.ca ? md(this) : this.sc()
};
p.sc = function() {
  md(this)
};
function md(a) {
  if(a.S && "undefined" != typeof ca) {
    if(a.bb[1] && 4 == R(a) && 2 == kc(a)) {
      W(a.q, Y(a, "Local request error detected and ignored"))
    }else {
      if(a.Na && 4 == R(a)) {
        q.setTimeout(w(a.Ob, a), 0)
      }else {
        if(a.dispatchEvent("readystatechange"), 4 == R(a)) {
          W(a.q, Y(a, "Request complete"));
          a.S = !1;
          try {
            var b = kc(a), c, d;
            a: {
              switch(b) {
                case 200:
                ;
                case 201:
                ;
                case 202:
                ;
                case 204:
                ;
                case 206:
                ;
                case 304:
                ;
                case 1223:
                  d = !0;
                  break a;
                default:
                  d = !1
              }
            }
            if(!(c = d)) {
              var f;
              if(f = 0 === b) {
                var g = String(a.Pa).match(Qa)[1] || null;
                if(!g && self.location) {
                  var h = self.location.protocol, g = h.substr(0, h.length - 1)
                }
                f = !id.test(g ? g.toLowerCase() : "")
              }
              c = f
            }
            if(c) {
              a.dispatchEvent("complete"), a.dispatchEvent("success")
            }else {
              a.la = 6;
              var n;
              try {
                n = 2 < R(a) ? a.g.statusText : ""
              }catch(k) {
                W(a.q, "Can not get status: " + k.message), n = ""
              }
              a.p = n + " [" + kc(a) + "]";
              kd(a)
            }
          }finally {
            ld(a)
          }
        }
      }
    }
  }
}
function ld(a, b) {
  if(a.g) {
    var c = a.g, d = a.bb[0] ? ea : null;
    a.g = null;
    a.bb = null;
    a.fa && (q.clearTimeout(a.fa), a.fa = null);
    b || a.dispatchEvent("ready");
    try {
      c.onreadystatechange = d
    }catch(f) {
      a.q.I("Problem encountered resetting onreadystatechange: " + f.message)
    }
  }
}
p.isActive = function() {
  return!!this.g
};
function R(a) {
  return a.g ? a.g.readyState : 0
}
function kc(a) {
  try {
    return 2 < R(a) ? a.g.status : -1
  }catch(b) {
    return a.q.$("Can not get status: " + b.message), -1
  }
}
function lc(a) {
  try {
    return a.g ? a.g.responseText : ""
  }catch(b) {
    return W(a.q, "Can not get responseText: " + b.message), ""
  }
}
p.Eb = function() {
  return u(this.p) ? this.p : String(this.p)
};
function Y(a, b) {
  return b + " [" + a.Jb + " " + a.Pa + " " + kc(a) + "]"
}
;function nd() {
  this.Vb = x()
}
new nd;
nd.prototype.set = m("Vb");
nd.prototype.reset = function() {
  this.set(x())
};
nd.prototype.get = aa("Vb");
function od(a, b, c, d, f) {
  (new X).debug("TestLoadImageWithRetries: " + f);
  if(0 == d) {
    c(!1)
  }else {
    var g = f || 0;
    d--;
    pd(a, b, function(f) {
      f ? c(!0) : q.setTimeout(function() {
        od(a, b, c, d, g)
      }, g)
    })
  }
}
function pd(a, b, c) {
  function d(a, b) {
    return function() {
      try {
        f.debug("TestLoadImage: " + b), g.onload = null, g.onerror = null, g.onabort = null, g.ontimeout = null, q.clearTimeout(h), c(a)
      }catch(d) {
        xc(f, d)
      }
    }
  }
  var f = new X;
  f.debug("TestLoadImage: loading " + a);
  var g = new Image, h = null;
  g.onload = d(!0, "loaded");
  g.onerror = d(!1, "error");
  g.onabort = d(!1, "abort");
  g.ontimeout = d(!1, "timeout");
  h = q.setTimeout(function() {
    if(g.ontimeout) {
      g.ontimeout()
    }
  }, b);
  g.src = a
}
;function qd(a, b) {
  this.b = a;
  this.a = b;
  this.P = new gd(null, !0)
}
p = qd.prototype;
p.v = null;
p.A = null;
p.Ua = !1;
p.ac = null;
p.Ka = null;
p.nb = null;
p.H = null;
p.c = null;
p.h = -1;
p.L = null;
p.wa = null;
p.Y = m("v");
p.Zb = m("P");
p.gb = function(a) {
  this.H = a;
  a = rd(this.b, this.H);
  T(sd);
  this.ac = x();
  var b = this.b.Cb;
  null != b ? (this.L = this.b.correctHostPrefix(b[0]), (this.wa = b[1]) ? (this.c = 1, td(this)) : (this.c = 2, ud(this))) : (qb(a, "MODE", "init"), this.A = new Q(this, this.a, void 0, void 0, void 0), this.A.Y(this.v), hc(this.A, a, !1, null, !0), this.c = 0)
};
function td(a) {
  var b = vd(a.b, a.wa, "/mail/images/cleardot.gif");
  J(b);
  od(b.toString(), 5E3, w(a.ic, a), 3, 2E3);
  a.G(jc)
}
p.ic = function(a) {
  if(a) {
    this.c = 2, ud(this)
  }else {
    T(wd);
    var b = this.b;
    b.a.debug("Test Connection Blocked");
    b.h = b.U.h;
    Z(b, 9)
  }
  a && this.G(pc)
};
function ud(a) {
  a.a.debug("TestConnection: starting stage 2");
  a.A = new Q(a, a.a, void 0, void 0, void 0);
  a.A.Y(a.v);
  var b = xd(a.b, a.L, a.H);
  T(yd);
  if(ec()) {
    qb(b, "TYPE", "xmlhttp"), hc(a.A, b, !1, a.L, !1)
  }else {
    qb(b, "TYPE", "html");
    var c = a.A;
    a = Boolean(a.L);
    c.sa = 3;
    c.T = J(b.n());
    Cc(c, a)
  }
}
p.hb = function(a) {
  return this.b.hb(a)
};
p.abort = function() {
  this.A && (this.A.cancel(), this.A = null);
  this.h = -1
};
p.Hb = ba(!1);
p.Pb = function(a, b) {
  this.h = a.h;
  if(0 == this.c) {
    if(this.a.debug("TestConnection: Got data for stage 1"), b) {
      try {
        var c = this.P.parse(b)
      }catch(d) {
        xc(this.a, d);
        zd(this.b, this);
        return
      }
      this.L = this.b.correctHostPrefix(c[0]);
      this.wa = c[1]
    }else {
      this.a.debug("TestConnection: Null responseText"), zd(this.b, this)
    }
  }else {
    if(2 == this.c) {
      if(this.Ua) {
        T(Ad), this.nb = x()
      }else {
        if("11111" == b) {
          if(T(Bd), this.Ua = !0, this.Ka = x(), c = this.Ka - this.ac, ec() || 500 > c) {
            this.h = 200, this.A.cancel(), this.a.debug("Test connection succeeded; using streaming connection"), T(Cd), Dd(this.b, this, !0)
          }
        }else {
          T(Ed), this.Ka = this.nb = x(), this.Ua = !1
        }
      }
    }
  }
};
p.ma = function() {
  this.h = this.A.h;
  if(!this.A.J) {
    this.a.debug("TestConnection: request failed, in state " + this.c), 0 == this.c ? T(Fd) : 2 == this.c && T(Gd), zd(this.b, this)
  }else {
    if(0 == this.c) {
      this.a.debug("TestConnection: request complete for initial check"), this.wa ? (this.c = 1, td(this)) : (this.c = 2, ud(this))
    }else {
      if(2 == this.c) {
        this.a.debug("TestConnection: request complete for stage 2");
        var a = !1;
        (a = ec() ? this.Ua : 200 > this.nb - this.Ka ? !1 : !0) ? (this.a.debug("Test connection succeeded; using streaming connection"), T(Cd), Dd(this.b, this, !0)) : (this.a.debug("Test connection failed; not using streaming"), T(Hd), Dd(this.b, this, !1))
      }
    }
  }
};
p.Ya = function() {
  return this.b.Ya()
};
p.isActive = function() {
  return this.b.isActive()
};
p.G = function(a) {
  this.b.G(a)
};
function Id(a, b) {
  this.vb = a || null;
  this.c = Jd;
  this.s = [];
  this.Q = [];
  this.a = new X;
  this.P = new gd(null, !0);
  this.Cb = b || null
}
function Kd(a, b) {
  this.Lb = a;
  this.map = b;
  this.Fc = null
}
p = Id.prototype;
p.v = null;
p.xa = null;
p.o = null;
p.k = null;
p.H = null;
p.La = null;
p.ub = null;
p.L = null;
p.fc = !0;
p.Aa = 0;
p.qc = 0;
p.Ja = !1;
p.e = null;
p.F = null;
p.M = null;
p.ba = null;
p.U = null;
p.rb = null;
p.ec = !0;
p.ya = -1;
p.Kb = -1;
p.h = -1;
p.V = 0;
p.ga = 0;
p.gc = 5E3;
p.Bc = 1E4;
p.kb = 2;
p.Db = 2E4;
p.oa = 0;
p.Za = !1;
p.ha = 8;
var Jd = 1, Ld = new Sb;
function Md(a, b) {
  N.call(this, "statevent", a);
  this.Pc = b
}
y(Md, N);
function Nd(a, b, c, d) {
  N.call(this, "timingevent", a);
  this.size = b;
  this.Nc = c;
  this.Mc = d
}
y(Nd, N);
var jc = 1, pc = 2, oc = 3, Fc = 4;
function Od(a, b) {
  N.call(this, "serverreachability", a);
  this.Lc = b
}
y(Od, N);
var sd = 3, wd = 4, yd = 5, Bd = 6, Ad = 7, Ed = 8, Fd = 9, Gd = 10, Hd = 11, Cd = 12, uc = 13, vc = 14, zc = 15, Ac = 16, Bc = 17, Hc = 18, Dc = 22, fd = "y2f%";
p = Id.prototype;
p.gb = function(a, b, c, d, f) {
  this.a.debug("connect()");
  T(0);
  this.H = b;
  this.xa = c || {};
  d && void 0 !== f && (this.xa.OSID = d, this.xa.OAID = f);
  this.a.debug("connectTest_()");
  Pd(this) && (this.U = new qd(this, this.a), this.U.Y(this.v), this.U.Zb(this.P), this.U.gb(a))
};
p.disconnect = function() {
  this.a.debug("disconnect()");
  Qd(this);
  if(3 == this.c) {
    var a = this.Aa++, b = this.La.n();
    I(b, "SID", this.Z);
    I(b, "RID", a);
    I(b, "TYPE", "terminate");
    Rd(this, b);
    a = new Q(this, this.a, this.Z, a, void 0);
    a.sa = 2;
    a.T = J(b.n());
    b = new Image;
    b.src = a.T;
    b.onload = b.onerror = w(a.lc, a);
    a.pa = x();
    ic(a)
  }
  Td(this)
};
function Qd(a) {
  a.U && (a.U.abort(), a.U = null);
  a.k && (a.k.cancel(), a.k = null);
  a.M && (q.clearTimeout(a.M), a.M = null);
  Ud(a);
  a.o && (a.o.cancel(), a.o = null);
  a.F && (q.clearTimeout(a.F), a.F = null)
}
p.Y = m("v");
p.$b = m("oa");
p.Hb = function() {
  return 0 == this.c
};
p.Zb = m("P");
function Vd(a) {
  a.o || a.F || (a.F = U(w(a.Rb, a), 0), a.V = 0)
}
p.Rb = function(a) {
  this.F = null;
  this.a.debug("startForwardChannel_");
  if(Pd(this)) {
    if(this.c == Jd) {
      if(a) {
        this.a.I("Not supposed to retry the open")
      }else {
        this.a.debug("open_()");
        this.Aa = Math.floor(1E5 * Math.random());
        a = this.Aa++;
        var b = new Q(this, this.a, "", a, void 0);
        b.Y(this.v);
        var c = Wd(this), d = this.La.n();
        I(d, "RID", a);
        this.vb && I(d, "CVER", this.vb);
        Rd(this, d);
        fc(b, d, c);
        this.o = b;
        this.c = 2
      }
    }else {
      3 == this.c && (a ? Xd(this, a) : 0 == this.s.length ? this.a.debug("startForwardChannel_ returned: nothing to send") : this.o ? this.a.I("startForwardChannel_ returned: connection already in progress") : (Xd(this), this.a.debug("startForwardChannel_ finished, sent request")))
    }
  }
};
function Xd(a, b) {
  var c, d;
  b ? 6 < a.ha ? (a.s = a.Q.concat(a.s), a.Q.length = 0, c = a.Aa - 1, d = Wd(a)) : (c = b.B, d = b.X) : (c = a.Aa++, d = Wd(a));
  var f = a.La.n();
  I(f, "SID", a.Z);
  I(f, "RID", c);
  I(f, "AID", a.ya);
  Rd(a, f);
  c = new Q(a, a.a, a.Z, c, a.V + 1);
  c.Y(a.v);
  c.setTimeout(Math.round(0.5 * a.Db) + Math.round(0.5 * a.Db * Math.random()));
  a.o = c;
  fc(c, f, d)
}
function Rd(a, b) {
  if(a.e) {
    var c = a.e.getAdditionalParams(a);
    c && E(c, function(a, c) {
      I(b, c, a)
    })
  }
}
function Wd(a) {
  var b = Math.min(a.s.length, 1E3), c = ["count=" + b], d;
  6 < a.ha && 0 < b ? (d = a.s[0].Lb, c.push("ofs=" + d)) : d = 0;
  for(var f = 0;f < b;f++) {
    var g = a.s[f].Lb, h = a.s[f].map, g = 6 >= a.ha ? f : g - d;
    try {
      E(h, function(a, b) {
        c.push("req" + g + "_" + b + "=" + encodeURIComponent(a))
      })
    }catch(n) {
      c.push("req" + g + "_type=" + encodeURIComponent("_badmap")), a.e && a.e.badMapError(a, h)
    }
  }
  a.Q = a.Q.concat(a.s.splice(0, b));
  return c.join("&")
}
function Yd(a) {
  a.k || a.M || (a.tb = 1, a.M = U(w(a.Qb, a), 0), a.ga = 0)
}
function Zd(a) {
  if(a.k || a.M) {
    return a.a.I("Request already in progress"), !1
  }
  if(3 <= a.ga) {
    return!1
  }
  a.a.debug("Going to retry GET");
  a.tb++;
  a.M = U(w(a.Qb, a), $d(a, a.ga));
  a.ga++;
  return!0
}
p.Qb = function() {
  this.M = null;
  if(Pd(this)) {
    this.a.debug("Creating new HttpRequest");
    this.k = new Q(this, this.a, this.Z, "rpc", this.tb);
    this.k.Y(this.v);
    this.k.$b(this.oa);
    var a = this.ub.n();
    I(a, "RID", "rpc");
    I(a, "SID", this.Z);
    I(a, "CI", this.rb ? "0" : "1");
    I(a, "AID", this.ya);
    Rd(this, a);
    if(ec()) {
      I(a, "TYPE", "xmlhttp"), hc(this.k, a, !0, this.L, !1)
    }else {
      I(a, "TYPE", "html");
      var b = this.k, c = Boolean(this.L);
      b.sa = 3;
      b.T = J(a.n());
      Cc(b, c)
    }
    this.a.debug("New Request created")
  }
};
function Pd(a) {
  if(a.e) {
    var b = a.e.okToMakeRequest(a);
    if(0 != b) {
      return a.a.debug("Handler returned error code from okToMakeRequest"), Z(a, b), !1
    }
  }
  return!0
}
function Dd(a, b, c) {
  a.a.debug("Test Connection Finished");
  a.rb = a.ec && c;
  a.h = b.h;
  a.a.debug("connectChannel_()");
  a.jc(Jd, 0);
  a.La = rd(a, a.H);
  Vd(a)
}
function zd(a, b) {
  a.a.debug("Test Connection Failed");
  a.h = b.h;
  Z(a, 2)
}
p.Pb = function(a, b) {
  if(0 != this.c && (this.k == a || this.o == a)) {
    if(this.h = a.h, this.o == a && 3 == this.c) {
      if(7 < this.ha) {
        var c;
        try {
          c = this.P.parse(b)
        }catch(d) {
          c = null
        }
        if(s(c) && 3 == c.length) {
          var f = c;
          if(0 == f[0]) {
            a: {
              if(this.a.debug("Server claims our backchannel is missing."), this.M) {
                this.a.debug("But we are currently starting the request.")
              }else {
                if(this.k) {
                  if(this.k.pa + 3E3 < this.o.pa) {
                    Ud(this), this.k.cancel(), this.k = null
                  }else {
                    break a
                  }
                }else {
                  this.a.$("We do not have a BackChannel established")
                }
                Zd(this);
                T(19)
              }
            }
          }else {
            this.Kb = f[1], c = this.Kb - this.ya, 0 < c && (f = f[2], this.a.debug(f + " bytes (in " + c + " arrays) are outstanding on the BackChannel"), 37500 > f && (this.rb && 0 == this.ga) && !this.ba && (this.ba = U(w(this.rc, this), 6E3)))
          }
        }else {
          this.a.debug("Bad POST response data returned"), Z(this, 11)
        }
      }else {
        b != fd && (this.a.debug("Bad data returned - missing/invald magic cookie"), Z(this, 11))
      }
    }else {
      if(this.k == a && Ud(this), !/^[\s\xa0]*$/.test(b)) {
        c = this.P.parse(b);
        for(var f = this.e && this.e.channelHandleMultipleArrays ? [] : null, g = 0;g < c.length;g++) {
          var h = c[g];
          this.ya = h[0];
          h = h[1];
          2 == this.c ? "c" == h[0] ? (this.Z = h[1], this.L = this.correctHostPrefix(h[2]), h = h[3], this.ha = null != h ? h : 6, this.c = 3, this.e && this.e.channelOpened(this), this.ub = xd(this, this.L, this.H), Yd(this)) : "stop" == h[0] && Z(this, 7) : 3 == this.c && ("stop" == h[0] ? (f && f.length && (this.e.channelHandleMultipleArrays(this, f), f.length = 0), Z(this, 7)) : "noop" != h[0] && (f ? f.push(h) : this.e && this.e.channelHandleArray(this, h)), this.ga = 0)
        }
        f && f.length && this.e.channelHandleMultipleArrays(this, f)
      }
    }
  }
};
p.correctHostPrefix = function(a) {
  return this.fc ? this.e ? this.e.correctHostPrefix(a) : a : null
};
p.rc = function() {
  null != this.ba && (this.ba = null, this.k.cancel(), this.k = null, Zd(this), T(20))
};
function Ud(a) {
  null != a.ba && (q.clearTimeout(a.ba), a.ba = null)
}
p.ma = function(a) {
  this.a.debug("Request complete");
  var b;
  if(this.k == a) {
    Ud(this), this.k = null, b = 2
  }else {
    if(this.o == a) {
      this.o = null, b = 1
    }else {
      return
    }
  }
  this.h = a.h;
  if(0 != this.c) {
    if(a.J) {
      1 == b ? (b = x() - a.pa, Ld.dispatchEvent(new Nd(Ld, a.X ? a.X.length : 0, b, this.V)), Vd(this), this.Q.length = 0) : Yd(this)
    }else {
      var c = a.Eb();
      if(3 == c || 7 == c || 0 == c && 0 < this.h) {
        this.a.debug("Not retrying due to error type")
      }else {
        this.a.debug("Maybe retrying, last error: " + bc(c, this.h));
        var d;
        if(d = 1 == b) {
          this.o || this.F ? (this.a.I("Request already in progress"), d = !1) : this.c == Jd || this.V >= (this.Ja ? 0 : this.kb) ? d = !1 : (this.a.debug("Going to retry POST"), this.F = U(w(this.Rb, this, a), $d(this, this.V)), this.V++, d = !0)
        }
        if(d || 2 == b && Zd(this)) {
          return
        }
        this.a.debug("Exceeded max number of retries")
      }
      this.a.debug("Error: HTTP request failed");
      switch(c) {
        case 1:
          Z(this, 5);
          break;
        case 4:
          Z(this, 10);
          break;
        case 3:
          Z(this, 6);
          break;
        case 7:
          Z(this, 12);
          break;
        default:
          Z(this, 2)
      }
    }
  }
};
function $d(a, b) {
  var c = a.gc + Math.floor(Math.random() * a.Bc);
  a.isActive() || (a.a.debug("Inactive channel"), c *= 2);
  return c * b
}
p.jc = function(a) {
  if(!(0 <= Xa(arguments, this.c))) {
    throw Error("Unexpected channel state: " + this.c);
  }
};
function Z(a, b) {
  a.a.info("Error code " + b);
  if(2 == b || 9 == b) {
    var c = null;
    a.e && (c = a.e.getNetworkTestImageUri(a));
    var d = w(a.Dc, a);
    c || (c = new F("http://www.google.com/images/cleardot.gif"), J(c));
    pd(c.toString(), 1E4, d)
  }else {
    T(2)
  }
  ae(a, b)
}
p.Dc = function(a) {
  a ? (this.a.info("Successfully pinged google.com"), T(2)) : (this.a.info("Failed to ping google.com"), T(1), ae(this, 8))
};
function ae(a, b) {
  a.a.debug("HttpChannel: error - " + b);
  a.c = 0;
  a.e && a.e.channelError(a, b);
  Td(a);
  Qd(a)
}
function Td(a) {
  a.c = 0;
  a.h = -1;
  if(a.e) {
    if(0 == a.Q.length && 0 == a.s.length) {
      a.e.channelClosed(a)
    }else {
      a.a.debug("Number of undelivered maps, pending: " + a.Q.length + ", outgoing: " + a.s.length);
      var b = $a(a.Q), c = $a(a.s);
      a.Q.length = 0;
      a.s.length = 0;
      a.e.channelClosed(a, b, c)
    }
  }
}
function rd(a, b) {
  var c = vd(a, null, b);
  a.a.debug("GetForwardChannelUri: " + c);
  return c
}
function xd(a, b, c) {
  b = vd(a, a.Ya() ? b : null, c);
  a.a.debug("GetBackChannelUri: " + b);
  return b
}
function vd(a, b, c) {
  var d = c instanceof F ? c.n() : new F(c, void 0);
  if("" != d.ja) {
    b && fb(d, b + "." + d.ja), gb(d, d.Ba)
  }else {
    var f = window.location, d = sb(f.protocol, b ? b + "." + f.hostname : f.hostname, f.port, c)
  }
  a.xa && E(a.xa, function(a, b) {
    I(d, b, a)
  });
  I(d, "VER", a.ha);
  Rd(a, d);
  return d
}
p.hb = function(a) {
  if(a && !this.Za) {
    throw Error("Can't create secondary domain capable XhrIo object.");
  }
  a = new hd;
  a.cc = this.Za;
  return a
};
p.isActive = function() {
  return!!this.e && this.e.isActive(this)
};
function U(a, b) {
  if(!ha(a)) {
    throw Error("Fn must not be null and must be a function");
  }
  return q.setTimeout(function() {
    a()
  }, b)
}
p.G = function(a) {
  Ld.dispatchEvent(new Od(Ld, a))
};
function T(a) {
  Ld.dispatchEvent(new Md(Ld, a))
}
p.Ya = function() {
  return this.Za || !ec()
};
function be() {
}
p = be.prototype;
p.channelHandleMultipleArrays = null;
p.okToMakeRequest = ba(0);
p.channelOpened = e();
p.channelHandleArray = e();
p.channelError = e();
p.channelClosed = e();
p.getAdditionalParams = function() {
  return{}
};
p.getNetworkTestImageUri = ba(null);
p.isActive = ba(!0);
p.badMapError = e();
p.correctHostPrefix = function(a) {
  return a
};
var $, ce, de = [].slice;
ce = {0:"Ok", 4:"User is logging out", 6:"Unknown session ID", 7:"Stopped by server", 8:"General network error", 2:"Request failed", 9:"Blocked by a network administrator", 5:"No data from server", 10:"Got bad data from the server", 11:"Got a bad response from the server"};
$ = function(a, b) {
  var c, d, f, g, h, n, k, t, l, r;
  t = this;
  a || (a = "channel");
  a.match(/:\/\//) && a.replace(/^ws/, "http");
  b || (b = {});
  s(b || "string" === typeof b) && (b = {});
  n = b.reconnectTime || 3E3;
  r = function(a) {
    t.readyState = t.readyState = a
  };
  r(this.CLOSED);
  l = null;
  g = b.Kc;
  c = function() {
    var a, b;
    b = arguments[0];
    a = 2 <= arguments.length ? de.call(arguments, 1) : [];
    try {
      return"function" === typeof t[b] ? t[b].apply(t, a) : void 0
    }catch(c) {
      throw a = c, "undefined" !== typeof console && null !== console && console.error(a.stack), a;
    }
  };
  d = new be;
  d.channelOpened = function() {
    g = l;
    r($.OPEN);
    return c("onopen")
  };
  f = null;
  d.channelError = function(a, b) {
    var d;
    d = ce[b];
    f = b;
    r($.cb);
    try {
      return c("onerror", d, b)
    }catch(g) {
    }
  };
  k = null;
  d.channelClosed = function(a, d, g) {
    if(t.readyState !== $.CLOSED) {
      l = null;
      a = f ? ce[f] : "Closed";
      r($.CLOSED);
      try {
        c("onclose", a, d, g)
      }catch(ee) {
      }
      b.reconnect && (7 !== f && 0 !== f) && (d = 6 === f ? 0 : n, clearTimeout(k), k = setTimeout(h, d));
      return f = null
    }
  };
  d.channelHandleArray = function(a, b) {
    return c("onmessage", b)
  };
  h = function() {
    if(l) {
      throw Error("Reconnect() called from invalid state");
    }
    r($.CONNECTING);
    c("onconnecting");
    clearTimeout(k);
    l = new Id(b.appVersion, null != g ? g.Cb : void 0);
    b.crossDomainXhr && (l.Za = !0);
    l.e = d;
    f = null;
    if(b.failFast) {
      var h = l;
      h.Ja = !0;
      h.a.info("setFailFast: true");
      (h.o || h.F) && h.V > (h.Ja ? 0 : h.kb) && (h.a.info("Retry count " + h.V + " > new maxRetries " + (h.Ja ? 0 : h.kb) + ". Fail immediately!"), h.o ? (h.o.cancel(), h.ma(h.o)) : (q.clearTimeout(h.F), h.F = null, Z(h, 2)))
    }
    return l.gb("" + a + "/test", "" + a + "/bind", b.extraParams, null != g ? g.Z : void 0, null != g ? g.ya : void 0)
  };
  this.open = function() {
    if(t.readyState !== t.CLOSED) {
      throw Error("Already open");
    }
    return h()
  };
  this.close = function() {
    clearTimeout(k);
    f = 0;
    if(t.readyState !== $.CLOSED) {
      return r($.cb), l.disconnect()
    }
  };
  this.sendMap = function(a) {
    var b;
    if((b = t.readyState) === $.cb || b === $.CLOSED) {
      throw Error("Cannot send to a closed connection");
    }
    b = l;
    if(0 == b.c) {
      throw Error("Invalid operation: sending map when state is closed");
    }
    1E3 == b.s.length && b.a.I("Already have 1000 queued maps upon queueing " + Kc(a));
    b.s.push(new Kd(b.qc++, a));
    2 != b.c && 3 != b.c || Vd(b)
  };
  this.send = function(a) {
    return this.sendMap({JSON:Kc(a)})
  };
  h();
  return this
};
$.prototype.CONNECTING = $.CONNECTING = $.CONNECTING = 0;
$.prototype.OPEN = $.OPEN = $.OPEN = 1;
$.prototype.CLOSING = $.CLOSING = $.cb = 2;
$.prototype.CLOSED = $.CLOSED = $.CLOSED = 3;
("undefined" !== typeof exports && null !== exports ? exports : window).BCSocket = $;

})();

},{}],13:[function(require,module,exports){
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]'
    };

var objectKeys = Object.keys || function objectKeys(object) {
    if (object !== Object(object)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in object) if (object.hasOwnProperty(key)) keys[keys.length] = key;
    return keys;
}


/*!
 * querystring
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Library version.
 */

exports.version = '0.3.1';

/**
 * Object#toString() ref for stringify().
 */

var toString = Object.prototype.toString;

/**
 * Cache non-integer test regexp.
 */

var notint = /[^0-9]/;

/**
 * Parse the given query `str`, returning an object.
 *
 * @param {String} str
 * @return {Object}
 * @api public
 */

exports.parse = function(str){
  if (null == str || '' == str) return {};

  function promote(parent, key) {
    if (parent[key].length == 0) return parent[key] = {};
    var t = {};
    for (var i in parent[key]) t[i] = parent[key][i];
    parent[key] = t;
    return t;
  }

  return String(str)
    .split('&')
    .reduce(function(ret, pair){
      try{ 
        pair = decodeURIComponent(pair.replace(/\+/g, ' '));
      } catch(e) {
        // ignore
      }

      var eql = pair.indexOf('=')
        , brace = lastBraceInKey(pair)
        , key = pair.substr(0, brace || eql)
        , val = pair.substr(brace || eql, pair.length)
        , val = val.substr(val.indexOf('=') + 1, val.length)
        , parent = ret;

      // ?foo
      if ('' == key) key = pair, val = '';

      // nested
      if (~key.indexOf(']')) {
        var parts = key.split('[')
          , len = parts.length
          , last = len - 1;

        function parse(parts, parent, key) {
          var part = parts.shift();

          // end
          if (!part) {
            if (isArray(parent[key])) {
              parent[key].push(val);
            } else if ('object' == typeof parent[key]) {
              parent[key] = val;
            } else if ('undefined' == typeof parent[key]) {
              parent[key] = val;
            } else {
              parent[key] = [parent[key], val];
            }
          // array
          } else {
            obj = parent[key] = parent[key] || [];
            if (']' == part) {
              if (isArray(obj)) {
                if ('' != val) obj.push(val);
              } else if ('object' == typeof obj) {
                obj[objectKeys(obj).length] = val;
              } else {
                obj = parent[key] = [parent[key], val];
              }
            // prop
            } else if (~part.indexOf(']')) {
              part = part.substr(0, part.length - 1);
              if(notint.test(part) && isArray(obj)) obj = promote(parent, key);
              parse(parts, obj, part);
            // key
            } else {
              if(notint.test(part) && isArray(obj)) obj = promote(parent, key);
              parse(parts, obj, part);
            }
          }
        }

        parse(parts, parent, 'base');
      // optimize
      } else {
        if (notint.test(key) && isArray(parent.base)) {
          var t = {};
          for(var k in parent.base) t[k] = parent.base[k];
          parent.base = t;
        }
        set(parent.base, key, val);
      }

      return ret;
    }, {base: {}}).base;
};

/**
 * Turn the given `obj` into a query string
 *
 * @param {Object} obj
 * @return {String}
 * @api public
 */

var stringify = exports.stringify = function(obj, prefix) {
  if (isArray(obj)) {
    return stringifyArray(obj, prefix);
  } else if ('[object Object]' == toString.call(obj)) {
    return stringifyObject(obj, prefix);
  } else if ('string' == typeof obj) {
    return stringifyString(obj, prefix);
  } else {
    return prefix;
  }
};

/**
 * Stringify the given `str`.
 *
 * @param {String} str
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyString(str, prefix) {
  if (!prefix) throw new TypeError('stringify expects an object');
  return prefix + '=' + encodeURIComponent(str);
}

/**
 * Stringify the given `arr`.
 *
 * @param {Array} arr
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyArray(arr, prefix) {
  var ret = [];
  if (!prefix) throw new TypeError('stringify expects an object');
  for (var i = 0; i < arr.length; i++) {
    ret.push(stringify(arr[i], prefix + '[]'));
  }
  return ret.join('&');
}

/**
 * Stringify the given `obj`.
 *
 * @param {Object} obj
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyObject(obj, prefix) {
  var ret = []
    , keys = objectKeys(obj)
    , key;
  for (var i = 0, len = keys.length; i < len; ++i) {
    key = keys[i];
    ret.push(stringify(obj[key], prefix
      ? prefix + '[' + encodeURIComponent(key) + ']'
      : encodeURIComponent(key)));
  }
  return ret.join('&');
}

/**
 * Set `obj`'s `key` to `val` respecting
 * the weird and wonderful syntax of a qs,
 * where "foo=bar&foo=baz" becomes an array.
 *
 * @param {Object} obj
 * @param {String} key
 * @param {String} val
 * @api private
 */

function set(obj, key, val) {
  var v = obj[key];
  if (undefined === v) {
    obj[key] = val;
  } else if (isArray(v)) {
    v.push(val);
  } else {
    obj[key] = [v, val];
  }
}

/**
 * Locate last brace in `str` within the key.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function lastBraceInKey(str) {
  var len = str.length
    , brace
    , c;
  for (var i = 0; i < len; ++i) {
    c = str[i];
    if (']' == c) brace = false;
    if ('[' == c) brace = true;
    if ('=' == c && !brace) return i;
  }
}

},{}],1:[function(require,module,exports){
(function(process,__dirname){var EventEmitter = require('events').EventEmitter;
var Model = require('./Model');
var util = require('./util');

module.exports = Racer;

function Racer() {
  EventEmitter.call(this);
}

util.mergeInto(Racer.prototype, EventEmitter.prototype);

// Make classes accessible for use by plugins and tests
Racer.prototype.Model = Model;
Racer.prototype.util = util;

// Support plugins on racer instances
Racer.prototype.use = util.use;

Racer.prototype.init = function(data) {
  var racer = this;

  process.env.NODE_ENV = data.nodeEnv;

  // Init is executed async so that plugins can extend Racer even if they are
  // included after the main entry point in the bundle
  process.nextTick(function() {
    var model = new Model;

    model._createConnection(data);

    racer.emit('model', model);

    // Re-create documents for all model data
    for (var collectionName in data.collections) {
      var collection = data.collections[collectionName];
      for (var id in collection) {
        var doc = model.getOrCreateDoc(collectionName, id, collection[id]);
        if (doc.shareDoc) {
          model._loadVersions[collectionName + '.' + id] = doc.shareDoc.version;
        }
      }
    }

    // TODO: Support re-init when there are contexts other than root
    var context = data.contexts.root;
    // Re-subscribe to document subscriptions
    for (var path in context.subscribedDocs) {
      var segments = path.split('.');
      model.subscribeDoc(segments[0], segments[1]);
      model._subscribedDocs[path] = context.subscribedDocs[path];
    }
    // Init fetchedDocs counts
    for (var path in context.fetchedDocs) {
      model._fetchedDocs[path] = context.fetchedDocs[path];
    }

    var silentModel = model.silent();
    // Re-create refs
    for (var i = 0; i < data.refs.length; i++) {
      var item = data.refs[i];
      silentModel.ref(item[0], item[1]);
    }
    // Re-create refLists
    for (var i = 0; i < data.refLists.length; i++) {
      var item = data.refLists[i];
      silentModel.refList(item[0], item[1], item[2], item[3]);
    }
    // Re-create fns
    for (var i = 0; i < data.fns.length; i++) {
      var item = data.fns[i];
      silentModel.start.apply(silentModel, item);
    }
    // Re-create filters
    for (var i = 0; i < data.filters.length; i++) {
      var item = data.filters[i];
      var filter = model._filters.add(item[0], item[1], item[2]);
      filter.ref(item[3]);
    }
    // Init and re-subscribe queries as appropriate
    model._initQueries(data.queries);

    racer._model = model;
    racer.emit('ready', model);
  });
  return this;
};

Racer.prototype.ready = function(cb) {
  if (this._model) {
    // Callback async in case the code depends on scripts included after in
    // the bundle and is gated by a ready
    process.nextTick(function() {
      cb(this._model);
    });
    return;
  }
  this.once('ready', cb);
};

util.serverRequire(__dirname + '/Racer.server.js');

})(require("__browserify_process"),"/node_modules/derby/node_modules/racer/lib")
},{"events":12,"./util":14,"./Model":15,"__browserify_process":11}],16:[function(require,module,exports){
var app = require('derby')
  .createApp(module)
  .use(require('../../ui'))
  .use(require('derby-ui-github-buttons'));

require('./controllerFns')(app);
require('./events')(app);
require('./user')(app);
require('./routes')(app);
require('./viewFns')(app);
},{"derby":"9UpRLI","./controllerFns":3,"./events":4,"./user":5,"./routes":6,"./viewFns":7,"../../ui":17,"derby-ui-github-buttons":18}],17:[function(require,module,exports){
(function(__filename){var config = {
  filename: __filename,
  scripts: {
    connectionAlert: require('./connectionAlert')
  }
};

module.exports = function (app, options) {
  app.createLibrary(config, options);
};
})("/ui/index.js")
},{"./connectionAlert":19}],19:[function(require,module,exports){
exports.setup = function(library) {
  library.view.fn('sentenceCase', function(text) {
    return text && (text.charAt(0).toUpperCase() + text.slice(1));
  });
};

exports.reconnect = function() {
  var model = this.model;
  model.set('hideReconnect', true);
  setTimeout(function() {
    model.set('hideReconnect', false);
  }, 1000);
  model.reconnect();
};

exports.reload = function() {
  window.location.reload();
};
},{}],2:[function(require,module,exports){
(function(global){var racer = require('racer')
  , tracks = require('tracks')
  , sharedCreateApp = require('./app').create
  , derbyModel = require('./derby.Model')
  , Dom = require('./Dom')
  , viewModel = require('./viewModel')
  , refresh = require('./refresh')

module.exports = derbyBrowser;

function derbyBrowser(derby) {
  // This assumes that only a single instance of this module can run at a time,
  // which is reasonable in the browser. This is written like this so that
  // the DERBY global can be used to initialize templates and data.
  global.DERBY = derby;
  derby.createApp = createApp;
  derby.init = init;
}

function createApp(appModule) {
  if (derbyBrowser.created) {
    throw new Error('derby.createApp() called multiple times in the browser');
  } else {
    derbyBrowser.created = true;
  }

  var app = sharedCreateApp(this, appModule)
  global.DERBY.app = app;

  racer.once('model', function(model) {
    app.emit('model', model);
  });

  // Adds get, post, put, del, enter, and exit methods
  // as well as history to app
  tracks.setup(app, createPage, onRoute);

  onRenderError = function(err, url) {
    setTimeout(function() {
      window.location = url;
    }, 0);
    throw err;
  }

  function Page(app) {
    this.app = app;
    this.model = app.model;
    this.dom = app.dom;
    this.history = app.history;
    this._viewModels = [];
    this._routing = false;
  }
  Page.prototype.render = function(ns, ctx) {
    try {
      if (typeof ns === 'object') {
        ctx = ns;
        ns = '';
      }
      ctx || (ctx = {});
      ctx.$url = this.params.url;
      app.view.render(this.model, ns, ctx);
      this._routing = false;
      tracks.render(this, {
        url: this.params.url
      , previous: this.params.previous
      , method: 'enter'
      , noNavigate: true
      });
    } catch (err) {
      onRenderError(err, this.params.url);
    }
  };
  Page.prototype.init = viewModel.pageInit;

  function createPage() {
    return new Page(app);
  }
  function onRoute(callback, page, params, next, isTransitional, done) {
    if (!app._initialized) return;
    try {
      if (isTransitional) {
        if (callback.length === 4) {
          callback(page.model, params, next, done);
          return true;
        } else {
          callback(page.model, params, next);
          return;
        }
      }

      if (params.method === 'enter' || params.method === 'exit') {
        callback.call(app, page.model, params);
        next();
        return;
      }

      if (!page._routing) {
        tracks.render(page, {
          url: page.params.previous
        , method: 'exit'
        , noNavigate: true
        });
        app.view._beforeRoute();
      }
      page._routing = true;
      callback(page, page.model, params, next);
    } catch (err) {
      onRenderError(err, page.params.url);
    }
  }

  app.ready = function(fn) {
    if (app._initialized) return fn.call(app.page, app.model);
    app.once('ready', function() {
      fn.call(app.page, app.model);
    });
  };
  return app;
}

function init(modelBundle, ctx) {
  var app = global.DERBY.app
    , ns = ctx.$ns
    , renderHash = ctx.$renderHash
    , derby = this

  // The ready event is fired after the model data is initialized
  racer.ready(function(model) {
    var dom = new Dom(model);

    app.model = model;
    app.dom = dom;

    // Calling history.page() creates the initial page, which is only
    // created one time on the client
    // TODO: This is a rather obtuse mechanism
    var page = app.history.page();
    app.page = page;
    page.model = model;
    page.dom = dom;

    // Reinitialize any viewModels which were already initialized
    // during rendering on the server
    if (ctx.$viewModels) {
      for (var i = 0; i < ctx.$viewModels.length; i++) {
        var item = ctx.$viewModels[i];
        var viewModel = app._viewModels[item[0]];
        item[1].unshift(page);
        viewModel.init.apply(viewModel, item[1]);
      }
    }

    derbyModel.init(derby, app);
    // Catch errors thrown when rendering and then throw from a setTimeout.
    // This way, the remaining init code can run and the app still connects
    try {
      // Render immediately upon initialization so that the page is in
      // EXACTLY the same state it was when rendered on the server
      app.view.render(model, ns, ctx, renderHash);
    } catch (err) {
      setTimeout(function() {
        throw err;
      }, 0);
    }
    app._initialized = true;

    app.emit('ready');

    tracks.render(app.history.page(), {
      url: (window.location.pathname.slice(window.location.pathname.indexOf('index.html') + 10) + '/') + window.location.search
    , method: 'enter'
    , noNavigate: true
    });

    // Delaying here to make sure that all ready callbacks are called before
    // the create functions run on various components
    setTimeout(function() {
      app.view._afterRender(ns, ctx);
    }, 0);

    if (ctx.$scriptPath) {
      model.channel.send('derby:app', ctx.$scriptPath);
      refresh.autoRefresh(app.view, model);
    }
  });
  racer.init(modelBundle);
}

})(window)
},{"racer":"CsQUzZ","./app":20,"./derby.Model":21,"./Dom":22,"./viewModel":23,"./refresh":24,"tracks":25}],20:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var racer = require('racer');
var component = require('./component');
var View = require('./View');
var viewModel = require('./viewModel');
var isServer = racer.util.isServer;
var paths = require('./paths');

exports.create = createApp;

function createApp(derby, appModule) {
  var app = racer.util.mergeInto(appModule.exports, EventEmitter.prototype)

  app.use = racer.util.use;
  component(app);
  app.filename = appModule.filename;
  app.view = new View(app._libraries, app, appModule.filename);
  app.fn = appFn;

  function appFn(value, fn) {
    if (typeof value === 'string') {
      // Don't bind the function on the server, since each
      // render gets passed a new model as part of the app
      paths.pathMerge(app, value, fn, bindPage);
    } else {
      paths.treeMerge(app, value, bindPage);
    }
    return app;
  }

  if (!isServer) {
    var bindPage = function(fn) {
      return function() {
        return fn.apply(app.page, arguments);
      };
    };
  }

  app._viewModels = {};
  app.viewModel = viewModel.construct.bind(app);

  return app;
}

},{"events":12,"racer":"CsQUzZ","./component":26,"./View":27,"./viewModel":23,"./paths":28}],21:[function(require,module,exports){
(function(){var EventDispatcher = require('./EventDispatcher')
var PathMap = require('./PathMap')
var Model = require('racer').Model
var valueBinding = require('./View').valueBinding
var arraySlice = [].slice;

exports.init = init;

// Add support for creating a model alias from a DOM node or jQuery object
Model.prototype.__at = Model.prototype.at;
Model.prototype.at = function(node) {
  var isNode = node && (node.parentNode || node.jquery && (node = node[0]));
  if (!isNode) return this.__at(node);

  updateMarkers();

  var blockPaths = this.root.__blockPaths
    , pathMap = this.root.__pathMap
    , child, i, id, last, path, blockPath, children, len;
  while (node) {
    if (node.$derbyMarkerParent && last) {
      node = last;
      while (node = node.previousSibling) {
        if (!(id = node.$derbyMarkerId)) continue;
        blockPath = blockPaths[id];
        if (node.$derbyMarkerEnd || !blockPath) break;

        path = pathMap.paths[blockPath.id];
        if ((blockPath.type === 'each') && last) {
          i = 0;
          while (node = node.nextSibling) {
            if (node === last) {
              path = path + '.' + i;
              break;
            }
            i++;
          }
        }
        return this.scope(path);
      }
      last = last.parentNode;
      node = last.parentNode;
      continue;
    }
    if ((id = node.id) && (blockPath = blockPaths[id])) {
      path = pathMap.paths[blockPath.id];
      if ((blockPath.type === 'each') && last) {
        children = node.childNodes;
        for (i = 0, len = children.length; i < len; i++) {
          child = children[i];
          if (child === last) {
            path = path + '.' + i;
            break;
          }
        }
      }
      return this.scope(path);
    }
    last = node;
    node = node.parentNode;
  }

  // Just return the root scope if a path can't be found
  return this.scope();
}

function updateMarkers() {
  // NodeFilter.SHOW_COMMENT == 128
  var commentIterator = document.createTreeWalker(document.body, 128, null, false)
    , comment, id;
  while (comment = commentIterator.nextNode()) {
    if (comment.$derbyChecked) continue;
    comment.$derbyChecked = true;
    id = comment.data;
    if (id.charAt(0) !== '$') continue;
    if (id.charAt(1) === '$') {
      comment.$derbyMarkerEnd = true;
      id = id.slice(1);
    }
    comment.$derbyMarkerId = id;
    comment.parentNode.$derbyMarkerParent = true;
  }
}

function init(derby, app) {
  var model = app.model;
  var dom = app.dom;
  var pathMap = model.__pathMap = new PathMap;
  var events = model.__events = new EventDispatcher({
    onTrigger: derbyModelTrigger
  , onCleanup: derbyModelEventsCleanup
  });

  function derbyModelEventsCleanup(pathId, listener) {
    var id = listener[0];
    return !dom.item(id);
  }

  function derbyModelTrigger(pathId, listener, type, pass, value, index, arg) {
    var id = listener[0]
      , el = dom.item(id);

    // Ignore if the element can't be found, and cleanup after some delay
    if (!el) return events.delayedCleanup(pathId);

    var method = listener[1]
      , property = listener[2]
      , partial = listener.partial
      , path = pathMap.paths[pathId]
      , triggerId;

    // Handle text OT events
    if (type === 'stringInsert' || type === 'stringRemove') {
      if (method !== 'propOt' || el === pass.$el) return;
      method = type;
    }
    // Ignore side-effect change events that were already handled
    if (method === 'propOt' && (pass.$original === 'stringInsert' || pass.$original === 'stringRemove')) return;

    if (partial) {
      triggerId = id;
      if (method === 'html' && type) {
        if (partial.type === 'each') {
          // Handle array updates
          method = type;
          if (type === 'insert') {
            triggerId = null;
          } else if (type === 'remove') {
            partial = null;
          } else if (type === 'move') {
            partial = null;
          }
        } else {
          value = model.get(path);
        }
      }
    }
    if (listener.getValue) {
      value = listener.getValue(model, path);
    }
    if (partial) {
      // TODO Get rid of model.__fnCtx cache
      // Was causing issues with not emitting "init:child" or "create:child"
      // when dynamically rendering a component inside a parent component
      // within an each block.
      delete model.__fnCtx;

      if (method === 'insert') {
        var values = value;
        value = '';
        for (var i = 0, len = values.length; i < len; i++) {
          value += partial(listener.ctx, model, triggerId, values[i], index + i, listener) || '<!--empty-->';
        }
      } else {
        value = partial(listener.ctx, model, triggerId, value, index, listener);
      }
    }
    value = valueBinding(value);
    dom.update(el, method, pass.ignore, value, property, index, arg);
    // HACK: Use of global
    DERBY.app.view._flushUncreated();
  }

  var types = Object.keys(Model.MUTATOR_EVENTS);
  types.push('all');
  types.forEach(function(type) {
    var beforeType = 'beforeBinding:' + type;
    model.on(type, function(segments, eventArgs) {
      model.emit(beforeType, segments, eventArgs);
    });
  });

  model.on('change', '**', function derbyOnChange(path, value, previous, pass) {
    // For set operations on array items, also emit a remove and insert in case the
    // array is bound
    if (/\.\d+$/.test(path)) {
      var i = path.lastIndexOf('.');
      var arrayPath = path.slice(0, i);
      var index = +path.slice(i + 1);
      triggerEach(arrayPath, 'remove', pass, index);
      triggerEach(arrayPath, 'insert', pass, [value], index);
    }
    triggerEach(path, 'html', pass, value);
  });

  model.on('load', '**', function derbyOnLoad(path, value, pass) {
    triggerEach(path, 'html', pass, value);
  });

  model.on('unload', '**', function derbyOnLoad(path, previous, pass) {
    triggerEach(path, 'html', pass, void 0);
  });

  model.on('insert', '**', function derbyOnInsert(path, index, values, pass) {
    pathMap.onInsert(path, index, values.length);
    triggerEach(path, 'insert', pass, values, index);
  });

  model.on('remove', '**', function derbyOnRemove(path, index, removed, pass) {
    var howMany = removed.length;
    var end = index + howMany;
    pathMap.onRemove(path, index, howMany);

    for (var i = index; i < end; i++) {
      var id = pathMap.ids[path];
      if (id) events.trigger(id, 'remove', pass, index);
    }
    triggerParents(path, pass);
  });

  model.on('move', '**', function derbyOnMove(path, from, to, howMany, pass) {
    pathMap.onMove(path, from, to, howMany);
    triggerEach(path, 'move', pass, from, to, howMany);
  });

  model.on('stringInsert', '**', function derbyOnStringInsert(path, index, inserted, pass) {
    var value = model.get(path);
    var id = pathMap.ids[path];
    events.trigger(id, 'stringInsert', pass, value, index, inserted);
  });

  model.on('stringRemove', '**', function derbyOnStringRemove(path, index, howMany, pass) {
    var value = model.get(path);
    var id = pathMap.ids[path];
    events.trigger(id, 'stringRemove', pass, value, index, howMany);
  });

  function triggerEach(path, type, pass, arg0, arg1, arg2) {
    // Trigger an event on the path if it has a pathMap ID
    var id = pathMap.ids[path];
    if (id) events.trigger(id, type, pass, arg0, arg1, arg2);
    // Trigger a pattern event for the path and each of its parent paths
    // This is used by view helper functions to match updates on a path
    // or any of its child segments
    triggerParents(path, pass);
  }

  function triggerParents(path, pass) {
    var segments = path.split('.');
    for (var i = 1, len = segments.length; i <= len; i++) {
      var pattern = segments.slice(0, i).join('.') + '*';
      var id = pathMap.ids[pattern];
      if (id) events.trigger(id, null, pass);
    }
  }

  return model;
}

})()
},{"racer":"CsQUzZ","./EventDispatcher":29,"./PathMap":30,"./View":27}],23:[function(require,module,exports){
var paths = require('./paths');

module.exports = {
  construct: construct
};

function ViewModel(name, proto) {
  this.name = name;
  this.proto = proto;
}
ViewModel.prototype.init = function(page) {
  var args = Array.prototype.slice.call(arguments, 1);
  // ViewModels are actually just scoped models for now
  var _super = page.model.at(this.name);
  var viewModel = _super._child();

  // Mixin viewModel specific methods
  viewModel._super = _super;
  viewModel.page = page;
  viewModel.model = page.model;
  for (key in this.proto) {
    if (key === 'init') continue;
    viewModel[key] = this.proto[key].bind(viewModel);
  }
  if (this.proto.init) {
    // Keep track of viewModels that were created so that
    // they can be recreated on the client if first rendered
    // on the server
    page._viewModels.push([this.name, args]);
    this.proto.init.apply(viewModel, args);
  }

  // Make viewModel available on the page for use in
  // event callbacks and other functions
  var segments = this.name.split('.');
  var last = segments.pop();
  var node = paths.traverseNode(page, segments);
  node[last] = viewModel;

  return viewModel;
}

function construct(name, proto) {
  // Keep a map of defined viewModels so that they can
  // be reinitialized from their name on the client
  var viewModel = this._viewModels[name] = new ViewModel(name, proto);
  return viewModel;
}

},{"./paths":28}],15:[function(require,module,exports){
(function(__dirname){module.exports = require('./Model');
var util = require('../util');

// Extend model on both server and client //
require('./events');
require('./paths');
require('./collections');
require('./mutators');
require('./setDiff');

require('./connection');
require('./subscriptions');
require('./Query');
require('./contexts');

require('./fn');
require('./filter');
require('./refList');
require('./ref');

// Extend model for server //
util.serverRequire(__dirname + '/bundle');
util.serverRequire(__dirname + '/connection.server');

})("/node_modules/derby/node_modules/racer/lib/Model")
},{"./Model":31,"../util":14,"./events":32,"./paths":33,"./collections":34,"./mutators":35,"./setDiff":36,"./connection":37,"./subscriptions":38,"./Query":39,"./contexts":40,"./fn":41,"./filter":42,"./refList":43,"./ref":44}],28:[function(require,module,exports){
module.exports = {
  traverseNode: traverseNode
, pathMerge: pathMerge
, treeMerge: treeMerge
};

function traverseNode(node, segments) {
  var i, len, segment
  for (i = 0, len = segments.length; i < len; i++) {
    segment = segments[i];
    node = node[segment] || (node[segment] = {});
  }
  return node;
}

// Recursively set nested objects based on a path
function pathMerge(node, path, value, nodeFn) {
  var segments = path.split('.')
    , last, i, len, segment
  if (typeof value === 'object') {
    node = traverseNode(node, segments);
    treeMerge(node, value, nodeFn);
    return;
  }
  last = segments.pop();
  node = traverseNode(node, segments);
  node[last] = (nodeFn) ? nodeFn(value) : value;
}

// Recursively set objects such that the non-objects are
// merged with the corresponding structure of the base node
function treeMerge(node, tree, nodeFn) {
  var key, child, value
  for (key in tree) {
    value = tree[key];
    if (typeof value === 'object') {
      child = node[key] || (node[key] = {});
      treeMerge(child, value, nodeFn);
      continue;
    }
    node[key] = (nodeFn) ? nodeFn(value) : value;
  }
}

},{}],29:[function(require,module,exports){
function empty() {}
function EventDispatcherNames() {}
function EventDispatcherListeners() {}
function CleanupPendingMap() {}

module.exports = EventDispatcher;

function EventDispatcher(options) {
  this._onTrigger = options && options.onTrigger || empty;
  this._onBind = options && options.onBind || empty;
  this._onCleanup = options && options.onCleanup;
  this._cleanupPending = new CleanupPendingMap();
  this.clear();
}

EventDispatcher.prototype.clear = function() {
  this.names = new EventDispatcherNames();
};

EventDispatcher.prototype.bind = function(name, listener, arg0) {
  this._onBind(name, listener, arg0);
  var obj = this.names[name] || (this.names[name] = new EventDispatcherListeners());
  obj[JSON.stringify(listener)] = listener;
  return obj;
};

EventDispatcher.prototype.trigger = function(name, value, arg0, arg1, arg2, arg3, arg4, arg5) {
  if (!name) return;
  var listeners = this.names[name];
  var onTrigger = this._onTrigger;
  var count = 0;
  var key, listener;
  for (key in listeners) {
    listener = listeners[key];
    count++;
    if (false !== onTrigger(name, listener, value, arg0, arg1, arg2, arg3, arg4, arg5)) {
      continue;
    }
    delete listeners[key];
    count--;
  }
  if (!count) delete this.names[name];
  return count;
};

EventDispatcher.prototype.delayedCleanup = function(name) {
  if (this._cleanupPending[name]) return;
  this._cleanupPending[name] = true;
  var eventDispatcher = this;
  setTimeout(function() {
    delete eventDispatcher._cleanupPending[name];
    eventDispatcher.cleanup(name);
  }, 0);
};

EventDispatcher.prototype.cleanup = function(name) {
  var listeners = this.names[name];
  var hasKeys = false;
  var key, remove;
  for (key in listeners) {
    remove = this._onCleanup(name, listeners[key]);
    if (remove) {
      delete listeners[key];
    } else {
      hasKeys = true;
    }
  }
  if (!hasKeys) delete this.names[name];
};

},{}],30:[function(require,module,exports){
module.exports = PathMap;

function PathMap() {
  this.clear();
  this.count = 0;
}

PathMap.prototype.clear = function() {
  this.ids = {};
  this.paths = {};
  this.arrays = {};
};

PathMap.prototype.id = function(path) {
  // Return the path for an id, or create a new id and index it
  var id = this.ids[path];
  if (id) return id;
  id = (++this.count).toString();
  this.paths[id] = path;
  this._indexArray(path, id);
  this.ids[path] = id;
  return id;
};

PathMap.prototype._indexArray = function(path, id) {
  var arr, index, match, nested, remainder, set, setArrays;
  while (match = /^(.+)\.(\d+)(\*?(?:\..+|$))/.exec(path)) {
    path = match[1];
    index = +match[2];
    remainder = match[3];
    arr = this.arrays[path] || (this.arrays[path] = []);
    set = arr[index] || (arr[index] = {});
    if (nested) {
      setArrays = set.arrays || (set.arrays = {});
      setArrays[remainder] = true;
    } else {
      set[id] = remainder;
    }
    nested = true;
  }
};

PathMap.prototype._incrItems = function(path, map, start, end, byNum, oldArrays, oldPath) {
  var arrayMap, arrayPath, arrayPathTo, i, id, ids, itemPath, remainder;
  if (oldArrays == null) oldArrays = {};

  for (i = start; i < end; i++) {
    ids = map[i];
    if (!ids) continue;

    for (id in ids) {
      remainder = ids[id];
      if (id === 'arrays') {
        for (remainder in ids[id]) {
          arrayPath = (oldPath || path) + '.' + i + remainder;
          arrayMap = oldArrays[arrayPath] || this.arrays[arrayPath];
          if (arrayMap) {
            arrayPathTo = path + '.' + (i + byNum) + remainder;
            this.arrays[arrayPathTo] = arrayMap;
            this._incrItems(arrayPathTo, arrayMap, 0, arrayMap.length, 0, oldArrays, arrayPath);
          }
        }
        continue;
      }

      itemPath = path + '.' + (i + byNum) + remainder;
      this.paths[id] = itemPath;
      this.ids[itemPath] = +id;
    }
  }
};

PathMap.prototype._delItems = function(path, map, start, end, len, oldArrays) {
  var arrayLen, arrayMap, arrayPath, i, id, ids, itemPath, remainder;
  if (oldArrays == null) oldArrays = {};

  for (i = start; i < len; i++) {
    ids = map[i];
    if (!ids) continue;

    for (id in ids) {
      if (id === 'arrays') {
        for (remainder in ids[id]) {
          arrayPath = path + '.' + i + remainder;
          if (arrayMap = this.arrays[arrayPath]) {
            arrayLen = arrayMap.length;
            this._delItems(arrayPath, arrayMap, 0, arrayLen, arrayLen, oldArrays);
            oldArrays[arrayPath] = arrayMap;
            delete this.arrays[arrayPath];
          }
        }
        continue;
      }

      itemPath = this.paths[id];
      delete this.ids[itemPath];
      if (i > end) continue;
      delete this.paths[id];
    }
  }

  return oldArrays;
};

PathMap.prototype.onRemove = function(path, start, howMany) {
  var map = this.arrays[path]
    , end, len, oldArrays;
  if (!map) return;
  end = start + howMany;
  len = map.length;
  // Delete indicies for removed items
  oldArrays = this._delItems(path, map, start, end + 1, len);
  // Decrement indicies of later items
  this._incrItems(path, map, end, len, -howMany, oldArrays);
  map.splice(start, howMany);
};

PathMap.prototype.onInsert = function(path, start, howMany) {
  var map = this.arrays[path]
    , end, len, oldArrays;
  if (!map) return;
  end = start + howMany;
  len = map.length;
  // Delete indicies for items in inserted positions
  oldArrays = this._delItems(path, map, start, end + 1, len);
  // Increment indicies of later items
  this._incrItems(path, map, start, len, howMany, oldArrays);
  while (howMany--) {
    map.splice(start, 0, {});
  }
};

PathMap.prototype.onMove = function(path, from, to, howMany) {
  var map = this.arrays[path]
    , afterFrom, afterTo, items, oldArrays;
  if (!map) return;
  afterFrom = from + howMany;
  afterTo = to + howMany;
  // Adjust paths for items between from and to
  if (from > to) {
    oldArrays = this._delItems(path, map, to, afterFrom, afterFrom);
    this._incrItems(path, map, to, from, howMany, oldArrays);
  } else {
    oldArrays = this._delItems(path, map, from, afterTo, afterTo);
    this._incrItems(path, map, afterFrom, afterTo, -howMany, oldArrays);
  }
  // Adjust paths for the moved item(s)
  this._incrItems(path, map, from, afterFrom, to - from, oldArrays);
  // Fix the array index
  items = map.splice(from, howMany);
  map.splice.apply(map, [to, 0].concat(items));
};

},{}],45:[function(require,module,exports){
module.exports = {
  onStringInsert: onStringInsert
, onStringRemove: onStringRemove
, onTextInput: onTextInput
};

function onStringInsert(el, previous, index, text) {
  function transformCursor(cursor) {
    return (index < cursor) ? cursor + text.length : cursor;
  }
  var newText = previous.slice(0, index) + text + previous.slice(index);
  replaceText(el, newText, transformCursor);
}

function onStringRemove(el, previous, index, howMany) {
  function transformCursor(cursor) {
    return (index < cursor) ? cursor - Math.min(howMany, cursor - index) : cursor;
  }
  var newText = previous.slice(0, index) + previous.slice(index + howMany);
  replaceText(el, newText, transformCursor);
}

function replaceText(el, newText, transformCursor) {
  var selectionStart = transformCursor(el.selectionStart);
  var selectionEnd = transformCursor(el.selectionEnd);

  var scrollTop = el.scrollTop;
  el.value = newText;
  if (el.scrollTop !== scrollTop) {
    el.scrollTop = scrollTop;
  }
  if (document.activeElement === el) {
    el.selectionStart = selectionStart;
    el.selectionEnd = selectionEnd;
  }
}

function onTextInput(model, path, value) {
  var previous = model.get(path) || '';
  if (previous === value) return;
  var start = 0;
  while (previous.charAt(start) == value.charAt(start)) {
    start++;
  }
  var end = 0;
  while (
    previous.charAt(previous.length - 1 - end) === value.charAt(value.length - 1 - end) &&
    end + start < previous.length &&
    end + start < value.length
  ) {
    end++;
  }

  if (previous.length !== start + end) {
    var howMany = previous.length - start - end;
    model.stringRemove(path, start, howMany);
  }
  if (value.length !== start + end) {
    var inserted = value.slice(start, value.length - end);
    model.stringInsert(path, start, inserted);
  }
}

},{}],18:[function(require,module,exports){
(function(__filename){var config = {
  filename: __filename,
  ns: 'ghbtns',
  scripts: {
    button: require('./button')
  }
};

module.exports = function(app, options) {
  app.createLibrary(config, options);
}
})("/node_modules/derby-ui-github-buttons/index.js")
},{"./button":46}],47:[function(require,module,exports){
(function(process){function filter (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (fn(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length; i >= 0; i--) {
    var last = parts[i];
    if (last == '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Regex to split a filename into [*, dir, basename, ext]
// posix version
var splitPathRe = /^(.+\/(?!$)|\/)?((?:.+?)?(\.[^.]*)?)$/;

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
var resolvedPath = '',
    resolvedAbsolute = false;

for (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {
  var path = (i >= 0)
      ? arguments[i]
      : process.cwd();

  // Skip empty and invalid entries
  if (typeof path !== 'string' || !path) {
    continue;
  }

  resolvedPath = path + '/' + resolvedPath;
  resolvedAbsolute = path.charAt(0) === '/';
}

// At this point the path should be resolved to a full absolute path, but
// handle relative paths to be safe (might happen when process.cwd() fails)

// Normalize the path
resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
var isAbsolute = path.charAt(0) === '/',
    trailingSlash = path.slice(-1) === '/';

// Normalize the path
path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }
  
  return (isAbsolute ? '/' : '') + path;
};


// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    return p && typeof p === 'string';
  }).join('/'));
};


exports.dirname = function(path) {
  var dir = splitPathRe.exec(path)[1] || '';
  var isWindows = false;
  if (!dir) {
    // No dirname
    return '.';
  } else if (dir.length === 1 ||
      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {
    // It is just a slash or a drive letter with a slash
    return dir;
  } else {
    // It is a full dirname, strip trailing slash
    return dir.substring(0, dir.length - 1);
  }
};


exports.basename = function(path, ext) {
  var f = splitPathRe.exec(path)[2] || '';
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPathRe.exec(path)[3] || '';
};

exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

})(require("__browserify_process"))
},{"__browserify_process":11}],14:[function(require,module,exports){
(function(process){var deepIs = require('deep-is');

var isServer = process.title !== 'browser';
var isProduction = process.env.NODE_ENV === 'production';

module.exports = {
  isServer: isServer
, isProduction: isProduction

, asyncGroup: asyncGroup
, contains: contains
, copyObject: copyObject
, deepCopy: deepCopy
, deepEqual: deepIs
, equal: equal
, equalsNaN: equalsNaN
, lookup: lookup
, mergeInto: mergeInto
, mayImpact: mayImpact
, mayImpactAny: mayImpactAny
, serverRequire: serverRequire
, use: use
};

function asyncGroup(cb) {
  var group = new AsyncGroup(cb);
  return function asyncGroupAdd() {
    return group.add();
  };
}

/**
 * @constructor
 * @param {Function} cb(err)
 */
function AsyncGroup(cb) {
  this.cb = cb;
  this.isDone = false;
  this.count = 0;
}
AsyncGroup.prototype.add = function() {
  this.count++;
  var self = this;
  return function(err) {
    self.count--;
    if (self.isDone) return;
    if (err) {
      self.isDone = true;
      self.cb(err);
      return;
    }
    if (self.count > 0) return;
    self.isDone = true;
    self.cb();
  };
};

function contains(segments, testSegments) {
  for (var i = 0; i < segments.length; i++) {
    if (segments[i] !== testSegments[i]) return false;
  }
  return true;
}

function copyObject(object) {
  var out = new object.constructor;
  for (var key in object) {
    if (object.hasOwnProperty(key)) {
      out[key] = object[key];
    }
  }
  return out;
}

function deepCopy(value) {
  if (value instanceof Date) return new Date(value);
  if (typeof value === 'object') {
    if (value === null) return null;
    var copy;
    if (Array.isArray(value)) {
      copy = [];
      for (var i = value.length; i--;) {
        copy[i] = deepCopy(value[i]);
      }
      return copy;
    }
    copy = new value.constructor;
    for (var key in value) {
      if (value.hasOwnProperty(key)) {
        copy[key] = deepCopy(value[key]);
      }
    }
    return copy;
  }
  return value;
}

function equal(a, b) {
  return (a === b) || (equalsNaN(a) && equalsNaN(b));
}

function equalsNaN(x) {
  return x !== x;
}

function lookup(segments, value) {
  if (!segments) return value;

  for (var i = 0, len = segments.length; i < len; i++) {
    if (value == null) return value;
    value = value[segments[i]];
  }
  return value;
}

function mayImpactAny(segmentsList, testSegments) {
  for (var i = 0, len = segmentsList.length; i < len; i++) {
    if (mayImpact(segmentsList[i], testSegments)) return true;
  }
  return false;
}

function mayImpact(segments, testSegments) {
  var len = Math.min(segments.length, testSegments.length);
  for (var i = 0; i < len; i++) {
    if (segments[i] !== testSegments[i]) return false;
  }
  return true;
}

function mergeInto(to, from) {
  for (var key in from) {
    to[key] = from[key];
  }
  return to;
}

function serverRequire(name) {
  if (!isServer) return;
  // Tricks Browserify into not logging a warning
  var _require = require;
  return _require(name);
}

function use(plugin, options) {
  // Server-side plugins may be included via filename
  if (typeof plugin === 'string') {
    if (!isServer) return this;
    plugin = serverRequire(plugin);
  }

  // Don't include a plugin more than once
  var plugins = this._plugins || (this._plugins = []);
  if (plugins.indexOf(plugin) === -1) {
    plugins.push(plugin);
    plugin(this, options);
  }
  return this;
}

})(require("__browserify_process"))
},{"deep-is":48,"__browserify_process":11}],25:[function(require,module,exports){
var Route = require('../vendor/express/router/route')
var History = require('./History')
var router = module.exports = require('./router')
var compose = require('./compose')

router.setup = setup

function setup(app, createPage, onRoute) {
  var routes = {
    queue: {}
  , transitional: {}
  , onRoute: onRoute
  }
  app.history = new History(createPage, routes)

  ;['get', 'post', 'put', 'del', 'enter', 'exit'].forEach(function(method) {
    var queue = routes.queue[method] = []
    var transitional = routes.transitional[method] = []
    var transitionalCalls = []

    app[method] = function(pattern, callback) {
      if (Array.isArray(pattern)) {
        pattern.forEach(function(item) {
          app[method](item, callback)
        })
        return app
      }

      if (router.isTransitional(pattern)) {
        var from = pattern.from
        var to = pattern.to
        var forward = pattern.forward || (callback && callback.forward) || callback
        var back = pattern.back || (callback && callback.back)
        transitionalCalls.push({
          from: from
        , to: to
        , forward: forward
        , back: back
        })

        var fromRoute = new Route(method, from, back)
        var toRoute = new Route(method, to, forward)
        fromRoute.isTransitional = true
        toRoute.isTransitional = true
        transitional.push({
          from: fromRoute
        , to: toRoute
        })
        if (back) transitional.push({
          from: toRoute
        , to: fromRoute
        })

        compose.transition(app[method], transitionalCalls, from, to, forward, back)
        return app
      }

      queue.push(new Route(method, pattern, callback))
      return app
    }
  })
}

},{"../vendor/express/router/route":49,"./History":50,"./router":51,"./compose":52}],26:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter
  , path = require('path')
  , util = require('racer').util
  , View = require('./View')
  , arraySlice = Array.prototype.slice

module.exports = componentPlugin;

function componentPlugin(app) {
  app._libraries = [];
  app._libraries.map = {};
  app.createLibrary = createLibrary;
}

function ComponentProto() {}
util.mergeInto(ComponentProto.prototype, EventEmitter.prototype);

ComponentProto.prototype.emitCancellable = function() {
  var cancelled = false
    , args = arraySlice.call(arguments)

  function cancel() {
    cancelled = true;
  }

  args.push(cancel);
  this.emit.apply(this, args);
  return cancelled;
};

ComponentProto.prototype.emitDelayable = function() {
  var delayed = false
    , args = arraySlice.call(arguments, 0, -1)
    , callback = arguments[arguments.length - 1]

  function delay() {
    delayed = true;
  }

  args.push(delay, callback);
  this.emit.apply(this, args);
  if (!delayed) callback();
  return delayed;
};

function createLibrary(config, options) {
  if (!config || !config.filename) {
    throw new Error ('Configuration argument with a filename is required');
  }
  if (!options) options = {};
  var root = path.dirname(config.filename);
  var ns = options.ns || config.ns || path.basename(root);
  var scripts = config.scripts || {};
  var view = new View;
  var constructors = {};
  var library = {
    ns: ns
  , root: root
  , view: view
  , constructors: constructors
  , styles: config.styles
  };

  view.parent = this;
  view._selfNs = 'lib';
  view._selfLibrary = library;

  for (var name in scripts) {
    var script = scripts[name];
    script.setup && script.setup(library);

    var Component = function(model, scope) {
      this.view = view;
      this.model = model;
      this.scope = scope;
      this.history = null;
      this.dom = null;

      // Don't limit the number of listeners
      this.setMaxListeners(0);

      var component = this;
      model.__on = model._on;
      model._on = function(name, listener) {
        component.on('destroy', function() {
          model.removeListener(name, listener);
        })
        return model.__on(name, listener);
      };
      component.on('destroy', function() {
        model.silent().del();
      });
    }
    var proto = Component.prototype = new ComponentProto();
    util.mergeInto(proto, script);

    Component.view = view;
    Component.ns = Component.prototype.ns = ns;
    Component.name = Component.prototype.name = name;

    // Note that component names are all lowercased
    constructors[name.toLowerCase()] = Component;
  }

  var replaced = false;
  for (var i = this._libraries.length; i--;) {
    if (this._libraries[i].ns === ns) {
      this._libraries[i] = library;
      replaced = true;
    }
  }
  if (!replaced) {
    this._libraries.push(library);
  }
  this._libraries.map[ns] = library;
  return library;
}

},{"events":12,"path":47,"racer":"CsQUzZ","./View":27}],22:[function(require,module,exports){
var racer = require('racer')
  , domShim = require('dom-shim')
  , EventDispatcher = require('./EventDispatcher')
  , viewPath = require('./viewPath')
  , escapeHtml = require('html-util').escapeHtml
  , textOt = require('./textOt')
  , merge = racer.util.merge
  , markers = {}
  , markersDirty = true
  , globalElements = {
      $_win: window
    , $_doc: document
    }
  , addListener, removeListener;

module.exports = Dom;

function Dom(model) {
  var dom = this
  var fns = this.fns

  // Map dom event name -> true
  var listenerAdded = {};
  var captureListenerAdded = {}

  // DOM listener capturing allows blur and focus to be delegated
  // http:http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
  var captureEvents = this._captureEvents = new EventDispatcher({
    onTrigger: onCaptureTrigger
  , onBind: onCaptureBind
  });
  function onCaptureTrigger(name, listener, e) {
    var id = listener.id
      , el = document.getElementById(id);

    // Remove listener if element isn't found
    if (!el) return false;

    if (el.tagName === 'HTML' || el.contains(e.target)) {
      onDomTrigger(name, listener, id, e, el);
    }
  }
  function onCaptureBind(name, listener) {
    if (captureListenerAdded[name]) return;
    addListener(document, name, captureTrigger, true);
    captureListenerAdded[name] = true;
  }

  var events = this._events = new EventDispatcher({
    onTrigger: onDomTrigger
  , onBind: onDomBind
  });
  function onDomTrigger(name, listener, id, e, el, next) {
    var delay = listener.delay
      , finish = listener.fn;

    e.path = function(name) {
      if (!name) return model.__pathMap.paths[listener.pathId];
      return viewPath.ctxPath(listener.view, listener.ctx, name);
    };
    e.get = function(name) {
      var path = e.path(name);
      return viewPath.dataValue(listener.view, listener.ctx, model, path);
    };
    e.at = function(name) {
      return model.at(e.path(name));
    };

    if (!finish) {
      // Update the model when the element's value changes
      finish = function() {
        var value = dom.getMethods[listener.method](el, listener.property)
          , setValue = listener.setValue;

        // Allow the listener to override the setting function
        if (setValue) {
          setValue(model, value);
          return;
        }

        // Remove this listener if its path id is no longer registered
        var path = model.__pathMap.paths[listener.pathId];
        if (!path) return false;

        // Set the value if changed
        if (model.get(path) === value) return;

        var setterModel = model.pass({$e: e, $el: el});
        if (listener.method === 'propOt') {
          return textOt.onTextInput(setterModel, path, value);
        }
        setterModel.set(path, value);
      }
    }

    if (delay != null) {
      setTimeout(finish, delay, e, el, next, dom);
    } else {
      finish(e, el, next, dom);
    }
  }
  function onDomBind(name, listener, eventName) {
    if (listenerAdded[eventName]) return;
    addListener(document, eventName, triggerDom, true);
    listenerAdded[eventName] = true;
  }

  function triggerDom(e, el, noBubble, continued) {
    if (!el) el = e.target;
    var prefix = e.type + ':'
      , id;

    // Next can be called from a listener to continue bubbling
    function next() {
      triggerDom(e, el.parentNode, false, true);
    }
    next.firstTrigger = !continued;
    if (noBubble && (id = el.id)) {
      return events.trigger(prefix + id, id, e, el, next);
    }
    while (true) {
      while (!(id = el.id)) {
        if (!(el = el.parentNode)) return;
      }
      // Stop bubbling once the event is handled
      if (events.trigger(prefix + id, id, e, el, next)) return;
      if (!(el = el.parentNode)) return;
    }
  }

  function captureTrigger(e) {
    captureEvents.trigger(e.type, e);
  }

  this.trigger = triggerDom;
  this.captureTrigger = captureTrigger;

  this._listeners = [];
  this._components = [];
  this._pendingUpdates = [];

  function componentCleanup() {
    var components = dom._components
      , map = getMarkers()
      , i, component
    for (i = components.length; i--;) {
      component = components[i];
      if (component && !getMarker(map, component.scope)) {
        component.emit('destroy');
      }
    }
  }
  // TODO This 'cleanup' event is never emitted; deal with later
  // This cleanup listeners is placed at the beginning so that component
  // scopes are cleared before any ref cleanups are checked
  model.listeners('cleanup').unshift(componentCleanup);
}

Dom.prototype = {
  clear: domClear
, bind: domBind
, item: domItem
, marker: domMarker
, update: domUpdate
, addListener: domAddListener
, removeListener: domRemoveListener
, addComponent: addComponent
, _setDirty: setDirty

, getMethods: {
    attr: getAttr
  , prop: getProp
  , propOt: getPropOt
  , stringInsert: getPropOt
  , stringRemove: getPropOt
  , html: getHtml
    // These methods return NaN, because it never equals anything else. Thus,
    // when compared against the new value, the new value will always be set
  , insert: getNaN
  , remove: getNaN
  , move: getNaN
  }

, setMethods: {
    attr: setAttr
  , prop: setProp
  , propOt: setPropOt
  , stringInsert: setStringInsert
  , stringRemove: setStringRemove
  , html: setHtml
  , insert: setInsert
  , remove: setRemove
  , move: setMove
  }

, fns: {
    $forChildren: forChildren
  , $forName: forName
  }
}

function domClear() {
  this._events.clear();
  this._captureEvents.clear();
  var components = this._components
    , listeners = this._listeners
    , i, component
  for (i = listeners.length; i--;) {
    removeListener.apply(null, listeners[i]);
  }
  this._listeners = [];
  for (i = components.length; i--;) {
    component = components[i];
    component && component.emit('destroy');
  }
  this._components = [];
  markers = {};
}

function domListenerHash() {
  var out = {}
    , key
  for (key in this) {
    if (key === 'view' || key === 'ctx' || key === 'pathId') continue;
    out[key] = this[key];
  }
  return out;
}

function domBind(eventName, id, listener) {
  listener.toJSON = domListenerHash;
  if (listener.capture) {
    listener.id = id;
    this._captureEvents.bind(eventName, listener);
  } else {
    this._events.bind("" + eventName + ":" + id, listener, eventName);
  }
}

function domItem(id) {
  return document.getElementById(id) || globalElements[id] || getRange(id);
}

// HACK: Crappy interface. Should refactor marker getting to be a prototype
// method and make dirty a property of dom instance
function setDirty(value) {
  markersDirty = value;
}

function domUpdate(el, method, ignore, value, property, index, arg) {
  // Wrapped in a try / catch so that errors thrown on DOM updates don't
  // stop subsequent code from running
  try {
    // Don't do anything if the element is already up to date
    if (value === this.getMethods[method](el, property)) return;
    this.setMethods[method](el, ignore, value, property, index, arg);
    markersDirty = true;
  } catch (err) {
    setTimeout(function() {
      throw err;
    }, 0);
  }
}

function domAddListener(el, name, callback, captures) {
  this._listeners.push([el, name, callback, captures]);
  addListener(el, name, callback, captures);
}
function domRemoveListener(el, name, callback, captures) {
  removeListener(el, name, callback, captures);
}

function addComponent(ctx, component) {
  var components = this._components
    , dom = component.dom = Object.create(this);

  components.push(component);
  component.on('destroy', function() {
    var index = components.indexOf(component);
    if (index === -1) return;
    // The components array gets replaced on a dom.clear, so we allow
    // it to get sparse as individual components are destroyed
    delete components[index];
  });

  dom.addListener = function(el, name, callback, captures) {
    component.on('destroy', function() {
      removeListener(el, name, callback, captures);
    });
    addListener(el, name, callback, captures);
  };

  dom.element = function(name) {
    var id = ctx.$elements[name];
    return document.getElementById(id);
  };

  return dom;
}


function getAttr(el, attr) {
  return el.getAttribute && el.getAttribute(attr);
}
function getProp(el, prop) {
  return el[prop];
}
function getPropOt(el, prop) {
  // IE and Opera replace \n with \r\n
  var value = el[prop];
  return value && value.replace && value.replace(/\r\n/g, '\n');
}
function getHtml(el) {
  return el.innerHTML;
}
function getNaN() {
  return NaN;
}

function setAttr(el, ignore, value, attr) {
  el.setAttribute && el.setAttribute(attr, value);
}
function setProp(el, ignore, value, prop) {
  el[prop] = value;
}
function setPropOt(el, ignore, value, prop) {
  el[prop] = value;
}
function setStringInsert(el, ignore, value, prop, index, text) {
  var previous = getPropOt(el, prop);
  textOt.onStringInsert(el, previous, index, text);
}
function setStringRemove(el, ignore, value, prop, index, howMany) {
  var previous = getPropOt(el, prop);
  textOt.onStringRemove(el, previous, index, howMany);
}

function makeSVGFragment(fragment, svgElement) {
  // TODO: Allow optional namespace declarations
  var pre = '<svg xmlns=http:http://www.w3.org/2000/svg xmlns:xlink=http:http://www.w3.org/1999/xlink>' 
    , post = '</svg>'
    , range = document.createRange()
  range.selectNode(svgElement);
  return range.createContextualFragment(pre + fragment + post);
}
function appendSVG(element, fragment, svgElement) {
  var frag = makeSVGFragment(fragment, svgElement)
    , children = frag.childNodes[0].childNodes
    , i
  for (i = children.length; i--;) {
    element.appendChild(children[0]);
  }
}
function insertBeforeSVG(element, fragment, svgElement) {
  var frag = makeSVGFragment(fragment, svgElement)
    , children = frag.childNodes[0].childNodes
    , parent = element.parentNode
    , i
  for (i = children.length; i--;) {
    parent.insertBefore(children[0], element);
  }
}
function removeChildren(element) {
  var children = element.childNodes
    , i
  for (i = children.length; i--;) {
    element.removeChild(children[0]);
  }
}

function isSVG(obj) {
  return !!obj.ownerSVGElement || obj.tagName === "svg";
}
function svgRoot(obj) {
  return obj.ownerSVGElement || obj;
}
function isRange(obj) {
  return !!obj.cloneRange;
}

function setHtml(obj, ignore, value, escape) {
  if (escape) value = escapeHtml(value);
  if(isRange(obj)) {
    if(isSVG(obj.startContainer)) {
      // SVG Element
      obj.deleteContents();
      var svgElement = svgRoot(obj.startContainer);
      obj.insertNode(makeSVGFragment(value, svgElement));
      return;
    } else {
      // Range
      obj.deleteContents();
      obj.insertNode(obj.createContextualFragment(value));
      return;
    }
  }
  if (isSVG(obj)) {
    // SVG Element
    var svgElement = svgRoot(obj);
    removeChildren(obj);
    appendSVG(obj, value, svgElement);
    return;
  }
  // HTML Element
  if (ignore && obj.id === ignore) return;
  obj.innerHTML = value;
}
function setInsert(obj, ignore, value, escape, index) {
  if (escape) value = escapeHtml(value);
  if (obj.nodeType) {
    // Element
    if (ref = obj.childNodes[index]) {
      if (isSVG(obj)) {
        var svgElement = obj.ownerSVGElement || obj;
        insertBeforeSVG(ref, value, svgElement);
        return;
      }
      var range = document.createRange();
      range.selectNodeContents(obj);
      obj.insertBefore(range.createContextualFragment(value), ref);
    } else {
      if (isSVG(obj)) {
        var svgElement = obj.ownerSVGElement || obj;
        appendSVG(obj, value, svgElement);
        return;
      }
      var range = document.createRange();
      range.selectNodeContents(obj);
      obj.appendChild(range.createContextualFragment(value));
    }
  } else {
    // Range
    if (isSVG(obj.startContainer)) {
      var el = obj.startContainer
      , ref = el.childNodes[obj.startOffset + index];
      var svgElement = svgRoot(ref);
      el.insertBefore(makeSVGFragment(value, svgElement), ref)
    } else {
      var el = obj.startContainer
        , ref = el.childNodes[obj.startOffset + index];
      el.insertBefore(obj.createContextualFragment(value), ref);
    }
  }
}
function setRemove(el, ignore, index) {
  if (!el.nodeType) {
    // Range
    index += el.startOffset;
    el = el.startContainer;
  }
  var child = el.childNodes[index];
  if (child) el.removeChild(child);
}
function setMove(el, ignore, from, property, to, howMany) {
  var child, fragment, nextChild, offset, ref, toEl;
  if (!el.nodeType) {
    offset = el.startOffset;
    from += offset;
    to += offset;
    el = el.startContainer;
  }
  child = el.childNodes[from];

  // Don't move if the item at the destination is passed as the ignore
  // option, since this indicates the intended item was already moved
  // Also don't move if the child to move matches the ignore option
  if (!child || ignore && (toEl = el.childNodes[to]) &&
      toEl.id === ignore || child.id === ignore) return;

  ref = el.childNodes[to > from ? to + howMany : to];
  if (howMany > 1) {
    fragment = document.createDocumentFragment();
    while (howMany--) {
      nextChild = child.nextSibling;
      fragment.appendChild(child);
      if (!(child = nextChild)) break;
    }
    el.insertBefore(fragment, ref);
    return;
  }
  el.insertBefore(child, ref);
}

function forChildren(e, el, next, dom) {
  // Prevent infinte emission
  if (!next.firstTrigger) return;

  // Re-trigger the event on all child elements
  var children = el.childNodes;
  for (var i = 0, len = children.length, child; i < len; i++) {
    child = children[i];
    if (child.nodeType !== 1) continue;  // Node.ELEMENT_NODE
    dom.trigger(e, child, true, true);
    forChildren(e, child, next, dom);
  }
}

function forName(e, el, next, dom) {
  // Prevent infinte emission
  if (!next.firstTrigger) return;

  var name = el.getAttribute('name');
  if (!name) return;

  // Re-trigger the event on all other elements with
  // the same 'name' attribute
  var elements = document.getElementsByName(name)
    , len = elements.length;
  if (!(len > 1)) return;
  for (var i = 0, element; i < len; i++) {
    element = elements[i];
    if (element === el) continue;
    dom.trigger(e, element, false, true);
  }
}

function getMarkers() {
  var map = {};
  // NodeFilter.SHOW_COMMENT == 128
  var commentIterator = document.createTreeWalker(document, 128, null, false);
  var comment;
  while (comment = commentIterator.nextNode()) {
    map[comment.data] = comment;
  }
  return map;
}

function getMarker(map, name) {
  var marker = map[name];
  if (!marker) return;

  // Comment nodes may continue to exist even if they have been removed from
  // the page. Thus, make sure they are still somewhere in the page body
  if (!document.contains(marker)) {
    delete map[name];
    return;
  }
  return marker;
}

function domMarker(name) {
  var marker = getMarker(markers, name);
  if (!marker && markersDirty) {
    markers = getMarkers();
    markersDirty = false;
    marker = getMarker(markers, name);
  }
  return marker;
}

function getRange(name) {
  var start = domMarker(name);
  if (!start) return;
  var end = domMarker('$' + name);
  if (!end) return;

  var range = document.createRange();
  range.setStartAfter(start);
  range.setEndBefore(end);
  return range;
}

if (document.addEventListener) {
  addListener = function(el, name, callback, captures) {
    el.addEventListener(name, callback, captures || false);
  };
  removeListener = function(el, name, callback, captures) {
    el.removeEventListener(name, callback, captures || false);
  };
}

},{"racer":"CsQUzZ","./EventDispatcher":29,"./viewPath":53,"./textOt":45,"dom-shim":54,"html-util":55}],24:[function(require,module,exports){
var escapeHtml = require('html-util').escapeHtml
  , errors = {};

exports.errorHtml = errorHtml;
exports.autoRefresh = autoRefresh;

function errorHtml(errors) {
  var text = ''
    , type, err;
  for (type in errors) {
    err = errors[type];
    text += '<h3>' + escapeHtml(type) + ' Error</h3><pre>' + escapeHtml(err) + '</pre>';
  }
  if (!text) return;
  return '<div id=$_derbyError style="position:absolute;background:rgba(0,0,0,.7);top:0;left:0;right:0;bottom:0;text-align:center">' +
    '<div style="background:#fff;padding:20px 40px;margin:60px;display:inline-block;text-align:left">' +
    text + '</div></div>';
}

function autoRefresh(view, model) {

  model.channel.on('derby:reload', reloadOnReady);
  // Wait to reload until the server is responsive again after restarting
  function reloadOnReady() {
    xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function() {
      if (xhr.readyState !== 4) return;
      if (xhr.status === 200) {
        return window.location.reload(true);
      }
      reloadOnReady();
    };
    xhr.open('GET', window.location.href);
    xhr.send();
  }

  model.channel.on('derby:refreshCss', function(data) {
    var el = document.getElementById('$_css');
    if (el) el.innerHTML = data.css;
    updateError('CSS', data.errText);
  });

  model.channel.on('derby:refreshHtml', function(data) {
    view._makeAll(data.templates, data.instances);
    view._makeComponents(data.libraryData);
    var errText = data.errText;
    try {
      view.app.history.refresh();
    } catch (err) {
      errText || (errText = err.stack);
    }
    updateError('Template', data.errText);
  });
}

function updateError(type, err) {
  if (err) {
    errors[type] = err;
  } else {
    delete errors[type];
  }
  var el = document.getElementById('$_derbyError')
    , html = errorHtml(errors)
    , fragment, range;
  if (html) {
    if (el) {
      el.outerHTML = html;
    } else {
      range = document.createRange();
      range.selectNode(document.body);
      fragment = range.createContextualFragment(html);
      document.body.appendChild(fragment);
    }
  } else {
    if (el) el.parentNode.removeChild(el);
  }
}

},{"html-util":55}],46:[function(require,module,exports){
var url = require('url');

exports.init = function (model) {
  var filename = model.get('filename') || 'github-btn.html'
    , fileurl = model.get('fileurl')
    , domain = model.get('domain') || 'ghbtns.com'
    , giturl = model.get('giturl')
    , height = model.get('height')
    , protocol = model.get('secure') ? 'https' : 'http'
    , repo = model.get('repo')
    , size = model.get('size')
    , type = model.get('type')
    , user = model.get('user');

  if (!giturl && (!user || !repo)) {
    return console.error('ghbtns:button: giturl or user/repo required');
  }

  if (!type) {
    return console.error('ghbtns:button: type required');
  }

  if (!fileurl) {
    model.set('fileurl', protocol + '://' + domain + '/' + filename);
  }

  if (giturl) {
    var gitpath = url.parse(giturl).path.split('/');
    model.set('repo', gitpath[2].slice(0, -4));
    model.set('user', gitpath[1]);
  }

  if (!height) {
    model.set('height', size === 'large' ? '30' : '20');
  }

  model.set('show', true);
};
},{"url":8}],48:[function(require,module,exports){
var pSlice = Array.prototype.slice;
var Object_keys = typeof Object.keys === 'function'
    ? Object.keys
    : function (obj) {
        var keys = [];
        for (var key in obj) keys.push(key);
        return keys;
    }
;

var deepEqual = module.exports = function (actual, expected) {
  // enforce Object.is +0 !== -0
  if (actual === 0 && expected === 0) {
    return areZerosEqual(actual, expected);

  // 7.1. All identical values are equivalent, as determined by ===.
  } else if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  } else if (isNumberNaN(actual)) {
    return isNumberNaN(expected);

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (typeof actual != 'object' && typeof expected != 'object') {
    return actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
};

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function isNumberNaN(value) {
  // NaN === NaN -> false
  return typeof value == 'number' && value !== value;
}

function areZerosEqual(zeroA, zeroB) {
  // (1 / +0|0) -> Infinity, but (1 / -0) -> -Infinity and (Infinity !== -Infinity)
  return (1 / zeroA) === (1 / zeroB);
}

function objEquiv(a, b) {
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;

  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b);
  }
  try {
    var ka = Object_keys(a),
        kb = Object_keys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key])) return false;
  }
  return true;
}

},{}],54:[function(require,module,exports){
var doc = document
  , elementProto = HTMLElement.prototype
  , nodeProto = Node.prototype

// Add support for Node.contains for Firefox < 9
if (!doc.contains) {
  nodeProto.contains = function(node) {
    return !!(this.compareDocumentPosition(node) & 16)
  }
}

// Add support for insertAdjacentHTML for Firefox < 8
// Based on insertAdjacentHTML.js by Eli Grey, http://eligrey.com
if (!doc.body.insertAdjacentHTML) {
  elementProto.insertAdjacentHTML = function(position, html) {
    var position = position.toLowerCase()
      , ref = this
      , parent = ref.parentNode
      , container = doc.createElement(parent.tagName)
      , firstChild, nextSibling, node

    container.innerHTML = html
    if (position === 'beforeend') {
      while (node = container.firstChild) {
        ref.appendChild(node)
      }
    } else if (position === 'beforebegin') {
      while (node = container.firstChild) {
        parent.insertBefore(node, ref)
      }
    } else if (position === 'afterend') {
      nextSibling = ref.nextSibling
      while (node = container.lastChild) {
        nextSibling = parent.insertBefore(node, nextSibling)
      }
    } else if (position === 'afterbegin') {
      firstChild = ref.firstChild
      while (node = container.lastChild) {
        firstChild = ref.insertBefore(node, firstChild)
      }
    }
  }
}

elementProto.matches =
  elementProto.webkitMatchesSelector ||
  elementProto.mozMatchesSelector ||
  elementProto.oMatchesSelector ||
  elementProto.msMatchesSelector

},{}],32:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var util = require('../util');
var Model = require('./Model');

// This map determines which events get re-emitted as an 'all' event
Model.MUTATOR_EVENTS = {
  change: true
, insert: true
, remove: true
, move: true
, stringInsert: true
, stringRemove: true
, load: true
, unload: true
};

Model.INITS.push(function(model) {
  EventEmitter.call(this);

  // Set max listeners to unlimited
  model.setMaxListeners(0);

  // Used in async methods to emit an error event if a callback is not supplied.
  // This will throw if there is no handler for model.on('error')
  model.root._defaultCallback = defaultCallback;
  function defaultCallback(err) {
    if (typeof err === 'string') err = new Error(err);
    if (err) model.emit('error', err);
  }

  model.root._mutatorEventQueue = null;
  model._pass = new Passed({}, {});
});

util.mergeInto(Model.prototype, EventEmitter.prototype);

// EventEmitter.prototype.on, EventEmitter.prototype.addListener, and
// EventEmitter.prototype.once return `this`. The Model equivalents return
// the listener instead, since it is made internally for method subscriptions
// and may need to be passed to removeListener.

Model.prototype._emit = EventEmitter.prototype.emit;
Model.prototype.emit = function(type) {
  if (Model.MUTATOR_EVENTS[type]) {
    if (this._silent) return this;
    var segments = arguments[1];
    var eventArgs = arguments[2];
    if (this.root._mutatorEventQueue) {
      this.root._mutatorEventQueue.push([type, segments, eventArgs]);
      return this;
    }
    this.root._mutatorEventQueue = [];
    this._emit(type, segments, eventArgs);
    this._emit('all', segments, [type].concat(eventArgs));
    while (this.root._mutatorEventQueue.length) {
      var queued = this.root._mutatorEventQueue.shift();
      type = queued[0];
      segments = queued[1];
      eventArgs = queued[2];
      this._emit(type, segments, eventArgs);
      this._emit('all', segments, [type].concat(eventArgs));
    }
    this.root._mutatorEventQueue = null;
    return this;
  }
  return this._emit.apply(this, arguments);
};

Model.prototype._on = EventEmitter.prototype.on;
Model.prototype.addListener =
Model.prototype.on = function(type, pattern, cb) {
  var listener = eventListener(this, pattern, cb);
  this._on(type, listener);
  return listener;
};

Model.prototype.once = function(type, pattern, cb) {
  var listener = eventListener(this, pattern, cb);
  function g() {
    var matches = listener.apply(null, arguments);
    if (matches) this.removeListener(type, g);
  }
  this._on(type, g);
  return g;
};

Model.prototype._removeAllListeners = EventEmitter.prototype.removeAllListeners;
Model.prototype.removeAllListeners = function(type, subpattern) {
  if (!this._events) return this;

  // If a pattern is specified without an event type, remove all model event
  // listeners under that pattern for all events
  if (!type) {
    for (var key in this._events) {
      this.removeAllListeners(key, subpattern);
    }
    return this;
  }

  var pattern = this.path(subpattern);
  // If no pattern is specified, remove all listeners like normal
  if (!pattern) {
    if (arguments.length === 0) {
      return this._removeAllListeners();
    } else {
      return this._removeAllListeners(type);
    }
  }

  // Remove all listeners for an event under a pattern
  var listeners = this.listeners(type);
  var segments = pattern.split('.');
  // Make sure to iterate in reverse, since the array might be
  // mutated as listeners are removed
  for (var i = listeners.length; i--;) {
    var listener = listeners[i];
    if (patternContained(pattern, segments, listener)) {
      this.removeListener(type, listener);
    }
  }
};

function patternContained(pattern, segments, listener) {
  var listenerSegments = listener.patternSegments;
  if (!listenerSegments) return false;
  if (pattern === listener.pattern || pattern === '**') return true;
  var len = segments.length;
  if (len > listenerSegments.length) return false;
  for (var i = 0; i < len; i++) {
    if (segments[i] !== listenerSegments[i]) return false;
  }
  return true;
}

Model.prototype.pass = function(object, invert) {
  var model = this._child();
  model._pass = (invert) ?
    new Passed(object, this._pass) :
    new Passed(this._pass, object);
  return model;
};

function Passed(previous, value) {
  for (var key in previous) {
    this[key] = previous[key];
  }
  for (var key in value) {
    this[key] = value[key];
  }
}

/**
 * The returned Model will or won't trigger event handlers when the model emits
 * events, depending on `value`
 * @param {Boolean|Null} value defaults to true
 * @return {Model}
 */
Model.prototype.silent = function(value) {
  var model = this._child();
  model._silent = (value == null) ? true : value;
  return model;
};

function eventListener(model, subpattern, cb) {
  if (cb) {
    // For signatures:
    // model.on('change', 'example.subpath', callback)
    // model.at('example').on('change', 'subpath', callback)
    var pattern = model.path(subpattern);
    return modelEventListener(pattern, cb);
  }
  var path = model.path();
  cb = arguments[1];
  // For signature:
  // model.at('example').on('change', callback)
  if (path) return modelEventListener(path, cb);
  // For signature:
  // model.on('normalEvent', callback)
  return cb;
}

function modelEventListener(pattern, cb) {
  var patternSegments = pattern.split('.');
  var testFn = testPatternFn(pattern, patternSegments);

  function modelListener(segments, eventArgs) {
    var captures = testFn(segments);
    if (!captures) return;

    var args = (captures.length) ? captures.concat(eventArgs) : eventArgs;
    cb.apply(null, args);
    return true;
  }

  // Used in Model#removeAllListeners
  modelListener.pattern = pattern;
  modelListener.patternSegments = patternSegments;

  return modelListener;
}

function testPatternFn(pattern, patternSegments) {
  if (pattern === '**') {
    return function testPattern(segments) {
      return [segments.join('.')];
    };
  }

  var endingRest = stripRestWildcard(patternSegments);

  return function testPattern(segments) {
    // Any pattern with more segments does not match
    var patternLen = patternSegments.length;
    if (patternLen > segments.length) return;

    // A pattern with the same number of segments matches if each
    // of the segments are wildcards or equal. A shorter pattern matches
    // if it ends in a rest wildcard and each of the corresponding
    // segments are wildcards or equal.
    if (patternLen === segments.length || endingRest) {
      var captures = [];
      for (var i = 0; i < patternLen; i++) {
        var patternSegment = patternSegments[i];
        var segment = segments[i];
        if (patternSegment === '*' || patternSegment === '**') {
          captures.push(segment);
          continue;
        }
        if (patternSegment !== segment) return;
      }
      if (endingRest) {
        var remainder = segments.slice(i).join('.');
        captures.push(remainder);
      }
      return captures;
    }
  };
}

function stripRestWildcard(segments) {
  // ['example', '**'] -> ['example']; return true
  var lastIndex = segments.length - 1;
  if (segments[lastIndex] === '**') {
    segments.pop();
    return true;
  }
  // ['example', 'subpath**'] -> ['example', 'subpath']; return true
  var match = /^([^\*]+)\*\*$/.exec(segments[lastIndex]);
  if (!match) return false;
  segments[lastIndex] = match[1];
  return true;
}

},{"events":12,"../util":14,"./Model":31}],33:[function(require,module,exports){
var Model = require('./Model');

exports.mixin = {};

Model.prototype._splitPath = function(subpath) {
  var path = this.path(subpath);
  return (path && path.split('.')) || [];
};

/**
 * Returns the path equivalent to the path of the current scoped model plus
 * (optionally) a suffix subpath
 *
 * @optional @param {String} subpath
 * @return {String} absolute path
 * @api public
 */
Model.prototype.path = function(subpath) {
  if (subpath == null || subpath === '') return (this._at) ? this._at : '';
  if (typeof subpath === 'string' || typeof subpath === 'number') {
    return (this._at) ? this._at + '.' + subpath : '' + subpath;
  }
  if (typeof subpath.path === 'function') return subpath.path();
};

Model.prototype.isPath = function(subpath) {
  return this.path(subpath) != null;
};

Model.prototype.scope = function(path) {
  var model = this._child();
  model._at = path;
  return model;
};

/**
 * Create a model object scoped to a particular path.
 * Example:
 *     var user = model.at('users.1');
 *     user.set('username', 'brian');
 *     user.on('push', 'todos', function (todo) {
 *       // ...
 *     });
 *
 *  @param {String} segment
 *  @return {Model} a scoped model
 *  @api public
 */
Model.prototype.at = function(subpath) {
  var path = this.path(subpath);
  return this.scope(path);
};

/**
 * Returns a model scope that is a number of levels above the current scoped
 * path. Number of levels defaults to 1, so this method called without
 * arguments returns the model scope's parent model scope.
 *
 * @optional @param {Number} levels
 * @return {Model} a scoped model
 */
Model.prototype.parent = function(levels) {
  if (levels == null) levels = 1;
  var segments = this._splitPath();
  var len = Math.max(0, segments.length - levels);
  var path = segments.slice(0, len).join('.');
  return this.scope(path);
};

/**
 * Returns the last property segment of the current model scope path
 *
 * @optional @param {String} path
 * @return {String}
 */
Model.prototype.leaf = function(path) {
  if (!path) path = this.path();
  var i = path.lastIndexOf('.');
  return path.slice(i + 1);
};

},{"./Model":31}],34:[function(require,module,exports){
var Model = require('./Model');
var LocalDoc = require('./LocalDoc');
var util = require('../util');

function CollectionMap() {}
function ModelData() {}
function DocMap() {}
function CollectionData() {}

Model.INITS.push(function(model) {
  model.root.collections = new CollectionMap;
  model.root.data = new ModelData;
});

Model.prototype.getCollection = function(collectionName) {
  return this.root.collections[collectionName];
};
Model.prototype.getDoc = function(collectionName, id) {
  var collection = this.root.collections[collectionName];
  return collection && collection.docs[id];
};
Model.prototype.get = function(subpath) {
  var segments = this._splitPath(subpath);
  return this._get(segments);
};
Model.prototype._get = function(segments) {
  return util.lookup(segments, this.root.data);
};
Model.prototype.getOrCreateCollection = function(name) {
  var collection = this.root.collections[name];
  if (collection) return collection;
  var Doc = this._getDocConstructor(name);
  collection = new Collection(this.root, name, Doc);
  this.root.collections[name] = collection;
  return collection;
};
Model.prototype._getDocConstructor = function() {
  // Only create local documents. This is overriden in ./connection.js, so that
  // the RemoteDoc behavior can be selectively included
  return LocalDoc;
};

/**
 * Returns an existing document with id in a collection. If the document does
 * not exist, then creates the document with id in a collection and returns the
 * new document.
 * @param {String} collectionName
 * @param {String} id
 * @param {Object} [data] data to create if doc with id does not exist in collection
 */
Model.prototype.getOrCreateDoc = function(collectionName, id, data) {
  var collection = this.getOrCreateCollection(collectionName);
  return collection.docs[id] || collection.add(id, data);
};

/**
 * @param {String} collectionName
 */
Model.prototype.destroy = function(collectionName) {
  // TODO: non-collections
  var collection = this.getCollection(collectionName);
  collection && collection.destroy();
  this.removeAllRefs(collectionName);
  this.stopAll(collectionName);
  this.removeAllFilters(collectionName);
  this.removeAllListeners(null, collectionName);
};

function Collection(model, name, Doc) {
  this.model = model;
  this.name = name;
  this.Doc = Doc;
  this.docs = new DocMap();
  this.data = model.data[name] = new CollectionData();
}

/**
 * Adds a document with `id` and `data` to `this` Collection.
 * @param {String} id
 * @param {Object} data
 * @return {LocalDoc|RemoteDoc} doc
 */
Collection.prototype.add = function(id, data) {
  var doc = new this.Doc(this.model, this.name, id, data);
  this.docs[id] = doc;
  return doc;
};
Collection.prototype.destroy = function() {
  delete this.model.collections[this.name];
  delete this.model.data[this.name];
};

/**
 * Removes the document with `id` from `this` Collection. If there are no more
 * documents in the Collection after the given document is removed, then this
 * also destroys the Collection.
 * @param {String} id
 */
Collection.prototype.remove = function(id) {
  delete this.docs[id];
  delete this.data[id];
  if (noKeys(this.docs)) this.destroy();
};

/**
 * Returns an object that maps doc ids to fully resolved documents.
 * @return {Object}
 */
Collection.prototype.get = function() {
  return this.data;
};

function noKeys(object) {
  for (var key in object) {
    return false;
  }
  return true;
}

},{"./Model":31,"./LocalDoc":56,"../util":14}],35:[function(require,module,exports){
var util = require('../util');
var Model = require('./Model');

Model.prototype._mutate = function(segments, fn, cb) {
  if (!cb) cb = this.root._defaultCallback;
  var collectionName = segments[0];
  var id = segments[1];
  if (!collectionName || !id) {
    var message = fn.name + ' must be performed under a collection ' +
      'and document id. Invalid path: ' + segments.join('.');
    return cb(new Error(message));
  }
  var doc = this.getOrCreateDoc(collectionName, id);
  var docSegments = segments.slice(2);
  return fn(doc, docSegments, cb);
};

Model.prototype.set = function() {
  var subpath, value, cb;
  if (arguments.length === 1) {
    value = arguments[0];
  } else if (arguments.length === 2) {
    subpath = arguments[0];
    value = arguments[1];
  } else {
    subpath = arguments[0];
    value = arguments[1];
    cb = arguments[2];
  }
  var segments = this._splitPath(subpath);
  return this._set(segments, value, cb);
};
Model.prototype._set = function(segments, value, cb) {
  segments = this._dereference(segments);
  var model = this;
  function set(doc, docSegments, fnCb) {
    var previous = doc.set(docSegments, value, fnCb);
    model.emit('change', segments, [value, previous, model._pass]);
    return previous;
  }
  return this._mutate(segments, set, cb);
};

Model.prototype.setEach = function() {
  var subpath, object, cb;
  if (arguments.length === 1) {
    object = arguments[0];
  } else if (arguments.length === 2) {
    subpath = arguments[0];
    object = arguments[1];
  } else {
    subpath = arguments[0];
    object = arguments[1];
    cb = arguments[2];
  }
  var segments = this._splitPath(subpath);
  return this._setEach(segments, object, cb);
};
Model.prototype._setEach = function(segments, object, cb) {
  segments = this._dereference(segments);
  var group = util.asyncGroup(cb || this.root._defaultCallback);
  for (var key in object) {
    var value = object[key];
    this._set(segments.concat(key), value, group());
  }
};

Model.prototype.add = function() {
  var subpath, value, cb;
  if (arguments.length === 1) {
    value = arguments[0];
  } else if (arguments.length === 2) {
    if (typeof arguments[1] === 'function') {
      value = arguments[0];
      cb = arguments[1];
    } else {
      subpath = arguments[0];
      value = arguments[1];
    }
  } else {
    subpath = arguments[0];
    value = arguments[1];
    cb = arguments[2];
  }
  var segments = this._splitPath(subpath);
  return this._add(segments, value, cb);
};
Model.prototype._add = function(segments, value, cb) {
  if (typeof value !== 'object') {
    var message = 'add requires an object value. Invalid value: ' + value;
    cb || (cb = this.root._defaultCallback);
    return cb(new Error(message));
  }
  var id = value.id || this.id();
  value.id = id;
  this._set(segments.concat(id), value, cb);
  return id;
};

Model.prototype.setNull = function() {
  var subpath, value, cb;
  if (arguments.length === 1) {
    value = arguments[0];
  } else if (arguments.length === 2) {
    subpath = arguments[0];
    value = arguments[1];
  } else {
    subpath = arguments[0];
    value = arguments[1];
    cb = arguments[2];
  }
  var segments = this._splitPath(subpath);
  return this._setNull(segments, value, cb);
};
Model.prototype._setNull = function(segments, value, cb) {
  segments = this._dereference(segments);
  var model = this;
  function setNull(doc, docSegments, fnCb) {
    var previous = doc.get(docSegments);
    if (previous != null) {
      fnCb();
      return previous;
    }
    doc.set(docSegments, value, fnCb);
    model.emit('change', segments, [value, previous, model._pass]);
    return value;
  }
  return this._mutate(segments, setNull, cb);
};

Model.prototype.del = function() {
  var subpath, cb;
  if (arguments.length === 1) {
    if (typeof arguments[0] === 'function') {
      cb = arguments[0];
    } else {
      subpath = arguments[0];
    }
  } else {
    subpath = arguments[0];
    cb = arguments[1];
  }
  var segments = this._splitPath(subpath);
  return this._del(segments, cb);
};
Model.prototype._del = function(segments, cb) {
  segments = this._dereference(segments);
  var model = this;
  function del(doc, docSegments, fnCb) {
    var previous = doc.del(docSegments, fnCb);
    // When deleting an entire document, also remove the reference to the
    // document object from its collection
    if (segments.length === 2) {
      var collectionName = segments[0];
      var id = segments[1];
      model.root.collections[collectionName].remove(id);
    }
    model.emit('change', segments, [void 0, previous, model._pass]);
    return previous;
  }
  return this._mutate(segments, del, cb);
};

Model.prototype.increment = function() {
  var subpath, byNumber, cb;
  if (arguments.length === 1) {
    if (typeof arguments[0] === 'function') {
      cb = arguments[0];
    } else if (typeof arguments[0] === 'number') {
      byNumber = arguments[0];
    } else {
      subpath = arguments[0];
    }
  } else if (arguments.length === 2) {
    if (typeof arguments[1] === 'function') {
      cb = arguments[1];
      if (typeof arguments[0] === 'number') {
        byNumber = arguments[0];
      } else {
        subpath = arguments[0];
      }
    } else {
      subpath = arguments[0];
      byNumber = arguments[1];
    }
  } else {
    subpath = arguments[0];
    byNumber = arguments[1];
    cb = arguments[2];
  }
  var segments = this._splitPath(subpath);
  return this._increment(segments, byNumber, cb);
};
Model.prototype._increment = function(segments, byNumber, cb) {
  segments = this._dereference(segments);
  if (byNumber == null) byNumber = 1;
  var model = this;
  function increment(doc, docSegments, fnCb) {
    var value = doc.increment(docSegments, byNumber, fnCb);
    var previous = value - byNumber;
    model.emit('change', segments, [value, previous, model._pass]);
    return value;
  }
  return this._mutate(segments, increment, cb);
};

Model.prototype.push = function() {
  var subpath, value, cb;
  if (arguments.length === 1) {
    value = arguments[0];
  } else if (arguments.length === 2) {
    subpath = arguments[0];
    value = arguments[1];
  } else {
    subpath = arguments[0];
    value = arguments[1];
    cb = arguments[2];
  }
  var segments = this._splitPath(subpath);
  return this._push(segments, value, cb);
};
Model.prototype._push = function(segments, value, cb) {
  var forArrayMutator = true;
  segments = this._dereference(segments, forArrayMutator);
  var model = this;
  function push(doc, docSegments, fnCb) {
    var length = doc.push(docSegments, value, fnCb);
    model.emit('insert', segments, [length - 1, [value], model._pass]);
    return length;
  }
  return this._mutate(segments, push, cb);
};

Model.prototype.unshift = function() {
  var subpath, value, cb;
  if (arguments.length === 1) {
    value = arguments[0];
  } else if (arguments.length === 2) {
    subpath = arguments[0];
    value = arguments[1];
  } else {
    subpath = arguments[0];
    value = arguments[1];
    cb = arguments[2];
  }
  var segments = this._splitPath(subpath);
  return this._unshift(segments, value, cb);
};
Model.prototype._unshift = function(segments, value, cb) {
  var forArrayMutator = true;
  segments = this._dereference(segments, forArrayMutator);
  var model = this;
  function unshift(doc, docSegments, fnCb) {
    var length = doc.unshift(docSegments, value, fnCb);
    model.emit('insert', segments, [0, [value], model._pass]);
    return length;
  }
  return this._mutate(segments, unshift, cb);
};

Model.prototype.insert = function() {
  var subpath, index, values, cb;
  if (arguments.length === 1) {
    this.emit('error', new Error('Not enough arguments for insert'));
  } else if (arguments.length === 2) {
    index = arguments[0];
    values = arguments[1];
  } else if (arguments.length === 3) {
    subpath = arguments[0];
    index = arguments[1];
    values = arguments[2];
  } else {
    subpath = arguments[0];
    index = arguments[1];
    values = arguments[2];
    cb = arguments[3];
  }
  var segments = this._splitPath(subpath);
  return this._insert(segments, +index, values, cb);
};
Model.prototype._insert = function(segments, index, values, cb) {
  var forArrayMutator = true;
  segments = this._dereference(segments, forArrayMutator);
  var model = this;
  function insert(doc, docSegments, fnCb) {
    var inserted = (Array.isArray(values)) ? values : [values];
    var length = doc.insert(docSegments, index, inserted, fnCb);
    model.emit('insert', segments, [index, inserted, model._pass]);
    return length;
  }
  return this._mutate(segments, insert, cb);
};

Model.prototype.pop = function() {
  var subpath, cb;
  if (arguments.length === 1) {
    if (typeof arguments[0] === 'function') {
      cb = arguments[0];
    } else {
      subpath = arguments[0];
    }
  } else {
    subpath = arguments[0];
    cb = arguments[1];
  }
  var segments = this._splitPath(subpath);
  return this._pop(segments, cb);
};
Model.prototype._pop = function(segments, cb) {
  var forArrayMutator = true;
  segments = this._dereference(segments, forArrayMutator);
  var model = this;
  function pop(doc, docSegments, fnCb) {
    var arr = doc.get(docSegments);
    var length = arr && arr.length;
    if (!length) {
      fnCb();
      return;
    }
    var value = doc.pop(docSegments, fnCb);
    model.emit('remove', segments, [length - 1, [value], model._pass]);
    return value;
  }
  return this._mutate(segments, pop, cb);
};

Model.prototype.shift = function() {
  var subpath, cb;
  if (arguments.length === 1) {
    if (typeof arguments[0] === 'function') {
      cb = arguments[0];
    } else {
      subpath = arguments[0];
    }
  } else {
    subpath = arguments[0];
    cb = arguments[1];
  }
  var segments = this._splitPath(subpath);
  return this._shift(segments, cb);
};
Model.prototype._shift = function(segments, cb) {
  var forArrayMutator = true;
  segments = this._dereference(segments, forArrayMutator);
  var model = this;
  function shift(doc, docSegments, fnCb) {
    var arr = doc.get(docSegments);
    var length = arr && arr.length;
    if (!length) {
      fnCb();
      return;
    }
    var value = doc.shift(docSegments, fnCb);
    model.emit('remove', segments, [0, [value], model._pass]);
    return value;
  }
  return this._mutate(segments, shift, cb);
};

Model.prototype.remove = function() {
  var subpath, index, howMany, cb;
  if (arguments.length === 1) {
    index = arguments[0];
  } else if (arguments.length === 2) {
    if (typeof arguments[1] === 'function') {
      cb = arguments[1];
      if (typeof arguments[0] === 'number') {
        index = arguments[0];
      } else {
        subpath = arguments[0];
      }
    } else {
      if (typeof arguments[0] === 'number') {
        index = arguments[0];
        howMany = arguments[1];
      } else {
        subpath = arguments[0];
        index = arguments[1];
      }
    }
  } else if (arguments.length === 3) {
    if (typeof arguments[2] === 'function') {
      cb = arguments[2];
      if (typeof arguments[0] === 'number') {
        index = arguments[0];
        howMany = arguments[1];
      } else {
        subpath = arguments[0];
        index = arguments[1];
      }
    } else {
      subpath = arguments[0];
      index = arguments[1];
      howMany = arguments[2];
    }
  } else {
    subpath = arguments[0];
    index = arguments[1];
    howMany = arguments[2];
    cb = arguments[3];
  }
  var segments = this._splitPath(subpath);
  if (index == null) index = segments.pop();
  return this._remove(segments, +index, howMany, cb);
};
Model.prototype._remove = function(segments, index, howMany, cb) {
  var forArrayMutator = true;
  segments = this._dereference(segments, forArrayMutator);
  if (howMany == null) howMany = 1;
  var model = this;
  function remove(doc, docSegments, fnCb) {
    var removed = doc.remove(docSegments, index, howMany, fnCb);
    model.emit('remove', segments, [index, removed, model._pass]);
    return removed;
  }
  return this._mutate(segments, remove, cb);
};

Model.prototype.move = function() {
  var subpath, from, to, howMany, cb;
  if (arguments.length === 1) {
    this.emit('error', new Error('Not enough arguments for move'));
  } else if (arguments.length === 2) {
    from = arguments[0];
    to = arguments[1];
  } else if (arguments.length === 3) {
    if (typeof arguments[2] === 'function') {
      from = arguments[0];
      to = arguments[1];
      cb = arguments[2];
    } else if (typeof arguments[0] === 'number') {
      from = arguments[0];
      to = arguments[1];
      howMany = arguments[2];
    } else {
      subpath = arguments[0];
      from = arguments[1];
      to = arguments[2];
    }
  } else if (arguments.length === 4) {
    if (typeof arguments[3] === 'function') {
      cb = arguments[3];
      if (typeof arguments[0] === 'number') {
        from = arguments[0];
        to = arguments[1];
        howMany = arguments[2];
      } else {
        subpath = arguments[0];
        from = arguments[1];
        to = arguments[2];
      }
    } else {
      subpath = arguments[0];
      from = arguments[1];
      to = arguments[2];
      howMany = arguments[3];
    }
  } else {
    subpath = arguments[0];
    from = arguments[1];
    to = arguments[2];
    howMany = arguments[3];
    cb = arguments[4];
  }
  var segments = this._splitPath(subpath);
  return this._move(segments, from, to, howMany, cb);
};
Model.prototype._move = function(segments, from, to, howMany, cb) {
  var forArrayMutator = true;
  segments = this._dereference(segments, forArrayMutator);
  if (howMany == null) howMany = 1;
  var model = this;
  function move(doc, docSegments, fnCb) {
    // Cast to numbers
    from = +from;
    to = +to;
    // Convert negative indices into positive
    if (from < 0 || to < 0) {
      var len = doc.get(docSegments).length;
      if (from < 0) from += len;
      if (to < 0) to += len;
    }
    var moved = doc.move(docSegments, from, to, howMany, fnCb);
    model.emit('move', segments, [from, to, moved.length, model._pass]);
    return moved;
  }
  return this._mutate(segments, move, cb);
};

Model.prototype.stringInsert = function() {
  var subpath, index, text, cb;
  if (arguments.length === 1) {
    this.emit('error', new Error('Not enough arguments for stringInsert'));
  } else if (arguments.length === 2) {
    index = arguments[0];
    text = arguments[1];
  } else if (arguments.length === 3) {
    if (typeof arguments[2] === 'function') {
      index = arguments[0];
      text = arguments[1];
      cb = arguments[2];
    } else {
      subpath = arguments[0];
      index = arguments[1];
      text = arguments[2];
    }
  } else {
    subpath = arguments[0];
    index = arguments[1];
    text = arguments[2];
    cb = arguments[3];
  }
  var segments = this._splitPath(subpath);
  return this._stringInsert(segments, index, text, cb);
};
Model.prototype._stringInsert = function(segments, index, text, cb) {
  segments = this._dereference(segments);
  var model = this;
  function stringInsert(doc, docSegments, fnCb) {
    var previous = doc.stringInsert(docSegments, index, text, fnCb);
    model.emit('stringInsert', segments, [index, text, model._pass]);
    var value = doc.get(docSegments);
    var pass = model.pass({$original: 'stringInsert'})._pass;
    model.emit('change', segments, [value, previous, pass]);
    return;
  }
  return this._mutate(segments, stringInsert, cb);
};

Model.prototype.stringRemove = function() {
  var subpath, index, howMany, cb;
  if (arguments.length === 1) {
    this.emit('error', new Error('Not enough arguments for stringRemove'));
  } else if (arguments.length === 2) {
    index = arguments[0];
    howMany = arguments[1];
  } else if (arguments.length === 3) {
    if (typeof arguments[2] === 'function') {
      index = arguments[0];
      howMany = arguments[1];
      cb = arguments[2];
    } else {
      subpath = arguments[0];
      index = arguments[1];
      howMany = arguments[2];
    }
  } else {
    subpath = arguments[0];
    index = arguments[1];
    howMany = arguments[2];
    cb = arguments[3];
  }
  var segments = this._splitPath(subpath);
  return this._stringRemove(segments, index, howMany, cb);
};
Model.prototype._stringRemove = function(segments, index, howMany, cb) {
  segments = this._dereference(segments);
  var model = this;
  function stringRemove(doc, docSegments, fnCb) {
    var previous = doc.stringRemove(docSegments, index, howMany, fnCb);
    model.emit('stringRemove', segments, [index, howMany, model._pass]);
    var value = doc.get(docSegments);
    var pass = model.pass({$original: 'stringRemove'})._pass;
    model.emit('change', segments, [value, previous, pass]);
    return;
  }
  return this._mutate(segments, stringRemove, cb);
};

},{"../util":14,"./Model":31}],38:[function(require,module,exports){
(function(process){var util = require('../util');
var Model = require('./Model');
var Query = require('./Query');

Model.INITS.push(function(model, options) {
  model.root.fetchOnly = options.fetchOnly;
  model.root.unloadDelay = options.unloadDelay || 1000;

  // Keeps track of the count of fetches (that haven't been undone by an
  // unfetch) per doc. Maps doc id to the fetch count.
  model.root._fetchedDocs = new FetchedDocs;

  // Keeps track of the count of subscribes (that haven't been undone by an
  // unsubscribe) per doc. Maps doc id to the subscribe count.
  model.root._subscribedDocs = new SubscribedDocs;

  // Maps doc path to doc version
  model.root._loadVersions = new LoadVersions;
});

function FetchedDocs() {}
function SubscribedDocs() {}
function LoadVersions() {}

Model.prototype.fetch = function() {
  this._forSubscribable(arguments, 'fetch');
  return this;
};
Model.prototype.unfetch = function() {
  this._forSubscribable(arguments, 'unfetch');
  return this;
};
Model.prototype.subscribe = function() {
  this._forSubscribable(arguments, 'subscribe');
  return this;
};
Model.prototype.unsubscribe = function() {
  this._forSubscribable(arguments, 'unsubscribe');
  return this;
};

/**
 * @private
 * @param {Arguments} argumentsObject can take 1 of two forms
 *   1. [[subscribableObjects...], cb]
 *   2. [subscribableObjects..., cb]
 * @param {String} method can be 'fetch', 'unfetch', 'subscribe', 'unsubscribe'
 */
Model.prototype._forSubscribable = function(argumentsObject, method) {
  if (Array.isArray(argumentsObject[0])) {
    var args = argumentsObject[0];
    var cb = argumentsObject[1] || this.root._defaultCallback;
  } else {
    var args = Array.prototype.slice.call(argumentsObject);
    var last = args[args.length - 1];
    var cb = (typeof last === 'function') ? args.pop() : this.root._defaultCallback;
  }
  // If no queries or paths are passed in, try to use this model's scope
  if (!args.length) args.push(null);
  var group = util.asyncGroup(cb);
  var docMethod = method + 'Doc';

  var finished = group();
  for (var i = 0; i < args.length; i++) {
    var item = args[i];
    if (item instanceof Query) {
      item[method](group());
    } else {
      var segments = this._dereference(this._splitPath(item));
      if (segments.length === 2) {
        // Do the appropriate method for a single document.
        this[docMethod](segments[0], segments[1], group());
      } else if (segments.length === 1) {
        // Make a query to an entire collection.
        var query = this.query(segments[0], {});
        query[method](group());
      } else if (segments.length === 0) {
        cb(new Error('No path specified for ' + method));
      } else {
        cb(new Error('Cannot ' + method + ' to a path within a document: ' +
            segments.join('.')));
      }
    }
  }
  finished();
};

/**
 * @param {String}
 * @param {String} id
 * @param {Function} cb(err)
 * @param {Boolean} alreadyLoaded
 */
Model.prototype.fetchDoc = function(collectionName, id, cb, alreadyLoaded) {
  if (!cb) cb = this.root._defaultCallback;

  // Maintain a count of fetches so that we can unload the document when
  // there are no remaining fetches or subscribes for that document
  var path = collectionName + '.' + id;
  this.emit('fetchDoc', path, this._context, this._pass);
  this.root._fetchedDocs[path] = (this.root._fetchedDocs[path] || 0) + 1;

  var model = this;
  var doc = this.getOrCreateDoc(collectionName, id);
  if (alreadyLoaded) {
    process.nextTick(fetchDocCallback);
  } else {
    doc.shareDoc.fetch(fetchDocCallback);
  }
  function fetchDocCallback(err) {
    if (err) return cb(err);
    if (doc.shareDoc.version !== model.root._loadVersions[path]) {
      model.root._loadVersions[path] = doc.shareDoc.version;
      doc._updateCollectionData();
      model.emit('load', [collectionName, id], [doc.get(), model._pass]);
    }
    cb();
  }
};

/**
 * @param {String} collectionName
 * @param {String} id of the document we want to subscribe to
 * @param {Function} cb(err)
 */
Model.prototype.subscribeDoc = function(collectionName, id, cb) {
  if (!cb) cb = this.root._defaultCallback;

  var path = collectionName + '.' + id;
  this.emit('subscribeDoc', path, this._context, this._pass);
  var count = this.root._subscribedDocs[path] = (this.root._subscribedDocs[path] || 0) + 1;
  // Already requested a subscribe, so just return
  if (count > 1) return cb();

  // Subscribe if currently unsubscribed
  var model = this;
  var doc = this.getOrCreateDoc(collectionName, id);
  if (this.root.fetchOnly) {
    // Only fetch if the document isn't already loaded
    if (doc.get() === void 0) {
      doc.shareDoc.fetch(subscribeDocCallback);
    } else {
      process.nextTick(subscribeDocCallback);
    }
  } else {
    doc.shareDoc.subscribe(subscribeDocCallback);
  }
  function subscribeDocCallback(err) {
    if (err) return cb(err);
    if (!doc.createdLocally && doc.shareDoc.version !== model.root._loadVersions[path]) {
      model.root._loadVersions[path] = doc.shareDoc.version;
      doc._updateCollectionData();
      model.emit('load', [collectionName, id], [doc.get(), model._pass]);
    }
    cb();
  }
};

Model.prototype.unfetchDoc = function(collectionName, id, cb) {
  if (!cb) cb = this.root._defaultCallback;
  var path = collectionName + '.' + id;
  this.emit('unfetchDoc', path, this._context, this._pass);
  var fetchedDocs = this.root._fetchedDocs;

  // No effect if the document has no fetch count
  if (!fetchedDocs[path]) return cb();

  var model = this;
  if (this.root.unloadDelay && !this._pass.$query) {
    setTimeout(finishUnfetchDoc, this.root.unloadDelay);
  } else {
    finishUnfetchDoc();
  }
  function finishUnfetchDoc() {
    var count = --fetchedDocs[path];
    if (count) return cb(null, count);
    delete fetchedDocs[path];
    model._maybeUnloadDoc(collectionName, id, path);
    cb(null, 0);
  }
};

Model.prototype.unsubscribeDoc = function(collectionName, id, cb) {
  if (!cb) cb = this.root._defaultCallback;
  var path = collectionName + '.' + id;
  this.emit('unsubscribeDoc', path, this._context, this._pass);
  var subscribedDocs = this.root._subscribedDocs;

  // No effect if the document is not currently subscribed
  if (!subscribedDocs[path]) return cb();

  var model = this;
  if (this.root.unloadDelay && !this._pass.$query) {
    setTimeout(finishUnsubscribeDoc, this.root.unloadDelay);
  } else {
    finishUnsubscribeDoc();
  }
  function finishUnsubscribeDoc() {
    var count = --subscribedDocs[path];
    // If there are more remaining subscriptions, only decrement the count
    // and callback with how many subscriptions are remaining
    if (count) return cb(null, count);

    // If there is only one remaining subscription, actually unsubscribe
    delete subscribedDocs[path];
    if (model.root.fetchOnly) {
      unsubscribeDocCallback();
    } else {
      var shareDoc = model.root.shareConnection.get(collectionName, id);
      if (!shareDoc) {
        return cb(new Error('Share document not found for: ' + path));
      }
      shareDoc.unsubscribe(unsubscribeDocCallback);
    }
  }
  function unsubscribeDocCallback(err) {
    model._maybeUnloadDoc(collectionName, id, path);
    if (err) return cb(err);
    cb(null, 0);
  }
};

/**
 * Removes the document from the local model if the model no longer has any
 * remaining fetches or subscribes on path.
 * Called from Model.prototype.unfetchDoc and Model.prototype.unsubscribeDoc as
 * part of attempted cleanup.
 * @param {String} collectionName
 * @param {String} id
 * @param {String} path
 */
Model.prototype._maybeUnloadDoc = function(collectionName, id, path) {
  var doc = this.getDoc(collectionName, id);
  if (!doc) return;
  // Remove the document from the local model if it no longer has any
  // remaining fetches or subscribes
  if (this.root._fetchedDocs[path] || this.root._subscribedDocs[path]) return;
  var previous = doc.get();
  this.root.collections[collectionName].remove(id);
  if (doc.shareDoc) doc.shareDoc.destroy();
  delete this.root._loadVersions[path];
  this.emit('unload', [collectionName, id], [previous, this._pass]);
};

})(require("__browserify_process"))
},{"../util":14,"./Model":31,"./Query":39,"__browserify_process":11}],40:[function(require,module,exports){
/**
 * Contexts are useful for keeping track of the origin of subscribes.
 */

var Model = require('./Model');
var Query = require('./Query');

Model.INITS.push(function(model) {
  model.root._contexts = new Contexts;
  model.setContext('root');
  [ 'fetchDoc', 'subscribeDoc', 'unfetchDoc', 'unsubscribeDoc'
  , 'fetchQuery', 'subscribeQuery', 'unfetchQuery', 'unsubscribeQuery'
  ].forEach(function(event) {
    model.on(event, function(item, context, pass) {
      context[event](item, pass);
    });
  });
});

Model.prototype.context = function(id) {
  var model = this._child();
  model.setContext(id);
  return model;
};

Model.prototype.setContext = function(id) {
  var context = this.root._contexts[id] || new Context(this, id);
  this._context = this.root._contexts[id] = context;
  return context;
};

Model.prototype.unload = function(id) {
  var context = (id) ? this.root._contexts[id] : this._context;
  context.unload();
};

function Contexts() {}

function FetchedDocs() {}
function SubscribedDocs() {}
function FetchedQueries() {}
function SubscribedQueries() {}

function Context(model, id) {
  this.model = model;
  this.id = id;
  this.fetchedDocs = new FetchedDocs;
  this.subscribedDocs = new SubscribedDocs;
  this.fetchedQueries = new FetchedQueries;
  this.subscribedQueries = new SubscribedQueries;
}

Context.prototype.toJSON = function() {
  return {
    fetchedDocs: this.fetchedDocs
  , subscribedDocs: this.subscribedDocs
  , fetchedQueries: this.fetchedQueries
  , subscribedQueries: this.subscribedQueries
  };
};

Context.prototype.fetchDoc = function(path, pass) {
  if (pass.$query) return;
  mapIncrement(this.fetchedDocs, path);
};
Context.prototype.subscribeDoc = function(path, pass) {
  if (pass.$query) return;
  mapIncrement(this.subscribedDocs, path);
};
Context.prototype.unfetchDoc = function(path, pass) {
  if (pass.$query) return;
  mapDecrement(this.fetchedDocs, path);
};
Context.prototype.unsubscribeDoc = function(path, pass) {
  if (pass.$query) return;
  mapDecrement(this.subscribedDocs, path);
};
Context.prototype.fetchQuery = function(query) {
  mapIncrement(this.fetchedQueries, query.hash);
};
Context.prototype.subscribeQuery = function(query) {
  mapIncrement(this.subscribedQueries, query.hash);
};
Context.prototype.unfetchQuery = function(query) {
  mapDecrement(this.fetchedQueries, query.hash);
};
Context.prototype.unsubscribeQuery = function(query) {
  mapDecrement(this.subscribedQueries, query.hash);
};
function mapIncrement(map, key) {
  map[key] = (map[key] || 0) + 1;
}
function mapDecrement(map, key) {
  map[key] && map[key]--;
  if (!map[key]) delete map[key];
}

Context.prototype.unload = function() {
  var model = this.model;
  for (var hash in this.fetchedQueries) {
    var query = model.root._queries.map[hash];
    if (!query) continue;
    var count = this.fetchedQueries[hash];
    while (count--) query.unfetch(null);
  }
  for (var hash in this.subscribedQueries) {
    var query = model.root._queries.map[hash];
    if (!query) continue;
    var count = this.subscribedQueries[hash];
    while (count--) query.unsubscribe(null);
  }
  for (var path in this.fetchedDocs) {
    var segments = path.split('.');
    var count = this.fetchedDocs[path];
    while (count--) model.unfetchDoc(segments[0], segments[1]);
  }
  for (var path in this.subscribedDocs) {
    var segments = path.split('.');
    var count = this.subscribedDocs[path];
    while (count--) model.unsubscribeDoc(segments[0], segments[1]);
  }
  model._context = model.root._contexts[this.id] = new Context(model, this.id);
};

},{"./Model":31,"./Query":39}],41:[function(require,module,exports){
var util = require('../util');
var Model = require('./Model');
var defaultFns = require('./defaultFns');

function NamedFns() {}

Model.INITS.push(function(model) {
  model.root._namedFns = new NamedFns();
  model.root._fns = new Fns(model);
  model.on('all', fnListener);
  function fnListener(segments, eventArgs) {
    var pass = eventArgs[eventArgs.length - 1];
    var map = model.root._fns.fromMap;
    for (var path in map) {
      var fn = map[path];
      if (pass.$fn === fn) continue;
      if (util.mayImpactAny(fn.inputsSegments, segments)) {
        // Mutation affecting input path
        fn.onInput(pass);
      } else if (util.mayImpact(fn.fromSegments, segments)) {
        // Mutation affecting output path
        fn.onOutput(pass);
      }
    }
  }
});

Model.prototype.fn = function(name, fns) {
  this.root._namedFns[name] = fns;
};

function parseStartArguments(model, args, hasPath) {
  if (typeof args[0] === 'function') {
    var fns = args[0];
  } else {
    var name = args[0];
  }
  if (hasPath) {
    var path = model.path(args[1]);
    var inputPaths = Array.prototype.slice.call(args, 2);
  } else {
    var inputPaths = Array.prototype.slice.call(args, 1);
  }
  var i = inputPaths.length - 1;
  if (model.isPath(inputPaths[i])) {
    inputPaths[i] = model.path(inputPaths[i]);
  } else {
    var options = inputPaths.pop();
  }
  while (i--) {
    inputPaths[i] = model.path(inputPaths[i]);
  }
  return {
    name: name
  , path: path
  , inputPaths: inputPaths
  , fns: fns
  , options: options
  };
}

Model.prototype.evaluate = function(name) {
  var args = parseStartArguments(this, arguments, false);
  return this.root._fns.get(args.name, args.inputPaths, args.fns, args.options);
};

Model.prototype.start = function(name, subpath) {
  var args = parseStartArguments(this, arguments, true);
  return this.root._fns.start(args.name, args.path, args.inputPaths, args.fns, args.options);
};

Model.prototype.stop = function(subpath) {
  var path = this.path(subpath);
  this.root._fns.stop(path);
};

Model.prototype.stopAll = function(subpath) {
  var segments = this._splitPath(subpath);
  var fns = this.root._fns.fromMap;
  for (var from in fns) {
    if (util.contains(segments, fns[from].fromSegments)) {
      this.stop(from);
    }
  }
};

function FromMap() {}
function Fns(model) {
  this.model = model;
  this.nameMap = model.root._namedFns;
  this.fromMap = new FromMap;
}

Fns.prototype.get = function(name, inputPaths, fns, options) {
  fns || (fns = this.nameMap[name] || defaultFns[name]);
  var fn = new Fn(this.model, name, null, inputPaths, fns, options);
  return fn.get();
};

Fns.prototype.start = function(name, path, inputPaths, fns, options) {
  fns || (fns = this.nameMap[name] || defaultFns[name]);
  var fn = new Fn(this.model, name, path, inputPaths, fns, options);
  this.fromMap[path] = fn;
  return fn.onInput();
};

Fns.prototype.stop = function(path) {
  var fn = this.fromMap[path];
  delete this.fromMap[path];
  return fn;
};

Fns.prototype.toJSON = function() {
  var out = [];
  for (var from in this.fromMap) {
    var fn = this.fromMap[from];
    // Don't try to bundle non-named functions that were started via
    // model.start directly instead of by name
    if (!fn.name) continue;
    out.push([fn.name, fn.from].concat(fn.inputPaths));
  }
  return out;
};

function Fn(model, name, from, inputPaths, fns, options) {
  this.model = model.pass({$fn: this});
  this.name = name;
  this.from = from;
  this.inputPaths = inputPaths;
  if (!fns) {
    var err = new TypeError('Model function not found: ' + name);
    model.emit('error', err);
  }
  this.getFn = fns.get || fns;
  this.setFn = fns.set;
  this.fromSegments = from && from.split('.');
  this.inputsSegments = [];
  for (var i = 0; i < this.inputPaths.length; i++) {
    var segments = this.inputPaths[i].split('.');
    this.inputsSegments.push(segments);
  }
  var copy = (options && options.copy) || 'output';
  this.copyInput = (copy === 'input' || copy === 'both');
  this.copyOutput = (copy === 'output' || copy === 'both');
}

Fn.prototype.apply = function(fn, inputs) {
  for (var i = 0, len = this.inputsSegments.length; i < len; i++) {
    var input = this.model._get(this.inputsSegments[i]);
    inputs.push(this.copyInput ? util.deepCopy(input) : input);
  }
  return fn.apply(this.model, inputs);
};

Fn.prototype.get = function() {
  return this.apply(this.getFn, []);
};

var diffOptions = {equal: util.deepEqual};
var eachDiffOptions = {each: true, equal: util.deepEqual};

Fn.prototype.set = function(value, pass) {
  if (!this.setFn) return;
  var out = this.apply(this.setFn, [value]);
  if (!out) return;
  var inputsSegments = this.inputsSegments;
  var model = this.model.pass(pass, true);
  for (var key in out) {
    if (key === 'each') {
      var each = out[key];
      for (key in each) {
        var value = (this.copyOutput) ? util.deepCopy(each[key]) : each[key];
        model._setDiff(inputsSegments[key], value, eachDiffOptions);
      }
      continue;
    }
    var value = (this.copyOutput) ? util.deepCopy(out[key]) : out[key];
    model._setDiff(inputsSegments[key], value, diffOptions);
  }
};

Fn.prototype.onInput = function(pass) {
  var value = (this.copyOutput) ? util.deepCopy(this.get()) : this.get();
  this.model.pass(pass, true)._setDiff(this.fromSegments, value, diffOptions);
  return value;
};

Fn.prototype.onOutput = function(pass) {
  var value = this.model._get(this.fromSegments);
  return this.set(value, pass);
};

},{"../util":14,"./Model":31,"./defaultFns":57}],42:[function(require,module,exports){
var util = require('../util');
var Model = require('./Model');
var defaultFns = require('./defaultFns');

Model.INITS.push(function(model) {
  model.root._filters = new Filters(model);
  model.on('all', filterListener);
  function filterListener(segments, eventArgs) {
    var pass = eventArgs[eventArgs.length - 1];
    var map = model.root._filters.fromMap;
    for (var path in map) {
      var filter = map[path];
      if (pass.$filter === filter) continue;
      if (util.mayImpact(filter.inputSegments, segments)) {
        filter.update(pass);
      }
    }
  }
});

Model.prototype.filter = function(input, fn) {
  var inputPath = this.path(input);
  return this.root._filters.add(inputPath, fn);
};

Model.prototype.sort = function(input, fn) {
  var inputPath = this.path(input);
  return this.root._filters.add(inputPath, null, fn || 'asc');
};

Model.prototype.removeAllFilters = function(subpath) {
  var segments = this._splitPath(subpath);
  var filters = this.root._filters.fromMap;
  for (var from in filters) {
    if (util.contains(segments, filters[from].fromSegments)) {
      filters[from].destroy();
    }
  }
};

function FromMap() {}
function Filters(model) {
  this.model = model;
  this.fromMap = new FromMap;
}

Filters.prototype.add = function(inputPath, filterFn, sortFn) {
  return new Filter(this, inputPath, filterFn, sortFn);
};

Filters.prototype.toJSON = function() {
  var out = [];
  for (var from in this.fromMap) {
    var filter = this.fromMap[from];
    // Don't try to bundle if functions were passed directly instead of by name
    if (!filter.bundle) continue;
    out.push([filter.inputPath, filter.filterName, filter.sortName, from]);
  }
  return out;
};

function Filter(filters, inputPath, filterFn, sortFn) {
  this.filters = filters;
  this.model = filters.model.pass({$filter: this});
  this.inputPath = inputPath;
  this.inputSegments = inputPath.split('.');
  this.filterName = null;
  this.sortName = null;
  this.bundle = true;
  this.filterFn = null;
  this.sortFn = null;
  if (filterFn) this.filter(filterFn);
  if (sortFn) this.sort(sortFn);
  this.idsSegments = null;
  this.from = null;
  this.fromSegments = null;
}

Filter.prototype.filter = function(fn) {
  if (typeof fn === 'function') {
    this.filterFn = fn;
    this.bundle = false;
    return this;
  }
  if (typeof fn === 'string') {
    this.filterName = fn;
    this.filterFn = this.model.root._namedFns[fn] || defaultFns[fn];
    if (!this.filterFn) {
      var err = new TypeError('Filter function not found: ' + fn);
      this.model.emit('error', err);
    }
  }
  return this;
};

Filter.prototype.sort = function(fn) {
  if (!fn) fn = 'asc';
  if (typeof fn === 'function') {
    this.sortFn = fn;
    this.bundle = false;
    return this;
  }
  if (typeof fn === 'string') {
    this.sortName = fn;
    this.sortFn = this.model.root._namedFns[fn] || defaultFns[fn];
    if (!this.sortFn) {
      var err = new TypeError('Sort function not found: ' + fn);
      this.model.emit('error', err);
    }
  }
  return this;
};

Filter.prototype.ids = function() {
  var items = this.model._get(this.inputSegments);
  var ids = [];
  if (!items) return ids;
  if (Array.isArray(items)) {
    if (this.filterFn) {
      for (var i = 0; i < items.length; i++) {
        if (this.filterFn.call(this.model, items[i], i, items)) {
          ids.push(i);
        }
      }
    } else {
      for (var i = 0; i < items.length; i++) ids.push(i);
    }
  } else {
    if (this.filterFn) {
      for (var key in items) {
        if (items.hasOwnProperty(key) &&
          this.filterFn.call(this.model, items[key], key, items)
        ) {
          ids.push(key);
        }
      }
    } else {
      ids = Object.keys(items);
    }
  }
  var sortFn = this.sortFn;
  if (sortFn) {
    ids.sort(function(a, b) {
      return sortFn(items[a], items[b]);
    });
  }
  return ids;
};

Filter.prototype.get = function() {
  var items = this.model._get(this.inputSegments);
  var results = [];
  if (Array.isArray(items)) {
    if (this.filterFn) {
      for (var i = 0; i < items.length; i++) {
        if (this.filterFn.call(this.model, items[i], i, items)) {
          results.push(items[i]);
        }
      }
    } else {
      results = items.slice();
    }
  } else {
    if (this.filterFn) {
      for (var key in items) {
        if (items.hasOwnProperty(key) &&
          this.filterFn.call(this.model, items[key], key, items)
        ) {
          results.push(items[key]);
        }
      }
    } else {
      for (var key in items) {
        if (items.hasOwnProperty(key)) {
          results.push(items[key]);
        }
      }
    }
  }
  if (this.sortFn) results.sort(this.sortFn);
  return results;
};

Filter.prototype.update = function(pass) {
  var ids = this.ids();
  this.model.pass(pass, true)._setDiff(this.idsSegments, ids);
};

Filter.prototype.ref = function(from) {
  from = this.model.path(from);
  this.from = from;
  this.fromSegments = from.split('.');
  this.filters.fromMap[from] = this;
  this.idsSegments = ['$filters', from.replace(/\./g, '|')];
  this.update();
  return this.model.refList(from, this.inputPath, this.idsSegments.join('.'));
};

Filter.prototype.destroy = function() {
  delete this.filters.fromMap[this.from];
  this.model.removeRefList(this.from);
  this.model._del(this.idsSegments);
};

},{"../util":14,"./Model":31,"./defaultFns":57}],43:[function(require,module,exports){
var util = require('../util');
var Model = require('./Model');

Model.INITS.push(function(model) {
  var root = model.root;
  root._refLists = new RefLists(root);
  for (var type in Model.MUTATOR_EVENTS) {
    addListener(root, type);
  }
});

function addListener(model, type) {
  model.on(type, refListListener);
  function refListListener(segments, eventArgs) {
    var pass = eventArgs[eventArgs.length - 1];
    // Check for updates on or underneath paths
    var fromMap = model._refLists.fromMap;
    for (var from in fromMap) {
      var refList = fromMap[from];
      if (pass.$refList === refList) continue;
      refList.onMutation(type, segments, eventArgs);
    }
  }
}

/**
 * @param {String} type
 * @param {Array} segments
 * @param {Array} eventArgs
 * @param {RefList} refList
 */
function patchFromEvent(type, segments, eventArgs, refList) {
  var fromLength = refList.fromSegments.length;
  var segmentsLength = segments.length;
  var pass = eventArgs[eventArgs.length - 1];
  var model = refList.model.pass(pass, true);

  // Mutation on the `from` output itself
  if (segmentsLength === fromLength) {
    if (type === 'insert') {
      var index = eventArgs[0];
      var values = eventArgs[1];
      var ids = setNewToValues(model, refList, values);
      model._insert(refList.idsSegments, index, ids);
      return;
    }

    if (type === 'remove') {
      var index = eventArgs[0];
      var howMany = eventArgs[1].length;
      var ids = model._remove(refList.idsSegments, index, howMany);
      // Delete the appropriate items underneath `to` if the `deleteRemoved`
      // option was set true
      if (refList.deleteRemoved) {
        for (var i = 0; i < ids.length; i++) {
          var item = refList.itemById(ids[i]);
          model._del(refList.toSegmentsByItem(item));
        }
      }
      return;
    }

    if (type === 'move') {
      var from = eventArgs[0];
      var to = eventArgs[1];
      var howMany = eventArgs[2];
      model._move(refList.idsSegments, from, to, howMany);
      return;
    }

    // Change of the entire output
    var values = (type === 'change') ?
      eventArgs[0] : model._get(refList.fromSegments);
    // Set ids to empty list if output is set to null
    if (!values) {
      model._set(refList.idsSegments, []);
      return;
    }
    // If the entire output is set, create a list of ids based on the output,
    // and update the corresponding items
    var ids = setNewToValues(model, refList, values);
    model._set(refList.idsSegments, ids);
    return;
  }

  // If mutation is on a parent of `from`, we might need to re-create the
  // entire refList output
  if (segmentsLength < fromLength) {
    model._setArrayDiff(refList.fromSegments, refList.get());
    return;
  }

  var index = segments[fromLength];
  var value = model._get(refList.fromSegments.concat(index));
  var toSegments = refList.toSegmentsByItem(value);

  // Mutation underneath a child of the `from` object.
  if (segmentsLength > fromLength + 1) {
    var message = 'Mutation on descendant of refList `from` should have been dereferenced: ' + segments.join('.');
    model.emit('error', new Error(message));
    return;
  }

  // Otherwise, mutation of a child of the `from` object

  // If changing the item itself, it will also have to be re-set on the
  // original object
  if (type === 'change') {
    model._set(toSegments, value);
    updateIdForValue(model, refList, index, value);
    return;
  }
  // The same goes for string mutations, since strings are immutable
  if (type === 'stringInsert') {
    var stringIndex = eventArgs[0];
    var stringValue = eventArgs[1];
    model._stringInsert(toSegments, stringIndex, stringValue);
    updateIdForValue(model, refList, index, value);
    return;
  }
  if (type === 'stringRemove') {
    var stringIndex = eventArgs[0];
    var howMany = eventArgs[1];
    model._stringRemove(toSegments, stringIndex, howMany);
    updateIdForValue(model, refList, index, value);
    return;
  }
  if (type === 'insert' || type === 'remove' || type === 'move') {
    var message = 'Array mutation on child of refList `from` should have been dereferenced: ' + segments.join('.');
    model.emit('error', new Error(message));
    return;
  }
}

/**
 * @private
 * @param {Model} model
 * @param {RefList} refList
 * @param {Array} values
 */
function setNewToValues(model, refList, values, fn) {
  var ids = [];
  for (var i = 0; i < values.length; i++) {
    var value = values[i];
    var id = refList.idByItem(value);
    if (id === void 0 && typeof value === 'object') {
      id = value.id = model.id();
    }
    var toSegments = refList.toSegmentsByItem(value);
    if (id === void 0 || toSegments === void 0) {
      var message = 'Unable to add item to refList: ' + value;
      return model.emit('error', new Error(message));
    }
    if (model._get(toSegments) !== value) {
      model._set(toSegments, value);
    }
    ids.push(id);
  }
  return ids;
}
function updateIdForValue(model, refList, index, value) {
  var id = refList.idByItem(value);
  var outSegments = refList.idsSegments.concat(index);
  model._set(outSegments, id);
}

function patchToEvent(type, segments, eventArgs, refList) {
  var toLength = refList.toSegments.length;
  var segmentsLength = segments.length;
  var pass = eventArgs[eventArgs.length - 1];
  var model = refList.model.pass(pass, true);

  // Mutation on the `to` object itself
  if (segmentsLength === toLength) {
    if (type === 'insert') {
      var insertIndex = eventArgs[0];
      var values = eventArgs[1];
      for (var i = 0; i < values.length; i++) {
        var value = values[i];
        var indices = refList.indicesByItem(value);
        if (!indices) continue;
        for (var j = 0; j < indices.length; j++) {
          var outSegments = refList.fromSegments.concat(indices[j]);
          model._set(outSegments, value);
        }
      }
      return;
    }

    if (type === 'remove') {
      var removeIndex = eventArgs[0];
      var values = eventArgs[1];
      var howMany = values.length;
      for (var i = removeIndex, len = removeIndex + howMany; i < len; i++) {
        var indices = refList.indicesByItem(values[i]);
        if (!indices) continue;
        for (var j = 0, indicesLen = indices.length; j < indicesLen; j++) {
          var outSegments = refList.fromSegments.concat(indices[j]);
          model._set(outSegments, void 0);
        }
      }
      return;
    }

    if (type === 'move') {
      // Moving items in the `to` object should have no effect on the output
      return;
    }
  }

  // Mutation on or above the `to` object
  if (segmentsLength <= toLength) {
    // If the entire `to` object is updated, we need to re-create the
    // entire refList output and apply what is different
    model._setArrayDiff(refList.fromSegments, refList.get());
    return;
  }

  // Mutation underneath a child of the `to` object. The item will already
  // be up to date, since it is under an object reference. Just re-emit
  if (segmentsLength > toLength + 1) {
    var value = model._get(segments.slice(0, toLength + 1));
    var indices = refList.indicesByItem(value);
    if (!indices) return;
    var remaining = segments.slice(toLength + 1);
    for (var i = 0; i < indices.length; i++) {
      var index = indices[i];
      var dereferenced = refList.fromSegments.concat(index, remaining);
      dereferenced = model._dereference(dereferenced, null, refList);
      eventArgs = eventArgs.slice();
      eventArgs[eventArgs.length - 1] = model._pass;
      model.emit(type, dereferenced, eventArgs);
    }
    return;
  }

  // Otherwise, mutation of a child of the `to` object

  // If changing the item itself, it will also have to be re-set on the
  // array created by the refList
  if (type === 'change' || type === 'load' || type === 'unload') {
    var value, previous;
    if (type === 'change') {
      value = eventArgs[0];
      previous = eventArgs[1];
    } else if (type === 'load') {
      value = eventArgs[0];
      previous = void 0;
    } else if (type === 'unload') {
      value = void 0;
      previous = eventArgs[0];
    }
    var newIndices = refList.indicesByItem(value);
    var oldIndices = refList.indicesByItem(previous);
    if (!newIndices && !oldIndices) return;
    if (oldIndices && !equivalentArrays(oldIndices, newIndices)) {
      // The changed item used to refer to some indices, but no longer does
      for (var i = 0; i < oldIndices.length; i++) {
        var outSegments = refList.fromSegments.concat(oldIndices[i]);
        model._set(outSegments, void 0);
      }
    }
    if (newIndices) {
      for (var i = 0; i < newIndices.length; i++) {
        var outSegments = refList.fromSegments.concat(newIndices[i]);
        model._set(outSegments, value);
      }
    }
    return;
  }

  var value = model._get(segments.slice(0, toLength + 1));
  var indices = refList.indicesByItem(value);
  if (!indices) return;

  // The same goes for string mutations, since strings are immutable
  if (type === 'stringInsert') {
    var stringIndex = eventArgs[0];
    var value = eventArgs[1];
    for (var i = 0; i < indices.length; i++) {
      var outSegments = refList.fromSegments(indices[i]);
      model._stringInsert(outSegments, stringIndex, value);
    }
    return;
  }
  if (type === 'stringRemove') {
    var stringIndex = eventArgs[0];
    var howMany = eventArgs[1];
    for (var i = 0; i < indices.length; i++) {
      var outSegments = refList.fromSegments(indices[i]);
      model._stringRemove(outSegments, stringIndex, howMany);
    }
    return;
  }
  if (type === 'insert' || type === 'remove' || type === 'move') {
    // Array mutations will have already been updated via an object
    // reference, so only re-emit
    for (var i = 0; i < indices.length; i++) {
      var dereferenced = refList.fromSegments.concat(indices[i]);
      dereferenced = model._dereference(dereferenced, null, refList);
      eventArgs = eventArgs.slice();
      eventArgs[eventArgs.length - 1] = model._pass;
      model.emit(type, dereferenced, eventArgs);
    }
  }
}
function equivalentArrays(a, b) {
  if (!a || !b) return false;
  if (a.length !== b.length) return false;
  for (var i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}

function patchIdsEvent(type, segments, eventArgs, refList) {
  var idsLength = refList.idsSegments.length;
  var segmentsLength = segments.length;
  var pass = eventArgs[eventArgs.length - 1];
  var model = refList.model.pass(pass, true);

  // An array mutation of the ids should be mirrored with a like change in
  // the output array
  if (segmentsLength === idsLength) {
    if (type === 'insert') {
      var index = eventArgs[0];
      var inserted = eventArgs[1];
      var values = [];
      for (var i = 0; i < inserted.length; i++) {
        var value = refList.itemById(inserted[i]);
        values.push(value);
      }
      model._insert(refList.fromSegments, index, values);
      return;
    }

    if (type === 'remove') {
      var index = eventArgs[0];
      var howMany = eventArgs[1].length;
      model._remove(refList.fromSegments, index, howMany);
      return;
    }

    if (type === 'move') {
      var from = eventArgs[0];
      var to = eventArgs[1];
      var howMany = eventArgs[2];
      model._move(refList.fromSegments, from, to, howMany);
      return;
    }
  }

  // Mutation on the `ids` list itself
  if (segmentsLength <= idsLength) {
    // If the entire `ids` array is updated, we need to re-create the
    // entire refList output and apply what is different
    model._setArrayDiff(refList.fromSegments, refList.get());
    return;
  }

  // Otherwise, direct mutation of a child in the `ids` object or mutation
  // underneath an item in the `ids` list. Update the item for the appropriate
  // id if it has changed
  var index = segments[idsLength];
  var id = refList.idByIndex(index);
  var item = refList.itemById(id);
  var itemSegments = refList.fromSegments.concat(index);
  if (model._get(itemSegments) !== item) {
    model._set(itemSegments, item);
  }
}

Model.prototype.refList = function() {
  var from, to, ids, options;
  if (arguments.length === 2) {
    to = arguments[0];
    ids = arguments[1];
  } else if (arguments.length === 3) {
    if (this.isPath(arguments[2])) {
      from = arguments[0];
      to = arguments[1];
      ids = arguments[2];
    } else {
      to = arguments[0];
      ids = arguments[1];
      options = arguments[2];
    }
  } else {
    from = arguments[0];
    to = arguments[1];
    ids = arguments[2];
    options = arguments[3];
  }
  var fromPath = this.path(from);
  if (Array.isArray(to)) {
    var toPath = [];
    for (var i = 0; i < to.length; i++) {
      toPath.push(this.path(to[i]));
    }
  } else {
    var toPath = this.path(to);
  }
  var idsPath = this.path(ids);
  var refList = this.root._refLists.add(fromPath, toPath, idsPath, options);
  this.pass({$refList: refList})._setArrayDiff(refList.fromSegments, refList.get());
  return this.scope(fromPath);
};

Model.prototype.removeRefList = function(from) {
  var fromPath = this.path(from);
  var refList = this.root._refLists.remove(fromPath);
  if (refList) this._del(refList.fromSegments);
};

function RefList(model, from, to, ids, options) {
  this.model = model && model.pass({$refList: this});
  this.from = from;
  this.to = to;
  this.ids = ids;
  this.fromSegments = from && from.split('.');
  this.toSegments = to && to.split('.');
  this.idsSegments = ids && ids.split('.');
  this.options = options;
  this.deleteRemoved = options && options.deleteRemoved;
}

// The default implementation assumes that the ids array is a flat list of
// keys on the to object. Ideally, this mapping could be customized via
// inheriting from RefList and overriding these methods without having to
// modify the above event handling code.
// 
// In the default refList implementation, `key` and `id` are equal.
// 
// Terms in the below methods:
//   `item`  - Object on the `to` path, which gets mirrored on the `from` path
//   `key`   - The property under `to` at which an item is located
//   `id`    - String or object in the array at the `ids` path
//   `index` - The index of an id, which corresponds to an index on `from`
RefList.prototype.get = function() {
  var ids = this.model._get(this.idsSegments);
  if (!ids) return [];
  var items = this.model._get(this.toSegments);
  var out = [];
  for (var i = 0; i < ids.length; i++) {
    var key = ids[i];
    out.push(items && items[key]);
  }
  return out;
};
RefList.prototype.dereference = function(segments, i) {
  var remaining = segments.slice(i + 1);
  var key = this.idByIndex(remaining[0]);
  if (key == null) return [];
  remaining[0] = key;
  return this.toSegments.concat(remaining);
};
RefList.prototype.toSegmentsByItem = function(item) {
  var key = this.idByItem(item);
  if (key === void 0) return;
  return this.toSegments.concat(key);
};
RefList.prototype.idByItem = function(item) {
  if (item && item.id) return item.id;
  var items = this.model._get(this.toSegments);
  for (var key in items) {
    if (item === items[key]) return key;
  }
};
RefList.prototype.indicesByItem = function(item) {
  var id = this.idByItem(item);
  var ids = this.model._get(this.idsSegments);
  if (!ids) return;
  var indices;
  var index = -1;
  while (true) {
    index = ids.indexOf(id, index + 1);
    if (index === -1) break;
    if (indices) {
      indices.push(index);
    } else {
      indices = [index];
    }
  }
  return indices;
};
RefList.prototype.itemById = function(id) {
  return this.model._get(this.toSegments.concat(id));
};
RefList.prototype.idByIndex = function(index) {
  return this.model._get(this.idsSegments.concat(index));
};
RefList.prototype.onMutation = function(type, segments, eventArgs) {
  if (util.mayImpact(this.toSegments, segments)) {
    patchToEvent(type, segments, eventArgs, this);
  } else if (util.mayImpact(this.idsSegments, segments)) {
    patchIdsEvent(type, segments, eventArgs, this);
  } else if (util.mayImpact(this.fromSegments, segments)) {
    patchFromEvent(type, segments, eventArgs, this);
  }
};

function FromMap() {}

function RefLists(model) {
  this.model = model;
  this.fromMap = new FromMap;
}

RefLists.prototype.add = function(from, to, ids, options) {
  var refList = new RefList(this.model, from, to, ids, options);
  this.fromMap[from] = refList;
  return refList;
};

RefLists.prototype.remove = function(from) {
  var refList = this.fromMap[from];
  delete this.fromMap[from];
  return refList;
};

RefLists.prototype.toJSON = function() {
  var out = [];
  for (var from in this.fromMap) {
    var refList = this.fromMap[from];
    out.push([refList.from, refList.to, refList.ids, refList.options]);
  }
  return out;
};

},{"../util":14,"./Model":31}],44:[function(require,module,exports){
var util = require('../util');
var Model = require('./Model');

Model.INITS.push(function(model) {
  var root = model.root;
  root._refs = new Refs(root);
  addIndexListeners(root);
  addListener(root, 'change', refChange);
  addListener(root, 'load', refLoad);
  addListener(root, 'unload', refUnload);
  addListener(root, 'insert', refInsert);
  addListener(root, 'remove', refRemove);
  addListener(root, 'move', refMove);
  addListener(root, 'stringInsert', refStringInsert);
  addListener(root, 'stringRemove', refStringRemove);
});

function addIndexListeners(model) {
  model.on('insert', function refInsertIndex(segments, eventArgs) {
    var index = eventArgs[0];
    var howMany = eventArgs[1].length;
    function patchInsert(refIndex) {
      return (index <= refIndex) ? refIndex + howMany : refIndex;
    }
    onIndexChange(segments, patchInsert);
  });
  model.on('remove', function refRemoveIndex(segments, eventArgs) {
    var index = eventArgs[0];
    var howMany = eventArgs[1].length;
    function patchRemove(refIndex) {
      return (index <= refIndex) ? refIndex - howMany : refIndex;
    }
    onIndexChange(segments, patchRemove);
  });
  model.on('move', function refMoveIndex(segments, eventArgs) {
    var from = eventArgs[0];
    var to = eventArgs[1];
    var howMany = eventArgs[2];
    function patchMove(refIndex) {
      // If the index was moved itself
      if (from <= refIndex && refIndex < from + howMany) {
        return refIndex + to - from;
      }
      // Remove part of a move
      if (from <= refIndex) refIndex -= howMany;
      // Insert part of a move
      if (to <= refIndex) refIndex += howMany;
      return refIndex;
    }
    onIndexChange(segments, patchMove);
  });
  function onIndexChange(segments, patch) {
    var fromMap = model._refs.fromMap;
    for (var from in fromMap) {
      var ref = fromMap[from];
      if (!(ref.updateIndices &&
        util.contains(segments, ref.toSegments) &&
        ref.toSegments.length > segments.length)) continue;
      var index = +ref.toSegments[segments.length];
      var patched = patch(index);
      if (index === patched) continue;
      model._refs.remove(from);
      ref.toSegments[segments.length] = '' + patched;
      ref.to = ref.toSegments.join('.');
      model._refs._add(ref);
    }
  }
}

function refChange(model, dereferenced, eventArgs) {
  var value = eventArgs[0];
  model._set(dereferenced, value);
}
function refLoad(model, dereferenced, eventArgs) {
  var value = eventArgs[0];
  model._set(dereferenced, value);
}
function refUnload(model, dereferenced, eventArgs) {
  model._del(dereferenced);
}
function refInsert(model, dereferenced, eventArgs) {
  var index = eventArgs[0];
  var values = eventArgs[1];
  model._insert(dereferenced, index, values);
}
function refRemove(model, dereferenced, eventArgs) {
  var index = eventArgs[0];
  var howMany = eventArgs[1].length;
  model._remove(dereferenced, index, howMany);
}
function refMove(model, dereferenced, eventArgs) {
  var from = eventArgs[0];
  var to = eventArgs[1];
  var howMany = eventArgs[2];
  model._move(dereferenced, from, to, howMany);
}
function refStringInsert(model, dereferenced, eventArgs) {
  var index = eventArgs[0];
  var text = eventArgs[1];
  model._stringInsert(dereferenced, index, text);
}
function refStringRemove(model, dereferenced, eventArgs) {
  var index = eventArgs[0];
  var howMany = eventArgs[1];
  model._stringRemove(dereferenced, index, howMany);
}

function addListener(model, type, fn) {
  model.on(type, refListener);
  function refListener(segments, eventArgs) {
    var pass = eventArgs[eventArgs.length - 1];
    // Find cases where an event is emitted on a path where a reference
    // is pointing. All original mutations happen on the fully dereferenced
    // location, so this detection only needs to happen in one direction
    var toMap = model._refs.toMap;
    for (var i = 0, len = segments.length; i < len; i++) {
      var subpath = (subpath) ? subpath + '.' + segments[i] : segments[i];
      // If a ref is found pointing to a matching subpath, re-emit on the
      // place where the reference is coming from as if the mutation also
      // occured at that path
      var refs = toMap[subpath];
      if (!refs) continue;
      var remaining = segments.slice(i + 1);
      for (var refIndex = 0, numRefs = refs.length; refIndex < numRefs; refIndex++) {
        var ref = refs[refIndex];
        var dereferenced = ref.fromSegments.concat(remaining);
        // The value may already be up to date via object reference. If so,
        // simply re-emit the event. Otherwise, perform the same mutation on
        // the ref's path
        if (pass.$original || model._get(dereferenced) === model._get(segments)) {
          model.emit(type, dereferenced, eventArgs);
        } else {
          var setterModel = ref.model.pass(pass, true);
          setterModel._dereference = noopDereference;
          fn(setterModel, dereferenced, eventArgs);
        }
      }
    }
    // If a ref points to a child of a matching subpath, get the value in
    // case it has changed and set if different
    var parentToMap = model._refs.parentToMap;
    var refs = parentToMap[subpath];
    if (!refs) return;
    for (var refIndex = 0, numRefs = refs.length; refIndex < numRefs; refIndex++) {
      var ref = refs[refIndex];
      var value = model._get(ref.toSegments);
      var previous = model._get(ref.fromSegments);
      if (previous !== value) {
        var setterModel = ref.model.pass(pass, true);
        setterModel._dereference = noopDereference;
        setterModel._set(ref.fromSegments, value);
      }
    }
  }
}

Model.prototype.ref = function() {
  var from, to, options;
  if (arguments.length === 1) {
    to = arguments[0];
  } else if (arguments.length === 2) {
    if (this.isPath(arguments[1])) {
      from = arguments[0];
      to = arguments[1];
    } else {
      to = arguments[0];
      options = arguments[1];
    }
  } else {
    from = arguments[0];
    to = arguments[1];
    options = arguments[2];
  }
  var fromPath = this.path(from);
  var toPath = this.path(to);
  var fromSegments = fromPath.split('.');
  if (fromSegments.length < 2) {
    var message = 'ref must be performed under a collection ' +
      'and document id. Invalid path: ' + fromPath;
    this.emit('error', new Error(message));
  }
  this.root._refs.remove(fromPath);
  var value = this.get(to);
  this._set(fromSegments, value);
  this.root._refs.add(fromPath, toPath, options);
  return this.scope(fromPath);
};

Model.prototype.removeRef = function(from) {
  var fromPath = this.path(from);
  this.root._refs.remove(fromPath);
  this.del(from);
};

Model.prototype.removeAllRefs = function(subpath) {
  var segments = this._splitPath(subpath);
  var refs = this.root._refs.fromMap;
  var refLists = this.root._refLists.fromMap;
  for (var from in refs) {
    if (util.contains(segments, refs[from].fromSegments)) {
      this.removeRef(from);
    }
  }
  for (var from in refLists) {
    if (util.contains(segments, refLists[from].fromSegments)) {
      this.removeRefList(from);
    }
  }
};

Model.prototype.dereference = function(subpath) {
  var segments = this._splitPath(subpath);
  return this._dereference(segments).join('.');
};

Model.prototype._dereference = function(segments, forArrayMutator, ignore) {
  if (segments.length === 0) return segments;
  var refs = this.root._refs.fromMap;
  var refLists = this.root._refLists.fromMap;
  do {
    var subpath = '';
    var doAgain = false;
    for (var i = 0, len = segments.length; i < len; i++) {
      subpath = (subpath) ? subpath + '.' + segments[i] : segments[i];

      var ref = refs[subpath];
      if (ref) {
        var remaining = segments.slice(i + 1);
        segments = ref.toSegments.concat(remaining);
        doAgain = true;
        break;
      }

      var refList = refLists[subpath];
      if (refList && refList !== ignore) {
        var belowDescendant = i + 2 < len;
        var belowChild = i + 1 < len;
        if (!(belowDescendant || forArrayMutator && belowChild)) continue;
        segments = refList.dereference(segments, i);
        doAgain = true;
        break;
      }
    }
  } while (doAgain);
  // If a dereference fails, return a path that will result in a null value
  // instead of a path to everything in the model
  if (segments.length === 0) return ['$null'];
  return segments;
};

function noopDereference(segments) {
  return segments;
}

function Ref(model, from, to, options) {
  this.model = model && model.pass({$ref: this});
  this.from = from;
  this.to = to;
  this.fromSegments = from.split('.');
  this.toSegments = to.split('.');
  this.parentTos = [];
  for (var i = 1, len = this.toSegments.length; i < len; i++) {
    var parentTo = this.toSegments.slice(0, i).join('.');
    this.parentTos.push(parentTo);
  }
  this.updateIndices = options && options.updateIndices;
}
function FromMap() {}
function ToMap() {}

function Refs(model) {
  this.model = model;
  this.fromMap = new FromMap;
  this.toMap = new ToMap;
  this.parentToMap = new ToMap;
}

Refs.prototype.add = function(from, to, options) {
  var ref = new Ref(this.model, from, to, options);
  return this._add(ref);
};

Refs.prototype._add = function(ref) {
  this.fromMap[ref.from] = ref;
  listMapAdd(this.toMap, ref.to, ref);
  for (var i = 0, len = ref.parentTos.length; i < len; i++) {
    listMapAdd(this.parentToMap, ref.parentTos[i], ref);
  }
  return ref;
};

Refs.prototype.remove = function(from) {
  var ref = this.fromMap[from];
  if (!ref) return;
  delete this.fromMap[from];
  listMapRemove(this.toMap, ref.to, ref);
  for (var i = 0, len = ref.parentTos.length; i < len; i++) {
    listMapRemove(this.parentToMap, ref.parentTos[i], ref);
  }
  return ref;
};

Refs.prototype.toJSON = function() {
  var out = [];
  for (var from in this.fromMap) {
    var ref = this.fromMap[from];
    out.push([ref.from, ref.to]);
  }
  return out;
};

function listMapAdd(map, name, item) {
  map[name] || (map[name] = []);
  map[name].push(item);
}

function listMapRemove(map, name, item) {
  var items = map[name];
  if (!items) return;
  var index = items.indexOf(item);
  if (index === -1) return;
  items.splice(index, 1);
  if (!items.length) delete map[name];
}

},{"../util":14,"./Model":31}],57:[function(require,module,exports){
var defaultFns = module.exports = new DefaultFns;

defaultFns.reverse = new FnPair(getReverse, setReverse);
defaultFns.asc = asc;
defaultFns.desc = desc;

function DefaultFns() {}
function FnPair(get, set) {
  this.get = get;
  this.set = set;
}

function getReverse(array) {
  return array && array.slice().reverse();
}
function setReverse(values) {
  return {0: getReverse(values)};
}

function asc(a, b) {
  if (a < b) return -1;
  if (a > b) return 1;
  return 0;
}
function desc(a, b) {
  if (a > b) return -1;
  if (a < b) return 1;
  return 0;
}

},{}],52:[function(require,module,exports){
var router = module.exports = require('./router')

module.exports = {
  transition: transition
}

/**
 * @param {Function} add (e.g., app.get, app.post, etc.)
 * @param {Array} transitionCalls is an array of objects that look 
 *   like {from, to, forward, back}
 * @param {String} from
 * @param {String} to
 * @param {Function} forward
 * @param {Function} back
 */
function transition(add, calls, from, to, forward, back) {
  if (from === to) return
  for (var i = 0, len = calls.length; i < len; i++) {
    var call = calls[i]
    if (call.from === to) {
      if (hasTransition(calls, from, call.to)) continue
      var composedForward = composeCallbacks(forward, call.forward, to)
      if (back && call.back) {
        var composedBack = composeCallbacks(call.back, back, to)
      }
      add({
        from: from
      , to: call.to
      , forward: composedForward
      , back: composedBack
      })
    } else if (call.to === from) {
      if (hasTransition(calls, call.from, to)) continue
      var composedForward = composeCallbacks(call.forward, forward, from)
      if (back && call.back) {
        var composedBack = composeCallbacks(back, call.back, from)
      }
      add({
        from: call.from
      , to: to
      , forward: composedForward
      , back: composedBack
      })
    }
  }
}

function hasTransition(calls, from, to) {
  for (var i = calls.length; i--;) {
    var call = calls[i];
    if (call.from === from && call.to === to) return true
  }
  return false
}

// TODO: Async support
function composeCallbacks(first, second, intermediatePath) {
  function composed(self, model, params, next, done) {
    var intermediateUrl = router.mapRoute(intermediatePath, params)
    var url = params.url
    var skipped = false
    function wrapNext(err) {
      skipped = true
      next(err)
    }
    params.url = intermediateUrl
    if (first.length === 4) {
      first.call(self, model, params, wrapNext, doneFirst)
    } else {
      first.call(self, model, params, wrapNext)
      doneFirst()
    }
    function doneFirst() {
      if (skipped) return
      params.previous = intermediateUrl
      params.url = url
      if (second.length === 4) {
        second.call(self, model, params, next, done)
      } else {
        second.call(self, model, params, next)
        done && done()
      }
    }
  }
  // These need to be defined individually, since their
  // argument length will be checked
  function asyncComposedCallback(model, params, next, done) {
    composed(this, model, params, next, done);
  }
  function composedCallback(model, params, next) {
    composed(this, model, params, next);
  }
  return (first.length === 4 || second.length === 4) ?
    asyncComposedCallback : composedCallback;
}

},{"./router":51}],27:[function(require,module,exports){
(function(global){var htmlUtil = require('html-util')
var md5 = require('MD5')
var parseHtml = htmlUtil.parse
var trimText = htmlUtil.trimText
var unescapeEntities = htmlUtil.unescapeEntities
var escapeHtml = htmlUtil.escapeHtml
var escapeAttribute = htmlUtil.escapeAttribute
var isVoid = htmlUtil.isVoid
var conditionalComment = htmlUtil.conditionalComment
var markup = require('./markup')
var viewPath = require('./viewPath')
var wrapRemainder = viewPath.wrapRemainder
var ctxPath = viewPath.ctxPath
var extractPlaceholder = viewPath.extractPlaceholder
var dataValue = viewPath.dataValue
var pathFnArgs = viewPath.pathFnArgs
var isBound = viewPath.isBound
var eventBinding = require('./eventBinding')
var splitEvents = eventBinding.splitEvents
var fnListener = eventBinding.fnListener
var derby = require('./derby')

module.exports = View;

function empty() {
  return '';
}

var defaultCtx = {
  $aliases: {}
, $paths: []
, $indices: []
};

var CAMEL_REGEXP = /([a-z])([A-Z])/g;

var defaultGetFns = {
  equal: function getEqual(a, b) {
    return a === b;
  }
, not: function getNot(value) {
    return !value;
  }
, or: function getOr() {
    for (var i = 0; i < arguments.length; i++) {
      var arg = arguments[i];
      if (arg) return arg;
    };
    return arg;
  }
, and: function getAnd() {
    for (var i = 0; i < arguments.length; i++) {
      var arg = arguments[i];
      if (!arg) return arg;
    };
    return arg;
  }
, gt: function getGt(a, b) {
    return a > b;
  }
, lt: function getLt(a, b) {
    return a < b;
  }
, gte: function getGte(a, b) {
    return a >= b;
  }
, lte: function getLte(a, b) {
    return a <= b;
  }
, dash: function getDash(value) {
    return value && value
      .replace(/[:_\s]/g, '-')
      .replace(CAMEL_REGEXP, '$1-$2')
      .toLowerCase()
  }
, join: function getJoin(items, property, separator) {
    var list, i;
    if (!items) return;
    if (property) {
      list = [];
      for (i = items.length; i--;) {
        list[i] = items[i][property];
      }
    } else {
      list = items;
    }
    return list.join(separator || ', ');
  }
, log: function getLog() {
    console.log.apply(console, arguments);
  }
, trace: function getTrace() {
    console.trace();
  }
, debugger: function getDebugger() {
    debugger;
  }
, path: function getPath(name) {
    return ctxPath(this.view, this.ctx, name);
  }
, noop: function noop() {}
, lookup: viewPath.lookup
};

var defaultSetFns = {
  equal: function setEqual(value, a, b) {
    return value && [b];
  }
, not: function setNot(value) {
    return [!value];
  }
};

function View(libraries, app, appFilename) {
  this._libraries = libraries || [];
  this.app = app || {};
  this._appFilename = appFilename;
  this._inline = '';
  this.clear();
  this.getFns = derby.util.copyObject(defaultGetFns);
  this.setFns = derby.util.copyObject(defaultSetFns);
  if (this._init) this._init();
  this._idCount = 0;
  this._uncreated = [];
}
View.prototype = {
  defaultViews: {
    doctype: function() {
      return '<!DOCTYPE html>';
    }
  , root: empty
  , charset: function() {
      return '<meta charset=utf-8>';
    }
  , title$s: empty
  , head: empty
  , header: empty
  , body: empty
  , footer: empty
  , scripts: empty
  , tail: empty
  }

, _selfNs: 'app'

  // All automatically created ids start with a dollar sign
  // TODO: change this since it messes up query selectors unless escaped
, _uniqueId: uniqueId

, clear: clear
, _resetForRender: resetForRender
, make: make
, _makeAll: makeAll
, _makeComponents: makeComponents
, _findView: findView
, _find: find
, get: get
, fn: fn
, render: render
, componentsByName: componentsByName
, _componentConstructor: componentConstructor
, _flushUncreated: flushUncreated
, _beforeRender: beforeRender
, _afterRender: afterRender
, _beforeRoute: beforeRoute

, inline: empty

, escapeHtml: escapeHtml
, escapeAttribute: escapeAttribute
}

View.valueBinding = valueBinding;

function clear() {
  this._views = derby.util.copyObject(this.defaultViews);
  this._renders = {};
  this._resetForRender();
}

function resetForRender(model, componentInstances) {
  componentInstances || (componentInstances = {});
  if (model) this.model = model;
  this._componentInstances = componentInstances;
  var libraries = this._libraries
    , i
  for (i = libraries.length; i--;) {
    libraries[i].view._resetForRender(model, componentInstances);
  }
}

function componentsByName(name) {
  return this._componentInstances[name] || [];
}

function componentConstructor(name) {
  return this._selfLibrary && this._selfLibrary.constructors[name];
}

function uniqueId() {
  return '$' + (this._idCount++).toString(36);
}

function make(name, template, options, templatePath) {
  var view = this
    , isString = options && options.literal
    , noMinify = isString
    , onBind, renderer, render, matchTitle;

  if (templatePath && (render = this._renders[templatePath])) {
    this._views[name] = render;
    return
  }

  name = name.toLowerCase();
  matchTitle = /(?:^|\:)title(\$s)?$/.exec(name);
  if (matchTitle) {
    isString = !!matchTitle[1];
    if (isString) {
      onBind = function(events, name) {
        return bindEvents(events, name, render, ['$_doc', 'prop', 'title']);
      };
    } else {
      this.make(name + '$s', template, options, templatePath);
    }
  }

  render = function(ctx, model, triggerId) {
    if (!renderer) {
      renderer = parse(view, name, template, isString, onBind, noMinify);
    }
    return renderer(ctx, model, triggerId);
  }

  render.nonvoid = options && options.nonvoid;

  this._views[name] = render;
  if (templatePath) this._renders[templatePath] = render;
}

function makeAll(templates, instances) {
  var name, instance, options, templatePath;
  if (!instances) return;
  this.clear();
  for (name in instances) {
    instance = instances[name];
    templatePath = instance[0];
    options = instance[1];
    this.make(name, templates[templatePath], options, templatePath);
  }
}

function makeComponents(components) {
  var librariesMap = this._libraries.map
    , name, component, library;
  for (name in components) {
    component = components[name];
    library = librariesMap[name];
    library && library.view._makeAll(component.templates, component.instances);
  }
}

function findView(name, ns) {
  var items = this._views
    , item, i, segments, testNs;
  name = name.toLowerCase();
  if (ns) {
    ns = ns.toLowerCase();
    item = items[ns + ':' + name];
    if (item) return item;

    segments = ns.split(':');
    for (i = segments.length; i-- > 1;) {
      testNs = segments.slice(0, i).join(':');
      item = items[testNs + ':' + name];
      if (item) return item;
    }
  }
  return items[name];
}

function find(name, ns, optional) {
  var view = this._findView(name, ns);
  if (view) return view;
  if (optional) return empty;
  if (ns) name = ns + ':' + name;
  throw new Error("Can't find template: \n  " + name + '\n\n' +
    'Available templates: \n  ' + Object.keys(this._views).join('\n  ')
  );
}

function get(name, ns, ctx) {
  if (typeof ns === 'object') {
    ctx = ns;
    ns = '';
  }
  ctx = ctx ? extend(ctx, defaultCtx) : derby.util.copyObject(defaultCtx);
  this.app.model = this.model;
  ctx.$fnCtx = [this.app];
  ctx.$pathIds = {};
  return this._find(name, ns)(ctx);
}

function fn(name, value) {
  if (typeof name === 'object') {
    for (var k in name) {
      this.fn(k, name[k]);
    }
    return;
  }
  var get, set;
  if (typeof value === 'object') {
    get = value.get;
    set = value.set;
  } else {
    get = value;
  }
  this.getFns[name] = get;
  if (set) this.setFns[name] = set;
}

function emitRender(view, ns, ctx, name) {
  if (view.isServer) return;
  view.app.emit(name, ctx);
  if (ns) view.app.emit(name + ':' + ns, ctx);
}
function beforeRender(model, ns, ctx) {
  ctx = (ctx && Object.create(ctx)) || {};
  ctx.$ns = ns;
  emitRender(this, ns, ctx, 'pre:render');
  return ctx;
}
function afterRender(ns, ctx) {
  emitRender(this, ns, ctx, 'render');
}
function beforeRoute() {
  this.app.dom.clear();
  // Remove all data, refs, listeners, and reactive functions
  // for the previous page
  var silentModel = this.model.silent();
  silentModel.destroy('_page');
  silentModel.destroy('$components');
  // Unfetch and unsubscribe from all queries and documents
  silentModel.unload();
  var lastRender = this._lastRender;
  if (!lastRender) return;
  emitRender(this, lastRender.ns, lastRender.ctx, 'replace');
}

function render(model, ns, ctx, renderHash) {
  if (typeof ns === 'object') {
    renderHash = ctx;
    ctx = ns;
    ns = '';
  }
  this.model = model;

  if (!ctx.$isServer) ctx = this._beforeRender(model, ns, ctx);
  this._lastRender = {
    ns: ns
  , ctx: ctx
  };

  this._resetForRender();
  model.__pathMap.clear();
  model.__events.clear();
  model.__blockPaths = {};
  this.app.dom.clear();
  model.silent().destroy('$components');

  var title = this.get('title$s', ns, ctx)
    , headHtml = this.get('head', ns, ctx)
    , rootHtml = this.get('root', ns, ctx)
    , bodyHtml = this.get('header', ns, ctx) +
        this.get('body', ns, ctx) +
        this.get('footer', ns, ctx)
    , doc = window.document
    , err

  if (renderHash) {
    // Check hashes in development to help find rendering bugs
    if (renderHash === md5(bodyHtml)) {
      this._flushUncreated();
      return;
    }
    err = new Error('Server and client page renders do not match');
    setTimeout(function() {
      throw err;
    }, 0);
  } else if (ctx.$isServer) {
    // Don't finish rendering client side on the very first load, since
    // the page should already have the same HTML from the server
    this._flushUncreated();
    return;
  }

  var documentElement = doc.documentElement
    , attrs = documentElement.attributes
    , i, attr, fakeRoot, body;

  // Remove all current attributes on the documentElement and replace
  // them with the attributes in the rendered rootHtml
  for (i = attrs.length; i--;) {
    attr = attrs[i];
    documentElement.removeAttribute(attr.name);
  }
  // Using the DOM to get the attributes on an <html> tag would require
  // some sort of iframe hack until DOMParser has better browser support.
  // String parsing the html should be simpler and more efficient
  parseHtml(rootHtml, {
    start: function(tag, tagName, attrs) {
      if (tagName !== 'html') return;
      for (var attr in attrs) {
        documentElement.setAttribute(attr, attrs[attr]);
      }
    }
  });

  fakeRoot = doc.createElement('html');
  fakeRoot.innerHTML = bodyHtml;
  body = fakeRoot.getElementsByTagName('body')[0];
  documentElement.replaceChild(body, doc.body);
  doc.title = title;

  this.app.dom._setDirty(true);
  this._flushUncreated();
  this._afterRender(ns, ctx);
}


function extend(parent, obj) {
  var out = Object.create(parent)
    , key;
  if (typeof obj !== 'object' || Array.isArray(obj)) {
    return out;
  }
  for (key in obj) {
    out[key] = obj[key];
  }
  return out;
}

function modelListener(params, triggerId, blockPaths, pathId, partial, ctx, saveBlockPath) {
  var listener = typeof params === 'function'
    ? params(triggerId, blockPaths, saveBlockPath && pathId)
    : params;
  listener.partial = partial;
  listener.ctx = ctx.$stringCtx || ctx;
  return listener;
}

function bindPathEvent(events, bindName, getName, partial, params, saveBlockPath) {
  events.push(function(ctx, modelEvents, dom, pathMap, view, blockPaths, triggerId) {
    var path = ctxPath(view, ctx, bindName)
    if (!path) return;
    var pathId = pathMap.id(path);
    var listener = modelListener(params, triggerId, blockPaths, pathId, partial, ctx, saveBlockPath);
    if (bindName !== getName) {
      listener.getValue = function(model) {
        return dataValue(view, ctx, model, getName);
      };
    }
    modelEvents.bind(pathId, listener);
  });
}
function bindEachPathEvent(events, name, getName, partial, params) {
  var bracketIndex = name.indexOf('[');
  if (~bracketIndex) {
    // Bind to each of the items inside brackets
    var paths = viewPath.squareBracketsArgs(name);
    for (var i = paths.length; i--;) {
      bindEachPathEvent(events, paths[i], getName, partial, params);
    }
    // Bind to anything under the root. This ins't very efficent, but it
    // should cover various cases that would require updating the bindings
    // when the arguments inside of the brackets change, which I don't feel
    // like figuring out at the moment
    var before = name.slice(0, bracketIndex);
    if (before) bindEachPathEvent(events, before + '*', getName, partial, params);
    return;
  }
  var match = /(\.*)(.*)/.exec(name);
  var prefix = match[1] || '';
  var relativeName = match[2] || '';
  var segments = relativeName.split('.');
  // This loop stops before reaching zero
  var saveBlockPath = true;
  for (var i = segments.length; i; i--) {
    var bindName = prefix + segments.slice(0, i).join('.');
    bindPathEvent(events, bindName, getName, partial, params, saveBlockPath);
    saveBlockPath = false;
  }
}
function bindEvents(events, name, partial, params) {
  if (~name.indexOf('(')) {
    var args = pathFnArgs(name);
    for (var i = args.length; i--;) {
      bindEachPathEvent(events, args[i] + '*', name, partial, params);
    }
    return;
  }
  bindEachPathEvent(events, name, name, partial, params);
}

function bindEventsById(events, name, partial, attrs, method, prop, blockType) {
  function params(triggerId, blockPaths, pathId) {
    var id = attrs._id || attrs.id;
    if (blockType && pathId) {
      blockPaths[id] = {id: pathId, type: blockType};
    }
    return [id, method, prop];
  }
  bindEvents(events, name, partial, params);
}

function bindEventsByIdString(events, name, partial, attrs, method, prop) {
  function params(triggerId) {
    var id = triggerId || attrs._id || attrs.id;
    return [id, method, prop];
  }
  bindEvents(events, name, partial, params);
}

function addId(view, attrs) {
  if (attrs.id == null) {
    attrs.id = function() {
      return attrs._id = view._uniqueId();
    };
  }
}

function pushValue(html, i, value, isAttr) {
  if (typeof value === 'function') {
    i = html.push(value, '') - 1;
  } else {
    html[i] += isAttr ? escapeAttribute(value) : value;
  }
  return i;
}

function reduceStack(stack) {
  var html = ['']
    , i = 0
    , attrs, bool, item, key, value, j, len;

  for (j = 0, len = stack.length; j < len; j++) {
    item = stack[j];
    switch (item[0]) {
      case 'start':
        html[i] += '<' + item[1];
        attrs = item[2];
        // Make sure that the id attribute is rendered first
        if ('id' in attrs) {
          html[i] += ' id=';
          i = pushValue(html, i, attrs.id, true);
        }
        for (key in attrs) {
          if (key === 'id') continue;
          value = attrs[key];
          if (value != null) {
            if (bool = value.bool) {
              i = pushValue(html, i, bool);
              continue;
            }
            html[i] += ' ' + key + '=';
            i = pushValue(html, i, value, true);
          } else {
            html[i] += ' ' + key;
          }
        }
        html[i] += '>';
        break;
      case 'text':
        i = pushValue(html, i, item[1]);
        break;
      case 'end':
        html[i] += '</' + item[1] + '>';
        break;
      case 'marker':
        html[i] += '<!--' + item[1];
        i = pushValue(html, i, item[2].id);
        html[i] += '-->';
    }
  }
  return html;
}

function renderer(view, items, events, onRender) {
  return function(ctx, model, triggerId) {
    if (!model) model = view.model;  // Needed, since model parameter is optional

    if (onRender) ctx = onRender(ctx);

    var html = '';
    for (var i = 0, len = items.length; i < len; i++) {
      item = items[i];
      html += (typeof item === 'function') ? item(ctx, model) || '' : item;
    }
    if (view.isServer) return html;

    var pathMap = model.__pathMap;
    var modelEvents = model.__events;
    var blockPaths = model.__blockPaths;
    var dom = global.DERBY && global.DERBY.app.dom;
    // Note that the events array can grow during rendering
    var i = 0;
    var event;
    while (event = events[i++]) {
      event(ctx, modelEvents, dom, pathMap, view, blockPaths, triggerId);
    }
    return html;
  }
}

function bindComponentEvent(component, name, listener) {
  if (name === 'init' || name === 'create') {
    component.once(name, listener.fn);
  } else {
    // Extra indirection allows listener to overwrite itself after first run
    component.on(name, function() {
      listener.fn.apply(null, arguments);
    });
  }
}
function bindComponentEvents(ctx, component, events) {
  var view = events.$view
    , items = events.$events
    , listenerCtx = Object.create(ctx)
    , i, item, name, listener
  // The fnCtx will include this component, but we want to emit
  // on the parent component or app
  listenerCtx.$fnCtx = listenerCtx.$fnCtx.slice(0, -1);
  for (i = items.length; i--;) {
    item = items[i];
    name = item[0];
    listener = fnListener(view, listenerCtx, item[2]);
    bindComponentEvent(component, name, listener);
  }
}

function createComponent(view, model, Component, scope, ctx, macroCtx) {
  var scoped = model.scope(scope);
  var marker = '<!--' + scope + '-->';
  var prefix = scope + '.';
  var component = new Component(scoped, scope);
  var parentFnCtx = model.__fnCtx || ctx.$fnCtx;
  var silentCtx = Object.create(ctx);
  silentCtx.$silent = true;
  var silentModel = model.silent();
  var i, key, path, value, instanceName, instances;

  ctx.$fnCtx = model.__fnCtx = parentFnCtx.concat(component);

  // HACK: Ensure that scoped model has something set
  scoped.set('$null', null);

  for (key in macroCtx) {
    value = macroCtx[key];
    if (key === 'bind') {
      bindComponentEvents(ctx, component, value);
      continue;
    }
    if (value && value.$matchName) {
      path = ctxPath(view, ctx, value.$matchName);
      if (value.$bound) {
        silentModel.ref(prefix + key, path, {updateIndices: true});
        continue;
      }
      value = dataValue(view, ctx, model, path);
      silentModel.set(prefix + key, value);
      continue;
    }
    // TODO: Figure out how to get value of templatized attributes
    if (typeof value === 'function') continue;
    silentModel.set(prefix + key, value);
  }

  instanceName = scoped.get('name');
  if (instanceName) {
    instances = view._componentInstances[instanceName] ||
      (view._componentInstances[instanceName] = []);
    instances.push(component);
  }

  if (component.init) component.init(scoped);
  component.emit('init', component);

  if (view.isServer || ctx.$silent) return marker;

  var app = global.DERBY && global.DERBY.app
    , dom = app.dom
  component.dom = dom;
  component.history = app.history;

  var uncreated = new UncreatedComponent(component, scoped, dom, scope, ctx);
  view._uncreated.push(uncreated);

  return marker;
}

function UncreatedComponent(component, model, dom, scope, ctx) {
  this.component = component;
  this.model = model;
  this.dom = dom;
  this.scope = scope;
  this.ctx = ctx;
}
UncreatedComponent.prototype.create = function() {
  // TODO: Figure out underlying issue and remove
  // If for some reason, component's scoped model does not have any data,
  // do nothing. Not sure why it would get to this state, but it does.
  if (!this.model.get()) return;

  // Destroy in case component was created and replaced within rendering
  if (!this.dom.marker(this.scope)) {
    this.component.emit('destroy');
    return;
  }

  this.dom.addComponent(this.ctx, this.component);
  if (this.component.create) this.component.create(this.model, this.component.dom);
  this.component.emit('create', this.component);
};

function flushUncreated() {
  var uncreated;
  while (uncreated = this._uncreated.shift()) {
    uncreated.create();
  }
};

function extendCtx(view, ctx, value, name, alias, isEach) {
  var path = ctxPath(view, ctx, name)
    , aliases;
  ctx = extend(ctx, value);
  ctx['this'] = value;
  if (alias) {
    aliases = ctx.$aliases = Object.create(ctx.$aliases);
    aliases[alias] = ctx.$paths.length;
    if (isEach) aliases[alias]++;
  }
  if (path) {
    ctx.$paths = [path].concat(ctx.$paths);
  }
  ctx.$pathIds = Object.create(ctx.$pathIds);
  return ctx;
}

function partialValue(view, ctx, model, name, value, listener) {
  if (listener) return value;
  return name ? dataValue(view, ctx, model, name) : true;
}

function partialFn(view, name, type, alias, render, ns, macroCtx) {
  function partialBlock (ctx, model, triggerId, value, index, listener) {
    // Inherit & render attribute context values
    var renderMacroCtx = {}
      , parentMacroCtx = ctx.$macroCtx
      , mergedMacroCtx = macroCtx
      , key, val, matchName
    if (macroCtx.inherit) {
      mergedMacroCtx = {};
      derby.util.mergeInto(mergedMacroCtx, parentMacroCtx);
      derby.util.mergeInto(mergedMacroCtx, macroCtx);
      delete mergedMacroCtx.inherit;
    }
    for (key in mergedMacroCtx) {
      val = mergedMacroCtx[key];
      if (val && val.$matchName) {
        matchName = ctxPath(view, ctx, val.$matchName);
        if (matchName.charAt(0) === '@') {
          val = dataValue(view, ctx, model, matchName);
        } else {
          val = derby.util.copyObject(val);
          val.$matchName = matchName;
        }
      }
      renderMacroCtx[key] = val;
    }

    // Find the appropriate partial template
    var partialNs, partialName, partialOptional, arr;
    if (name === 'derby:view') {
      partialNs = mergedMacroCtx.ns || view._selfNs;
      partialName = mergedMacroCtx.view;
      partialOptional = mergedMacroCtx.optional;
      if (!partialName) throw new Error('<derby:view> tag without a "view" attribute')
      if (partialNs.$matchName) {
        partialNs = dataValue(view, ctx, model, partialNs.$matchName);
      }
      if (partialName.$matchName) {
        partialName = dataValue(view, ctx, model, partialName.$matchName);
      }
    } else {
      arr = splitPartial(name);
      partialNs = arr[0];
      partialName = arr[1];
    }
    // This can happen when using <derby:view view={{...}}>
    if (typeof partialName === 'function') {
      partialName = partialName(Object.create(ctx), model);
    }
    var partialView = nsView(view, partialNs)
      , render = partialView._find(partialName, ns, partialOptional)
      , Component = partialView._componentConstructor(partialName)
      , renderCtx, scope, out, marker

    // Prepare the context for rendering
    if (Component) {
      scope = '$components.' + view._uniqueId();
      renderCtx = extendCtx(view, ctx, null, scope, 'self');
      renderCtx.$elements = {};
      marker = createComponent(view, model, Component, scope, renderCtx, renderMacroCtx);
    } else {
      renderCtx = Object.create(ctx);
    }
    renderCtx.$macroCtx = renderMacroCtx;

    out = render(renderCtx, model);
    if (Component) {
      if (model.__fnCtx) {
        model.__fnCtx = model.__fnCtx.slice(0, -1);
      }
      out = marker + out;
    }
    return out;
  }

  function withBlock(ctx, model, triggerId, value, index, listener) {
    value = partialValue(view, ctx, model, name, value, listener);
    var renderCtx = extendCtx(view, ctx, value, name, alias);
    return render(renderCtx, model);
  }

  function ifBlock(ctx, model, triggerId, value, index, listener) {
    value = partialValue(view, ctx, model, name, value, listener);
    if (!(Array.isArray(value) ? value.length : value)) return;
    var renderCtx = extendCtx(view, ctx, value, name, alias);
    return render(renderCtx, model);
  }

  function unlessBlock(ctx, model, triggerId, value, index, listener) {
    value = partialValue(view, ctx, model, name, value, listener);
    if (Array.isArray(value) ? value.length : value) return;
    var renderCtx = extendCtx(view, ctx, value, name, alias);
    return render(renderCtx, model);
  }

  function eachBlock(ctx, model, triggerId, value, index, listener) {
    value = partialValue(view, ctx, model, name, value, listener);
    var isArray = Array.isArray(value);

    if (listener && !isArray) {
      if (value === void 0) return;
      var listCtx = extendCtx(view, ctx, null, name, alias, true);
      var itemPath = listCtx.$paths[0] + '.' + index;
      var item = partialValue(view, listCtx, model, itemPath, value, listener);
      renderCtx = extend(listCtx, item);
      renderCtx['this'] = item;
      renderCtx.$indices = [index].concat(renderCtx.$indices);
      renderCtx.$index = index;
      renderCtx.$paths = [itemPath].concat(renderCtx.$paths);
      return render(renderCtx, model);
    }

    if (!isArray || !value.length) return;

    var listCtx = extendCtx(view, ctx, null, name, alias, true);

    var out = '';
    var indices = listCtx.$indices;
    var paths = listCtx.$paths;
    var basePath = paths[0];
    for (var i = 0, len = value.length; i < len; i++) {
      var item = value[i];
      var renderCtx = extend(listCtx, item);
      renderCtx['this'] = item;
      renderCtx.$indices = [i].concat(indices);
      renderCtx.$index = i;
      renderCtx.$paths = [basePath + '.' + i].concat(paths);
      out += (item === void 0) ?
        '<!--empty-->' :
        render(renderCtx, model);
    }
    return out;
  }

  var block =
      (type === 'partial') ? partialBlock
    : (type === 'with' || type === 'else') ? withBlock
    : (type === 'if' || type === 'else if') ? ifBlock
    : (type === 'unless') ? unlessBlock
    : (type === 'each') ? eachBlock
    : null

  if (!block) throw new Error('Unknown block type: ' + type);
  block.type = type;
  return block;
}

var objectToString = Object.prototype.toString;
var arrayToString = Array.prototype.toString;

function valueBinding(value) {
  return value == null ? '' :
    (value.toString === objectToString || value.toString === arrayToString) ?
    JSON.stringify(value) : value;
}

function valueText(value) {
  return valueBinding(value).toString();
}

function textFn(view, name, escape, force) {
  var filter = escape ? function(value) {
    return escape(valueText(value));
  } : valueText;
  return function(ctx, model) {
    return dataValue(view, ctx, model, name, filter, force);
  }
}

function sectionFn(view, queue) {
  var render = renderer(view, reduceStack(queue.stack), queue.events);
  var block = queue.block;
  return partialFn(view, block.name, block.type, block.alias, render);
}

function blockFn(view, sections) {
  var len = sections.length;
  if (!len) return;
  if (len === 1) {
    return sectionFn(view, sections[0]);

  } else {
    var fns = []
      , i, out;
    for (i = 0; i < len; i++) {
      fns.push(sectionFn(view, sections[i]));
    }
    out = function(ctx, model, triggerId, value, index, listener) {
      var out;
      for (i = 0; i < len; i++) {
        out = fns[i](ctx, model, triggerId, value, index, listener);
        if (out != null) return out;
      }
    }
    return out;
  }
}

function parseMarkup(type, attr, tagName, events, attrs, value) {
  var parser = markup[type][attr]
    , anyOut, anyParser, elOut, elParser, out;
  if (!parser) return;
  if (anyParser = parser['*']) {
    anyOut = anyParser(events, attrs, value);
  }
  if (elParser = parser[tagName]) {
    elOut = elParser(events, attrs, value);
  }
  out = anyOut ? extend(anyOut, elOut) : elOut;
  if (out && out.del) delete attrs[attr];
  return out;
}

function pushText(stack, text) {
  if (text) stack.push(['text', text]);
}

function pushVarFn(view, stack, fn, name, escapeFn) {
  if (fn) {
    pushText(stack, fn);
  } else {
    pushText(stack, textFn(view, name, escapeFn));
  }
}

function isPartial(view, tagName) {
  if (tagName === 'derby:view') return true;
  var split = splitPartial(tagName);
  if (!split) return false;
  var tagNs = split[0];
  return (
    tagNs === 'app' ||
    tagNs === 'lib' ||
    !!libraryForNs(view, tagNs)
  );
}

function isPartialSection(tagName) {
  return tagName.charAt(0) === '@';
}

function partialSectionName(tagName) {
  return isPartialSection(tagName) ? tagName.slice(1) : null;
}

function libraryForNs(view, ns) {
  var library = view._libraries.map[ns];
  if (library) return library;
  if (view.parent) return view.parent.view._libraries.map[ns];
}

function nsView(view, ns) {
  if (ns === view._selfNs) return view;
  if (view.parent && ns === view.parent.view._selfNs) return view.parent.view;
  var library = libraryForNs(view, ns);
  if (!library) throw new Error('No library found with namespace ' + ns);
  var partialView = library.view;
  partialView._uniqueId = function() {
    return view._uniqueId();
  };
  partialView.model = view.model;
  partialView._uncreated = view._uncreated;
  return partialView;
}

function splitPartial(partial) {
  var i = partial.indexOf(':');
  if (i === -1) return;
  var partialNs = partial.slice(0, i);
  var partialName = partial.slice(i + 1);
  return [partialNs, partialName];
}

function findComponent(view, partial, ns) {
  var arr = splitPartial(partial)
    , partialNs = arr[0]
    , partialName = arr[1]
    , partialView = nsView(view, partialNs)
  return partialView._find(partialName, ns);
}

function isVoidComponent(view, partial, ns) {
  if (partial === 'derby:view') return true;
  return !findComponent(view, partial, ns).nonvoid;
}

function pushVar(view, ns, stack, events, remainder, match, fn) {
  var name = match.name
    , partial = match.partial
    , escapeFn = match.escaped && escapeHtml
    , attr, attrs, boundOut, last, tagName, wrap;

  if (partial) {
    fn = partialFn(view, partial, 'partial', null, null, ns, match.macroCtx);
  }

  else if (match.bound) {
    last = lastItem(stack);
    wrap = match.pre ||
      !last ||
      (last[0] !== 'start') ||
      isVoid(tagName = last[1]) ||
      wrapRemainder(tagName, remainder);

    if (wrap) {
      stack.push(['marker', '', attrs = {}]);
    } else {
      attrs = last[2];
      for (attr in attrs) {
        parseMarkup('boundParent', attr, tagName, events, attrs, match);
      }
      boundOut = parseMarkup('boundParent', '*', tagName, events, attrs, match);
      if (boundOut) {
        bindEventsById(events, name, null, attrs, boundOut.method, boundOut.property);
      }
    }
    addId(view, attrs);

    if (!boundOut) {
      bindEventsById(events, name, fn, attrs, 'html', !fn && escapeFn, match.type);
    }
  }

  pushVarFn(view, stack, fn, name, escapeFn);
  if (wrap) {
    stack.push([
      'marker'
    , '$'
    , { id: function() { return attrs._id } }
    ]);
  }
}

function pushVarString(view, ns, stack, events, remainder, match, fn) {
  var name = match.name
    , escapeFn = !match.escaped && unescapeEntities;
  function bindOnce(ctx) {
    ctx.$onBind(events, name);
    bindOnce = empty;
  }
  if (match.bound) {
    events.push(function(ctx) {
      bindOnce(ctx);
    });
  }
  pushVarFn(view, stack, fn, name, escapeFn);
}

function parseMatchError(text, message) {
  throw new Error(message + '\n\n' + text + '\n');
}

function onBlock(start, end, block, queues, callbacks) {
  var lastQueue, queue;
  if (end) {
    lastQueue = queues.pop();
    queue = lastItem(queues);
    queue.sections.push(lastQueue);
  } else {
    queue = lastItem(queues);
  }

  if (start) {
    queue = {
      stack: []
    , events: []
    , block: block
    , sections: []
    };
    queues.push(queue);
    callbacks.onStart(queue);
  } else {
    if (end) {
      callbacks.onStart(queue);
      callbacks.onEnd(queue.sections);
      queue.sections = [];
    } else {
      callbacks.onContent(block);
    }
  }
}

function parseMatch(text, match, queues, callbacks) {
  var hash = match.hash
    , type = match.type
    , name = match.name
    , block = lastItem(queues).block
    , blockType = block && block.type
    , startBlock, endBlock;

  if (type === 'if' || type === 'unless' || type === 'each' || type === 'with') {
    if (hash === '#') {
      startBlock = true;
    } else if (hash === '/') {
      endBlock = true;
    } else {
      parseMatchError(text, type + ' blocks must begin with a #');
    }

  } else if (type === 'else' || type === 'else if') {
    if (hash) {
      parseMatchError(text, type + ' blocks may not start with ' + hash);
    }
    if (blockType !== 'if' && blockType !== 'else if' &&
        blockType !== 'unless' && blockType !== 'each') {
      parseMatchError(text, type + ' may only follow `if`, `else if`, `unless`, or `each`');
    }
    startBlock = true;
    endBlock = true;

  } else if (hash === '/') {
    endBlock = true;

  } else if (hash === '#') {
    parseMatchError(text, '# must be followed by `if`, `unless`, `each`, or `with`');
  }

  if (endBlock && !block) {
    parseMatchError(text, 'Unmatched template end tag');
  }

  onBlock(startBlock, endBlock, match, queues, callbacks);
}

function parseAttr(view, viewName, events, tagName, attrs, attr) {
  var value = attrs[attr];
  if (typeof value === 'function') return;

  var attrOut = parseMarkup('attr', attr, tagName, events, attrs, value) || {}
    , boundOut, match, name, render, method, property;
  if (attrOut.addId) addId(view, attrs);

  if (match = extractPlaceholder(value)) {
    name = match.name;

    if (match.pre || match.post) {
      // Attributes must be a single string, so create a string partial
      addId(view, attrs);
      render = parse(view, viewName, value, true, function(events, name) {
        bindEventsByIdString(events, name, render, attrs, 'attr', attr);
      });

      attrs[attr] = attr === 'id' ? function(ctx, model) {
        return attrs._id = escapeAttribute(render(ctx, model));
      } : function(ctx, model) {
        return escapeAttribute(render(ctx, model));
      }
      return;
    }

    if (match.bound) {
      boundOut = parseMarkup('bound', attr, tagName, events, attrs, match) || {};
      addId(view, attrs);
      method = boundOut.method || 'attr';
      property = boundOut.property || attr;
      bindEventsById(events, name, null, attrs, method, property);
    }

    if (!attrOut.del) {
      attrs[attr] = attrOut.bool ? {
        bool: function(ctx, model) {
          return (dataValue(view, ctx, model, name)) ? ' ' + attr : '';
        }
      } : textFn(view, name, escapeAttribute, true);
    }
  }
}

function parsePartialAttr(view, viewName, events, attrs, attr) {
  var value = attrs[attr]
    , match;

  if (!value) {
    // A true boolean attribute will have a value of null
    if (value === null) attrs[attr] = true;
    return;
  }

  if (attr === 'bind') {
    attrs[attr] = {$events: splitEvents(value), $view: view};
    return;
  }

  if (match = extractPlaceholder(value)) {
    // This attribute needs to be treated as a section
    if (match.pre || match.post) return true;

    attrs[attr] = {$matchName: match.name, $bound: match.bound};

  } else if (value === 'true') {
    attrs[attr] = true;
  } else if (value === 'false') {
    attrs[attr] = false;
  } else if (value === 'null') {
    attrs[attr] = null;
  } else if (!isNaN(value)) {
    attrs[attr] = +value;
  } else if (/^[{[]/.test(value)) {
    try {
      attrs[attr] = JSON.parse(value)
    } catch (err) {}
  }
}

function lastItem(arr) {
  return arr[arr.length - 1];
}

function parse(view, viewName, template, isString, onBind, noMinify) {
  var queues, stack, events, onRender, push;

  queues = [{
    stack: stack = []
  , events: events = []
  , sections: []
  }];

  function onStart(queue) {
    stack = queue.stack;
    events = queue.events;
  }

  if (isString) {
    push = pushVarString;
    onRender = function(ctx) {
      if (ctx.$stringCtx) return ctx;
      ctx = Object.create(ctx);
      ctx.$onBind = onBind;
      ctx.$stringCtx = ctx;
      return ctx;
    }
  } else {
    push = pushVar;
  }

  var index = viewName.lastIndexOf(':')
    , ns = ~index ? viewName.slice(0, index) : ''

  function parseStart(tag, tagName, attrs) {
    var attr, block, out, parser, isSection, attrBlock
    if ('x-no-minify' in attrs) {
      delete attrs['x-no-minify'];
      noMinify = true;
    }

    if (isPartial(view, tagName)) {
      block = {
        partial: tagName
      , macroCtx: attrs
      };
      onBlock(true, false, block, queues, {onStart: onStart});

      for (attr in attrs) {
        isSection = parsePartialAttr(view, viewName, events, attrs, attr);
        if (!isSection) continue;
        attrBlock = {
          partial: '@' + attr
        , macroCtx: lastItem(queues).block.macroCtx
        };
        onBlock(true, false, attrBlock, queues, {onStart: onStart});
        parseText(attrs[attr]);
        parseEnd(tag, '@' + attr);
      }

      if (isVoidComponent(view, tagName, ns)) {
        onBlock(false, true, null, queues, {
          onStart: onStart
        , onEnd: function(queues) {
            push(view, ns, stack, events, '', block);
          }
        })
      }
      return;
    }

    if (isPartialSection(tagName)) {
      block = {
        partial: tagName
      , macroCtx: lastItem(queues).block.macroCtx
      };
      onBlock(true, false, block, queues, {onStart: onStart});
      return;
    }

    if (parser = markup.element[tagName]) {
      out = parser(events, attrs);
      if (out != null ? out.addId : void 0) {
        addId(view, attrs);
      }
    }

    for (attr in attrs) {
      parseAttr(view, viewName, events, tagName, attrs, attr);
    }
    stack.push(['start', tagName, attrs]);
  }

  function parseText(text, isRawText, remainder) {
    var match = extractPlaceholder(text)
      , post, pre;
    if (!match || isRawText) {
      if (!noMinify) {
        text = isString ? unescapeEntities(trimText(text)) : trimText(text);
      }
      pushText(stack, text);
      return;
    }

    pre = match.pre;
    post = match.post;
    if (isString) pre = unescapeEntities(pre);
    pushText(stack, pre);
    remainder = post || remainder;

    parseMatch(text, match, queues, {
      onStart: onStart
    , onEnd: function(sections) {
        var fn = blockFn(view, sections);
        push(view, ns, stack, events, remainder, sections[0].block, fn);
      }
    , onContent: function(match) {
        push(view, ns, stack, events, remainder, match);
      }
    });

    if (post) return parseText(post);
  }

  function parseEnd(tag, tagName) {
    var sectionName = partialSectionName(tagName)
      , endsPartial = isPartial(view, tagName)
    if (endsPartial && isVoidComponent(view, tagName, ns)) {
      throw new Error('End tag "' + tag + '" is not allowed for void component')
    }
    if (sectionName || endsPartial) {
      onBlock(false, true, null, queues, {
        onStart: onStart
      , onEnd: function(queues) {
          var queue = queues[0]
            , block = queue.block
            , fn = renderer(view, reduceStack(queue.stack), queue.events)
          fn.unescaped = true;
          if (sectionName) {
            block.macroCtx[sectionName] = fn;
            return;
          }
          // Put the remaining content not in a section in the default "content" section,
          // unless "inherit" is specified and there is no content, so that the parent
          // content can be inherited
          if (queue.stack.length || !block.macroCtx.inherit) {
            block.macroCtx.content = fn;
          }
          push(view, ns, stack, events, '', block);
        }
      })
      return;
    }
    stack.push(['end', tagName]);
  }

  if (isString) {
    parseText(template);
  } else {
    parseHtml(template, {
      start: parseStart
    , text: parseText
    , end: parseEnd
    , comment: function(tag) {
        if (conditionalComment(tag)) pushText(stack, tag);
      }
    , other: function(tag) {
        pushText(stack, tag);
      }
    });
  }
  return renderer(view, reduceStack(stack), events, onRender);
}

})(window)
},{"./markup":58,"./derby":"9UpRLI","./viewPath":53,"./eventBinding":59,"html-util":55,"MD5":60}],58:[function(require,module,exports){
var eventBinding = require('./eventBinding')
  , splitEvents = eventBinding.splitEvents
  , containsEvent = eventBinding.containsEvent
  , addDomEvent = eventBinding.addDomEvent
  , TEXT_EVENTS = 'keyup,keydown/0,cut/0,paste/0,dragover/0,blur'
  , AUTOCOMPLETE_OFF = {
      checkbox: true
    , radio: true
    }
  , onBindA, onBindForm;

module.exports = {
  bound: {
    'value': {
      'input': function(events, attrs, match) {
        var type = attrs.type
          , eventNames, method;
        if (type === 'radio' || type === 'checkbox') return;
        if (type === 'range' || 'x-blur' in attrs) {
          // Only update after the element loses focus
          delete attrs['x-blur'];
          eventNames = 'change,blur';
        } else {
          // By default, update as the user types
          eventNames = TEXT_EVENTS;
        }
        if ('x-atomic' in attrs) {
          delete attrs['x-atomic'];
          method = 'prop';
        } else if (type === 'text' || !type) {
          method = 'propOt';
        } else {
          method = 'prop';
        }
        addDomEvent(events, attrs, eventNames, match, {
          method: method
        , property: 'value'
        });
        return {method: method};
      }
    }

  , 'checked': {
      '*': function(events, attrs, match) {
        addDomEvent(events, attrs, 'change', match, {
          method: 'prop'
        , property: 'checked'
        });
        return {method: 'prop'};
      }
    }

  , 'selected': {
      '*': function(events, attrs, match) {
        addDomEvent(events, attrs, 'change', match, {
          method: 'prop'
        , property: 'selected'
        });
        return {method: 'prop'};
      }
    }

  , 'disabled': {
      '*': function() {
        return {method: 'prop'};
      }
    }
  }

, boundParent: {
    'contenteditable': {
      '*': function(events, attrs, match) {
        addDomEvent(events, attrs, TEXT_EVENTS, match, {
          method: 'html'
        });
      }
    }

  , '*': {
      'textarea': function(events, attrs, match) {
        if ('x-atomic' in attrs) {
          delete attrs['x-atomic'];
          var method = 'prop';
        } else {
          var method = 'propOt';
        }
        addDomEvent(events, attrs, TEXT_EVENTS, match, {
          method: method
        , property: 'value'
        });
        return {method: method, property: 'value'};
      }
    }
  }

, element: {
    'select': function(events, attrs) {
      // Distribute change event to child nodes of select elements
      addDomEvent(events, attrs, 'change:$forChildren');
      return {addId: true};
    }

  , 'input': function(events, attrs) {
      if (AUTOCOMPLETE_OFF[attrs.type] && !('autocomplete' in attrs)) {
        attrs.autocomplete = 'off';
      }
      if (attrs.type === 'radio') {
        // Distribute change events to other elements with the same name
        addDomEvent(events, attrs, 'change:$forName');
      }
    }
  }

, attr: {
    'x-bind': {
      '*': function(events, attrs, eventNames) {
        addDomEvent(events, attrs, eventNames);
        return {addId: true, del: true};
      }

    , 'a': onBindA = function(events, attrs, eventNames) {
        if (containsEvent(eventNames, ['click', 'focus']) && !('href' in attrs)) {
          attrs.href = '#';
          if (!('onclick' in attrs)) {
            attrs.onclick = 'return false';
          }
        }
      }

    , 'form': onBindForm = function(events, attrs, eventNames) {
        if (containsEvent(eventNames, 'submit')) {
          if (!('onsubmit' in attrs)) {
            attrs.onsubmit = 'return false';
          }
        }
      }
    }

  , 'x-capture': {
      '*': function(events, attrs, eventNames) {
        addDomEvent(events, attrs, eventNames, null, {capture: true});
        return {addId: true, del: true};
      }
    , 'a': onBindA
    , 'form': onBindForm
    }

  , 'x-as': {
      '*': function(events, attrs, name) {
        events.push(function(ctx) {
          ctx.$elements[name] = attrs._id || attrs.id;
        });
        return {addId: true, del: true}
      }
  }

  , 'checked': {
      '*': function() {
        return {bool: true};
      }
    }

  , 'selected': {
      '*': function() {
        return {bool: true};
      }
    }

  , 'disabled': {
      '*': function() {
        return {bool: true};
      }
    }

  , 'autofocus': {
      '*': function() {
        return {bool: true};
      }
    }
  }

, TEXT_EVENTS: TEXT_EVENTS
, AUTOCOMPLETE_OFF: AUTOCOMPLETE_OFF
};

},{"./eventBinding":59}],59:[function(require,module,exports){
var util = require('racer').util
  , viewPath = require('./viewPath')
  , extractPlaceholder = viewPath.extractPlaceholder
  , dataValue = viewPath.dataValue
  , ctxPath = viewPath.ctxPath
  , pathFnArgs = viewPath.pathFnArgs
  , setBoundFn = viewPath.setBoundFn
  , arraySlice = [].slice

exports.splitEvents = splitEvents;
exports.fnListener = fnListener;
exports.containsEvent = containsEvent;
exports.addDomEvent = util.isServer ? empty : addDomEvent;

function splitEvents(eventNames) {
  var pairs = eventNames.split(',')
    , eventList = []
    , i, j, pair, segments, name, eventName, delay, fns, fn;
  for (i = pairs.length; i--;) {
    pair = pairs[i];
    segments = pair.split(':');
    name = segments[0].split('/');
    eventName = name[0].trim();
    delay = name[1];
    fns = (segments[1] || '').trim().split(/\s+/);
    for (j = fns.length; j--;) {
      fn = fns[j];
      fns[j] = extractPlaceholder(fn) || fn;
    }
    eventList.push([eventName, delay, fns]);
  }
  return eventList;
}

function containsEvent(eventNames, expected) {
  if (!Array.isArray(expected)) expected = [expected];
  var eventList = splitEvents(eventNames)
    , i, j, eventName
  for (i = eventList.length; i--;) {
    eventName = eventList[i][0];
    for (j = expected.length; j--;) {
      if (eventName === expected[j]) return true;
    }
  }
  return false;
}

function addDomEvent(events, attrs, eventNames, match, options) {
  var eventList = splitEvents(eventNames)
    , args, name;

  if (match) {
    name = match.name;

    if (~name.indexOf('(')) {
      args = pathFnArgs(name);
      if (!args.length) return;

      events.push(function(ctx, modelEvents, dom, pathMap, view) {
        var id = attrs._id || attrs.id
          , paths = []
          , arg, path, pathId, event, eventName, eventOptions, i, j;
        options.setValue = function(model, value) {
          return setBoundFn(view, ctx, model, name, value);
        }
        for (i = args.length; i--;) {
          arg = args[i];
          path = ctxPath(view, ctx, arg);
          paths.push(path);
          pathId = pathMap.id(path);
          for (j = eventList.length; j--;) {
            event = eventList[j];
            eventName = event[0];
            eventOptions = util.mergeInto({view: view, ctx: ctx, pathId: pathId, delay: event[1]}, options);
            dom.bind(eventName, id, eventOptions);
          }
        }
      });
      return;
    }

    events.push(function(ctx, modelEvents, dom, pathMap, view) {
      var id = attrs._id || attrs.id
        , pathId = pathMap.id(ctxPath(view, ctx, name))
        , event, eventName, eventOptions, i;
      for (i = eventList.length; i--;) {
        event = eventList[i];
        eventName = event[0];
        eventOptions = util.mergeInto({view: view, ctx: ctx, pathId: pathId, delay: event[1]}, options);
        dom.bind(eventName, id, eventOptions);
      }
    });
    return;
  }

  events.push(function(ctx, modelEvents, dom, pathMap, view) {
    var id = attrs._id || attrs.id
      , pathId = pathMap.id(ctxPath(view, ctx, '.'))
      , event, eventName, eventOptions, i;
    for (i = eventList.length; i--;) {
      event = eventList[i];
      eventName = event[0];
      eventOptions = fnListener(view, ctx, event[2], dom);
      eventOptions.delay = event[1];
      util.mergeInto(eventOptions, options);
      util.mergeInto(eventOptions, {view: view, ctx: ctx, pathId: pathId});
      dom.bind(eventName, id, eventOptions);
    }
  });
}

function eachFnListener(view, ctx, fnObj, dom) {
  var fnName, fn, fnCtxs, i, fnCtx;

  fnName = typeof fnObj === 'object'
    ? dataValue(view, ctx, view.model, fnObj.name)
    : fnName = fnObj;

  // If a placeholder for an event name does not have a value, do nothing
  if (!fnName) return empty;

  // See if it is a built-in function
  fn = dom && dom.fns[fnName];

  // Lookup the function name on the component script or app

  // TODO: This simply looks in the local scope for the function
  // and then goes up the scope if a function name is not found.
  // Better would be to actually figure out the scope of where the
  // function name is specfied, since there could easily be namespace
  // conflicts between functions in a component and functions in an
  // app using that component. How to implement this correctly is not
  // obvious at the moment.
  if (!fn) {
    fnCtxs = ctx.$fnCtx;
    for (i = fnCtxs.length; i--;) {
      fnCtx = fnCtxs[i];
      fn = fnCtx[fnName] || viewPath.lookup(fnName, fnCtx);
      if (fn) break;
    }
  }
  if (!fn) throw new Error('Bound function not found: ' + fnName);

  // Bind the listener to the app or component object on which it
  // was defined so that the `this` context will be the instance
  return fn.bind(fnCtx);
}

function fnListener(view, ctx, fnNames, dom) {
  var listener = {
    fn: function() {
      var len = fnNames.length
        , args = arraySlice.call(arguments)
        , i, fn, boundFns

      if (len === 0) {
        // Don't do anything if no handler functions were specified
        return listener.fn = empty;

      } else if (len === 1) {
        fn = eachFnListener(view, ctx, fnNames[0], dom);

      } else {
        boundFns = [];
        for (i = len; i--;) {
          boundFns.push(eachFnListener(view, ctx, fnNames[i], dom));
        }
        fn = function() {
          var args = arraySlice.call(arguments)
          for (var i = boundFns.length; i--;) {
            boundFns[i].apply(null, args);
          }
        }
      }

      listener.fn = fn;
      fn.apply(null, args);
    }
  };
  return listener;
}

function empty() {}

},{"racer":"CsQUzZ","./viewPath":53}],53:[function(require,module,exports){
var trimLeading = require('html-util').trimLeading;

exports.wrapRemainder = wrapRemainder;
exports.extractPlaceholder = extractPlaceholder;
exports.pathFnArgs = pathFnArgs;
exports.squareBracketsArgs = squareBracketsArgs;
exports.ctxPath = ctxPath;
exports.getValue = getValue;
exports.dataValue = dataValue;
exports.setBoundFn = setBoundFn;
exports.lookup = lookup;
exports.replaceSquareBrackets = replaceSquareBrackets;

function wrapRemainder(tagName, remainder) {
  if (!remainder) return false;
  return !(new RegExp('^<\/' + tagName, 'i')).test(remainder);
}

var openPlaceholder = /^([\s\S]*?)(\{{1,3})\s*([\s\S]*)/
  , aliasContent = /^([\s\S]*)\s+as\s+:(\S+)\s*$/
  , blockContent = /^([\#\/]?)(else\sif|if|else|unless|each|with|unescaped)?\s*([\s\S]*?)\s*$/
  , closeMap = { 1: '}', 2: '}}' }
function extractPlaceholder(text) {
  var match = openPlaceholder.exec(text);
  if (!match) return;
  var pre = match[1]
    , open = match[2]
    , remainder = match[3]
    , openLen = open.length
    , bound = openLen === 1
    , end = matchBraces(remainder, openLen, 0, '{', '}')
    , endInner = end - openLen
    , inner = remainder.slice(0, endInner)
    , post = remainder.slice(end)
    , alias, hash, type, name, escaped;

  if (/["{[]/.test(inner)) {
    // Make sure that we didn't accidentally match a JSON literal
    try {
      JSON.parse(open + inner + closeMap[openLen]);
      return;
    } catch (e) {}
  }

  match = aliasContent.exec(inner);
  if (match) {
    inner = match[1];
    alias = match[2];
  }

  match = blockContent.exec(inner)
  if (!match) return;
  hash = match[1];
  type = match[2];
  name = match[3];

  escaped = true;
  if (type === 'unescaped') {
    escaped = false;
    type = '';
  }
  if (bound) name = name.replace(/\bthis\b/, '.');
  return {
    pre: pre
  , post: post
  , bound: bound
  , alias: alias
  , hash: hash
  , type: type
  , name: name
  , escaped: escaped
  , source: text
  };
}

function matchBraces(text, num, i, openChar, closeChar) {
  var close, hasClose, hasOpen, open;
  i++;
  while (num) {
    close = text.indexOf(closeChar, i);
    open = text.indexOf(openChar, i);
    hasClose = ~close;
    hasOpen = ~open;
    if (hasClose && (!hasOpen || (close < open))) {
      i = close + 1;
      num--;
      continue;
    } else if (hasOpen) {
      i = open + 1;
      num++;
      continue;
    } else {
      return -1;
    }
  }
  return i;
}

var fnCall = /^([^(]+)\s*\(\s*([\s\S]*?)\s*\)\s*$/
  , argSeparator = /\s*([,(])\s*/g
  , notSeparator = /[^,\s]/g
  , notPathArg = /(?:^['"\d\-[{])|(?:^null$)|(?:^true$)|(?:^false$)/;

function fnArgs(inner) {
  var args = []
    , lastIndex = 0
    , match, end, last;
  while (match = argSeparator.exec(inner)) {
    if (match[1] === '(') {
      end = matchBraces(inner, 1, argSeparator.lastIndex, '(', ')');
      args.push(inner.slice(lastIndex, end));
      notSeparator.lastIndex = end;
      lastIndex = argSeparator.lastIndex =
        notSeparator.test(inner) ? notSeparator.lastIndex - 1 : end;
      continue;
    }
    args.push(inner.slice(lastIndex, match.index));
    lastIndex = argSeparator.lastIndex;
  }
  last = inner.slice(lastIndex);
  if (last) args.push(last);
  return args;
}

function fnCallError(name) {
  throw new Error('malformed view function call: ' + name);
}

function fnArgValue(view, ctx, model, name, arg) {
  var literal = literalValue(arg);
  if (literal !== void 0) return literal;

  var pathMap = model.__pathMap;
  if (!pathMap) return dataValue(view, ctx, model, arg);

  var argIds = ctx.hasOwnProperty('$fnArgIds') ?
    ctx.$fnArgIds : (ctx.$fnArgIds = {});
  var pathId = argIds[arg];
  var path;
  if (pathId) {
    path = pathMap.paths[pathId];
  } else {
    path = ctxPath(view, ctx, arg);
    argIds[arg] = pathMap.id(path);
  }
  return dataValue(view, ctx, model, path);
}

function fnValue(view, ctx, model, name) {
  var match = fnCall.exec(name) || fnCallError(name)
    , fnName = match[1]
    , args = fnArgs(match[2])
    , fn, fnName, i;
  for (i = args.length; i--;) {
    args[i] = fnArgValue(view, ctx, model, name, args[i]);
  }
  if (!(fn = view.getFns[fnName])) {
    throw new Error('view function "' + fnName + '" not found for call: ' + name);
  }
  return fn.apply({view: view, ctx: ctx, model: model}, args);
}

function pathFnArgs(name, paths) {
  var match = fnCall.exec(name) || fnCallError(name)
    , args = fnArgs(match[2])
    , i, arg;
  if (paths == null) paths = [];
  for (i = args.length; i--;) {
    arg = args[i];
    if (notPathArg.test(arg)) continue;
    if (~arg.indexOf('(')) {
      pathFnArgs(arg, paths);
      continue;
    }
    paths.push(arg);
  }
  return paths;
}

function relativePath(view, ctx, i, remainder) {
  var name = ctx.$paths[i - 1] + remainder;

  // pathMap is only created in the browser
  var pathMap = view.model.__pathMap;
  if (!pathMap) return name;
  var pathId = ctx.$pathIds[name] || (ctx.$pathIds[name] = pathMap.id(name));
  return pathMap.paths[pathId];
}

function macroName(view, ctx, name) {
  if (name.charAt(0) !== '@') return;

  var segments = name.slice(1).split('.');
  var base = segments.shift().toLowerCase();
  var value = lookup(base, ctx.$macroCtx);
  var matchName = value && value.$matchName;
  var remainder = segments.join('.');

  if (matchName) {
    if (!remainder) return value;
    return {$matchName: matchName + '.' + remainder};
  }
  return (remainder) ? base + '.' + remainder : base;
}

function ctxPath(view, ctx, name) {
  var isWildcard = name.charAt(name.length - 1) === '*';
  if (isWildcard) name = name.slice(0, -1);

  var macroPath = macroName(view, ctx, name);
  if (macroPath && macroPath.$matchName) name = macroPath.$matchName;

  var firstChar = name.charAt(0)
    , i, aliasName, remainder

  // Resolve path aliases
  if (firstChar === ':') {
    if (~(i = name.search(/[.[]/))) {
      aliasName = name.slice(1, i);
      remainder = name.slice(i);
    } else {
      aliasName = name.slice(1);
      remainder = '';
    }
    aliasName = aliasName;
    i = ctx.$paths.length - ctx.$aliases[aliasName];
    if (i !== i) throw new Error('Cannot find alias: ' + name);

    name = relativePath(view, ctx, i, remainder);

  // Resolve relative paths
  } else if (firstChar === '.') {
    i = 0;
    while (name.charAt(i) === '.') {
      i++;
    }
    remainder = i === name.length ? '' : name.slice(i - 1);

    name = relativePath(view, ctx, i, remainder);
  }

  name = replaceSquareBrackets(view, ctx, name);
  if (isWildcard) name += '*';
  return name;
}

function replaceSquareBrackets(view, ctx, name) {
  if (!name) return '';
  var i = name.indexOf('[');
  if (i === -1) return name;

  var end = matchBraces(name, 1, i, '[', ']');
  // This shouldn't normally happen, but just in case return
  if (end === -1) return;
  var before = name.slice(0, i);
  var inside = name.slice(i + 1, end - 1);
  var after = name.slice(end);

  name = replaceSquareBrackets(view, ctx, inside);
  var value = getValue(view, ctx, view.model, name);
  name = (value == null) ? '$null' : value;
  var out = (before) ? before + '.' + name : name;

  while (after) {
    i = after.indexOf('[');
    if (i === -1) return out + after;

    name = after;
    end = matchBraces(name, 1, i, '[', ']');
    if (end === -1) return;
    before = name.slice(0, i);
    inside = name.slice(i + 1, end - 1);
    after = name.slice(end);

    if (before) out += before;

    name = replaceSquareBrackets(view, ctx, inside);
    value = getValue(view, ctx, view.model, name);
    value = (value == null) ? '$null' : value;
    out += '.' + value;
  }
  return out;
}

function squareBracketsArgs(name, paths) {
  paths || (paths = []);

  while (name) {
    i = name.indexOf('[');
    if (i === -1) return paths;

    end = matchBraces(name, 1, i, '[', ']');
    if (end === -1) return paths;
    inside = name.slice(i + 1, end - 1);
    name = name.slice(end);

    if (inside.indexOf('[') === -1) {
      paths.push(inside);
    } else {
      squareBracketsArgs(inside, paths);
    }
  }
  return paths;
}

function escapeValue(value, escape) {
  return escape ? escape(value) : value;
}

function literalValue(value) {
  if (value === 'null') return null;
  if (value === 'true') return true;
  if (value === 'false') return false;
  var firstChar = value.charAt(0)
    , match;
  if (firstChar === "'") {
    match = /^'(.*)'$/.exec(value) || fnCallError(value);
    return match[1];
  }
  if (firstChar === '"') {
    match = /^"(.*)"$/.exec(value) || fnCallError(value);
    return match[1];
  }
  if (/^[\d\-]/.test(firstChar) && !isNaN(value)) {
    return +value;
  }
  if (firstChar === '[' || firstChar === '{') {
    try {
      return JSON.parse(value);
    } catch (e) {}
  }
  return undefined;
}

function getValue(view, ctx, model, name, escape, forceEscape) {
  var literal = literalValue(name)
  if (literal === undefined) {
    return dataValue(view, ctx, model, name, escape, forceEscape);
  }
  return literal;
}

function dataValue(view, ctx, model, name, escape, forceEscape) {
  var macroPath, path, value;
  if (!name) return;
  if (~name.indexOf('(')) {
    value = fnValue(view, ctx, model, name);
    return escapeValue(value, escape);
  }
  path = ctxPath(view, ctx, name);
  macroPath = macroName(view, ctx, path);
  if (macroPath) {
    if (macroPath.$matchName) {
      path = macroPath.$matchName;
    } else {
      value = lookup(macroPath, ctx.$macroCtx);
      if (typeof value === 'function') {
        if (value.unescaped && !forceEscape) return value(ctx, model);
        value = value(ctx, model);
      }
      return escapeValue(value, escape);
    }
  }
  value = lookup(path, ctx);
  if (value === void 0) value = model.get(path)
  return escapeValue(value, escape);
}

function setBoundFn(view, ctx, model, name, value) {
  var match = fnCall.exec(name) || fnCallError(name)
    , fnName = match[1]
    , args = fnArgs(match[2])
    , get = view.getFns[fnName]
    , set = view.setFns[fnName]
    , numInputs = set && set.length - 1
    , arg, i, inputs, out, key, path, len;

  if (!(get && set)) {
    throw new Error('view function "' + fnName + '" setter not found for binding to: ' + name);
  }

  if (numInputs) {
    inputs = [value];
    i = 0;
    while (i < numInputs) {
      inputs.push(fnArgValue(view, ctx, model, name, args[i++]));
    }
    out = set.apply(null, inputs);
  } else {
    out = set(value);
  }
  if (!out) return;

  for (key in out) {
    value = out[key];
    arg = args[key];
    if (~arg.indexOf('(')) {
      setBoundFn(view, ctx, model, arg, value);
      continue;
    }
    if (value === void 0 || notPathArg.test(arg)) continue;
    path = ctxPath(view, ctx, arg);
    if (model.get(path) === value) continue;
    model.set(path, value);
  }
}

function lookup(path, obj) {
  if (!path || !obj) return;
  if (path.indexOf('.') === -1) return obj[path];

  var parts = path.split('.');
  for (var i = 0, l = parts.length; i < l; i++) {
    if (!obj) return obj;

    var prop = parts[i];
    obj = obj[prop];
  }
  return obj;
}

},{"html-util":55}],55:[function(require,module,exports){
var entityCode = require('./entityCode')
  , parse = require('./parse')

module.exports = {
  parse: parse
, escapeHtml: escapeHtml
, escapeAttribute: escapeAttribute
, unescapeEntities: unescapeEntities
, isVoid: isVoid
, conditionalComment: conditionalComment
, trimLeading: trimLeading
, trimText: trimText
, trimTag: trimTag
, minify: minify
}

function escapeHtml(value) {
  if (value == null) return ''

  return value
    .toString()
    .replace(/&(?!\s)|</g, function(match) {
      return match === '&' ? '&amp;' : '&lt;'
    })
}

function escapeAttribute(value) {
  if (value == null || value === '') return '""'

  value = value
    .toString()
    .replace(/&(?!\s)|"/g, function(match) {
      return match === '&' ? '&amp;' : '&quot;'
    })
  return /[ =<>']/.test(value) ? '"' + value + '"' : value
}

// Based on:
// http://code.google.com/p/jslibs/wiki/JavascriptTips#Escape_and_unescape_HTML_entities
function unescapeEntities(html) {
  return html.replace(/&([^;]+);/g, function(match, entity) {
    var charCode = entity.charAt(0) === '#'
          ? entity.charAt(1) === 'x'
            ? entity.slice(2, 17)
            : entity.slice(1)
          : entityCode[entity]
    return String.fromCharCode(charCode)
  })
}

var voidElement = {
  area: 1
, base: 1
, br: 1
, col: 1
, command: 1
, embed: 1
, hr: 1
, img: 1
, input: 1
, keygen: 1
, link: 1
, meta: 1
, param: 1
, source: 1
, track: 1
, wbr: 1
}
function isVoid(name) {
  return name in voidElement
}

// Assume any HTML comment that starts with `<!--[` or ends with `]-->`
// is a conditional comment. This can also be used to keep comments in
// minified HTML, such as `<!--[ Copyright John Doe, MIT Licensed ]-->`
function conditionalComment(tag) {
  return /(?:^<!--\[)|(?:\]-->$)/.test(tag)
}

// Remove leading whitespace and newlines from a string. Whitespace at the end
// of a line will be maintained
function trimLeading(text) {
  return text ? text.replace(/\r?\n\s*/g, '') : ''
}

// Remove leading & trailing whitespace and newlines from a string
function trimText(text) {
  return text ? text.replace(/\s*\r?\n\s*/g, '') : ''
}

// Within a tag, remove leading & trailing whitespace. Keep a linebreak, since
// this could be the separator between attributes
function trimTag(tag) {
  return tag.replace(/(?:\s*\r?\n\s*)+/g, '\n')
}

// Remove linebreaks, leading & trailing space, and comments. Maintain a
// linebreak between HTML tag attributes and maintain conditional comments.
function minify(html) {
  var minified = ''
    , minifyContent = true

  parse(html, {
    start: function(tag, tagName, attrs) {
      minifyContent = !('x-no-minify' in attrs)
      minified += trimTag(tag)
    }
  , end: function(tag) {
      minified += trimTag(tag)
    }
  , text: function(text) {
      minified += minifyContent ? trimText(text) : text
    }
  , comment: function(tag) {
      if (conditionalComment(tag)) minified += tag
    }
  , other: function(tag) {
      minified += tag
    }
  })
  return minified
}

},{"./entityCode":61,"./parse":62}],49:[function(require,module,exports){

/**
 * Module dependencies.
 */

var utils = require('../utils');

/**
 * Expose `Route`.
 */

module.exports = Route;

/**
 * Initialize `Route` with the given HTTP `method`, `path`,
 * and an array of `callbacks` and `options`.
 *
 * Options:
 *
 *   - `sensitive`    enable case-sensitive routes
 *   - `strict`       enable strict matching for trailing slashes
 *
 * @param {String} method
 * @param {String} path
 * @param {Array} callbacks
 * @param {Object} options.
 * @api private
 */

function Route(method, path, callbacks, options) {
  options = options || {};
  this.path = path;
  this.method = method;
  this.callbacks = callbacks;
  this.regexp = utils.pathRegexp(path
    , this.keys = []
    , options.sensitive
    , options.strict);
}

/**
 * Check if this route matches `path`, if so
 * populate `.params`.
 *
 * @param {String} path
 * @return {Boolean}
 * @api private
 */

Route.prototype.match = function(path){
  var keys = this.keys
    , params = this.params = []
    , m = this.regexp.exec(path);

  if (!m) return false;

  for (var i = 1, len = m.length; i < len; ++i) {
    var key = keys[i - 1];

    var val = 'string' == typeof m[i]
      ? decodeURIComponent(m[i])
      : m[i];

    if (key) {
      params[key.name] = val;
    } else {
      params.push(val);
    }
  }

  return true;
};

},{"../utils":63}],61:[function(require,module,exports){
module.exports = {
  quot: 0x0022
, amp: 0x0026
, apos: 0x0027
, lpar: 0x0028
, rpar: 0x0029
, lt: 0x003C
, gt: 0x003E
, nbsp: 0x00A0
, iexcl: 0x00A1
, cent: 0x00A2
, pound: 0x00A3
, curren: 0x00A4
, yen: 0x00A5
, brvbar: 0x00A6
, sect: 0x00A7
, uml: 0x00A8
, copy: 0x00A9
, ordf: 0x00AA
, laquo: 0x00AB
, not: 0x00AC
, shy: 0x00AD
, reg: 0x00AE
, macr: 0x00AF
, deg: 0x00B0
, plusmn: 0x00B1
, sup2: 0x00B2
, sup3: 0x00B3
, acute: 0x00B4
, micro: 0x00B5
, para: 0x00B6
, middot: 0x00B7
, cedil: 0x00B8
, sup1: 0x00B9
, ordm: 0x00BA
, raquo: 0x00BB
, frac14: 0x00BC
, frac12: 0x00BD
, frac34: 0x00BE
, iquest: 0x00BF
, Agrave: 0x00C0
, Aacute: 0x00C1
, Acirc: 0x00C2
, Atilde: 0x00C3
, Auml: 0x00C4
, Aring: 0x00C5
, AElig: 0x00C6
, Ccedil: 0x00C7
, Egrave: 0x00C8
, Eacute: 0x00C9
, Ecirc: 0x00CA
, Euml: 0x00CB
, Igrave: 0x00CC
, Iacute: 0x00CD
, Icirc: 0x00CE
, Iuml: 0x00CF
, ETH: 0x00D0
, Ntilde: 0x00D1
, Ograve: 0x00D2
, Oacute: 0x00D3
, Ocirc: 0x00D4
, Otilde: 0x00D5
, Ouml: 0x00D6
, times: 0x00D7
, Oslash: 0x00D8
, Ugrave: 0x00D9
, Uacute: 0x00DA
, Ucirc: 0x00DB
, Uuml: 0x00DC
, Yacute: 0x00DD
, THORN: 0x00DE
, szlig: 0x00DF
, agrave: 0x00E0
, aacute: 0x00E1
, acirc: 0x00E2
, atilde: 0x00E3
, auml: 0x00E4
, aring: 0x00E5
, aelig: 0x00E6
, ccedil: 0x00E7
, egrave: 0x00E8
, eacute: 0x00E9
, ecirc: 0x00EA
, euml: 0x00EB
, igrave: 0x00EC
, iacute: 0x00ED
, icirc: 0x00EE
, iuml: 0x00EF
, eth: 0x00F0
, ntilde: 0x00F1
, ograve: 0x00F2
, oacute: 0x00F3
, ocirc: 0x00F4
, otilde: 0x00F5
, ouml: 0x00F6
, divide: 0x00F7
, oslash: 0x00F8
, ugrave: 0x00F9
, uacute: 0x00FA
, ucirc: 0x00FB
, uuml: 0x00FC
, yacute: 0x00FD
, thorn: 0x00FE
, yuml: 0x00FF
, OElig: 0x0152
, oelig: 0x0153
, Scaron: 0x0160
, scaron: 0x0161
, Yuml: 0x0178
, fnof: 0x0192
, circ: 0x02C6
, tilde: 0x02DC
, Alpha: 0x0391
, Beta: 0x0392
, Gamma: 0x0393
, Delta: 0x0394
, Epsilon: 0x0395
, Zeta: 0x0396
, Eta: 0x0397
, Theta: 0x0398
, Iota: 0x0399
, Kappa: 0x039A
, Lambda: 0x039B
, Mu: 0x039C
, Nu: 0x039D
, Xi: 0x039E
, Omicron: 0x039F
, Pi: 0x03A0
, Rho: 0x03A1
, Sigma: 0x03A3
, Tau: 0x03A4
, Upsilon: 0x03A5
, Phi: 0x03A6
, Chi: 0x03A7
, Psi: 0x03A8
, Omega: 0x03A9
, alpha: 0x03B1
, beta: 0x03B2
, gamma: 0x03B3
, delta: 0x03B4
, epsilon: 0x03B5
, zeta: 0x03B6
, eta: 0x03B7
, theta: 0x03B8
, iota: 0x03B9
, kappa: 0x03BA
, lambda: 0x03BB
, mu: 0x03BC
, nu: 0x03BD
, xi: 0x03BE
, omicron: 0x03BF
, pi: 0x03C0
, rho: 0x03C1
, sigmaf: 0x03C2
, sigma: 0x03C3
, tau: 0x03C4
, upsilon: 0x03C5
, phi: 0x03C6
, chi: 0x03C7
, psi: 0x03C8
, omega: 0x03C9
, thetasym: 0x03D1
, upsih: 0x03D2
, piv: 0x03D6
, ensp: 0x2002
, emsp: 0x2003
, thinsp: 0x2009
, zwnj: 0x200C
, zwj: 0x200D
, lrm: 0x200E
, rlm: 0x200F
, ndash: 0x2013
, mdash: 0x2014
, lsquo: 0x2018
, rsquo: 0x2019
, sbquo: 0x201A
, ldquo: 0x201C
, rdquo: 0x201D
, bdquo: 0x201E
, dagger: 0x2020
, Dagger: 0x2021
, bull: 0x2022
, hellip: 0x2026
, permil: 0x2030
, prime: 0x2032
, Prime: 0x2033
, lsaquo: 0x2039
, rsaquo: 0x203A
, oline: 0x203E
, frasl: 0x2044
, euro: 0x20AC
, image: 0x2111
, weierp: 0x2118
, real: 0x211C
, trade: 0x2122
, alefsym: 0x2135
, larr: 0x2190
, uarr: 0x2191
, rarr: 0x2192
, darr: 0x2193
, harr: 0x2194
, crarr: 0x21B5
, lArr: 0x21D0
, uArr: 0x21D1
, rArr: 0x21D2
, dArr: 0x21D3
, hArr: 0x21D4
, forall: 0x2200
, part: 0x2202
, exist: 0x2203
, empty: 0x2205
, nabla: 0x2207
, isin: 0x2208
, notin: 0x2209
, ni: 0x220B
, prod: 0x220F
, sum: 0x2211
, minus: 0x2212
, lowast: 0x2217
, radic: 0x221A
, prop: 0x221D
, infin: 0x221E
, ang: 0x2220
, and: 0x2227
, or: 0x2228
, cap: 0x2229
, cup: 0x222A
, int: 0x222B
, there4: 0x2234
, sim: 0x223C
, cong: 0x2245
, asymp: 0x2248
, ne: 0x2260
, equiv: 0x2261
, le: 0x2264
, ge: 0x2265
, sub: 0x2282
, sup: 0x2283
, nsub: 0x2284
, sube: 0x2286
, supe: 0x2287
, oplus: 0x2295
, otimes: 0x2297
, perp: 0x22A5
, sdot: 0x22C5
, lceil: 0x2308
, rceil: 0x2309
, lfloor: 0x230A
, rfloor: 0x230B
, lang: 0x2329
, rang: 0x232A
, loz: 0x25CA
, spades: 0x2660
, clubs: 0x2663
, hearts: 0x2665
, diams: 0x2666
}

},{}],62:[function(require,module,exports){
var startTag = /^<([^\s=\/!>]+)((?:\s+[^\s=\/>]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+)?)?)*)\s*(\/?)\s*>/
  , endTag = /^<\/([^\s=\/!>]+)[^>]*>/
  , comment = /^<!--([\s\S]*?)-->/
  , commentInside = /<!--[\s\S]*?-->/
  , other = /^<([\s\S]*?)>/
  , attr = /([^\s=]+)(?:\s*(=)\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|([^>\s]+))?)?/g
  , rawTagsDefault = /^(style|script)$/i

function empty() {}

function matchEndDefault(tagName) {
  return new RegExp('</' + tagName, 'i')
}

function onStartTag(html, match, handler) {
  var attrs = {}
    , tag = match[0]
    , tagName = match[1]
    , remainder = match[2]
  html = html.slice(tag.length)

  remainder.replace(attr, function(match, name, equals, attr0, attr1, attr2) {
    attrs[name.toLowerCase()] = attr0 || attr1 || attr2 || (equals ? '' : null)
  })
  handler(tag, tagName.toLowerCase(), attrs, html)

  return html
}

function onTag(html, match, handler) {
  var tag = match[0]
    , data = match[1]
  html = html.slice(tag.length)

  handler(tag, data, html)

  return html
}

function onText(html, index, isRawText, handler) {
  var text
  if (~index) {
    text = html.slice(0, index)
    html = html.slice(index)
  } else {
    text = html
    html = ''
  }

  if (text) handler(text, isRawText, html)

  return html
}

function rawEnd(html, ending, offset) {
  offset || (offset = 0)
  var index = html.search(ending)
    , commentMatch = html.match(commentInside)
    , commentEnd
  // Make sure that the ending condition isn't inside of an HTML comment
  if (commentMatch && commentMatch.index < index) {
    commentEnd = commentMatch.index + commentMatch[0].length
    offset += commentEnd
    html = html.slice(commentEnd)
    return rawEnd(html, ending, offset)
  }
  return index + offset
}

module.exports = function(html, options) {
  if (options == null) options = {}

  if (!html) return

  var startHandler = options.start || empty
    , endHandler = options.end || empty
    , textHandler = options.text || empty
    , commentHandler = options.comment || empty
    , otherHandler = options.other || empty
    , matchEnd = options.matchEnd || matchEndDefault
    , errorHandler = options.error
    , rawTags = options.rawTags || rawTagsDefault
    , index, last, match, tagName, err

  while (html) {
    if (html === last) {
      err = new Error('HTML parse error: ' + html)
      if (errorHandler) {
        errorHandler(err)
      } else {
        throw err
      }
    }
    last = html

    if (html[0] === '<') {
      if (match = html.match(startTag)) {
        html = onStartTag(html, match, startHandler)

        tagName = match[1]
        if (rawTags.test(tagName)) {
          index = rawEnd(html, matchEnd(tagName))
          html = onText(html, index, true, textHandler)
        }
        continue
      }

      if (match = html.match(endTag)) {
        match[1] = match[1].toLowerCase()  // tagName
        html = onTag(html, match, endHandler)
        continue
      }

      if (match = html.match(comment)) {
        html = onTag(html, match, commentHandler)
        continue
      }

      if (match = html.match(other)) {
        html = onTag(html, match, otherHandler)
        continue
      }
    }

    index = html.indexOf('<')
    html = onText(html, index, false, textHandler)
  }
}

},{}],64:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var util = require('./util');

module.exports = Channel;

function Channel(socket) {
  EventEmitter.call(this);

  this.socket = socket;
  this.messages = new Messages;

  var channel = this;
  var onmessage = socket.onmessage;
  socket.onmessage = function(data) {
    if (data && data.racer) return channel._onMessage(data);
    onmessage && onmessage.call(socket, data);
  };
}

util.mergeInto(Channel.prototype, EventEmitter.prototype);

Channel.prototype.send = function(name, data, cb) {
  var message = this.messages.add(name, data, cb);
  // Proactively call the toJSON function, since the Google Closure JSON
  // serializer doesn't check for it
  this.socket.send(message.toJSON());
};

Channel.prototype._reply = function(id, name, data) {
  var message = new Message(id, true, name, data);
  this.socket.send(message.toJSON());
};

Channel.prototype._onMessage = function(data) {
  if (data.ack) {
    var message = this.messages.remove(data.id);
    if (message && message.cb) message.cb.apply(data.data);
    return;
  }
  var name = data.racer;
  if (data.cb) {
    var channel = this;
    var hasListeners = this.emit(name, data.data, function() {
      var args = Array.prototype.slice.call(arguments);
      channel._reply(data.id, name, args);
    });
    if (!hasListeners) this._reply(data.id, name);
  } else {
    this.emit(name, data.data);
    this._reply(data.id, name);
  }
};

function MessagesMap() {}

function Messages() {
  this.map = new MessagesMap();
  this.idCount = 0;
}
Messages.prototype.id = function() {
  return (++this.idCount).toString(36);
};
Messages.prototype.add = function(name, data, cb) {
  var message = new Message(this.id(), false, name, data, cb);
  this.map[message.id] = message;
  return message;
};
Messages.prototype.remove = function(id) {
  var message = this.map[id];
  delete this.map[id];
  return message;
};

function Message(id, ack, name, data, cb) {
  this.id = id;
  this.ack = ack;
  this.name = name;
  this.data = data;
  this.cb = cb;
}
Message.prototype.toJSON = function() {
  return {
    racer: this.name
  , id: this.id
  , data: this.data
  , ack: +this.ack
  , cb: (this.cb) ? 1 : 0
  };
};

},{"events":12,"./util":14}],56:[function(require,module,exports){
var Doc = require('./Doc');
var util = require('../util');

module.exports = LocalDoc;

function LocalDoc(model, collectionName, id, snapshot) {
  Doc.call(this, model, collectionName, id);
  this.snapshot = snapshot;
  this._updateCollectionData();
}

LocalDoc.prototype = new Doc;

LocalDoc.prototype._updateCollectionData = function() {
  this.collectionData[this.id] = this.snapshot;
};

LocalDoc.prototype.set = function(segments, value, cb) {
  function set(node, key) {
    var previous = node[key];
    node[key] = value;
    return previous;
  }
  return this._apply(segments, set, cb);
};

LocalDoc.prototype.del = function(segments, cb) {
  // Don't do anything if the value is already undefined, since
  // apply creates objects as it traverses, and the del method
  // should not create anything
  var previous = this.get(segments);
  if (previous === void 0) {
    cb();
    return;
  }
  function del(node, key) {
    delete node[key];
    return previous;
  }
  return this._apply(segments, del, cb);
};

LocalDoc.prototype.increment = function(segments, byNumber, cb) {
  var self = this;
  function validate(value) {
    if (typeof value === 'number' || value == null) return;
    return new TypeError(self._errorMessage(
      'increment on non-number', segments, value
    ));
  }
  function increment(node, key) {
    var value = (node[key] || 0) + byNumber;
    node[key] = value;
    return value;
  }
  return this._validatedApply(segments, validate, increment, cb);
};

LocalDoc.prototype.push = function(segments, value, cb) {
  function push(arr) {
    return arr.push(value);
  }
  return this._arrayApply(segments, push, cb);
};

LocalDoc.prototype.unshift = function(segments, value, cb) {
  function unshift(arr) {
    return arr.unshift(value);
  }
  return this._arrayApply(segments, unshift, cb);
};

LocalDoc.prototype.insert = function(segments, index, values, cb) {
  function insert(arr) {
    arr.splice.apply(arr, [index, 0].concat(values));
    return arr.length;
  }
  return this._arrayApply(segments, insert, cb);
};

LocalDoc.prototype.pop = function(segments, cb) {
  function pop(arr) {
    return arr.pop();
  }
  return this._arrayApply(segments, pop, cb);
};

LocalDoc.prototype.shift = function(segments, cb) {
  function shift(arr) {
    return arr.shift();
  }
  return this._arrayApply(segments, shift, cb);
};

LocalDoc.prototype.remove = function(segments, index, howMany, cb) {
  function remove(arr) {
    return arr.splice(index, howMany);
  }
  return this._arrayApply(segments, remove, cb);
};

LocalDoc.prototype.move = function(segments, from, to, howMany, cb) {
  function move(arr) {
    // Remove from old location
    var values = arr.splice(from, howMany);
    // Insert in new location
    arr.splice.apply(arr, [to, 0].concat(values));
    return values;
  }
  return this._arrayApply(segments, move, cb);
};

LocalDoc.prototype.stringInsert = function(segments, index, value, cb) {
  var self = this;
  function validate(value) {
    if (typeof value === 'string' || value == null) return;
    return new TypeError(self._errorMessage(
      'stringInsert on non-string', segments, value
    ));
  }
  function stringInsert(node, key) {
    var previous = node[key];
    if (previous == null) {
      node[key] = value;
      return previous;
    }
    node[key] = previous.slice(0, index) + value + previous.slice(index);
    return previous;
  }
  return this._validatedApply(segments, validate, stringInsert, cb);
};

LocalDoc.prototype.stringRemove = function(segments, index, howMany, cb) {
  var self = this;
  function validate(value) {
    if (typeof value === 'string' || value == null) return;
    return new TypeError(self._errorMessage(
      'stringRemove on non-string', segments, value
    ));
  }
  function stringRemove(node, key) {
    var previous = node[key];
    if (previous == null) return previous;
    if (index < 0) index += previous.length;
    node[key] = previous.slice(0, index) + previous.slice(index + howMany);
    return previous;
  }
  return this._validatedApply(segments, validate, stringRemove, cb);
};

LocalDoc.prototype.get = function(segments) {
  return util.lookup(segments, this.snapshot);
};

/**
 * @param {Array} segments is the array representing a path
 * @param {Function} fn(node, key) applies a mutation on node[key]
 * @return {Object} returns the return value of fn(node, key)
 */
LocalDoc.prototype._createImplied = function(segments, fn) {
  var node = this;
  var key = 'snapshot';
  var i = 0;
  var nextKey = segments[i++];
  while (nextKey != null) {
    // Get or create implied object or array
    node = node[key] || (node[key] = /^\d+$/.test(nextKey) ? [] : {});
    key = nextKey;
    nextKey = segments[i++];
  }
  return fn(node, key);
};

LocalDoc.prototype._apply = function(segments, fn, cb) {
  var out = this._createImplied(segments, fn);
  this._updateCollectionData();
  cb();
  return out;
};

LocalDoc.prototype._validatedApply = function(segments, validate, fn, cb) {
  var out = this._createImplied(segments, function(node, key) {
    var err = validate(node[key]);
    if (err) return cb(err);
    return fn(node, key);
  });
  this._updateCollectionData();
  cb();
  return out;
};

LocalDoc.prototype._arrayApply = function(segments, fn, cb) {
  // Lookup a pointer to the property or nested property &
  // return the current value or create a new array
  var arr = this._createImplied(segments, nodeCreateArray);

  if (!Array.isArray(arr)) {
    var message = this._errorMessage(fn.name + ' on non-array', segments, arr);
    var err = new TypeError(message);
    return cb(err);
  }
  var out = fn(arr);
  this._updateCollectionData();
  cb();
  return out;
};

function nodeCreateArray(node, key) {
  return node[key] || (node[key] = []);
}

},{"./Doc":65,"../util":14}],66:[function(require,module,exports){
/**
 * RemoteDoc adapts the ShareJS operation protocol to Racer's mutator
 * interface.
 *
 * 1. It maps Racer's mutator methods to outgoing ShareJS operations.
 * 2. It maps incoming ShareJS operations to Racer events.
 */

var Doc = require('./Doc');
var util = require('../util');

module.exports = RemoteDoc;

function RemoteDoc(model, collectionName, id, data) {
  Doc.call(this, model, collectionName, id);
  var shareDoc = this.shareDoc = model._getOrCreateShareDoc(collectionName, id, data);
  this.createdLocally = false;
  this.model = model = model.pass({$remote: true});
  this._passStringInsert = model.pass({$original: 'stringInsert'})._pass;
  this._passStringRemove = model.pass({$original: 'stringRemove'})._pass;
  this._updateCollectionData();

  var doc = this;
  shareDoc.on('op', function(op, isLocal) {
    // Don't emit on local operations, since they are emitted in the mutator
    if (isLocal) return;
    doc._updateCollectionData();
    doc._onOp(op);
  });
  shareDoc.on('del', function(isLocal, previous) {
    // Calling the shareDoc.del method does not emit an operation event,
    // so we create the appropriate event here.
    if (isLocal) return;
    doc._updateCollectionData();
    model.emit('change', [collectionName, id], [void 0, previous, model._pass]);
  });
  shareDoc.on('create', function(isLocal) {
    // Local creates should not emit an event, since they only happen
    // implicitly as a result of another mutation, and that operation will
    // emit the appropriate event. Remote creates can set the snapshot data
    // without emitting an operation event, so an event needs to be emitted
    // for them.
    if (isLocal) {
      // Track when a document was created by this client, so that we don't
      // emit a load event when subsequently subscribed
      doc.createdLocally = true;
      return;
    }
    doc._updateCollectionData();
    var value = shareDoc.snapshot;
    model.emit('change', [collectionName, id], [value, void 0, model._pass]);
  });
}

RemoteDoc.prototype = new Doc;

RemoteDoc.prototype._updateCollectionData = function() {
  this.collectionData[this.id] = this.shareDoc.snapshot;
};

RemoteDoc.prototype.set = function(segments, value, cb) {
  if (segments.length === 0 && !this.shareDoc.type) {
    this.shareDoc.create('json0', value, cb);
    this._updateCollectionData();
    return;
  }
  var previous = this._createImplied(segments);
  var lastSegment = segments[segments.length - 1];
  if (previous instanceof ImpliedOp) {
    previous.value[lastSegment] = value;
    this.shareDoc.submitOp(previous.op, cb);
    this._updateCollectionData();
    return;
  }
  var op = (isArrayIndex(lastSegment)) ?
    (previous == null) ?
      [new ListInsertOp(segments.slice(0, -1), lastSegment, value)] :
      [new ListReplaceOp(segments.slice(0, -1), lastSegment, previous, value)] :
    (previous == null) ?
      [new ObjectInsertOp(segments, value)] :
      [new ObjectReplaceOp(segments, previous, value)];
  this.shareDoc.submitOp(op, cb);
  this._updateCollectionData();
  return previous;
};

RemoteDoc.prototype.del = function(segments, cb) {
  if (segments.length === 0) {
    var previous = this.get();
    this.shareDoc.del(cb);
    this._updateCollectionData();
    return previous;
  }
  // Don't do anything if the value is already undefined, since
  // the del method should not create anything
  var previous = this.get(segments);
  if (previous === void 0) {
    cb();
    return;
  }
  var op = [new ObjectDeleteOp(segments, previous)];
  this.shareDoc.submitOp(op, cb);
  this._updateCollectionData();
  return previous;
};

RemoteDoc.prototype.increment = function(segments, byNumber, cb) {
  var previous = this._createImplied(segments);
  if (previous instanceof ImpliedOp) {
    var lastSegment = segments[segments.length - 1];
    previous.value[lastSegment] = byNumber;
    this.shareDoc.submitOp(previous.op, cb);
    this._updateCollectionData();
    return byNumber;
  }
  if (previous == null) {
    var lastSegment = segments[segments.length - 1];
    var op = (isArrayIndex(lastSegment)) ?
      [new ListInsertOp(segments.slice(0, -1), lastSegment, byNumber)] :
      [new ObjectInsertOp(segments, byNumber)];
    this.shareDoc.submitOp(op, cb);
    this._updateCollectionData();
    return byNumber;
  }
  var op = [new IncrementOp(segments, byNumber)];
  this.shareDoc.submitOp(op, cb);
  this._updateCollectionData();
  return previous + byNumber;
};

RemoteDoc.prototype.push = function(segments, value, cb) {
  var shareDoc = this.shareDoc;
  function push(arr, fnCb) {
    var op = [new ListInsertOp(segments, arr.length, value)];
    shareDoc.submitOp(op, fnCb);
    return arr.length;
  }
  return this._arrayApply(segments, push, cb);
};

RemoteDoc.prototype.unshift = function(segments, value, cb) {
  var shareDoc = this.shareDoc;
  function unshift(arr, fnCb) {
    var op = [new ListInsertOp(segments, 0, value)];
    shareDoc.submitOp(op, fnCb);
    return arr.length;
  }
  return this._arrayApply(segments, unshift, cb);
};

RemoteDoc.prototype.insert = function(segments, index, values, cb) {
  var shareDoc = this.shareDoc;
  function insert(arr, fnCb) {
    var op = createInsertOp(segments, index, values);
    shareDoc.submitOp(op, fnCb);
    return arr.length;
  }
  return this._arrayApply(segments, insert, cb);
};

function createInsertOp(segments, index, values) {
  if (!Array.isArray(values)) {
    return [new ListInsertOp(segments, index, values)];
  }
  var op = [];
  for (var i = 0, len = values.length; i < len; i++) {
    op.push(new ListInsertOp(segments, index++, values[i]));
  }
  return op;
}

RemoteDoc.prototype.pop = function(segments, cb) {
  var shareDoc = this.shareDoc;
  function pop(arr, fnCb) {
    var index = arr.length - 1;
    var value = arr[index];
    var op = [new ListRemoveOp(segments, index, value)];
    shareDoc.submitOp(op, fnCb);
    return value;
  }
  return this._arrayApply(segments, pop, cb);
};

RemoteDoc.prototype.shift = function(segments, cb) {
  var shareDoc = this.shareDoc;
  function shift(arr, fnCb) {
    var value = arr[0];
    var op = [new ListRemoveOp(segments, 0, value)];
    shareDoc.submitOp(op, fnCb);
    return value;
  }
  return this._arrayApply(segments, shift, cb);
};

RemoteDoc.prototype.remove = function(segments, index, howMany, cb) {
  var shareDoc = this.shareDoc;
  function remove(arr, fnCb) {
    var values = arr.slice(index, index + howMany);
    var op = [];
    for (var i = 0, len = values.length; i < len; i++) {
      op.push(new ListRemoveOp(segments, index, values[i]));
    }
    shareDoc.submitOp(op, fnCb);
    return values;
  }
  return this._arrayApply(segments, remove, cb);
};

RemoteDoc.prototype.move = function(segments, from, to, howMany, cb) {
  var shareDoc = this.shareDoc;
  function move(arr, fnCb) {
    // Get the return value
    var values = arr.slice(from, from + howMany);

    // Build an op that moves each item individually
    var op = [];
    for (var i = 0; i < howMany; i++) {
      op.push(new ListMoveOp(segments, (from < to) ? from : from + howMany - 1, (from < to) ? to + howMany - 1 : to));
    }
    shareDoc.submitOp(op, fnCb);

    return values;
  }
  return this._arrayApply(segments, move, cb);
};

RemoteDoc.prototype.stringInsert = function(segments, index, value, cb) {
  var previous = this._createImplied(segments);
  if (previous instanceof ImpliedOp) {
    var lastSegment = segments[segments.length - 1];
    previous.value[lastSegment] = value;
    this.shareDoc.submitOp(previous.op, cb);
    this._updateCollectionData();
    return;
  }
  if (previous == null) {
    var lastSegment = segments[segments.length - 1];
    var op = (isArrayIndex(lastSegment)) ?
      [new ListInsertOp(segments.slice(0, -1), lastSegment, value)] :
      [new ObjectInsertOp(segments, value)];
    this.shareDoc.submitOp(op, cb);
    this._updateCollectionData();
    return previous;
  }
  var op = [new StringInsertOp(segments, index, value)];
  this.shareDoc.submitOp(op, cb);
  this._updateCollectionData();
  return previous;
};

RemoteDoc.prototype.stringRemove = function(segments, index, howMany, cb) {
  var previous = this._createImplied(segments);
  if (previous instanceof ImpliedOp) return;
  if (previous == null) return previous;
  var removed = previous.slice(index, index + howMany);
  var op = [new StringRemoveOp(segments, index, removed)];
  this.shareDoc.submitOp(op, cb);
  this._updateCollectionData();
  return previous;
};

RemoteDoc.prototype.get = function(segments) {
  return util.lookup(segments, this.shareDoc.snapshot);
};

RemoteDoc.prototype._createImplied = function(segments) {
  if (!this.shareDoc.type) {
    this.shareDoc.create('json0');
  }
  var parent = this.shareDoc;
  var key = 'snapshot';
  var node = parent[key];
  var i = 0;
  var nextKey = segments[i++];
  var op, value;
  while (nextKey != null) {
    if (!node) {
      if (op) {
        value = value[key] = isArrayIndex(nextKey) ? [] : {};
      } else {
        value = isArrayIndex(nextKey) ? [] : {};
        op = (Array.isArray(parent)) ?
          new ListInsertOp(segments.slice(0, i - 2), key, value) :
          new ObjectInsertOp(segments.slice(0, i - 1), value);
      }
      node = value;
    }
    parent = node;
    key = nextKey;
    node = parent[key];
    nextKey = segments[i++];
  }
  if (op) return new ImpliedOp(op, value);
  return node;
};

function ImpliedOp(op, value) {
  this.op = op;
  this.value = value;
}

RemoteDoc.prototype._arrayApply = function(segments, fn, cb) {
  var arr = this._createImplied(segments);
  if (arr instanceof ImpliedOp) {
    this.shareDoc.submitOp(arr.op);
    arr = this.get(segments);
  } else if (arr == null) {
    var lastSegment = segments[segments.length - 1];
    var op = (isArrayIndex(lastSegment)) ?
      [new ListInsertOp(segments.slice(0, -1), lastSegment, [])] :
      [new ObjectInsertOp(segments, [])];
    this.shareDoc.submitOp(op);
    arr = this.get(segments);
  }

  if (!Array.isArray(arr)) {
    var message = this._errorMessage(fn.name + ' on non-array', segments, arr);
    var err = new TypeError(message);
    return cb(err);
  }
  var out = fn(arr, cb);
  this._updateCollectionData();
  return out;
};

RemoteDoc.prototype._onOp = function(op) {
  var item = op[0];
  var segments = [this.collectionName, this.id].concat(item.p);
  var model = this.model;

  // ObjectReplaceOp, ObjectInsertOp, or ObjectDeleteOp
  if (defined(item.oi) || defined(item.od)) {
    var value = item.oi;
    var previous = item.od;
    model.emit('change', segments, [value, previous, model._pass]);

  // ListReplaceOp
  } else if (defined(item.li) && defined(item.ld)) {
    var value = item.li;
    var previous = item.ld;
    model.emit('change', segments, [value, previous, model._pass]);

  // ListInsertOp
  } else if (defined(item.li)) {
    var index = segments[segments.length - 1];
    var values = [item.li];
    model.emit('insert', segments.slice(0, -1), [index, values, model._pass]);

  // ListRemoveOp
  } else if (defined(item.ld)) {
    var index = segments[segments.length - 1];
    var removed = [item.ld];
    model.emit('remove', segments.slice(0, -1), [index, removed, model._pass]);

  // ListMoveOp
  } else if (defined(item.lm)) {
    var from = segments[segments.length - 1];
    var to = item.lm - 1;
    var howMany = 1;
    model.emit('move', segments.slice(0, -1), [from, to, howMany, model._pass]);

  // StringInsertOp
  } else if (defined(item.si)) {
    var index = segments[segments.length - 1];
    var text = item.si;
    segments = segments.slice(0, -1);
    model.emit('stringInsert', segments, [index, text, model._pass]);
    var value = model._get(segments);
    var previous = value.slice(0, index) + value.slice(index + text.length);
    model.emit('change', segments, [value, previous, this._passStringInsert]);

  // StringRemoveOp
  } else if (defined(item.sd)) {
    var index = segments[segments.length - 1];
    var text = item.sd;
    var howMany = text.length;
    segments = segments.slice(0, -1);
    model.emit('stringRemove', segments, [index, howMany, model._pass]);
    var value = model._get(segments);
    var previous = value.slice(0, index) + text + value.slice(index);
    model.emit('change', segments, [value, previous, this._passStringRemove]);

  // IncrementOp
  } else if (defined(item.na)) {
    var value = this.get(item.p);
    var previous = value - item.na;
    model.emit('change', segments, [value, previous, model._pass]);
  }
};

function ObjectReplaceOp(segments, before, after) {
  this.p = castSegments(segments);
  this.od = before;
  this.oi = (after === void 0) ? null : after;
}
function ObjectInsertOp(segments, value) {
  this.p = castSegments(segments);
  this.oi = (value === void 0) ? null : value;
}
function ObjectDeleteOp(segments, value) {
  this.p = castSegments(segments);
  this.od = (value === void 0) ? null : value;
}
function ListReplaceOp(segments, index, before, after) {
  this.p = castSegments(segments.concat(index));
  this.ld = before;
  this.li = (after === void 0) ? null : after;
}
function ListInsertOp(segments, index, value) {
  this.p = castSegments(segments.concat(index));
  this.li = (value === void 0) ? null : value;
}
function ListRemoveOp(segments, index, value) {
  this.p = castSegments(segments.concat(index));
  this.ld = (value === void 0) ? null : value;
}
function ListMoveOp(segments, from, to) {
  this.p = castSegments(segments.concat(from));
  this.lm = to;
}
function StringInsertOp(segments, index, value) {
  this.p = castSegments(segments.concat(index));
  this.si = value;
}
function StringRemoveOp(segments, index, value) {
  this.p = castSegments(segments.concat(index));
  this.sd = value;
}
function IncrementOp(segments, byNumber) {
  this.p = castSegments(segments);
  this.na = byNumber;
}

function defined(value) {
  return value !== void 0;
}

function castSegments(segments) {
  // Cast number path segments from strings to numbers
  for (var i = segments.length; i--;) {
    var segment = segments[i];
    if (typeof segment === 'string' && isArrayIndex(segment)) {
      segments[i] = +segment;
    }
  }
  return segments;
}

function isArrayIndex(segment) {
  return (/^[0-9]+$/).test(segment);
}

},{"./Doc":65,"../util":14}],63:[function(require,module,exports){
(function(){
/**
 * Module dependencies.
 */

/**
 * toString ref.
 */

var toString = {}.toString;

/**
 * Return ETag for `body`.
 *
 * @param {String|Buffer} body
 * @return {String}
 * @api private
 */

exports.etag = function(body){
  return '"' + crc32.signed(body) + '"';
};

/**
 * Make `locals()` bound to the given `obj`.
 *
 * This is used for `app.locals` and `res.locals`.
 *
 * @param {Object} obj
 * @return {Function}
 * @api private
 */

exports.locals = function(obj){
  function locals(obj){
    for (var key in obj) locals[key] = obj[key];
    return obj;
  };

  return locals;
};

/**
 * Check if `path` looks absolute.
 *
 * @param {String} path
 * @return {Boolean}
 * @api private
 */

exports.isAbsolute = function(path){
  if ('/' == path[0]) return true;
  if (':' == path[1] && '\\' == path[2]) return true;
};

/**
 * Flatten the given `arr`.
 *
 * @param {Array} arr
 * @return {Array}
 * @api private
 */

exports.flatten = function(arr, ret){
  var ret = ret || []
    , len = arr.length;
  for (var i = 0; i < len; ++i) {
    if (Array.isArray(arr[i])) {
      exports.flatten(arr[i], ret);
    } else {
      ret.push(arr[i]);
    }
  }
  return ret;
};

/**
 * Normalize the given `type`, for example "html" becomes "text/html".
 *
 * @param {String} type
 * @return {Object}
 * @api private
 */

exports.normalizeType = function(type){
  return ~type.indexOf('/')
    ? acceptParams(type)
    : { value: mime.lookup(type), params: {} };
};

/**
 * Normalize `types`, for example "html" becomes "text/html".
 *
 * @param {Array} types
 * @return {Array}
 * @api private
 */

exports.normalizeTypes = function(types){
  var ret = [];

  for (var i = 0; i < types.length; ++i) {
    ret.push(exports.normalizeType(types[i]));
  }

  return ret;
};

/**
 * Return the acceptable type in `types`, if any.
 *
 * @param {Array} types
 * @param {String} str
 * @return {String}
 * @api private
 */

exports.acceptsArray = function(types, str){
  // accept anything when Accept is not present
  if (!str) return types[0];

  // parse
  var accepted = exports.parseAccept(str)
    , normalized = exports.normalizeTypes(types)
    , len = accepted.length;

  for (var i = 0; i < len; ++i) {
    for (var j = 0, jlen = types.length; j < jlen; ++j) {
      if (exports.accept(normalized[j], accepted[i])) {
        return types[j];
      }
    }
  }
};

/**
 * Check if `type(s)` are acceptable based on
 * the given `str`.
 *
 * @param {String|Array} type(s)
 * @param {String} str
 * @return {Boolean|String}
 * @api private
 */

exports.accepts = function(type, str){
  if ('string' == typeof type) type = type.split(/ *, */);
  return exports.acceptsArray(type, str);
};

/**
 * Check if `type` array is acceptable for `other`.
 *
 * @param {Object} type
 * @param {Object} other
 * @return {Boolean}
 * @api private
 */

exports.accept = function(type, other){
  var t = type.value.split('/');
  return (t[0] == other.type || '*' == other.type)
    && (t[1] == other.subtype || '*' == other.subtype)
    && paramsEqual(type.params, other.params);
};

/**
 * Check if accept params are equal.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Boolean}
 * @api private
 */

function paramsEqual(a, b){
  return !Object.keys(a).some(function(k) {
    return a[k] != b[k];
  });
}

/**
 * Parse accept `str`, returning
 * an array objects containing
 * `.type` and `.subtype` along
 * with the values provided by
 * `parseQuality()`.
 *
 * @param {Type} name
 * @return {Type}
 * @api private
 */

exports.parseAccept = function(str){
  return exports
    .parseParams(str)
    .map(function(obj){
      var parts = obj.value.split('/');
      obj.type = parts[0];
      obj.subtype = parts[1];
      return obj;
    });
};

/**
 * Parse quality `str`, returning an
 * array of objects with `.value`,
 * `.quality` and optional `.params`
 *
 * @param {String} str
 * @return {Array}
 * @api private
 */

exports.parseParams = function(str){
  return str
    .split(/ *, */)
    .map(acceptParams)
    .filter(function(obj){
      return obj.quality;
    })
    .sort(function(a, b){
      if (a.quality === b.quality) {
        return a.originalIndex - b.originalIndex;
      } else {
        return b.quality - a.quality;
      }
    });
};

/**
 * Parse accept params `str` returning an
 * object with `.value`, `.quality` and `.params`.
 * also includes `.originalIndex` for stable sorting
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function acceptParams(str, index) {
  var parts = str.split(/ *; */);
  var ret = { value: parts[0], quality: 1, params: {}, originalIndex: index };

  for (var i = 1; i < parts.length; ++i) {
    var pms = parts[i].split(/ *= */);
    if ('q' == pms[0]) {
      ret.quality = parseFloat(pms[1]);
    } else {
      ret.params[pms[0]] = pms[1];
    }
  }

  return ret;
}

/**
 * Escape special characters in the given string of html.
 *
 * @param  {String} html
 * @return {String}
 * @api private
 */

exports.escape = function(html) {
  return String(html)
    .replace(/&/g, '&amp;')
    .replace(/"/g, '&quot;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
};

/**
 * Normalize the given path string,
 * returning a regular expression.
 *
 * An empty array should be passed,
 * which will contain the placeholder
 * key names. For example "/user/:id" will
 * then contain ["id"].
 *
 * @param  {String|RegExp|Array} path
 * @param  {Array} keys
 * @param  {Boolean} sensitive
 * @param  {Boolean} strict
 * @return {RegExp}
 * @api private
 */

exports.pathRegexp = function(path, keys, sensitive, strict) {
  if (toString.call(path) == '[object RegExp]') return path;
  if (Array.isArray(path)) path = '(' + path.join('|') + ')';
  path = path
    .concat(strict ? '' : '/?')
    .replace(/\/\(/g, '(?:/')
    .replace(/(\/)?(\.)?:(\w+)(?:(\(.*?\)))?(\?)?(\*)?/g, function(_, slash, format, key, capture, optional, star){
      keys.push({ name: key, optional: !! optional });
      slash = slash || '';
      return ''
        + (optional ? '' : slash)
        + '(?:'
        + (optional ? slash : '')
        + (format || '') + (capture || (format && '([^/.]+?)' || '([^/]+?)')) + ')'
        + (optional || '')
        + (star ? '(/*)?' : '');
    })
    .replace(/([\/.])/g, '\\$1')
    .replace(/\*/g, '(.*)');
  return new RegExp('^' + path + '$', sensitive ? '' : 'i');
}

})()
},{}],37:[function(require,module,exports){
var share = require('share/lib/client');
var Channel = require('../Channel');
var Model = require('./Model');
var LocalDoc = require('./LocalDoc');
var RemoteDoc = require('./RemoteDoc');

Model.prototype._createConnection = function(bundle) {
  // Model::_createSocket should be defined by the socket plugin
  this.root.socket = this._createSocket(bundle);

  // The Share connection will bind to the socket by defining the onopen,
  // onmessage, etc. methods
  var shareConnection = this.root.shareConnection = new share.Connection(this.root.socket);
  var segments = ['$connection', 'state'];
  var states = ['connecting', 'connected', 'disconnected', 'stopped'];
  var model = this;
  states.forEach(function(state) {
    shareConnection.on(state, function() {
      model._set(segments, state);
    });
  });
  this._set(segments, 'connected');

  // Wrap the socket methods on top of Share's methods
  this._createChannel();
};

Model.prototype.connect = function() {
  this.root.socket.open();
};
Model.prototype.disconnect = function() {
  this.root.socket.close();
};
Model.prototype.reconnect = function() {
  this.disconnect();
  this.connect();
};

Model.prototype._createChannel = function() {
  this.root.channel = new Channel(this.root.socket);
};

Model.prototype._getOrCreateShareDoc = function(collectionName, id, data) {
  var shareDoc = this.root.shareConnection.get(collectionName, id, data);
  shareDoc.incremental = true;
  return shareDoc;
};

Model.prototype._getDocConstructor = function(name) {
  // Whether the collection is local or remote is determined by its name.
  // Collections starting with an underscore ('_') are for user-defined local
  // collections, those starting with a dollar sign ('$'') are for
  // framework-defined local collections, and all others are remote.
  var firstCharcter = name.charAt(0);
  var isLocal = (firstCharcter === '_' || firstCharcter === '$');
  return (isLocal) ? LocalDoc : RemoteDoc;
};

},{"../Channel":64,"./Model":31,"./LocalDoc":56,"./RemoteDoc":66,"share/lib/client":67}],31:[function(require,module,exports){
var uuid = require('node-uuid');

Model.INITS = [];

module.exports = Model;

function Model(options) {
  this.root = this;

  var inits = Model.INITS;
  options || (options = {});
  for (var i = 0; i < inits.length; i++) {
    inits[i](this, options);
  }
}

Model.prototype.id = function() {
  return uuid.v4();
};

Model.prototype._child = function() {
  return new ChildModel(this);
};

function ChildModel(model) {
  // Shared properties should be accessed via the root. This makes inheritance
  // cheap and easily extensible
  this.root = model.root;

  // EventEmitter methods access these properties directly, so they must be
  // inherited manually instead of via the root
  this._events = model._events;
  this._maxListeners = model._maxListeners;

  // Properties specific to a child instance
  this._context = model._context;
  this._at = model._at;
  this._pass = model._pass;
  this._silent = model._silent;
}
ChildModel.prototype = new Model;

},{"node-uuid":68}],65:[function(require,module,exports){
module.exports = Doc;

function Doc(model, collectionName, id) {
  this.collectionName = collectionName;
  this.id = id;
  this.collectionData = model && model.data[collectionName];
}

Doc.prototype.path = function(segments) {
  return this.collectionName + '.' + this.id + '.' + segments.join('.');
};

Doc.prototype._errorMessage = function(description, segments, value) {
  return description + ' at ' + this.path(segments) + ': ' +
    JSON.stringify(value, null, 2);
};

},{}],36:[function(require,module,exports){
var util = require('../util');
var Model = require('./Model');
var arrayDiff = require('arraydiff');

Model.prototype.setDiff = function() {
  var subpath, value, options, cb;
  if (arguments.length === 1) {
    value = arguments[0];
  } else if (arguments.length === 2) {
    subpath = arguments[0];
    value = arguments[1];
  } else if (arguments.length === 3) {
    subpath = arguments[0];
    value = arguments[1];
    if (typeof arguments[2] === 'function') {
      cb = arguments[2];
    } else {
      options = arguments[2];
    }
  } else {
    subpath = arguments[0];
    value = arguments[1];
    options = arguments[2];
    cb = arguments[3];
  }
  var segments = this._splitPath(subpath);
  return this._setDiff(segments, value, options, cb);
};
Model.prototype._setDiff = function(segments, value, options, cb) {
  segments = this._dereference(segments);
  var equalFn = (options && options.equal) || util.equal;
  var isEach = options && options.each;
  var model = this;
  function setDiff(doc, docSegments, fnCb) {
    var before = doc.get(docSegments);
    if (equalFn(before, value)) return fnCb();
    var group = util.asyncGroup(fnCb);
    doDiff(model, doc, segments, before, value, equalFn, group, isEach);
  }
  return this._mutate(segments, setDiff, cb);
};
Model.prototype._setArrayDiff = function(segments, value, cb) {
  segments = this._dereference(segments);
  var model = this;
  function setArrayDiff(doc, docSegments, fnCb) {
    var before = doc.get(docSegments);
    if (before === value) return fnCb();
    if (!Array.isArray(before) || !Array.isArray(value)) {
      applySet(model, doc, segments, value, fnCb);
      return;
    }
    var diff = arrayDiff(before, value);
    if (!diff.length) return fnCb();
    var group = util.asyncGroup(fnCb);
    applyArrayDiff(model, doc, segments, diff, group);
  }
  return this._mutate(segments, setArrayDiff, cb);
};

/**
 * @param {Object} doc
 * @param {String} doc.collectionName
 * @param {String} doc.id
 * @param {Object} doc.snapshot
 * @param {Array} segments
 * @param {Object} before
 * @param {Object} after
 * @param {Function} group
 * @param {Boolean} isEach
 */
function doDiff(model, doc, segments, before, after, equalFn, group, isEach) {
  if (typeof before !== 'object' || !before ||
      typeof after !== 'object' || !after) {
    // Set the entire value if not diffable
    applySet(model, doc, segments, after, group());
    return;
  }
  if (Array.isArray(before) && Array.isArray(after)) {
    var diff = arrayDiff(before, after, equalFn);
    if (!diff.length) return group()();
    // If the only change is a single item replacement, diff the item instead
    if (
      diff.length === 2 &&
      diff[0].index === diff[1].index &&
      diff[0] instanceof arrayDiff.RemoveDiff &&
      diff[0].howMany === 1 &&
      diff[1] instanceof arrayDiff.InsertDiff &&
      diff[1].values.length === 1
    ) {
      var index = diff[0].index;
      var itemSegments = segments.concat(index);
      doDiff(model, doc, itemSegments, before[index], after[index], equalFn, group);
      return;
    }
    applyArrayDiff(model, doc, segments, diff, group);
    return;
  }
  if (!isEach) {
    // Delete keys that were in before but not after
    for (var key in before) {
      if (key in after) continue;
      var itemSegments = segments.concat(key);
      var docSegments = itemSegments.slice(2);
      var previous = doc.del(docSegments, group());
      model.emit('change', itemSegments, [void 0, previous, model._pass]);
    }
  }
  // Diff each property in after
  for (var key in after) {
    if (equalFn(before[key], after[key])) continue;
    var itemSegments = segments.concat(key);
    doDiff(model, doc, itemSegments, before[key], after[key], equalFn, group);
  }
}

function applySet(model, doc, segments, after, cb) {
  var docSegments = segments.slice(2);
  var previous = doc.set(docSegments, after, cb);
  model.emit('change', segments, [after, previous, model._pass]);
}

function applyArrayDiff(model, doc, segments, diff, group) {
  var docSegments = segments.slice(2);
  for (var i = 0, len = diff.length; i < len; i++) {
    var item = diff[i];
    if (item instanceof arrayDiff.InsertDiff) {
      // Insert
      doc.insert(docSegments, item.index, item.values, group());
      model.emit('insert', segments, [item.index, item.values, model._pass]);
    } else if (item instanceof arrayDiff.RemoveDiff) {
      // Remove
      var removed = doc.remove(docSegments, item.index, item.howMany, group());
      model.emit('remove', segments, [item.index, removed, model._pass]);
    } else if (item instanceof arrayDiff.MoveDiff) {
      // Move
      var moved = doc.move(docSegments, item.from, item.to, item.howMany, group());
      model.emit('move', segments, [item.from, item.to, moved.length, model._pass]);
    }
  }
}

},{"../util":14,"./Model":31,"arraydiff":69}],39:[function(require,module,exports){
(function(process){var util = require('../util');
var Model = require('./Model');
var arrayDiff = require('arraydiff');
var deepEquals = require('deep-is');

module.exports = Query;

Model.INITS.push(function(model) {
  model.root._queries = new Queries;
  if (model.root.fetchOnly) return;
  model.on('all', function(segments) {
    // Updated async, since this is likely the result of an operation that
    // includes creating the doc, and we would like that to happen before
    // sending the subscribe message
    process.nextTick(function() {
      var map = model.root._queries.map;
      for (var hash in map) {
        var query = map[hash];
        if (query.isPathQuery && query.shareQuery && util.mayImpact(query.expression, segments)) {
          var ids = pathIds(model, query.expression);
          var previousIds = model._get(query.idSegments);
          query._onChange(ids, previousIds);
        }
      }
    });
  });
});

/**
 * @param {String} collectionName
 * @param {Object} expression
 * @param {String} source
 * @return {Query}
 */
Model.prototype.query = function(collectionName, expression, source) {
  if (typeof expression.path === 'function' || typeof expression !== 'object') {
    expression = this._splitPath(expression);
  }
  var query = this.root._queries.get(collectionName, expression, source);
  if (query) return query;
  query = new Query(this, collectionName, expression, source);
  this.root._queries.add(query);
  return query;
};

/**
 * Called during initialization of the bundle on page load.
 * @param {Array} items
 * @param {Array} items[*]
 * @param {String} items[*][0] collectionName
 * @param {Object} items[*][1] expression
 * @param {String} items[*][2] source
 * @param {Number} items[*][3] subscribeCount
 * @param {Number} items[*][4] fetchCount
 * @param {Array}  items[*][5] fetchIds
 */
Model.prototype._initQueries = function(items) {
  for (var i = 0; i < items.length; i++) {
    var item = items[i];
    var query = new Query(this, item[0], item[1], item[2], item[3], item[4], item[5]);
    var count = query.fetchCount;
    while (count--) this.emit('fetchQuery', query, this._context);
    var count = query.subscribeCount;
    query.subscribeCount = 0;
    while (count--) query.subscribe();
  }
};

function QueriesMap() {}

function Queries() {
  this.map = new QueriesMap;
}
Queries.prototype.add = function(query) {
  this.map[query.hash] = query;
};
Queries.prototype.remove = function(query) {
  delete this.map[query.hash];
};
Queries.prototype.get = function(collectionName, expression, source) {
  var hash = queryHash(collectionName, expression, source);
  return this.map[hash];
};
Queries.prototype.toJSON = function() {
  var out = [];
  for (var hash in this.map) {
    var query = this.map[hash];
    if (query.subscribeCount || query.fetchCount) {
      out.push(query.serialize());
    }
  }
  return out;
};

/**
 * @private
 * @constructor
 * @param {Model} model
 * @param {Object} collectionName
 * @param {Object} expression
 * @param {String} source (e.g., 'solr')
 * @param {Number} subscribeCount
 * @param {Number} fetchCount
 * @param {Array<Array<String>>} fetchIds
 */
function Query(model, collectionName, expression, source, subscribeCount, fetchCount, fetchIds) {
  this.model = model.pass({$query: this});
  this.collectionName = collectionName;
  this.expression = expression;
  this.source = source;
  this.hash = queryHash(collectionName, expression, source);
  this.segments = ['$queries', this.hash];
  this.idSegments = ['$queries', this.hash, 'ids'];
  this.extraSegments = ['$queries', this.hash, 'extra'];
  this.isPathQuery = Array.isArray(expression);

  this._pendingSubscribeCallbacks = [];

  // These are used to help cleanup appropriately when calling unsubscribe and
  // unfetch. A query won't be fully cleaned up until unfetch and unsubscribe
  // are called the same number of times that fetch and subscribe were called.
  this.subscribeCount = subscribeCount || 0;
  this.fetchCount = fetchCount || 0;
  // The list of ids at the time of each fetch is pushed onto fetchIds, so
  // that unfetchDoc can be called the same number of times as fetchDoc
  this.fetchIds = fetchIds || [];

  this.created = false;
  this.shareQuery = null;
}

Query.prototype.create = function() {
  this.created = true;
  this.model.root._queries.add(this);
};

Query.prototype.destroy = function() {
  this.created = false;
  if (this.shareQuery) {
    this.shareQuery.destroy();
    this.shareQuery = null;
  }
  this.model.root._queries.remove(this);
  this.model._del(this.segments);
};

Query.prototype.sourceQuery = function() {
  if (this.isPathQuery) {
    var ids = pathIds(this.model, this.expression);
    return {_id: {$in: ids}};
  }
  return this.expression;
};

/**
 * @param {Function} [cb] cb(err)
 */
Query.prototype.fetch = function(cb) {
  if (!cb) cb = this.model.root._defaultCallback;
  this.model.emit('fetchQuery', this, this.model._context);

  this.fetchCount++;

  if (!this.created) this.create();
  var query = this;

  var model = this.model;
  var shareDocs = collectionShareDocs(this.model, this.collectionName);
  var options = {docMode: 'fetch', knownDocs: shareDocs};
  if (this.source) options.source = this.source;

  model.root.shareConnection.createFetchQuery(
    this.collectionName, this.sourceQuery(), options, fetchQueryCallback
  );
  function fetchQueryCallback(err, results, extra) {
    if (err) return cb(err);
    var ids = resultsIds(results);

    // Keep track of the ids at fetch time for use in unfetch
    query.fetchIds.push(ids.slice());
    // Update the results ids and extra
    model._setDiff(query.idSegments, ids);
    if (extra !== void 0) {
      model._setDiff(query.extraSegments, extra, {equal: deepEquals});
    }

    if (!ids.length) return cb();

    // Call fetchDoc for each document returned so that the proper load events
    // and internal counts are maintained. However, specify that we already
    // loaded the documents as part of the query, since we don't want to
    // actually fetch the documents again
    var alreadyLoaded = true;
    var group = util.asyncGroup(cb);
    for (var i = 0; i < ids.length; i++) {
      model.fetchDoc(query.collectionName, ids[i], group(), alreadyLoaded);
    }
  }
  return this;
};

/**
 * Sets up a subscription to `this` query.
 * @param {Function} cb(err)
 */
Query.prototype.subscribe = function(cb) {
  if (!cb) cb = this.model.root._defaultCallback;
  this.model.emit('subscribeQuery', this, this.model._context);

  var query = this;

  if (this.subscribeCount++) {
    process.nextTick(function () {
      var data = query.model._get(query.segments);
      if (data) cb();
      else query._pendingSubscribeCallbacks.push(cb);
    });
    return this;
  }

  if (!this.created) this.create();

  // When doing server-side rendering, we actually do a fetch the first time
  // that subscribe is called, but keep track of the state as if subscribe
  // were called for proper initialization in the client
  var shareDocs = collectionShareDocs(this.model, this.collectionName);
  var options = {docMode: 'sub', knownDocs: shareDocs};
  if (this.source) options.source = this.source;

  if (!this.model.root.fetchOnly) {
    this._shareSubscribe(options, cb);
    return this;
  }

  var model = this.model;
  options.docMode = 'fetch';
  model.root.shareConnection.createFetchQuery(
    this.collectionName, this.sourceQuery(), options, function(err, results, extra) {
      if (err) return cb(err);
      var ids = resultsIds(results);
      if (extra !== void 0) {
        model._setDiff(query.extraSegments, extra, {equal: deepEquals});
      }
      query._onChange(ids, null, cb);
      while (cb = query._pendingSubscribeCallbacks.shift()) {
        query._onChange(ids, null, cb);
      }
    }
  );
  return this;
};

/**
 * @private
 * @param {Object} options
 * @param {String} [options.source]
 * @param {Boolean} [options.poll]
 * @param {Boolean} [options.docMode = fetch or subscribe]
 * @param {Function} cb(err, results)
 */
Query.prototype._shareSubscribe = function(options, cb) {
  var query = this;
  var model = this.model;
  this.shareQuery = this.model.root.shareConnection.createSubscribeQuery(
    this.collectionName, this.sourceQuery(), options, function (err, results, extra) {
      if (err) return cb(err);
      if (extra !== void 0) {
        model._setDiff(query.extraSegments, extra, {equal: deepEquals});
      }
      // Results are not set in the callback, because the shareQuery should
      // emit a 'change' event before calling back
      cb();
    }
  );
  var query = this;
  this.shareQuery.on('insert', function(shareDocs, index) {
    query._onInsert(shareDocs, index);
  });
  this.shareQuery.on('remove', function(shareDocs, index) {
    query._onRemove(shareDocs, index);
  });
  this.shareQuery.on('move', function(shareDocs, from, to) {
    query._onMove(shareDocs, from, to);
  });
  this.shareQuery.on('change', function(results, previous) {
    // Get the new and previous list of ids when the entire results set changes
    var ids = resultsIds(results);
    var previousIds = previous && resultsIds(previous);
    query._onChange(ids, previousIds);
  });
  this.shareQuery.on('extra', function (extra) {
    model._setDiff(query.extraSegments, extra, {equal: deepEquals});
  });
};

/**
 * @public
 * @param {Function} cb(err, newFetchCount)
 */
Query.prototype.unfetch = function(cb) {
  if (!cb) cb = this.model.root._defaultCallback;
  this.model.emit('unfetchQuery', this, this.model._context);

  // No effect if the query is not currently fetched
  if (!this.fetchCount) {
    cb();
    return this;
  }

  var ids = this.fetchIds.shift() || [];
  for (var i = 0; i < ids.length; i++) {
    this.model.unfetchDoc(this.collectionName, ids[i]);
  }

  var query = this;
  if (this.model.root.unloadDelay) {
    setTimeout(finishUnfetchQuery, this.model.root.unloadDelay);
  } else {
    finishUnfetchQuery();
  }
  function finishUnfetchQuery() {
    var count = --query.fetchCount;
    if (count) return cb(null, count);
    // Cleanup when no fetches or subscribes remain
    if (!query.subscribeCount) query.destroy();
    cb(null, 0);
  }
  return this;
};

Query.prototype.unsubscribe = function(cb) {
  if (!cb) cb = this.model.root._defaultCallback;
  this.model.emit('unsubscribeQuery', this, this.model._context);

  // No effect if the query is not currently subscribed
  if (!this.subscribeCount) {
    cb();
    return this;
  }

  var query = this;
  if (this.model.root.unloadDelay) {
    setTimeout(finishUnsubscribeQuery, this.model.root.unloadDelay);
  } else {
    finishUnsubscribeQuery();
  }
  function finishUnsubscribeQuery() {
    var count = --query.subscribeCount;
    if (count) return cb(null, count);

    if (query.shareQuery) {
      var ids = resultsIds(query.shareQuery.results);
      query.shareQuery.destroy();
      query.shareQuery = null;
    }

    if (!query.model.root.fetchOnly && ids && ids.length) {
      // Unsubscribe all documents that this query currently has in results
      var group = util.asyncGroup(unsubscribeQueryCallback);
      for (var i = 0; i < ids.length; i++) {
        query.model.unsubscribeDoc(query.collectionName, ids[i], group());
      }
    }
    unsubscribeQueryCallback();
  }
  function unsubscribeQueryCallback(err) {
    if (err) return cb(err);
    // Cleanup when no fetches or subscribes remain
    if (!query.fetchCount) query.destroy();
    cb(null, 0);
  }
  return this;
};

Query.prototype._onInsert = function(shareDocs, index) {
  var ids = [];
  for (var i = 0; i < shareDocs.length; i++) {
    var id = shareDocs[i].name;
    ids.push(id);
    this.model.subscribeDoc(this.collectionName, id);
  }
  this.model._insert(this.idSegments, index, ids);
};
Query.prototype._onRemove = function(shareDocs, index) {
  this.model._remove(this.idSegments, index, shareDocs.length);
  for (var i = 0; i < shareDocs.length; i++) {
    this.model.unsubscribeDoc(this.collectionName, shareDocs[i].name);
  }
};
Query.prototype._onMove = function(shareDocs, from, to) {
  this.model._move(this.idSegments, from, to, shareDocs.length);
};

Query.prototype._onChange = function(ids, previousIds, cb) {
  // Diff the new and previous list of ids, subscribing to documents for
  // inserted ids and unsubscribing from documents for removed ids
  var diff = (previousIds) ?
    arrayDiff(previousIds, ids) :
    [new arrayDiff.InsertDiff(0, ids)];
  var previousCopy = previousIds && previousIds.slice();

  // The results are updated via a different diff, since they might already
  // have a value from a fetch or previous shareQuery instance
  this.model._setDiff(this.idSegments, ids);

  if (cb) {
    var group = util.asyncGroup(cb);
    var finished = group();
  }
  for (var i = 0; i < diff.length; i++) {
    var item = diff[i];
    if (item instanceof arrayDiff.InsertDiff) {
      // Subscribe to the document for each inserted id
      var values = item.values;
      for (var j = 0; j < values.length; j++) {
        this.model.subscribeDoc(this.collectionName, values[j], cb && group());
      }
    } else if (item instanceof arrayDiff.RemoveDiff) {
      var values = previousCopy.splice(item.index, item.howMany);
      // Unsubscribe from the document for each removed id
      for (var j = 0; j < values.length; j++) {
        this.model.unsubscribeDoc(this.collectionName, values[j], cb && group());
      }
    }
    // Moving doesn't change document subscriptions, so that is ignored.
  }
  // Make sure that the callback gets called if the diff is empty or it
  // contains no inserts or removes
  finished && finished();
};

Query.prototype.get = function() {
  var results = [];
  var data = this.model._get(this.segments);
  if (!data) {
    console.warn('You must fetch or subscribe to a query before getting its results.');
    return results;
  }
  var ids = data.ids;
  if (!ids) return results;

  var collection = this.model.getCollection(this.collectionName);
  for (var i = 0, l = ids.length; i < l; i++) {
    var id = ids[i];
    var doc = collection && collection.docs[id];
    results.push(doc && doc.get());
  }
  return (data.extra === void 0) ?
    results :
    {results: results, extra: data.extra};
};

/**
 * Lazily creates or gets a ref to our resultset's results.
 */
Query.prototype.ref = function(from) {
  var idsPath = this.idSegments.join('.');
  return this.model.refList(from, this.collectionName, idsPath);
};

/**
 * Lazily creates or gets a ref to our resultset's extra data.
 */
Query.prototype.extraRef = function(from, relPath) {
  var extraPath = this.extraSegments.join('.') + (relPath ? '.' + relPath : '');
  return this.model.ref(from, extraPath);
};

Query.prototype.serialize = function() {
  return [
    this.collectionName
  , this.expression
  , this.source
  , this.subscribeCount
  , this.fetchCount
  , this.fetchIds
  ];
};

function queryHash(collectionName, expression, source) {
  var args = [collectionName, expression, source];
  return JSON.stringify(args).replace(/\./g, '|');
}

function resultsIds(results) {
  var ids = [];
  for (var i = 0; i < results.length; i++) {
    var shareDoc = results[i];
    ids.push(shareDoc.name);
  }
  return ids;
}

function pathIds(model, segments) {
  var value = model._get(segments);
  return (typeof value === 'string') ? [value] :
    (Array.isArray(value)) ? value.slice() : [];
}

function collectionShareDocs(model, collectionName) {
  var collection = model.getCollection(collectionName);
  if (!collection) return;

  var results = [];
  for (var name in collection.docs) {
    results.push(collection.docs[name].shareDoc);
  }

  return results;
}


})(require("__browserify_process"))
},{"../util":14,"./Model":31,"arraydiff":69,"deep-is":48,"__browserify_process":11}],50:[function(require,module,exports){
var qs = require('qs')
var parseUrl = require('url').parse
var resolveUrl = require('url').resolve
var renderRoute = require('./router').render
var currentPath = (window.location.pathname.slice(window.location.pathname.indexOf('index.html') + 10) + '/') + window.location.search

// Replace the initial state with the current URL immediately,
// so that it will be rendered if the state is later popped
if (window.history.replaceState) {
  window.history.replaceState({
    $render: true,
    $method: 'get'
  }, null, window.location.href)
}

module.exports = History

function History(createPage, routes) {
  this._createPage = createPage
  this._routes = routes

  if (window.history.pushState) {
    addListeners(this)
    return
  }
  this.push = function(url) {
    window.location.assign(url)
  }
  this.replace = function(url) {
    window.location.replace(url)
  }
  this.refresh = function() {
    window.location.reload()
  }
}

History.prototype.push = function(url, render, state, e) {
  this._update('pushState', url, render, state, e)
}

History.prototype.replace = function(url, render, state, e) {
  this._update('replaceState', url, render, state, e)
}

// Rerender the current url locally
History.prototype.refresh = function() {
  var path = routePath(window.location.href)
  renderRoute(this.page(), {url: path, previous: path, method: 'get'})
}

History.prototype.back = function() {
  window.history.back()
}

History.prototype.forward = function() {
  window.history.forward()
}

History.prototype.go = function(i) {
  window.history.go(i)
}

History.prototype._update = function(historyMethod, relativeUrl, render, state, e) {
  var url = resolveUrl(window.location.href, relativeUrl)
  var path = routePath(url)

  // TODO: history.push should set the window.location with external urls
  if (!path) return
  if (render == null) render = true
  if (state == null) state = {}

  // Update the URL
  var options = renderOptions(e, path)
  state.$render = true
  state.$method = options.method
  window.history[historyMethod](state, null, options.url)
  currentPath = (window.location.pathname.slice(window.location.pathname.indexOf('index.html') + 10) + '/') + window.location.search
  if (render) renderRoute(this.page(), options, e)
}

History.prototype.page = function() {
  if (this._page) return this._page

  var page = this._page = this._createPage()
  var history = this

  function redirect(url) {
    if (url === 'back') return history.back()
    // TODO: Add support for `basepath` option like Express
    if (url === 'home') url = '\\'
    history.replace(url, true)
  }

  page.redirect = redirect
  page._routes = this._routes
  return page
}

// Get the pathname if it is on the same protocol and domain
function routePath(url) {
  var match = parseUrl(url)
  return match &&
    match.protocol === window.location.protocol &&
    match.host === window.location.host &&
    match.pathname + (match.search || '')
}

function renderOptions(e, path) {
  // If this is a form submission, extract the form data and
  // append it to the url for a get or params.body for a post
  if (e && e.type === 'submit') {
    var form = e.target
    var elements = form.elements
    var query = []
    for (var i = 0, len = elements.length, el; i < len; i++) {
      el = elements[i]
      var name = el.name
      if (!name) continue
      var value = el.value
      query.push(encodeURIComponent(name) + '=' + encodeURIComponent(value))
      if (name === '_method') {
        var override = value.toLowerCase()
        if (override === 'delete') override = 'del'
      }
    }
    query = query.join('&')
    if (form.method.toLowerCase() === 'post') {
      var method = override || 'post'
      var body = qs.parse(query)
    } else {
      method = 'get'
      path += '?' + query
    }
  } else {
    method = 'get'
  }
  return {
    method: method
  , url: path
  , previous: (window.location.pathname.slice(window.location.pathname.indexOf('index.html') + 10) + '/') + window.location.search
  , body: body
  , form: form
  , link: e && e._tracksLink
  }
}

function addListeners(history) {

  // Detect clicks on links
  function onClick(e) {
    var el = e.target

    // Ignore command click, control click, and non-left click
    if (e.metaKey || e.which !== 1) return

    // Ignore if already prevented
    if (e.defaultPrevented || e.returnValue === false) return

    // Also look up for parent links (<a><img></a>)
    while (el) {
      var url = el.href
      if (url) {

        // Ignore if created by Tracks
        if (el.hasAttribute && el.hasAttribute('data-router-ignore')) return

        // Ignore links meant to open in a different window or frame
        if (el.target && el.target !== '_self') return

        // Ignore hash links to the same page
        var hashIndex = url.indexOf('#')
        if (~hashIndex && url.slice(0, hashIndex) === window.location.href.replace(/#.*/, '')) {
          return
        }

        e._tracksLink = el
        history.push(url, true, null, e)
        return
      }

      el = el.parentNode
    }
  }

  function onSubmit(e) {
    var target = e.target

    // Ignore if already prevented
    if (e.defaultPrevented || e.returnValue === false) return

    // Only handle if emitted on a form element that isn't multipart
    if (target.tagName.toLowerCase() !== 'form') return
    if (target.enctype === 'multipart/form-data') return

    // Ignore if created by Tracks
    if (target.hasAttribute && target.hasAttribute('data-router-ignore')) return

    // Use the url from the form action, defaulting to the current url
    var url = target.action || window.location.href
    history.push(url, true, null, e)
  }

  function onPopState(e) {
    var previous = currentPath
    var state = e.state
    currentPath = (window.location.pathname.slice(window.location.pathname.indexOf('index.html') + 10) + '/') + window.location.search

    var options = {
      previous: previous
    , url: currentPath
    }

    if (state) {
      if (!state.$render) return
      options.method = state.$method
      // Note that the post body is only sent on the initial reqest
      // and it is empty if the state is later popped
      return renderRoute(history.page(), options)
    }

    // The state object will be null for states created by jump links.
    // window.location.hash cannot be used, because it returns nothing
    // if the url ends in just a hash character
    var url = window.location.href
      , hashIndex = url.indexOf('#')
      , el, id
    if (~hashIndex && currentPath !== previous) {
      options.method = 'get'
      renderRoute(history.page(), options)
      id = url.slice(hashIndex + 1)
      if (el = document.getElementById(id) || document.getElementsByName(id)[0]) {
        el.scrollIntoView()
      }
    }
  }

  document.addEventListener('click', onClick, false)
  document.addEventListener('submit', onSubmit, false)
  window.addEventListener('popstate', onPopState, false)
}

},{"url":8,"./router":51,"qs":70}],51:[function(require,module,exports){
var qs = require('qs')
var nodeUrl = require('url');

module.exports = {
  render: render
, isTransitional: isTransitional
, mapRoute: mapRoute
}

function isTransitional(pattern) {
  return pattern.hasOwnProperty('from') && pattern.hasOwnProperty('to')
}

function mapRoute(from, params) {
  var i = params.url.indexOf('?')
  var queryString = (~i) ? params.url.slice(i) : ''
  // If the route looks like /:a/:b?/:c/:d?
  // and :b and :d are missing, return /a/c
  // Thus, skip the / if the value is missing
  var i = 0
  var path = from.replace(/\/(?:(?:\:([^?\/:*]+))|\*)(\?)?/g, onMatch)
  function onMatch(match, key, optional) {
    var value = key ? params[key] : params[i++]
    return (optional && value === void 0) ? '' : '/' + value
  }
  return path + queryString
}

function render(page, options, e) {
  var req = new RenderReq(page, options, e)
  req.routeTransitional(0, function() {
    req.routeQueue(0, function() {
      req.routeAndTransition(0, function() {
        // Cancel rendering by this app if no routes match
        req.cancel()
      })
    })
  })
}

function RenderReq(page, options, e) {
  this.page = page
  this.options = options
  this.e = e
  this.setUrl(options.url.replace(/#.*/, ''))
  var queryString = nodeUrl.parse(this.url).query;
  this.query = queryString ? qs.parse(queryString) : {}
  this.method = options.method
  this.body = options.body || {}
  this.previous = options.previous
  var routes = page._routes
  this.transitional = routes.transitional[this.method]
  this.queue = routes.queue[this.method]
  this.onRoute = routes.onRoute
}

RenderReq.prototype.cancel = function() {
  var options = this.options
  // Don't do anything if this is the result of an event, since the
  // appropriate action will happen by default
  if (this.e || options.noNavigate) return
  // Otherwise, manually perform appropriate action
  if (options.form) {
    options.form.setAttribute('data-router-ignore', '')
    options.form.submit()
  } else if (options.link) {
    options.link.setAttribute('data-router-ignore', '')
    options.link.click()
  } else {
    window.location.assign(options.url)
  }
}

RenderReq.prototype.setUrl = function(url) {
  this.url = url
  this.path = this.url.replace(/\?.*/, '')
}

RenderReq.prototype.routeTransitional = function(i, next) {
  i || (i = 0)
  var item
  while (item = this.transitional[i++]) {
    if (!item.to.match(this.path) || !item.from.match(this.previous)) continue
    var req = this
    var otherParams = this.routeParams(item.from)
    var params = this.routeParams(item.to, otherParams)
    // Even though we don't need to do anything after a done, pass a
    // no op function, so that routes can expect it to be defined
    function done() {}
    this.onMatch(item.to, params, function(err) {
      if (err) return req.cancel()
      req.routeTransitional(i, next)
    }, done)
    return
  }
  next()
}

RenderReq.prototype.routeQueue = function(i, next) {
  i || (i = 0)
  var route
  while (route = this.queue[i++]) {
    if (!route.match(this.path)) continue
    var req = this
    var params = this.routeParams(route)
    this.onMatch(route, params, function(err) {
      if (err) return req.cancel()
      req.routeQueue(i, next)
    })
    return
  }
  next()
}

RenderReq.prototype.routeAndTransition = function(i, next) {
  i || (i = 0)
  var render = this.page.render
  var item
  while (item = this.transitional[i++]) {
    if (!item.to.match(this.path)) continue
    var url = this.url
    var params = this.routeParams(item.to)
    this.setUrl(mapRoute(item.from.path, params))
    var req = this
    var skipped = false
    function continueNext() {
      skipped = true
      req.setUrl(url)
      req.page.render = render
      req.routeAndTransition(i, next)
    }
    this.page.render = function() {
      var renderArguments = arguments
      function done() {
        if (skipped) return
        req.page.render = render
        render.apply(req.page, renderArguments)
      }
      req.setUrl(url)
      var isAsync = req.onMatch(item.to, params, continueNext, done)
      if (isAsync) return
      done()
    }
    this.routeQueue(0, continueNext)
    return
  }
  next()
}

RenderReq.prototype.onMatch = function(route, params, next, done) {
  // Stop the default browser action, such as clicking a link or submitting a form
  if (this.e) {
    this.e.preventDefault()
    this.e = null
  }
  this.page.params = params
  return this.onRoute(
    route.callbacks
  , this.page
  , this.page.params
  , next
  , route.isTransitional
  , done
  )
}

RenderReq.prototype.routeParams = function(route, otherParams) {
  var routeParams = route.params
  var params = routeParams.slice()
  if (otherParams) {
    for (var key in otherParams) {
      params[key] = otherParams[key]
    }
  }
  for (var key in routeParams) {
    params[key] = routeParams[key]
  }
  params.previous = this.previous
  params.url = this.url
  params.body = this.body
  params.query = this.query
  params.method = this.method
  return params
}

},{"url":8,"qs":70}],71:[function(require,module,exports){
require=(function(e,t,n,r){function i(r){if(!n[r]){if(!t[r]){if(e)return e(r);throw new Error("Cannot find module '"+r+"'")}var s=n[r]={exports:{}};t[r][0](function(e){var n=t[r][1][e];return i(n?n:e)},s,s.exports)}return n[r].exports}for(var s=0;s<r.length;s++)i(r[s]);return i})(typeof require!=="undefined"&&require,{1:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],2:[function(require,module,exports){
(function(){// UTILITY
var util = require('util');
var Buffer = require("buffer").Buffer;
var pSlice = Array.prototype.slice;

function objectKeys(object) {
  if (Object.keys) return Object.keys(object);
  var result = [];
  for (var name in object) {
    if (Object.prototype.hasOwnProperty.call(object, name)) {
      result.push(name);
    }
  }
  return result;
}

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.message = options.message;
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
};
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (value === undefined) {
    return '' + value;
  }
  if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (typeof value === 'function' || value instanceof RegExp) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (typeof s == 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

assert.AssertionError.prototype.toString = function() {
  if (this.message) {
    return [this.name + ':', this.message].join(' ');
  } else {
    return [
      this.name + ':',
      truncate(JSON.stringify(this.actual, replacer), 128),
      this.operator,
      truncate(JSON.stringify(this.expected, replacer), 128)
    ].join(' ');
  }
};

// assert.AssertionError instanceof Error

assert.AssertionError.__proto__ = Error.prototype;

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!!!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (typeof actual != 'object' && typeof expected != 'object') {
    return actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (expected instanceof RegExp) {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail('Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail('Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

})()
},{"util":3,"buffer":4}],"buffer-browserify":[function(require,module,exports){
module.exports=require('q9TxCC');
},{}],"q9TxCC":[function(require,module,exports){
(function(){function SlowBuffer (size) {
    this.length = size;
};

var assert = require('assert');

exports.INSPECT_MAX_BYTES = 50;


function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

SlowBuffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
    case 'binary':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

SlowBuffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

SlowBuffer.prototype.binaryWrite = SlowBuffer.prototype.asciiWrite;

SlowBuffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

SlowBuffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

SlowBuffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

SlowBuffer.prototype.binarySlice = SlowBuffer.prototype.asciiSlice;

SlowBuffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<SlowBuffer ' + out.join(' ') + '>';
};


SlowBuffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


SlowBuffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


SlowBuffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  SlowBuffer._charsWritten = i * 2;
  return i;
};


SlowBuffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};


// slice(start, end)
SlowBuffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;

  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  return new Buffer(this, end - start, +start);
};

SlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {
  var temp = [];
  for (var i=sourcestart; i<sourceend; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=targetstart; i<targetstart+temp.length; i++) {
    target[i] = temp[i-targetstart];
  }
};

SlowBuffer.prototype.fill = function(value, start, end) {
  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  for (var i = start; i < end; i++) {
    this[i] = value;
  }
}

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}


// Buffer

function Buffer(subject, encoding, offset) {
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    this.parent = subject;
    this.offset = offset;
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    if (this.length > Buffer.poolSize) {
      // Big buffer, just alloc one.
      this.parent = new SlowBuffer(this.length);
      this.offset = 0;

    } else {
      // Small buffer.
      if (!pool || pool.length - pool.used < this.length) allocPool();
      this.parent = pool;
      this.offset = pool.used;
      pool.used += this.length;
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        if (subject instanceof Buffer) {
          this.parent[i + this.offset] = subject.readUInt8(i);
        }
        else {
          this.parent[i + this.offset] = subject[i];
        }
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    }
  }

}

function isArrayIsh(subject) {
  return Array.isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

exports.SlowBuffer = SlowBuffer;
exports.Buffer = Buffer;

Buffer.poolSize = 8 * 1024;
var pool;

function allocPool() {
  pool = new SlowBuffer(Buffer.poolSize);
  pool.used = 0;
}


// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof SlowBuffer;
};

Buffer.concat = function (list, totalLength) {
  if (!Array.isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

// Inspect
Buffer.prototype.inspect = function inspect() {
  var out = [],
      len = this.length;

  for (var i = 0; i < len; i++) {
    out[i] = toHex(this.parent[i + this.offset]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }

  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i];
};


Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i] = v;
};


// write(string, offset = 0, length = buffer.length-offset, encoding = 'utf8')
Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  var ret;
  switch (encoding) {
    case 'hex':
      ret = this.parent.hexWrite(string, this.offset + offset, length);
      break;

    case 'utf8':
    case 'utf-8':
      ret = this.parent.utf8Write(string, this.offset + offset, length);
      break;

    case 'ascii':
      ret = this.parent.asciiWrite(string, this.offset + offset, length);
      break;

    case 'binary':
      ret = this.parent.binaryWrite(string, this.offset + offset, length);
      break;

    case 'base64':
      // Warning: maxLength not taken into account in base64Write
      ret = this.parent.base64Write(string, this.offset + offset, length);
      break;

    case 'ucs2':
    case 'ucs-2':
      ret = this.parent.ucs2Write(string, this.offset + offset, length);
      break;

    default:
      throw new Error('Unknown encoding');
  }

  Buffer._charsWritten = SlowBuffer._charsWritten;

  return ret;
};


// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();

  if (typeof start == 'undefined' || start < 0) {
    start = 0;
  } else if (start > this.length) {
    start = this.length;
  }

  if (typeof end == 'undefined' || end > this.length) {
    end = this.length;
  } else if (end < 0) {
    end = 0;
  }

  start = start + this.offset;
  end = end + this.offset;

  switch (encoding) {
    case 'hex':
      return this.parent.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.parent.utf8Slice(start, end);

    case 'ascii':
      return this.parent.asciiSlice(start, end);

    case 'binary':
      return this.parent.binarySlice(start, end);

    case 'base64':
      return this.parent.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.parent.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


// byteLength
Buffer.byteLength = SlowBuffer.byteLength;


// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  return this.parent.fill(value,
                          start + this.offset,
                          end + this.offset);
};


// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  end || (end = this.length);
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  return this.parent.copy(target.parent,
                          target_start + target.offset,
                          start + this.offset,
                          end + this.offset);
};


// slice(start, end)
Buffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;
  if (end > this.length) throw new Error('oob');
  if (start > end) throw new Error('oob');

  return new Buffer(this.parent, end - start, +start + this.offset);
};


// Legacy methods for backwards compatibility.

Buffer.prototype.utf8Slice = function(start, end) {
  return this.toString('utf8', start, end);
};

Buffer.prototype.binarySlice = function(start, end) {
  return this.toString('binary', start, end);
};

Buffer.prototype.asciiSlice = function(start, end) {
  return this.toString('ascii', start, end);
};

Buffer.prototype.utf8Write = function(string, offset) {
  return this.write(string, offset, 'utf8');
};

Buffer.prototype.binaryWrite = function(string, offset) {
  return this.write(string, offset, 'binary');
};

Buffer.prototype.asciiWrite = function(string, offset) {
  return this.write(string, offset, 'ascii');
};

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  return buffer.parent[buffer.offset + offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset] << 8;
    if (offset + 1 < buffer.length) {
      val |= buffer.parent[buffer.offset + offset + 1];
    }
  } else {
    val = buffer.parent[buffer.offset + offset];
    if (offset + 1 < buffer.length) {
      val |= buffer.parent[buffer.offset + offset + 1] << 8;
    }
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    if (offset + 1 < buffer.length)
      val = buffer.parent[buffer.offset + offset + 1] << 16;
    if (offset + 2 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 2] << 8;
    if (offset + 3 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 3];
    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);
  } else {
    if (offset + 2 < buffer.length)
      val = buffer.parent[buffer.offset + offset + 2] << 16;
    if (offset + 1 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 1] << 8;
    val |= buffer.parent[buffer.offset + offset];
    if (offset + 3 < buffer.length)
      val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  neg = buffer.parent[buffer.offset + offset] & 0x80;
  if (!neg) {
    return (buffer.parent[buffer.offset + offset]);
  }

  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  if (offset < buffer.length) {
    buffer.parent[buffer.offset + offset] = value;
  }
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
    buffer.parent[buffer.offset + offset + i] =
        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>
            (isBigEndian ? 1 - i : i) * 8;
  }

}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
    buffer.parent[buffer.offset + offset + i] =
        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

SlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;
SlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;
SlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;
SlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;
SlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;
SlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;
SlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;
SlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;
SlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;
SlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;
SlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;
SlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;
SlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;
SlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;
SlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;
SlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;
SlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;
SlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;
SlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;
SlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;
SlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;
SlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;
SlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;
SlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;
SlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;
SlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;
SlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;
SlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;

})()
},{"assert":2,"./buffer_ieee754":1,"base64-js":5}],3:[function(require,module,exports){
var events = require('events');

exports.isArray = isArray;
exports.isDate = function(obj){return Object.prototype.toString.call(obj) === '[object Date]'};
exports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === '[object RegExp]'};


exports.print = function () {};
exports.puts = function () {};
exports.debug = function() {};

exports.inspect = function(obj, showHidden, depth, colors) {
  var seen = [];

  var stylize = function(str, styleType) {
    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    var styles =
        { 'bold' : [1, 22],
          'italic' : [3, 23],
          'underline' : [4, 24],
          'inverse' : [7, 27],
          'white' : [37, 39],
          'grey' : [90, 39],
          'black' : [30, 39],
          'blue' : [34, 39],
          'cyan' : [36, 39],
          'green' : [32, 39],
          'magenta' : [35, 39],
          'red' : [31, 39],
          'yellow' : [33, 39] };

    var style =
        { 'special': 'cyan',
          'number': 'blue',
          'boolean': 'yellow',
          'undefined': 'grey',
          'null': 'bold',
          'string': 'green',
          'date': 'magenta',
          // "name": intentionally not styling
          'regexp': 'red' }[styleType];

    if (style) {
      return '\033[' + styles[style][0] + 'm' + str +
             '\033[' + styles[style][1] + 'm';
    } else {
      return str;
    }
  };
  if (! colors) {
    stylize = function(str, styleType) { return str; };
  }

  function format(value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (value && typeof value.inspect === 'function' &&
        // Filter out the util module, it's inspect function is special
        value !== exports &&
        // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
      return value.inspect(recurseTimes);
    }

    // Primitive types cannot have properties
    switch (typeof value) {
      case 'undefined':
        return stylize('undefined', 'undefined');

      case 'string':
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                 .replace(/'/g, "\\'")
                                                 .replace(/\\"/g, '"') + '\'';
        return stylize(simple, 'string');

      case 'number':
        return stylize('' + value, 'number');

      case 'boolean':
        return stylize('' + value, 'boolean');
    }
    // For some reason typeof null is "object", so special case here.
    if (value === null) {
      return stylize('null', 'null');
    }

    // Look up the keys of the object.
    var visible_keys = Object_keys(value);
    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;

    // Functions without properties can be shortcutted.
    if (typeof value === 'function' && keys.length === 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        var name = value.name ? ': ' + value.name : '';
        return stylize('[Function' + name + ']', 'special');
      }
    }

    // Dates without properties can be shortcutted
    if (isDate(value) && keys.length === 0) {
      return stylize(value.toUTCString(), 'date');
    }

    var base, type, braces;
    // Determine the object type
    if (isArray(value)) {
      type = 'Array';
      braces = ['[', ']'];
    } else {
      type = 'Object';
      braces = ['{', '}'];
    }

    // Make functions say that they are functions
    if (typeof value === 'function') {
      var n = value.name ? ': ' + value.name : '';
      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';
    } else {
      base = '';
    }

    // Make dates with properties first say the date
    if (isDate(value)) {
      base = ' ' + value.toUTCString();
    }

    if (keys.length === 0) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        return stylize('[Object]', 'special');
      }
    }

    seen.push(value);

    var output = keys.map(function(key) {
      var name, str;
      if (value.__lookupGetter__) {
        if (value.__lookupGetter__(key)) {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Getter/Setter]', 'special');
          } else {
            str = stylize('[Getter]', 'special');
          }
        } else {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Setter]', 'special');
          }
        }
      }
      if (visible_keys.indexOf(key) < 0) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (seen.indexOf(value[key]) < 0) {
          if (recurseTimes === null) {
            str = format(value[key]);
          } else {
            str = format(value[key], recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (isArray(value)) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = stylize('[Circular]', 'special');
        }
      }
      if (typeof name === 'undefined') {
        if (type === 'Array' && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    });

    seen.pop();

    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
      numLinesEst++;
      if (cur.indexOf('\n') >= 0) numLinesEst++;
      return prev + cur.length + 1;
    }, 0);

    if (length > 50) {
      output = braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];

    } else {
      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }

    return output;
  }
  return format(obj, (typeof depth === 'undefined' ? 2 : depth));
};


function isArray(ar) {
  return ar instanceof Array ||
         Array.isArray(ar) ||
         (ar && ar !== Object.prototype && isArray(ar.__proto__));
}


function isRegExp(re) {
  return re instanceof RegExp ||
    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');
}


function isDate(d) {
  if (d instanceof Date) return true;
  if (typeof d !== 'object') return false;
  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);
  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);
  return JSON.stringify(proto) === JSON.stringify(properties);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

exports.log = function (msg) {};

exports.pump = null;

var Object_keys = Object.keys || function (obj) {
    var res = [];
    for (var key in obj) res.push(key);
    return res;
};

var Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {
    var res = [];
    for (var key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) res.push(key);
    }
    return res;
};

var Object_create = Object.create || function (prototype, properties) {
    // from es5-shim
    var object;
    if (prototype === null) {
        object = { '__proto__' : null };
    }
    else {
        if (typeof prototype !== 'object') {
            throw new TypeError(
                'typeof prototype[' + (typeof prototype) + '] != \'object\''
            );
        }
        var Type = function () {};
        Type.prototype = prototype;
        object = new Type();
        object.__proto__ = prototype;
    }
    if (typeof properties !== 'undefined' && Object.defineProperties) {
        Object.defineProperties(object, properties);
    }
    return object;
};

exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object_create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (typeof f !== 'string') {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(exports.inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j': return JSON.stringify(args[i++]);
      default:
        return x;
    }
  });
  for(var x = args[i]; i < len; x = args[++i]){
    if (x === null || typeof x !== 'object') {
      str += ' ' + x;
    } else {
      str += ' ' + exports.inspect(x);
    }
  }
  return str;
};

},{"events":6}],5:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}],7:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],8:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],6:[function(require,module,exports){
(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};

var EventEmitter = exports.EventEmitter = process.EventEmitter;
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]'
    }
;
function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (x === xs[i]) return i;
    }
    return -1;
}

// By default EventEmitters will print a warning if more than
// 10 listeners are added to it. This is a useful default which
// helps finding memory leaks.
//
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!this._events) this._events = {};
  this._events.maxListeners = n;
};


EventEmitter.prototype.emit = function(type) {
  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events || !this._events.error ||
        (isArray(this._events.error) && !this._events.error.length))
    {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }
  }

  if (!this._events) return false;
  var handler = this._events[type];
  if (!handler) return false;

  if (typeof handler == 'function') {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        var args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
    return true;

  } else if (isArray(handler)) {
    var args = Array.prototype.slice.call(arguments, 1);

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i].apply(this, args);
    }
    return true;

  } else {
    return false;
  }
};

// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('addListener only takes instances of Function');
  }

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  } else if (isArray(this._events[type])) {

    // Check for listener leak
    if (!this._events[type].warned) {
      var m;
      if (this._events.maxListeners !== undefined) {
        m = this._events.maxListeners;
      } else {
        m = defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }

    // If we've already got an array, just append.
    this._events[type].push(listener);
  } else {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  var self = this;
  self.on(type, function g() {
    self.removeListener(type, g);
    listener.apply(this, arguments);
  });

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('removeListener only takes instances of Function');
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (!this._events || !this._events[type]) return this;

  var list = this._events[type];

  if (isArray(list)) {
    var i = indexOf(list, listener);
    if (i < 0) return this;
    list.splice(i, 1);
    if (list.length == 0)
      delete this._events[type];
  } else if (this._events[type] === listener) {
    delete this._events[type];
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  if (arguments.length === 0) {
    this._events = {};
    return this;
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (type && this._events && this._events[type]) this._events[type] = null;
  return this;
};

EventEmitter.prototype.listeners = function(type) {
  if (!this._events) this._events = {};
  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
};

})(require("__browserify_process"))
},{"__browserify_process":8}],4:[function(require,module,exports){
(function(){function SlowBuffer (size) {
    this.length = size;
};

var assert = require('assert');

exports.INSPECT_MAX_BYTES = 50;


function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

SlowBuffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

SlowBuffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

SlowBuffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

SlowBuffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

SlowBuffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<SlowBuffer ' + out.join(' ') + '>';
};


SlowBuffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


SlowBuffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


SlowBuffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  SlowBuffer._charsWritten = i * 2;
  return i;
};


SlowBuffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};


// slice(start, end)
SlowBuffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;

  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  return new Buffer(this, end - start, +start);
};

SlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {
  var temp = [];
  for (var i=sourcestart; i<sourceend; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=targetstart; i<targetstart+temp.length; i++) {
    target[i] = temp[i-targetstart];
  }
};

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}


// Buffer

function Buffer(subject, encoding, offset) {
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    this.parent = subject;
    this.offset = offset;
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    if (this.length > Buffer.poolSize) {
      // Big buffer, just alloc one.
      this.parent = new SlowBuffer(this.length);
      this.offset = 0;

    } else {
      // Small buffer.
      if (!pool || pool.length - pool.used < this.length) allocPool();
      this.parent = pool;
      this.offset = pool.used;
      pool.used += this.length;
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        this.parent[i + this.offset] = subject[i];
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    }
  }

}

function isArrayIsh(subject) {
  return Array.isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

exports.SlowBuffer = SlowBuffer;
exports.Buffer = Buffer;

Buffer.poolSize = 8 * 1024;
var pool;

function allocPool() {
  pool = new SlowBuffer(Buffer.poolSize);
  pool.used = 0;
}


// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof SlowBuffer;
};

Buffer.concat = function (list, totalLength) {
  if (!Array.isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

// Inspect
Buffer.prototype.inspect = function inspect() {
  var out = [],
      len = this.length;

  for (var i = 0; i < len; i++) {
    out[i] = toHex(this.parent[i + this.offset]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }

  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i];
};


Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i] = v;
};


// write(string, offset = 0, length = buffer.length-offset, encoding = 'utf8')
Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  var ret;
  switch (encoding) {
    case 'hex':
      ret = this.parent.hexWrite(string, this.offset + offset, length);
      break;

    case 'utf8':
    case 'utf-8':
      ret = this.parent.utf8Write(string, this.offset + offset, length);
      break;

    case 'ascii':
      ret = this.parent.asciiWrite(string, this.offset + offset, length);
      break;

    case 'binary':
      ret = this.parent.binaryWrite(string, this.offset + offset, length);
      break;

    case 'base64':
      // Warning: maxLength not taken into account in base64Write
      ret = this.parent.base64Write(string, this.offset + offset, length);
      break;

    case 'ucs2':
    case 'ucs-2':
      ret = this.parent.ucs2Write(string, this.offset + offset, length);
      break;

    default:
      throw new Error('Unknown encoding');
  }

  Buffer._charsWritten = SlowBuffer._charsWritten;

  return ret;
};


// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();

  if (typeof start == 'undefined' || start < 0) {
    start = 0;
  } else if (start > this.length) {
    start = this.length;
  }

  if (typeof end == 'undefined' || end > this.length) {
    end = this.length;
  } else if (end < 0) {
    end = 0;
  }

  start = start + this.offset;
  end = end + this.offset;

  switch (encoding) {
    case 'hex':
      return this.parent.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.parent.utf8Slice(start, end);

    case 'ascii':
      return this.parent.asciiSlice(start, end);

    case 'binary':
      return this.parent.binarySlice(start, end);

    case 'base64':
      return this.parent.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.parent.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


// byteLength
Buffer.byteLength = SlowBuffer.byteLength;


// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  return this.parent.fill(value,
                          start + this.offset,
                          end + this.offset);
};


// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  end || (end = this.length);
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  return this.parent.copy(target.parent,
                          target_start + target.offset,
                          start + this.offset,
                          end + this.offset);
};


// slice(start, end)
Buffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;
  if (end > this.length) throw new Error('oob');
  if (start > end) throw new Error('oob');

  return new Buffer(this.parent, end - start, +start + this.offset);
};


// Legacy methods for backwards compatibility.

Buffer.prototype.utf8Slice = function(start, end) {
  return this.toString('utf8', start, end);
};

Buffer.prototype.binarySlice = function(start, end) {
  return this.toString('binary', start, end);
};

Buffer.prototype.asciiSlice = function(start, end) {
  return this.toString('ascii', start, end);
};

Buffer.prototype.utf8Write = function(string, offset) {
  return this.write(string, offset, 'utf8');
};

Buffer.prototype.binaryWrite = function(string, offset) {
  return this.write(string, offset, 'binary');
};

Buffer.prototype.asciiWrite = function(string, offset) {
  return this.write(string, offset, 'ascii');
};

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  return buffer.parent[buffer.offset + offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset] << 8;
    val |= buffer.parent[buffer.offset + offset + 1];
  } else {
    val = buffer.parent[buffer.offset + offset];
    val |= buffer.parent[buffer.offset + offset + 1] << 8;
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset + 1] << 16;
    val |= buffer.parent[buffer.offset + offset + 2] << 8;
    val |= buffer.parent[buffer.offset + offset + 3];
    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);
  } else {
    val = buffer.parent[buffer.offset + offset + 2] << 16;
    val |= buffer.parent[buffer.offset + offset + 1] << 8;
    val |= buffer.parent[buffer.offset + offset];
    val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  neg = buffer.parent[buffer.offset + offset] & 0x80;
  if (!neg) {
    return (buffer.parent[buffer.offset + offset]);
  }

  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  buffer.parent[buffer.offset + offset] = value;
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  if (isBigEndian) {
    buffer.parent[buffer.offset + offset] = (value & 0xff00) >>> 8;
    buffer.parent[buffer.offset + offset + 1] = value & 0x00ff;
  } else {
    buffer.parent[buffer.offset + offset + 1] = (value & 0xff00) >>> 8;
    buffer.parent[buffer.offset + offset] = value & 0x00ff;
  }
}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  if (isBigEndian) {
    buffer.parent[buffer.offset + offset] = (value >>> 24) & 0xff;
    buffer.parent[buffer.offset + offset + 1] = (value >>> 16) & 0xff;
    buffer.parent[buffer.offset + offset + 2] = (value >>> 8) & 0xff;
    buffer.parent[buffer.offset + offset + 3] = value & 0xff;
  } else {
    buffer.parent[buffer.offset + offset + 3] = (value >>> 24) & 0xff;
    buffer.parent[buffer.offset + offset + 2] = (value >>> 16) & 0xff;
    buffer.parent[buffer.offset + offset + 1] = (value >>> 8) & 0xff;
    buffer.parent[buffer.offset + offset] = value & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

SlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;
SlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;
SlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;
SlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;
SlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;
SlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;
SlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;
SlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;
SlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;
SlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;
SlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;
SlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;
SlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;
SlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;
SlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;
SlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;
SlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;
SlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;
SlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;
SlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;
SlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;
SlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;
SlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;
SlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;
SlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;
SlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;
SlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;
SlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;

})()
},{"assert":2,"./buffer_ieee754":7,"base64-js":9}],9:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}]},{},[])
;;module.exports=require("buffer-browserify")

},{}],68:[function(require,module,exports){
(function(Buffer){//     uuid.js
//
//     Copyright (c) 2010-2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

(function() {
  var _global = this;

  // Unique ID creation requires a high quality random # generator.  We feature
  // detect to determine the best RNG source, normalizing to a function that
  // returns 128-bits of randomness, since that's what's usually required
  var _rng;

  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
  //
  // Moderately fast, high quality
  if (typeof(require) == 'function') {
    try {
      var _rb = require('crypto').randomBytes;
      _rng = _rb && function() {return _rb(16);};
    } catch(e) {}
  }

  if (!_rng && _global.crypto && crypto.getRandomValues) {
    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
    //
    // Moderately fast, high quality
    var _rnds8 = new Uint8Array(16);
    _rng = function whatwgRNG() {
      crypto.getRandomValues(_rnds8);
      return _rnds8;
    };
  }

  if (!_rng) {
    // Math.random()-based (RNG)
    //
    // If all else fails, use Math.random().  It's fast, but is of unspecified
    // quality.
    var  _rnds = new Array(16);
    _rng = function() {
      for (var i = 0, r; i < 16; i++) {
        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
      }

      return _rnds;
    };
  }

  // Buffer class to use
  var BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;

  // Maps for number <-> hex string conversion
  var _byteToHex = [];
  var _hexToByte = {};
  for (var i = 0; i < 256; i++) {
    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
    _hexToByte[_byteToHex[i]] = i;
  }

  // **`parse()` - Parse a UUID into it's component bytes**
  function parse(s, buf, offset) {
    var i = (buf && offset) || 0, ii = 0;

    buf = buf || [];
    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
      if (ii < 16) { // Don't overflow!
        buf[i + ii++] = _hexToByte[oct];
      }
    });

    // Zero out remaining bytes if string was short
    while (ii < 16) {
      buf[i + ii++] = 0;
    }

    return buf;
  }

  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
  function unparse(buf, offset) {
    var i = offset || 0, bth = _byteToHex;
    return  bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]];
  }

  // **`v1()` - Generate time-based UUID**
  //
  // Inspired by https://github.com/LiosK/UUID.js
  // and http://docs.python.org/library/uuid.html

  // random #'s we need to init node and clockseq
  var _seedBytes = _rng();

  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
  var _nodeId = [
    _seedBytes[0] | 0x01,
    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
  ];

  // Per 4.2.2, randomize (14 bit) clockseq
  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

  // Previous uuid creation time
  var _lastMSecs = 0, _lastNSecs = 0;

  // See https://github.com/broofa/node-uuid for API details
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];

    options = options || {};

    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;

    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    var msecs = options.msecs != null ? options.msecs : new Date().getTime();

    // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;

    // Time since last uuid creation (in msecs)
    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

    // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq == null) {
      clockseq = clockseq + 1 & 0x3fff;
    }

    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
      nsecs = 0;
    }

    // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) {
      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
    }

    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;

    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000;

    // `time_low`
    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff;

    // `time_mid`
    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff;

    // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff;

    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80;

    // `clock_seq_low`
    b[i++] = clockseq & 0xff;

    // `node`
    var node = options.node || _nodeId;
    for (var n = 0; n < 6; n++) {
      b[i + n] = node[n];
    }

    return buf ? buf : unparse(b);
  }

  // **`v4()` - Generate random UUID**

  // See https://github.com/broofa/node-uuid for API details
  function v4(options, buf, offset) {
    // Deprecated - 'format' argument, as supported in v1.2
    var i = buf && offset || 0;

    if (typeof(options) == 'string') {
      buf = options == 'binary' ? new BufferClass(16) : null;
      options = null;
    }
    options = options || {};

    var rnds = options.random || (options.rng || _rng)();

    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;

    // Copy bytes to buffer, if provided
    if (buf) {
      for (var ii = 0; ii < 16; ii++) {
        buf[i + ii] = rnds[ii];
      }
    }

    return buf || unparse(rnds);
  }

  // Export public API
  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  uuid.parse = parse;
  uuid.unparse = unparse;
  uuid.BufferClass = BufferClass;

  if (typeof define === 'function' && define.amd) {
    // Publish as AMD module
    define(function() {return uuid;});
  } else if (typeof(module) != 'undefined' && module.exports) {
    // Publish as node.js module
    module.exports = uuid;
  } else {
    // Publish as global (in browsers)
    var _previousRoot = _global.uuid;

    // **`noConflict()` - (browser only) to reset global 'uuid' var**
    uuid.noConflict = function() {
      _global.uuid = _previousRoot;
      return uuid;
    };

    _global.uuid = uuid;
  }
}).call(this);

})(require("__browserify_buffer").Buffer)
},{"crypto":72,"__browserify_buffer":71}],69:[function(require,module,exports){
module.exports = arrayDiff;

// Based on some rough benchmarking, this algorithm is about O(2n) worst case,
// and it can compute diffs on random arrays of length 1024 in about 34ms,
// though just a few changes on an array of length 1024 takes about 0.5ms

arrayDiff.InsertDiff = InsertDiff;
arrayDiff.RemoveDiff = RemoveDiff;
arrayDiff.MoveDiff = MoveDiff;

function InsertDiff(index, values) {
  this.index = index;
  this.values = values;
}
InsertDiff.prototype.type = 'insert';
InsertDiff.prototype.toJSON = function() {
  return {
    type: this.type
  , index: this.index
  , values: this.values
  };
};

function RemoveDiff(index, howMany) {
  this.index = index;
  this.howMany = howMany;
}
RemoveDiff.prototype.type = 'remove';
RemoveDiff.prototype.toJSON = function() {
  return {
    type: this.type
  , index: this.index
  , howMany: this.howMany
  };
};

function MoveDiff(from, to, howMany) {
  this.from = from;
  this.to = to;
  this.howMany = howMany;
}
MoveDiff.prototype.type = 'move';
MoveDiff.prototype.toJSON = function() {
  return {
    type: this.type
  , from: this.from
  , to: this.to
  , howMany: this.howMany
  };
};

function strictEqual(a, b) {
  return a === b;
}

function arrayDiff(before, after, equalFn) {
  if (!equalFn) equalFn = strictEqual;

  // Find all items in both the before and after array, and represent them
  // as moves. Many of these "moves" may end up being discarded in the last
  // pass if they are from an index to the same index, but we don't know this
  // up front, since we haven't yet offset the indices.
  // 
  // Also keep a map of all the indicies accounted for in the before and after
  // arrays. These maps are used next to create insert and remove diffs.
  var beforeLength = before.length;
  var afterLength = after.length;
  var moves = [];
  var beforeMarked = {};
  var afterMarked = {};
  for (var beforeIndex = 0; beforeIndex < beforeLength; beforeIndex++) {
    var beforeItem = before[beforeIndex];
    for (var afterIndex = 0; afterIndex < afterLength; afterIndex++) {
      if (afterMarked[afterIndex]) continue;
      if (!equalFn(beforeItem, after[afterIndex])) continue;
      var from = beforeIndex;
      var to = afterIndex;
      var howMany = 0;
      do {
        beforeMarked[beforeIndex++] = afterMarked[afterIndex++] = true;
        howMany++;
      } while (
        beforeIndex < beforeLength &&
        afterIndex < afterLength &&
        equalFn(before[beforeIndex], after[afterIndex]) &&
        !afterMarked[afterIndex]
      );
      moves.push(new MoveDiff(from, to, howMany));
      beforeIndex--;
      break;
    }
  }

  // Create a remove for all of the items in the before array that were
  // not marked as being matched in the after array as well
  var removes = [];
  for (beforeIndex = 0; beforeIndex < beforeLength;) {
    if (beforeMarked[beforeIndex]) {
      beforeIndex++;
      continue;
    }
    var index = beforeIndex;
    var howMany = 0;
    while (beforeIndex < beforeLength && !beforeMarked[beforeIndex++]) {
      howMany++;
    }
    removes.push(new RemoveDiff(index, howMany));
  }

  // Create an insert for all of the items in the after array that were
  // not marked as being matched in the before array as well
  var inserts = [];
  for (afterIndex = 0; afterIndex < afterLength;) {
    if (afterMarked[afterIndex]) {
      afterIndex++;
      continue;
    }
    var index = afterIndex;
    var howMany = 0;
    while (afterIndex < afterLength && !afterMarked[afterIndex++]) {
      howMany++;
    }
    var values = after.slice(index, index + howMany);
    inserts.push(new InsertDiff(index, values));
  }

  var insertsLength = inserts.length;
  var removesLength = removes.length;
  var movesLength = moves.length;
  var i, j;

  // Offset subsequent removes and moves by removes
  var count = 0;
  for (i = 0; i < removesLength; i++) {
    var remove = removes[i];
    remove.index -= count;
    count += remove.howMany;
    for (j = 0; j < movesLength; j++) {
      var move = moves[j];
      if (move.from >= remove.index) move.from -= remove.howMany;
    }
  }

  // Offset moves by inserts
  for (i = insertsLength; i--;) {
    var insert = inserts[i];
    var howMany = insert.values.length;
    for (j = movesLength; j--;) {
      var move = moves[j];
      if (move.to >= insert.index) move.to -= howMany;
    }
  }

  // Offset the to of moves by later moves
  for (i = movesLength; i-- > 1;) {
    var move = moves[i];
    if (move.to === move.from) continue;
    for (j = i; j--;) {
      var earlier = moves[j];
      if (earlier.to >= move.to) earlier.to -= move.howMany;
      if (earlier.to >= move.from) earlier.to += move.howMany;
    }
  }

  // Only output moves that end up having an effect after offsetting
  var outputMoves = [];

  // Offset the from of moves by earlier moves
  for (i = 0; i < movesLength; i++) {
    var move = moves[i];
    if (move.to === move.from) continue;
    outputMoves.push(move);
    for (j = i + 1; j < movesLength; j++) {
      var later = moves[j];
      if (later.from >= move.from) later.from -= move.howMany;
      if (later.from >= move.to) later.from += move.howMany;
    }
  }

  return removes.concat(outputMoves, inserts);
}

},{}],70:[function(require,module,exports){
/**
 * Object#toString() ref for stringify().
 */

var toString = Object.prototype.toString;

/**
 * Object#hasOwnProperty ref
 */

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Array#indexOf shim.
 */

var indexOf = typeof Array.prototype.indexOf === 'function'
  ? function(arr, el) { return arr.indexOf(el); }
  : function(arr, el) {
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] === el) return i;
      }
      return -1;
    };

/**
 * Array.isArray shim.
 */

var isArray = Array.isArray || function(arr) {
  return toString.call(arr) == '[object Array]';
};

/**
 * Object.keys shim.
 */

var objectKeys = Object.keys || function(obj) {
  var ret = [];
  for (var key in obj) ret.push(key);
  return ret;
};

/**
 * Array#forEach shim.
 */

var forEach = typeof Array.prototype.forEach === 'function'
  ? function(arr, fn) { return arr.forEach(fn); }
  : function(arr, fn) {
      for (var i = 0; i < arr.length; i++) fn(arr[i]);
    };

/**
 * Array#reduce shim.
 */

var reduce = function(arr, fn, initial) {
  if (typeof arr.reduce === 'function') return arr.reduce(fn, initial);
  var res = initial;
  for (var i = 0; i < arr.length; i++) res = fn(res, arr[i]);
  return res;
};

/**
 * Create a nullary object if possible
 */

function createObject() {
  return Object.create
    ? Object.create(null)
    : {};
}

/**
 * Cache non-integer test regexp.
 */

var isint = /^[0-9]+$/;

function promote(parent, key) {
  if (parent[key].length == 0) return parent[key] = createObject();
  var t = createObject();
  for (var i in parent[key]) {
    if (hasOwnProperty.call(parent[key], i)) {
      t[i] = parent[key][i];
    }
  }
  parent[key] = t;
  return t;
}

function parse(parts, parent, key, val) {
  var part = parts.shift();
  // end
  if (!part) {
    if (isArray(parent[key])) {
      parent[key].push(val);
    } else if ('object' == typeof parent[key]) {
      parent[key] = val;
    } else if ('undefined' == typeof parent[key]) {
      parent[key] = val;
    } else {
      parent[key] = [parent[key], val];
    }
    // array
  } else {
    var obj = parent[key] = parent[key] || [];
    if (']' == part) {
      if (isArray(obj)) {
        if ('' != val) obj.push(val);
      } else if ('object' == typeof obj) {
        obj[objectKeys(obj).length] = val;
      } else {
        obj = parent[key] = [parent[key], val];
      }
      // prop
    } else if (~indexOf(part, ']')) {
      part = part.substr(0, part.length - 1);
      if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
      parse(parts, obj, part, val);
      // key
    } else {
      if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
      parse(parts, obj, part, val);
    }
  }
}

/**
 * Merge parent key/val pair.
 */

function merge(parent, key, val){
  if (~indexOf(key, ']')) {
    var parts = key.split('[')
      , len = parts.length
      , last = len - 1;
    parse(parts, parent, 'base', val);
    // optimize
  } else {
    if (!isint.test(key) && isArray(parent.base)) {
      var t = createObject();
      for (var k in parent.base) t[k] = parent.base[k];
      parent.base = t;
    }
    set(parent.base, key, val);
  }

  return parent;
}

/**
 * Compact sparse arrays.
 */

function compact(obj) {
  if ('object' != typeof obj) return obj;

  if (isArray(obj)) {
    var ret = [];

    for (var i in obj) {
      if (hasOwnProperty.call(obj, i)) {
        ret.push(obj[i]);
      }
    }

    return ret;
  }

  for (var key in obj) {
    obj[key] = compact(obj[key]);
  }

  return obj;
}

/**
 * Restore Object.prototype.
 * see pull-request #58
 */

function restoreProto(obj) {
  if (!Object.create) return obj;
  if (isArray(obj)) return obj;
  if (obj && 'object' != typeof obj) return obj;

  for (var key in obj) {
    if (hasOwnProperty.call(obj, key)) {
      obj[key] = restoreProto(obj[key]);
    }
  }

  obj.__proto__ = Object.prototype;
  return obj;
}

/**
 * Parse the given obj.
 */

function parseObject(obj){
  var ret = { base: {} };

  forEach(objectKeys(obj), function(name){
    merge(ret, name, obj[name]);
  });

  return compact(ret.base);
}

/**
 * Parse the given str.
 */

function parseString(str){
  var ret = reduce(String(str).split('&'), function(ret, pair){
    var eql = indexOf(pair, '=')
      , brace = lastBraceInKey(pair)
      , key = pair.substr(0, brace || eql)
      , val = pair.substr(brace || eql, pair.length)
      , val = val.substr(indexOf(val, '=') + 1, val.length);

    // ?foo
    if ('' == key) key = pair, val = '';
    if ('' == key) return ret;

    return merge(ret, decode(key), decode(val));
  }, { base: createObject() }).base;

  return restoreProto(compact(ret));
}

/**
 * Parse the given query `str` or `obj`, returning an object.
 *
 * @param {String} str | {Object} obj
 * @return {Object}
 * @api public
 */

exports.parse = function(str){
  if (null == str || '' == str) return {};
  return 'object' == typeof str
    ? parseObject(str)
    : parseString(str);
};

/**
 * Turn the given `obj` into a query string
 *
 * @param {Object} obj
 * @return {String}
 * @api public
 */

var stringify = exports.stringify = function(obj, prefix) {
  if (isArray(obj)) {
    return stringifyArray(obj, prefix);
  } else if ('[object Object]' == toString.call(obj)) {
    return stringifyObject(obj, prefix);
  } else if ('string' == typeof obj) {
    return stringifyString(obj, prefix);
  } else {
    return prefix + '=' + encodeURIComponent(String(obj));
  }
};

/**
 * Stringify the given `str`.
 *
 * @param {String} str
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyString(str, prefix) {
  if (!prefix) throw new TypeError('stringify expects an object');
  return prefix + '=' + encodeURIComponent(str);
}

/**
 * Stringify the given `arr`.
 *
 * @param {Array} arr
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyArray(arr, prefix) {
  var ret = [];
  if (!prefix) throw new TypeError('stringify expects an object');
  for (var i = 0; i < arr.length; i++) {
    ret.push(stringify(arr[i], prefix + '[' + i + ']'));
  }
  return ret.join('&');
}

/**
 * Stringify the given `obj`.
 *
 * @param {Object} obj
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyObject(obj, prefix) {
  var ret = []
    , keys = objectKeys(obj)
    , key;

  for (var i = 0, len = keys.length; i < len; ++i) {
    key = keys[i];
    if ('' == key) continue;
    if (null == obj[key]) {
      ret.push(encodeURIComponent(key) + '=');
    } else {
      ret.push(stringify(obj[key], prefix
        ? prefix + '[' + encodeURIComponent(key) + ']'
        : encodeURIComponent(key)));
    }
  }

  return ret.join('&');
}

/**
 * Set `obj`'s `key` to `val` respecting
 * the weird and wonderful syntax of a qs,
 * where "foo=bar&foo=baz" becomes an array.
 *
 * @param {Object} obj
 * @param {String} key
 * @param {String} val
 * @api private
 */

function set(obj, key, val) {
  var v = obj[key];
  if (undefined === v) {
    obj[key] = val;
  } else if (isArray(v)) {
    v.push(val);
  } else {
    obj[key] = [v, val];
  }
}

/**
 * Locate last brace in `str` within the key.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function lastBraceInKey(str) {
  var len = str.length
    , brace
    , c;
  for (var i = 0; i < len; ++i) {
    c = str[i];
    if (']' == c) brace = false;
    if ('[' == c) brace = true;
    if ('=' == c && !brace) return i;
  }
}

/**
 * Decode `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function decode(str) {
  try {
    return decodeURIComponent(str.replace(/\+/g, ' '));
  } catch (err) {
    return str;
  }
}

},{}],60:[function(require,module,exports){
(function(){
  var crypt = require('crypt'),
      utf8 = require('charenc').utf8,
      bin = require('charenc').bin,

  // The core
  md5 = function (message) {
    // Convert to byte array
    if (message.constructor == String)
      message = utf8.stringToBytes(message);
    else if (!Array.isArray(message))
      message = message.toString();
    // else, assume byte array already

    var m = crypt.bytesToWords(message),
        l = message.length * 8,
        a =  1732584193,
        b = -271733879,
        c = -1732584194,
        d =  271733878;

    // Swap endian
    for (var i = 0; i < m.length; i++) {
      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |
             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;
    }

    // Padding
    m[l >>> 5] |= 0x80 << (l % 32);
    m[(((l + 64) >>> 9) << 4) + 14] = l;

    // Method shortcuts
    var FF = md5._ff,
        GG = md5._gg,
        HH = md5._hh,
        II = md5._ii;

    for (var i = 0; i < m.length; i += 16) {

      var aa = a,
          bb = b,
          cc = c,
          dd = d;

      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);
      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);
      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);
      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);
      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);
      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);
      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);
      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);
      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);
      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);
      c = FF(c, d, a, b, m[i+10], 17, -42063);
      b = FF(b, c, d, a, m[i+11], 22, -1990404162);
      a = FF(a, b, c, d, m[i+12],  7,  1804603682);
      d = FF(d, a, b, c, m[i+13], 12, -40341101);
      c = FF(c, d, a, b, m[i+14], 17, -1502002290);
      b = FF(b, c, d, a, m[i+15], 22,  1236535329);

      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);
      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);
      c = GG(c, d, a, b, m[i+11], 14,  643717713);
      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);
      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);
      d = GG(d, a, b, c, m[i+10],  9,  38016083);
      c = GG(c, d, a, b, m[i+15], 14, -660478335);
      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);
      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);
      d = GG(d, a, b, c, m[i+14],  9, -1019803690);
      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);
      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);
      a = GG(a, b, c, d, m[i+13],  5, -1444681467);
      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);
      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);
      b = GG(b, c, d, a, m[i+12], 20, -1926607734);

      a = HH(a, b, c, d, m[i+ 5],  4, -378558);
      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);
      c = HH(c, d, a, b, m[i+11], 16,  1839030562);
      b = HH(b, c, d, a, m[i+14], 23, -35309556);
      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);
      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);
      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);
      b = HH(b, c, d, a, m[i+10], 23, -1094730640);
      a = HH(a, b, c, d, m[i+13],  4,  681279174);
      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);
      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);
      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);
      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);
      d = HH(d, a, b, c, m[i+12], 11, -421815835);
      c = HH(c, d, a, b, m[i+15], 16,  530742520);
      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);

      a = II(a, b, c, d, m[i+ 0],  6, -198630844);
      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);
      c = II(c, d, a, b, m[i+14], 15, -1416354905);
      b = II(b, c, d, a, m[i+ 5], 21, -57434055);
      a = II(a, b, c, d, m[i+12],  6,  1700485571);
      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);
      c = II(c, d, a, b, m[i+10], 15, -1051523);
      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);
      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);
      d = II(d, a, b, c, m[i+15], 10, -30611744);
      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);
      b = II(b, c, d, a, m[i+13], 21,  1309151649);
      a = II(a, b, c, d, m[i+ 4],  6, -145523070);
      d = II(d, a, b, c, m[i+11], 10, -1120210379);
      c = II(c, d, a, b, m[i+ 2], 15,  718787259);
      b = II(b, c, d, a, m[i+ 9], 21, -343485551);

      a = (a + aa) >>> 0;
      b = (b + bb) >>> 0;
      c = (c + cc) >>> 0;
      d = (d + dd) >>> 0;
    }

    return crypt.endian([a, b, c, d]);
  };

  // Auxiliary functions
  md5._ff  = function (a, b, c, d, x, s, t) {
    var n = a + (b & c | ~b & d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._gg  = function (a, b, c, d, x, s, t) {
    var n = a + (b & d | c & ~d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._hh  = function (a, b, c, d, x, s, t) {
    var n = a + (b ^ c ^ d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._ii  = function (a, b, c, d, x, s, t) {
    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };

  // Package private blocksize
  md5._blocksize = 16;
  md5._digestsize = 16;

  module.exports = function (message, options) {
    var digestbytes = crypt.wordsToBytes(md5(message));
    return options && options.asBytes ? digestbytes :
        options && options.asString ? bin.bytesToString(digestbytes) :
        crypt.bytesToHex(digestbytes);
  };

})();

},{"crypt":73,"charenc":74}],67:[function(require,module,exports){

exports.Connection = require('./connection').Connection;
exports.Doc = require('./doc').Doc;

},{"./connection":75,"./doc":76}],73:[function(require,module,exports){
(function() {
  var base64map
      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',

  crypt = {
    // Bit-wise rotation left
    rotl: function(n, b) {
      return (n << b) | (n >>> (32 - b));
    },

    // Bit-wise rotation right
    rotr: function(n, b) {
      return (n << (32 - b)) | (n >>> b);
    },

    // Swap big-endian to little-endian and vice versa
    endian: function(n) {
      // If number given, swap endian
      if (n.constructor == Number) {
        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
      }

      // Else, assume array and swap all items
      for (var i = 0; i < n.length; i++)
        n[i] = crypt.endian(n[i]);
      return n;
    },

    // Generate an array of any length of random bytes
    randomBytes: function(n) {
      for (var bytes = []; n > 0; n--)
        bytes.push(Math.floor(Math.random() * 256));
      return bytes;
    },

    // Convert a byte array to big-endian 32-bit words
    bytesToWords: function(bytes) {
      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
        words[b >>> 5] |= bytes[i] << (24 - b % 32);
      return words;
    },

    // Convert big-endian 32-bit words to a byte array
    wordsToBytes: function(words) {
      for (var bytes = [], b = 0; b < words.length * 32; b += 8)
        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a hex string
    bytesToHex: function(bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 0xF).toString(16));
      }
      return hex.join('');
    },

    // Convert a hex string to a byte array
    hexToBytes: function(hex) {
      for (var bytes = [], c = 0; c < hex.length; c += 2)
        bytes.push(parseInt(hex.substr(c, 2), 16));
      return bytes;
    },

    // Convert a byte array to a base-64 string
    bytesToBase64: function(bytes) {
      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
        for (var j = 0; j < 4; j++)
          if (i * 8 + j * 6 <= bytes.length * 8)
            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
          else
            base64.push('=');
      }
      return base64.join('');
    },

    // Convert a base-64 string to a byte array
    base64ToBytes: function(base64) {
      // Remove non-base-64 characters
      base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;
          imod4 = ++i % 4) {
        if (imod4 == 0) continue;
        bytes.push(((base64map.indexOf(base64.charAt(i - 1))
            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))
            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
      }
      return bytes;
    }
  };

  module.exports = crypt;
})();

},{}],74:[function(require,module,exports){
var charenc = {
  // UTF-8 encoding
  utf8: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
    }
  },

  // Binary encoding
  bin: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      for (var bytes = [], i = 0; i < str.length; i++)
        bytes.push(str.charCodeAt(i) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      for (var str = [], i = 0; i < bytes.length; i++)
        str.push(String.fromCharCode(bytes[i]));
      return str.join('');
    }
  }
};

module.exports = charenc;

},{}],72:[function(require,module,exports){
var sha = require('./sha')
var rng = require('./rng')
var md5 = require('./md5')

var algorithms = {
  sha1: {
    hex: sha.hex_sha1,
    binary: sha.b64_sha1,
    ascii: sha.str_sha1
  },
  md5: {
    hex: md5.hex_md5,
    binary: md5.b64_md5,
    ascii: md5.any_md5
  }
}

function error () {
  var m = [].slice.call(arguments).join(' ')
  throw new Error([
    m,
    'we accept pull requests',
    'http://github.com/dominictarr/crypto-browserify'
    ].join('\n'))
}

exports.createHash = function (alg) {
  alg = alg || 'sha1'
  if(!algorithms[alg])
    error('algorithm:', alg, 'is not yet supported')
  var s = ''
  var _alg = algorithms[alg]
  return {
    update: function (data) {
      s += data
      return this
    },
    digest: function (enc) {
      enc = enc || 'binary'
      var fn
      if(!(fn = _alg[enc]))
        error('encoding:', enc , 'is not yet supported for algorithm', alg)
      var r = fn(s)
      s = null //not meant to use the hash after you've called digest.
      return r
    }
  }
}

exports.randomBytes = function(size, callback) {
  if (callback && callback.call) {
    try {
      callback.call(this, undefined, rng(size));
    } catch (err) { callback(err); }
  } else {
    return rng(size);
  }
}

// the least I can do is make error messages for the rest of the node.js/crypto api.
;['createCredentials'
, 'createHmac'
, 'createCypher'
, 'createCypheriv'
, 'createDecipher'
, 'createDecipheriv'
, 'createSign'
, 'createVerify'
, 'createDeffieHellman'
, 'pbkdf2'].forEach(function (name) {
  exports[name] = function () {
    error('sorry,', name, 'is not implemented yet')
  }
})

},{"./sha":77,"./rng":78,"./md5":79}],77:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

exports.hex_sha1 = hex_sha1;
exports.b64_sha1 = b64_sha1;
exports.str_sha1 = str_sha1;
exports.hex_hmac_sha1 = hex_hmac_sha1;
exports.b64_hmac_sha1 = b64_hmac_sha1;
exports.str_hmac_sha1 = str_hmac_sha1;

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = ""; /* base-64 pad character. "=" for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1("abc") == "a9993e364706816aba3e25717850c26c9cd0d89d";
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j < 80; j++)
    {
      if(j < 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t < 20) return (b & c) | ((~b) & d);
  if(t < 40) return b ^ c ^ d;
  if(t < 60) return (b & c) | (b & d) | (c & d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
         (t < 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length > 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters >255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < str.length * chrsz; i += chrsz)
    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = "";
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i>>5] >>> (32 - chrsz - i%32)) & mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +
           hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16)
                | (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 )
                |  ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);
    }
  }
  return str;
}


},{}],78:[function(require,module,exports){
// Original code adapted from Robert Kieffer.
// details at https://github.com/broofa/node-uuid
(function() {
  var _global = this;

  var mathRNG, whatwgRNG;

  // NOTE: Math.random() does not guarantee "cryptographic quality"
  mathRNG = function(size) {
    var bytes = new Array(size);
    var r;

    for (var i = 0, r; i < size; i++) {
      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;
      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return bytes;
  }

  // currently only available in webkit-based browsers.
  if (_global.crypto && crypto.getRandomValues) {
    var _rnds = new Uint32Array(4);
    whatwgRNG = function(size) {
      var bytes = new Array(size);
      crypto.getRandomValues(_rnds);

      for (var c = 0 ; c < size; c++) {
        bytes[c] = _rnds[c >> 2] >>> ((c & 0x03) * 8) & 0xff;
      }
      return bytes;
    }
  }

  module.exports = whatwgRNG || mathRNG;

}())
},{}],79:[function(require,module,exports){
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;   /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = "";  /* base-64 pad character. "=" for strict RFC compliance   */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_md5(s)    { return rstr2hex(rstr_md5(str2rstr_utf8(s))); }
function b64_md5(s)    { return rstr2b64(rstr_md5(str2rstr_utf8(s))); }
function any_md5(s, e) { return rstr2any(rstr_md5(str2rstr_utf8(s)), e); }
function hex_hmac_md5(k, d)
  { return rstr2hex(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
function b64_hmac_md5(k, d)
  { return rstr2b64(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
function any_hmac_md5(k, d, e)
  { return rstr2any(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)), e); }

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test()
{
  return hex_md5("abc").toLowerCase() == "900150983cd24fb0d6963f7d28e17f72";
}

/*
 * Calculate the MD5 of a raw string
 */
function rstr_md5(s)
{
  return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
}

/*
 * Calculate the HMAC-MD5, of a key and some data (raw strings)
 */
function rstr_hmac_md5(key, data)
{
  var bkey = rstr2binl(key);
  if(bkey.length > 16) bkey = binl_md5(bkey, key.length * 8);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
  return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));
}

/*
 * Convert a raw string to a hex string
 */
function rstr2hex(input)
{
  try { hexcase } catch(e) { hexcase=0; }
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var output = "";
  var x;
  for(var i = 0; i < input.length; i++)
  {
    x = input.charCodeAt(i);
    output += hex_tab.charAt((x >>> 4) & 0x0F)
           +  hex_tab.charAt( x        & 0x0F);
  }
  return output;
}

/*
 * Convert a raw string to a base-64 string
 */
function rstr2b64(input)
{
  try { b64pad } catch(e) { b64pad=''; }
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var output = "";
  var len = input.length;
  for(var i = 0; i < len; i += 3)
  {
    var triplet = (input.charCodeAt(i) << 16)
                | (i + 1 < len ? input.charCodeAt(i+1) << 8 : 0)
                | (i + 2 < len ? input.charCodeAt(i+2)      : 0);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > input.length * 8) output += b64pad;
      else output += tab.charAt((triplet >>> 6*(3-j)) & 0x3F);
    }
  }
  return output;
}

/*
 * Convert a raw string to an arbitrary string encoding
 */
function rstr2any(input, encoding)
{
  var divisor = encoding.length;
  var i, j, q, x, quotient;

  /* Convert to an array of 16-bit big-endian values, forming the dividend */
  var dividend = Array(Math.ceil(input.length / 2));
  for(i = 0; i < dividend.length; i++)
  {
    dividend[i] = (input.charCodeAt(i * 2) << 8) | input.charCodeAt(i * 2 + 1);
  }

  /*
   * Repeatedly perform a long division. The binary array forms the dividend,
   * the length of the encoding is the divisor. Once computed, the quotient
   * forms the dividend for the next step. All remainders are stored for later
   * use.
   */
  var full_length = Math.ceil(input.length * 8 /
                                    (Math.log(encoding.length) / Math.log(2)));
  var remainders = Array(full_length);
  for(j = 0; j < full_length; j++)
  {
    quotient = Array();
    x = 0;
    for(i = 0; i < dividend.length; i++)
    {
      x = (x << 16) + dividend[i];
      q = Math.floor(x / divisor);
      x -= q * divisor;
      if(quotient.length > 0 || q > 0)
        quotient[quotient.length] = q;
    }
    remainders[j] = x;
    dividend = quotient;
  }

  /* Convert the remainders to the output string */
  var output = "";
  for(i = remainders.length - 1; i >= 0; i--)
    output += encoding.charAt(remainders[i]);

  return output;
}

/*
 * Encode a string as utf-8.
 * For efficiency, this assumes the input is valid utf-16.
 */
function str2rstr_utf8(input)
{
  var output = "";
  var i = -1;
  var x, y;

  while(++i < input.length)
  {
    /* Decode utf-16 surrogate pairs */
    x = input.charCodeAt(i);
    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
    if(0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)
    {
      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
      i++;
    }

    /* Encode output as utf-8 */
    if(x <= 0x7F)
      output += String.fromCharCode(x);
    else if(x <= 0x7FF)
      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0xFFFF)
      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0x1FFFFF)
      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),
                                    0x80 | ((x >>> 12) & 0x3F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
  }
  return output;
}

/*
 * Encode a string as utf-16
 */
function str2rstr_utf16le(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode( input.charCodeAt(i)        & 0xFF,
                                  (input.charCodeAt(i) >>> 8) & 0xFF);
  return output;
}

function str2rstr_utf16be(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode((input.charCodeAt(i) >>> 8) & 0xFF,
                                   input.charCodeAt(i)        & 0xFF);
  return output;
}

/*
 * Convert a raw string to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */
function rstr2binl(input)
{
  var output = Array(input.length >> 2);
  for(var i = 0; i < output.length; i++)
    output[i] = 0;
  for(var i = 0; i < input.length * 8; i += 8)
    output[i>>5] |= (input.charCodeAt(i / 8) & 0xFF) << (i%32);
  return output;
}

/*
 * Convert an array of little-endian words to a string
 */
function binl2rstr(input)
{
  var output = "";
  for(var i = 0; i < input.length * 32; i += 8)
    output += String.fromCharCode((input[i>>5] >>> (i % 32)) & 0xFF);
  return output;
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */
function binl_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);
}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}


exports.hex_md5 = hex_md5;
exports.b64_md5 = b64_md5;
exports.any_md5 = any_md5;

},{}],80:[function(require,module,exports){
// This is a simple rewrite of microevent.js. I've changed the
// function names to be consistent with node.js EventEmitter.
//
// microevent.js is copyright Jerome Etienne, and licensed under the MIT license:
// https://github.com/jeromeetienne/microevent.js

var MicroEvent = function() {};

MicroEvent.prototype.on = function(event, fn) {
  var events = this._events = this._events || {};
  (events[event] = events[event] || []).push(fn);
};

MicroEvent.prototype.removeListener = function(event, fn) {
  var events = this._events = this._events || {};
  var listeners = events[event] = events[event] || [];

  // Sadly, no IE8 support for indexOf.
  var i = 0;
  while (i < listeners.length) {
    if (listeners[i] === fn) {
      listeners[i] = undefined;
    }
    i++;
  }

  // Compact the list when no event handler is actually running.
  setTimeout(function() {
    events[event] = [];
    var fn;
    for (var i = 0; i < listeners.length; i++) {
      // Only add back event handlers which exist.
      if ((fn = listeners[i])) events[event].push(fn);
    }
  }, 0);
};

MicroEvent.prototype.emit = function(event) {
  var events = this._events;
  var args = Array.prototype.splice.call(arguments, 1);

  if (!events || !events[event]) {
    if (event == 'error') {
      if (console) {
        console.error.apply(console, args);
      }
    }
    return;
  }

  var listeners = events[event];
  for (var i = 0; i < listeners.length; i++) {
    if (listeners[i]) {
      listeners[i].apply(this, args);
    }
  }
};

MicroEvent.prototype.once = function(event, fn) {
  var listener, _this = this;
  this.on(event, listener = function() {
    _this.removeListener(event, listener);
    fn.apply(_this, arguments);
  });
};

MicroEvent.mixin = function(obj) {
  var proto = obj.prototype || obj;
  proto.on = MicroEvent.prototype.on;
  proto.removeListener = MicroEvent.prototype.removeListener;
  proto.emit = MicroEvent.prototype.emit;
  proto.once = MicroEvent.prototype.once;
  return obj;
};

if (typeof module !== "undefined") module.exports = MicroEvent;


},{}],81:[function(require,module,exports){
var Doc;
if (typeof require !== 'undefined') {
  Doc = require('./doc').Doc;
}

// Queries are live requests to the database for particular sets of fields.
//
// The server actively tells the client when there's new data that matches
// a set of conditions.
var Query = exports.Query = function(type, connection, id, collection, query, options, callback) {
  // 'fetch' or 'sub'
  this.type = type;

  this.connection = connection;
  this.id = id;
  this.collection = collection;

  // The query itself. For mongo, this should look something like {"data.x":5}
  this.query = query;

  // Resultant document action for the server. Fetch mode will automatically
  // fetch all results. Subscribe mode will automatically subscribe all
  // results. Results are never unsubscribed.
  this.docMode = options.docMode; // undefined, 'fetch' or 'sub'.
  if (this.docMode === 'subscribe') this.docMode = 'sub';

  // Do we repoll the entire query whenever anything changes? (As opposed to
  // just polling the changed item). This needs to be enabled to be able to use
  // ordered queries (sortby:) and paginated queries. Set to undefined, it will
  // be enabled / disabled automatically based on the query's properties.
  this.poll = options.poll;

  // The backend we actually hit. If this isn't defined, it hits the snapshot
  // database. Otherwise this can be used to hit another configured query
  // index.
  this.backend = options.backend || options.source;

  // A list of resulting documents. These are actual documents, complete with
  // data and all the rest. If fetch is false, these documents will not
  // have any data. You should manually call fetch() or subscribe() on them.
  //
  // Calling subscribe() might be a good idea anyway, as you won't be
  // subscribed to the documents by default.
  this.knownDocs = options.knownDocs || [];
  this.results = [];

  // Do we have some initial data?
  this.ready = false;

  this.callback = callback;
};
Query.prototype.action = 'qsub';

// Helper for subscribe & fetch, since they share the same message format.
//
// This function actually issues the query.
Query.prototype._execute = function() {
  if (!this.connection.canSend) return;

  if (this.docMode) {
    var collectionVersions = {};
    // Collect the version of all the documents in the current result set so we
    // don't need to be sent their snapshots again.
    for (var i = 0; i < this.knownDocs.length; i++) {
      var doc = this.knownDocs[i];
      var c = collectionVersions[doc.collection] = collectionVersions[doc.collection] || {};
      c[doc.name] = doc.version;
    }
  }

  var msg = {
    a: 'q' + this.type,
    id: this.id,
    c: this.collection,
    o: {},
    q: this.query,
  };

  if (this.docMode) {
    msg.o.m = this.docMode;
    // This should be omitted if empty, but whatever.
    msg.o.vs = collectionVersions;
  }
  if (this.backend != null) msg.o.b = this.backend;
  if (this.poll !== undefined) msg.o.p = this.poll;

  this.connection.send(msg);
};

// Make a list of documents from the list of server-returned data objects
Query.prototype._dataToDocs = function(data) {
  var results = [];
  var lastType;
  for (var i = 0; i < data.length; i++) {
    var docData = data[i];

    // Types are only put in for the first result in the set and every time the type changes in the list.
    if (docData.type) {
      lastType = docData.type;
    } else {
      docData.type = lastType;
    }

    var doc = this.connection.get(docData.c || this.collection, docData.d, docData);
    // Force the document to know its subscribed if we're in docmode:subscribe.
    if (this.docMode === 'sub') {
      doc.subscribed = true; // Set before setWantSubscribe() so flush doesn't send a subscribe request.
      doc._setWantSubscribe(true); // this will call any subscribe callbacks or whatever.
      doc.emit('subscribe');
      doc._finishSub(true); // this doesn't actually do anything here, but its more correct to have it.
    }
    results.push(doc);
  }
  return results;
};

// Destroy the query object. Any subsequent messages for the query will be
// ignored by the connection. You should unsubscribe from the query before
// destroying it.
Query.prototype.destroy = function() {
  if (this.connection.canSend && this.type === 'sub') {
    this.connection.send({a:'qunsub', id:this.id});
  }

  this.connection._destroyQuery(this);
};

Query.prototype._onConnectionStateChanged = function(state, reason) {
  if (this.connection.state === 'connecting') {
    this._execute();
  }
};

// Internal method called from connection to pass server messages to the query.
Query.prototype._onMessage = function(msg) {
  if ((msg.a === 'qfetch') !== (this.type === 'fetch')) {
    if (console) console.warn('Invalid message sent to query', msg, this);
    return;
  }

  if (msg.error) this.emit('error', msg.error);

  switch (msg.a) {
    case 'qfetch':
      var results = msg.data ? this._dataToDocs(msg.data) : undefined;
      if (this.callback) this.callback(msg.error, results, msg.extra);
      // Once a fetch query gets its data, it is destroyed.
      this.connection._destroyQuery(this);
      break;

    case 'q':
      // Query diff data (inserts and removes)
      if (msg.diff) {
        // We need to go through the list twice. First, we'll injest all the
        // new documents and set them as subscribed.  After that we'll emit
        // events and actually update our list. This avoids race conditions
        // around setting documents to be subscribed & unsubscribing documents
        // in event callbacks.
        for (var i = 0; i < msg.diff.length; i++) {
          var d = msg.diff[i];
          if (d.type === 'insert') d.values = this._dataToDocs(d.values);
        }

        for (var i = 0; i < msg.diff.length; i++) {
          var d = msg.diff[i];
          switch (d.type) {
            case 'insert':
              var newDocs = d.values;
              Array.prototype.splice.apply(this.results, [d.index, 0].concat(newDocs));
              this.emit('insert', newDocs, d.index);
              break;
            case 'remove':
              var howMany = d.howMany || 1;
              var removed = this.results.splice(d.index, howMany);
              this.emit('remove', removed, d.index);
              break;
            case 'move':
              var howMany = d.howMany || 1;
              var docs = this.results.splice(d.from, howMany);
              Array.prototype.splice.apply(this.results, [d.to, 0].concat(docs));
              this.emit('move', docs, d.from, d.to);
              break;
          }
        }
      }

      if (msg.extra) {
        this.emit('extra', msg.extra);
      }
      break;
    case 'qsub':
      // This message replaces the entire result set with the set passed.
      if (!msg.error) {
        var previous = this.results;

        // Then add everything in the new result set.
        this.results = this.knownDocs = this._dataToDocs(msg.data);
        this.extra = msg.extra;

        this.ready = true;
        this.emit('change', this.results, previous);
      }
      if (this.callback) {
        this.callback(msg.error, this.results, this.extra);
        delete this.callback;
      }
      break;
  }
};

// Change the thing we're searching for. This isn't fully supported on the
// backend (it destroys the old query and makes a new one) - but its
// programatically useful and I might add backend support at some point.
Query.prototype.setQuery = function(q) {
  if (this.type !== 'sub') throw new Error('cannot change a fetch query');

  this.query = q;
  if (this.connection.canSend) {
    // There's no 'change' message to send to the server. Just resubscribe.
    this.connection.send({a:'qunsub', id:this.id});
    this._execute();
  }
};

var MicroEvent;
if (typeof require !== 'undefined') {
  MicroEvent = require('./microevent');
}

MicroEvent.mixin(Query);


},{"./doc":76,"./microevent":80}],75:[function(require,module,exports){
// A Connection wraps a persistant BC connection to a sharejs server.
//
// This class implements the client side of the protocol defined here:
// https://github.com/josephg/ShareJS/wiki/Wire-Protocol
//
// The equivalent server code is in src/server/session.
//
// This file is a bit of a mess. I'm dreadfully sorry about that. It passes all the tests,
// so I have hope that its *correct* even if its not clean.
//
// To make a connection, use:
//  new sharejs.Connection(socket)
//
// The socket should look like a websocket connection. It should have the following properties:
//  send(msg): Send the given message. msg may be an object - if so, you might need to JSON.stringify it.
//  close(): Disconnect the session
//
//  onmessage = function(msg){}: Event handler which is called whenever a message is received. The message
//     passed in should already be an object. (It may need to be JSON.parsed)
//  onclose
//  onerror
//  onopen
//  onconnecting
//
// The socket should probably automatically reconnect. If so, it should emit the appropriate events as it
// disconnects & reconnects. (onclose(), onconnecting(), onopen()).

var types, Doc;
if (typeof require !== 'undefined') {
  types = require('ottypes');
  Doc = require('./doc').Doc;
  Query = require('./query').Query;
} else {
  types = window.ottypes;
  Doc = exports.Doc;
}

var Connection = exports.Connection = function (socket) {
  this.socket = socket;

  // Map of collection -> docName -> doc object for created documents.
  // (created documents MUST BE UNIQUE)
  this.collections = {};

  // Each query is created with an id that the server uses when it sends us
  // info about the query (updates, etc).
  //this.nextQueryId = (Math.random() * 1000) |0;
  this.nextQueryId = 1;

  // Map from query ID -> query object.
  this.queries = {};

  // Connection state.
  // 
  // States:
  // - 'connecting': The connection has been established, but we don't have our client ID yet
  // - 'connected': We have connected and recieved our client ID. Ready for data.
  // - 'disconnected': The connection is closed, but it will reconnect automatically.
  // - 'stopped': The connection is closed, and should not reconnect.
  this.state = (socket.readyState === 0 || socket.readyState === 1) ? 'connecting' : 'disconnected';

  // This is a helper variable the document uses to see whether we're currently
  // in a 'live' state. It is true if the state is 'connecting' or 'connected'.
  this.canSend = this.state === 'connecting';

  // Reset some more state variables.
  this.reset();

  this.debug = false;
  // I'll store the most recent 100 messages so when errors occur we can see what happened.
  this.messageBuffer = [];

  var connection = this;

  var handleMessage = function(msg) {
    // Switch on the message action. Most messages are for documents and are
    // handled in the doc class.
    switch (msg.a) {
      case 'init':
        // Client initialization packet. This bundle of joy contains our client
        // ID.
        if (msg.protocol !== 0) throw new Error('Invalid protocol version');
        if (typeof msg.id != 'string') throw new Error('Invalid client id');

        connection.id = msg.id;
        connection._setState('connected');
        break;

      case 'qfetch':
      case 'qsub':
      case 'q':
      case 'qunsub':
        // Query message. Pass this to the appropriate query object.
        var query = connection.queries[msg.id];
        if (query) query._onMessage(msg);
        break;

      case 'bs':
        // Bulk subscribe response. The responses for each document are contained within.
        var result = msg.s;
        for (var cName in result) {
          for (var docName in result[cName]) {
            var doc = connection.get(cName, docName);
            if (!doc) {
              if (console) console.error('Message for unknown doc. Ignoring.', msg);
              break;
            }

            var msg = result[cName][docName];
            if (typeof msg === 'object') {
              doc._handleSubscribe(msg.error, msg.data);
            } else {
              // The msg will be true if we simply resubscribed.
              doc._handleSubscribe(null, null);
            }
          }
        }
        break;

      default:
        // Document message. Pull out the referenced document and forward the
        // message.
        var collection, docName, doc;
        if (msg.d) {
          collection = connection._lastReceivedCollection = msg.c;
          docName = connection._lastReceivedDoc = msg.d;
        } else {
          collection = msg.c = connection._lastReceivedCollection;
          docName = msg.d = connection._lastReceivedDoc;
        }

        doc = connection.get(collection, docName);
        if (!doc) {
          if (console) console.error('Message for unknown doc. Ignoring.', msg);
          break;
        }
        doc._onMessage(msg);
    }
  };

  // Attach event handlers to the socket.
  socket.onmessage = function(msg) {
    if (connection.debug) console.log('RECV', JSON.stringify(msg));
    connection.messageBuffer.push({t:(new Date()).toTimeString(), recv:JSON.stringify(msg)});
    while (connection.messageBuffer.length > 100) {
      connection.messageBuffer.shift();
    }

    try {
      handleMessage(msg);
    } catch (e) {
      connection.emit('error', e);
      // We could also restart the connection here, although that might result
      // in infinite reconnection bugs.
    }
  }

  socket.onopen = function() {
    connection._setState('connecting');
  };

  socket.onerror = function(e) {
    // This isn't the same as a regular error, because it will happen normally
    // from time to time. Your connection should probably automatically
    // reconnect anyway, but that should be triggered off onclose not onerror.
    // (onclose happens when onerror gets called anyway).
    connection.emit('connection error', e);
  };

  socket.onclose = function(reason) {
    connection._setState('disconnected', reason);
    if (reason === 'Closed' || reason === 'Stopped by server') {
      connection._setState('stopped', reason);
    }
  };
}

/* Why does this function exist? Is it important?
Connection.prototype._error = function(e) {
  this._setState('stopped', e);
  return this.disconnect(e);
};
*/

Connection.prototype.reset = function() {
  this.id = this.lastError =
    this._lastReceivedCollection = this._lastReceivedDoc =
    this._lastSentCollection = this._lastSentDoc = null;

  this.seq = 1;
};

// Set the connection's state. The connection is basically a state machine.
Connection.prototype._setState = function(newState, data) {
  if (this.state === newState) return;

  // I made a state diagram. The only invalid transitions are getting to
  // 'connecting' from anywhere other than 'disconnected' and getting to
  // 'connected' from anywhere other than 'connecting'.
  if ((newState === 'connecting' && (this.state !== 'disconnected' && this.state !== 'stopped'))
      || (newState === 'connected' && this.state !== 'connecting')) {
    throw new Error("Cannot transition directly from " + this.state + " to " + newState);
  }

  this.state = newState;
  this.canSend = newState === 'connecting' || newState === 'connected';

  if (newState === 'disconnected') this.reset();

  this.emit(newState, data);

  // & Emit the event to all documents & queries. It might make sense for
  // documents to just register for this stuff using events, but that couples
  // connections and documents a bit much. Its not a big deal either way.
  this.opQueue = [];
  this.subscribeData = {};
  for (var c in this.collections) {
    var collection = this.collections[c];
    for (var docName in collection) {
      collection[docName]._onConnectionStateChanged(newState, data);
    }
  }


  // Its important that operations are resent in the same order that they were
  // originally sent. If we don't sort, an op with a high sequence number will
  // convince the server not to accept any ops with earlier sequence numbers.
  this.opQueue.sort(function(a, b) { return a.seq - b.seq; });
  for (var i = 0; i < this.opQueue.length; i++) {
    this.send(this.opQueue[i]);
  }

  // Only send bulk subscribe if not empty. Its weird using a for loop for
  // this, but it works pretty well.
  for (var __unused in this.subscribeData) { 
    this.send({a:'bs', s:this.subscribeData});
    break;
  }

  this.opQueue = null;
  this.subscribeData = null;
  
  // No bulk subscribe for queries yet.
  for (var id in this.queries) {
    this.queries[id]._onConnectionStateChanged(newState, data);
  }
};

// So, there's an awful error case where the client sends two requests (which
// fail), then reconnects. The documents could have _onConnectionStateChanged
// called in the wrong order and the operations then get sent with reversed
// sequence numbers. This causes the server to incorrectly reject the second
// sent op. So we need to queue the operations while we're reconnecting and
// resend them in the correct order.
Connection.prototype.sendOp = function(data) {
  if (this.opQueue) {
    this.opQueue.push(data);
  } else {
    this.send(data);
  }
};

// This is called by the document class when the document wants to subscribe.
// We could just send a subscribe message, but during reconnect that causes a
// bajillion messages over browserchannel. During reconnect we'll aggregate,
// similar to sendOp.
Connection.prototype.sendSubscribe = function(collection, name, v) {
  if (this.subscribeData) {
    var data = this.subscribeData;
    if (!data[collection]) data[collection] = {};

    data[collection][name] = v || null;
  } else {
    var msg = {a:'sub', c:collection, d:name};
    if (v != null) msg.v = v;
    this.send(msg);
  }
};

// Send a message to the connection.
Connection.prototype.send = function(msg) {
  if (this.debug) console.log("SEND", JSON.stringify(msg));
  this.messageBuffer.push({t:Date.now(), send:JSON.stringify(msg)});
  while (this.messageBuffer.length > 100) {
    this.messageBuffer.shift();
  }

  if (msg.d) { // The document the message refers to. Not set for queries.
    var collection = msg.c;
    var docName = msg.d;
    if (collection === this._lastSentCollection && docName === this._lastSentDoc) {
      delete msg.c;
      delete msg.d;
    } else {
      this._lastSentCollection = collection;
      this._lastSentDoc = docName;
    }
  }

  this.socket.send(msg);
};

Connection.prototype.disconnect = function() {
  // This will call @socket.onclose(), which in turn will emit the 'disconnected' event.
  this.socket.close();
};


// ***** Document management

Connection.prototype.getExisting = function(collection, name) {
  if (this.collections[collection]) return this.collections[collection][name];
};

Connection.prototype.getOrCreate = function(collection, name, data) {
  console.trace('getOrCreate is deprecated. Use get() instead');
  return this.get(collection, name, data);
};

// Create a document if it doesn't exist. Returns the document synchronously.
Connection.prototype.get = function(collection, name, data) {
  var doc = this.getExisting(collection, name);

  if (!doc) {
    // Create it.
    doc = new Doc(this, collection, name);

    var collectionObject = this.collections[collection] =
      (this.collections[collection] || {});
    collectionObject[name] = doc;
  }

  // Even if the document isn't new, its possible the document was created
  // manually and then tried to be re-created with data (suppose a query
  // returns with data for the document). We should hydrate the document
  // immediately if we can because the query callback will expect the document
  // to have data.
  if (data && data.data !== undefined && !doc.state) {
    doc.injestData(data);
  }

  return doc;
};

// Call doc.destroy()
Connection.prototype._destroyDoc = function(doc) {
  var collectionObject = this.collections[doc.collection];
  if (!collectionObject) return;

  delete collectionObject[doc.name];

  // Delete the collection container if its empty. This could be a source of
  // memory leaks if you slowly make a billion collections, which you probably
  // won't do anyway, but whatever.
  if (!hasKeys(collectionObject))
    delete this.collections[doc.collection];
};
 
function hasKeys(object) {
  for (var key in object) return true;
  return false;
};

// **** Queries.

// Helper for createFetchQuery and createSubscribeQuery, below.
Connection.prototype._createQuery = function(type, collection, q, options, callback) {
  if (type !== 'fetch' && type !== 'sub')
    throw new Error('Invalid query type: ' + type);

  if (!options) options = {};
  var id = this.nextQueryId++;
  var query = new Query(type, this, id, collection, q, options, callback);
  this.queries[id] = query;
  query._execute();
  return query;
};

// Internal function. Use query.destroy() to remove queries.
Connection.prototype._destroyQuery = function(query) {
  delete this.queries[query.id];
};

// The query options object can contain the following fields:
//
// docMode: What to do with documents that are in the result set. Can be
//   null/undefined (default), 'fetch' or 'subscribe'. Fetch mode indicates
//   that the server should send document snapshots to the client for all query
//   results. These will be hydrated into the document objects before the query
//   result callbacks are returned. Subscribe mode gets document snapshots and
//   automatically subscribes the client to all results. Note that the
//   documents *WILL NOT* be automatically unsubscribed when the query is
//   destroyed. (ShareJS doesn't have enough information to do that safely).
//   Beware of memory leaks when using this option.
//
// poll: Forcably enable or disable polling mode. Polling mode will reissue the query
//   every time anything in the collection changes (!!) so, its quite
//   expensive.  It is automatically enabled for paginated and sorted queries.
//   By default queries run with polling mode disabled; which will only check
//   changed documents to test if they now match the specified query.
//   Set to false to disable polling mode, or true to enable it. If you don't
//   specify a poll option, polling mode is enabled or disabled automatically
//   by the query's backend.
//
// backend: Set the backend source for the query. You can attach different
//   query backends to livedb and pick which one the query should hit using
//   this parameter.
//
// results: (experimental) Initial list of resultant documents. This is
//   useful for rehydrating queries when you're using autoFetch / autoSubscribe
//   so the server doesn't have to send over snapshots for documents the client
//   already knows about. This is experimental - the API may change in upcoming
//   versions.

// Create a fetch query. Fetch queries are only issued once, returning the
// results directly into the callback.
//
// The index is specific to the source, but if you're using mongodb it'll be
// the collection to which the query is made.
// The callback should have the signature function(error, results, extraData)
// where results is a list of Doc objects.
Connection.prototype.createFetchQuery = function(index, q, options, callback) {
  return this._createQuery('fetch', index, q, options, callback);
};

// Create a subscribe query. Subscribe queries return with the initial data
// through the callback, then update themselves whenever the query result set
// changes via their own event emitter.
//
// If present, the callback should have the signature function(error, results, extraData)
// where results is a list of Doc objects.
Connection.prototype.createSubscribeQuery = function(index, q, options, callback) {
  return this._createQuery('sub', index, q, options, callback);
};

if (typeof require !== 'undefined') {
  MicroEvent = require('./microevent');
}

MicroEvent.mixin(Connection);


},{"./doc":76,"./microevent":80,"./query":81,"ottypes":82}],76:[function(require,module,exports){
var types, MicroEvent;

if (typeof require !== "undefined") {
  types = require('ottypes');
  MicroEvent = require('./microevent');
} else {
  types = window.ottypes;
}

/*
 * A Doc is a client's view on a sharejs document.
 *
 * Documents should not be created directly. Create them by calling the
 * document getting functions in connection.
 *
 * Documents are event emitters. Use doc.on(eventname, fn) to subscribe.
 *
 * Documents currently get mixed in with their type's API methods. So, you can
 * .insert('foo', 0) into a text document and stuff like that.
 *
 * Events:
 * - before op (op, localSite): Fired before an operation is applied to the
 *   document.
 * - op (op, localSite): Fired right after an operation (or part of an
 *   operation) has been applied to the document. Submitting another op here is
 *   invalid - wait until 'after op' if you want to submit more operations.  -
 *   changed (op)
 * - after op (op, localSite): Fired after an operation has been applied. You
 *   can submit more ops here.
 * - subscribed (error): The document was subscribed
 * - unsubscribed (error): The document was unsubscribed
 * - created: The document was created. That means its type was set and it has
 *   some initial data.
 * - error
 */
var Doc = exports.Doc = function(connection, collection, name) {
  this.connection = connection;

  this.collection = collection;
  this.name = name;

  this.version = this.type = null;

  // **** State in document:
 
  // Action. This is either null, or one of the actions (subscribe,
  // unsubscribe, fetch, submit). Only one action can be happening at a time to
  // prevent me from going mad.
  //
  // Possible values:
  // - subscribe
  // - unsubscribe
  // - fetch
  // - submit
  this.action = null;
 
  // The data the document object stores can be in one of the following three states:
  //   - No data. (null) We honestly don't know whats going on.
  //   - Floating ('floating'): we have a locally created document that hasn't
  //     been created on the server yet)
  //   - Live ('ready') (we have data thats current on the server at some version).
  this.state = null;

  // Our subscription status. Either we're subscribed on the server, or we aren't.
  this.subscribed = false;
  // Either we want to be subscribed (true), we want a new snapshot from the
  // server ('fetch'), or we don't care (false).  This is also used when we
  // disconnect & reconnect to decide what to do.
  this.wantSubscribe = false;
  // This list is used for subscribe and unsubscribe, since we'll only want to
  // do one thing at a time.
  this._subscribeCallbacks = [];


  // *** end state stuff.

  // This doesn't provide any standard API access right now.
  this.provides = {};

  // The editing contexts. These are usually instances of the type API when the
  // document is ready for edits.
  this.editingContexts = [];
  
  // The op that is currently roundtripping to the server, or null.
  //
  // When the connection reconnects, the inflight op is resubmitted.
  //
  // This has the same format as an entry in pendingData, which is:
  // {[create:{...}], [del:true], [op:...], callbacks:[...], src:, seq:}
  this.inflightData = null;

  // All ops that are waiting for the server to acknowledge @inflightData
  // This used to just be a single operation, but creates & deletes can't be composed with
  // regular operations.
  //
  // This is a list of {[create:{...}], [del:true], [op:...], callbacks:[...]}
  this.pendingData = [];
};

MicroEvent.mixin(Doc);

Doc.prototype.destroy = function(callback) {
  var doc = this;
  this.unsubscribe(function() {
    // Don't care if there's an error unsubscribing.

    setTimeout(function() {
      // There'll probably be nothing here seeing as how we just unsubscribed.
      for (var i = 0; i < doc._subscribeCallbacks.length; i++) {
        doc._subscribeCallbacks[i]('Document destroyed');
      }
      doc._subscribeCallbacks.length = 0;
    }, 0);

    doc.connection._destroyDoc(doc);
    doc.removeContexts();
    if (callback) callback();
  });
};


// ****** Manipulating the document snapshot, version and type.

// Set the document's type, and associated properties. Most of the logic in
// this function exists to update the document based on any added & removed API
// methods.
Doc.prototype._setType = function(newType) {
  if (typeof newType === 'string') {
    if (!types[newType]) throw new Error("Missing type " + newType);
    newType = types[newType];
  }
  this.removeContexts();

  // Set the new type
  this.type = newType;

  // If we removed the type from the object, also remove its snapshot.
  if (!newType) {
    this.provides = {};
  } else if (newType.api) {
    // Register the new type's API.
    this.provides = newType.api.provides;
  }
};

// Injest snapshot data. This data must include a version, snapshot and type.
// This is used both to injest data that was exported with a webpage and data
// that was received from the server during a fetch.
Doc.prototype.injestData = function(data) {
  if (this.state) {
    if (typeof console !== "undefined") console.warn('Ignoring attempt to injest data in state', this.state);
    return;
  }
  if (typeof data.v !== 'number') throw new Error('Missing version in injested data');


  this.version = data.v;
  // data.data is what the server will actually send. data.snapshot is the old
  // field name - supported now for backwards compatibility.
  this.snapshot = data.data || data.snapshot;
  this._setType(data.type);

  this.state = 'ready';
  this.emit('ready');
};

// Get and return the current document snapshot.
Doc.prototype.getSnapshot = function() {
  return this.snapshot;
};

// The callback will be called at a time when the document has a snapshot and
// you can start applying operations. This may be immediately.
Doc.prototype.whenReady = function(fn) {
  if (this.state === 'ready') {
    fn();
  } else {
    this.on('ready', fn);
  }
};

Doc.prototype.hasPending = function() {
  return this.inflightData != null || !!this.pendingData.length;
};


// **** Helpers for network messages

// Send a message to the connection from this document.
Doc.prototype._send = function(message) {
  message.c = this.collection;
  message.d = this.name;
  this.connection.send(message);
};

// This function exists so connection can call it directly for bulk subscribes.
// It could just make a temporary object literal, thats pretty slow.
Doc.prototype._handleSubscribe = function(err, data) {
  if (err && err !== 'Already subscribed') {
    if (console) console.error("Could not subscribe: " + err);
    this.emit('error', err);
    // There's probably a reason we couldn't subscribe. Don't retry.
    this._setWantSubscribe(false, null, err)
  } else {
    if (data) this.injestData(data);
    this.subscribed = true;
    this.emit('subscribe');
    this._finishSub(true);
  }

  this._clearAction('subscribe');
};

// This is called by the connection when it receives a message for the document.
Doc.prototype._onMessage = function(msg) {
  if (!(msg.c === this.collection && msg.d === this.name)) {
    // This should never happen - its a sanity check for bugs in the connection code.
    throw new Error("Got message for wrong document.");
  }

  // msg.a = the action.
  switch (msg.a) {
    case 'fetch':
      // We're done fetching. This message has no other information.
      if (msg.data) this.injestData(msg.data);
      this._finishSub('fetch', msg.error);
      if (this.wantSubscribe === 'fetch') this.wantSubscribe = false;
      this._clearAction('fetch');
      break;

    case 'sub':
      // Subscribe reply.
      this._handleSubscribe(msg.error, msg.data);
      break;

    case 'unsub':
      // Unsubscribe reply
      this.subscribed = false;
      this.emit('unsubscribe');

      this._finishSub(false, msg.error);
      this._clearAction('unsubscribe');
      break;

    case 'ack':
      // Acknowledge a locally submitted operation.
      //
      // Usually we do nothing here - all the interesting logic happens when we
      // get sent our op back in the op stream (which happens even if we aren't
      // subscribed). However, if the op doesn't get accepted, we still need to
      // clear some state.
      //
      // If the message error is 'Op already submitted', that means we've
      // resent an op that the server already got. It will also be confirmed
      // normally.
      if (msg.error && msg.error !== 'Op already submitted') {
        // The server has rejected an op from the client for some reason.
        // We'll send the error message to the user and try to roll back the change.
        if (this.inflightData) {
          console.warn('Operation was rejected (' + msg.error + '). Trying to rollback change locally.');
          this._tryRollback(this.inflightData);
        } else {
          // I managed to get into this state once. I'm not sure how it happened.
          // The op was maybe double-acknowledged?
          if (console) console.warn('Second acknowledgement message (error) received', msg, this);
        }
          
        this._clearInflightOp(msg.error);
      }
      break;

    case 'op':
      if (this.inflightData &&
          msg.src === this.inflightData.src &&
          msg.seq === this.inflightData.seq) {
        // This one is mine. Accept it as acknowledged.
        this._opAcknowledged(msg);
        break;
      }

      if (msg.v !== this.version) {
        // This will happen naturally in the following (or similar) cases:
        //
        // Client is not subscribed to document.
        // -> client submits an operation (v=10)
        // -> client subscribes to a query which matches this document. Says we
        //    have v=10 of the doc.
        //
        // <- server acknowledges the operation (v=11). Server acknowledges the
        //    operation because the doc isn't subscribed
        // <- server processes the query, which says the client only has v=10.
        //    Server subscribes at v=10 not v=11, so we get another copy of the
        //    v=10 operation.
        //
        // In this case, we can safely ignore the old (duplicate) operation.
        break;
      }

      if (this.inflightData) xf(this.inflightData, msg);

      for (var i = 0; i < this.pendingData.length; i++) {
        xf(this.pendingData[i], msg);
      }

      this.version++;
      this._otApply(msg, false);
      this._afterOtApply(msg, false);
      //console.log('applied', JSON.stringify(msg));
      break;

    case 'meta':
      if (console) console.warn('Unhandled meta op:', msg);
      break;

    default:
      if (console) console.warn('Unhandled document message:', msg);
      break;
  }
};

// Called whenever (you guessed it!) the connection state changes. This will
// happen when we get disconnected & reconnect.
Doc.prototype._onConnectionStateChanged = function(state, reason) {
  if (state === 'connecting') {
    if (this.inflightData) {
      this._sendOpData();
    } else {
      this.flush();
    }
  } else if (state === 'connected') {
    // We go into the connected state once we have a sessionID. We can't send
    // new ops until then, so we need to flush again.
    this.flush();
  } else if (state === 'disconnected') {
    this.action = null;
    this.subscribed = false;
    if (this.subscribed) this.emit('unsubscribed');
  }
};




// ****** Dealing with actions

Doc.prototype._clearAction = function(expectedAction) {
  if (this.action !== expectedAction) {
    console.warn('Unexpected action ' + this.action + ' expected: ' + expectedAction);
  }
  this.action = null;
  this.flush();
};



// Send the next pending op to the server, if we can.
//
// Only one operation can be in-flight at a time. If an operation is already on
// its way, or we're not currently connected, this method does nothing.
Doc.prototype.flush = function() {
  if (!this.connection.canSend || this.action) return;

  var opData;
  // Pump and dump any no-ops from the front of the pending op list.
  while (this.pendingData.length && isNoOp(opData = this.pendingData[0])) {
    var callbacks = opData.callbacks;
    for (var i = 0; i < callbacks.length; i++) {
      callbacks[i](opData.error);
    }
    this.pendingData.shift();
  }

  // First consider changing state
  if (this.subscribed && !this.wantSubscribe) {
    this.action = 'unsubscribe';
    this._send({a:'unsub'});
  } else if (!this.subscribed && this.wantSubscribe === 'fetch') {
    this.action = 'fetch';
    this._send(this.state === 'ready' ? {a:'fetch', v:this.version} : {a:'fetch'});
  } else if (!this.subscribed && this.wantSubscribe) {
    this.action = 'subscribe';
    // Special send method needed for bulk subscribes on reconnect.
    this.connection.sendSubscribe(this.collection, this.name, this.state === 'ready' ? this.version : null);
  } else if (!this.paused && this.pendingData.length && this.connection.state === 'connected') {
    // Try and send any pending ops. We can't send ops while in 
    this.inflightData = this.pendingData.shift();

    // Delay for debugging.
    //var that = this;
    //setTimeout(function() { that._sendOpData(); }, 1000);

    // This also sets action to 'submit'.
    this._sendOpData();
  }
};


// ****** Subscribing, unsubscribing and fetching

// These functions iare copied into the query class as well, so be careful making
// changes here.

// Value is true, false or 'fetch'.
Doc.prototype._setWantSubscribe = function(value, callback, err) {
  if (this.subscribed === this.wantSubscribe &&
      (this.subscribed === value || value === 'fetch' && this.subscribed)) {
    if (callback) callback(err);
    return;
  }
  
  if (!this.wantSubscribe !== !value) {
    // Call all the current subscribe/unsubscribe callbacks.
    for (var i = 0; i < this._subscribeCallbacks.length; i++) {
      // Should I return an error here? What happened is the user unsubcribed
      // with a callback then resubscribed straight after. Does that mean the
      // unsubscribe failed?
      this._subscribeCallbacks[i](err);
    }
    this._subscribeCallbacks.length = 0;
  }

  // If we want to subscribe, don't weaken it to a fetch.
  if (value !== 'fetch' || this.wantSubscribe !== true)
    this.wantSubscribe = value;

  if (callback) this._subscribeCallbacks.push(callback);
  this.flush();
};

// Open the document. There is no callback and no error handling if you're
// already connected.
//
// Only call this once per document.
Doc.prototype.subscribe = function(callback) {
  this._setWantSubscribe(true, callback);
};

// Unsubscribe. The data will stay around in local memory, but we'll stop
// receiving updates.
Doc.prototype.unsubscribe = function(callback) {
  this._setWantSubscribe(false, callback);
};

// Call to request fresh data from the server.
Doc.prototype.fetch = function(callback) {
  this._setWantSubscribe('fetch', callback);
};

// Called when our subscribe, fetch or unsubscribe messages are acknowledged.
Doc.prototype._finishSub = function(value, error) {
  if (value === this.wantSubscribe) {
    for (var i = 0; i < this._subscribeCallbacks.length; i++) {
      this._subscribeCallbacks[i](error);
    }
    this._subscribeCallbacks.length = 0;
  }
};


// Operations


// ************ Dealing with operations.

// Helper function to set opData to contain a no-op.
var setNoOp = function(opData) {
  delete opData.op;
  delete opData.create;
  delete opData.del;
};

var isNoOp = function(opData) {
  return !opData.op && !opData.create && !opData.del;
}

// Try to compose data2 into data1. Returns truthy if it succeeds, otherwise falsy.
var tryCompose = function(type, data1, data2) {
  if (data1.create && data2.del) {
    setNoOp(data1);
  } else if (data1.create && data2.op) {
    // Compose the data into the create data.
    var data = (data1.create.data === undefined) ? type.create() : data1.create.data;
    data1.create.data = type.apply(data, data2.op);
  } else if (isNoOp(data1)) {
    data1.create = data2.create;
    data1.del = data2.del;
    data1.op = data2.op;
  } else if (data1.op && data2.op && type.compose) {
    data1.op = type.compose(data1.op, data2.op);
  } else {
    return false;
  }
  return true;
};

// Transform server op data by a client op, and vice versa. Ops are edited in place.
var xf = function(client, server) {
  // In this case, we're in for some fun. There are some local operations
  // which are totally invalid - either the client continued editing a
  // document that someone else deleted or a document was created both on the
  // client and on the server. In either case, the local document is way
  // invalid and the client's ops are useless.
  //
  // The client becomes a no-op, and we keep the server op entirely.
  if (server.create || server.del) return setNoOp(client);
  if (client.create) throw new Error('Invalid state. This is a bug.');

  // The client has deleted the document while the server edited it. Kill the
  // server's op.
  if (client.del) return setNoOp(server);

  // We only get here if either the server or client ops are no-op. Carry on,
  // nothing to see here.
  if (!server.op || !client.op) return;

  // They both edited the document. This is the normal case for this function -
  // as in, most of the time we'll end up down here.
  //
  // You should be wondering why I'm using client.type instead of this.type.
  // The reason is, if we get ops at an old version of the document, this.type
  // might be undefined or a totally different type. By pinning the type to the
  // op data, we make sure the right type has its transform function called.
  if (client.type.transformX) {
    var result = client.type.transformX(client.op, server.op);
    client.op = result[0];
    server.op = result[1];
  } else {
    //console.log('xf', JSON.stringify(client.op), JSON.stringify(server.op));
    var _c = client.type.transform(client.op, server.op, 'left');
    var _s = client.type.transform(server.op, client.op, 'right');
    client.op = _c; server.op = _s;
    //console.log('->', JSON.stringify(client.op), JSON.stringify(server.op));
  }
};

// Internal method to actually apply the given op data to our local model.
//
// _afterOtApply() should always be called synchronously afterwards.
Doc.prototype._otApply = function(opData, context) {
  // Lock the document. Nobody is allowed to call submitOp() until _afterOtApply is called.
  this.locked = true;

  if (opData.create) {
    // If the type is currently set, it means we tried creating the document
    // and someone else won. client create x server create = server create.
    var create = opData.create;
    this._setType(create.type);
    this.snapshot = this.type.create(create.data);

    // This is a bit heavyweight, but I want the created event to fire outside of the lock.
    this.once('unlock', function() {
      this.emit('create', context);
    });
  } else if (opData.del) {
    // The type should always exist in this case. del x _ = del
    var oldSnapshot = this.snapshot;
    this._setType(null);
    this.once('unlock', function() {
      this.emit('del', context, oldSnapshot);
    });
  } else if (opData.op) {
    if (!this.type) throw new Error('Document does not exist');

    var type = this.type;

    var op = opData.op;
    
    // The context needs to be told we're about to edit, just in case it needs
    // to store any extra data. (text-tp2 has this constraint.)
    for (var i = 0; i < this.editingContexts.length; i++) {
      var c = this.editingContexts[i];
      if (c != context && c._beforeOp) c._beforeOp(opData.op);
    }

    this.emit('before op', op, context);

    // This exists so clients can pull any necessary data out of the snapshot
    // before it gets changed.  Previously we kept the old snapshot object and
    // passed it to the op event handler. However, apply no longer guarantees
    // the old object is still valid.
    //
    // Because this could be totally unnecessary work, its behind a flag. set
    // doc.incremental to enable.
    if (this.incremental && type.incrementalApply) {
      var _this = this;
      type.incrementalApply(this.snapshot, op, function(o, snapshot) {
        _this.snapshot = snapshot;
        _this.emit('op', o, context);
      });
    } else {
      // This is the most common case, simply applying the operation to the local snapshot.
      this.snapshot = type.apply(this.snapshot, op);
      this.emit('op', op, context);
    }
  }
  // Its possible for none of the above cases to match, in which case the op is
  // a no-op. This will happen when a document has been deleted locally and
  // remote ops edit the document.
};

// This should be called right after _otApply.
Doc.prototype._afterOtApply = function(opData, context) {
  this.locked = false;
  this.emit('unlock');
  if (opData.op) {
    var contexts = this.editingContexts;
    // Notify all the contexts about the op (well, all the contexts except
    // the one which initiated the submit in the first place).
    for (var i = 0; i < contexts.length; i++) {
      var c = contexts[i];
      if (c != context && c._onOp) c._onOp(opData.op);
    }
    for (var i = 0; i < contexts.length; i++) {
      if (contexts.remove) contexts.splice(i--, 1);
    }

    return this.emit('after op', opData.op, context);
  }
};



// ***** Sending operations


// Actually send op data to the server.
Doc.prototype._sendOpData = function() {
  var d = this.inflightData;

  if (this.action) throw new Error('invalid state ' + this.action + ' for sendOpData');
  this.action = 'submit';

  var msg = {a:'op', v:this.version};
  if (d.src) {
    msg.src = d.src;
    msg.seq = d.seq;
  }

  // The server autodetects this.
  //if (this.state === 'unsubscribed') msg.f = true; // fetch intermediate ops

  if (d.op) msg.op = d.op;
  if (d.create) msg.create = d.create;
  if (d.del) msg.del = d.del;

  msg.c = this.collection;
  msg.d = this.name;

  this.connection.sendOp(msg);
   
  // The first time we send an op, its id and sequence number is implicit.
  if (!d.src) {
    d.src = this.connection.id;
    d.seq = this.connection.seq++;
  }
};


// Internal method called to do the actual work for submitOp(), create() and del().
//
// context is optional.
Doc.prototype._submitOpData = function(opData, context, callback) {
  //console.log('submit', JSON.stringify(opData), 'v=', this.version);

  if (typeof context === 'function') {
    callback = context;
    context = true; // The default context is true.
  }
  if (context == null) context = true;

  var error = function(err) {
    if (callback) callback(err);
    else if (console) console.warn('Failed attempt to submitOp:', err);
  };

  if (this.locked) {
    return error("Cannot call submitOp from inside an 'op' event handler");
  }

  // The opData contains either op, create, delete, or none of the above (a no-op).

  if (opData.op) {
    if (!this.type) return error('Document has not been created');

    // Try to normalize the op. This removes trailing skip:0's and things like that.
    if (this.type.normalize) opData.op = this.type.normalize(opData.op);
  }

  if (!this.state) {
    this.state = 'floating';
  }

  // Actually apply the operation locally.
  this._otApply(opData, context);

  // If the type supports composes, try to compose the operation onto the end
  // of the last pending operation.
  var entry = this.pendingData[this.pendingData.length - 1];

  if (this.pendingData.length &&
      (entry = this.pendingData[this.pendingData.length - 1],
       tryCompose(this.type, entry, opData))) {
  } else {
    entry = opData;
    opData.type = this.type;
    opData.callbacks = [];
    this.pendingData.push(opData);
  }

  if (callback) entry.callbacks.push(callback);

  this._afterOtApply(opData, context);

  // The call to flush is in a timeout so if submitOp() is called multiple
  // times in a closure all the ops are combined before being sent to the
  // server. It doesn't matter if flush is called a bunch of times.
  var _this = this;
  setTimeout((function() { _this.flush(); }), 0);
};


// *** Client OT entrypoints.

// Submit an operation to the document. The op must be valid given the current OT type.
Doc.prototype.submitOp = function(op, context, callback) {
  this._submitOpData({op: op}, context, callback);
};

// Create the document, which in ShareJS semantics means to set its type. Every
// object implicitly exists in the database but has no data and no type. Create
// sets the type of the object and can optionally set some initial data on the
// object, depending on the type.
Doc.prototype.create = function(type, data, context, callback) {
  if (typeof data === 'function') {
    // Setting the context to be the callback function in this case so _submitOpData
    // can handle the default value thing.
    context = data;
    data = undefined;
  }
  if (this.type) {
    if (callback) callback('Document already exists');
    return 
  }

  this._submitOpData({create: {type:type, data:data}}, context, callback);
};

// Delete the document. This creates and submits a delete operation to the
// server. Deleting resets the object's type to null and deletes its data. The
// document still exists, and still has the version it used to have before you
// deleted it (well, old version +1).
Doc.prototype.del = function(context, callback) {
  if (!this.type) {
    if (callback) callback('Document does not exist');
    return;
  }

  this._submitOpData({del: true}, context, callback);
};


// Pausing stops the document from sending any operations to the server.
Doc.prototype.pause = function() {
  this.paused = true;
};

Doc.prototype.resume = function() {
  this.paused = false;
  this.flush();
};


// *** Receiving operations


// This will be called when the server rejects our operations for some reason.
// There's not much we can do here if the OT type is noninvertable, but that
// shouldn't happen too much in real life because readonly documents should be
// flagged as such. (I should probably figure out a flag for that).
//
// This does NOT get called if our op fails to reach the server for some reason
// - we optimistically assume it'll make it there eventually.
Doc.prototype._tryRollback = function(opData) {
  // This is probably horribly broken.
  if (opData.create) {
    this._setType(null);

    // I don't think its possible to get here if we aren't in a floating state.
    if (this.state === 'floating')
      this.state = null;
    else
      console.warn('Rollback a create from state ' + this.state);

  } else if (opData.op && opData.type.invert) {
    opData.op = opData.type.invert(opData.op);

    // Transform the undo operation by any pending ops.
    for (var i = 0; i < this.pendingData.length; i++) {
      xf(this.pendingData[i], opData);
    }

    // ... and apply it locally, reverting the changes.
    // 
    // This operation is applied to look like it comes from a remote context.
    // I'm still not 100% sure about this functionality, because its really a
    // local op. Basically, the problem is that if the client's op is rejected
    // by the server, the editor window should update to reflect the undo.
    this._otApply(opData, false);
    this._afterOtApply(opData, false);
  } else if (opData.op || opData.del) {
    // This is where an undo stack would come in handy.
    this._setType(null);
    this.version = null;
    this.state = null;
    this.subscribed = false;
    this.emit('error', "Op apply failed and the operation could not be reverted");

    // Trigger a fetch. In our invalid state, we can't really do anything.
    this.fetch();
    this.flush();
  }
};

Doc.prototype._clearInflightOp = function(error) {
  var callbacks = this.inflightData.callbacks;
  for (var i = 0; i < callbacks.length; i++) {
    callbacks[i](error || this.inflightData.error);
  }

  this.inflightData = null;
  this._clearAction('submit');

  if (!this.pendingData.length) {
    // This isn't a very good name.
    this.emit('nothing pending');
  }
};

// This is called when the server acknowledges an operation from the client.
Doc.prototype._opAcknowledged = function(msg) {
  // Our inflight op has been acknowledged, so we can throw away the inflight data.
  // (We were only holding on to it incase we needed to resend the op.)
  if (!this.state) {
    throw new Error('opAcknowledged called from a null state. This should never happen.');
  } else if (this.state === 'floating') {
    if (!this.inflightData.create) throw new Error('Cannot acknowledge an op.');

    // Our create has been acknowledged. This is the same as injesting some data.
    this.version = msg.v;
    this.state = 'ready';
    var _this = this;
    setTimeout(function() { _this.emit('ready'); }, 0);
  } else {
    // We already have a snapshot. The snapshot should be at the acknowledged
    // version, because the server has sent us all the ops that have happened
    // before acknowledging our op.

    // This should never happen - something is out of order.
    if (msg.v !== this.version)
      throw new Error('Invalid version from server. This can happen when you submit ops in a submitOp callback.');
  }
  
  // The op was committed successfully. Increment the version number
  this.version++;

  this._clearInflightOp();
};


// API Contexts

// This creates and returns an editing context using the current OT type.
Doc.prototype.createContext = function() {
  var type = this.type;
  if (!type) throw new Error('Missing type');

  // I could use the prototype chain to do this instead, but Object.create
  // isn't defined on old browsers. This will be fine.
  var doc = this;
  var context = {
    getSnapshot: function() {
      return doc.snapshot;
    },
    submitOp: function(op, callback) {
      doc.submitOp(op, context, callback);
    },
    destroy: function() {
      if (this.detach) {
        this.detach();
        // Don't double-detach.
        delete this.detach;
      }
      // It will be removed from the actual editingContexts list next time
      // we receive an op on the document (and the list is iterated through).
      //
      // This is potentially dodgy, allowing a memory leak if you create &
      // destroy a whole bunch of contexts without receiving or sending any ops
      // to the document.
      delete this._onOp;
      this.remove = true;
    },

    // This is dangerous, but really really useful for debugging. I hope people
    // don't depend on it.
    _doc: this,
  };

  if (type.api) {
    // Copy everything else from the type's API into the editing context.
    for (var k in type.api) {
      context[k] = type.api[k];
    }
  } else {
    context.provides = {};
  }

  this.editingContexts.push(context);

  return context;
};

Doc.prototype.removeContexts = function() {
  for (var i = 0; i < this.editingContexts.length; i++) {
    this.editingContexts[i].destroy();
  }
  this.editingContexts.length = 0;
};


},{"./microevent":80,"ottypes":82}],82:[function(require,module,exports){

var register = function(type) {
  exports[type.name] = type;
  if (type.uri) {
    return exports[type.uri] = type;
  }
};

// Import all the built-in types. Requiring directly rather than in register()
// so browserify works.
register(require('./simple'));

register(require('./text'));
register(require('./text-tp2'));

register(require('./json0'));


},{"./simple":83,"./text":84,"./text-tp2":85,"./json0":86}],83:[function(require,module,exports){
// This is a really simple OT type. Its not compiled with the web client, but it could be.
//
// Its mostly included for demonstration purposes and its used in the meta unit tests.
//
// This defines a really simple text OT type which only allows inserts. (No deletes).
//
// Ops look like:
//   {position:#, text:"asdf"}
//
// Document snapshots look like:
//   {str:string}

module.exports = {
  // The name of the OT type. The type itself is exposed to ottypes[type.name] and ottypes[type.uri].
  // The name can be used instead of the actual type in all API methods in ShareJS.
  name: 'simple',

  // Canonical name.
  uri: 'http://sharejs.org/types/simple',

  // Create a new document snapshot. Initial data can be passed in.
  create: function(initial) {
    if (initial == null)
      initial = '';

    return {str: initial};
  },

  // Apply the given op to the document snapshot. Returns the new snapshot.
  apply: function(snapshot, op) {
    if (op.position < 0 || op.position > snapshot.str.length)
      throw new Error('Invalid position');

    var str = snapshot.str;
    str = str.slice(0, op.position) + op.text + str.slice(op.position);
    return {str: str};
  },

  // Transform op1 by op2. Returns transformed version of op1.
  // Sym describes the symmetry of the operation. Its either 'left' or 'right'
  // depending on whether the op being transformed comes from the client or the
  // server.
  transform: function(op1, op2, sym) {
    var pos = op1.position;

    if (op2.position < pos || (op2.position === pos && sym === 'left')) {
      pos += op2.text.length;
    }

    return {position: pos, text: op1.text};
  }
};


},{}],84:[function(require,module,exports){
/* Text OT!
 *
 * This is an OT implementation for text. It is the standard implementation of
 * text used by ShareJS.
 *
 * This type is composable but non-invertable. Its similar to ShareJS's old
 * text-composable type, but its not invertable and its very similar to the
 * text-tp2 implementation but it doesn't support tombstones or purging.
 *
 * Ops are lists of components which iterate over the document.
 * Components are either:
 *   A number N: Skip N characters in the original document
 *   "str"     : Insert "str" at the current position in the document
 *   {d:'str'} : Delete 'str', which appears at the current position in the document
 *
 * Eg: [3, 'hi', 5, {d:8}]
 *
 * The operation does not have to skip the last characters in the document.
 *
 * Snapshots are strings.
 *
 * Cursors are either a single number (which is the cursor position) or a pair of
 * [anchor, focus] (aka [start, end]). Be aware that end can be before start.
 */

/** @module text */

exports.name = 'text';
exports.uri = 'http://sharejs.org/types/textv1';

/** Create a new text snapshot.
 *
 * @param {string} initial - initial snapshot data. Optional. Defaults to ''.
 */
exports.create = function(initial) {
  if ((initial != null) && typeof initial !== 'string') {
    throw new Error('Initial data must be a string');
  }
  return initial || '';
};

var isArray = Array.isArray || function(obj) {
  return Object.prototype.toString.call(obj) === "[object Array]";
};

/** Check the operation is valid. Throws if not valid. */
var checkOp = function(op) {
  if (!isArray(op)) throw new Error('Op must be an array of components');

  var last = null;
  for (var i = 0; i < op.length; i++) {
    var c = op[i];
    switch (typeof c) {
      case 'object':
        // The only valid objects are {d:X} for +ive values of X.
        if (!(typeof c.d === 'number' && c.d > 0)) throw new Error('Object components must be deletes of size > 0');
        break;
      case 'string':
        // Strings are inserts.
        if (!(c.length > 0)) throw new Error('Inserts cannot be empty');
        break;
      case 'number':
        // Numbers must be skips. They have to be +ive numbers.
        if (!(c > 0)) throw new Error('Skip components must be >0');
        if (typeof last === 'number') throw new Error('Adjacent skip components should be combined');
        break;
    }
    last = c;
  }

  if (typeof last === 'number') throw new Error('Op has a trailing skip');
};

/** Make a function that appends to the given operation. */
var makeAppend = function(op) {
  return function(component) {
    if (!component || component.d === 0) {
      // The component is a no-op. Ignore!
 
    } else if (op.length === 0) {
      return op.push(component);

    } else if (typeof component === typeof op[op.length - 1]) {
      if (typeof component === 'object') {
        return op[op.length - 1].d += component.d;
      } else {
        return op[op.length - 1] += component;
      }
    } else {
      return op.push(component);
    }
  };
};

/** Makes and returns utility functions take and peek. */
var makeTake = function(op) {
  // The index of the next component to take
  var idx = 0;
  // The offset into the component
  var offset = 0;

  // Take up to length n from the front of op. If n is -1, take the entire next
  // op component. If indivisableField == 'd', delete components won't be separated.
  // If indivisableField == 'i', insert components won't be separated.
  var take = function(n, indivisableField) {
    // We're at the end of the operation. The op has skips, forever. Infinity
    // might make more sense than null here.
    if (idx === op.length)
      return n === -1 ? null : n;

    var part;
    var c = op[idx];
    if (typeof c === 'number') {
      // Skip
      if (n === -1 || c - offset <= n) {
        part = c - offset;
        ++idx;
        offset = 0;
        return part;
      } else {
        offset += n;
        return n;
      }
    } else if (typeof c === 'string') {
      // Insert
      if (n === -1 || indivisableField === 'i' || c.length - offset <= n) {
        part = c.slice(offset);
        ++idx;
        offset = 0;
        return part;
      } else {
        part = c.slice(offset, offset + n);
        offset += n;
        return part;
      }
    } else {
      // Delete
      if (n === -1 || indivisableField === 'd' || c.d - offset <= n) {
        part = {d: c.d - offset};
        ++idx;
        offset = 0;
        return part;
      } else {
        offset += n;
        return {d: n};
      }
    }
  };

  // Peek at the next op that will be returned.
  var peekType = function() { return op[idx]; };

  return [take, peekType];
};

/** Get the length of a component */
var componentLength = function(c) {
  // Uglify will compress this down into a ternary
  if (typeof c === 'number') {
    return c;
  } else {
    return c.length || c.d;
  }
};

/** Trim any excess skips from the end of an operation.
 *
 * There should only be at most one, because the operation was made with append.
 */
var trim = function(op) {
  if (op.length > 0 && typeof op[op.length - 1] === 'number') {
    op.pop();
  }
  return op;
};

exports.normalize = function(op) {
  var newOp = [];
  var append = makeAppend(newOp);
  for (var i = 0; i < op.length; i++) {
    append(op[i]);
  }
  return trim(newOp);
};

/** Apply an operation to a document snapshot */
exports.apply = function(str, op) {
  if (typeof str !== 'string') {
    throw new Error('Snapshot should be a string');
  }
  checkOp(op);

  // We'll gather the new document here and join at the end.
  var newDoc = [];

  for (var i = 0; i < op.length; i++) {
    var component = op[i];
    switch (typeof component) {
      case 'number':
        if (component > str.length) throw new Error('The op is too long for this document');

        newDoc.push(str.slice(0, component));
        // This might be slow for big strings. Consider storing the offset in
        // str instead of rewriting it each time.
        str = str.slice(component);
        break;
      case 'string':
        newDoc.push(component);
        break;
      case 'object':
        str = str.slice(component.d);
        break;
    }
  }

  return newDoc.join('') + str;
};

/** Transform op by otherOp.
 *
 * @param op - The operation to transform
 * @param otherOp - Operation to transform it by
 * @param side - Either 'left' or 'right'
 */
exports.transform = function(op, otherOp, side) {
  if (side != 'left' && side != 'right') throw new Error("side (" + side + ") must be 'left' or 'right'");

  checkOp(op);
  checkOp(otherOp);

  var newOp = [];
  var append = makeAppend(newOp);

  var _fns = makeTake(op);
  var take = _fns[0],
      peek = _fns[1];

  for (var i = 0; i < otherOp.length; i++) {
    var component = otherOp[i];

    var length, chunk;
    switch (typeof component) {
      case 'number': // Skip
        length = component;
        while (length > 0) {
          chunk = take(length, 'i');
          append(chunk);
          if (typeof chunk !== 'string') {
            length -= componentLength(chunk);
          }
        }
        break;

      case 'string': // Insert
        if (side === 'left') {
          // The left insert should go first.
          if (typeof peek() === 'string') {
            append(take(-1));
          }
        }

        // Otherwise skip the inserted text.
        append(component.length);
        break;

      case 'object': // Delete
        length = component.d;
        while (length > 0) {
          chunk = take(length, 'i');
          switch (typeof chunk) {
            case 'number':
              length -= chunk;
              break;
            case 'string':
              append(chunk);
              break;
            case 'object':
              // The delete is unnecessary now - the text has already been deleted.
              length -= chunk.d;
          }
        }
        break;
    }
  }
  
  // Append any extra data in op1.
  while ((component = take(-1)))
    append(component);
  
  return trim(newOp);
};

/** Compose op1 and op2 together and return the result */
exports.compose = function(op1, op2) {
  checkOp(op1);
  checkOp(op2);

  var result = [];
  var append = makeAppend(result);
  var take = makeTake(op1)[0];

  for (var i = 0; i < op2.length; i++) {
    var component = op2[i];
    var length, chunk;
    switch (typeof component) {
      case 'number': // Skip
        length = component;
        while (length > 0) {
          chunk = take(length, 'd');
          append(chunk);
          if (typeof chunk !== 'object') {
            length -= componentLength(chunk);
          }
        }
        break;

      case 'string': // Insert
        append(component);
        break;

      case 'object': // Delete
        length = component.d;

        while (length > 0) {
          chunk = take(length, 'd');

          switch (typeof chunk) {
            case 'number':
              append({d: chunk});
              length -= chunk;
              break;
            case 'string':
              length -= chunk.length;
              break;
            case 'object':
              append(chunk);
          }
        }
        break;
    }
  }

  while ((component = take(-1)))
    append(component);

  return trim(result);
};

var transformPosition = function(cursor, op) {
  var pos = 0;
  for (var i = 0; i < op.length; i++) {
    var c = op[i];
    if (cursor <= pos) break;

    // I could actually use the op_iter stuff above - but I think its simpler
    // like this.
    switch (typeof c) {
      case 'number':
        if (cursor <= pos + c)
          return cursor;
        pos += c;
        break;

      case 'string':
        pos += c.length;
        cursor += c.length;
        break;

      case 'object':
        cursor -= Math.min(c.d, cursor - pos);
        break;
    }
  }
  return cursor;
};

exports.transformCursor = function(cursor, op, isOwnOp) {
  var pos = 0;
  if (isOwnOp) {
    // Just track the position. We'll teleport the cursor to the end anyway.
    // This works because text ops don't have any trailing skips at the end - so the last
    // component is the last thing.
    for (var i = 0; i < op.length; i++) {
      var c = op[i];
      switch (typeof c) {
        case 'number':
          pos += c;
          break;
        case 'string':
          pos += c.length;
          break;
        // Just eat deletes.
      }
    }
    return [pos, pos];
  } else {
    return [transformPosition(cursor[0], op), transformPosition(cursor[1], op)];
  }
};

},{}],85:[function(require,module,exports){
(function(){// A TP2 implementation of text, following this spec:
// http://code.google.com/p/lightwave/source/browse/trunk/experimental/ot/README
//
// A document is made up of a string and a set of tombstones inserted throughout
// the string. For example, 'some ', (2 tombstones), 'string'.
//
// This is encoded in a document as: {s:'some string', t:[5, -2, 6]}
//
// Ops are lists of components which iterate over the whole document. (I might
// change this at some point, but a version thats less strict is backwards
// compatible.)
//
// Components are either:
//   N:         Skip N characters in the original document
//   {i:'str'}: Insert 'str' at the current position in the document
//   {i:N}:     Insert N tombstones at the current position in the document
//   {d:N}:     Delete (tombstone) N characters at the current position in the document
//
// Eg: [3, {i:'hi'}, 5, {d:8}]
//
// Snapshots are lists with characters and tombstones. Characters are stored in strings
// and adjacent tombstones are flattened into numbers.
//
// Eg, the document: 'Hello .....world' ('.' denotes tombstoned (deleted) characters)
// would be represented by a document snapshot of ['Hello ', 5, 'world']

//var append, appendDoc, componentLength, makeTake, takeDoc, transformer;

var type = module.exports = {
  name: 'text-tp2',
  tp2: true,
  uri: 'http://sharejs.org/types/text-tp2v1',
  create: function(initial) {
    if (initial == null) {
      initial = '';
    } else {
      if (typeof initial != 'string') throw new Error('Initial data must be a string');
    }

    return {
      charLength: initial.length,
      totalLength: initial.length,
      data: initial.length ? [initial] : []
    };
  },

  serialize: function(doc) {
    if (!doc.data) {
      throw new Error('invalid doc snapshot');
    }
    return doc.data;
  },

  deserialize: function(data) {
    var doc = type.create();
    doc.data = data;

    for (var i = 0; i < data.length; i++) {
      var component = data[i];

      if (typeof component === 'string') {
        doc.charLength += component.length;
        doc.totalLength += component.length;
      } else {
        doc.totalLength += component;
      }
    }

    return doc;
  }
};

var isArray = Array.isArray || function(obj) {
  return Object.prototype.toString.call(obj) == '[object Array]';
};

var checkOp = function(op) {
  if (!isArray(op)) throw new Error('Op must be an array of components');

  var last = null;
  for (var i = 0; i < op.length; i++) {
    var c = op[i];
    if (typeof c == 'object') {
      // The component is an insert or a delete.
      if (c.i !== undefined) { // Insert.
        if (!((typeof c.i === 'string' && c.i.length > 0) // String inserts
              || (typeof c.i === 'number' && c.i > 0))) // Tombstone inserts
          throw new Error('Inserts must insert a string or a +ive number');

      } else if (c.d !== undefined) { // Delete
        if (!(typeof c.d === 'number' && c.d > 0))
          throw new Error('Deletes must be a +ive number');

      } else throw new Error('Operation component must define .i or .d');

    } else {
      // The component must be a skip.
      if (typeof c != 'number') throw new Error('Op components must be objects or numbers');

      if (c <= 0) throw new Error('Skip components must be a positive number');
      if (typeof last === 'number') throw new Error('Adjacent skip components should be combined');
    }

    last = c;
  }
};

// Take the next part from the specified position in a document snapshot.
// position = {index, offset}. It will be updated.
var takeDoc = type._takeDoc = function(doc, position, maxlength, tombsIndivisible) {
  if (position.index >= doc.data.length)
    throw new Error('Operation goes past the end of the document');

  var part = doc.data[position.index];

  // This can be written as an ugly-arsed giant ternary statement, but its much
  // more readable like this. Uglify will convert it into said ternary anyway.
  var result;
  if (typeof part == 'string') {
    if (maxlength != null) {
      result = part.slice(position.offset, position.offset + maxlength);
    } else {
      result = part.slice(position.offset);
    }
  } else {
    if (maxlength == null || tombsIndivisible) {
      result = part - position.offset;
    } else {
      result = Math.min(maxlength, part - position.offset);
    }
  }

  var resultLen = result.length || result;

  if ((part.length || part) - position.offset > resultLen) {
    position.offset += resultLen;
  } else {
    position.index++;
    position.offset = 0;
  }

  return result;
};

// Append a part to the end of a document
var appendDoc = type._appendDoc = function(doc, p) {
  if (p === 0 || p === '') return;

  if (typeof p === 'string') {
    doc.charLength += p.length;
    doc.totalLength += p.length;
  } else {
    doc.totalLength += p;
  }

  var data = doc.data;
  if (data.length === 0) {
    data.push(p);
  } else if (typeof data[data.length - 1] === typeof p) {
    data[data.length - 1] += p;
  } else {
    data.push(p);
  }
};

// Apply the op to the document. The document is not modified in the process.
type.apply = function(doc, op) {
  if (doc.totalLength == null || doc.charLength == null || !isArray(doc.data)) {
    throw new Error('Snapshot is invalid');
  }
  checkOp(op);

  var newDoc = type.create();
  var position = {index: 0, offset: 0};

  for (var i = 0; i < op.length; i++) {
    var component = op[i];
    var remainder, part;

    if (typeof component == 'number') { // Skip
      remainder = component;
      while (remainder > 0) {
        part = takeDoc(doc, position, remainder);
        appendDoc(newDoc, part);
        remainder -= part.length || part;
      }

    } else if (component.i !== undefined) { // Insert
      appendDoc(newDoc, component.i);

    } else if (component.d !== undefined) { // Delete
      remainder = component.d;
      while (remainder > 0) {
        part = takeDoc(doc, position, remainder);
        remainder -= part.length || part;
      }
      appendDoc(newDoc, component.d);
    }
  }
  return newDoc;
};

// Append an op component to the end of the specified op.  Exported for the
// randomOpGenerator.
var append = type._append = function(op, component) {
  var last;

  if (component === 0 || component.i === '' || component.i === 0 || component.d === 0) {
    // Drop the new component.
  } else if (op.length === 0) {
    op.push(component);
  } else {
    last = op[op.length - 1];
    if (typeof component == 'number' && typeof last == 'number') {
      op[op.length - 1] += component;
    } else if (component.i != null && (last.i != null) && typeof last.i === typeof component.i) {
      last.i += component.i;
    } else if (component.d != null && (last.d != null)) {
      last.d += component.d;
    } else {
      op.push(component);
    }
  }
};

// Makes 2 functions for taking components from the start of an op, and for
// peeking at the next op that could be taken.
var makeTake = function(op) {
  // The index of the next component to take
  var index = 0;
  // The offset into the component
  var offset = 0;

  var take = function(maxlength, insertsIndivisible) {
    if (index === op.length) return null;
    var e = op[index];
    var current;
    var result;

    // if the current element is a skip, an insert of a number or a delete
    if (typeof (current = e) == 'number' || typeof (current = e.i) == 'number' || (current = e.d) != null) {
      var c;
      if ((maxlength == null) || current - offset <= maxlength || (insertsIndivisible && e.i != null)) {
        // Return the rest of the current element.
        c = current - offset;
        ++index;
        offset = 0;
      } else {
        offset += maxlength;
        c = maxlength;
      }

      // Package the component back up.
      if (e.i != null) {
        return {i: c};
      } else if (e.d != null) {
        return {d: c};
      } else {
        return c;
      }
    } else { // Insert of a string.
      if ((maxlength == null) || e.i.length - offset <= maxlength || insertsIndivisible) {
        result = {i: e.i.slice(offset)};
        ++index;
        offset = 0;
      } else {
        result = {i: e.i.slice(offset, offset + maxlength)};
        offset += maxlength;
      }
      return result;
    }
  };

  var peekType = function() {return op[index];};
  return [take, peekType];
};

// Find and return the length of an op component
var componentLength = function(component) {
  if (typeof component === 'number') {
    return component;
  } else if (typeof component.i === 'string') {
    return component.i.length;
  } else {
    return component.d || component.i;
  }
};

// Normalize an op, removing all empty skips and empty inserts / deletes.
// Concatenate adjacent inserts and deletes.
type.normalize = function(op) {
  var newOp = [];
  for (var i = 0; i < op.length; i++) {
    append(newOp, op[i]);
  }
  return newOp;
};

// This is a helper method to transform and prune. goForwards is true for transform, false for prune.
var transformer = function(op, otherOp, goForwards, side) {
  checkOp(op);
  checkOp(otherOp);

  var newOp = [];

  var fns = makeTake(op),
      take = fns[0],
      peek = fns[1];

  for (var i = 0; i < otherOp.length; i++) {
    var component = otherOp[i];
    var len = componentLength(component);
    var chunk;

    if (component.i != null) { // Insert text or tombs
      if (goForwards) { // Transform - insert skips over deleted parts.
        if (side === 'left') {
          // The left side insert should go first.
          var next;
          while ((next = peek()) && next.i != null) {
            append(newOp, take());
          }
        }
        // In any case, skip the inserted text.
        append(newOp, len);

      } else { // Prune. Remove skips for inserts.
        while (len > 0) {
          chunk = take(len, true);

          // The chunk will be null if we run out of components in the other op.
          if (chunk === null) throw new Error('The transformed op is invalid');
          if (chunk.d != null)
            throw new Error('The transformed op deletes locally inserted characters - it cannot be purged of the insert.');

          if (typeof chunk == 'number')
            len -= chunk;
          else
            append(newOp, chunk);
        }
      }
    } else { // Skips or deletes.
      while (len > 0) {
        chunk = take(len, true);
        if (chunk === null) throw new Error('The op traverses more elements than the document has');

        append(newOp, chunk);
        if (!chunk.i) len -= componentLength(chunk);
      }
    }
  }

  // Append extras from op1.
  var component;
  while ((component = take())) {
    if (component.i === undefined) {
      throw new Error("Remaining fragments in the op: " + component);
    }
    append(newOp, component);
  }
  return newOp;
};

// transform op1 by op2. Return transformed version of op1. op1 and op2 are
// unchanged by transform. Side should be 'left' or 'right', depending on if
// op1.id <> op2.id.
//
// 'left' == client op for ShareJS.
type.transform = function(op, otherOp, side) {
  if (side != 'left' && side != 'right')
    throw new Error("side (" + side + ") should be 'left' or 'right'");

  return transformer(op, otherOp, true, side);
};

type.prune = function(op, otherOp) {
  return transformer(op, otherOp, false);
};

type.compose = function(op1, op2) {
  //var chunk, chunkLength, component, length, result, take, _, _i, _len, _ref;
  if (op1 == null) return op2;

  checkOp(op1);
  checkOp(op2);

  var result = [];
  var take = makeTake(op1)[0];
  var component;

  for (var i = 0; i < op2.length; i++) {
    component = op2[i];
    var len, chunk;

    if (typeof component === 'number') { // Skip
      // Just copy from op1.
      len = component;
      while (len > 0) {
        chunk = take(len);
        if (chunk === null)
          throw new Error('The op traverses more elements than the document has');

        append(result, chunk);
        len -= componentLength(chunk);
      }

    } else if (component.i !== undefined) { // Insert
      append(result, {i: component.i});

    } else { // Delete
      len = component.d;
      while (len > 0) {
        chunk = take(len);
        if (chunk === null)
          throw new Error('The op traverses more elements than the document has');

        var chunkLength = componentLength(chunk);

        if (chunk.i !== undefined)
          append(result, {i: chunkLength});
        else
          append(result, {d: chunkLength});

        len -= chunkLength;
      }
    }
  }

  // Append extras from op1.
  while ((component = take())) {
    if (component.i === undefined) {
      throw new Error("Remaining fragments in op1: " + component);
    }
    append(result, component);
  }
  return result;
};


})()
},{}],86:[function(require,module,exports){
/*
 This is the implementation of the JSON OT type.

 Spec is here: https://github.com/josephg/ShareJS/wiki/JSON-Operations

 Note: This is being made obsolete. It will soon be replaced by the JSON2 type.
*/

/**
 * UTILITY FUNCTIONS
 */

/**
 * Checks if the passed object is an Array instance. Can't use Array.isArray
 * yet because its not supported on IE8.
 *
 * @param obj
 * @returns {boolean}
 */
var isArray = function(obj) {
  return Object.prototype.toString.call(obj) == '[object Array]';
};

/**
 * Clones the passed object using JSON serialization (which is slow).
 *
 * hax, copied from test/types/json. Apparently this is still the fastest way
 * to deep clone an object, assuming we have browser support for JSON.  @see
 * http://jsperf.com/cloning-an-object/12
 */
var clone = function(o) {
  return JSON.parse(JSON.stringify(o));
};



/**
 * Reference to the Text OT type. This is used for the JSON String operations.
 * @type {*}
 */
var text = typeof require !== "undefined" ? require('./text-old') : window.ottypes.text;



/**
 * JSON OT Type
 * @type {*}
 */
var json = { 
  name: 'json0',
  uri: 'http://sharejs.org/types/JSONv0'
};

json.create = function(data) {
  // Null instead of undefined if you don't pass an argument.
  return data === undefined ? null : data;
};

json.invertComponent = function(c) {
  var c_ = {p: c.p};

  if (c.si !== void 0) c_.sd = c.si;
  if (c.sd !== void 0) c_.si = c.sd;
  if (c.oi !== void 0) c_.od = c.oi;
  if (c.od !== void 0) c_.oi = c.od;
  if (c.li !== void 0) c_.ld = c.li;
  if (c.ld !== void 0) c_.li = c.ld;
  if (c.na !== void 0) c_.na = -c.na;

  if (c.lm !== void 0) {
    c_.lm = c.p[c.p.length-1];
    c_.p = c.p.slice(0,c.p.length-1).concat([c.lm]);
  }

  return c_;
};

json.invert = function(op) {
  var op_ = op.slice().reverse();
  var iop = [];
  for (var i = 0; i < op_.length; i++) {
    iop.push(json.invertComponent(op_[i]));
  }
  return iop;
};

json.checkValidOp = function(op) {
  for (var i = 0; i < op.length; i++) {
  if (!isArray(op[i].p))
    throw new Error('Missing path');
  }
};

json.checkList = function(elem) {
  if (!isArray(elem))
    throw new Error('Referenced element not a list');
};

json.checkObj = function(elem) {
  if (elem.constructor !== Object) {
    throw new Error("Referenced element not an object (it was " + JSON.stringify(elem) + ")");
  }
};

json.apply = function(snapshot, op) {
  json.checkValidOp(op);

  op = clone(op);

  var container = {
    data: snapshot
  };

  for (var i = 0; i < op.length; i++) {
    var c = op[i];

    var parent = null;
    var parentKey = null;
    var elem = container;
    var key = 'data';

    for (var j = 0; j < c.p.length; j++) {
      var p = c.p[j];

      parent = elem;
      parentKey = key;
      elem = elem[key];
      key = p;

      if (parent == null)
        throw new Error('Path invalid');
    }

    // Number add
    if (c.na !== void 0) {
      if (typeof elem[key] != 'number')
        throw new Error('Referenced element not a number');

      elem[key] += c.na;
    }

    // String insert
    else if (c.si !== void 0) {
      if (typeof elem != 'string')
        throw new Error('Referenced element not a string (it was '+JSON.stringify(elem)+')');

      parent[parentKey] = elem.slice(0,key) + c.si + elem.slice(key);
    }

    // String delete
    else if (c.sd !== void 0) {
      if (typeof elem != 'string')
        throw new Error('Referenced element not a string');

      if (elem.slice(key,key + c.sd.length) !== c.sd)
        throw new Error('Deleted string does not match');

      parent[parentKey] = elem.slice(0,key) + elem.slice(key + c.sd.length);
    }

    // List replace
    else if (c.li !== void 0 && c.ld !== void 0) {
      json.checkList(elem);
      // Should check the list element matches c.ld
      elem[key] = c.li;
    }

    // List insert
    else if (c.li !== void 0) {
      json.checkList(elem);
      elem.splice(key,0, c.li);
    }

    // List delete
    else if (c.ld !== void 0) {
      json.checkList(elem);
      // Should check the list element matches c.ld here too.
      elem.splice(key,1);
    }

    // List move
    else if (c.lm !== void 0) {
      json.checkList(elem);
      if (c.lm != key) {
        var e = elem[key];
        // Remove it...
        elem.splice(key,1);
        // And insert it back.
        elem.splice(c.lm,0,e);
      }
    }

    // Object insert / replace
    else if (c.oi !== void 0) {
      json.checkObj(elem);

      // Should check that elem[key] == c.od
      elem[key] = c.oi;
    }

    // Object delete
    else if (c.od !== void 0) {
      json.checkObj(elem);

      // Should check that elem[key] == c.od
      delete elem[key];
    }

    else {
      throw new Error('invalid / missing instruction in op');
    }
  }

  return container.data;
};

// Helper for incrementally applying an operation to a snapshot. Calls yield
// after each op component has been applied.
json.incrementalApply = function(snapshot, op, _yield) {
  for (var i = 0; i < op.length; i++) {
    var smallOp = [op[i]];
    snapshot = json.apply(snapshot, smallOp);
    // I'd just call this yield, but thats a reserved keyword. Bah!
    _yield(smallOp, snapshot);
  }
  
  return snapshot;
};

// Checks if two paths, p1 and p2 match.
var pathMatches = json.pathMatches = function(p1, p2, ignoreLast) {
  if (p1.length != p2.length)
    return false;

  for (var i = 0; i < p1.length; i++) {
    if (p1[i] !== p2[i] && (!ignoreLast || i !== p1.length - 1))
      return false;
  }

  return true;
};

var _convertToTextComponent = function(component) {
  var newC = {p: component.p[component.p.length - 1]};
  if (component.si != null) {
    newC.i = component.si;
  } else {
    newC.d = component.sd;
  }
  return newC;
};

json.append = function(dest,c) {
  c = clone(c);

  var last;

  if (dest.length != 0 && pathMatches(c.p, (last = dest[dest.length - 1]).p)) {
    if (last.na != null && c.na != null) {
      dest[dest.length - 1] = {p: last.p, na: last.na + c.na};
    } else if (last.li !== undefined && c.li === undefined && c.ld === last.li) {
      // insert immediately followed by delete becomes a noop.
      if (last.ld !== undefined) {
        // leave the delete part of the replace
        delete last.li;
      } else {
        dest.pop();
      }
    } else if (last.od !== undefined && last.oi === undefined && c.oi !== undefined && c.od === undefined) {
      last.oi = c.oi;
    } else if (last.oi !== undefined && c.od !== undefined) {
      // The last path component inserted something that the new component deletes (or replaces).
      // Just merge them.
      if (c.oi !== undefined) {
        last.oi = c.oi;
      } else if (last.od !== undefined) {
        delete last.oi;
      } else {
        // An insert directly followed by a delete turns into a no-op and can be removed.
        dest.pop();
      }
    } else if (c.lm !== undefined && c.p[c.p.length - 1] === c.lm) {
      // don't do anything
    } else {
      dest.push(c);
    }
  } else if (dest.length != 0 && pathMatches(c.p, last.p, true)) {
    if ((c.si != null || c.sd != null) && (last.si != null || last.sd != null)) {
      // Try to compose the string ops together using text's equivalent methods
      var textOp = [_convertToTextComponent(last)];
      text._append(textOp, _convertToTextComponent(c));
      
      // Then convert back.
      if (textOp.length !== 1) {
        dest.push(c);
      } else {
        var textC = textOp[0];
        last.p[last.p.length - 1] = textC.p;
        if (textC.i != null)
          last.si = textC.i;
        else
          last.sd = textC.d;
      }
    } else {
      dest.push(c);
    }
  } else {
    dest.push(c);
  }
};

json.compose = function(op1,op2) {
  json.checkValidOp(op1);
  json.checkValidOp(op2);

  var newOp = clone(op1);

  for (var i = 0; i < op2.length; i++) {
    json.append(newOp,op2[i]);
  }

  return newOp;
};

json.normalize = function(op) {
  var newOp = [];

  op = isArray(op) ? op : [op];

  for (var i = 0; i < op.length; i++) {
    var c = op[i];
    if (c.p == null) c.p = [];

    json.append(newOp,c);
  }

  return newOp;
};

// Returns true if an op at otherPath may affect an op at path
json.canOpAffectOp = function(otherPath,path) {
  if (otherPath.length === 0) return true;
  if (path.length === 0) return false;

  path = path.slice(0,path.length - 1);
  otherPath = otherPath.slice(0,otherPath.length - 1);

  for (var i = 0; i < otherPath.length; i++) {
    var p = otherPath[i];
    if (i >= path.length || p != path[i]) return false;
  }

  // Same
  return true;
};

// transform c so it applies to a document with otherC applied.
json.transformComponent = function(dest, c, otherC, type) {
  c = clone(c);

  if (c.na !== void 0)
    c.p.push(0);

  if (otherC.na !== void 0)
    otherC.p.push(0);

  var common;
  if (json.canOpAffectOp(otherC.p, c.p))
    common = otherC.p.length - 1;

  var common2;
  if (json.canOpAffectOp(c.p,otherC.p))
    common2 = c.p.length - 1;

  var cplength = c.p.length;
  var otherCplength = otherC.p.length;

  if (c.na !== void 0) // hax
    c.p.pop();

  if (otherC.na !== void 0)
    otherC.p.pop();

  if (otherC.na) {
    if (common2 != null && otherCplength >= cplength && otherC.p[common2] == c.p[common2]) {
      if (c.ld !== void 0) {
        var oc = clone(otherC);
        oc.p = oc.p.slice(cplength);
        c.ld = json.apply(clone(c.ld),[oc]);
      } else if (c.od !== void 0) {
        var oc = clone(otherC);
        oc.p = oc.p.slice(cplength);
        c.od = json.apply(clone(c.od),[oc]);
      }
    }
    json.append(dest,c);
    return dest;
  }

  // if c is deleting something, and that thing is changed by otherC, we need to
  // update c to reflect that change for invertibility.
  // TODO this is probably not needed since we don't have invertibility
  if (common2 != null && otherCplength > cplength && c.p[common2] == otherC.p[common2]) {
    if (c.ld !== void 0) {
      var oc = clone(otherC);
      oc.p = oc.p.slice(cplength);
      c.ld = json.apply(clone(c.ld),[oc]);
    } else if (c.od !== void 0) {
      var oc = clone(otherC);
      oc.p = oc.p.slice(cplength);
      c.od = json.apply(clone(c.od),[oc]);
    }
  }

  if (common != null) {
    var commonOperand = cplength == otherCplength;

    // transform based on otherC
    if (otherC.na !== void 0) {
      // this case is handled above due to icky path hax
    } else if (otherC.si !== void 0 || otherC.sd !== void 0) {
      // String op vs string op - pass through to text type
      if (c.si !== void 0 || c.sd !== void 0) {
        if (!commonOperand) throw new Error('must be a string?');

        // Convert an op component to a text op component so we can use the
        // text type's transform function
        var tc1 = _convertToTextComponent(c);
        var tc2 = _convertToTextComponent(otherC);

        var res = [];

        // actually transform
        text._tc(res, tc1, tc2, type);
        
        // .... then convert the result back into a JSON op again.
        for (var i = 0; i < res.length; i++) {
          // Text component
          var tc = res[i];
          // JSON component
          var jc = {p: c.p.slice(0, common)};
          jc.p.push(tc.p);

          if (tc.i != null) jc.si = tc.i;
          if (tc.d != null) jc.sd = tc.d;
          json.append(dest, jc);
        }
        return dest;
      }
    } else if (otherC.li !== void 0 && otherC.ld !== void 0) {
      if (otherC.p[common] === c.p[common]) {
        // noop

        if (!commonOperand) {
          return dest;
        } else if (c.ld !== void 0) {
          // we're trying to delete the same element, -> noop
          if (c.li !== void 0 && type === 'left') {
            // we're both replacing one element with another. only one can survive
            c.ld = clone(otherC.li);
          } else {
            return dest;
          }
        }
      }
    } else if (otherC.li !== void 0) {
      if (c.li !== void 0 && c.ld === undefined && commonOperand && c.p[common] === otherC.p[common]) {
        // in li vs. li, left wins.
        if (type === 'right')
          c.p[common]++;
      } else if (otherC.p[common] <= c.p[common]) {
        c.p[common]++;
      }

      if (c.lm !== void 0) {
        if (commonOperand) {
          // otherC edits the same list we edit
          if (otherC.p[common] <= c.lm)
            c.lm++;
          // changing c.from is handled above.
        }
      }
    } else if (otherC.ld !== void 0) {
      if (c.lm !== void 0) {
        if (commonOperand) {
          if (otherC.p[common] === c.p[common]) {
            // they deleted the thing we're trying to move
            return dest;
          }
          // otherC edits the same list we edit
          var p = otherC.p[common];
          var from = c.p[common];
          var to = c.lm;
          if (p < to || (p === to && from < to))
            c.lm--;

        }
      }

      if (otherC.p[common] < c.p[common]) {
        c.p[common]--;
      } else if (otherC.p[common] === c.p[common]) {
        if (otherCplength < cplength) {
          // we're below the deleted element, so -> noop
          return dest;
        } else if (c.ld !== void 0) {
          if (c.li !== void 0) {
            // we're replacing, they're deleting. we become an insert.
            delete c.ld;
          } else {
            // we're trying to delete the same element, -> noop
            return dest;
          }
        }
      }

    } else if (otherC.lm !== void 0) {
      if (c.lm !== void 0 && cplength === otherCplength) {
        // lm vs lm, here we go!
        var from = c.p[common];
        var to = c.lm;
        var otherFrom = otherC.p[common];
        var otherTo = otherC.lm;
        if (otherFrom !== otherTo) {
          // if otherFrom == otherTo, we don't need to change our op.

          // where did my thing go?
          if (from === otherFrom) {
            // they moved it! tie break.
            if (type === 'left') {
              c.p[common] = otherTo;
              if (from === to) // ugh
                c.lm = otherTo;
            } else {
              return dest;
            }
          } else {
            // they moved around it
            if (from > otherFrom) c.p[common]--;
            if (from > otherTo) c.p[common]++;
            else if (from === otherTo) {
              if (otherFrom > otherTo) {
                c.p[common]++;
                if (from === to) // ugh, again
                  c.lm++;
              }
            }

            // step 2: where am i going to put it?
            if (to > otherFrom) {
              c.lm--;
            } else if (to === otherFrom) {
              if (to > from)
                c.lm--;
            }
            if (to > otherTo) {
              c.lm++;
            } else if (to === otherTo) {
              // if we're both moving in the same direction, tie break
              if ((otherTo > otherFrom && to > from) ||
                  (otherTo < otherFrom && to < from)) {
                if (type === 'right') c.lm++;
              } else {
                if (to > from) c.lm++;
                else if (to === otherFrom) c.lm--;
              }
            }
          }
        }
      } else if (c.li !== void 0 && c.ld === undefined && commonOperand) {
        // li
        var from = otherC.p[common];
        var to = otherC.lm;
        p = c.p[common];
        if (p > from) c.p[common]--;
        if (p > to) c.p[common]++;
      } else {
        // ld, ld+li, si, sd, na, oi, od, oi+od, any li on an element beneath
        // the lm
        //
        // i.e. things care about where their item is after the move.
        var from = otherC.p[common];
        var to = otherC.lm;
        p = c.p[common];
        if (p === from) {
          c.p[common] = to;
        } else {
          if (p > from) c.p[common]--;
          if (p > to) c.p[common]++;
          else if (p === to && from > to) c.p[common]++;
        }
      }
    }
    else if (otherC.oi !== void 0 && otherC.od !== void 0) {
      if (c.p[common] === otherC.p[common]) {
        if (c.oi !== void 0 && commonOperand) {
          // we inserted where someone else replaced
          if (type === 'right') {
            // left wins
            return dest;
          } else {
            // we win, make our op replace what they inserted
            c.od = otherC.oi;
          }
        } else {
          // -> noop if the other component is deleting the same object (or any parent)
          return dest;
        }
      }
    } else if (otherC.oi !== void 0) {
      if (c.oi !== void 0 && c.p[common] === otherC.p[common]) {
        // left wins if we try to insert at the same place
        if (type === 'left') {
          json.append(dest,{p: c.p, od:otherC.oi});
        } else {
          return dest;
        }
      }
    } else if (otherC.od !== void 0) {
      if (c.p[common] == otherC.p[common]) {
        if (!commonOperand)
          return dest;
        if (c.oi !== void 0) {
          delete c.od;
        } else {
          return dest;
        }
      }
    }
  }

  json.append(dest,c);
  return dest;
};

if (typeof require !== "undefined") {
  require('./helpers')._bootstrapTransform(json, json.transformComponent, json.checkValidOp, json.append);
} else {
  // This is kind of awful - come up with a better way to hook this helper code up.
  exports._bootstrapTransform(json, json.transformComponent, json.checkValidOp, json.append);
}

module.exports = json;

},{"./text-old":87,"./helpers":88}],88:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
exports._bootstrapTransform = function(type, transformComponent, checkValidOp, append) {
  var transformComponentX, transformX;

  transformComponentX = function(left, right, destLeft, destRight) {
    transformComponent(destLeft, left, right, 'left');
    return transformComponent(destRight, right, left, 'right');
  };
  type.transformX = type.transformX = transformX = function(leftOp, rightOp) {
    var k, l, l_, newLeftOp, newRightOp, nextC, r, r_, rightComponent, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1;

    checkValidOp(leftOp);
    checkValidOp(rightOp);
    newRightOp = [];
    for (_i = 0, _len = rightOp.length; _i < _len; _i++) {
      rightComponent = rightOp[_i];
      newLeftOp = [];
      k = 0;
      while (k < leftOp.length) {
        nextC = [];
        transformComponentX(leftOp[k], rightComponent, newLeftOp, nextC);
        k++;
        if (nextC.length === 1) {
          rightComponent = nextC[0];
        } else if (nextC.length === 0) {
          _ref = leftOp.slice(k);
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            l = _ref[_j];
            append(newLeftOp, l);
          }
          rightComponent = null;
          break;
        } else {
          _ref1 = transformX(leftOp.slice(k), nextC), l_ = _ref1[0], r_ = _ref1[1];
          for (_k = 0, _len2 = l_.length; _k < _len2; _k++) {
            l = l_[_k];
            append(newLeftOp, l);
          }
          for (_l = 0, _len3 = r_.length; _l < _len3; _l++) {
            r = r_[_l];
            append(newRightOp, r);
          }
          rightComponent = null;
          break;
        }
      }
      if (rightComponent != null) {
        append(newRightOp, rightComponent);
      }
      leftOp = newLeftOp;
    }
    return [leftOp, newRightOp];
  };
  return type.transform = type['transform'] = function(op, otherOp, type) {
    if (!(type === 'left' || type === 'right')) {
      throw new Error("type must be 'left' or 'right'");
    }
    if (otherOp.length === 0) {
      return op;
    }
    if (op.length === 1 && otherOp.length === 1) {
      return transformComponent([], op[0], otherOp[0], type);
    }
    if (type === 'left') {
      return transformX(op, otherOp)[0];
    } else {
      return transformX(otherOp, op)[1];
    }
  };
};

},{}],87:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var append, checkValidComponent, checkValidOp, invertComponent, strInject, text, transformComponent, transformPosition;

text = {
  name: 'text-old',
  uri: 'http://sharejs.org/types/textv0',
  create: function() {
    return '';
  }
};

strInject = function(s1, pos, s2) {
  return s1.slice(0, pos) + s2 + s1.slice(pos);
};

checkValidComponent = function(c) {
  var d_type, i_type;

  if (typeof c.p !== 'number') {
    throw new Error('component missing position field');
  }
  i_type = typeof c.i;
  d_type = typeof c.d;
  if (!((i_type === 'string') ^ (d_type === 'string'))) {
    throw new Error('component needs an i or d field');
  }
  if (!(c.p >= 0)) {
    throw new Error('position cannot be negative');
  }
};

checkValidOp = function(op) {
  var c, _i, _len;

  for (_i = 0, _len = op.length; _i < _len; _i++) {
    c = op[_i];
    checkValidComponent(c);
  }
  return true;
};

text.apply = function(snapshot, op) {
  var component, deleted, _i, _len;

  checkValidOp(op);
  for (_i = 0, _len = op.length; _i < _len; _i++) {
    component = op[_i];
    if (component.i != null) {
      snapshot = strInject(snapshot, component.p, component.i);
    } else {
      deleted = snapshot.slice(component.p, component.p + component.d.length);
      if (component.d !== deleted) {
        throw new Error("Delete component '" + component.d + "' does not match deleted text '" + deleted + "'");
      }
      snapshot = snapshot.slice(0, component.p) + snapshot.slice(component.p + component.d.length);
    }
  }
  return snapshot;
};

text._append = append = function(newOp, c) {
  var last, _ref, _ref1;

  if (c.i === '' || c.d === '') {
    return;
  }
  if (newOp.length === 0) {
    return newOp.push(c);
  } else {
    last = newOp[newOp.length - 1];
    if ((last.i != null) && (c.i != null) && (last.p <= (_ref = c.p) && _ref <= (last.p + last.i.length))) {
      return newOp[newOp.length - 1] = {
        i: strInject(last.i, c.p - last.p, c.i),
        p: last.p
      };
    } else if ((last.d != null) && (c.d != null) && (c.p <= (_ref1 = last.p) && _ref1 <= (c.p + c.d.length))) {
      return newOp[newOp.length - 1] = {
        d: strInject(c.d, last.p - c.p, last.d),
        p: c.p
      };
    } else {
      return newOp.push(c);
    }
  }
};

text.compose = function(op1, op2) {
  var c, newOp, _i, _len;

  checkValidOp(op1);
  checkValidOp(op2);
  newOp = op1.slice();
  for (_i = 0, _len = op2.length; _i < _len; _i++) {
    c = op2[_i];
    append(newOp, c);
  }
  return newOp;
};

text.compress = function(op) {
  return text.compose([], op);
};

text.normalize = function(op) {
  var c, newOp, _i, _len, _ref;

  newOp = [];
  if ((op.i != null) || (op.p != null)) {
    op = [op];
  }
  for (_i = 0, _len = op.length; _i < _len; _i++) {
    c = op[_i];
    if ((_ref = c.p) == null) {
      c.p = 0;
    }
    append(newOp, c);
  }
  return newOp;
};

transformPosition = function(pos, c, insertAfter) {
  if (c.i != null) {
    if (c.p < pos || (c.p === pos && insertAfter)) {
      return pos + c.i.length;
    } else {
      return pos;
    }
  } else {
    if (pos <= c.p) {
      return pos;
    } else if (pos <= c.p + c.d.length) {
      return c.p;
    } else {
      return pos - c.d.length;
    }
  }
};

text.transformCursor = function(position, op, side) {
  var c, insertAfter, _i, _len;

  insertAfter = side === 'right';
  for (_i = 0, _len = op.length; _i < _len; _i++) {
    c = op[_i];
    position = transformPosition(position, c, insertAfter);
  }
  return position;
};

text._tc = transformComponent = function(dest, c, otherC, side) {
  var cIntersect, intersectEnd, intersectStart, newC, otherIntersect, s;

  checkValidOp([c]);
  checkValidOp([otherC]);
  if (c.i != null) {
    append(dest, {
      i: c.i,
      p: transformPosition(c.p, otherC, side === 'right')
    });
  } else {
    if (otherC.i != null) {
      s = c.d;
      if (c.p < otherC.p) {
        append(dest, {
          d: s.slice(0, otherC.p - c.p),
          p: c.p
        });
        s = s.slice(otherC.p - c.p);
      }
      if (s !== '') {
        append(dest, {
          d: s,
          p: c.p + otherC.i.length
        });
      }
    } else {
      if (c.p >= otherC.p + otherC.d.length) {
        append(dest, {
          d: c.d,
          p: c.p - otherC.d.length
        });
      } else if (c.p + c.d.length <= otherC.p) {
        append(dest, c);
      } else {
        newC = {
          d: '',
          p: c.p
        };
        if (c.p < otherC.p) {
          newC.d = c.d.slice(0, otherC.p - c.p);
        }
        if (c.p + c.d.length > otherC.p + otherC.d.length) {
          newC.d += c.d.slice(otherC.p + otherC.d.length - c.p);
        }
        intersectStart = Math.max(c.p, otherC.p);
        intersectEnd = Math.min(c.p + c.d.length, otherC.p + otherC.d.length);
        cIntersect = c.d.slice(intersectStart - c.p, intersectEnd - c.p);
        otherIntersect = otherC.d.slice(intersectStart - otherC.p, intersectEnd - otherC.p);
        if (cIntersect !== otherIntersect) {
          throw new Error('Delete ops delete different text in the same region of the document');
        }
        if (newC.d !== '') {
          newC.p = transformPosition(newC.p, otherC);
          append(dest, newC);
        }
      }
    }
  }
  return dest;
};

invertComponent = function(c) {
  if (c.i != null) {
    return {
      d: c.i,
      p: c.p
    };
  } else {
    return {
      i: c.d,
      p: c.p
    };
  }
};

text.invert = function(op) {
  var c, _i, _len, _ref, _results;

  _ref = op.slice().reverse();
  _results = [];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    c = _ref[_i];
    _results.push(invertComponent(c));
  }
  return _results;
};

if (typeof require === 'undefined') {
  exports._bootstrapTransform(text, text.transformComponent, text.checkValidOp, text.append);
} else {
  require('./helpers')._bootstrapTransform(text, text.transformComponent, text.checkValidOp, text.append);
}

module.exports = text;

},{"./helpers":88}]},{},[16,9])
//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItc2FtcGxlL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbGliL2luZGV4LmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLXNhbXBsZS9ub2RlX21vZHVsZXMvZGVyYnkvbGliL2RlcmJ5LmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLXNhbXBsZS9saWIvYXBwL2NvbnRyb2xsZXJGbnMuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItc2FtcGxlL2xpYi9hcHAvZXZlbnRzLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLXNhbXBsZS9saWIvYXBwL3VzZXIuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItc2FtcGxlL2xpYi9hcHAvcm91dGVzLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLXNhbXBsZS9saWIvYXBwL3ZpZXdGbnMuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItc2FtcGxlL25vZGVfbW9kdWxlcy9yYWNlci1icm93c2VyY2hhbm5lbC9saWIvYnJvd3Nlci5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItc2FtcGxlL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9idWlsdGluL2V2ZW50cy5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2J1aWx0aW4vdXJsLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLXNhbXBsZS9ub2RlX21vZHVsZXMvcmFjZXItYnJvd3NlcmNoYW5uZWwvbm9kZV9tb2R1bGVzL2Jyb3dzZXJjaGFubmVsL2Rpc3QvYmNzb2NrZXQtdW5jb21wcmVzc2VkLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLXNhbXBsZS9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvYnVpbHRpbi9xdWVyeXN0cmluZy5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9saWIvUmFjZXIuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItc2FtcGxlL2xpYi9hcHAvaW5kZXguanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItc2FtcGxlL3VpL2luZGV4LmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLXNhbXBsZS91aS9jb25uZWN0aW9uQWxlcnQvaW5kZXguanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItc2FtcGxlL25vZGVfbW9kdWxlcy9kZXJieS9saWIvZGVyYnkuYnJvd3Nlci5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L2xpYi9hcHAuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItc2FtcGxlL25vZGVfbW9kdWxlcy9kZXJieS9saWIvZGVyYnkuTW9kZWwuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItc2FtcGxlL25vZGVfbW9kdWxlcy9kZXJieS9saWIvdmlld01vZGVsLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLXNhbXBsZS9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL2xpYi9Nb2RlbC9pbmRleC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L2xpYi9wYXRocy5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L2xpYi9FdmVudERpc3BhdGNoZXIuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItc2FtcGxlL25vZGVfbW9kdWxlcy9kZXJieS9saWIvUGF0aE1hcC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L2xpYi90ZXh0T3QuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItc2FtcGxlL25vZGVfbW9kdWxlcy9kZXJieS11aS1naXRodWItYnV0dG9ucy9pbmRleC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2J1aWx0aW4vcGF0aC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9saWIvdXRpbC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy90cmFja3MvbGliL2Jyb3dzZXIuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItc2FtcGxlL25vZGVfbW9kdWxlcy9kZXJieS9saWIvY29tcG9uZW50LmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLXNhbXBsZS9ub2RlX21vZHVsZXMvZGVyYnkvbGliL0RvbS5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L2xpYi9yZWZyZXNoLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLXNhbXBsZS9ub2RlX21vZHVsZXMvZGVyYnktdWktZ2l0aHViLWJ1dHRvbnMvYnV0dG9uL2luZGV4LmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLXNhbXBsZS9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL25vZGVfbW9kdWxlcy9kZWVwLWlzL2luZGV4LmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLXNhbXBsZS9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL2RvbS1zaGltL2xpYi9pbmRleC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9saWIvTW9kZWwvZXZlbnRzLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLXNhbXBsZS9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL2xpYi9Nb2RlbC9wYXRocy5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9saWIvTW9kZWwvY29sbGVjdGlvbnMuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItc2FtcGxlL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbGliL01vZGVsL211dGF0b3JzLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLXNhbXBsZS9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL2xpYi9Nb2RlbC9zdWJzY3JpcHRpb25zLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLXNhbXBsZS9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL2xpYi9Nb2RlbC9jb250ZXh0cy5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9saWIvTW9kZWwvZm4uanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItc2FtcGxlL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbGliL01vZGVsL2ZpbHRlci5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9saWIvTW9kZWwvcmVmTGlzdC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9saWIvTW9kZWwvcmVmLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLXNhbXBsZS9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL2xpYi9Nb2RlbC9kZWZhdWx0Rm5zLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLXNhbXBsZS9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3RyYWNrcy9saWIvY29tcG9zZS5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L2xpYi9WaWV3LmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLXNhbXBsZS9ub2RlX21vZHVsZXMvZGVyYnkvbGliL21hcmt1cC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L2xpYi9ldmVudEJpbmRpbmcuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItc2FtcGxlL25vZGVfbW9kdWxlcy9kZXJieS9saWIvdmlld1BhdGguanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItc2FtcGxlL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvaHRtbC11dGlsL2xpYi9pbmRleC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy90cmFja3MvdmVuZG9yL2V4cHJlc3Mvcm91dGVyL3JvdXRlLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLXNhbXBsZS9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL2h0bWwtdXRpbC9saWIvZW50aXR5Q29kZS5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9odG1sLXV0aWwvbGliL3BhcnNlLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLXNhbXBsZS9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL2xpYi9DaGFubmVsLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLXNhbXBsZS9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL2xpYi9Nb2RlbC9Mb2NhbERvYy5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9saWIvTW9kZWwvUmVtb3RlRG9jLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLXNhbXBsZS9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3RyYWNrcy92ZW5kb3IvZXhwcmVzcy91dGlscy5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9saWIvTW9kZWwvY29ubmVjdGlvbi5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9saWIvTW9kZWwvTW9kZWwuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItc2FtcGxlL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbGliL01vZGVsL0RvYy5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9saWIvTW9kZWwvc2V0RGlmZi5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9saWIvTW9kZWwvUXVlcnkuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItc2FtcGxlL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvdHJhY2tzL2xpYi9IaXN0b3J5LmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLXNhbXBsZS9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3RyYWNrcy9saWIvcm91dGVyLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLXNhbXBsZS9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvYnVmZmVyLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLXNhbXBsZS9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL25vZGVfbW9kdWxlcy9ub2RlLXV1aWQvdXVpZC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvYXJyYXlkaWZmL2luZGV4LmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLXNhbXBsZS9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3RyYWNrcy9ub2RlX21vZHVsZXMvcXMvaW5kZXguanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItc2FtcGxlL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvTUQ1L21kNS5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvc2hhcmUvbGliL2NsaWVudC9pbmRleC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9NRDUvbm9kZV9tb2R1bGVzL2NyeXB0L2NyeXB0LmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLXNhbXBsZS9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL01ENS9ub2RlX21vZHVsZXMvY2hhcmVuYy9jaGFyZW5jLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLXNhbXBsZS9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L2luZGV4LmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLXNhbXBsZS9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L3NoYS5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ybmcuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItc2FtcGxlL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbWQ1LmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLXNhbXBsZS9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL25vZGVfbW9kdWxlcy9zaGFyZS9saWIvY2xpZW50L21pY3JvZXZlbnQuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItc2FtcGxlL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbm9kZV9tb2R1bGVzL3NoYXJlL2xpYi9jbGllbnQvcXVlcnkuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItc2FtcGxlL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbm9kZV9tb2R1bGVzL3NoYXJlL2xpYi9jbGllbnQvY29ubmVjdGlvbi5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvc2hhcmUvbGliL2NsaWVudC9kb2MuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItc2FtcGxlL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbm9kZV9tb2R1bGVzL3NoYXJlL25vZGVfbW9kdWxlcy9vdHR5cGVzL2xpYi9pbmRleC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvc2hhcmUvbm9kZV9tb2R1bGVzL290dHlwZXMvbGliL3NpbXBsZS5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvc2hhcmUvbm9kZV9tb2R1bGVzL290dHlwZXMvbGliL3RleHQuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL1NpdGVzL2RlcmJ5LXVzZXItc2FtcGxlL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbm9kZV9tb2R1bGVzL3NoYXJlL25vZGVfbW9kdWxlcy9vdHR5cGVzL2xpYi90ZXh0LXRwMi5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvc2hhcmUvbm9kZV9tb2R1bGVzL290dHlwZXMvbGliL2pzb24wLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9TaXRlcy9kZXJieS11c2VyLXNhbXBsZS9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL25vZGVfbW9kdWxlcy9zaGFyZS9ub2RlX21vZHVsZXMvb3R0eXBlcy9saWIvaGVscGVycy5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvU2l0ZXMvZGVyYnktdXNlci1zYW1wbGUvbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvc2hhcmUvbm9kZV9tb2R1bGVzL290dHlwZXMvbGliL3RleHQtb2xkLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFDQTs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4akJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3Y1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdnhIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbllBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoNkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNub0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUmFjZXIgPSByZXF1aXJlKCcuL1JhY2VyJyk7XG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBSYWNlcjtcbiIsIihmdW5jdGlvbihfX2Rpcm5hbWUpe3ZhciByYWNlciA9IHJlcXVpcmUoJ3JhY2VyJyk7XG52YXIgZGVyYnkgPSBtb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUocmFjZXIpO1xuXG52YXIgZGVyYnlQbHVnaW4gPSAocmFjZXIudXRpbC5pc1NlcnZlcikgP1xuICBfX2Rpcm5hbWUgKyAnL2RlcmJ5LnNlcnZlcicgOlxuICByZXF1aXJlKCcuL2RlcmJ5LmJyb3dzZXInKTtcblxuLy8gVE9ETzogUmVtb3ZlIG9yIGltcGxlbWVudFxuZGVyYnkuZ2V0ID0gZnVuY3Rpb24oKSB7fVxuXG5kZXJieVxuICAvLyBTZXJ2ZXItc2lkZSBvciBicm93c2VyLXNpZGUgbWV0aG9kc1xuICAudXNlKGRlcmJ5UGx1Z2luKTtcblxufSkoXCIvbm9kZV9tb2R1bGVzL2RlcmJ5L2xpYlwiKSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFwcCkge1xuICBhcHAuZm4oJ3VzZXInLCB7XG4gICAgY2hhbmdlRW1haWw6IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgb3JpZ2luID0gdGhpcy5tb2RlbC5nZXQoJyRjb25maWcub3JpZ2luJyk7XG4gICAgICAkLnBvc3Qob3JpZ2luICsgJy91c2VyL2NoYW5nZUVtYWlsJywgZS5hdCgpLmdldCgpKTtcbiAgICB9LFxuICAgIGNoYW5nZVBhc3N3b3JkOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIG9yaWdpbiA9IHRoaXMubW9kZWwuZ2V0KCckY29uZmlnLm9yaWdpbicpO1xuICAgICAgJC5wb3N0KG9yaWdpbiArICcvdXNlci9jaGFuZ2VQYXNzd29yZCcsIGUuYXQoKS5nZXQoKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlLmF0KCkuZGVsKCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGNoYW5nZVVzZXJuYW1lOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIG9yaWdpbiA9IHRoaXMubW9kZWwuZ2V0KCckY29uZmlnLm9yaWdpbicpO1xuICAgICAgJC5wb3N0KG9yaWdpbiArICcvdXNlci9jaGFuZ2VVc2VybmFtZScsIGUuYXQoKS5nZXQoKSk7XG4gICAgfSxcbiAgICBjb25uZWN0OiB7XG4gICAgICBmYWNlYm9vazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIG9yaWdpbiA9IHRoaXMubW9kZWwuZ2V0KCckY29uZmlnLm9yaWdpbicpO1xuICAgICAgICAkLnBvcHVwV2luZG93KG9yaWdpbiArICcvdXNlci9hdXRoL2ZhY2Vib29rJyk7XG4gICAgICB9LFxuICAgICAgZ29vZ2xlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgb3JpZ2luID0gdGhpcy5tb2RlbC5nZXQoJyRjb25maWcub3JpZ2luJyk7XG4gICAgICAgICQucG9wdXBXaW5kb3cob3JpZ2luICsgJy91c2VyL2F1dGgvZ29vZ2xlJyk7XG4gICAgICB9LFxuICAgICAgdHdpdHRlcjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIG9yaWdpbiA9IHRoaXMubW9kZWwuZ2V0KCckY29uZmlnLm9yaWdpbicpO1xuICAgICAgICAkLnBvcHVwV2luZG93KG9yaWdpbiArICcvdXNlci9hdXRoL3R3aXR0ZXInKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGZvcmdvdFBhc3N3b3JkOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIG9yaWdpbiA9IHRoaXMubW9kZWwuZ2V0KCckY29uZmlnLm9yaWdpbicpO1xuICAgICAgJC5wb3N0KG9yaWdpbiArICcvdXNlci9mb3Jnb3RQYXNzd29yZCcsIGUuYXQoKS5nZXQoKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlLmF0KCkuZGVsKCk7XG4gICAgICAgIGUuYXQoKS5zZXQoJ3N1Y2Nlc3MnLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcmVzZXRQYXNzd29yZDogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcywgb3JpZ2luID0gdGhpcy5tb2RlbC5nZXQoJyRjb25maWcub3JpZ2luJyk7XG4gICAgICAkLnBvc3Qob3JpZ2luICsgJy91c2VyL3Jlc2V0UGFzc3dvcmQnLCBlLmF0KCkuZ2V0KCksIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHNlbGYubW9kZWwuc2V0KCdfc2Vzc2lvbi51c2VyLmlkJywgZS5hdCgpLmdldCgndXNlcklkJykpO1xuICAgICAgICBzZWxmLm1vZGVsLnNldCgnX3Nlc3Npb24udXNlci5pc1JlZ2lzdGVyZWQnLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2lnbmluOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzLCBvcmlnaW4gPSB0aGlzLm1vZGVsLmdldCgnJGNvbmZpZy5vcmlnaW4nKTtcbiAgICAgICQucG9zdChvcmlnaW4gKyAnL3VzZXIvc2lnbmluJywgZS5hdCgpLmdldCgpLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBzZWxmLm1vZGVsLnNldCgnX3Nlc3Npb24udXNlci5pZCcsIGRhdGEudXNlci5pZCk7XG4gICAgICAgIHNlbGYubW9kZWwuc2V0KCdfc2Vzc2lvbi51c2VyLmlzUmVnaXN0ZXJlZCcsIHRydWUpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBzaWdub3V0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzLCBvcmlnaW4gPSB0aGlzLm1vZGVsLmdldCgnJGNvbmZpZy5vcmlnaW4nKTtcbiAgICAgICQucG9zdChvcmlnaW4gKyAnL3VzZXIvc2lnbm91dCcsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHNlbGYubW9kZWwuc2V0KCdfc2Vzc2lvbi51c2VyLmlkJywgZGF0YS51c2VyLmlkKTtcbiAgICAgICAgc2VsZi5tb2RlbC5zZXQoJ19zZXNzaW9uLnVzZXIuaXNSZWdpc3RlcmVkJywgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBzaWdudXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMsIG9yaWdpbiA9IHRoaXMubW9kZWwuZ2V0KCckY29uZmlnLm9yaWdpbicpO1xuICAgICAgJC5wb3N0KG9yaWdpbiArICcvdXNlci9zaWdudXAnLCBlLmF0KCkuZ2V0KCksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5tb2RlbC5zZXQoJ19zZXNzaW9uLnVzZXIuaXNSZWdpc3RlcmVkJywgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHZlcmlmeUVtYWlsOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzLCBvcmlnaW4gPSB0aGlzLm1vZGVsLmdldCgnJGNvbmZpZy5vcmlnaW4nKTtcbiAgICAgICQucG9zdChvcmlnaW4gKyAnL3VzZXIvdmVyaWZ5RW1haWwnLCBlLmF0KCkuZ2V0KCkpO1xuICAgIH1cbiAgfSk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFwcCkge1xuICBhcHAucmVhZHkoZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgbW9kZWwub24oJ2NoYW5nZScsICckY29ubmVjdGlvbi5zdGF0ZScsIGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgaWYgKHN0YXRlICE9PSAnY29ubmVjdGVkJykgcmV0dXJuO1xuICAgICAgaWYgKG1vZGVsLmdldCgnX3Nlc3Npb24udXNlci5pZCcpKSByZXR1cm47XG4gICAgICB2YXIgb3JpZ2luID0gbW9kZWwuZ2V0KCckY29uZmlnLm9yaWdpbicpO1xuICAgICAgJC5hamF4KHt0eXBlOiAnUE9TVCcsIHVybDogb3JpZ2luICsgJy91c2VyL3Nlc3Npb25pemUnfSkuZG9uZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBtb2RlbC5zZXQoJ19zZXNzaW9uLnVzZXIuaWQnLCBkYXRhLnVzZXIuaWQpO1xuICAgICAgICBtb2RlbC5zZXQoJ19zZXNzaW9uLnVzZXIucmVnaXN0ZXJlZCcsIGRhdGEudXNlci5yZWdpc3RlcmVkKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgbW9kZWwub24oJ2NoYW5nZScsICdfc2Vzc2lvbi51c2VyLmlkJywgZnVuY3Rpb24gKHVzZXJJZCkge1xuICAgICAgaWYgKCF1c2VySWQpIHJldHVybjtcbiAgICAgIHZhciAkcHJpdmF0ZSA9IG1vZGVsLmF0KCd1c2Vyc1ByaXZhdGUuJyArIHVzZXJJZCk7XG4gICAgICB2YXIgJHB1YmxpYyA9IG1vZGVsLmF0KCd1c2Vyc1B1YmxpYy4nICsgdXNlcklkKTtcbiAgICAgIG1vZGVsLnN1YnNjcmliZSgkcHJpdmF0ZSwgJHB1YmxpYywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICBtb2RlbC5yZWYoJ19wYWdlLnVzZXIucHJpdmF0ZScsICRwcml2YXRlKTtcbiAgICAgICAgbW9kZWwucmVmKCdfcGFnZS51c2VyLnB1YmxpYycsICRwdWJsaWMpO1xuICAgICAgICB2YXIgaXNSZWdpc3RlcmVkID0gJHB1YmxpYy5nZXQoJ2lzUmVnaXN0ZXJlZCcpO1xuICAgICAgICBpZiAobW9kZWwuZ2V0KCdfcGFnZS5wcml2YXRlJykgJiYgIWlzUmVnaXN0ZXJlZCkgcmV0dXJuIGFwcC5oaXN0b3J5LnB1c2goJy8nKTtcbiAgICAgICAgaWYgKG1vZGVsLmdldCgnX3BhZ2UucHVibGljJykgJiYgaXNSZWdpc3RlcmVkKSBhcHAuaGlzdG9yeS5wdXNoKCcvc2V0dGluZ3MnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgbW9kZWwub24oJ2NoYW5nZScsICdfc2Vzc2lvbi51c2VyLmlzUmVnaXN0ZXJlZCcsIGZ1bmN0aW9uIChpc1JlZ2lzdGVyZWQpIHtcbiAgICAgIGlmIChtb2RlbC5nZXQoJ19wYWdlLnByaXZhdGUnKSAmJiAhaXNSZWdpc3RlcmVkKSByZXR1cm4gYXBwLmhpc3RvcnkucHVzaCgnLycpO1xuICAgICAgaWYgKG1vZGVsLmdldCgnX3BhZ2UucHVibGljJykgJiYgaXNSZWdpc3RlcmVkKSBhcHAuaGlzdG9yeS5wdXNoKCcvc2V0dGluZ3MnKTtcbiAgICB9KTtcbiAgfSk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFwcCkge1xuICBhcHAuZ2V0KCcqJywgZnVuY3Rpb24gKHBhZ2UsIG1vZGVsLCBwYXJhbXMsIG5leHQpIHtcbiAgICB2YXIgdXNlcklkID0gbW9kZWwuZ2V0KCdfc2Vzc2lvbi51c2VyLmlkJyk7XG4gICAgaWYgKCF1c2VySWQpIHJldHVybiBuZXh0KCk7XG4gICAgdmFyICRwcml2YXRlID0gbW9kZWwuYXQoJ3VzZXJzUHJpdmF0ZS4nICsgdXNlcklkKTtcbiAgICB2YXIgJHB1YmxpYyA9IG1vZGVsLmF0KCd1c2Vyc1B1YmxpYy4nICsgdXNlcklkKTtcbiAgICBtb2RlbC5zdWJzY3JpYmUoJHByaXZhdGUsICRwdWJsaWMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBuZXh0KGVycik7XG4gICAgICBtb2RlbC5yZWYoJ19wYWdlLnVzZXIucHJpdmF0ZScsICRwcml2YXRlKTtcbiAgICAgIG1vZGVsLnJlZignX3BhZ2UudXNlci5wdWJsaWMnLCAkcHVibGljKTtcbiAgICAgIG5leHQoKTtcbiAgICB9KTtcbiAgfSk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFwcCkge1xuICBhcHAuZ2V0KCcvJywgZnVuY3Rpb24gKHBhZ2UpIHtcbiAgICBwYWdlLnJlbmRlcignaG9tZScpO1xuICB9KTtcblxuICBhcHAuZ2V0KCcvNDAzJywgZnVuY3Rpb24gKHBhZ2UpIHtcbiAgICBwYWdlLnJlbmRlcignNDAzJyk7XG4gIH0pO1xuXG4gIGFwcC5nZXQoJy80MDQnLCBmdW5jdGlvbiAocGFnZSkge1xuICAgIHBhZ2UucmVuZGVyKCc0MDQnKTtcbiAgfSk7XG5cbiAgYXBwLmdldCgnLzQwNCcsIGZ1bmN0aW9uIChwYWdlKSB7XG4gICAgcGFnZS5yZW5kZXIoJzQwNCcpO1xuICB9KTtcblxuICBhcHAuZ2V0KCcvNTAwJywgZnVuY3Rpb24gKHBhZ2UpIHtcbiAgICBwYWdlLnJlbmRlcignNTAwJyk7XG4gIH0pO1xuXG4gIGFwcC5nZXQoJy9mb3Jnb3QnLCBmdW5jdGlvbiAocGFnZSwgbW9kZWwpIHtcbiAgICBtb2RlbC5zZXQoJ19wYWdlLnB1YmxpYycsIHRydWUpO1xuICAgIHBhZ2UucmVuZGVyKCdmb3Jnb3QnKTtcbiAgfSk7XG5cbiAgYXBwLmdldCgnL3Jlc2V0Lzp1c2VySWQvOnRva2VuJywgZnVuY3Rpb24gKHBhZ2UsIG1vZGVsKSB7XG4gICAgbW9kZWwuc2V0KCdfcGFnZS5mb3JtLnRva2VuJywgcGFnZS5wYXJhbXMudG9rZW4pO1xuICAgIG1vZGVsLnNldCgnX3BhZ2UuZm9ybS51c2VySWQnLCBwYWdlLnBhcmFtcy51c2VySWQpO1xuICAgIG1vZGVsLnNldCgnX3BhZ2UucHVibGljJywgdHJ1ZSk7XG4gICAgcGFnZS5yZW5kZXIoJ3Jlc2V0Jyk7XG4gIH0pO1xuXG4gIGFwcC5nZXQoJy9zZXR0aW5ncycsIGZ1bmN0aW9uIChwYWdlLCBtb2RlbCkge1xuICAgIG1vZGVsLnNldE51bGwoJ19wYWdlLmZvcm0udXNlcm5hbWUudXNlcm5hbWUnLCBtb2RlbC5nZXQoJ19wYWdlLnVzZXIucHVibGljLmxvY2FsLnVzZXJuYW1lJykpO1xuICAgIG1vZGVsLnNldE51bGwoJ19wYWdlLmZvcm0uZW1haWwuZW1haWwnLCBtb2RlbC5nZXQoJ19wYWdlLnVzZXIucHJpdmF0ZS5sb2NhbC5lbWFpbHMuMC52YWx1ZScpKTtcbiAgICBtb2RlbC5zZXQoJ19wYWdlLnByaXZhdGUnLCB0cnVlKTtcbiAgICBwYWdlLnJlbmRlcignc2V0dGluZ3MnKTtcbiAgfSk7XG5cbiAgYXBwLmdldCgnL3NpZ25pbicsIGZ1bmN0aW9uIChwYWdlLCBtb2RlbCkge1xuICAgIG1vZGVsLnNldCgnX3BhZ2UucHVibGljJywgdHJ1ZSk7XG4gICAgcGFnZS5yZW5kZXIoJ3NpZ25pbicpO1xuICB9KTtcblxuICBhcHAuZ2V0KCcvc2lnbnVwJywgZnVuY3Rpb24gKHBhZ2UsIG1vZGVsKSB7XG4gICAgbW9kZWwuc2V0KCdfcGFnZS5wdWJsaWMnLCB0cnVlKTtcbiAgICBwYWdlLnJlbmRlcignc2lnbnVwJyk7XG4gIH0pO1xuXG4gIGFwcC5nZXQoJy91c2VyL2F1dGgvOnByb3ZpZGVyL2RvbmUnLCBmdW5jdGlvbiAocGFnZSwgbW9kZWwpIHtcbiAgICBwYWdlLnJlbmRlcignaG9tZScpO1xuICB9KTtcblxuICBhcHAuZW50ZXIoJy91c2VyL2F1dGgvOnByb3ZpZGVyL2RvbmUnLCBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICBpZiAoIXdpbmRvdy5vcGVuZXIpIHJldHVybjtcbiAgICB2YXIgdXNlcklkID0gbW9kZWwuZ2V0KCdfc2Vzc2lvbi51c2VyLmlkJyk7XG4gICAgd2luZG93Lm9wZW5lci5ERVJCWS5hcHAubW9kZWwuc2V0KCdfc2Vzc2lvbi51c2VyLmlkJywgdXNlcklkKTtcbiAgICB3aW5kb3cub3BlbmVyLkRFUkJZLmFwcC5tb2RlbC5zZXQoJ19zZXNzaW9uLnVzZXIucmVnaXN0ZXJlZCcsIHRydWUpO1xuICAgIHdpbmRvdy5jbG9zZSgpO1xuICB9KTtcbn07IiwidmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcHApIHtcbiAgYXBwLnZpZXcuZm4oJ3VzZXIuZGlzcGxheU5hbWUnLCBmdW5jdGlvbiAocHVibGljKSB7XG4gICAgaWYgKHB1YmxpYy5sb2NhbCkgcmV0dXJuIHB1YmxpYy5sb2NhbC51c2VybmFtZTtcbiAgICBpZiAocHVibGljLmZhY2Vib29rKSByZXR1cm4gcHVibGljLmZhY2Vib29rLmRpc3BsYXlOYW1lO1xuICAgIGlmIChwdWJsaWMuZ29vZ2xlKSByZXR1cm4gcHVibGljLmdvb2dsZS5kaXNwbGF5TmFtZTtcbiAgICBpZiAocHVibGljLnR3aXR0ZXIpIHJldHVybiBwdWJsaWMudHdpdHRlci5kaXNwbGF5TmFtZTtcbiAgfSk7XG5cbiAgYXBwLnZpZXcuZm4oJ3VzZXIucGhvdG9VcmwnLCBmdW5jdGlvbiAocHVibGljKSB7XG4gICAgaWYgKHB1YmxpYy5mYWNlYm9vaykgcmV0dXJuICdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS8nICsgcHVibGljLmZhY2Vib29rLnVzZXJuYW1lICsgJy9waWN0dXJlJztcbiAgICBpZiAocHVibGljLmdvb2dsZSAmJiBwdWJsaWMuZ29vZ2xlLnBob3RvcyAmJiBwdWJsaWMuZ29vZ2xlLnBob3Rvc1swXSkgcmV0dXJuIHB1YmxpYy5nb29nbGUucGhvdG9zWzBdLnZhbHVlO1xuICAgIGlmIChwdWJsaWMudHdpdHRlciAmJiBwdWJsaWMudHdpdHRlci5waG90b3MgJiYgcHVibGljLnR3aXR0ZXIucGhvdG9zWzBdKSByZXR1cm4gcHVibGljLnR3aXR0ZXIucGhvdG9zWzBdLnZhbHVlO1xuICAgIGlmIChwdWJsaWMuZ3JhdmF0YXIgJiYgcHVibGljLmdyYXZhdGFyLnRodW1ibmFpbFVybCkgcmV0dXJuIHB1YmxpYy5ncmF2YXRhci50aHVtYm5haWxVcmw7XG4gIH0pO1xufTsiLCJ2YXIgcmFjZXIgPSByZXF1aXJlKCdyYWNlcicpO1xudmFyIEJDU29ja2V0ID0gcmVxdWlyZSgnYnJvd3NlcmNoYW5uZWwvZGlzdC9iY3NvY2tldC11bmNvbXByZXNzZWQnKS5CQ1NvY2tldDtcblxucmFjZXIuTW9kZWwucHJvdG90eXBlLl9jcmVhdGVTb2NrZXQgPSBmdW5jdGlvbihidW5kbGUpIHtcbiAgdmFyIG9wdGlvbnMgPSBidW5kbGUucmFjZXJCcm93c2VyQ2hhbm5lbDtcbiAgdmFyIGJhc2UgPSBvcHRpb25zLmJhc2UgfHwgJy9jaGFubmVsJztcbiAgaWYgKGJ1bmRsZS5tb3VudCkgYmFzZSA9IGJ1bmRsZS5tb3VudCArIGJhc2U7XG4gIHJldHVybiBuZXcgQkNTb2NrZXQoYmFzZSwgb3B0aW9ucyk7XG59O1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxucHJvY2Vzcy5uZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhblNldEltbWVkaWF0ZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnNldEltbWVkaWF0ZTtcbiAgICB2YXIgY2FuUG9zdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgO1xuXG4gICAgaWYgKGNhblNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZikgfTtcbiAgICB9XG5cbiAgICBpZiAoY2FuUG9zdCkge1xuICAgICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGlmIChldi5zb3VyY2UgPT09IHdpbmRvdyAmJiBldi5kYXRhID09PSAncHJvY2Vzcy10aWNrJykge1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKCdwcm9jZXNzLXRpY2snLCAnKicpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xufSkoKTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG4iLCIoZnVuY3Rpb24ocHJvY2Vzcyl7aWYgKCFwcm9jZXNzLkV2ZW50RW1pdHRlcikgcHJvY2Vzcy5FdmVudEVtaXR0ZXIgPSBmdW5jdGlvbiAoKSB7fTtcblxudmFyIEV2ZW50RW1pdHRlciA9IGV4cG9ydHMuRXZlbnRFbWl0dGVyID0gcHJvY2Vzcy5FdmVudEVtaXR0ZXI7XG52YXIgaXNBcnJheSA9IHR5cGVvZiBBcnJheS5pc0FycmF5ID09PSAnZnVuY3Rpb24nXG4gICAgPyBBcnJheS5pc0FycmF5XG4gICAgOiBmdW5jdGlvbiAoeHMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgICB9XG47XG5mdW5jdGlvbiBpbmRleE9mICh4cywgeCkge1xuICAgIGlmICh4cy5pbmRleE9mKSByZXR1cm4geHMuaW5kZXhPZih4KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh4ID09PSB4c1tpXSkgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhblxuLy8gMTAgbGlzdGVuZXJzIGFyZSBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoXG4vLyBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbi8vXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIXRoaXMuX2V2ZW50cykgdGhpcy5fZXZlbnRzID0ge307XG4gIHRoaXMuX2V2ZW50cy5tYXhMaXN0ZW5lcnMgPSBuO1xufTtcblxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc0FycmF5KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKVxuICAgIHtcbiAgICAgIGlmIChhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBhcmd1bWVudHNbMV07IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmNhdWdodCwgdW5zcGVjaWZpZWQgJ2Vycm9yJyBldmVudC5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpIHJldHVybiBmYWxzZTtcbiAgdmFyIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGlmICghaGFuZGxlcikgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PSAnZnVuY3Rpb24nKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmIChpc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgdmFyIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8vIEV2ZW50RW1pdHRlciBpcyBkZWZpbmVkIGluIHNyYy9ub2RlX2V2ZW50cy5jY1xuLy8gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0KCkgaXMgYWxzbyBkZWZpbmVkIHRoZXJlLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2YgbGlzdGVuZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZExpc3RlbmVyIG9ubHkgdGFrZXMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XG4gIH1cblxuICBpZiAoIXRoaXMuX2V2ZW50cykgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PSBcIm5ld0xpc3RlbmVyc1wiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lcnNcIi5cbiAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodGhpcy5fZXZlbnRzW3R5cGVdKSkge1xuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICAgIHZhciBtO1xuICAgICAgaWYgKHRoaXMuX2V2ZW50cy5tYXhMaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtID0gdGhpcy5fZXZlbnRzLm1heExpc3RlbmVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG0gPSBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgICAgfVxuXG4gICAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5vbih0eXBlLCBmdW5jdGlvbiBnKCkge1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG4gICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBsaXN0ZW5lcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVtb3ZlTGlzdGVuZXIgb25seSB0YWtlcyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIC8vIGRvZXMgbm90IHVzZSBsaXN0ZW5lcnMoKSwgc28gbm8gc2lkZSBlZmZlY3Qgb2YgY3JlYXRpbmcgX2V2ZW50c1t0eXBlXVxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKSByZXR1cm4gdGhpcztcblxuICB2YXIgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNBcnJheShsaXN0KSkge1xuICAgIHZhciBpID0gaW5kZXhPZihsaXN0LCBsaXN0ZW5lcik7XG4gICAgaWYgKGkgPCAwKSByZXR1cm4gdGhpcztcbiAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICBpZiAobGlzdC5sZW5ndGggPT0gMClcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIH0gZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdID09PSBsaXN0ZW5lcikge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZG9lcyBub3QgdXNlIGxpc3RlbmVycygpLCBzbyBubyBzaWRlIGVmZmVjdCBvZiBjcmVhdGluZyBfZXZlbnRzW3R5cGVdXG4gIGlmICh0eXBlICYmIHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbdHlwZV0pIHRoaXMuX2V2ZW50c1t0eXBlXSA9IG51bGw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSB7fTtcbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFtdO1xuICBpZiAoIWlzQXJyYXkodGhpcy5fZXZlbnRzW3R5cGVdKSkge1xuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICB9XG4gIHJldHVybiB0aGlzLl9ldmVudHNbdHlwZV07XG59O1xuXG59KShyZXF1aXJlKFwiX19icm93c2VyaWZ5X3Byb2Nlc3NcIikpIiwidmFyIHB1bnljb2RlID0geyBlbmNvZGUgOiBmdW5jdGlvbiAocykgeyByZXR1cm4gcyB9IH07XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZihhcnJheSwgc3ViamVjdCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gYXJyYXkubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgIGlmKGFycmF5W2ldID09IHN1YmplY3QpIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gb2JqZWN0S2V5cyhvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ICE9PSBPYmplY3Qob2JqZWN0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBvYmplY3QnKTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkga2V5c1trZXlzLmxlbmd0aF0gPSBrZXk7XG4gICAgcmV0dXJuIGtleXM7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0rJC8sXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ34nLCAnWycsICddJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10sXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddXG4gICAgICAuY29uY2F0KHVud2lzZSkuY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIG5vbkF1dGhDaGFycyA9IFsnLycsICdAJywgJz8nLCAnIyddLmNvbmNhdChkZWxpbXMpLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlthLXpBLVowLTldW2EtejAtOUEtWl8tXXswLDYyfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oW2EtekEtWjAtOV1bYS16MC05QS1aXy1dezAsNjJ9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGhhdmUgYSBwYXRoIGNvbXBvbmVudC5cbiAgICBwYXRoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdHlwZW9mKHVybCkgPT09ICdvYmplY3QnICYmIHVybC5ocmVmKSByZXR1cm4gdXJsO1xuXG4gIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICB2YXIgb3V0ID0ge30sXG4gICAgICByZXN0ID0gdXJsO1xuXG4gIC8vIGN1dCBvZmYgYW55IGRlbGltaXRlcnMuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiPGh0dHA6Ly9mb28uY29tPlwiXG4gIGZvciAodmFyIGkgPSAwLCBsID0gcmVzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoYXJyYXlJbmRleE9mKGRlbGltcywgcmVzdC5jaGFyQXQoaSkpID09PSAtMSkgYnJlYWs7XG4gIH1cbiAgaWYgKGkgIT09IDApIHJlc3QgPSByZXN0LnN1YnN0cihpKTtcblxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICBvdXQucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICBvdXQuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvLyBkb24ndCBlbmZvcmNlIGZ1bGwgUkZDIGNvcnJlY3RuZXNzLCBqdXN0IGJlIHVuc3R1cGlkIGFib3V0IGl0LlxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBAIHNpZ24sIHVubGVzcyBzb21lIG5vbi1hdXRoIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIHZhciBhdFNpZ24gPSBhcnJheUluZGV4T2YocmVzdCwgJ0AnKTtcbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgLy8gdGhlcmUgKm1heSBiZSogYW4gYXV0aFxuICAgICAgdmFyIGhhc0F1dGggPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub25BdXRoQ2hhcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGFycmF5SW5kZXhPZihyZXN0LCBub25BdXRoQ2hhcnNbaV0pO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xICYmIGluZGV4IDwgYXRTaWduKSB7XG4gICAgICAgICAgLy8gbm90IGEgdmFsaWQgYXV0aC4gIFNvbWV0aGluZyBsaWtlIGh0dHA6Ly9mb28uY29tL2JhckBiYXovXG4gICAgICAgICAgaGFzQXV0aCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaGFzQXV0aCkge1xuICAgICAgICAvLyBwbHVjayBvZmYgdGhlIGF1dGggcG9ydGlvbi5cbiAgICAgICAgb3V0LmF1dGggPSByZXN0LnN1YnN0cigwLCBhdFNpZ24pO1xuICAgICAgICByZXN0ID0gcmVzdC5zdWJzdHIoYXRTaWduICsgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0Tm9uSG9zdCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9uSG9zdENoYXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGluZGV4ID0gYXJyYXlJbmRleE9mKHJlc3QsIG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xICYmXG4gICAgICAgICAgKGZpcnN0Tm9uSG9zdCA8IDAgfHwgaW5kZXggPCBmaXJzdE5vbkhvc3QpKSBmaXJzdE5vbkhvc3QgPSBpbmRleDtcbiAgICB9XG5cbiAgICBpZiAoZmlyc3ROb25Ib3N0ICE9PSAtMSkge1xuICAgICAgb3V0Lmhvc3QgPSByZXN0LnN1YnN0cigwLCBmaXJzdE5vbkhvc3QpO1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKGZpcnN0Tm9uSG9zdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dC5ob3N0ID0gcmVzdDtcbiAgICAgIHJlc3QgPSAnJztcbiAgICB9XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHZhciBwID0gcGFyc2VIb3N0KG91dC5ob3N0KTtcbiAgICB2YXIga2V5cyA9IG9iamVjdEtleXMocCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBvdXRba2V5XSA9IHBba2V5XTtcbiAgICB9XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgb3V0Lmhvc3RuYW1lID0gb3V0Lmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKG91dC5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgb3V0Lmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSBvdXQuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0Lmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgIG91dC5ob3N0bmFtZSA9IG91dC5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueSBjb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgIC8vIEl0IG9ubHkgY29udmVydHMgdGhlIHBhcnQgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAvLyBoYXMgbm9uIEFTQ0lJIGNoYXJhY3RlcnMuIEkuZS4gaXQgZG9zZW50IG1hdHRlciBpZlxuICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIGluIEFTQ0lJLlxuICAgIHZhciBkb21haW5BcnJheSA9IG91dC5ob3N0bmFtZS5zcGxpdCgnLicpO1xuICAgIHZhciBuZXdPdXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvbWFpbkFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgcyA9IGRvbWFpbkFycmF5W2ldO1xuICAgICAgbmV3T3V0LnB1c2gocy5tYXRjaCgvW15BLVphLXowLTlfLV0vKSA/XG4gICAgICAgICAgJ3huLS0nICsgcHVueWNvZGUuZW5jb2RlKHMpIDogcyk7XG4gICAgfVxuICAgIG91dC5ob3N0bmFtZSA9IG5ld091dC5qb2luKCcuJyk7XG5cbiAgICBvdXQuaG9zdCA9IChvdXQuaG9zdG5hbWUgfHwgJycpICtcbiAgICAgICAgKChvdXQucG9ydCkgPyAnOicgKyBvdXQucG9ydCA6ICcnKTtcbiAgICBvdXQuaHJlZiArPSBvdXQuaG9zdDtcbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cblxuICAgIC8vIE5vdyBtYWtlIHN1cmUgdGhhdCBkZWxpbXMgbmV2ZXIgYXBwZWFyIGluIGEgdXJsLlxuICAgIHZhciBjaG9wID0gcmVzdC5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBkZWxpbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGFycmF5SW5kZXhPZihyZXN0LCBkZWxpbXNbaV0pO1xuICAgICAgaWYgKGMgIT09IC0xKSB7XG4gICAgICAgIGNob3AgPSBNYXRoLm1pbihjLCBjaG9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKDAsIGNob3ApO1xuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IGFycmF5SW5kZXhPZihyZXN0LCAnIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgb3V0Lmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSBhcnJheUluZGV4T2YocmVzdCwgJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIG91dC5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgb3V0LnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgb3V0LnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2Uob3V0LnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIG91dC5zZWFyY2ggPSAnJztcbiAgICBvdXQucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgb3V0LnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIG91dC5ob3N0bmFtZSAmJiAhb3V0LnBhdGhuYW1lKSB7XG4gICAgb3V0LnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAob3V0LnBhdGhuYW1lIHx8IG91dC5zZWFyY2gpIHtcbiAgICBvdXQucGF0aCA9IChvdXQucGF0aG5hbWUgPyBvdXQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgKG91dC5zZWFyY2ggPyBvdXQuc2VhcmNoIDogJycpO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIG91dC5ocmVmID0gdXJsRm9ybWF0KG91dCk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodHlwZW9mKG9iaikgPT09ICdzdHJpbmcnKSBvYmogPSB1cmxQYXJzZShvYmopO1xuXG4gIHZhciBhdXRoID0gb2JqLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGF1dGguc3BsaXQoJ0AnKS5qb2luKCclNDAnKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vbkF1dGhDaGFycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBuQUMgPSBub25BdXRoQ2hhcnNbaV07XG4gICAgICBhdXRoID0gYXV0aC5zcGxpdChuQUMpLmpvaW4oZW5jb2RlVVJJQ29tcG9uZW50KG5BQykpO1xuICAgIH1cbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IG9iai5wcm90b2NvbCB8fCAnJyxcbiAgICAgIGhvc3QgPSAob2JqLmhvc3QgIT09IHVuZGVmaW5lZCkgPyBhdXRoICsgb2JqLmhvc3QgOlxuICAgICAgICAgIG9iai5ob3N0bmFtZSAhPT0gdW5kZWZpbmVkID8gKFxuICAgICAgICAgICAgICBhdXRoICsgb2JqLmhvc3RuYW1lICtcbiAgICAgICAgICAgICAgKG9iai5wb3J0ID8gJzonICsgb2JqLnBvcnQgOiAnJylcbiAgICAgICAgICApIDpcbiAgICAgICAgICBmYWxzZSxcbiAgICAgIHBhdGhuYW1lID0gb2JqLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgcXVlcnkgPSBvYmoucXVlcnkgJiZcbiAgICAgICAgICAgICAgKCh0eXBlb2Ygb2JqLnF1ZXJ5ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIG9iamVjdEtleXMob2JqLnF1ZXJ5KS5sZW5ndGgpID9cbiAgICAgICAgICAgICAgICAgcXVlcnlzdHJpbmcuc3RyaW5naWZ5KG9iai5xdWVyeSkgOlxuICAgICAgICAgICAgICAgICAnJykgfHwgJycsXG4gICAgICBzZWFyY2ggPSBvYmouc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJyxcbiAgICAgIGhhc2ggPSBvYmouaGFzaCB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmIChvYmouc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsRm9ybWF0KHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkpO1xufVxuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcblxuICBzb3VyY2UgPSB1cmxQYXJzZSh1cmxGb3JtYXQoc291cmNlKSwgZmFsc2UsIHRydWUpO1xuICByZWxhdGl2ZSA9IHVybFBhcnNlKHVybEZvcm1hdChyZWxhdGl2ZSksIGZhbHNlLCB0cnVlKTtcblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgc291cmNlLmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHNvdXJjZS5ocmVmID0gdXJsRm9ybWF0KHNvdXJjZSk7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICByZWxhdGl2ZS5wcm90b2NvbCA9IHNvdXJjZS5wcm90b2NvbDtcbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdICYmXG4gICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lICYmICFyZWxhdGl2ZS5wYXRobmFtZSkge1xuICAgICAgcmVsYXRpdmUucGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lID0gJy8nO1xuICAgIH1cbiAgICByZWxhdGl2ZS5ocmVmID0gdXJsRm9ybWF0KHJlbGF0aXZlKTtcbiAgICByZXR1cm4gcmVsYXRpdmU7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHNvdXJjZS5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHJlbGF0aXZlLmhyZWYgPSB1cmxGb3JtYXQocmVsYXRpdmUpO1xuICAgICAgcmV0dXJuIHJlbGF0aXZlO1xuICAgIH1cbiAgICBzb3VyY2UucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZWxhdGl2ZS5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH1cbiAgICBzb3VyY2UucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICBzb3VyY2Uuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHNvdXJjZS5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNvdXJjZS5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICBzb3VyY2UuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgc291cmNlLmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICBzb3VyY2UucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChzb3VyY2UucGF0aG5hbWUgIT09IHVuZGVmaW5lZCB8fCBzb3VyY2Uuc2VhcmNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNvdXJjZS5wYXRoID0gKHNvdXJjZS5wYXRobmFtZSA/IHNvdXJjZS5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChzb3VyY2Uuc2VhcmNoID8gc291cmNlLnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgc291cmNlLnNsYXNoZXMgPSBzb3VyY2Uuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHNvdXJjZS5ocmVmID0gdXJsRm9ybWF0KHNvdXJjZSk7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChzb3VyY2UucGF0aG5hbWUgJiYgc291cmNlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAoc291cmNlLmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHNvdXJjZS5wYXRobmFtZSAmJiBzb3VyY2UucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gc291cmNlLnByb3RvY29sICYmXG4gICAgICAgICAgIXNsYXNoZWRQcm90b2NvbFtzb3VyY2UucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHNvdXJjZS5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG5cbiAgICBkZWxldGUgc291cmNlLmhvc3RuYW1lO1xuICAgIGRlbGV0ZSBzb3VyY2UucG9ydDtcbiAgICBpZiAoc291cmNlLmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHNvdXJjZS5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQoc291cmNlLmhvc3QpO1xuICAgIH1cbiAgICBkZWxldGUgc291cmNlLmhvc3Q7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICBkZWxldGUgcmVsYXRpdmUuaG9zdG5hbWU7XG4gICAgICBkZWxldGUgcmVsYXRpdmUucG9ydDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHJlbGF0aXZlLmhvc3Q7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHNvdXJjZS5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogc291cmNlLmhvc3Q7XG4gICAgc291cmNlLmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogc291cmNlLmhvc3RuYW1lO1xuICAgIHNvdXJjZS5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgc291cmNlLnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgc291cmNlLnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICBzb3VyY2UucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICgnc2VhcmNoJyBpbiByZWxhdGl2ZSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHNvdXJjZS5ob3N0bmFtZSA9IHNvdXJjZS5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHNvdXJjZS5ob3N0ICYmIGFycmF5SW5kZXhPZihzb3VyY2UuaG9zdCwgJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICBzb3VyY2UuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgc291cmNlLmhvc3QgPSBzb3VyY2UuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHNvdXJjZS5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgc291cmNlLnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChzb3VyY2UucGF0aG5hbWUgIT09IHVuZGVmaW5lZCB8fCBzb3VyY2Uuc2VhcmNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNvdXJjZS5wYXRoID0gKHNvdXJjZS5wYXRobmFtZSA/IHNvdXJjZS5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChzb3VyY2Uuc2VhcmNoID8gc291cmNlLnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgc291cmNlLmhyZWYgPSB1cmxGb3JtYXQoc291cmNlKTtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICBkZWxldGUgc291cmNlLnBhdGhuYW1lO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXNvdXJjZS5zZWFyY2gpIHtcbiAgICAgIHNvdXJjZS5wYXRoID0gJy8nICsgc291cmNlLnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHNvdXJjZS5wYXRoO1xuICAgIH1cbiAgICBzb3VyY2UuaHJlZiA9IHVybEZvcm1hdChzb3VyY2UpO1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChzb3VyY2UuaG9zdCB8fCByZWxhdGl2ZS5ob3N0KSAmJiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8XG4gICAgICBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICBzb3VyY2UuaG9zdG5hbWUgPSBzb3VyY2UuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSBzb3VyY2UuaG9zdCAmJiBhcnJheUluZGV4T2Yoc291cmNlLmhvc3QsICdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgc291cmNlLmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICBzb3VyY2UuaG9zdCA9IHNvdXJjZS5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAoc291cmNlLmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIHNvdXJjZS5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmIChzb3VyY2UucGF0aG5hbWUgIT09IHVuZGVmaW5lZCB8fCBzb3VyY2Uuc2VhcmNoICE9PSB1bmRlZmluZWQpIHtcbiAgICBzb3VyY2UucGF0aCA9IChzb3VyY2UucGF0aG5hbWUgPyBzb3VyY2UucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNvdXJjZS5zZWFyY2ggPyBzb3VyY2Uuc2VhcmNoIDogJycpO1xuICB9XG4gIHNvdXJjZS5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCBzb3VyY2UuYXV0aDtcbiAgc291cmNlLnNsYXNoZXMgPSBzb3VyY2Uuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICBzb3VyY2UuaHJlZiA9IHVybEZvcm1hdChzb3VyY2UpO1xuICByZXR1cm4gc291cmNlO1xufVxuXG5mdW5jdGlvbiBwYXJzZUhvc3QoaG9zdCkge1xuICB2YXIgb3V0ID0ge307XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBvdXQucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgb3V0Lmhvc3RuYW1lID0gaG9zdDtcbiAgcmV0dXJuIG91dDtcbn1cbiIsIihmdW5jdGlvbigpe1xuZnVuY3Rpb24gZSgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICB9XG59XG5mdW5jdGlvbiBtKGEpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGIpIHtcbiAgICB0aGlzW2FdID0gYlxuICB9XG59XG5mdW5jdGlvbiBhYShhKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpc1thXVxuICB9XG59XG5mdW5jdGlvbiBiYShhKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYVxuICB9XG59XG52YXIgcCwgY2EgPSBjYSB8fCB7fSwgcSA9IHRoaXM7XG5mdW5jdGlvbiBkYShhKSB7XG4gIGEgPSBhLnNwbGl0KFwiLlwiKTtcbiAgZm9yKHZhciBiID0gcSwgYztjID0gYS5zaGlmdCgpOykge1xuICAgIGlmKG51bGwgIT0gYltjXSkge1xuICAgICAgYiA9IGJbY11cbiAgICB9ZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuICByZXR1cm4gYlxufVxuZnVuY3Rpb24gZWEoKSB7XG59XG5mdW5jdGlvbiBmYShhKSB7XG4gIHZhciBiID0gdHlwZW9mIGE7XG4gIGlmKFwib2JqZWN0XCIgPT0gYikge1xuICAgIGlmKGEpIHtcbiAgICAgIGlmKGEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICByZXR1cm5cImFycmF5XCJcbiAgICAgIH1cbiAgICAgIGlmKGEgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJcbiAgICAgIH1cbiAgICAgIHZhciBjID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpO1xuICAgICAgaWYoXCJbb2JqZWN0IFdpbmRvd11cIiA9PSBjKSB7XG4gICAgICAgIHJldHVyblwib2JqZWN0XCJcbiAgICAgIH1cbiAgICAgIGlmKFwiW29iamVjdCBBcnJheV1cIiA9PSBjIHx8IFwibnVtYmVyXCIgPT0gdHlwZW9mIGEubGVuZ3RoICYmIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGEuc3BsaWNlICYmIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGEucHJvcGVydHlJc0VudW1lcmFibGUgJiYgIWEucHJvcGVydHlJc0VudW1lcmFibGUoXCJzcGxpY2VcIikpIHtcbiAgICAgICAgcmV0dXJuXCJhcnJheVwiXG4gICAgICB9XG4gICAgICBpZihcIltvYmplY3QgRnVuY3Rpb25dXCIgPT0gYyB8fCBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBhLmNhbGwgJiYgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgYS5wcm9wZXJ0eUlzRW51bWVyYWJsZSAmJiAhYS5wcm9wZXJ0eUlzRW51bWVyYWJsZShcImNhbGxcIikpIHtcbiAgICAgICAgcmV0dXJuXCJmdW5jdGlvblwiXG4gICAgICB9XG4gICAgfWVsc2Uge1xuICAgICAgcmV0dXJuXCJudWxsXCJcbiAgICB9XG4gIH1lbHNlIHtcbiAgICBpZihcImZ1bmN0aW9uXCIgPT0gYiAmJiBcInVuZGVmaW5lZFwiID09IHR5cGVvZiBhLmNhbGwpIHtcbiAgICAgIHJldHVyblwib2JqZWN0XCJcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJcbn1cbmZ1bmN0aW9uIHMoYSkge1xuICByZXR1cm5cImFycmF5XCIgPT0gZmEoYSlcbn1cbmZ1bmN0aW9uIGdhKGEpIHtcbiAgdmFyIGIgPSBmYShhKTtcbiAgcmV0dXJuXCJhcnJheVwiID09IGIgfHwgXCJvYmplY3RcIiA9PSBiICYmIFwibnVtYmVyXCIgPT0gdHlwZW9mIGEubGVuZ3RoXG59XG5mdW5jdGlvbiB1KGEpIHtcbiAgcmV0dXJuXCJzdHJpbmdcIiA9PSB0eXBlb2YgYVxufVxuZnVuY3Rpb24gaGEoYSkge1xuICByZXR1cm5cImZ1bmN0aW9uXCIgPT0gZmEoYSlcbn1cbmZ1bmN0aW9uIHYoYSkge1xuICByZXR1cm4gYVtpYV0gfHwgKGFbaWFdID0gKytqYSlcbn1cbnZhciBpYSA9IFwiY2xvc3VyZV91aWRfXCIgKyAoMUU5ICogTWF0aC5yYW5kb20oKSA+Pj4gMCksIGphID0gMDtcbmZ1bmN0aW9uIGthKGEsIGIsIGMpIHtcbiAgcmV0dXJuIGEuY2FsbC5hcHBseShhLmJpbmQsIGFyZ3VtZW50cylcbn1cbmZ1bmN0aW9uIGxhKGEsIGIsIGMpIHtcbiAgaWYoIWEpIHtcbiAgICB0aHJvdyBFcnJvcigpO1xuICB9XG4gIGlmKDIgPCBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdmFyIGQgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIEFycmF5LnByb3RvdHlwZS51bnNoaWZ0LmFwcGx5KGMsIGQpO1xuICAgICAgcmV0dXJuIGEuYXBwbHkoYiwgYylcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhLmFwcGx5KGIsIGFyZ3VtZW50cylcbiAgfVxufVxuZnVuY3Rpb24gdyhhLCBiLCBjKSB7XG4gIHcgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCAmJiAtMSAhPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC50b1N0cmluZygpLmluZGV4T2YoXCJuYXRpdmUgY29kZVwiKSA/IGthIDogbGE7XG4gIHJldHVybiB3LmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbn1cbnZhciB4ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7XG4gIHJldHVybituZXcgRGF0ZVxufTtcbmZ1bmN0aW9uIHkoYSwgYikge1xuICBmdW5jdGlvbiBjKCkge1xuICB9XG4gIGMucHJvdG90eXBlID0gYi5wcm90b3R5cGU7XG4gIGEucmEgPSBiLnByb3RvdHlwZTtcbiAgYS5wcm90b3R5cGUgPSBuZXcgY1xufVxuO2Z1bmN0aW9uIG1hKGEsIGIpIHtcbiAgZm9yKHZhciBjID0gMTtjIDwgYXJndW1lbnRzLmxlbmd0aDtjKyspIHtcbiAgICB2YXIgZCA9IFN0cmluZyhhcmd1bWVudHNbY10pLnJlcGxhY2UoL1xcJC9nLCBcIiQkJCRcIik7XG4gICAgYSA9IGEucmVwbGFjZSgvXFwlcy8sIGQpXG4gIH1cbiAgcmV0dXJuIGFcbn1cbmZ1bmN0aW9uIG5hKGEpIHtcbiAgaWYoIW9hLnRlc3QoYSkpIHtcbiAgICByZXR1cm4gYVxuICB9XG4gIC0xICE9IGEuaW5kZXhPZihcIiZcIikgJiYgKGEgPSBhLnJlcGxhY2UocGEsIFwiJmFtcDtcIikpO1xuICAtMSAhPSBhLmluZGV4T2YoXCI8XCIpICYmIChhID0gYS5yZXBsYWNlKHFhLCBcIiZsdDtcIikpO1xuICAtMSAhPSBhLmluZGV4T2YoXCI+XCIpICYmIChhID0gYS5yZXBsYWNlKHJhLCBcIiZndDtcIikpO1xuICAtMSAhPSBhLmluZGV4T2YoJ1wiJykgJiYgKGEgPSBhLnJlcGxhY2Uoc2EsIFwiJnF1b3Q7XCIpKTtcbiAgcmV0dXJuIGFcbn1cbnZhciBwYSA9IC8mL2csIHFhID0gLzwvZywgcmEgPSAvPi9nLCBzYSA9IC9cXFwiL2csIG9hID0gL1smPD5cXFwiXS87XG52YXIgeiwgdGEsIHVhLCB2YTtcbmZ1bmN0aW9uIHdhKCkge1xuICByZXR1cm4gcS5uYXZpZ2F0b3IgPyBxLm5hdmlnYXRvci51c2VyQWdlbnQgOiBudWxsXG59XG52YSA9IHVhID0gdGEgPSB6ID0gITE7XG52YXIgeGE7XG5pZih4YSA9IHdhKCkpIHtcbiAgdmFyIHlhID0gcS5uYXZpZ2F0b3I7XG4gIHogPSAwID09IHhhLmluZGV4T2YoXCJPcGVyYVwiKTtcbiAgdGEgPSAheiAmJiAtMSAhPSB4YS5pbmRleE9mKFwiTVNJRVwiKTtcbiAgdWEgPSAheiAmJiAtMSAhPSB4YS5pbmRleE9mKFwiV2ViS2l0XCIpO1xuICB2YSA9ICF6ICYmICF1YSAmJiBcIkdlY2tvXCIgPT0geWEucHJvZHVjdFxufVxudmFyIHphID0geiwgQSA9IHRhLCBBYSA9IHZhLCBCID0gdWEsIEJhID0gcS5uYXZpZ2F0b3IsIENhID0gLTEgIT0gKEJhICYmIEJhLnBsYXRmb3JtIHx8IFwiXCIpLmluZGV4T2YoXCJNYWNcIik7XG5mdW5jdGlvbiBEYSgpIHtcbiAgdmFyIGEgPSBxLmRvY3VtZW50O1xuICByZXR1cm4gYSA/IGEuZG9jdW1lbnRNb2RlIDogdm9pZCAwXG59XG52YXIgRWE7XG5hOiB7XG4gIHZhciBGYSA9IFwiXCIsIEdhO1xuICBpZih6YSAmJiBxLm9wZXJhKSB7XG4gICAgdmFyIEhhID0gcS5vcGVyYS52ZXJzaW9uLCBGYSA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgSGEgPyBIYSgpIDogSGFcbiAgfWVsc2Uge1xuICAgIGlmKEFhID8gR2EgPSAvcnZcXDooW15cXCk7XSspKFxcKXw7KS8gOiBBID8gR2EgPSAvTVNJRVxccysoW15cXCk7XSspKFxcKXw7KS8gOiBCICYmIChHYSA9IC9XZWJLaXRcXC8oXFxTKykvKSwgR2EpIHtcbiAgICAgIHZhciBJYSA9IEdhLmV4ZWMod2EoKSksIEZhID0gSWEgPyBJYVsxXSA6IFwiXCJcbiAgICB9XG4gIH1cbiAgaWYoQSkge1xuICAgIHZhciBKYSA9IERhKCk7XG4gICAgaWYoSmEgPiBwYXJzZUZsb2F0KEZhKSkge1xuICAgICAgRWEgPSBTdHJpbmcoSmEpO1xuICAgICAgYnJlYWsgYVxuICAgIH1cbiAgfVxuICBFYSA9IEZhXG59XG52YXIgS2EgPSB7fTtcbmZ1bmN0aW9uIEMoYSkge1xuICB2YXIgYjtcbiAgaWYoIShiID0gS2FbYV0pKSB7XG4gICAgYiA9IDA7XG4gICAgZm9yKHZhciBjID0gU3RyaW5nKEVhKS5yZXBsYWNlKC9eW1xcc1xceGEwXSt8W1xcc1xceGEwXSskL2csIFwiXCIpLnNwbGl0KFwiLlwiKSwgZCA9IFN0cmluZyhhKS5yZXBsYWNlKC9eW1xcc1xceGEwXSt8W1xcc1xceGEwXSskL2csIFwiXCIpLnNwbGl0KFwiLlwiKSwgZiA9IE1hdGgubWF4KGMubGVuZ3RoLCBkLmxlbmd0aCksIGcgPSAwOzAgPT0gYiAmJiBnIDwgZjtnKyspIHtcbiAgICAgIHZhciBoID0gY1tnXSB8fCBcIlwiLCBuID0gZFtnXSB8fCBcIlwiLCBrID0gUmVnRXhwKFwiKFxcXFxkKikoXFxcXEQqKVwiLCBcImdcIiksIHQgPSBSZWdFeHAoXCIoXFxcXGQqKShcXFxcRCopXCIsIFwiZ1wiKTtcbiAgICAgIGRvIHtcbiAgICAgICAgdmFyIGwgPSBrLmV4ZWMoaCkgfHwgW1wiXCIsIFwiXCIsIFwiXCJdLCByID0gdC5leGVjKG4pIHx8IFtcIlwiLCBcIlwiLCBcIlwiXTtcbiAgICAgICAgaWYoMCA9PSBsWzBdLmxlbmd0aCAmJiAwID09IHJbMF0ubGVuZ3RoKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBiID0gKCgwID09IGxbMV0ubGVuZ3RoID8gMCA6IHBhcnNlSW50KGxbMV0sIDEwKSkgPCAoMCA9PSByWzFdLmxlbmd0aCA/IDAgOiBwYXJzZUludChyWzFdLCAxMCkpID8gLTEgOiAoMCA9PSBsWzFdLmxlbmd0aCA/IDAgOiBwYXJzZUludChsWzFdLCAxMCkpID4gKDAgPT0gclsxXS5sZW5ndGggPyAwIDogcGFyc2VJbnQoclsxXSwgMTApKSA/IDEgOiAwKSB8fCAoKDAgPT0gbFsyXS5sZW5ndGgpIDwgKDAgPT0gclsyXS5sZW5ndGgpID8gLTEgOiAoMCA9PSBsWzJdLmxlbmd0aCkgPiAoMCA9PSByWzJdLmxlbmd0aCkgPyAxIDogMCkgfHwgKGxbMl0gPCByWzJdID8gLTEgOiBsWzJdID4gclsyXSA/IDEgOiAwKVxuICAgICAgfXdoaWxlKDAgPT0gYilcbiAgICB9XG4gICAgYiA9IEthW2FdID0gMCA8PSBiXG4gIH1cbiAgcmV0dXJuIGJcbn1cbnZhciBMYSA9IHEuZG9jdW1lbnQsIE1hID0gTGEgJiYgQSA/IERhKCkgfHwgKFwiQ1NTMUNvbXBhdFwiID09IExhLmNvbXBhdE1vZGUgPyBwYXJzZUludChFYSwgMTApIDogNSkgOiB2b2lkIDA7XG5mdW5jdGlvbiBOYShhKSB7XG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID8gRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgTmEpIDogdGhpcy5zdGFjayA9IEVycm9yKCkuc3RhY2sgfHwgXCJcIjtcbiAgYSAmJiAodGhpcy5tZXNzYWdlID0gU3RyaW5nKGEpKVxufVxueShOYSwgRXJyb3IpO1xuTmEucHJvdG90eXBlLm5hbWUgPSBcIkN1c3RvbUVycm9yXCI7XG5mdW5jdGlvbiBPYShhLCBiKSB7XG4gIGIudW5zaGlmdChhKTtcbiAgTmEuY2FsbCh0aGlzLCBtYS5hcHBseShudWxsLCBiKSk7XG4gIGIuc2hpZnQoKTtcbiAgdGhpcy5KYyA9IGFcbn1cbnkoT2EsIE5hKTtcbk9hLnByb3RvdHlwZS5uYW1lID0gXCJBc3NlcnRpb25FcnJvclwiO1xuZnVuY3Rpb24gUGEoYSwgYikge1xuICB0aHJvdyBuZXcgT2EoXCJGYWlsdXJlXCIgKyAoYSA/IFwiOiBcIiArIGEgOiBcIlwiKSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG59XG47dmFyIFFhID0gUmVnRXhwKFwiXig/OihbXjovPyMuXSspOik/KD86Ly8oPzooW14vPyNdKilAKT8oW14vIz9dKj8pKD86OihbMC05XSspKT8oPz1bLyM/XXwkKSk/KFtePyNdKyk/KD86XFxcXD8oW14jXSopKT8oPzojKC4qKSk/JFwiKTtcbmZ1bmN0aW9uIFJhKGEpIHtcbiAgdmFyIGIgPSBTYSwgYztcbiAgZm9yKGMgaW4gYikge1xuICAgIGEuY2FsbCh2b2lkIDAsIGJbY10sIGMsIGIpXG4gIH1cbn1cbmZ1bmN0aW9uIFRhKGEpIHtcbiAgdmFyIGIgPSBbXSwgYyA9IDAsIGQ7XG4gIGZvcihkIGluIGEpIHtcbiAgICBiW2MrK10gPSBhW2RdXG4gIH1cbiAgcmV0dXJuIGJcbn1cbmZ1bmN0aW9uIFVhKGEpIHtcbiAgdmFyIGIgPSBbXSwgYyA9IDAsIGQ7XG4gIGZvcihkIGluIGEpIHtcbiAgICBiW2MrK10gPSBkXG4gIH1cbiAgcmV0dXJuIGJcbn1cbnZhciBWYSA9IFwiY29uc3RydWN0b3IgaGFzT3duUHJvcGVydHkgaXNQcm90b3R5cGVPZiBwcm9wZXJ0eUlzRW51bWVyYWJsZSB0b0xvY2FsZVN0cmluZyB0b1N0cmluZyB2YWx1ZU9mXCIuc3BsaXQoXCIgXCIpO1xuZnVuY3Rpb24gV2EoYSwgYikge1xuICBmb3IodmFyIGMsIGQsIGYgPSAxO2YgPCBhcmd1bWVudHMubGVuZ3RoO2YrKykge1xuICAgIGQgPSBhcmd1bWVudHNbZl07XG4gICAgZm9yKGMgaW4gZCkge1xuICAgICAgYVtjXSA9IGRbY11cbiAgICB9XG4gICAgZm9yKHZhciBnID0gMDtnIDwgVmEubGVuZ3RoO2crKykge1xuICAgICAgYyA9IFZhW2ddLCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZCwgYykgJiYgKGFbY10gPSBkW2NdKVxuICAgIH1cbiAgfVxufVxuO3ZhciBEID0gQXJyYXkucHJvdG90eXBlLCBYYSA9IEQuaW5kZXhPZiA/IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgcmV0dXJuIEQuaW5kZXhPZi5jYWxsKGEsIGIsIGMpXG59IDogZnVuY3Rpb24oYSwgYiwgYykge1xuICBjID0gbnVsbCA9PSBjID8gMCA6IDAgPiBjID8gTWF0aC5tYXgoMCwgYS5sZW5ndGggKyBjKSA6IGM7XG4gIGlmKHUoYSkpIHtcbiAgICByZXR1cm4gdShiKSAmJiAxID09IGIubGVuZ3RoID8gYS5pbmRleE9mKGIsIGMpIDogLTFcbiAgfVxuICBmb3IoO2MgPCBhLmxlbmd0aDtjKyspIHtcbiAgICBpZihjIGluIGEgJiYgYVtjXSA9PT0gYikge1xuICAgICAgcmV0dXJuIGNcbiAgICB9XG4gIH1cbiAgcmV0dXJuLTFcbn0sIFlhID0gRC5mb3JFYWNoID8gZnVuY3Rpb24oYSwgYiwgYykge1xuICBELmZvckVhY2guY2FsbChhLCBiLCBjKVxufSA6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgZm9yKHZhciBkID0gYS5sZW5ndGgsIGYgPSB1KGEpID8gYS5zcGxpdChcIlwiKSA6IGEsIGcgPSAwO2cgPCBkO2crKykge1xuICAgIGcgaW4gZiAmJiBiLmNhbGwoYywgZltnXSwgZywgYSlcbiAgfVxufTtcbmZ1bmN0aW9uIFphKGEpIHtcbiAgcmV0dXJuIEQuY29uY2F0LmFwcGx5KEQsIGFyZ3VtZW50cylcbn1cbmZ1bmN0aW9uICRhKGEpIHtcbiAgdmFyIGIgPSBhLmxlbmd0aDtcbiAgaWYoMCA8IGIpIHtcbiAgICBmb3IodmFyIGMgPSBBcnJheShiKSwgZCA9IDA7ZCA8IGI7ZCsrKSB7XG4gICAgICBjW2RdID0gYVtkXVxuICAgIH1cbiAgICByZXR1cm4gY1xuICB9XG4gIHJldHVybltdXG59XG47ZnVuY3Rpb24gYWIoYSkge1xuICBpZihcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGEuTikge1xuICAgIHJldHVybiBhLk4oKVxuICB9XG4gIGlmKHUoYSkpIHtcbiAgICByZXR1cm4gYS5zcGxpdChcIlwiKVxuICB9XG4gIGlmKGdhKGEpKSB7XG4gICAgZm9yKHZhciBiID0gW10sIGMgPSBhLmxlbmd0aCwgZCA9IDA7ZCA8IGM7ZCsrKSB7XG4gICAgICBiLnB1c2goYVtkXSlcbiAgICB9XG4gICAgcmV0dXJuIGJcbiAgfVxuICByZXR1cm4gVGEoYSlcbn1cbmZ1bmN0aW9uIEUoYSwgYiwgYykge1xuICBpZihcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGEuZm9yRWFjaCkge1xuICAgIGEuZm9yRWFjaChiLCBjKVxuICB9ZWxzZSB7XG4gICAgaWYoZ2EoYSkgfHwgdShhKSkge1xuICAgICAgWWEoYSwgYiwgYylcbiAgICB9ZWxzZSB7XG4gICAgICB2YXIgZDtcbiAgICAgIGlmKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgYS5rYSkge1xuICAgICAgICBkID0gYS5rYSgpXG4gICAgICB9ZWxzZSB7XG4gICAgICAgIGlmKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgYS5OKSB7XG4gICAgICAgICAgaWYoZ2EoYSkgfHwgdShhKSkge1xuICAgICAgICAgICAgZCA9IFtdO1xuICAgICAgICAgICAgZm9yKHZhciBmID0gYS5sZW5ndGgsIGcgPSAwO2cgPCBmO2crKykge1xuICAgICAgICAgICAgICBkLnB1c2goZylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICBkID0gVWEoYSlcbiAgICAgICAgICB9XG4gICAgICAgIH1lbHNlIHtcbiAgICAgICAgICBkID0gdm9pZCAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvcih2YXIgZiA9IGFiKGEpLCBnID0gZi5sZW5ndGgsIGggPSAwO2ggPCBnO2grKykge1xuICAgICAgICBiLmNhbGwoYywgZltoXSwgZCAmJiBkW2hdLCBhKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuO2Z1bmN0aW9uIGJiKGEsIGIpIHtcbiAgdGhpcy5PID0ge307XG4gIHRoaXMuaiA9IFtdO1xuICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIGlmKDEgPCBjKSB7XG4gICAgaWYoYyAlIDIpIHtcbiAgICAgIHRocm93IEVycm9yKFwiVW5ldmVuIG51bWJlciBvZiBhcmd1bWVudHNcIik7XG4gICAgfVxuICAgIGZvcih2YXIgZCA9IDA7ZCA8IGM7ZCArPSAyKSB7XG4gICAgICB0aGlzLnNldChhcmd1bWVudHNbZF0sIGFyZ3VtZW50c1tkICsgMV0pXG4gICAgfVxuICB9ZWxzZSB7XG4gICAgaWYoYSkge1xuICAgICAgYSBpbnN0YW5jZW9mIGJiID8gKGMgPSBhLmthKCksIGQgPSBhLk4oKSkgOiAoYyA9IFVhKGEpLCBkID0gVGEoYSkpO1xuICAgICAgZm9yKHZhciBmID0gMDtmIDwgYy5sZW5ndGg7ZisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGNbZl0sIGRbZl0pXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5wID0gYmIucHJvdG90eXBlO1xucC5mID0gMDtcbnAuYmMgPSAwO1xucC5OID0gZnVuY3Rpb24oKSB7XG4gIGNiKHRoaXMpO1xuICBmb3IodmFyIGEgPSBbXSwgYiA9IDA7YiA8IHRoaXMuai5sZW5ndGg7YisrKSB7XG4gICAgYS5wdXNoKHRoaXMuT1t0aGlzLmpbYl1dKVxuICB9XG4gIHJldHVybiBhXG59O1xucC5rYSA9IGZ1bmN0aW9uKCkge1xuICBjYih0aGlzKTtcbiAgcmV0dXJuIHRoaXMuai5jb25jYXQoKVxufTtcbnAuaWEgPSBmdW5jdGlvbihhKSB7XG4gIHJldHVybiBkYih0aGlzLk8sIGEpXG59O1xucC5yZW1vdmUgPSBmdW5jdGlvbihhKSB7XG4gIHJldHVybiBkYih0aGlzLk8sIGEpID8gKGRlbGV0ZSB0aGlzLk9bYV0sIHRoaXMuZi0tLCB0aGlzLmJjKyssIHRoaXMuai5sZW5ndGggPiAyICogdGhpcy5mICYmIGNiKHRoaXMpLCAhMCkgOiAhMVxufTtcbmZ1bmN0aW9uIGNiKGEpIHtcbiAgaWYoYS5mICE9IGEuai5sZW5ndGgpIHtcbiAgICBmb3IodmFyIGIgPSAwLCBjID0gMDtiIDwgYS5qLmxlbmd0aDspIHtcbiAgICAgIHZhciBkID0gYS5qW2JdO1xuICAgICAgZGIoYS5PLCBkKSAmJiAoYS5qW2MrK10gPSBkKTtcbiAgICAgIGIrK1xuICAgIH1cbiAgICBhLmoubGVuZ3RoID0gY1xuICB9XG4gIGlmKGEuZiAhPSBhLmoubGVuZ3RoKSB7XG4gICAgZm9yKHZhciBmID0ge30sIGMgPSBiID0gMDtiIDwgYS5qLmxlbmd0aDspIHtcbiAgICAgIGQgPSBhLmpbYl0sIGRiKGYsIGQpIHx8IChhLmpbYysrXSA9IGQsIGZbZF0gPSAxKSwgYisrXG4gICAgfVxuICAgIGEuai5sZW5ndGggPSBjXG4gIH1cbn1cbnAuZ2V0ID0gZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gZGIodGhpcy5PLCBhKSA/IHRoaXMuT1thXSA6IGJcbn07XG5wLnNldCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgZGIodGhpcy5PLCBhKSB8fCAodGhpcy5mKyssIHRoaXMuai5wdXNoKGEpLCB0aGlzLmJjKyspO1xuICB0aGlzLk9bYV0gPSBiXG59O1xucC5uID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgYmIodGhpcylcbn07XG5mdW5jdGlvbiBkYihhLCBiKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgYilcbn1cbjtmdW5jdGlvbiBGKGEsIGIpIHtcbiAgdmFyIGM7XG4gIGlmKGEgaW5zdGFuY2VvZiBGKSB7XG4gICAgdGhpcy5EID0gdm9pZCAwICE9PSBiID8gYiA6IGEuRCwgZWIodGhpcywgYS5xYSksIGMgPSBhLmFiLCBIKHRoaXMpLCB0aGlzLmFiID0gYywgZmIodGhpcywgYS5qYSksIGdiKHRoaXMsIGEuQmEpLCBoYih0aGlzLCBhLkgpLCBpYih0aGlzLCBhLlIubigpKSwgYyA9IGEuTWEsIEgodGhpcyksIHRoaXMuTWEgPSBjXG4gIH1lbHNlIHtcbiAgICBpZihhICYmIChjID0gU3RyaW5nKGEpLm1hdGNoKFFhKSkpIHtcbiAgICAgIHRoaXMuRCA9ICEhYjtcbiAgICAgIGViKHRoaXMsIGNbMV0gfHwgXCJcIiwgITApO1xuICAgICAgdmFyIGQgPSBjWzJdIHx8IFwiXCI7XG4gICAgICBIKHRoaXMpO1xuICAgICAgdGhpcy5hYiA9IGQgPyBkZWNvZGVVUklDb21wb25lbnQoZCkgOiBcIlwiO1xuICAgICAgZmIodGhpcywgY1szXSB8fCBcIlwiLCAhMCk7XG4gICAgICBnYih0aGlzLCBjWzRdKTtcbiAgICAgIGhiKHRoaXMsIGNbNV0gfHwgXCJcIiwgITApO1xuICAgICAgaWIodGhpcywgY1s2XSB8fCBcIlwiLCAhMCk7XG4gICAgICBjID0gY1s3XSB8fCBcIlwiO1xuICAgICAgSCh0aGlzKTtcbiAgICAgIHRoaXMuTWEgPSBjID8gZGVjb2RlVVJJQ29tcG9uZW50KGMpIDogXCJcIlxuICAgIH1lbHNlIHtcbiAgICAgIHRoaXMuRCA9ICEhYiwgdGhpcy5SID0gbmV3IGpiKG51bGwsIDAsIHRoaXMuRClcbiAgICB9XG4gIH1cbn1cbnAgPSBGLnByb3RvdHlwZTtcbnAucWEgPSBcIlwiO1xucC5hYiA9IFwiXCI7XG5wLmphID0gXCJcIjtcbnAuQmEgPSBudWxsO1xucC5IID0gXCJcIjtcbnAuTWEgPSBcIlwiO1xucC5tYyA9ICExO1xucC5EID0gITE7XG5wLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhID0gW10sIGIgPSB0aGlzLnFhO1xuICBiICYmIGEucHVzaChrYihiLCBsYiksIFwiOlwiKTtcbiAgaWYoYiA9IHRoaXMuamEpIHtcbiAgICBhLnB1c2goXCIvL1wiKTtcbiAgICB2YXIgYyA9IHRoaXMuYWI7XG4gICAgYyAmJiBhLnB1c2goa2IoYywgbGIpLCBcIkBcIik7XG4gICAgYS5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYikpKTtcbiAgICBiID0gdGhpcy5CYTtcbiAgICBudWxsICE9IGIgJiYgYS5wdXNoKFwiOlwiLCBTdHJpbmcoYikpXG4gIH1cbiAgaWYoYiA9IHRoaXMuSCkge1xuICAgIHRoaXMuamEgJiYgXCIvXCIgIT0gYi5jaGFyQXQoMCkgJiYgYS5wdXNoKFwiL1wiKSwgYS5wdXNoKGtiKGIsIFwiL1wiID09IGIuY2hhckF0KDApID8gbWIgOiBuYikpXG4gIH1cbiAgKGIgPSB0aGlzLlIudG9TdHJpbmcoKSkgJiYgYS5wdXNoKFwiP1wiLCBiKTtcbiAgKGIgPSB0aGlzLk1hKSAmJiBhLnB1c2goXCIjXCIsIGtiKGIsIG9iKSk7XG4gIHJldHVybiBhLmpvaW4oXCJcIilcbn07XG5wLm4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBGKHRoaXMpXG59O1xuZnVuY3Rpb24gZWIoYSwgYiwgYykge1xuICBIKGEpO1xuICBhLnFhID0gYyA/IGIgPyBkZWNvZGVVUklDb21wb25lbnQoYikgOiBcIlwiIDogYjtcbiAgYS5xYSAmJiAoYS5xYSA9IGEucWEucmVwbGFjZSgvOiQvLCBcIlwiKSlcbn1cbmZ1bmN0aW9uIGZiKGEsIGIsIGMpIHtcbiAgSChhKTtcbiAgYS5qYSA9IGMgPyBiID8gZGVjb2RlVVJJQ29tcG9uZW50KGIpIDogXCJcIiA6IGJcbn1cbmZ1bmN0aW9uIGdiKGEsIGIpIHtcbiAgSChhKTtcbiAgaWYoYikge1xuICAgIGIgPSBOdW1iZXIoYik7XG4gICAgaWYoaXNOYU4oYikgfHwgMCA+IGIpIHtcbiAgICAgIHRocm93IEVycm9yKFwiQmFkIHBvcnQgbnVtYmVyIFwiICsgYik7XG4gICAgfVxuICAgIGEuQmEgPSBiXG4gIH1lbHNlIHtcbiAgICBhLkJhID0gbnVsbFxuICB9XG59XG5mdW5jdGlvbiBoYihhLCBiLCBjKSB7XG4gIEgoYSk7XG4gIGEuSCA9IGMgPyBiID8gZGVjb2RlVVJJQ29tcG9uZW50KGIpIDogXCJcIiA6IGJcbn1cbmZ1bmN0aW9uIGliKGEsIGIsIGMpIHtcbiAgSChhKTtcbiAgYiBpbnN0YW5jZW9mIGpiID8gKGEuUiA9IGIsIGEuUi5xYihhLkQpKSA6IChjIHx8IChiID0ga2IoYiwgcGIpKSwgYS5SID0gbmV3IGpiKGIsIDAsIGEuRCkpXG59XG5mdW5jdGlvbiBJKGEsIGIsIGMpIHtcbiAgSChhKTtcbiAgYS5SLnNldChiLCBjKVxufVxuZnVuY3Rpb24gcWIoYSwgYiwgYykge1xuICBIKGEpO1xuICBzKGMpIHx8IChjID0gW1N0cmluZyhjKV0pO1xuICByYihhLlIsIGIsIGMpXG59XG5mdW5jdGlvbiBKKGEpIHtcbiAgSChhKTtcbiAgSShhLCBcInp4XCIsIE1hdGguZmxvb3IoMjE0NzQ4MzY0OCAqIE1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKDM2KSArIE1hdGguYWJzKE1hdGguZmxvb3IoMjE0NzQ4MzY0OCAqIE1hdGgucmFuZG9tKCkpIF4geCgpKS50b1N0cmluZygzNikpO1xuICByZXR1cm4gYVxufVxuZnVuY3Rpb24gSChhKSB7XG4gIGlmKGEubWMpIHtcbiAgICB0aHJvdyBFcnJvcihcIlRyaWVkIHRvIG1vZGlmeSBhIHJlYWQtb25seSBVcmlcIik7XG4gIH1cbn1cbnAucWIgPSBmdW5jdGlvbihhKSB7XG4gIHRoaXMuRCA9IGE7XG4gIHRoaXMuUiAmJiB0aGlzLlIucWIoYSk7XG4gIHJldHVybiB0aGlzXG59O1xuZnVuY3Rpb24gc2IoYSwgYiwgYywgZCkge1xuICB2YXIgZiA9IG5ldyBGKG51bGwsIHZvaWQgMCk7XG4gIGEgJiYgZWIoZiwgYSk7XG4gIGIgJiYgZmIoZiwgYik7XG4gIGMgJiYgZ2IoZiwgYyk7XG4gIGQgJiYgaGIoZiwgZCk7XG4gIHJldHVybiBmXG59XG5mdW5jdGlvbiBrYihhLCBiKSB7XG4gIHJldHVybiB1KGEpID8gZW5jb2RlVVJJKGEpLnJlcGxhY2UoYiwgdGIpIDogbnVsbFxufVxuZnVuY3Rpb24gdGIoYSkge1xuICBhID0gYS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm5cIiVcIiArIChhID4+IDQgJiAxNSkudG9TdHJpbmcoMTYpICsgKGEgJiAxNSkudG9TdHJpbmcoMTYpXG59XG52YXIgbGIgPSAvWyNcXC9cXD9AXS9nLCBuYiA9IC9bXFwjXFw/Ol0vZywgbWIgPSAvW1xcI1xcP10vZywgcGIgPSAvW1xcI1xcP0BdL2csIG9iID0gLyMvZztcbmZ1bmN0aW9uIGpiKGEsIGIsIGMpIHtcbiAgdGhpcy5DID0gYSB8fCBudWxsO1xuICB0aGlzLkQgPSAhIWNcbn1cbmZ1bmN0aW9uIEsoYSkge1xuICBpZighYS5pICYmIChhLmkgPSBuZXcgYmIsIGEuZiA9IDAsIGEuQykpIHtcbiAgICBmb3IodmFyIGIgPSBhLkMuc3BsaXQoXCImXCIpLCBjID0gMDtjIDwgYi5sZW5ndGg7YysrKSB7XG4gICAgICB2YXIgZCA9IGJbY10uaW5kZXhPZihcIj1cIiksIGYgPSBudWxsLCBnID0gbnVsbDtcbiAgICAgIDAgPD0gZCA/IChmID0gYltjXS5zdWJzdHJpbmcoMCwgZCksIGcgPSBiW2NdLnN1YnN0cmluZyhkICsgMSkpIDogZiA9IGJbY107XG4gICAgICBmID0gZGVjb2RlVVJJQ29tcG9uZW50KGYucmVwbGFjZSgvXFwrL2csIFwiIFwiKSk7XG4gICAgICBmID0gTChhLCBmKTtcbiAgICAgIGEuYWRkKGYsIGcgPyBkZWNvZGVVUklDb21wb25lbnQoZy5yZXBsYWNlKC9cXCsvZywgXCIgXCIpKSA6IFwiXCIpXG4gICAgfVxuICB9XG59XG5wID0gamIucHJvdG90eXBlO1xucC5pID0gbnVsbDtcbnAuZiA9IG51bGw7XG5wLmFkZCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgSyh0aGlzKTtcbiAgdGhpcy5DID0gbnVsbDtcbiAgYSA9IEwodGhpcywgYSk7XG4gIHZhciBjID0gdGhpcy5pLmdldChhKTtcbiAgYyB8fCB0aGlzLmkuc2V0KGEsIGMgPSBbXSk7XG4gIGMucHVzaChiKTtcbiAgdGhpcy5mKys7XG4gIHJldHVybiB0aGlzXG59O1xucC5yZW1vdmUgPSBmdW5jdGlvbihhKSB7XG4gIEsodGhpcyk7XG4gIGEgPSBMKHRoaXMsIGEpO1xuICByZXR1cm4gdGhpcy5pLmlhKGEpID8gKHRoaXMuQyA9IG51bGwsIHRoaXMuZiAtPSB0aGlzLmkuZ2V0KGEpLmxlbmd0aCwgdGhpcy5pLnJlbW92ZShhKSkgOiAhMVxufTtcbnAuaWEgPSBmdW5jdGlvbihhKSB7XG4gIEsodGhpcyk7XG4gIGEgPSBMKHRoaXMsIGEpO1xuICByZXR1cm4gdGhpcy5pLmlhKGEpXG59O1xucC5rYSA9IGZ1bmN0aW9uKCkge1xuICBLKHRoaXMpO1xuICBmb3IodmFyIGEgPSB0aGlzLmkuTigpLCBiID0gdGhpcy5pLmthKCksIGMgPSBbXSwgZCA9IDA7ZCA8IGIubGVuZ3RoO2QrKykge1xuICAgIGZvcih2YXIgZiA9IGFbZF0sIGcgPSAwO2cgPCBmLmxlbmd0aDtnKyspIHtcbiAgICAgIGMucHVzaChiW2RdKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY1xufTtcbnAuTiA9IGZ1bmN0aW9uKGEpIHtcbiAgSyh0aGlzKTtcbiAgdmFyIGIgPSBbXTtcbiAgaWYoYSkge1xuICAgIHRoaXMuaWEoYSkgJiYgKGIgPSBaYShiLCB0aGlzLmkuZ2V0KEwodGhpcywgYSkpKSlcbiAgfWVsc2Uge1xuICAgIGEgPSB0aGlzLmkuTigpO1xuICAgIGZvcih2YXIgYyA9IDA7YyA8IGEubGVuZ3RoO2MrKykge1xuICAgICAgYiA9IFphKGIsIGFbY10pXG4gICAgfVxuICB9XG4gIHJldHVybiBiXG59O1xucC5zZXQgPSBmdW5jdGlvbihhLCBiKSB7XG4gIEsodGhpcyk7XG4gIHRoaXMuQyA9IG51bGw7XG4gIGEgPSBMKHRoaXMsIGEpO1xuICB0aGlzLmlhKGEpICYmICh0aGlzLmYgLT0gdGhpcy5pLmdldChhKS5sZW5ndGgpO1xuICB0aGlzLmkuc2V0KGEsIFtiXSk7XG4gIHRoaXMuZisrO1xuICByZXR1cm4gdGhpc1xufTtcbnAuZ2V0ID0gZnVuY3Rpb24oYSwgYikge1xuICB2YXIgYyA9IGEgPyB0aGlzLk4oYSkgOiBbXTtcbiAgcmV0dXJuIDAgPCBjLmxlbmd0aCA/IFN0cmluZyhjWzBdKSA6IGJcbn07XG5mdW5jdGlvbiByYihhLCBiLCBjKSB7XG4gIGEucmVtb3ZlKGIpO1xuICAwIDwgYy5sZW5ndGggJiYgKGEuQyA9IG51bGwsIGEuaS5zZXQoTChhLCBiKSwgJGEoYykpLCBhLmYgKz0gYy5sZW5ndGgpXG59XG5wLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIGlmKHRoaXMuQykge1xuICAgIHJldHVybiB0aGlzLkNcbiAgfVxuICBpZighdGhpcy5pKSB7XG4gICAgcmV0dXJuXCJcIlxuICB9XG4gIGZvcih2YXIgYSA9IFtdLCBiID0gdGhpcy5pLmthKCksIGMgPSAwO2MgPCBiLmxlbmd0aDtjKyspIHtcbiAgICBmb3IodmFyIGQgPSBiW2NdLCBmID0gZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhkKSksIGQgPSB0aGlzLk4oZCksIGcgPSAwO2cgPCBkLmxlbmd0aDtnKyspIHtcbiAgICAgIHZhciBoID0gZjtcbiAgICAgIFwiXCIgIT09IGRbZ10gJiYgKGggKz0gXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGRbZ10pKSk7XG4gICAgICBhLnB1c2goaClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXMuQyA9IGEuam9pbihcIiZcIilcbn07XG5wLm4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGEgPSBuZXcgamI7XG4gIGEuQyA9IHRoaXMuQztcbiAgdGhpcy5pICYmIChhLmkgPSB0aGlzLmkubigpLCBhLmYgPSB0aGlzLmYpO1xuICByZXR1cm4gYVxufTtcbmZ1bmN0aW9uIEwoYSwgYikge1xuICB2YXIgYyA9IFN0cmluZyhiKTtcbiAgYS5EICYmIChjID0gYy50b0xvd2VyQ2FzZSgpKTtcbiAgcmV0dXJuIGNcbn1cbnAucWIgPSBmdW5jdGlvbihhKSB7XG4gIGEgJiYgIXRoaXMuRCAmJiAoSyh0aGlzKSwgdGhpcy5DID0gbnVsbCwgRSh0aGlzLmksIGZ1bmN0aW9uKGEsIGMpIHtcbiAgICB2YXIgZCA9IGMudG9Mb3dlckNhc2UoKTtcbiAgICBjICE9IGQgJiYgKHRoaXMucmVtb3ZlKGMpLCByYih0aGlzLCBkLCBhKSlcbiAgfSwgdGhpcykpO1xuICB0aGlzLkQgPSBhXG59O1xuZnVuY3Rpb24gdWIoKSB7XG59XG51Yi5wcm90b3R5cGUuR2EgPSBudWxsO1xudmFyIHZiO1xuZnVuY3Rpb24gd2IoKSB7XG59XG55KHdiLCB1Yik7XG5mdW5jdGlvbiB4YihhKSB7XG4gIHJldHVybihhID0geWIoYSkpID8gbmV3IEFjdGl2ZVhPYmplY3QoYSkgOiBuZXcgWE1MSHR0cFJlcXVlc3Rcbn1cbmZ1bmN0aW9uIHpiKGEpIHtcbiAgdmFyIGIgPSB7fTtcbiAgeWIoYSkgJiYgKGJbMF0gPSAhMCwgYlsxXSA9ICEwKTtcbiAgcmV0dXJuIGJcbn1cbmZ1bmN0aW9uIHliKGEpIHtcbiAgaWYoIWEuR2IgJiYgXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgJiYgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgQWN0aXZlWE9iamVjdCkge1xuICAgIGZvcih2YXIgYiA9IFtcIk1TWE1MMi5YTUxIVFRQLjYuMFwiLCBcIk1TWE1MMi5YTUxIVFRQLjMuMFwiLCBcIk1TWE1MMi5YTUxIVFRQXCIsIFwiTWljcm9zb2Z0LlhNTEhUVFBcIl0sIGMgPSAwO2MgPCBiLmxlbmd0aDtjKyspIHtcbiAgICAgIHZhciBkID0gYltjXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdChkKSwgYS5HYiA9IGRcbiAgICAgIH1jYXRjaChmKSB7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IEVycm9yKFwiQ291bGQgbm90IGNyZWF0ZSBBY3RpdmVYT2JqZWN0LiBBY3RpdmVYIG1pZ2h0IGJlIGRpc2FibGVkLCBvciBNU1hNTCBtaWdodCBub3QgYmUgaW5zdGFsbGVkXCIpO1xuICB9XG4gIHJldHVybiBhLkdiXG59XG52YiA9IG5ldyB3YjtcbmZ1bmN0aW9uIE0oKSB7XG4gIDAgIT0gQWIgJiYgKHRoaXMuR2MgPSBFcnJvcigpLnN0YWNrLCBCYlt2KHRoaXMpXSA9IHRoaXMpXG59XG52YXIgQWIgPSAwLCBCYiA9IHt9O1xuTS5wcm90b3R5cGUueWIgPSAhMTtcbk0ucHJvdG90eXBlLklhID0gZnVuY3Rpb24oKSB7XG4gIGlmKCF0aGlzLnliICYmICh0aGlzLnliID0gITAsIHRoaXMudSgpLCAwICE9IEFiKSkge1xuICAgIHZhciBhID0gdih0aGlzKTtcbiAgICBkZWxldGUgQmJbYV1cbiAgfVxufTtcbk0ucHJvdG90eXBlLnUgPSBmdW5jdGlvbigpIHtcbiAgaWYodGhpcy5OYikge1xuICAgIGZvcig7dGhpcy5OYi5sZW5ndGg7KSB7XG4gICAgICB0aGlzLk5iLnNoaWZ0KCkoKVxuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIE4oYSwgYikge1xuICB0aGlzLnR5cGUgPSBhO1xuICB0aGlzLmN1cnJlbnRUYXJnZXQgPSB0aGlzLnRhcmdldCA9IGJcbn1cbnAgPSBOLnByb3RvdHlwZTtcbnAudSA9IGUoKTtcbnAuSWEgPSBlKCk7XG5wLm5hID0gITE7XG5wLmRlZmF1bHRQcmV2ZW50ZWQgPSAhMTtcbnAuV2EgPSAhMDtcbnAucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gITA7XG4gIHRoaXMuV2EgPSAhMVxufTtcbnZhciBDYiA9IDA7XG5mdW5jdGlvbiBEYigpIHtcbn1cbnAgPSBEYi5wcm90b3R5cGU7XG5wLmtleSA9IDA7XG5wLmVhID0gITE7XG5wLkhhID0gITE7XG5wLk9hID0gZnVuY3Rpb24oYSwgYiwgYywgZCwgZiwgZykge1xuICBpZihoYShhKSkge1xuICAgIHRoaXMuSWIgPSAhMFxuICB9ZWxzZSB7XG4gICAgaWYoYSAmJiBhLmhhbmRsZUV2ZW50ICYmIGhhKGEuaGFuZGxlRXZlbnQpKSB7XG4gICAgICB0aGlzLkliID0gITFcbiAgICB9ZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgbGlzdGVuZXIgYXJndW1lbnRcIik7XG4gICAgfVxuICB9XG4gIHRoaXMuVyA9IGE7XG4gIHRoaXMuVWIgPSBiO1xuICB0aGlzLnNyYyA9IGM7XG4gIHRoaXMudHlwZSA9IGQ7XG4gIHRoaXMuY2FwdHVyZSA9ICEhZjtcbiAgdGhpcy5sYiA9IGc7XG4gIHRoaXMuSGEgPSAhMTtcbiAgdGhpcy5rZXkgPSArK0NiO1xuICB0aGlzLmVhID0gITFcbn07XG5wLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24oYSkge1xuICByZXR1cm4gdGhpcy5JYiA/IHRoaXMuVy5jYWxsKHRoaXMubGIgfHwgdGhpcy5zcmMsIGEpIDogdGhpcy5XLmhhbmRsZUV2ZW50LmNhbGwodGhpcy5XLCBhKVxufTtcbnZhciBFYiA9ICFBIHx8IEEgJiYgOSA8PSBNYSwgRmIgPSBBICYmICFDKFwiOVwiKTtcbiFCIHx8IEMoXCI1MjhcIik7XG5BYSAmJiBDKFwiMS45YlwiKSB8fCBBICYmIEMoXCI4XCIpIHx8IHphICYmIEMoXCI5LjVcIikgfHwgQiAmJiBDKFwiNTI4XCIpO1xuQWEgJiYgIUMoXCI4XCIpIHx8IEEgJiYgQyhcIjlcIik7XG5mdW5jdGlvbiBHYihhKSB7XG4gIEdiW1wiIFwiXShhKTtcbiAgcmV0dXJuIGFcbn1cbkdiW1wiIFwiXSA9IGVhO1xuZnVuY3Rpb24gSGIoYSwgYikge1xuICBhICYmIHRoaXMuT2EoYSwgYilcbn1cbnkoSGIsIE4pO1xucCA9IEhiLnByb3RvdHlwZTtcbnAudGFyZ2V0ID0gbnVsbDtcbnAucmVsYXRlZFRhcmdldCA9IG51bGw7XG5wLm9mZnNldFggPSAwO1xucC5vZmZzZXRZID0gMDtcbnAuY2xpZW50WCA9IDA7XG5wLmNsaWVudFkgPSAwO1xucC5zY3JlZW5YID0gMDtcbnAuc2NyZWVuWSA9IDA7XG5wLmJ1dHRvbiA9IDA7XG5wLmtleUNvZGUgPSAwO1xucC5jaGFyQ29kZSA9IDA7XG5wLmN0cmxLZXkgPSAhMTtcbnAuYWx0S2V5ID0gITE7XG5wLnNoaWZ0S2V5ID0gITE7XG5wLm1ldGFLZXkgPSAhMTtcbnAueWMgPSAhMTtcbnAuemIgPSBudWxsO1xucC5PYSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGMgPSB0aGlzLnR5cGUgPSBhLnR5cGU7XG4gIE4uY2FsbCh0aGlzLCBjKTtcbiAgdGhpcy50YXJnZXQgPSBhLnRhcmdldCB8fCBhLnNyY0VsZW1lbnQ7XG4gIHRoaXMuY3VycmVudFRhcmdldCA9IGI7XG4gIHZhciBkID0gYS5yZWxhdGVkVGFyZ2V0O1xuICBpZihkKSB7XG4gICAgaWYoQWEpIHtcbiAgICAgIHZhciBmO1xuICAgICAgYToge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEdiKGQubm9kZU5hbWUpO1xuICAgICAgICAgIGYgPSAhMDtcbiAgICAgICAgICBicmVhayBhXG4gICAgICAgIH1jYXRjaChnKSB7XG4gICAgICAgIH1cbiAgICAgICAgZiA9ICExXG4gICAgICB9XG4gICAgICBmIHx8IChkID0gbnVsbClcbiAgICB9XG4gIH1lbHNlIHtcbiAgICBcIm1vdXNlb3ZlclwiID09IGMgPyBkID0gYS5mcm9tRWxlbWVudCA6IFwibW91c2VvdXRcIiA9PSBjICYmIChkID0gYS50b0VsZW1lbnQpXG4gIH1cbiAgdGhpcy5yZWxhdGVkVGFyZ2V0ID0gZDtcbiAgdGhpcy5vZmZzZXRYID0gQiB8fCB2b2lkIDAgIT09IGEub2Zmc2V0WCA/IGEub2Zmc2V0WCA6IGEubGF5ZXJYO1xuICB0aGlzLm9mZnNldFkgPSBCIHx8IHZvaWQgMCAhPT0gYS5vZmZzZXRZID8gYS5vZmZzZXRZIDogYS5sYXllclk7XG4gIHRoaXMuY2xpZW50WCA9IHZvaWQgMCAhPT0gYS5jbGllbnRYID8gYS5jbGllbnRYIDogYS5wYWdlWDtcbiAgdGhpcy5jbGllbnRZID0gdm9pZCAwICE9PSBhLmNsaWVudFkgPyBhLmNsaWVudFkgOiBhLnBhZ2VZO1xuICB0aGlzLnNjcmVlblggPSBhLnNjcmVlblggfHwgMDtcbiAgdGhpcy5zY3JlZW5ZID0gYS5zY3JlZW5ZIHx8IDA7XG4gIHRoaXMuYnV0dG9uID0gYS5idXR0b247XG4gIHRoaXMua2V5Q29kZSA9IGEua2V5Q29kZSB8fCAwO1xuICB0aGlzLmNoYXJDb2RlID0gYS5jaGFyQ29kZSB8fCAoXCJrZXlwcmVzc1wiID09IGMgPyBhLmtleUNvZGUgOiAwKTtcbiAgdGhpcy5jdHJsS2V5ID0gYS5jdHJsS2V5O1xuICB0aGlzLmFsdEtleSA9IGEuYWx0S2V5O1xuICB0aGlzLnNoaWZ0S2V5ID0gYS5zaGlmdEtleTtcbiAgdGhpcy5tZXRhS2V5ID0gYS5tZXRhS2V5O1xuICB0aGlzLnljID0gQ2EgPyBhLm1ldGFLZXkgOiBhLmN0cmxLZXk7XG4gIHRoaXMuc3RhdGUgPSBhLnN0YXRlO1xuICB0aGlzLnpiID0gYTtcbiAgYS5kZWZhdWx0UHJldmVudGVkICYmIHRoaXMucHJldmVudERlZmF1bHQoKTtcbiAgZGVsZXRlIHRoaXMubmFcbn07XG5wLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gIEhiLnJhLnByZXZlbnREZWZhdWx0LmNhbGwodGhpcyk7XG4gIHZhciBhID0gdGhpcy56YjtcbiAgaWYoYS5wcmV2ZW50RGVmYXVsdCkge1xuICAgIGEucHJldmVudERlZmF1bHQoKVxuICB9ZWxzZSB7XG4gICAgaWYoYS5yZXR1cm5WYWx1ZSA9ICExLCBGYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYoYS5jdHJsS2V5IHx8IDExMiA8PSBhLmtleUNvZGUgJiYgMTIzID49IGEua2V5Q29kZSkge1xuICAgICAgICAgIGEua2V5Q29kZSA9IC0xXG4gICAgICAgIH1cbiAgICAgIH1jYXRjaChiKSB7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xucC51ID0gZSgpO1xudmFyIFNhID0ge30sIE8gPSB7fSwgUCA9IHt9LCBJYiA9IHt9O1xuZnVuY3Rpb24gSmIoYSwgYiwgYywgZCwgZikge1xuICBpZihzKGIpKSB7XG4gICAgZm9yKHZhciBnID0gMDtnIDwgYi5sZW5ndGg7ZysrKSB7XG4gICAgICBKYihhLCBiW2ddLCBjLCBkLCBmKVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGE6IHtcbiAgICBpZighYikge1xuICAgICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIGV2ZW50IHR5cGVcIik7XG4gICAgfVxuICAgIGQgPSAhIWQ7XG4gICAgdmFyIGggPSBPO1xuICAgIGIgaW4gaCB8fCAoaFtiXSA9IHtmOjAsIHQ6MH0pO1xuICAgIGggPSBoW2JdO1xuICAgIGQgaW4gaCB8fCAoaFtkXSA9IHtmOjAsIHQ6MH0sIGguZisrKTtcbiAgICB2YXIgaCA9IGhbZF0sIGcgPSB2KGEpLCBuO1xuICAgIGgudCsrO1xuICAgIGlmKGhbZ10pIHtcbiAgICAgIG4gPSBoW2ddO1xuICAgICAgZm9yKHZhciBrID0gMDtrIDwgbi5sZW5ndGg7aysrKSB7XG4gICAgICAgIGlmKGggPSBuW2tdLCBoLlcgPT0gYyAmJiBoLmxiID09IGYpIHtcbiAgICAgICAgICBpZihoLmVhKSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBuW2tdLkhhID0gITE7XG4gICAgICAgICAgYSA9IG5ba107XG4gICAgICAgICAgYnJlYWsgYVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfWVsc2Uge1xuICAgICAgbiA9IGhbZ10gPSBbXSwgaC5mKytcbiAgICB9XG4gICAgayA9IEtiKCk7XG4gICAgaCA9IG5ldyBEYjtcbiAgICBoLk9hKGMsIGssIGEsIGIsIGQsIGYpO1xuICAgIGguSGEgPSAhMTtcbiAgICBrLnNyYyA9IGE7XG4gICAgay5XID0gaDtcbiAgICBuLnB1c2goaCk7XG4gICAgUFtnXSB8fCAoUFtnXSA9IFtdKTtcbiAgICBQW2ddLnB1c2goaCk7XG4gICAgYS5hZGRFdmVudExpc3RlbmVyID8gYSAhPSBxICYmIGEud2IgfHwgYS5hZGRFdmVudExpc3RlbmVyKGIsIGssIGQpIDogYS5hdHRhY2hFdmVudChiIGluIEliID8gSWJbYl0gOiBJYltiXSA9IFwib25cIiArIGIsIGspO1xuICAgIGEgPSBoXG4gIH1cbiAgYiA9IGEua2V5O1xuICBTYVtiXSA9IGE7XG4gIHJldHVybiBiXG59XG5mdW5jdGlvbiBLYigpIHtcbiAgdmFyIGEgPSBMYiwgYiA9IEViID8gZnVuY3Rpb24oYykge1xuICAgIHJldHVybiBhLmNhbGwoYi5zcmMsIGIuVywgYylcbiAgfSA6IGZ1bmN0aW9uKGMpIHtcbiAgICBjID0gYS5jYWxsKGIuc3JjLCBiLlcsIGMpO1xuICAgIGlmKCFjKSB7XG4gICAgICByZXR1cm4gY1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGJcbn1cbmZ1bmN0aW9uIE1iKGEsIGIsIGMsIGQsIGYpIHtcbiAgaWYocyhiKSkge1xuICAgIGZvcih2YXIgZyA9IDA7ZyA8IGIubGVuZ3RoO2crKykge1xuICAgICAgTWIoYSwgYltnXSwgYywgZCwgZilcbiAgICB9XG4gIH1lbHNlIHtcbiAgICBkID0gISFkO1xuICAgIGE6IHtcbiAgICAgIGcgPSBPO1xuICAgICAgaWYoYiBpbiBnICYmIChnID0gZ1tiXSwgZCBpbiBnICYmIChnID0gZ1tkXSwgYSA9IHYoYSksIGdbYV0pKSkge1xuICAgICAgICBhID0gZ1thXTtcbiAgICAgICAgYnJlYWsgYVxuICAgICAgfVxuICAgICAgYSA9IG51bGxcbiAgICB9XG4gICAgaWYoYSkge1xuICAgICAgZm9yKGcgPSAwO2cgPCBhLmxlbmd0aDtnKyspIHtcbiAgICAgICAgaWYoYVtnXS5XID09IGMgJiYgYVtnXS5jYXB0dXJlID09IGQgJiYgYVtnXS5sYiA9PSBmKSB7XG4gICAgICAgICAgTmIoYVtnXS5rZXkpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIE5iKGEpIHtcbiAgdmFyIGIgPSBTYVthXTtcbiAgaWYoIWIgfHwgYi5lYSkge1xuICAgIHJldHVybiExXG4gIH1cbiAgdmFyIGMgPSBiLnNyYywgZCA9IGIudHlwZSwgZiA9IGIuVWIsIGcgPSBiLmNhcHR1cmU7XG4gIGMucmVtb3ZlRXZlbnRMaXN0ZW5lciA/IGMgIT0gcSAmJiBjLndiIHx8IGMucmVtb3ZlRXZlbnRMaXN0ZW5lcihkLCBmLCBnKSA6IGMuZGV0YWNoRXZlbnQgJiYgYy5kZXRhY2hFdmVudChkIGluIEliID8gSWJbZF0gOiBJYltkXSA9IFwib25cIiArIGQsIGYpO1xuICBjID0gdihjKTtcbiAgaWYoUFtjXSkge1xuICAgIHZhciBmID0gUFtjXSwgaCA9IFhhKGYsIGIpO1xuICAgIDAgPD0gaCAmJiBELnNwbGljZS5jYWxsKGYsIGgsIDEpO1xuICAgIDAgPT0gZi5sZW5ndGggJiYgZGVsZXRlIFBbY11cbiAgfVxuICBiLmVhID0gITA7XG4gIGlmKGIgPSBPW2RdW2ddW2NdKSB7XG4gICAgYi5NYiA9ICEwLCBPYihkLCBnLCBjLCBiKVxuICB9XG4gIGRlbGV0ZSBTYVthXTtcbiAgcmV0dXJuITBcbn1cbmZ1bmN0aW9uIE9iKGEsIGIsIGMsIGQpIHtcbiAgaWYoIWQuUWEgJiYgZC5NYikge1xuICAgIGZvcih2YXIgZiA9IDAsIGcgPSAwO2YgPCBkLmxlbmd0aDtmKyspIHtcbiAgICAgIGRbZl0uZWEgPyBkW2ZdLlViLnNyYyA9IG51bGwgOiAoZiAhPSBnICYmIChkW2ddID0gZFtmXSksIGcrKylcbiAgICB9XG4gICAgZC5sZW5ndGggPSBnO1xuICAgIGQuTWIgPSAhMTtcbiAgICAwID09IGcgJiYgKGRlbGV0ZSBPW2FdW2JdW2NdLCBPW2FdW2JdLmYtLSwgMCA9PSBPW2FdW2JdLmYgJiYgKGRlbGV0ZSBPW2FdW2JdLCBPW2FdLmYtLSksIDAgPT0gT1thXS5mICYmIGRlbGV0ZSBPW2FdKVxuICB9XG59XG5mdW5jdGlvbiBQYihhKSB7XG4gIHZhciBiID0gMDtcbiAgaWYobnVsbCAhPSBhKSB7XG4gICAgaWYoYSA9IHYoYSksIFBbYV0pIHtcbiAgICAgIGEgPSBQW2FdO1xuICAgICAgZm9yKHZhciBjID0gYS5sZW5ndGggLSAxOzAgPD0gYztjLS0pIHtcbiAgICAgICAgTmIoYVtjXS5rZXkpLCBiKytcbiAgICAgIH1cbiAgICB9XG4gIH1lbHNlIHtcbiAgICBSYShmdW5jdGlvbihhLCBjKSB7XG4gICAgICBOYihjKTtcbiAgICAgIGIrK1xuICAgIH0pXG4gIH1cbn1cbmZ1bmN0aW9uIFFiKGEsIGIsIGMsIGQsIGYpIHtcbiAgdmFyIGcgPSAxO1xuICBiID0gdihiKTtcbiAgaWYoYVtiXSkge1xuICAgIHZhciBoID0gLS1hLnQsIG4gPSBhW2JdO1xuICAgIG4uUWEgPyBuLlFhKysgOiBuLlFhID0gMTtcbiAgICB0cnkge1xuICAgICAgZm9yKHZhciBrID0gbi5sZW5ndGgsIHQgPSAwO3QgPCBrO3QrKykge1xuICAgICAgICB2YXIgbCA9IG5bdF07XG4gICAgICAgIGwgJiYgIWwuZWEgJiYgKGcgJj0gITEgIT09IFJiKGwsIGYpKVxuICAgICAgfVxuICAgIH1maW5hbGx5IHtcbiAgICAgIGEudCA9IE1hdGgubWF4KGgsIGEudCksIG4uUWEtLSwgT2IoYywgZCwgYiwgbilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEJvb2xlYW4oZylcbn1cbmZ1bmN0aW9uIFJiKGEsIGIpIHtcbiAgYS5IYSAmJiBOYihhLmtleSk7XG4gIHJldHVybiBhLmhhbmRsZUV2ZW50KGIpXG59XG5mdW5jdGlvbiBMYihhLCBiKSB7XG4gIGlmKGEuZWEpIHtcbiAgICByZXR1cm4hMFxuICB9XG4gIHZhciBjID0gYS50eXBlLCBkID0gTztcbiAgaWYoIShjIGluIGQpKSB7XG4gICAgcmV0dXJuITBcbiAgfVxuICB2YXIgZCA9IGRbY10sIGYsIGc7XG4gIGlmKCFFYikge1xuICAgIGYgPSBiIHx8IGRhKFwid2luZG93LmV2ZW50XCIpO1xuICAgIHZhciBoID0gITAgaW4gZCwgbiA9ICExIGluIGQ7XG4gICAgaWYoaCkge1xuICAgICAgaWYoMCA+IGYua2V5Q29kZSB8fCB2b2lkIDAgIT0gZi5yZXR1cm5WYWx1ZSkge1xuICAgICAgICByZXR1cm4hMFxuICAgICAgfVxuICAgICAgYToge1xuICAgICAgICB2YXIgayA9ICExO1xuICAgICAgICBpZigwID09IGYua2V5Q29kZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmLmtleUNvZGUgPSAtMTtcbiAgICAgICAgICAgIGJyZWFrIGFcbiAgICAgICAgICB9Y2F0Y2godCkge1xuICAgICAgICAgICAgayA9ICEwXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKGsgfHwgdm9pZCAwID09IGYucmV0dXJuVmFsdWUpIHtcbiAgICAgICAgICBmLnJldHVyblZhbHVlID0gITBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBrID0gbmV3IEhiO1xuICAgIGsuT2EoZiwgdGhpcyk7XG4gICAgZiA9ICEwO1xuICAgIHRyeSB7XG4gICAgICBpZihoKSB7XG4gICAgICAgIGZvcih2YXIgbCA9IFtdLCByID0gay5jdXJyZW50VGFyZ2V0O3I7ciA9IHIucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGwucHVzaChyKVxuICAgICAgICB9XG4gICAgICAgIGcgPSBkWyEwXTtcbiAgICAgICAgZy50ID0gZy5mO1xuICAgICAgICBmb3IodmFyIEcgPSBsLmxlbmd0aCAtIDE7IWsubmEgJiYgMCA8PSBHICYmIGcudDtHLS0pIHtcbiAgICAgICAgICBrLmN1cnJlbnRUYXJnZXQgPSBsW0ddLCBmICY9IFFiKGcsIGxbR10sIGMsICEwLCBrKVxuICAgICAgICB9XG4gICAgICAgIGlmKG4pIHtcbiAgICAgICAgICBmb3IoZyA9IGRbITFdLCBnLnQgPSBnLmYsIEcgPSAwOyFrLm5hICYmIEcgPCBsLmxlbmd0aCAmJiBnLnQ7RysrKSB7XG4gICAgICAgICAgICBrLmN1cnJlbnRUYXJnZXQgPSBsW0ddLCBmICY9IFFiKGcsIGxbR10sIGMsICExLCBrKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfWVsc2Uge1xuICAgICAgICBmID0gUmIoYSwgaylcbiAgICAgIH1cbiAgICB9ZmluYWxseSB7XG4gICAgICBsICYmIChsLmxlbmd0aCA9IDApXG4gICAgfVxuICAgIHJldHVybiBmXG4gIH1cbiAgYyA9IG5ldyBIYihiLCB0aGlzKTtcbiAgcmV0dXJuIGYgPSBSYihhLCBjKVxufVxuO2Z1bmN0aW9uIFNiKCkge1xuICBNLmNhbGwodGhpcylcbn1cbnkoU2IsIE0pO1xucCA9IFNiLnByb3RvdHlwZTtcbnAud2IgPSAhMDtcbnAucGIgPSBudWxsO1xucC5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oYSwgYiwgYywgZCkge1xuICBKYih0aGlzLCBhLCBiLCBjLCBkKVxufTtcbnAucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQpIHtcbiAgTWIodGhpcywgYSwgYiwgYywgZClcbn07XG5wLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihhKSB7XG4gIHZhciBiID0gYS50eXBlIHx8IGEsIGMgPSBPO1xuICBpZihiIGluIGMpIHtcbiAgICBpZih1KGEpKSB7XG4gICAgICBhID0gbmV3IE4oYSwgdGhpcylcbiAgICB9ZWxzZSB7XG4gICAgICBpZihhIGluc3RhbmNlb2YgTikge1xuICAgICAgICBhLnRhcmdldCA9IGEudGFyZ2V0IHx8IHRoaXNcbiAgICAgIH1lbHNlIHtcbiAgICAgICAgdmFyIGQgPSBhO1xuICAgICAgICBhID0gbmV3IE4oYiwgdGhpcyk7XG4gICAgICAgIFdhKGEsIGQpXG4gICAgICB9XG4gICAgfVxuICAgIHZhciBkID0gMSwgZiwgYyA9IGNbYl0sIGIgPSAhMCBpbiBjLCBnO1xuICAgIGlmKGIpIHtcbiAgICAgIGYgPSBbXTtcbiAgICAgIGZvcihnID0gdGhpcztnO2cgPSBnLnBiKSB7XG4gICAgICAgIGYucHVzaChnKVxuICAgICAgfVxuICAgICAgZyA9IGNbITBdO1xuICAgICAgZy50ID0gZy5mO1xuICAgICAgZm9yKHZhciBoID0gZi5sZW5ndGggLSAxOyFhLm5hICYmIDAgPD0gaCAmJiBnLnQ7aC0tKSB7XG4gICAgICAgIGEuY3VycmVudFRhcmdldCA9IGZbaF0sIGQgJj0gUWIoZywgZltoXSwgYS50eXBlLCAhMCwgYSkgJiYgITEgIT0gYS5XYVxuICAgICAgfVxuICAgIH1cbiAgICBpZighMSBpbiBjKSB7XG4gICAgICBpZihnID0gY1shMV0sIGcudCA9IGcuZiwgYikge1xuICAgICAgICBmb3IoaCA9IDA7IWEubmEgJiYgaCA8IGYubGVuZ3RoICYmIGcudDtoKyspIHtcbiAgICAgICAgICBhLmN1cnJlbnRUYXJnZXQgPSBmW2hdLCBkICY9IFFiKGcsIGZbaF0sIGEudHlwZSwgITEsIGEpICYmICExICE9IGEuV2FcbiAgICAgICAgfVxuICAgICAgfWVsc2Uge1xuICAgICAgICBmb3IoZiA9IHRoaXM7IWEubmEgJiYgZiAmJiBnLnQ7ZiA9IGYucGIpIHtcbiAgICAgICAgICBhLmN1cnJlbnRUYXJnZXQgPSBmLCBkICY9IFFiKGcsIGYsIGEudHlwZSwgITEsIGEpICYmICExICE9IGEuV2FcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBhID0gQm9vbGVhbihkKVxuICB9ZWxzZSB7XG4gICAgYSA9ICEwXG4gIH1cbiAgcmV0dXJuIGFcbn07XG5wLnUgPSBmdW5jdGlvbigpIHtcbiAgU2IucmEudS5jYWxsKHRoaXMpO1xuICBQYih0aGlzKTtcbiAgdGhpcy5wYiA9IG51bGxcbn07XG5mdW5jdGlvbiBUYihhLCBiKSB7XG4gIE0uY2FsbCh0aGlzKTtcbiAgdGhpcy5kYSA9IGEgfHwgMTtcbiAgdGhpcy5FYSA9IGIgfHwgcTtcbiAgdGhpcy5lYiA9IHcodGhpcy5FYywgdGhpcyk7XG4gIHRoaXMub2IgPSB4KClcbn1cbnkoVGIsIFNiKTtcbnAgPSBUYi5wcm90b3R5cGU7XG5wLmVuYWJsZWQgPSAhMTtcbnAuciA9IG51bGw7XG5wLnNldEludGVydmFsID0gZnVuY3Rpb24oYSkge1xuICB0aGlzLmRhID0gYTtcbiAgdGhpcy5yICYmIHRoaXMuZW5hYmxlZCA/ICh0aGlzLnN0b3AoKSwgdGhpcy5zdGFydCgpKSA6IHRoaXMuciAmJiB0aGlzLnN0b3AoKVxufTtcbnAuRWMgPSBmdW5jdGlvbigpIHtcbiAgaWYodGhpcy5lbmFibGVkKSB7XG4gICAgdmFyIGEgPSB4KCkgLSB0aGlzLm9iO1xuICAgIDAgPCBhICYmIGEgPCAwLjggKiB0aGlzLmRhID8gdGhpcy5yID0gdGhpcy5FYS5zZXRUaW1lb3V0KHRoaXMuZWIsIHRoaXMuZGEgLSBhKSA6ICh0aGlzLmRpc3BhdGNoRXZlbnQoVWIpLCB0aGlzLmVuYWJsZWQgJiYgKHRoaXMuciA9IHRoaXMuRWEuc2V0VGltZW91dCh0aGlzLmViLCB0aGlzLmRhKSwgdGhpcy5vYiA9IHgoKSkpXG4gIH1cbn07XG5wLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW5hYmxlZCA9ICEwO1xuICB0aGlzLnIgfHwgKHRoaXMuciA9IHRoaXMuRWEuc2V0VGltZW91dCh0aGlzLmViLCB0aGlzLmRhKSwgdGhpcy5vYiA9IHgoKSlcbn07XG5wLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbmFibGVkID0gITE7XG4gIHRoaXMuciAmJiAodGhpcy5FYS5jbGVhclRpbWVvdXQodGhpcy5yKSwgdGhpcy5yID0gbnVsbClcbn07XG5wLnUgPSBmdW5jdGlvbigpIHtcbiAgVGIucmEudS5jYWxsKHRoaXMpO1xuICB0aGlzLnN0b3AoKTtcbiAgZGVsZXRlIHRoaXMuRWFcbn07XG52YXIgVWIgPSBcInRpY2tcIjtcbmZ1bmN0aW9uIFZiKGEpIHtcbiAgTS5jYWxsKHRoaXMpO1xuICB0aGlzLmUgPSBhO1xuICB0aGlzLmogPSBbXVxufVxueShWYiwgTSk7XG52YXIgV2IgPSBbXTtcbmZ1bmN0aW9uIFhiKGEsIGIsIGMsIGQpIHtcbiAgcyhjKSB8fCAoV2JbMF0gPSBjLCBjID0gV2IpO1xuICBmb3IodmFyIGYgPSAwO2YgPCBjLmxlbmd0aDtmKyspIHtcbiAgICB2YXIgZyA9IEpiKGIsIGNbZl0sIGQgfHwgYSwgITEsIGEuZSB8fCBhKTtcbiAgICBhLmoucHVzaChnKVxuICB9XG59XG5WYi5wcm90b3R5cGUudSA9IGZ1bmN0aW9uKCkge1xuICBWYi5yYS51LmNhbGwodGhpcyk7XG4gIFlhKHRoaXMuaiwgTmIpO1xuICB0aGlzLmoubGVuZ3RoID0gMFxufTtcblZiLnByb3RvdHlwZS5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBFcnJvcihcIkV2ZW50SGFuZGxlci5oYW5kbGVFdmVudCBub3QgaW1wbGVtZW50ZWRcIik7XG59O1xuZnVuY3Rpb24gWWIoYSwgYiwgYykge1xuICBNLmNhbGwodGhpcyk7XG4gIHRoaXMubmMgPSBhO1xuICB0aGlzLmRhID0gYjtcbiAgdGhpcy5lID0gYztcbiAgdGhpcy5oYyA9IHcodGhpcy50YywgdGhpcylcbn1cbnkoWWIsIE0pO1xucCA9IFliLnByb3RvdHlwZTtcbnAuWGEgPSAhMTtcbnAuVGIgPSAwO1xucC5yID0gbnVsbDtcbnAuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnIgJiYgKHEuY2xlYXJUaW1lb3V0KHRoaXMuciksIHRoaXMuciA9IG51bGwsIHRoaXMuWGEgPSAhMSlcbn07XG5wLnUgPSBmdW5jdGlvbigpIHtcbiAgWWIucmEudS5jYWxsKHRoaXMpO1xuICB0aGlzLnN0b3AoKVxufTtcbnAudGMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yID0gbnVsbDtcbiAgdGhpcy5YYSAmJiAhdGhpcy5UYiAmJiAodGhpcy5YYSA9ICExLCBaYih0aGlzKSlcbn07XG5mdW5jdGlvbiBaYihhKSB7XG4gIHZhciBiO1xuICBiID0gYS5oYztcbiAgdmFyIGMgPSBhLmRhO1xuICBpZighaGEoYikpIHtcbiAgICBpZihiICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgYi5oYW5kbGVFdmVudCkge1xuICAgICAgYiA9IHcoYi5oYW5kbGVFdmVudCwgYilcbiAgICB9ZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgbGlzdGVuZXIgYXJndW1lbnRcIik7XG4gICAgfVxuICB9XG4gIGIgPSAyMTQ3NDgzNjQ3IDwgYyA/IC0xIDogcS5zZXRUaW1lb3V0KGIsIGMgfHwgMCk7XG4gIGEuciA9IGI7XG4gIGEubmMuY2FsbChhLmUpXG59XG47ZnVuY3Rpb24gUShhLCBiLCBjLCBkLCBmKSB7XG4gIHRoaXMuYiA9IGE7XG4gIHRoaXMuYSA9IGI7XG4gIHRoaXMuWiA9IGM7XG4gIHRoaXMuQiA9IGQ7XG4gIHRoaXMuQ2EgPSBmIHx8IDE7XG4gIHRoaXMuRGEgPSAkYjtcbiAgdGhpcy5qYiA9IG5ldyBWYih0aGlzKTtcbiAgdGhpcy5TYSA9IG5ldyBUYjtcbiAgdGhpcy5TYS5zZXRJbnRlcnZhbChhYylcbn1cbnAgPSBRLnByb3RvdHlwZTtcbnAudiA9IG51bGw7XG5wLkogPSAhMTtcbnAudWEgPSBudWxsO1xucC5zYiA9IG51bGw7XG5wLnBhID0gbnVsbDtcbnAuc2EgPSBudWxsO1xucC5UID0gbnVsbDtcbnAudyA9IG51bGw7XG5wLlggPSBudWxsO1xucC5sID0gbnVsbDtcbnAuRmEgPSAwO1xucC5LID0gbnVsbDtcbnAudGEgPSBudWxsO1xucC5wID0gbnVsbDtcbnAuaCA9IC0xO1xucC5YYiA9ICEwO1xucC5hYSA9ICExO1xucC5vYSA9IDA7XG5wLlRhID0gbnVsbDtcbnZhciAkYiA9IDQ1RTMsIGFjID0gMjUwO1xuZnVuY3Rpb24gYmMoYSwgYikge1xuICBzd2l0Y2goYSkge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVyblwiTm9uLTIwMCByZXR1cm4gY29kZSAoXCIgKyBiICsgXCIpXCI7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuXCJYTUxIVFRQIGZhaWx1cmUgKG5vIGRhdGEpXCI7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuXCJIdHRwQ29ubmVjdGlvbiB0aW1lb3V0XCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVyblwiVW5rbm93biBlcnJvclwiXG4gIH1cbn1cbnZhciBjYyA9IHt9LCBkYyA9IHt9O1xuZnVuY3Rpb24gZWMoKSB7XG4gIHJldHVybiFBIHx8IEEgJiYgMTAgPD0gTWFcbn1cbnAgPSBRLnByb3RvdHlwZTtcbnAuWSA9IG0oXCJ2XCIpO1xucC5zZXRUaW1lb3V0ID0gbShcIkRhXCIpO1xucC4kYiA9IG0oXCJvYVwiKTtcbmZ1bmN0aW9uIGZjKGEsIGIsIGMpIHtcbiAgYS5zYSA9IDE7XG4gIGEuVCA9IEooYi5uKCkpO1xuICBhLlggPSBjO1xuICBhLnhiID0gITA7XG4gIGdjKGEsIG51bGwpXG59XG5mdW5jdGlvbiBoYyhhLCBiLCBjLCBkLCBmKSB7XG4gIGEuc2EgPSAxO1xuICBhLlQgPSBKKGIubigpKTtcbiAgYS5YID0gbnVsbDtcbiAgYS54YiA9IGM7XG4gIGYgJiYgKGEuWGIgPSAhMSk7XG4gIGdjKGEsIGQpXG59XG5mdW5jdGlvbiBnYyhhLCBiKSB7XG4gIGEucGEgPSB4KCk7XG4gIGljKGEpO1xuICBhLncgPSBhLlQubigpO1xuICBxYihhLncsIFwidFwiLCBhLkNhKTtcbiAgYS5GYSA9IDA7XG4gIGEubCA9IGEuYi5oYihhLmIuWWEoKSA/IGIgOiBudWxsKTtcbiAgMCA8IGEub2EgJiYgKGEuVGEgPSBuZXcgWWIodyhhLmRjLCBhLCBhLmwpLCBhLm9hKSk7XG4gIFhiKGEuamIsIGEubCwgXCJyZWFkeXN0YXRlY2hhbmdlXCIsIGEuQWMpO1xuICB2YXIgYztcbiAgaWYoYS52KSB7XG4gICAgYyA9IGEudjtcbiAgICB2YXIgZCA9IHt9LCBmO1xuICAgIGZvcihmIGluIGMpIHtcbiAgICAgIGRbZl0gPSBjW2ZdXG4gICAgfVxuICAgIGMgPSBkXG4gIH1lbHNlIHtcbiAgICBjID0ge31cbiAgfVxuICBhLlggPyAoYS50YSA9IFwiUE9TVFwiLCBjW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiwgYS5sLnNlbmQoYS53LCBhLnRhLCBhLlgsIGMpKSA6IChhLnRhID0gXCJHRVRcIiwgYS5YYiAmJiAhQiAmJiAoYy5Db25uZWN0aW9uID0gXCJjbG9zZVwiKSwgYS5sLnNlbmQoYS53LCBhLnRhLCBudWxsLCBjKSk7XG4gIGEuYi5HKGpjKTtcbiAgaWYoZCA9IGEuWCkge1xuICAgIGZvcihjID0gXCJcIiwgZCA9IGQuc3BsaXQoXCImXCIpLCBmID0gMDtmIDwgZC5sZW5ndGg7ZisrKSB7XG4gICAgICB2YXIgZyA9IGRbZl0uc3BsaXQoXCI9XCIpO1xuICAgICAgaWYoMSA8IGcubGVuZ3RoKSB7XG4gICAgICAgIHZhciBoID0gZ1swXSwgZyA9IGdbMV0sIG4gPSBoLnNwbGl0KFwiX1wiKTtcbiAgICAgICAgYyA9IDIgPD0gbi5sZW5ndGggJiYgXCJ0eXBlXCIgPT0gblsxXSA/IGMgKyAoaCArIFwiPVwiICsgZyArIFwiJlwiKSA6IGMgKyAoaCArIFwiPXJlZGFjdGVkJlwiKVxuICAgICAgfVxuICAgIH1cbiAgfWVsc2Uge1xuICAgIGMgPSBudWxsXG4gIH1cbiAgYS5hLmluZm8oXCJYTUxIVFRQIFJFUSAoXCIgKyBhLkIgKyBcIikgW2F0dGVtcHQgXCIgKyBhLkNhICsgXCJdOiBcIiArIGEudGEgKyBcIlxcblwiICsgYS53ICsgXCJcXG5cIiArIGMpXG59XG5wLkFjID0gZnVuY3Rpb24oYSkge1xuICBhID0gYS50YXJnZXQ7XG4gIHZhciBiID0gdGhpcy5UYTtcbiAgYiAmJiAzID09IFIoYSkgPyAodGhpcy5hLmRlYnVnKFwiVGhyb3R0bGluZyByZWFkeXN0YXRlY2hhbmdlLlwiKSwgYi5yIHx8IGIuVGIgPyBiLlhhID0gITAgOiBaYihiKSkgOiB0aGlzLmRjKGEpXG59O1xucC5kYyA9IGZ1bmN0aW9uKGEpIHtcbiAgdHJ5IHtcbiAgICBpZihhID09IHRoaXMubCkge1xuICAgICAgYToge1xuICAgICAgICB2YXIgYiA9IFIodGhpcy5sKSwgYyA9IHRoaXMubC5sYSwgZCA9IGtjKHRoaXMubCk7XG4gICAgICAgIGlmKCFlYygpIHx8IEIgJiYgIUMoXCI0MjArXCIpKSB7XG4gICAgICAgICAgaWYoNCA+IGIpIHtcbiAgICAgICAgICAgIGJyZWFrIGFcbiAgICAgICAgICB9XG4gICAgICAgIH1lbHNlIHtcbiAgICAgICAgICBpZigzID4gYiB8fCAzID09IGIgJiYgIXphICYmICFsYyh0aGlzLmwpKSB7XG4gICAgICAgICAgICBicmVhayBhXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWEgfHwgKDQgIT0gYiB8fCBjID09IG1jKSB8fCAoYyA9PSBuYyB8fCAwID49IGQgPyB0aGlzLmIuRyhvYykgOiB0aGlzLmIuRyhwYykpO1xuICAgICAgICBxYyh0aGlzKTtcbiAgICAgICAgdmFyIGYgPSBrYyh0aGlzLmwpO1xuICAgICAgICB0aGlzLmggPSBmO1xuICAgICAgICB2YXIgZyA9IGxjKHRoaXMubCk7XG4gICAgICAgIGcgfHwgdGhpcy5hLmRlYnVnKFwiTm8gcmVzcG9uc2UgdGV4dCBmb3IgdXJpIFwiICsgdGhpcy53ICsgXCIgc3RhdHVzIFwiICsgZik7XG4gICAgICAgIHRoaXMuSiA9IDIwMCA9PSBmO1xuICAgICAgICB0aGlzLmEuaW5mbyhcIlhNTEhUVFAgUkVTUCAoXCIgKyB0aGlzLkIgKyBcIikgWyBhdHRlbXB0IFwiICsgdGhpcy5DYSArIFwiXTogXCIgKyB0aGlzLnRhICsgXCJcXG5cIiArIHRoaXMudyArIFwiXFxuXCIgKyBiICsgXCIgXCIgKyBmKTtcbiAgICAgICAgdGhpcy5KID8gKDQgPT0gYiAmJiBTKHRoaXMpLCB0aGlzLnhiID8gKHJjKHRoaXMsIGIsIGcpLCB6YSAmJiAzID09IGIgJiYgKFhiKHRoaXMuamIsIHRoaXMuU2EsIFViLCB0aGlzLnpjKSwgdGhpcy5TYS5zdGFydCgpKSkgOiAoc2ModGhpcy5hLCB0aGlzLkIsIGcsIG51bGwpLCB0Yyh0aGlzLCBnKSksIHRoaXMuSiAmJiAhdGhpcy5hYSAmJiAoNCA9PSBiID8gdGhpcy5iLm1hKHRoaXMpIDogKHRoaXMuSiA9ICExLCBpYyh0aGlzKSkpKSA6ICg0MDAgPT0gZiAmJiAwIDwgZy5pbmRleE9mKFwiVW5rbm93biBTSURcIikgPyAodGhpcy5wID0gMywgVCh1YyksIHRoaXMuYS4kKFwiWE1MSFRUUCBVbmtub3duIFNJRCAoXCIgKyB0aGlzLkIgKyBcIilcIikpIDogKHRoaXMucCA9IDAsIFQodmMpLCB0aGlzLmEuJChcIlhNTEhUVFAgQmFkIHN0YXR1cyBcIiArIGYgKyBcIiAoXCIgKyB0aGlzLkIgKyBcIilcIikpLCBTKHRoaXMpLCB3Yyh0aGlzKSlcbiAgICAgIH1cbiAgICB9ZWxzZSB7XG4gICAgICB0aGlzLmEuJChcIkNhbGxlZCBiYWNrIHdpdGggYW4gdW5leHBlY3RlZCB4bWxodHRwXCIpXG4gICAgfVxuICB9Y2F0Y2goaCkge1xuICAgIHRoaXMuYS5kZWJ1ZyhcIkZhaWxlZCBjYWxsIHRvIE9uWG1sSHR0cFJlYWR5U3RhdGVDaGFuZ2VkX1wiKSwgdGhpcy5sICYmIGxjKHRoaXMubCkgPyB4Yyh0aGlzLmEsIGgsIFwiUmVzcG9uc2VUZXh0OiBcIiArIGxjKHRoaXMubCkpIDogeGModGhpcy5hLCBoLCBcIk5vIHJlc3BvbnNlIHRleHRcIilcbiAgfWZpbmFsbHkge1xuICB9XG59O1xuZnVuY3Rpb24gcmMoYSwgYiwgYykge1xuICBmb3IodmFyIGQgPSAhMDshYS5hYSAmJiBhLkZhIDwgYy5sZW5ndGg7KSB7XG4gICAgdmFyIGYgPSB5YyhhLCBjKTtcbiAgICBpZihmID09IGRjKSB7XG4gICAgICA0ID09IGIgJiYgKGEucCA9IDQsIFQoemMpLCBkID0gITEpO1xuICAgICAgc2MoYS5hLCBhLkIsIG51bGwsIFwiW0luY29tcGxldGUgUmVzcG9uc2VdXCIpO1xuICAgICAgYnJlYWtcbiAgICB9ZWxzZSB7XG4gICAgICBpZihmID09IGNjKSB7XG4gICAgICAgIGEucCA9IDQ7XG4gICAgICAgIFQoQWMpO1xuICAgICAgICBzYyhhLmEsIGEuQiwgYywgXCJbSW52YWxpZCBDaHVua11cIik7XG4gICAgICAgIGQgPSAhMTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1lbHNlIHtcbiAgICAgICAgc2MoYS5hLCBhLkIsIGYsIG51bGwpLCB0YyhhLCBmKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICA0ID09IGIgJiYgMCA9PSBjLmxlbmd0aCAmJiAoYS5wID0gMSwgVChCYyksIGQgPSAhMSk7XG4gIGEuSiA9IGEuSiAmJiBkO1xuICBkIHx8IChzYyhhLmEsIGEuQiwgYywgXCJbSW52YWxpZCBDaHVua2VkIFJlc3BvbnNlXVwiKSwgUyhhKSwgd2MoYSkpXG59XG5wLnpjID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhID0gUih0aGlzLmwpLCBiID0gbGModGhpcy5sKTtcbiAgdGhpcy5GYSA8IGIubGVuZ3RoICYmIChxYyh0aGlzKSwgcmModGhpcywgYSwgYiksIHRoaXMuSiAmJiA0ICE9IGEgJiYgaWModGhpcykpXG59O1xuZnVuY3Rpb24geWMoYSwgYikge1xuICB2YXIgYyA9IGEuRmEsIGQgPSBiLmluZGV4T2YoXCJcXG5cIiwgYyk7XG4gIGlmKC0xID09IGQpIHtcbiAgICByZXR1cm4gZGNcbiAgfVxuICBjID0gTnVtYmVyKGIuc3Vic3RyaW5nKGMsIGQpKTtcbiAgaWYoaXNOYU4oYykpIHtcbiAgICByZXR1cm4gY2NcbiAgfVxuICBkICs9IDE7XG4gIGlmKGQgKyBjID4gYi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZGNcbiAgfVxuICB2YXIgZiA9IGIuc3Vic3RyKGQsIGMpO1xuICBhLkZhID0gZCArIGM7XG4gIHJldHVybiBmXG59XG5mdW5jdGlvbiBDYyhhLCBiKSB7XG4gIGEucGEgPSB4KCk7XG4gIGljKGEpO1xuICB2YXIgYyA9IGIgPyB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgOiBcIlwiO1xuICBhLncgPSBhLlQubigpO1xuICBJKGEudywgXCJET01BSU5cIiwgYyk7XG4gIEkoYS53LCBcInRcIiwgYS5DYSk7XG4gIHRyeSB7XG4gICAgYS5LID0gbmV3IEFjdGl2ZVhPYmplY3QoXCJodG1sZmlsZVwiKVxuICB9Y2F0Y2goZCkge1xuICAgIGEuYS5JKFwiQWN0aXZlWCBibG9ja2VkXCIpO1xuICAgIFMoYSk7XG4gICAgYS5wID0gNztcbiAgICBUKERjKTtcbiAgICB3YyhhKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgZiA9IFwiPGh0bWw+PGJvZHk+XCI7XG4gIGIgJiYgKGYgKz0gJzxzY3JpcHQ+ZG9jdW1lbnQuZG9tYWluPVwiJyArIGMgKyAnXCJcXHgzYy9zY3JpcHQ+Jyk7XG4gIGYgKz0gXCI8L2JvZHk+PC9odG1sPlwiO1xuICBhLksub3BlbigpO1xuICBhLksud3JpdGUoZik7XG4gIGEuSy5jbG9zZSgpO1xuICBhLksucGFyZW50V2luZG93Lm0gPSB3KGEud2MsIGEpO1xuICBhLksucGFyZW50V2luZG93LmQgPSB3KGEuU2IsIGEsICEwKTtcbiAgYS5LLnBhcmVudFdpbmRvdy5ycGNDbG9zZSA9IHcoYS5TYiwgYSwgITEpO1xuICBjID0gYS5LLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGEuSy5wYXJlbnRXaW5kb3cuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjKTtcbiAgYy5pbm5lckhUTUwgPSAnPGlmcmFtZSBzcmM9XCInICsgYS53ICsgJ1wiPjwvaWZyYW1lPic7XG4gIGEuYS5pbmZvKFwiVFJJREVOVCBSRVEgKFwiICsgYS5CICsgXCIpIFsgYXR0ZW1wdCBcIiArIGEuQ2EgKyBcIl06IEdFVFxcblwiICsgYS53KTtcbiAgYS5iLkcoamMpXG59XG5wLndjID0gZnVuY3Rpb24oYSkge1xuICBVKHcodGhpcy52YywgdGhpcywgYSksIDApXG59O1xucC52YyA9IGZ1bmN0aW9uKGEpIHtcbiAgaWYoIXRoaXMuYWEpIHtcbiAgICB2YXIgYiA9IHRoaXMuYTtcbiAgICBiLmluZm8oXCJUUklERU5UIFRFWFQgKFwiICsgdGhpcy5CICsgXCIpOiBcIiArIEVjKGIsIGEpKTtcbiAgICBxYyh0aGlzKTtcbiAgICB0Yyh0aGlzLCBhKTtcbiAgICBpYyh0aGlzKVxuICB9XG59O1xucC5TYiA9IGZ1bmN0aW9uKGEpIHtcbiAgVSh3KHRoaXMudWMsIHRoaXMsIGEpLCAwKVxufTtcbnAudWMgPSBmdW5jdGlvbihhKSB7XG4gIHRoaXMuYWEgfHwgKHRoaXMuYS5pbmZvKFwiVFJJREVOVCBURVhUIChcIiArIHRoaXMuQiArIFwiKTogXCIgKyBhID8gXCJzdWNjZXNzXCIgOiBcImZhaWx1cmVcIiksIFModGhpcyksIHRoaXMuSiA9IGEsIHRoaXMuYi5tYSh0aGlzKSwgdGhpcy5iLkcoRmMpKVxufTtcbnAubGMgPSBmdW5jdGlvbigpIHtcbiAgcWModGhpcyk7XG4gIHRoaXMuYi5tYSh0aGlzKVxufTtcbnAuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuYWEgPSAhMDtcbiAgUyh0aGlzKVxufTtcbmZ1bmN0aW9uIGljKGEpIHtcbiAgYS5zYiA9IHgoKSArIGEuRGE7XG4gIEdjKGEsIGEuRGEpXG59XG5mdW5jdGlvbiBHYyhhLCBiKSB7XG4gIGlmKG51bGwgIT0gYS51YSkge1xuICAgIHRocm93IEVycm9yKFwiV2F0Y2hEb2cgdGltZXIgbm90IG51bGxcIik7XG4gIH1cbiAgYS51YSA9IFUodyhhLnhjLCBhKSwgYilcbn1cbmZ1bmN0aW9uIHFjKGEpIHtcbiAgYS51YSAmJiAocS5jbGVhclRpbWVvdXQoYS51YSksIGEudWEgPSBudWxsKVxufVxucC54YyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnVhID0gbnVsbDtcbiAgdmFyIGEgPSB4KCk7XG4gIDAgPD0gYSAtIHRoaXMuc2IgPyAodGhpcy5KICYmIHRoaXMuYS5JKFwiUmVjZWl2ZWQgd2F0Y2hkb2cgdGltZW91dCBldmVuIHRob3VnaCByZXF1ZXN0IGxvYWRlZCBzdWNjZXNzZnVsbHlcIiksIHRoaXMuYS5pbmZvKFwiVElNRU9VVDogXCIgKyB0aGlzLncpLCAyICE9IHRoaXMuc2EgJiYgdGhpcy5iLkcob2MpLCBTKHRoaXMpLCB0aGlzLnAgPSAyLCBUKEhjKSwgd2ModGhpcykpIDogKHRoaXMuYS4kKFwiV2F0Y2hEb2cgdGltZXIgY2FsbGVkIHRvbyBlYXJseVwiKSwgR2ModGhpcywgdGhpcy5zYiAtIGEpKVxufTtcbmZ1bmN0aW9uIHdjKGEpIHtcbiAgYS5iLkhiKCkgfHwgYS5hYSB8fCBhLmIubWEoYSlcbn1cbmZ1bmN0aW9uIFMoYSkge1xuICBxYyhhKTtcbiAgdmFyIGIgPSBhLlRhO1xuICBiICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgYi5JYSAmJiBiLklhKCk7XG4gIGEuVGEgPSBudWxsO1xuICBhLlNhLnN0b3AoKTtcbiAgYiA9IGEuamI7XG4gIFlhKGIuaiwgTmIpO1xuICBiLmoubGVuZ3RoID0gMDtcbiAgYS5sICYmIChiID0gYS5sLCBhLmwgPSBudWxsLCBiLmFib3J0KCksIGIuSWEoKSk7XG4gIGEuSyAmJiAoYS5LID0gbnVsbClcbn1cbnAuRWIgPSBhYShcInBcIik7XG5mdW5jdGlvbiB0YyhhLCBiKSB7XG4gIHRyeSB7XG4gICAgYS5iLlBiKGEsIGIpLCBhLmIuRyhGYylcbiAgfWNhdGNoKGMpIHtcbiAgICB4YyhhLmEsIGMsIFwiRXJyb3IgaW4gaHR0cHJlcXVlc3QgY2FsbGJhY2tcIilcbiAgfVxufVxuO2Z1bmN0aW9uIEljKGEpIHtcbiAgYSA9IFN0cmluZyhhKTtcbiAgaWYoL15cXHMqJC8udGVzdChhKSA/IDAgOiAvXltcXF0sOnt9XFxzXFx1MjAyOFxcdTIwMjldKiQvLnRlc3QoYS5yZXBsYWNlKC9cXFxcW1wiXFxcXFxcL2JmbnJ0dV0vZywgXCJAXCIpLnJlcGxhY2UoL1wiW15cIlxcXFxcXG5cXHJcXHUyMDI4XFx1MjAyOVxceDAwLVxceDA4XFx4MGEtXFx4MWZdKlwifHRydWV8ZmFsc2V8bnVsbHwtP1xcZCsoPzpcXC5cXGQqKT8oPzpbZUVdWytcXC1dP1xcZCspPy9nLCBcIl1cIikucmVwbGFjZSgvKD86Xnw6fCwpKD86W1xcc1xcdTIwMjhcXHUyMDI5XSpcXFspKy9nLCBcIlwiKSkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGV2YWwoXCIoXCIgKyBhICsgXCIpXCIpXG4gICAgfWNhdGNoKGIpIHtcbiAgICB9XG4gIH1cbiAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIEpTT04gc3RyaW5nOiBcIiArIGEpO1xufVxuZnVuY3Rpb24gSmMoYSkge1xuICByZXR1cm4gZXZhbChcIihcIiArIGEgKyBcIilcIilcbn1cbmZ1bmN0aW9uIEtjKGEpIHtcbiAgdmFyIGIgPSBbXTtcbiAgTGMobmV3IE1jKHZvaWQgMCksIGEsIGIpO1xuICByZXR1cm4gYi5qb2luKFwiXCIpXG59XG5mdW5jdGlvbiBNYyhhKSB7XG4gIHRoaXMuVmEgPSBhXG59XG5mdW5jdGlvbiBMYyhhLCBiLCBjKSB7XG4gIHN3aXRjaCh0eXBlb2YgYikge1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIE5jKGIsIGMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgYy5wdXNoKGlzRmluaXRlKGIpICYmICFpc05hTihiKSA/IGIgOiBcIm51bGxcIik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgYy5wdXNoKGIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgYy5wdXNoKFwibnVsbFwiKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIGlmKG51bGwgPT0gYikge1xuICAgICAgICBjLnB1c2goXCJudWxsXCIpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYocyhiKSkge1xuICAgICAgICB2YXIgZCA9IGIubGVuZ3RoO1xuICAgICAgICBjLnB1c2goXCJbXCIpO1xuICAgICAgICBmb3IodmFyIGYgPSBcIlwiLCBnID0gMDtnIDwgZDtnKyspIHtcbiAgICAgICAgICBjLnB1c2goZiksIGYgPSBiW2ddLCBMYyhhLCBhLlZhID8gYS5WYS5jYWxsKGIsIFN0cmluZyhnKSwgZikgOiBmLCBjKSwgZiA9IFwiLFwiXG4gICAgICAgIH1cbiAgICAgICAgYy5wdXNoKFwiXVwiKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGMucHVzaChcIntcIik7XG4gICAgICBkID0gXCJcIjtcbiAgICAgIGZvcihnIGluIGIpIHtcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGcpICYmIChmID0gYltnXSwgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBmICYmIChjLnB1c2goZCksIE5jKGcsIGMpLCBjLnB1c2goXCI6XCIpLCBMYyhhLCBhLlZhID8gYS5WYS5jYWxsKGIsIGcsIGYpIDogZiwgYyksIGQgPSBcIixcIikpXG4gICAgICB9XG4gICAgICBjLnB1c2goXCJ9XCIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgRXJyb3IoXCJVbmtub3duIHR5cGU6IFwiICsgdHlwZW9mIGIpO1xuICB9XG59XG52YXIgT2MgPSB7J1wiJzonXFxcXFwiJywgXCJcXFxcXCI6XCJcXFxcXFxcXFwiLCBcIi9cIjpcIlxcXFwvXCIsIFwiXFxiXCI6XCJcXFxcYlwiLCBcIlxcZlwiOlwiXFxcXGZcIiwgXCJcXG5cIjpcIlxcXFxuXCIsIFwiXFxyXCI6XCJcXFxcclwiLCBcIlxcdFwiOlwiXFxcXHRcIiwgXCJcXHgwQlwiOlwiXFxcXHUwMDBiXCJ9LCBQYyA9IC9cXHVmZmZmLy50ZXN0KFwiXFx1ZmZmZlwiKSA/IC9bXFxcXFxcXCJcXHgwMC1cXHgxZlxceDdmLVxcdWZmZmZdL2cgOiAvW1xcXFxcXFwiXFx4MDAtXFx4MWZcXHg3Zi1cXHhmZl0vZztcbmZ1bmN0aW9uIE5jKGEsIGIpIHtcbiAgYi5wdXNoKCdcIicsIGEucmVwbGFjZShQYywgZnVuY3Rpb24oYSkge1xuICAgIGlmKGEgaW4gT2MpIHtcbiAgICAgIHJldHVybiBPY1thXVxuICAgIH1cbiAgICB2YXIgYiA9IGEuY2hhckNvZGVBdCgwKSwgZiA9IFwiXFxcXHVcIjtcbiAgICAxNiA+IGIgPyBmICs9IFwiMDAwXCIgOiAyNTYgPiBiID8gZiArPSBcIjAwXCIgOiA0MDk2ID4gYiAmJiAoZiArPSBcIjBcIik7XG4gICAgcmV0dXJuIE9jW2FdID0gZiArIGIudG9TdHJpbmcoMTYpXG4gIH0pLCAnXCInKVxufVxuO2Z1bmN0aW9uIFFjKGEpIHtcbiAgcmV0dXJuIFJjKGEgfHwgYXJndW1lbnRzLmNhbGxlZS5jYWxsZXIsIFtdKVxufVxuZnVuY3Rpb24gUmMoYSwgYikge1xuICB2YXIgYyA9IFtdO1xuICBpZigwIDw9IFhhKGIsIGEpKSB7XG4gICAgYy5wdXNoKFwiWy4uLmNpcmN1bGFyIHJlZmVyZW5jZS4uLl1cIilcbiAgfWVsc2Uge1xuICAgIGlmKGEgJiYgNTAgPiBiLmxlbmd0aCkge1xuICAgICAgYy5wdXNoKFNjKGEpICsgXCIoXCIpO1xuICAgICAgZm9yKHZhciBkID0gYS5hcmd1bWVudHMsIGYgPSAwO2YgPCBkLmxlbmd0aDtmKyspIHtcbiAgICAgICAgMCA8IGYgJiYgYy5wdXNoKFwiLCBcIik7XG4gICAgICAgIHZhciBnO1xuICAgICAgICBnID0gZFtmXTtcbiAgICAgICAgc3dpdGNoKHR5cGVvZiBnKSB7XG4gICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgZyA9IGcgPyBcIm9iamVjdFwiIDogXCJudWxsXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBnID0gU3RyaW5nKGcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgIGcgPSBnID8gXCJ0cnVlXCIgOiBcImZhbHNlXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgIGcgPSAoZyA9IFNjKGcpKSA/IGcgOiBcIltmbl1cIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBnID0gdHlwZW9mIGdcbiAgICAgICAgfVxuICAgICAgICA0MCA8IGcubGVuZ3RoICYmIChnID0gZy5zdWJzdHIoMCwgNDApICsgXCIuLi5cIik7XG4gICAgICAgIGMucHVzaChnKVxuICAgICAgfVxuICAgICAgYi5wdXNoKGEpO1xuICAgICAgYy5wdXNoKFwiKVxcblwiKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGMucHVzaChSYyhhLmNhbGxlciwgYikpXG4gICAgICB9Y2F0Y2goaCkge1xuICAgICAgICBjLnB1c2goXCJbZXhjZXB0aW9uIHRyeWluZyB0byBnZXQgY2FsbGVyXVxcblwiKVxuICAgICAgfVxuICAgIH1lbHNlIHtcbiAgICAgIGEgPyBjLnB1c2goXCJbLi4ubG9uZyBzdGFjay4uLl1cIikgOiBjLnB1c2goXCJbZW5kXVwiKVxuICAgIH1cbiAgfVxuICByZXR1cm4gYy5qb2luKFwiXCIpXG59XG5mdW5jdGlvbiBTYyhhKSB7XG4gIGlmKFRjW2FdKSB7XG4gICAgcmV0dXJuIFRjW2FdXG4gIH1cbiAgYSA9IFN0cmluZyhhKTtcbiAgaWYoIVRjW2FdKSB7XG4gICAgdmFyIGIgPSAvZnVuY3Rpb24gKFteXFwoXSspLy5leGVjKGEpO1xuICAgIFRjW2FdID0gYiA/IGJbMV0gOiBcIltBbm9ueW1vdXNdXCJcbiAgfVxuICByZXR1cm4gVGNbYV1cbn1cbnZhciBUYyA9IHt9O1xuZnVuY3Rpb24gVWMoYSwgYiwgYywgZCwgZikge1xuICB0aGlzLnJlc2V0KGEsIGIsIGMsIGQsIGYpXG59XG5VYy5wcm90b3R5cGUuQ2MgPSAwO1xuVWMucHJvdG90eXBlLkJiID0gbnVsbDtcblVjLnByb3RvdHlwZS5BYiA9IG51bGw7XG52YXIgVmMgPSAwO1xuVWMucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oYSwgYiwgYywgZCwgZikge1xuICB0aGlzLkNjID0gXCJudW1iZXJcIiA9PSB0eXBlb2YgZiA/IGYgOiBWYysrO1xuICB0aGlzLlFjID0gZCB8fCB4KCk7XG4gIHRoaXMuemEgPSBhO1xuICB0aGlzLm9jID0gYjtcbiAgdGhpcy5JYyA9IGM7XG4gIGRlbGV0ZSB0aGlzLkJiO1xuICBkZWxldGUgdGhpcy5BYlxufTtcblVjLnByb3RvdHlwZS5ZYiA9IG0oXCJ6YVwiKTtcbmZ1bmN0aW9uIFYoYSkge1xuICB0aGlzLnBjID0gYVxufVxuVi5wcm90b3R5cGUuUmEgPSBudWxsO1xuVi5wcm90b3R5cGUuemEgPSBudWxsO1xuVi5wcm90b3R5cGUuZmIgPSBudWxsO1xuVi5wcm90b3R5cGUuRmIgPSBudWxsO1xuZnVuY3Rpb24gV2MoYSwgYikge1xuICB0aGlzLm5hbWUgPSBhO1xuICB0aGlzLnZhbHVlID0gYlxufVxuV2MucHJvdG90eXBlLnRvU3RyaW5nID0gYWEoXCJuYW1lXCIpO1xudmFyIFhjID0gbmV3IFdjKFwiU0VWRVJFXCIsIDFFMyksIFljID0gbmV3IFdjKFwiV0FSTklOR1wiLCA5MDApLCBaYyA9IG5ldyBXYyhcIklORk9cIiwgODAwKSwgJGMgPSBuZXcgV2MoXCJDT05GSUdcIiwgNzAwKSwgYWQgPSBuZXcgV2MoXCJGSU5FXCIsIDUwMCk7XG5wID0gVi5wcm90b3R5cGU7XG5wLmdldFBhcmVudCA9IGFhKFwiUmFcIik7XG5wLlliID0gbShcInphXCIpO1xuZnVuY3Rpb24gYmQoYSkge1xuICBpZihhLnphKSB7XG4gICAgcmV0dXJuIGEuemFcbiAgfVxuICBpZihhLlJhKSB7XG4gICAgcmV0dXJuIGJkKGEuUmEpXG4gIH1cbiAgUGEoXCJSb290IGxvZ2dlciBoYXMgbm8gbGV2ZWwgc2V0LlwiKTtcbiAgcmV0dXJuIG51bGxcbn1cbnAubG9nID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICBpZihhLnZhbHVlID49IGJkKHRoaXMpLnZhbHVlKSB7XG4gICAgZm9yKGEgPSB0aGlzLmtjKGEsIGIsIGMpLCBiID0gXCJsb2c6XCIgKyBhLm9jLCBxLmNvbnNvbGUgJiYgKHEuY29uc29sZS50aW1lU3RhbXAgPyBxLmNvbnNvbGUudGltZVN0YW1wKGIpIDogcS5jb25zb2xlLm1hcmtUaW1lbGluZSAmJiBxLmNvbnNvbGUubWFya1RpbWVsaW5lKGIpKSwgcS5tc1dyaXRlUHJvZmlsZXJNYXJrICYmIHEubXNXcml0ZVByb2ZpbGVyTWFyayhiKSwgYiA9IHRoaXM7YjspIHtcbiAgICAgIGMgPSBiO1xuICAgICAgdmFyIGQgPSBhO1xuICAgICAgaWYoYy5GYikge1xuICAgICAgICBmb3IodmFyIGYgPSAwLCBnID0gdm9pZCAwO2cgPSBjLkZiW2ZdO2YrKykge1xuICAgICAgICAgIGcoZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYiA9IGIuZ2V0UGFyZW50KClcbiAgICB9XG4gIH1cbn07XG5wLmtjID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICB2YXIgZCA9IG5ldyBVYyhhLCBTdHJpbmcoYiksIHRoaXMucGMpO1xuICBpZihjKSB7XG4gICAgZC5CYiA9IGM7XG4gICAgdmFyIGY7XG4gICAgdmFyIGcgPSBhcmd1bWVudHMuY2FsbGVlLmNhbGxlcjtcbiAgICB0cnkge1xuICAgICAgdmFyIGg7XG4gICAgICB2YXIgbiA9IGRhKFwid2luZG93LmxvY2F0aW9uLmhyZWZcIik7XG4gICAgICBpZih1KGMpKSB7XG4gICAgICAgIGggPSB7bWVzc2FnZTpjLCBuYW1lOlwiVW5rbm93biBlcnJvclwiLCBsaW5lTnVtYmVyOlwiTm90IGF2YWlsYWJsZVwiLCBmaWxlTmFtZTpuLCBzdGFjazpcIk5vdCBhdmFpbGFibGVcIn1cbiAgICAgIH1lbHNlIHtcbiAgICAgICAgdmFyIGssIHQsIGwgPSAhMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBrID0gYy5saW5lTnVtYmVyIHx8IGMuSGMgfHwgXCJOb3QgYXZhaWxhYmxlXCJcbiAgICAgICAgfWNhdGNoKHIpIHtcbiAgICAgICAgICBrID0gXCJOb3QgYXZhaWxhYmxlXCIsIGwgPSAhMFxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdCA9IGMuZmlsZU5hbWUgfHwgYy5maWxlbmFtZSB8fCBjLnNvdXJjZVVSTCB8fCBxLiRnb29nRGVidWdGbmFtZSB8fCBuXG4gICAgICAgIH1jYXRjaChHKSB7XG4gICAgICAgICAgdCA9IFwiTm90IGF2YWlsYWJsZVwiLCBsID0gITBcbiAgICAgICAgfVxuICAgICAgICBoID0gIWwgJiYgYy5saW5lTnVtYmVyICYmIGMuZmlsZU5hbWUgJiYgYy5zdGFjayA/IGMgOiB7bWVzc2FnZTpjLm1lc3NhZ2UsIG5hbWU6Yy5uYW1lLCBsaW5lTnVtYmVyOmssIGZpbGVOYW1lOnQsIHN0YWNrOmMuc3RhY2sgfHwgXCJOb3QgYXZhaWxhYmxlXCJ9XG4gICAgICB9XG4gICAgICBmID0gXCJNZXNzYWdlOiBcIiArIG5hKGgubWVzc2FnZSkgKyAnXFxuVXJsOiA8YSBocmVmPVwidmlldy1zb3VyY2U6JyArIGguZmlsZU5hbWUgKyAnXCIgdGFyZ2V0PVwiX25ld1wiPicgKyBoLmZpbGVOYW1lICsgXCI8L2E+XFxuTGluZTogXCIgKyBoLmxpbmVOdW1iZXIgKyBcIlxcblxcbkJyb3dzZXIgc3RhY2s6XFxuXCIgKyBuYShoLnN0YWNrICsgXCItPiBcIikgKyBcIltlbmRdXFxuXFxuSlMgc3RhY2sgdHJhdmVyc2FsOlxcblwiICsgbmEoUWMoZykgKyBcIi0+IFwiKVxuICAgIH1jYXRjaChTZCkge1xuICAgICAgZiA9IFwiRXhjZXB0aW9uIHRyeWluZyB0byBleHBvc2UgZXhjZXB0aW9uISBZb3Ugd2luLCB3ZSBsb3NlLiBcIiArIFNkXG4gICAgfVxuICAgIGQuQWIgPSBmXG4gIH1cbiAgcmV0dXJuIGRcbn07XG5wLkkgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHRoaXMubG9nKFhjLCBhLCBiKVxufTtcbnAuJCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdGhpcy5sb2coWWMsIGEsIGIpXG59O1xucC5pbmZvID0gZnVuY3Rpb24oYSwgYikge1xuICB0aGlzLmxvZyhaYywgYSwgYilcbn07XG5mdW5jdGlvbiBXKGEsIGIpIHtcbiAgYS5sb2coYWQsIGIsIHZvaWQgMClcbn1cbnZhciBjZCA9IHt9LCBkZCA9IG51bGw7XG5mdW5jdGlvbiBlZChhKSB7XG4gIGRkIHx8IChkZCA9IG5ldyBWKFwiXCIpLCBjZFtcIlwiXSA9IGRkLCBkZC5ZYigkYykpO1xuICB2YXIgYjtcbiAgaWYoIShiID0gY2RbYV0pKSB7XG4gICAgYiA9IG5ldyBWKGEpO1xuICAgIHZhciBjID0gYS5sYXN0SW5kZXhPZihcIi5cIiksIGQgPSBhLnN1YnN0cihjICsgMSksIGMgPSBlZChhLnN1YnN0cigwLCBjKSk7XG4gICAgYy5mYiB8fCAoYy5mYiA9IHt9KTtcbiAgICBjLmZiW2RdID0gYjtcbiAgICBiLlJhID0gYztcbiAgICBjZFthXSA9IGJcbiAgfVxuICByZXR1cm4gYlxufVxuO2Z1bmN0aW9uIFgoKSB7XG4gIHRoaXMucSA9IGVkKFwiZ29vZy5uZXQuQnJvd3NlckNoYW5uZWxcIilcbn1cbmZ1bmN0aW9uIHNjKGEsIGIsIGMsIGQpIHtcbiAgYS5pbmZvKFwiWE1MSFRUUCBURVhUIChcIiArIGIgKyBcIik6IFwiICsgRWMoYSwgYykgKyAoZCA/IFwiIFwiICsgZCA6IFwiXCIpKVxufVxuWC5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbihhKSB7XG4gIHRoaXMuaW5mbyhhKVxufTtcbmZ1bmN0aW9uIHhjKGEsIGIsIGMpIHtcbiAgYS5JKChjIHx8IFwiRXhjZXB0aW9uXCIpICsgYilcbn1cblgucHJvdG90eXBlLmluZm8gPSBmdW5jdGlvbihhKSB7XG4gIHRoaXMucS5pbmZvKGEpXG59O1xuWC5wcm90b3R5cGUuJCA9IGZ1bmN0aW9uKGEpIHtcbiAgdGhpcy5xLiQoYSlcbn07XG5YLnByb3RvdHlwZS5JID0gZnVuY3Rpb24oYSkge1xuICB0aGlzLnEuSShhKVxufTtcbmZ1bmN0aW9uIEVjKGEsIGIpIHtcbiAgaWYoIWIgfHwgYiA9PSBmZCkge1xuICAgIHJldHVybiBiXG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIgYyA9IEpjKGIpO1xuICAgIGlmKGMpIHtcbiAgICAgIGZvcih2YXIgZCA9IDA7ZCA8IGMubGVuZ3RoO2QrKykge1xuICAgICAgICBpZihzKGNbZF0pKSB7XG4gICAgICAgICAgdmFyIGYgPSBjW2RdO1xuICAgICAgICAgIGlmKCEoMiA+IGYubGVuZ3RoKSkge1xuICAgICAgICAgICAgdmFyIGcgPSBmWzFdO1xuICAgICAgICAgICAgaWYocyhnKSAmJiAhKDEgPiBnLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgdmFyIGggPSBnWzBdO1xuICAgICAgICAgICAgICBpZihcIm5vb3BcIiAhPSBoICYmIFwic3RvcFwiICE9IGgpIHtcbiAgICAgICAgICAgICAgICBmb3IodmFyIG4gPSAxO24gPCBnLmxlbmd0aDtuKyspIHtcbiAgICAgICAgICAgICAgICAgIGdbbl0gPSBcIlwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBLYyhjKVxuICB9Y2F0Y2goaykge1xuICAgIHJldHVybiBhLmRlYnVnKFwiRXhjZXB0aW9uIHBhcnNpbmcgZXhwZWN0ZWQgSlMgYXJyYXkgLSBwcm9iYWJseSB3YXMgbm90IEpTXCIpLCBiXG4gIH1cbn1cbjtmdW5jdGlvbiBnZChhLCBiKSB7XG4gIHRoaXMuT2MgPSBuZXcgTWMoYSk7XG4gIHRoaXMuUCA9IGIgPyBKYyA6IEljXG59XG5nZC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihhKSB7XG4gIHJldHVybiB0aGlzLlAoYSlcbn07XG52YXIgbWMgPSA3LCBuYyA9IDg7XG5mdW5jdGlvbiBoZChhKSB7XG4gIE0uY2FsbCh0aGlzKTtcbiAgdGhpcy5oZWFkZXJzID0gbmV3IGJiO1xuICB0aGlzLnZhID0gYSB8fCBudWxsXG59XG55KGhkLCBTYik7XG5oZC5wcm90b3R5cGUucSA9IGVkKFwiZ29vZy5uZXQuWGhySW9cIik7XG52YXIgaWQgPSAvXmh0dHBzPyQvaTtcbnAgPSBoZC5wcm90b3R5cGU7XG5wLlMgPSAhMTtcbnAuZyA9IG51bGw7XG5wLmJiID0gbnVsbDtcbnAuUGEgPSBcIlwiO1xucC5KYiA9IFwiXCI7XG5wLmxhID0gMDtcbnAucCA9IFwiXCI7XG5wLmliID0gITE7XG5wLk5hID0gITE7XG5wLm1iID0gITE7XG5wLmNhID0gITE7XG5wLiRhID0gMDtcbnAuZmEgPSBudWxsO1xucC5XYiA9IFwiXCI7XG5wLmNjID0gITE7XG5wLnNlbmQgPSBmdW5jdGlvbihhLCBiLCBjLCBkKSB7XG4gIGlmKHRoaXMuZykge1xuICAgIHRocm93IEVycm9yKFwiW2dvb2cubmV0LlhocklvXSBPYmplY3QgaXMgYWN0aXZlIHdpdGggYW5vdGhlciByZXF1ZXN0PVwiICsgdGhpcy5QYSArIFwiOyBuZXdVcmk9XCIgKyBhKTtcbiAgfVxuICBiID0gYiA/IGIudG9VcHBlckNhc2UoKSA6IFwiR0VUXCI7XG4gIHRoaXMuUGEgPSBhO1xuICB0aGlzLnAgPSBcIlwiO1xuICB0aGlzLmxhID0gMDtcbiAgdGhpcy5KYiA9IGI7XG4gIHRoaXMuaWIgPSAhMTtcbiAgdGhpcy5TID0gITA7XG4gIHRoaXMuZyA9IHRoaXMudmEgPyB4Yih0aGlzLnZhKSA6IHhiKHZiKTtcbiAgdGhpcy5iYiA9IHRoaXMudmEgPyB0aGlzLnZhLkdhIHx8ICh0aGlzLnZhLkdhID0gemIodGhpcy52YSkpIDogdmIuR2EgfHwgKHZiLkdhID0gemIodmIpKTtcbiAgdGhpcy5nLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHcodGhpcy5PYiwgdGhpcyk7XG4gIHRyeSB7XG4gICAgVyh0aGlzLnEsIFkodGhpcywgXCJPcGVuaW5nIFhoclwiKSksIHRoaXMubWIgPSAhMCwgdGhpcy5nLm9wZW4oYiwgYSwgITApLCB0aGlzLm1iID0gITFcbiAgfWNhdGNoKGYpIHtcbiAgICBXKHRoaXMucSwgWSh0aGlzLCBcIkVycm9yIG9wZW5pbmcgWGhyOiBcIiArIGYubWVzc2FnZSkpO1xuICAgIGpkKHRoaXMsIGYpO1xuICAgIHJldHVyblxuICB9XG4gIGEgPSBjIHx8IFwiXCI7XG4gIHZhciBnID0gdGhpcy5oZWFkZXJzLm4oKTtcbiAgZCAmJiBFKGQsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBnLnNldChiLCBhKVxuICB9KTtcbiAgZCA9IHEuRm9ybURhdGEgJiYgYSBpbnN0YW5jZW9mIHEuRm9ybURhdGE7XG4gIFwiUE9TVFwiICE9IGIgfHwgKGcuaWEoXCJDb250ZW50LVR5cGVcIikgfHwgZCkgfHwgZy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOFwiKTtcbiAgRShnLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgdGhpcy5nLnNldFJlcXVlc3RIZWFkZXIoYiwgYSlcbiAgfSwgdGhpcyk7XG4gIHRoaXMuV2IgJiYgKHRoaXMuZy5yZXNwb25zZVR5cGUgPSB0aGlzLldiKTtcbiAgXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB0aGlzLmcgJiYgKHRoaXMuZy53aXRoQ3JlZGVudGlhbHMgPSB0aGlzLmNjKTtcbiAgdHJ5IHtcbiAgICB0aGlzLmZhICYmIChxLmNsZWFyVGltZW91dCh0aGlzLmZhKSwgdGhpcy5mYSA9IG51bGwpLCAwIDwgdGhpcy4kYSAmJiAoVyh0aGlzLnEsIFkodGhpcywgXCJXaWxsIGFib3J0IGFmdGVyIFwiICsgdGhpcy4kYSArIFwibXMgaWYgaW5jb21wbGV0ZVwiKSksIHRoaXMuZmEgPSBxLnNldFRpbWVvdXQodyh0aGlzLkRhLCB0aGlzKSwgdGhpcy4kYSkpLCBXKHRoaXMucSwgWSh0aGlzLCBcIlNlbmRpbmcgcmVxdWVzdFwiKSksIHRoaXMuTmEgPSAhMCwgdGhpcy5nLnNlbmQoYSksIHRoaXMuTmEgPSAhMVxuICB9Y2F0Y2goaCkge1xuICAgIFcodGhpcy5xLCBZKHRoaXMsIFwiU2VuZCBlcnJvcjogXCIgKyBoLm1lc3NhZ2UpKSwgamQodGhpcywgaClcbiAgfVxufTtcbnAuRGEgPSBmdW5jdGlvbigpIHtcbiAgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgY2EgJiYgdGhpcy5nICYmICh0aGlzLnAgPSBcIlRpbWVkIG91dCBhZnRlciBcIiArIHRoaXMuJGEgKyBcIm1zLCBhYm9ydGluZ1wiLCB0aGlzLmxhID0gbmMsIFcodGhpcy5xLCBZKHRoaXMsIHRoaXMucCkpLCB0aGlzLmRpc3BhdGNoRXZlbnQoXCJ0aW1lb3V0XCIpLCB0aGlzLmFib3J0KG5jKSlcbn07XG5mdW5jdGlvbiBqZChhLCBiKSB7XG4gIGEuUyA9ICExO1xuICBhLmcgJiYgKGEuY2EgPSAhMCwgYS5nLmFib3J0KCksIGEuY2EgPSAhMSk7XG4gIGEucCA9IGI7XG4gIGEubGEgPSA1O1xuICBrZChhKTtcbiAgbGQoYSlcbn1cbmZ1bmN0aW9uIGtkKGEpIHtcbiAgYS5pYiB8fCAoYS5pYiA9ICEwLCBhLmRpc3BhdGNoRXZlbnQoXCJjb21wbGV0ZVwiKSwgYS5kaXNwYXRjaEV2ZW50KFwiZXJyb3JcIikpXG59XG5wLmFib3J0ID0gZnVuY3Rpb24oYSkge1xuICB0aGlzLmcgJiYgdGhpcy5TICYmIChXKHRoaXMucSwgWSh0aGlzLCBcIkFib3J0aW5nXCIpKSwgdGhpcy5TID0gITEsIHRoaXMuY2EgPSAhMCwgdGhpcy5nLmFib3J0KCksIHRoaXMuY2EgPSAhMSwgdGhpcy5sYSA9IGEgfHwgbWMsIHRoaXMuZGlzcGF0Y2hFdmVudChcImNvbXBsZXRlXCIpLCB0aGlzLmRpc3BhdGNoRXZlbnQoXCJhYm9ydFwiKSwgbGQodGhpcykpXG59O1xucC51ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZyAmJiAodGhpcy5TICYmICh0aGlzLlMgPSAhMSwgdGhpcy5jYSA9ICEwLCB0aGlzLmcuYWJvcnQoKSwgdGhpcy5jYSA9ICExKSwgbGQodGhpcywgITApKTtcbiAgaGQucmEudS5jYWxsKHRoaXMpXG59O1xucC5PYiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLm1iIHx8IHRoaXMuTmEgfHwgdGhpcy5jYSA/IG1kKHRoaXMpIDogdGhpcy5zYygpXG59O1xucC5zYyA9IGZ1bmN0aW9uKCkge1xuICBtZCh0aGlzKVxufTtcbmZ1bmN0aW9uIG1kKGEpIHtcbiAgaWYoYS5TICYmIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGNhKSB7XG4gICAgaWYoYS5iYlsxXSAmJiA0ID09IFIoYSkgJiYgMiA9PSBrYyhhKSkge1xuICAgICAgVyhhLnEsIFkoYSwgXCJMb2NhbCByZXF1ZXN0IGVycm9yIGRldGVjdGVkIGFuZCBpZ25vcmVkXCIpKVxuICAgIH1lbHNlIHtcbiAgICAgIGlmKGEuTmEgJiYgNCA9PSBSKGEpKSB7XG4gICAgICAgIHEuc2V0VGltZW91dCh3KGEuT2IsIGEpLCAwKVxuICAgICAgfWVsc2Uge1xuICAgICAgICBpZihhLmRpc3BhdGNoRXZlbnQoXCJyZWFkeXN0YXRlY2hhbmdlXCIpLCA0ID09IFIoYSkpIHtcbiAgICAgICAgICBXKGEucSwgWShhLCBcIlJlcXVlc3QgY29tcGxldGVcIikpO1xuICAgICAgICAgIGEuUyA9ICExO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgYiA9IGtjKGEpLCBjLCBkO1xuICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICBzd2l0Y2goYikge1xuICAgICAgICAgICAgICAgIGNhc2UgMjAwOlxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBjYXNlIDIwMTpcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgY2FzZSAyMDI6XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGNhc2UgMjA0OlxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBjYXNlIDIwNjpcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgY2FzZSAzMDQ6XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGNhc2UgMTIyMzpcbiAgICAgICAgICAgICAgICAgIGQgPSAhMDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIGQgPSAhMVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZighKGMgPSBkKSkge1xuICAgICAgICAgICAgICB2YXIgZjtcbiAgICAgICAgICAgICAgaWYoZiA9IDAgPT09IGIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZyA9IFN0cmluZyhhLlBhKS5tYXRjaChRYSlbMV0gfHwgbnVsbDtcbiAgICAgICAgICAgICAgICBpZighZyAmJiBzZWxmLmxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaCA9IHNlbGYubG9jYXRpb24ucHJvdG9jb2wsIGcgPSBoLnN1YnN0cigwLCBoLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGYgPSAhaWQudGVzdChnID8gZy50b0xvd2VyQ2FzZSgpIDogXCJcIilcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjID0gZlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoYykge1xuICAgICAgICAgICAgICBhLmRpc3BhdGNoRXZlbnQoXCJjb21wbGV0ZVwiKSwgYS5kaXNwYXRjaEV2ZW50KFwic3VjY2Vzc1wiKVxuICAgICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgICBhLmxhID0gNjtcbiAgICAgICAgICAgICAgdmFyIG47XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbiA9IDIgPCBSKGEpID8gYS5nLnN0YXR1c1RleHQgOiBcIlwiXG4gICAgICAgICAgICAgIH1jYXRjaChrKSB7XG4gICAgICAgICAgICAgICAgVyhhLnEsIFwiQ2FuIG5vdCBnZXQgc3RhdHVzOiBcIiArIGsubWVzc2FnZSksIG4gPSBcIlwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYS5wID0gbiArIFwiIFtcIiArIGtjKGEpICsgXCJdXCI7XG4gICAgICAgICAgICAgIGtkKGEpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfWZpbmFsbHkge1xuICAgICAgICAgICAgbGQoYSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGxkKGEsIGIpIHtcbiAgaWYoYS5nKSB7XG4gICAgdmFyIGMgPSBhLmcsIGQgPSBhLmJiWzBdID8gZWEgOiBudWxsO1xuICAgIGEuZyA9IG51bGw7XG4gICAgYS5iYiA9IG51bGw7XG4gICAgYS5mYSAmJiAocS5jbGVhclRpbWVvdXQoYS5mYSksIGEuZmEgPSBudWxsKTtcbiAgICBiIHx8IGEuZGlzcGF0Y2hFdmVudChcInJlYWR5XCIpO1xuICAgIHRyeSB7XG4gICAgICBjLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGRcbiAgICB9Y2F0Y2goZikge1xuICAgICAgYS5xLkkoXCJQcm9ibGVtIGVuY291bnRlcmVkIHJlc2V0dGluZyBvbnJlYWR5c3RhdGVjaGFuZ2U6IFwiICsgZi5tZXNzYWdlKVxuICAgIH1cbiAgfVxufVxucC5pc0FjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4hIXRoaXMuZ1xufTtcbmZ1bmN0aW9uIFIoYSkge1xuICByZXR1cm4gYS5nID8gYS5nLnJlYWR5U3RhdGUgOiAwXG59XG5mdW5jdGlvbiBrYyhhKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIDIgPCBSKGEpID8gYS5nLnN0YXR1cyA6IC0xXG4gIH1jYXRjaChiKSB7XG4gICAgcmV0dXJuIGEucS4kKFwiQ2FuIG5vdCBnZXQgc3RhdHVzOiBcIiArIGIubWVzc2FnZSksIC0xXG4gIH1cbn1cbmZ1bmN0aW9uIGxjKGEpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYS5nID8gYS5nLnJlc3BvbnNlVGV4dCA6IFwiXCJcbiAgfWNhdGNoKGIpIHtcbiAgICByZXR1cm4gVyhhLnEsIFwiQ2FuIG5vdCBnZXQgcmVzcG9uc2VUZXh0OiBcIiArIGIubWVzc2FnZSksIFwiXCJcbiAgfVxufVxucC5FYiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdSh0aGlzLnApID8gdGhpcy5wIDogU3RyaW5nKHRoaXMucClcbn07XG5mdW5jdGlvbiBZKGEsIGIpIHtcbiAgcmV0dXJuIGIgKyBcIiBbXCIgKyBhLkpiICsgXCIgXCIgKyBhLlBhICsgXCIgXCIgKyBrYyhhKSArIFwiXVwiXG59XG47ZnVuY3Rpb24gbmQoKSB7XG4gIHRoaXMuVmIgPSB4KClcbn1cbm5ldyBuZDtcbm5kLnByb3RvdHlwZS5zZXQgPSBtKFwiVmJcIik7XG5uZC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zZXQoeCgpKVxufTtcbm5kLnByb3RvdHlwZS5nZXQgPSBhYShcIlZiXCIpO1xuZnVuY3Rpb24gb2QoYSwgYiwgYywgZCwgZikge1xuICAobmV3IFgpLmRlYnVnKFwiVGVzdExvYWRJbWFnZVdpdGhSZXRyaWVzOiBcIiArIGYpO1xuICBpZigwID09IGQpIHtcbiAgICBjKCExKVxuICB9ZWxzZSB7XG4gICAgdmFyIGcgPSBmIHx8IDA7XG4gICAgZC0tO1xuICAgIHBkKGEsIGIsIGZ1bmN0aW9uKGYpIHtcbiAgICAgIGYgPyBjKCEwKSA6IHEuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgb2QoYSwgYiwgYywgZCwgZylcbiAgICAgIH0sIGcpXG4gICAgfSlcbiAgfVxufVxuZnVuY3Rpb24gcGQoYSwgYiwgYykge1xuICBmdW5jdGlvbiBkKGEsIGIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmLmRlYnVnKFwiVGVzdExvYWRJbWFnZTogXCIgKyBiKSwgZy5vbmxvYWQgPSBudWxsLCBnLm9uZXJyb3IgPSBudWxsLCBnLm9uYWJvcnQgPSBudWxsLCBnLm9udGltZW91dCA9IG51bGwsIHEuY2xlYXJUaW1lb3V0KGgpLCBjKGEpXG4gICAgICB9Y2F0Y2goZCkge1xuICAgICAgICB4YyhmLCBkKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgZiA9IG5ldyBYO1xuICBmLmRlYnVnKFwiVGVzdExvYWRJbWFnZTogbG9hZGluZyBcIiArIGEpO1xuICB2YXIgZyA9IG5ldyBJbWFnZSwgaCA9IG51bGw7XG4gIGcub25sb2FkID0gZCghMCwgXCJsb2FkZWRcIik7XG4gIGcub25lcnJvciA9IGQoITEsIFwiZXJyb3JcIik7XG4gIGcub25hYm9ydCA9IGQoITEsIFwiYWJvcnRcIik7XG4gIGcub250aW1lb3V0ID0gZCghMSwgXCJ0aW1lb3V0XCIpO1xuICBoID0gcS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGlmKGcub250aW1lb3V0KSB7XG4gICAgICBnLm9udGltZW91dCgpXG4gICAgfVxuICB9LCBiKTtcbiAgZy5zcmMgPSBhXG59XG47ZnVuY3Rpb24gcWQoYSwgYikge1xuICB0aGlzLmIgPSBhO1xuICB0aGlzLmEgPSBiO1xuICB0aGlzLlAgPSBuZXcgZ2QobnVsbCwgITApXG59XG5wID0gcWQucHJvdG90eXBlO1xucC52ID0gbnVsbDtcbnAuQSA9IG51bGw7XG5wLlVhID0gITE7XG5wLmFjID0gbnVsbDtcbnAuS2EgPSBudWxsO1xucC5uYiA9IG51bGw7XG5wLkggPSBudWxsO1xucC5jID0gbnVsbDtcbnAuaCA9IC0xO1xucC5MID0gbnVsbDtcbnAud2EgPSBudWxsO1xucC5ZID0gbShcInZcIik7XG5wLlpiID0gbShcIlBcIik7XG5wLmdiID0gZnVuY3Rpb24oYSkge1xuICB0aGlzLkggPSBhO1xuICBhID0gcmQodGhpcy5iLCB0aGlzLkgpO1xuICBUKHNkKTtcbiAgdGhpcy5hYyA9IHgoKTtcbiAgdmFyIGIgPSB0aGlzLmIuQ2I7XG4gIG51bGwgIT0gYiA/ICh0aGlzLkwgPSB0aGlzLmIuY29ycmVjdEhvc3RQcmVmaXgoYlswXSksICh0aGlzLndhID0gYlsxXSkgPyAodGhpcy5jID0gMSwgdGQodGhpcykpIDogKHRoaXMuYyA9IDIsIHVkKHRoaXMpKSkgOiAocWIoYSwgXCJNT0RFXCIsIFwiaW5pdFwiKSwgdGhpcy5BID0gbmV3IFEodGhpcywgdGhpcy5hLCB2b2lkIDAsIHZvaWQgMCwgdm9pZCAwKSwgdGhpcy5BLlkodGhpcy52KSwgaGModGhpcy5BLCBhLCAhMSwgbnVsbCwgITApLCB0aGlzLmMgPSAwKVxufTtcbmZ1bmN0aW9uIHRkKGEpIHtcbiAgdmFyIGIgPSB2ZChhLmIsIGEud2EsIFwiL21haWwvaW1hZ2VzL2NsZWFyZG90LmdpZlwiKTtcbiAgSihiKTtcbiAgb2QoYi50b1N0cmluZygpLCA1RTMsIHcoYS5pYywgYSksIDMsIDJFMyk7XG4gIGEuRyhqYylcbn1cbnAuaWMgPSBmdW5jdGlvbihhKSB7XG4gIGlmKGEpIHtcbiAgICB0aGlzLmMgPSAyLCB1ZCh0aGlzKVxuICB9ZWxzZSB7XG4gICAgVCh3ZCk7XG4gICAgdmFyIGIgPSB0aGlzLmI7XG4gICAgYi5hLmRlYnVnKFwiVGVzdCBDb25uZWN0aW9uIEJsb2NrZWRcIik7XG4gICAgYi5oID0gYi5VLmg7XG4gICAgWihiLCA5KVxuICB9XG4gIGEgJiYgdGhpcy5HKHBjKVxufTtcbmZ1bmN0aW9uIHVkKGEpIHtcbiAgYS5hLmRlYnVnKFwiVGVzdENvbm5lY3Rpb246IHN0YXJ0aW5nIHN0YWdlIDJcIik7XG4gIGEuQSA9IG5ldyBRKGEsIGEuYSwgdm9pZCAwLCB2b2lkIDAsIHZvaWQgMCk7XG4gIGEuQS5ZKGEudik7XG4gIHZhciBiID0geGQoYS5iLCBhLkwsIGEuSCk7XG4gIFQoeWQpO1xuICBpZihlYygpKSB7XG4gICAgcWIoYiwgXCJUWVBFXCIsIFwieG1saHR0cFwiKSwgaGMoYS5BLCBiLCAhMSwgYS5MLCAhMSlcbiAgfWVsc2Uge1xuICAgIHFiKGIsIFwiVFlQRVwiLCBcImh0bWxcIik7XG4gICAgdmFyIGMgPSBhLkE7XG4gICAgYSA9IEJvb2xlYW4oYS5MKTtcbiAgICBjLnNhID0gMztcbiAgICBjLlQgPSBKKGIubigpKTtcbiAgICBDYyhjLCBhKVxuICB9XG59XG5wLmhiID0gZnVuY3Rpb24oYSkge1xuICByZXR1cm4gdGhpcy5iLmhiKGEpXG59O1xucC5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLkEgJiYgKHRoaXMuQS5jYW5jZWwoKSwgdGhpcy5BID0gbnVsbCk7XG4gIHRoaXMuaCA9IC0xXG59O1xucC5IYiA9IGJhKCExKTtcbnAuUGIgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHRoaXMuaCA9IGEuaDtcbiAgaWYoMCA9PSB0aGlzLmMpIHtcbiAgICBpZih0aGlzLmEuZGVidWcoXCJUZXN0Q29ubmVjdGlvbjogR290IGRhdGEgZm9yIHN0YWdlIDFcIiksIGIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5QLnBhcnNlKGIpXG4gICAgICB9Y2F0Y2goZCkge1xuICAgICAgICB4Yyh0aGlzLmEsIGQpO1xuICAgICAgICB6ZCh0aGlzLmIsIHRoaXMpO1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRoaXMuTCA9IHRoaXMuYi5jb3JyZWN0SG9zdFByZWZpeChjWzBdKTtcbiAgICAgIHRoaXMud2EgPSBjWzFdXG4gICAgfWVsc2Uge1xuICAgICAgdGhpcy5hLmRlYnVnKFwiVGVzdENvbm5lY3Rpb246IE51bGwgcmVzcG9uc2VUZXh0XCIpLCB6ZCh0aGlzLmIsIHRoaXMpXG4gICAgfVxuICB9ZWxzZSB7XG4gICAgaWYoMiA9PSB0aGlzLmMpIHtcbiAgICAgIGlmKHRoaXMuVWEpIHtcbiAgICAgICAgVChBZCksIHRoaXMubmIgPSB4KClcbiAgICAgIH1lbHNlIHtcbiAgICAgICAgaWYoXCIxMTExMVwiID09IGIpIHtcbiAgICAgICAgICBpZihUKEJkKSwgdGhpcy5VYSA9ICEwLCB0aGlzLkthID0geCgpLCBjID0gdGhpcy5LYSAtIHRoaXMuYWMsIGVjKCkgfHwgNTAwID4gYykge1xuICAgICAgICAgICAgdGhpcy5oID0gMjAwLCB0aGlzLkEuY2FuY2VsKCksIHRoaXMuYS5kZWJ1ZyhcIlRlc3QgY29ubmVjdGlvbiBzdWNjZWVkZWQ7IHVzaW5nIHN0cmVhbWluZyBjb25uZWN0aW9uXCIpLCBUKENkKSwgRGQodGhpcy5iLCB0aGlzLCAhMClcbiAgICAgICAgICB9XG4gICAgICAgIH1lbHNlIHtcbiAgICAgICAgICBUKEVkKSwgdGhpcy5LYSA9IHRoaXMubmIgPSB4KCksIHRoaXMuVWEgPSAhMVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xucC5tYSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmggPSB0aGlzLkEuaDtcbiAgaWYoIXRoaXMuQS5KKSB7XG4gICAgdGhpcy5hLmRlYnVnKFwiVGVzdENvbm5lY3Rpb246IHJlcXVlc3QgZmFpbGVkLCBpbiBzdGF0ZSBcIiArIHRoaXMuYyksIDAgPT0gdGhpcy5jID8gVChGZCkgOiAyID09IHRoaXMuYyAmJiBUKEdkKSwgemQodGhpcy5iLCB0aGlzKVxuICB9ZWxzZSB7XG4gICAgaWYoMCA9PSB0aGlzLmMpIHtcbiAgICAgIHRoaXMuYS5kZWJ1ZyhcIlRlc3RDb25uZWN0aW9uOiByZXF1ZXN0IGNvbXBsZXRlIGZvciBpbml0aWFsIGNoZWNrXCIpLCB0aGlzLndhID8gKHRoaXMuYyA9IDEsIHRkKHRoaXMpKSA6ICh0aGlzLmMgPSAyLCB1ZCh0aGlzKSlcbiAgICB9ZWxzZSB7XG4gICAgICBpZigyID09IHRoaXMuYykge1xuICAgICAgICB0aGlzLmEuZGVidWcoXCJUZXN0Q29ubmVjdGlvbjogcmVxdWVzdCBjb21wbGV0ZSBmb3Igc3RhZ2UgMlwiKTtcbiAgICAgICAgdmFyIGEgPSAhMTtcbiAgICAgICAgKGEgPSBlYygpID8gdGhpcy5VYSA6IDIwMCA+IHRoaXMubmIgLSB0aGlzLkthID8gITEgOiAhMCkgPyAodGhpcy5hLmRlYnVnKFwiVGVzdCBjb25uZWN0aW9uIHN1Y2NlZWRlZDsgdXNpbmcgc3RyZWFtaW5nIGNvbm5lY3Rpb25cIiksIFQoQ2QpLCBEZCh0aGlzLmIsIHRoaXMsICEwKSkgOiAodGhpcy5hLmRlYnVnKFwiVGVzdCBjb25uZWN0aW9uIGZhaWxlZDsgbm90IHVzaW5nIHN0cmVhbWluZ1wiKSwgVChIZCksIERkKHRoaXMuYiwgdGhpcywgITEpKVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnAuWWEgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuYi5ZYSgpXG59O1xucC5pc0FjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5iLmlzQWN0aXZlKClcbn07XG5wLkcgPSBmdW5jdGlvbihhKSB7XG4gIHRoaXMuYi5HKGEpXG59O1xuZnVuY3Rpb24gSWQoYSwgYikge1xuICB0aGlzLnZiID0gYSB8fCBudWxsO1xuICB0aGlzLmMgPSBKZDtcbiAgdGhpcy5zID0gW107XG4gIHRoaXMuUSA9IFtdO1xuICB0aGlzLmEgPSBuZXcgWDtcbiAgdGhpcy5QID0gbmV3IGdkKG51bGwsICEwKTtcbiAgdGhpcy5DYiA9IGIgfHwgbnVsbFxufVxuZnVuY3Rpb24gS2QoYSwgYikge1xuICB0aGlzLkxiID0gYTtcbiAgdGhpcy5tYXAgPSBiO1xuICB0aGlzLkZjID0gbnVsbFxufVxucCA9IElkLnByb3RvdHlwZTtcbnAudiA9IG51bGw7XG5wLnhhID0gbnVsbDtcbnAubyA9IG51bGw7XG5wLmsgPSBudWxsO1xucC5IID0gbnVsbDtcbnAuTGEgPSBudWxsO1xucC51YiA9IG51bGw7XG5wLkwgPSBudWxsO1xucC5mYyA9ICEwO1xucC5BYSA9IDA7XG5wLnFjID0gMDtcbnAuSmEgPSAhMTtcbnAuZSA9IG51bGw7XG5wLkYgPSBudWxsO1xucC5NID0gbnVsbDtcbnAuYmEgPSBudWxsO1xucC5VID0gbnVsbDtcbnAucmIgPSBudWxsO1xucC5lYyA9ICEwO1xucC55YSA9IC0xO1xucC5LYiA9IC0xO1xucC5oID0gLTE7XG5wLlYgPSAwO1xucC5nYSA9IDA7XG5wLmdjID0gNUUzO1xucC5CYyA9IDFFNDtcbnAua2IgPSAyO1xucC5EYiA9IDJFNDtcbnAub2EgPSAwO1xucC5aYSA9ICExO1xucC5oYSA9IDg7XG52YXIgSmQgPSAxLCBMZCA9IG5ldyBTYjtcbmZ1bmN0aW9uIE1kKGEsIGIpIHtcbiAgTi5jYWxsKHRoaXMsIFwic3RhdGV2ZW50XCIsIGEpO1xuICB0aGlzLlBjID0gYlxufVxueShNZCwgTik7XG5mdW5jdGlvbiBOZChhLCBiLCBjLCBkKSB7XG4gIE4uY2FsbCh0aGlzLCBcInRpbWluZ2V2ZW50XCIsIGEpO1xuICB0aGlzLnNpemUgPSBiO1xuICB0aGlzLk5jID0gYztcbiAgdGhpcy5NYyA9IGRcbn1cbnkoTmQsIE4pO1xudmFyIGpjID0gMSwgcGMgPSAyLCBvYyA9IDMsIEZjID0gNDtcbmZ1bmN0aW9uIE9kKGEsIGIpIHtcbiAgTi5jYWxsKHRoaXMsIFwic2VydmVycmVhY2hhYmlsaXR5XCIsIGEpO1xuICB0aGlzLkxjID0gYlxufVxueShPZCwgTik7XG52YXIgc2QgPSAzLCB3ZCA9IDQsIHlkID0gNSwgQmQgPSA2LCBBZCA9IDcsIEVkID0gOCwgRmQgPSA5LCBHZCA9IDEwLCBIZCA9IDExLCBDZCA9IDEyLCB1YyA9IDEzLCB2YyA9IDE0LCB6YyA9IDE1LCBBYyA9IDE2LCBCYyA9IDE3LCBIYyA9IDE4LCBEYyA9IDIyLCBmZCA9IFwieTJmJVwiO1xucCA9IElkLnByb3RvdHlwZTtcbnAuZ2IgPSBmdW5jdGlvbihhLCBiLCBjLCBkLCBmKSB7XG4gIHRoaXMuYS5kZWJ1ZyhcImNvbm5lY3QoKVwiKTtcbiAgVCgwKTtcbiAgdGhpcy5IID0gYjtcbiAgdGhpcy54YSA9IGMgfHwge307XG4gIGQgJiYgdm9pZCAwICE9PSBmICYmICh0aGlzLnhhLk9TSUQgPSBkLCB0aGlzLnhhLk9BSUQgPSBmKTtcbiAgdGhpcy5hLmRlYnVnKFwiY29ubmVjdFRlc3RfKClcIik7XG4gIFBkKHRoaXMpICYmICh0aGlzLlUgPSBuZXcgcWQodGhpcywgdGhpcy5hKSwgdGhpcy5VLlkodGhpcy52KSwgdGhpcy5VLlpiKHRoaXMuUCksIHRoaXMuVS5nYihhKSlcbn07XG5wLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5hLmRlYnVnKFwiZGlzY29ubmVjdCgpXCIpO1xuICBRZCh0aGlzKTtcbiAgaWYoMyA9PSB0aGlzLmMpIHtcbiAgICB2YXIgYSA9IHRoaXMuQWErKywgYiA9IHRoaXMuTGEubigpO1xuICAgIEkoYiwgXCJTSURcIiwgdGhpcy5aKTtcbiAgICBJKGIsIFwiUklEXCIsIGEpO1xuICAgIEkoYiwgXCJUWVBFXCIsIFwidGVybWluYXRlXCIpO1xuICAgIFJkKHRoaXMsIGIpO1xuICAgIGEgPSBuZXcgUSh0aGlzLCB0aGlzLmEsIHRoaXMuWiwgYSwgdm9pZCAwKTtcbiAgICBhLnNhID0gMjtcbiAgICBhLlQgPSBKKGIubigpKTtcbiAgICBiID0gbmV3IEltYWdlO1xuICAgIGIuc3JjID0gYS5UO1xuICAgIGIub25sb2FkID0gYi5vbmVycm9yID0gdyhhLmxjLCBhKTtcbiAgICBhLnBhID0geCgpO1xuICAgIGljKGEpXG4gIH1cbiAgVGQodGhpcylcbn07XG5mdW5jdGlvbiBRZChhKSB7XG4gIGEuVSAmJiAoYS5VLmFib3J0KCksIGEuVSA9IG51bGwpO1xuICBhLmsgJiYgKGEuay5jYW5jZWwoKSwgYS5rID0gbnVsbCk7XG4gIGEuTSAmJiAocS5jbGVhclRpbWVvdXQoYS5NKSwgYS5NID0gbnVsbCk7XG4gIFVkKGEpO1xuICBhLm8gJiYgKGEuby5jYW5jZWwoKSwgYS5vID0gbnVsbCk7XG4gIGEuRiAmJiAocS5jbGVhclRpbWVvdXQoYS5GKSwgYS5GID0gbnVsbClcbn1cbnAuWSA9IG0oXCJ2XCIpO1xucC4kYiA9IG0oXCJvYVwiKTtcbnAuSGIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIDAgPT0gdGhpcy5jXG59O1xucC5aYiA9IG0oXCJQXCIpO1xuZnVuY3Rpb24gVmQoYSkge1xuICBhLm8gfHwgYS5GIHx8IChhLkYgPSBVKHcoYS5SYiwgYSksIDApLCBhLlYgPSAwKVxufVxucC5SYiA9IGZ1bmN0aW9uKGEpIHtcbiAgdGhpcy5GID0gbnVsbDtcbiAgdGhpcy5hLmRlYnVnKFwic3RhcnRGb3J3YXJkQ2hhbm5lbF9cIik7XG4gIGlmKFBkKHRoaXMpKSB7XG4gICAgaWYodGhpcy5jID09IEpkKSB7XG4gICAgICBpZihhKSB7XG4gICAgICAgIHRoaXMuYS5JKFwiTm90IHN1cHBvc2VkIHRvIHJldHJ5IHRoZSBvcGVuXCIpXG4gICAgICB9ZWxzZSB7XG4gICAgICAgIHRoaXMuYS5kZWJ1ZyhcIm9wZW5fKClcIik7XG4gICAgICAgIHRoaXMuQWEgPSBNYXRoLmZsb29yKDFFNSAqIE1hdGgucmFuZG9tKCkpO1xuICAgICAgICBhID0gdGhpcy5BYSsrO1xuICAgICAgICB2YXIgYiA9IG5ldyBRKHRoaXMsIHRoaXMuYSwgXCJcIiwgYSwgdm9pZCAwKTtcbiAgICAgICAgYi5ZKHRoaXMudik7XG4gICAgICAgIHZhciBjID0gV2QodGhpcyksIGQgPSB0aGlzLkxhLm4oKTtcbiAgICAgICAgSShkLCBcIlJJRFwiLCBhKTtcbiAgICAgICAgdGhpcy52YiAmJiBJKGQsIFwiQ1ZFUlwiLCB0aGlzLnZiKTtcbiAgICAgICAgUmQodGhpcywgZCk7XG4gICAgICAgIGZjKGIsIGQsIGMpO1xuICAgICAgICB0aGlzLm8gPSBiO1xuICAgICAgICB0aGlzLmMgPSAyXG4gICAgICB9XG4gICAgfWVsc2Uge1xuICAgICAgMyA9PSB0aGlzLmMgJiYgKGEgPyBYZCh0aGlzLCBhKSA6IDAgPT0gdGhpcy5zLmxlbmd0aCA/IHRoaXMuYS5kZWJ1ZyhcInN0YXJ0Rm9yd2FyZENoYW5uZWxfIHJldHVybmVkOiBub3RoaW5nIHRvIHNlbmRcIikgOiB0aGlzLm8gPyB0aGlzLmEuSShcInN0YXJ0Rm9yd2FyZENoYW5uZWxfIHJldHVybmVkOiBjb25uZWN0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3NcIikgOiAoWGQodGhpcyksIHRoaXMuYS5kZWJ1ZyhcInN0YXJ0Rm9yd2FyZENoYW5uZWxfIGZpbmlzaGVkLCBzZW50IHJlcXVlc3RcIikpKVxuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIFhkKGEsIGIpIHtcbiAgdmFyIGMsIGQ7XG4gIGIgPyA2IDwgYS5oYSA/IChhLnMgPSBhLlEuY29uY2F0KGEucyksIGEuUS5sZW5ndGggPSAwLCBjID0gYS5BYSAtIDEsIGQgPSBXZChhKSkgOiAoYyA9IGIuQiwgZCA9IGIuWCkgOiAoYyA9IGEuQWErKywgZCA9IFdkKGEpKTtcbiAgdmFyIGYgPSBhLkxhLm4oKTtcbiAgSShmLCBcIlNJRFwiLCBhLlopO1xuICBJKGYsIFwiUklEXCIsIGMpO1xuICBJKGYsIFwiQUlEXCIsIGEueWEpO1xuICBSZChhLCBmKTtcbiAgYyA9IG5ldyBRKGEsIGEuYSwgYS5aLCBjLCBhLlYgKyAxKTtcbiAgYy5ZKGEudik7XG4gIGMuc2V0VGltZW91dChNYXRoLnJvdW5kKDAuNSAqIGEuRGIpICsgTWF0aC5yb3VuZCgwLjUgKiBhLkRiICogTWF0aC5yYW5kb20oKSkpO1xuICBhLm8gPSBjO1xuICBmYyhjLCBmLCBkKVxufVxuZnVuY3Rpb24gUmQoYSwgYikge1xuICBpZihhLmUpIHtcbiAgICB2YXIgYyA9IGEuZS5nZXRBZGRpdGlvbmFsUGFyYW1zKGEpO1xuICAgIGMgJiYgRShjLCBmdW5jdGlvbihhLCBjKSB7XG4gICAgICBJKGIsIGMsIGEpXG4gICAgfSlcbiAgfVxufVxuZnVuY3Rpb24gV2QoYSkge1xuICB2YXIgYiA9IE1hdGgubWluKGEucy5sZW5ndGgsIDFFMyksIGMgPSBbXCJjb3VudD1cIiArIGJdLCBkO1xuICA2IDwgYS5oYSAmJiAwIDwgYiA/IChkID0gYS5zWzBdLkxiLCBjLnB1c2goXCJvZnM9XCIgKyBkKSkgOiBkID0gMDtcbiAgZm9yKHZhciBmID0gMDtmIDwgYjtmKyspIHtcbiAgICB2YXIgZyA9IGEuc1tmXS5MYiwgaCA9IGEuc1tmXS5tYXAsIGcgPSA2ID49IGEuaGEgPyBmIDogZyAtIGQ7XG4gICAgdHJ5IHtcbiAgICAgIEUoaCwgZnVuY3Rpb24oYSwgYikge1xuICAgICAgICBjLnB1c2goXCJyZXFcIiArIGcgKyBcIl9cIiArIGIgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChhKSlcbiAgICAgIH0pXG4gICAgfWNhdGNoKG4pIHtcbiAgICAgIGMucHVzaChcInJlcVwiICsgZyArIFwiX3R5cGU9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoXCJfYmFkbWFwXCIpKSwgYS5lICYmIGEuZS5iYWRNYXBFcnJvcihhLCBoKVxuICAgIH1cbiAgfVxuICBhLlEgPSBhLlEuY29uY2F0KGEucy5zcGxpY2UoMCwgYikpO1xuICByZXR1cm4gYy5qb2luKFwiJlwiKVxufVxuZnVuY3Rpb24gWWQoYSkge1xuICBhLmsgfHwgYS5NIHx8IChhLnRiID0gMSwgYS5NID0gVSh3KGEuUWIsIGEpLCAwKSwgYS5nYSA9IDApXG59XG5mdW5jdGlvbiBaZChhKSB7XG4gIGlmKGEuayB8fCBhLk0pIHtcbiAgICByZXR1cm4gYS5hLkkoXCJSZXF1ZXN0IGFscmVhZHkgaW4gcHJvZ3Jlc3NcIiksICExXG4gIH1cbiAgaWYoMyA8PSBhLmdhKSB7XG4gICAgcmV0dXJuITFcbiAgfVxuICBhLmEuZGVidWcoXCJHb2luZyB0byByZXRyeSBHRVRcIik7XG4gIGEudGIrKztcbiAgYS5NID0gVSh3KGEuUWIsIGEpLCAkZChhLCBhLmdhKSk7XG4gIGEuZ2ErKztcbiAgcmV0dXJuITBcbn1cbnAuUWIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5NID0gbnVsbDtcbiAgaWYoUGQodGhpcykpIHtcbiAgICB0aGlzLmEuZGVidWcoXCJDcmVhdGluZyBuZXcgSHR0cFJlcXVlc3RcIik7XG4gICAgdGhpcy5rID0gbmV3IFEodGhpcywgdGhpcy5hLCB0aGlzLlosIFwicnBjXCIsIHRoaXMudGIpO1xuICAgIHRoaXMuay5ZKHRoaXMudik7XG4gICAgdGhpcy5rLiRiKHRoaXMub2EpO1xuICAgIHZhciBhID0gdGhpcy51Yi5uKCk7XG4gICAgSShhLCBcIlJJRFwiLCBcInJwY1wiKTtcbiAgICBJKGEsIFwiU0lEXCIsIHRoaXMuWik7XG4gICAgSShhLCBcIkNJXCIsIHRoaXMucmIgPyBcIjBcIiA6IFwiMVwiKTtcbiAgICBJKGEsIFwiQUlEXCIsIHRoaXMueWEpO1xuICAgIFJkKHRoaXMsIGEpO1xuICAgIGlmKGVjKCkpIHtcbiAgICAgIEkoYSwgXCJUWVBFXCIsIFwieG1saHR0cFwiKSwgaGModGhpcy5rLCBhLCAhMCwgdGhpcy5MLCAhMSlcbiAgICB9ZWxzZSB7XG4gICAgICBJKGEsIFwiVFlQRVwiLCBcImh0bWxcIik7XG4gICAgICB2YXIgYiA9IHRoaXMuaywgYyA9IEJvb2xlYW4odGhpcy5MKTtcbiAgICAgIGIuc2EgPSAzO1xuICAgICAgYi5UID0gSihhLm4oKSk7XG4gICAgICBDYyhiLCBjKVxuICAgIH1cbiAgICB0aGlzLmEuZGVidWcoXCJOZXcgUmVxdWVzdCBjcmVhdGVkXCIpXG4gIH1cbn07XG5mdW5jdGlvbiBQZChhKSB7XG4gIGlmKGEuZSkge1xuICAgIHZhciBiID0gYS5lLm9rVG9NYWtlUmVxdWVzdChhKTtcbiAgICBpZigwICE9IGIpIHtcbiAgICAgIHJldHVybiBhLmEuZGVidWcoXCJIYW5kbGVyIHJldHVybmVkIGVycm9yIGNvZGUgZnJvbSBva1RvTWFrZVJlcXVlc3RcIiksIFooYSwgYiksICExXG4gICAgfVxuICB9XG4gIHJldHVybiEwXG59XG5mdW5jdGlvbiBEZChhLCBiLCBjKSB7XG4gIGEuYS5kZWJ1ZyhcIlRlc3QgQ29ubmVjdGlvbiBGaW5pc2hlZFwiKTtcbiAgYS5yYiA9IGEuZWMgJiYgYztcbiAgYS5oID0gYi5oO1xuICBhLmEuZGVidWcoXCJjb25uZWN0Q2hhbm5lbF8oKVwiKTtcbiAgYS5qYyhKZCwgMCk7XG4gIGEuTGEgPSByZChhLCBhLkgpO1xuICBWZChhKVxufVxuZnVuY3Rpb24gemQoYSwgYikge1xuICBhLmEuZGVidWcoXCJUZXN0IENvbm5lY3Rpb24gRmFpbGVkXCIpO1xuICBhLmggPSBiLmg7XG4gIFooYSwgMilcbn1cbnAuUGIgPSBmdW5jdGlvbihhLCBiKSB7XG4gIGlmKDAgIT0gdGhpcy5jICYmICh0aGlzLmsgPT0gYSB8fCB0aGlzLm8gPT0gYSkpIHtcbiAgICBpZih0aGlzLmggPSBhLmgsIHRoaXMubyA9PSBhICYmIDMgPT0gdGhpcy5jKSB7XG4gICAgICBpZig3IDwgdGhpcy5oYSkge1xuICAgICAgICB2YXIgYztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjID0gdGhpcy5QLnBhcnNlKGIpXG4gICAgICAgIH1jYXRjaChkKSB7XG4gICAgICAgICAgYyA9IG51bGxcbiAgICAgICAgfVxuICAgICAgICBpZihzKGMpICYmIDMgPT0gYy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgZiA9IGM7XG4gICAgICAgICAgaWYoMCA9PSBmWzBdKSB7XG4gICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgIGlmKHRoaXMuYS5kZWJ1ZyhcIlNlcnZlciBjbGFpbXMgb3VyIGJhY2tjaGFubmVsIGlzIG1pc3NpbmcuXCIpLCB0aGlzLk0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmEuZGVidWcoXCJCdXQgd2UgYXJlIGN1cnJlbnRseSBzdGFydGluZyB0aGUgcmVxdWVzdC5cIilcbiAgICAgICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuaykge1xuICAgICAgICAgICAgICAgICAgaWYodGhpcy5rLnBhICsgM0UzIDwgdGhpcy5vLnBhKSB7XG4gICAgICAgICAgICAgICAgICAgIFVkKHRoaXMpLCB0aGlzLmsuY2FuY2VsKCksIHRoaXMuayA9IG51bGxcbiAgICAgICAgICAgICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgYVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuYS4kKFwiV2UgZG8gbm90IGhhdmUgYSBCYWNrQ2hhbm5lbCBlc3RhYmxpc2hlZFwiKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBaZCh0aGlzKTtcbiAgICAgICAgICAgICAgICBUKDE5KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgdGhpcy5LYiA9IGZbMV0sIGMgPSB0aGlzLktiIC0gdGhpcy55YSwgMCA8IGMgJiYgKGYgPSBmWzJdLCB0aGlzLmEuZGVidWcoZiArIFwiIGJ5dGVzIChpbiBcIiArIGMgKyBcIiBhcnJheXMpIGFyZSBvdXRzdGFuZGluZyBvbiB0aGUgQmFja0NoYW5uZWxcIiksIDM3NTAwID4gZiAmJiAodGhpcy5yYiAmJiAwID09IHRoaXMuZ2EpICYmICF0aGlzLmJhICYmICh0aGlzLmJhID0gVSh3KHRoaXMucmMsIHRoaXMpLCA2RTMpKSlcbiAgICAgICAgICB9XG4gICAgICAgIH1lbHNlIHtcbiAgICAgICAgICB0aGlzLmEuZGVidWcoXCJCYWQgUE9TVCByZXNwb25zZSBkYXRhIHJldHVybmVkXCIpLCBaKHRoaXMsIDExKVxuICAgICAgICB9XG4gICAgICB9ZWxzZSB7XG4gICAgICAgIGIgIT0gZmQgJiYgKHRoaXMuYS5kZWJ1ZyhcIkJhZCBkYXRhIHJldHVybmVkIC0gbWlzc2luZy9pbnZhbGQgbWFnaWMgY29va2llXCIpLCBaKHRoaXMsIDExKSlcbiAgICAgIH1cbiAgICB9ZWxzZSB7XG4gICAgICBpZih0aGlzLmsgPT0gYSAmJiBVZCh0aGlzKSwgIS9eW1xcc1xceGEwXSokLy50ZXN0KGIpKSB7XG4gICAgICAgIGMgPSB0aGlzLlAucGFyc2UoYik7XG4gICAgICAgIGZvcih2YXIgZiA9IHRoaXMuZSAmJiB0aGlzLmUuY2hhbm5lbEhhbmRsZU11bHRpcGxlQXJyYXlzID8gW10gOiBudWxsLCBnID0gMDtnIDwgYy5sZW5ndGg7ZysrKSB7XG4gICAgICAgICAgdmFyIGggPSBjW2ddO1xuICAgICAgICAgIHRoaXMueWEgPSBoWzBdO1xuICAgICAgICAgIGggPSBoWzFdO1xuICAgICAgICAgIDIgPT0gdGhpcy5jID8gXCJjXCIgPT0gaFswXSA/ICh0aGlzLlogPSBoWzFdLCB0aGlzLkwgPSB0aGlzLmNvcnJlY3RIb3N0UHJlZml4KGhbMl0pLCBoID0gaFszXSwgdGhpcy5oYSA9IG51bGwgIT0gaCA/IGggOiA2LCB0aGlzLmMgPSAzLCB0aGlzLmUgJiYgdGhpcy5lLmNoYW5uZWxPcGVuZWQodGhpcyksIHRoaXMudWIgPSB4ZCh0aGlzLCB0aGlzLkwsIHRoaXMuSCksIFlkKHRoaXMpKSA6IFwic3RvcFwiID09IGhbMF0gJiYgWih0aGlzLCA3KSA6IDMgPT0gdGhpcy5jICYmIChcInN0b3BcIiA9PSBoWzBdID8gKGYgJiYgZi5sZW5ndGggJiYgKHRoaXMuZS5jaGFubmVsSGFuZGxlTXVsdGlwbGVBcnJheXModGhpcywgZiksIGYubGVuZ3RoID0gMCksIFoodGhpcywgNykpIDogXCJub29wXCIgIT0gaFswXSAmJiAoZiA/IGYucHVzaChoKSA6IHRoaXMuZSAmJiB0aGlzLmUuY2hhbm5lbEhhbmRsZUFycmF5KHRoaXMsIGgpKSwgdGhpcy5nYSA9IDApXG4gICAgICAgIH1cbiAgICAgICAgZiAmJiBmLmxlbmd0aCAmJiB0aGlzLmUuY2hhbm5lbEhhbmRsZU11bHRpcGxlQXJyYXlzKHRoaXMsIGYpXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xucC5jb3JyZWN0SG9zdFByZWZpeCA9IGZ1bmN0aW9uKGEpIHtcbiAgcmV0dXJuIHRoaXMuZmMgPyB0aGlzLmUgPyB0aGlzLmUuY29ycmVjdEhvc3RQcmVmaXgoYSkgOiBhIDogbnVsbFxufTtcbnAucmMgPSBmdW5jdGlvbigpIHtcbiAgbnVsbCAhPSB0aGlzLmJhICYmICh0aGlzLmJhID0gbnVsbCwgdGhpcy5rLmNhbmNlbCgpLCB0aGlzLmsgPSBudWxsLCBaZCh0aGlzKSwgVCgyMCkpXG59O1xuZnVuY3Rpb24gVWQoYSkge1xuICBudWxsICE9IGEuYmEgJiYgKHEuY2xlYXJUaW1lb3V0KGEuYmEpLCBhLmJhID0gbnVsbClcbn1cbnAubWEgPSBmdW5jdGlvbihhKSB7XG4gIHRoaXMuYS5kZWJ1ZyhcIlJlcXVlc3QgY29tcGxldGVcIik7XG4gIHZhciBiO1xuICBpZih0aGlzLmsgPT0gYSkge1xuICAgIFVkKHRoaXMpLCB0aGlzLmsgPSBudWxsLCBiID0gMlxuICB9ZWxzZSB7XG4gICAgaWYodGhpcy5vID09IGEpIHtcbiAgICAgIHRoaXMubyA9IG51bGwsIGIgPSAxXG4gICAgfWVsc2Uge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIHRoaXMuaCA9IGEuaDtcbiAgaWYoMCAhPSB0aGlzLmMpIHtcbiAgICBpZihhLkopIHtcbiAgICAgIDEgPT0gYiA/IChiID0geCgpIC0gYS5wYSwgTGQuZGlzcGF0Y2hFdmVudChuZXcgTmQoTGQsIGEuWCA/IGEuWC5sZW5ndGggOiAwLCBiLCB0aGlzLlYpKSwgVmQodGhpcyksIHRoaXMuUS5sZW5ndGggPSAwKSA6IFlkKHRoaXMpXG4gICAgfWVsc2Uge1xuICAgICAgdmFyIGMgPSBhLkViKCk7XG4gICAgICBpZigzID09IGMgfHwgNyA9PSBjIHx8IDAgPT0gYyAmJiAwIDwgdGhpcy5oKSB7XG4gICAgICAgIHRoaXMuYS5kZWJ1ZyhcIk5vdCByZXRyeWluZyBkdWUgdG8gZXJyb3IgdHlwZVwiKVxuICAgICAgfWVsc2Uge1xuICAgICAgICB0aGlzLmEuZGVidWcoXCJNYXliZSByZXRyeWluZywgbGFzdCBlcnJvcjogXCIgKyBiYyhjLCB0aGlzLmgpKTtcbiAgICAgICAgdmFyIGQ7XG4gICAgICAgIGlmKGQgPSAxID09IGIpIHtcbiAgICAgICAgICB0aGlzLm8gfHwgdGhpcy5GID8gKHRoaXMuYS5JKFwiUmVxdWVzdCBhbHJlYWR5IGluIHByb2dyZXNzXCIpLCBkID0gITEpIDogdGhpcy5jID09IEpkIHx8IHRoaXMuViA+PSAodGhpcy5KYSA/IDAgOiB0aGlzLmtiKSA/IGQgPSAhMSA6ICh0aGlzLmEuZGVidWcoXCJHb2luZyB0byByZXRyeSBQT1NUXCIpLCB0aGlzLkYgPSBVKHcodGhpcy5SYiwgdGhpcywgYSksICRkKHRoaXMsIHRoaXMuVikpLCB0aGlzLlYrKywgZCA9ICEwKVxuICAgICAgICB9XG4gICAgICAgIGlmKGQgfHwgMiA9PSBiICYmIFpkKHRoaXMpKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hLmRlYnVnKFwiRXhjZWVkZWQgbWF4IG51bWJlciBvZiByZXRyaWVzXCIpXG4gICAgICB9XG4gICAgICB0aGlzLmEuZGVidWcoXCJFcnJvcjogSFRUUCByZXF1ZXN0IGZhaWxlZFwiKTtcbiAgICAgIHN3aXRjaChjKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBaKHRoaXMsIDUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgWih0aGlzLCAxMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBaKHRoaXMsIDYpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgWih0aGlzLCAxMik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgWih0aGlzLCAyKVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uICRkKGEsIGIpIHtcbiAgdmFyIGMgPSBhLmdjICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYS5CYyk7XG4gIGEuaXNBY3RpdmUoKSB8fCAoYS5hLmRlYnVnKFwiSW5hY3RpdmUgY2hhbm5lbFwiKSwgYyAqPSAyKTtcbiAgcmV0dXJuIGMgKiBiXG59XG5wLmpjID0gZnVuY3Rpb24oYSkge1xuICBpZighKDAgPD0gWGEoYXJndW1lbnRzLCB0aGlzLmMpKSkge1xuICAgIHRocm93IEVycm9yKFwiVW5leHBlY3RlZCBjaGFubmVsIHN0YXRlOiBcIiArIHRoaXMuYyk7XG4gIH1cbn07XG5mdW5jdGlvbiBaKGEsIGIpIHtcbiAgYS5hLmluZm8oXCJFcnJvciBjb2RlIFwiICsgYik7XG4gIGlmKDIgPT0gYiB8fCA5ID09IGIpIHtcbiAgICB2YXIgYyA9IG51bGw7XG4gICAgYS5lICYmIChjID0gYS5lLmdldE5ldHdvcmtUZXN0SW1hZ2VVcmkoYSkpO1xuICAgIHZhciBkID0gdyhhLkRjLCBhKTtcbiAgICBjIHx8IChjID0gbmV3IEYoXCIvL3d3dy5nb29nbGUuY29tL2ltYWdlcy9jbGVhcmRvdC5naWZcIiksIEooYykpO1xuICAgIHBkKGMudG9TdHJpbmcoKSwgMUU0LCBkKVxuICB9ZWxzZSB7XG4gICAgVCgyKVxuICB9XG4gIGFlKGEsIGIpXG59XG5wLkRjID0gZnVuY3Rpb24oYSkge1xuICBhID8gKHRoaXMuYS5pbmZvKFwiU3VjY2Vzc2Z1bGx5IHBpbmdlZCBnb29nbGUuY29tXCIpLCBUKDIpKSA6ICh0aGlzLmEuaW5mbyhcIkZhaWxlZCB0byBwaW5nIGdvb2dsZS5jb21cIiksIFQoMSksIGFlKHRoaXMsIDgpKVxufTtcbmZ1bmN0aW9uIGFlKGEsIGIpIHtcbiAgYS5hLmRlYnVnKFwiSHR0cENoYW5uZWw6IGVycm9yIC0gXCIgKyBiKTtcbiAgYS5jID0gMDtcbiAgYS5lICYmIGEuZS5jaGFubmVsRXJyb3IoYSwgYik7XG4gIFRkKGEpO1xuICBRZChhKVxufVxuZnVuY3Rpb24gVGQoYSkge1xuICBhLmMgPSAwO1xuICBhLmggPSAtMTtcbiAgaWYoYS5lKSB7XG4gICAgaWYoMCA9PSBhLlEubGVuZ3RoICYmIDAgPT0gYS5zLmxlbmd0aCkge1xuICAgICAgYS5lLmNoYW5uZWxDbG9zZWQoYSlcbiAgICB9ZWxzZSB7XG4gICAgICBhLmEuZGVidWcoXCJOdW1iZXIgb2YgdW5kZWxpdmVyZWQgbWFwcywgcGVuZGluZzogXCIgKyBhLlEubGVuZ3RoICsgXCIsIG91dGdvaW5nOiBcIiArIGEucy5sZW5ndGgpO1xuICAgICAgdmFyIGIgPSAkYShhLlEpLCBjID0gJGEoYS5zKTtcbiAgICAgIGEuUS5sZW5ndGggPSAwO1xuICAgICAgYS5zLmxlbmd0aCA9IDA7XG4gICAgICBhLmUuY2hhbm5lbENsb3NlZChhLCBiLCBjKVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmQoYSwgYikge1xuICB2YXIgYyA9IHZkKGEsIG51bGwsIGIpO1xuICBhLmEuZGVidWcoXCJHZXRGb3J3YXJkQ2hhbm5lbFVyaTogXCIgKyBjKTtcbiAgcmV0dXJuIGNcbn1cbmZ1bmN0aW9uIHhkKGEsIGIsIGMpIHtcbiAgYiA9IHZkKGEsIGEuWWEoKSA/IGIgOiBudWxsLCBjKTtcbiAgYS5hLmRlYnVnKFwiR2V0QmFja0NoYW5uZWxVcmk6IFwiICsgYik7XG4gIHJldHVybiBiXG59XG5mdW5jdGlvbiB2ZChhLCBiLCBjKSB7XG4gIHZhciBkID0gYyBpbnN0YW5jZW9mIEYgPyBjLm4oKSA6IG5ldyBGKGMsIHZvaWQgMCk7XG4gIGlmKFwiXCIgIT0gZC5qYSkge1xuICAgIGIgJiYgZmIoZCwgYiArIFwiLlwiICsgZC5qYSksIGdiKGQsIGQuQmEpXG4gIH1lbHNlIHtcbiAgICB2YXIgZiA9IHdpbmRvdy5sb2NhdGlvbiwgZCA9IHNiKGYucHJvdG9jb2wsIGIgPyBiICsgXCIuXCIgKyBmLmhvc3RuYW1lIDogZi5ob3N0bmFtZSwgZi5wb3J0LCBjKVxuICB9XG4gIGEueGEgJiYgRShhLnhhLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgSShkLCBiLCBhKVxuICB9KTtcbiAgSShkLCBcIlZFUlwiLCBhLmhhKTtcbiAgUmQoYSwgZCk7XG4gIHJldHVybiBkXG59XG5wLmhiID0gZnVuY3Rpb24oYSkge1xuICBpZihhICYmICF0aGlzLlphKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJDYW4ndCBjcmVhdGUgc2Vjb25kYXJ5IGRvbWFpbiBjYXBhYmxlIFhocklvIG9iamVjdC5cIik7XG4gIH1cbiAgYSA9IG5ldyBoZDtcbiAgYS5jYyA9IHRoaXMuWmE7XG4gIHJldHVybiBhXG59O1xucC5pc0FjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4hIXRoaXMuZSAmJiB0aGlzLmUuaXNBY3RpdmUodGhpcylcbn07XG5mdW5jdGlvbiBVKGEsIGIpIHtcbiAgaWYoIWhhKGEpKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJGbiBtdXN0IG5vdCBiZSBudWxsIGFuZCBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gIH1cbiAgcmV0dXJuIHEuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBhKClcbiAgfSwgYilcbn1cbnAuRyA9IGZ1bmN0aW9uKGEpIHtcbiAgTGQuZGlzcGF0Y2hFdmVudChuZXcgT2QoTGQsIGEpKVxufTtcbmZ1bmN0aW9uIFQoYSkge1xuICBMZC5kaXNwYXRjaEV2ZW50KG5ldyBNZChMZCwgYSkpXG59XG5wLllhID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLlphIHx8ICFlYygpXG59O1xuZnVuY3Rpb24gYmUoKSB7XG59XG5wID0gYmUucHJvdG90eXBlO1xucC5jaGFubmVsSGFuZGxlTXVsdGlwbGVBcnJheXMgPSBudWxsO1xucC5va1RvTWFrZVJlcXVlc3QgPSBiYSgwKTtcbnAuY2hhbm5lbE9wZW5lZCA9IGUoKTtcbnAuY2hhbm5lbEhhbmRsZUFycmF5ID0gZSgpO1xucC5jaGFubmVsRXJyb3IgPSBlKCk7XG5wLmNoYW5uZWxDbG9zZWQgPSBlKCk7XG5wLmdldEFkZGl0aW9uYWxQYXJhbXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJue31cbn07XG5wLmdldE5ldHdvcmtUZXN0SW1hZ2VVcmkgPSBiYShudWxsKTtcbnAuaXNBY3RpdmUgPSBiYSghMCk7XG5wLmJhZE1hcEVycm9yID0gZSgpO1xucC5jb3JyZWN0SG9zdFByZWZpeCA9IGZ1bmN0aW9uKGEpIHtcbiAgcmV0dXJuIGFcbn07XG52YXIgJCwgY2UsIGRlID0gW10uc2xpY2U7XG5jZSA9IHswOlwiT2tcIiwgNDpcIlVzZXIgaXMgbG9nZ2luZyBvdXRcIiwgNjpcIlVua25vd24gc2Vzc2lvbiBJRFwiLCA3OlwiU3RvcHBlZCBieSBzZXJ2ZXJcIiwgODpcIkdlbmVyYWwgbmV0d29yayBlcnJvclwiLCAyOlwiUmVxdWVzdCBmYWlsZWRcIiwgOTpcIkJsb2NrZWQgYnkgYSBuZXR3b3JrIGFkbWluaXN0cmF0b3JcIiwgNTpcIk5vIGRhdGEgZnJvbSBzZXJ2ZXJcIiwgMTA6XCJHb3QgYmFkIGRhdGEgZnJvbSB0aGUgc2VydmVyXCIsIDExOlwiR290IGEgYmFkIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlclwifTtcbiQgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBjLCBkLCBmLCBnLCBoLCBuLCBrLCB0LCBsLCByO1xuICB0ID0gdGhpcztcbiAgYSB8fCAoYSA9IFwiY2hhbm5lbFwiKTtcbiAgYS5tYXRjaCgvOlxcL1xcLy8pICYmIGEucmVwbGFjZSgvXndzLywgXCJodHRwXCIpO1xuICBiIHx8IChiID0ge30pO1xuICBzKGIgfHwgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGIpICYmIChiID0ge30pO1xuICBuID0gYi5yZWNvbm5lY3RUaW1lIHx8IDNFMztcbiAgciA9IGZ1bmN0aW9uKGEpIHtcbiAgICB0LnJlYWR5U3RhdGUgPSB0LnJlYWR5U3RhdGUgPSBhXG4gIH07XG4gIHIodGhpcy5DTE9TRUQpO1xuICBsID0gbnVsbDtcbiAgZyA9IGIuS2M7XG4gIGMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYSwgYjtcbiAgICBiID0gYXJndW1lbnRzWzBdO1xuICAgIGEgPSAyIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBkZS5jYWxsKGFyZ3VtZW50cywgMSkgOiBbXTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdFtiXSA/IHRbYl0uYXBwbHkodCwgYSkgOiB2b2lkIDBcbiAgICB9Y2F0Y2goYykge1xuICAgICAgdGhyb3cgYSA9IGMsIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBjb25zb2xlICYmIG51bGwgIT09IGNvbnNvbGUgJiYgY29uc29sZS5lcnJvcihhLnN0YWNrKSwgYTtcbiAgICB9XG4gIH07XG4gIGQgPSBuZXcgYmU7XG4gIGQuY2hhbm5lbE9wZW5lZCA9IGZ1bmN0aW9uKCkge1xuICAgIGcgPSBsO1xuICAgIHIoJC5PUEVOKTtcbiAgICByZXR1cm4gYyhcIm9ub3BlblwiKVxuICB9O1xuICBmID0gbnVsbDtcbiAgZC5jaGFubmVsRXJyb3IgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIGQ7XG4gICAgZCA9IGNlW2JdO1xuICAgIGYgPSBiO1xuICAgIHIoJC5jYik7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjKFwib25lcnJvclwiLCBkLCBiKVxuICAgIH1jYXRjaChnKSB7XG4gICAgfVxuICB9O1xuICBrID0gbnVsbDtcbiAgZC5jaGFubmVsQ2xvc2VkID0gZnVuY3Rpb24oYSwgZCwgZykge1xuICAgIGlmKHQucmVhZHlTdGF0ZSAhPT0gJC5DTE9TRUQpIHtcbiAgICAgIGwgPSBudWxsO1xuICAgICAgYSA9IGYgPyBjZVtmXSA6IFwiQ2xvc2VkXCI7XG4gICAgICByKCQuQ0xPU0VEKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGMoXCJvbmNsb3NlXCIsIGEsIGQsIGcpXG4gICAgICB9Y2F0Y2goZWUpIHtcbiAgICAgIH1cbiAgICAgIGIucmVjb25uZWN0ICYmICg3ICE9PSBmICYmIDAgIT09IGYpICYmIChkID0gNiA9PT0gZiA/IDAgOiBuLCBjbGVhclRpbWVvdXQoayksIGsgPSBzZXRUaW1lb3V0KGgsIGQpKTtcbiAgICAgIHJldHVybiBmID0gbnVsbFxuICAgIH1cbiAgfTtcbiAgZC5jaGFubmVsSGFuZGxlQXJyYXkgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGMoXCJvbm1lc3NhZ2VcIiwgYilcbiAgfTtcbiAgaCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmKGwpIHtcbiAgICAgIHRocm93IEVycm9yKFwiUmVjb25uZWN0KCkgY2FsbGVkIGZyb20gaW52YWxpZCBzdGF0ZVwiKTtcbiAgICB9XG4gICAgcigkLkNPTk5FQ1RJTkcpO1xuICAgIGMoXCJvbmNvbm5lY3RpbmdcIik7XG4gICAgY2xlYXJUaW1lb3V0KGspO1xuICAgIGwgPSBuZXcgSWQoYi5hcHBWZXJzaW9uLCBudWxsICE9IGcgPyBnLkNiIDogdm9pZCAwKTtcbiAgICBiLmNyb3NzRG9tYWluWGhyICYmIChsLlphID0gITApO1xuICAgIGwuZSA9IGQ7XG4gICAgZiA9IG51bGw7XG4gICAgaWYoYi5mYWlsRmFzdCkge1xuICAgICAgdmFyIGggPSBsO1xuICAgICAgaC5KYSA9ICEwO1xuICAgICAgaC5hLmluZm8oXCJzZXRGYWlsRmFzdDogdHJ1ZVwiKTtcbiAgICAgIChoLm8gfHwgaC5GKSAmJiBoLlYgPiAoaC5KYSA/IDAgOiBoLmtiKSAmJiAoaC5hLmluZm8oXCJSZXRyeSBjb3VudCBcIiArIGguViArIFwiID4gbmV3IG1heFJldHJpZXMgXCIgKyAoaC5KYSA/IDAgOiBoLmtiKSArIFwiLiBGYWlsIGltbWVkaWF0ZWx5IVwiKSwgaC5vID8gKGguby5jYW5jZWwoKSwgaC5tYShoLm8pKSA6IChxLmNsZWFyVGltZW91dChoLkYpLCBoLkYgPSBudWxsLCBaKGgsIDIpKSlcbiAgICB9XG4gICAgcmV0dXJuIGwuZ2IoXCJcIiArIGEgKyBcIi90ZXN0XCIsIFwiXCIgKyBhICsgXCIvYmluZFwiLCBiLmV4dHJhUGFyYW1zLCBudWxsICE9IGcgPyBnLlogOiB2b2lkIDAsIG51bGwgIT0gZyA/IGcueWEgOiB2b2lkIDApXG4gIH07XG4gIHRoaXMub3BlbiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmKHQucmVhZHlTdGF0ZSAhPT0gdC5DTE9TRUQpIHtcbiAgICAgIHRocm93IEVycm9yKFwiQWxyZWFkeSBvcGVuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gaCgpXG4gIH07XG4gIHRoaXMuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICBjbGVhclRpbWVvdXQoayk7XG4gICAgZiA9IDA7XG4gICAgaWYodC5yZWFkeVN0YXRlICE9PSAkLkNMT1NFRCkge1xuICAgICAgcmV0dXJuIHIoJC5jYiksIGwuZGlzY29ubmVjdCgpXG4gICAgfVxuICB9O1xuICB0aGlzLnNlbmRNYXAgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIGI7XG4gICAgaWYoKGIgPSB0LnJlYWR5U3RhdGUpID09PSAkLmNiIHx8IGIgPT09ICQuQ0xPU0VEKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkNhbm5vdCBzZW5kIHRvIGEgY2xvc2VkIGNvbm5lY3Rpb25cIik7XG4gICAgfVxuICAgIGIgPSBsO1xuICAgIGlmKDAgPT0gYi5jKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgb3BlcmF0aW9uOiBzZW5kaW5nIG1hcCB3aGVuIHN0YXRlIGlzIGNsb3NlZFwiKTtcbiAgICB9XG4gICAgMUUzID09IGIucy5sZW5ndGggJiYgYi5hLkkoXCJBbHJlYWR5IGhhdmUgMTAwMCBxdWV1ZWQgbWFwcyB1cG9uIHF1ZXVlaW5nIFwiICsgS2MoYSkpO1xuICAgIGIucy5wdXNoKG5ldyBLZChiLnFjKyssIGEpKTtcbiAgICAyICE9IGIuYyAmJiAzICE9IGIuYyB8fCBWZChiKVxuICB9O1xuICB0aGlzLnNlbmQgPSBmdW5jdGlvbihhKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZE1hcCh7SlNPTjpLYyhhKX0pXG4gIH07XG4gIGgoKTtcbiAgcmV0dXJuIHRoaXNcbn07XG4kLnByb3RvdHlwZS5DT05ORUNUSU5HID0gJC5DT05ORUNUSU5HID0gJC5DT05ORUNUSU5HID0gMDtcbiQucHJvdG90eXBlLk9QRU4gPSAkLk9QRU4gPSAkLk9QRU4gPSAxO1xuJC5wcm90b3R5cGUuQ0xPU0lORyA9ICQuQ0xPU0lORyA9ICQuY2IgPSAyO1xuJC5wcm90b3R5cGUuQ0xPU0VEID0gJC5DTE9TRUQgPSAkLkNMT1NFRCA9IDM7XG4oXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGV4cG9ydHMgJiYgbnVsbCAhPT0gZXhwb3J0cyA/IGV4cG9ydHMgOiB3aW5kb3cpLkJDU29ja2V0ID0gJDtcblxufSkoKTtcbiIsInZhciBpc0FycmF5ID0gdHlwZW9mIEFycmF5LmlzQXJyYXkgPT09ICdmdW5jdGlvbidcbiAgICA/IEFycmF5LmlzQXJyYXlcbiAgICA6IGZ1bmN0aW9uICh4cykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgIH07XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gb2JqZWN0S2V5cyhvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ICE9PSBPYmplY3Qob2JqZWN0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBvYmplY3QnKTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkga2V5c1trZXlzLmxlbmd0aF0gPSBrZXk7XG4gICAgcmV0dXJuIGtleXM7XG59XG5cblxuLyohXG4gKiBxdWVyeXN0cmluZ1xuICogQ29weXJpZ2h0KGMpIDIwMTAgVEogSG9sb3dheWNodWsgPHRqQHZpc2lvbi1tZWRpYS5jYT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogTGlicmFyeSB2ZXJzaW9uLlxuICovXG5cbmV4cG9ydHMudmVyc2lvbiA9ICcwLjMuMSc7XG5cbi8qKlxuICogT2JqZWN0I3RvU3RyaW5nKCkgcmVmIGZvciBzdHJpbmdpZnkoKS5cbiAqL1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIENhY2hlIG5vbi1pbnRlZ2VyIHRlc3QgcmVnZXhwLlxuICovXG5cbnZhciBub3RpbnQgPSAvW14wLTldLztcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gcXVlcnkgYHN0cmAsIHJldHVybmluZyBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24oc3RyKXtcbiAgaWYgKG51bGwgPT0gc3RyIHx8ICcnID09IHN0cikgcmV0dXJuIHt9O1xuXG4gIGZ1bmN0aW9uIHByb21vdGUocGFyZW50LCBrZXkpIHtcbiAgICBpZiAocGFyZW50W2tleV0ubGVuZ3RoID09IDApIHJldHVybiBwYXJlbnRba2V5XSA9IHt9O1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgaSBpbiBwYXJlbnRba2V5XSkgdFtpXSA9IHBhcmVudFtrZXldW2ldO1xuICAgIHBhcmVudFtrZXldID0gdDtcbiAgICByZXR1cm4gdDtcbiAgfVxuXG4gIHJldHVybiBTdHJpbmcoc3RyKVxuICAgIC5zcGxpdCgnJicpXG4gICAgLnJlZHVjZShmdW5jdGlvbihyZXQsIHBhaXIpe1xuICAgICAgdHJ5eyBcbiAgICAgICAgcGFpciA9IGRlY29kZVVSSUNvbXBvbmVudChwYWlyLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAvLyBpZ25vcmVcbiAgICAgIH1cblxuICAgICAgdmFyIGVxbCA9IHBhaXIuaW5kZXhPZignPScpXG4gICAgICAgICwgYnJhY2UgPSBsYXN0QnJhY2VJbktleShwYWlyKVxuICAgICAgICAsIGtleSA9IHBhaXIuc3Vic3RyKDAsIGJyYWNlIHx8IGVxbClcbiAgICAgICAgLCB2YWwgPSBwYWlyLnN1YnN0cihicmFjZSB8fCBlcWwsIHBhaXIubGVuZ3RoKVxuICAgICAgICAsIHZhbCA9IHZhbC5zdWJzdHIodmFsLmluZGV4T2YoJz0nKSArIDEsIHZhbC5sZW5ndGgpXG4gICAgICAgICwgcGFyZW50ID0gcmV0O1xuXG4gICAgICAvLyA/Zm9vXG4gICAgICBpZiAoJycgPT0ga2V5KSBrZXkgPSBwYWlyLCB2YWwgPSAnJztcblxuICAgICAgLy8gbmVzdGVkXG4gICAgICBpZiAofmtleS5pbmRleE9mKCddJykpIHtcbiAgICAgICAgdmFyIHBhcnRzID0ga2V5LnNwbGl0KCdbJylcbiAgICAgICAgICAsIGxlbiA9IHBhcnRzLmxlbmd0aFxuICAgICAgICAgICwgbGFzdCA9IGxlbiAtIDE7XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2UocGFydHMsIHBhcmVudCwga2V5KSB7XG4gICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0cy5zaGlmdCgpO1xuXG4gICAgICAgICAgLy8gZW5kXG4gICAgICAgICAgaWYgKCFwYXJ0KSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheShwYXJlbnRba2V5XSkpIHtcbiAgICAgICAgICAgICAgcGFyZW50W2tleV0ucHVzaCh2YWwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PSB0eXBlb2YgcGFyZW50W2tleV0pIHtcbiAgICAgICAgICAgICAgcGFyZW50W2tleV0gPSB2YWw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCd1bmRlZmluZWQnID09IHR5cGVvZiBwYXJlbnRba2V5XSkge1xuICAgICAgICAgICAgICBwYXJlbnRba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcmVudFtrZXldID0gW3BhcmVudFtrZXldLCB2YWxdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIC8vIGFycmF5XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9iaiA9IHBhcmVudFtrZXldID0gcGFyZW50W2tleV0gfHwgW107XG4gICAgICAgICAgICBpZiAoJ10nID09IHBhcnQpIHtcbiAgICAgICAgICAgICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgICAgIGlmICgnJyAhPSB2YWwpIG9iai5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoJ29iamVjdCcgPT0gdHlwZW9mIG9iaikge1xuICAgICAgICAgICAgICAgIG9ialtvYmplY3RLZXlzKG9iaikubGVuZ3RoXSA9IHZhbDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmogPSBwYXJlbnRba2V5XSA9IFtwYXJlbnRba2V5XSwgdmFsXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcHJvcFxuICAgICAgICAgICAgfSBlbHNlIGlmICh+cGFydC5pbmRleE9mKCddJykpIHtcbiAgICAgICAgICAgICAgcGFydCA9IHBhcnQuc3Vic3RyKDAsIHBhcnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgIGlmKG5vdGludC50ZXN0KHBhcnQpICYmIGlzQXJyYXkob2JqKSkgb2JqID0gcHJvbW90ZShwYXJlbnQsIGtleSk7XG4gICAgICAgICAgICAgIHBhcnNlKHBhcnRzLCBvYmosIHBhcnQpO1xuICAgICAgICAgICAgLy8ga2V5XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZihub3RpbnQudGVzdChwYXJ0KSAmJiBpc0FycmF5KG9iaikpIG9iaiA9IHByb21vdGUocGFyZW50LCBrZXkpO1xuICAgICAgICAgICAgICBwYXJzZShwYXJ0cywgb2JqLCBwYXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZShwYXJ0cywgcGFyZW50LCAnYmFzZScpO1xuICAgICAgLy8gb3B0aW1pemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChub3RpbnQudGVzdChrZXkpICYmIGlzQXJyYXkocGFyZW50LmJhc2UpKSB7XG4gICAgICAgICAgdmFyIHQgPSB7fTtcbiAgICAgICAgICBmb3IodmFyIGsgaW4gcGFyZW50LmJhc2UpIHRba10gPSBwYXJlbnQuYmFzZVtrXTtcbiAgICAgICAgICBwYXJlbnQuYmFzZSA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KHBhcmVudC5iYXNlLCBrZXksIHZhbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSwge2Jhc2U6IHt9fSkuYmFzZTtcbn07XG5cbi8qKlxuICogVHVybiB0aGUgZ2l2ZW4gYG9iamAgaW50byBhIHF1ZXJ5IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudmFyIHN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24ob2JqLCBwcmVmaXgpIHtcbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlBcnJheShvYmosIHByZWZpeCk7XG4gIH0gZWxzZSBpZiAoJ1tvYmplY3QgT2JqZWN0XScgPT0gdG9TdHJpbmcuY2FsbChvYmopKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdChvYmosIHByZWZpeCk7XG4gIH0gZWxzZSBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIG9iaikge1xuICAgIHJldHVybiBzdHJpbmdpZnlTdHJpbmcob2JqLCBwcmVmaXgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcmVmaXg7XG4gIH1cbn07XG5cbi8qKlxuICogU3RyaW5naWZ5IHRoZSBnaXZlbiBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlTdHJpbmcoc3RyLCBwcmVmaXgpIHtcbiAgaWYgKCFwcmVmaXgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ2lmeSBleHBlY3RzIGFuIG9iamVjdCcpO1xuICByZXR1cm4gcHJlZml4ICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cik7XG59XG5cbi8qKlxuICogU3RyaW5naWZ5IHRoZSBnaXZlbiBgYXJyYC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXhcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5KGFyciwgcHJlZml4KSB7XG4gIHZhciByZXQgPSBbXTtcbiAgaWYgKCFwcmVmaXgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ2lmeSBleHBlY3RzIGFuIG9iamVjdCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIHJldC5wdXNoKHN0cmluZ2lmeShhcnJbaV0sIHByZWZpeCArICdbXScpKTtcbiAgfVxuICByZXR1cm4gcmV0LmpvaW4oJyYnKTtcbn1cblxuLyoqXG4gKiBTdHJpbmdpZnkgdGhlIGdpdmVuIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXhcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdChvYmosIHByZWZpeCkge1xuICB2YXIgcmV0ID0gW11cbiAgICAsIGtleXMgPSBvYmplY3RLZXlzKG9iailcbiAgICAsIGtleTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGtleXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIHJldC5wdXNoKHN0cmluZ2lmeShvYmpba2V5XSwgcHJlZml4XG4gICAgICA/IHByZWZpeCArICdbJyArIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJ10nXG4gICAgICA6IGVuY29kZVVSSUNvbXBvbmVudChrZXkpKSk7XG4gIH1cbiAgcmV0dXJuIHJldC5qb2luKCcmJyk7XG59XG5cbi8qKlxuICogU2V0IGBvYmpgJ3MgYGtleWAgdG8gYHZhbGAgcmVzcGVjdGluZ1xuICogdGhlIHdlaXJkIGFuZCB3b25kZXJmdWwgc3ludGF4IG9mIGEgcXMsXG4gKiB3aGVyZSBcImZvbz1iYXImZm9vPWJhelwiIGJlY29tZXMgYW4gYXJyYXkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2V0KG9iaiwga2V5LCB2YWwpIHtcbiAgdmFyIHYgPSBvYmpba2V5XTtcbiAgaWYgKHVuZGVmaW5lZCA9PT0gdikge1xuICAgIG9ialtrZXldID0gdmFsO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodikpIHtcbiAgICB2LnB1c2godmFsKTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IFt2LCB2YWxdO1xuICB9XG59XG5cbi8qKlxuICogTG9jYXRlIGxhc3QgYnJhY2UgaW4gYHN0cmAgd2l0aGluIHRoZSBrZXkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbGFzdEJyYWNlSW5LZXkoc3RyKSB7XG4gIHZhciBsZW4gPSBzdHIubGVuZ3RoXG4gICAgLCBicmFjZVxuICAgICwgYztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGMgPSBzdHJbaV07XG4gICAgaWYgKCddJyA9PSBjKSBicmFjZSA9IGZhbHNlO1xuICAgIGlmICgnWycgPT0gYykgYnJhY2UgPSB0cnVlO1xuICAgIGlmICgnPScgPT0gYyAmJiAhYnJhY2UpIHJldHVybiBpO1xuICB9XG59XG4iLCIoZnVuY3Rpb24ocHJvY2VzcyxfX2Rpcm5hbWUpe3ZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhY2VyO1xuXG5mdW5jdGlvbiBSYWNlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG59XG5cbnV0aWwubWVyZ2VJbnRvKFJhY2VyLnByb3RvdHlwZSwgRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5cbi8vIE1ha2UgY2xhc3NlcyBhY2Nlc3NpYmxlIGZvciB1c2UgYnkgcGx1Z2lucyBhbmQgdGVzdHNcblJhY2VyLnByb3RvdHlwZS5Nb2RlbCA9IE1vZGVsO1xuUmFjZXIucHJvdG90eXBlLnV0aWwgPSB1dGlsO1xuXG4vLyBTdXBwb3J0IHBsdWdpbnMgb24gcmFjZXIgaW5zdGFuY2VzXG5SYWNlci5wcm90b3R5cGUudXNlID0gdXRpbC51c2U7XG5cblJhY2VyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oZGF0YSkge1xuICB2YXIgcmFjZXIgPSB0aGlzO1xuXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WID0gZGF0YS5ub2RlRW52O1xuXG4gIC8vIEluaXQgaXMgZXhlY3V0ZWQgYXN5bmMgc28gdGhhdCBwbHVnaW5zIGNhbiBleHRlbmQgUmFjZXIgZXZlbiBpZiB0aGV5IGFyZVxuICAvLyBpbmNsdWRlZCBhZnRlciB0aGUgbWFpbiBlbnRyeSBwb2ludCBpbiB0aGUgYnVuZGxlXG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1vZGVsID0gbmV3IE1vZGVsO1xuXG4gICAgbW9kZWwuX2NyZWF0ZUNvbm5lY3Rpb24oZGF0YSk7XG5cbiAgICByYWNlci5lbWl0KCdtb2RlbCcsIG1vZGVsKTtcblxuICAgIC8vIFJlLWNyZWF0ZSBkb2N1bWVudHMgZm9yIGFsbCBtb2RlbCBkYXRhXG4gICAgZm9yICh2YXIgY29sbGVjdGlvbk5hbWUgaW4gZGF0YS5jb2xsZWN0aW9ucykge1xuICAgICAgdmFyIGNvbGxlY3Rpb24gPSBkYXRhLmNvbGxlY3Rpb25zW2NvbGxlY3Rpb25OYW1lXTtcbiAgICAgIGZvciAodmFyIGlkIGluIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgdmFyIGRvYyA9IG1vZGVsLmdldE9yQ3JlYXRlRG9jKGNvbGxlY3Rpb25OYW1lLCBpZCwgY29sbGVjdGlvbltpZF0pO1xuICAgICAgICBpZiAoZG9jLnNoYXJlRG9jKSB7XG4gICAgICAgICAgbW9kZWwuX2xvYWRWZXJzaW9uc1tjb2xsZWN0aW9uTmFtZSArICcuJyArIGlkXSA9IGRvYy5zaGFyZURvYy52ZXJzaW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogU3VwcG9ydCByZS1pbml0IHdoZW4gdGhlcmUgYXJlIGNvbnRleHRzIG90aGVyIHRoYW4gcm9vdFxuICAgIHZhciBjb250ZXh0ID0gZGF0YS5jb250ZXh0cy5yb290O1xuICAgIC8vIFJlLXN1YnNjcmliZSB0byBkb2N1bWVudCBzdWJzY3JpcHRpb25zXG4gICAgZm9yICh2YXIgcGF0aCBpbiBjb250ZXh0LnN1YnNjcmliZWREb2NzKSB7XG4gICAgICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgICBtb2RlbC5zdWJzY3JpYmVEb2Moc2VnbWVudHNbMF0sIHNlZ21lbnRzWzFdKTtcbiAgICAgIG1vZGVsLl9zdWJzY3JpYmVkRG9jc1twYXRoXSA9IGNvbnRleHQuc3Vic2NyaWJlZERvY3NbcGF0aF07XG4gICAgfVxuICAgIC8vIEluaXQgZmV0Y2hlZERvY3MgY291bnRzXG4gICAgZm9yICh2YXIgcGF0aCBpbiBjb250ZXh0LmZldGNoZWREb2NzKSB7XG4gICAgICBtb2RlbC5fZmV0Y2hlZERvY3NbcGF0aF0gPSBjb250ZXh0LmZldGNoZWREb2NzW3BhdGhdO1xuICAgIH1cblxuICAgIHZhciBzaWxlbnRNb2RlbCA9IG1vZGVsLnNpbGVudCgpO1xuICAgIC8vIFJlLWNyZWF0ZSByZWZzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLnJlZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gZGF0YS5yZWZzW2ldO1xuICAgICAgc2lsZW50TW9kZWwucmVmKGl0ZW1bMF0sIGl0ZW1bMV0pO1xuICAgIH1cbiAgICAvLyBSZS1jcmVhdGUgcmVmTGlzdHNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEucmVmTGlzdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gZGF0YS5yZWZMaXN0c1tpXTtcbiAgICAgIHNpbGVudE1vZGVsLnJlZkxpc3QoaXRlbVswXSwgaXRlbVsxXSwgaXRlbVsyXSwgaXRlbVszXSk7XG4gICAgfVxuICAgIC8vIFJlLWNyZWF0ZSBmbnNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IGRhdGEuZm5zW2ldO1xuICAgICAgc2lsZW50TW9kZWwuc3RhcnQuYXBwbHkoc2lsZW50TW9kZWwsIGl0ZW0pO1xuICAgIH1cbiAgICAvLyBSZS1jcmVhdGUgZmlsdGVyc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5maWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IGRhdGEuZmlsdGVyc1tpXTtcbiAgICAgIHZhciBmaWx0ZXIgPSBtb2RlbC5fZmlsdGVycy5hZGQoaXRlbVswXSwgaXRlbVsxXSwgaXRlbVsyXSk7XG4gICAgICBmaWx0ZXIucmVmKGl0ZW1bM10pO1xuICAgIH1cbiAgICAvLyBJbml0IGFuZCByZS1zdWJzY3JpYmUgcXVlcmllcyBhcyBhcHByb3ByaWF0ZVxuICAgIG1vZGVsLl9pbml0UXVlcmllcyhkYXRhLnF1ZXJpZXMpO1xuXG4gICAgcmFjZXIuX21vZGVsID0gbW9kZWw7XG4gICAgcmFjZXIuZW1pdCgncmVhZHknLCBtb2RlbCk7XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cblJhY2VyLnByb3RvdHlwZS5yZWFkeSA9IGZ1bmN0aW9uKGNiKSB7XG4gIGlmICh0aGlzLl9tb2RlbCkge1xuICAgIC8vIENhbGxiYWNrIGFzeW5jIGluIGNhc2UgdGhlIGNvZGUgZGVwZW5kcyBvbiBzY3JpcHRzIGluY2x1ZGVkIGFmdGVyIGluXG4gICAgLy8gdGhlIGJ1bmRsZSBhbmQgaXMgZ2F0ZWQgYnkgYSByZWFkeVxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBjYih0aGlzLl9tb2RlbCk7XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMub25jZSgncmVhZHknLCBjYik7XG59O1xuXG51dGlsLnNlcnZlclJlcXVpcmUoX19kaXJuYW1lICsgJy9SYWNlci5zZXJ2ZXIuanMnKTtcblxufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9wcm9jZXNzXCIpLFwiL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbGliXCIpIiwidmFyIGFwcCA9IHJlcXVpcmUoJ2RlcmJ5JylcbiAgLmNyZWF0ZUFwcChtb2R1bGUpXG4gIC51c2UocmVxdWlyZSgnLi4vLi4vdWknKSlcbiAgLnVzZShyZXF1aXJlKCdkZXJieS11aS1naXRodWItYnV0dG9ucycpKTtcblxucmVxdWlyZSgnLi9jb250cm9sbGVyRm5zJykoYXBwKTtcbnJlcXVpcmUoJy4vZXZlbnRzJykoYXBwKTtcbnJlcXVpcmUoJy4vdXNlcicpKGFwcCk7XG5yZXF1aXJlKCcuL3JvdXRlcycpKGFwcCk7XG5yZXF1aXJlKCcuL3ZpZXdGbnMnKShhcHApOyIsIihmdW5jdGlvbihfX2ZpbGVuYW1lKXt2YXIgY29uZmlnID0ge1xuICBmaWxlbmFtZTogX19maWxlbmFtZSxcbiAgc2NyaXB0czoge1xuICAgIGNvbm5lY3Rpb25BbGVydDogcmVxdWlyZSgnLi9jb25uZWN0aW9uQWxlcnQnKVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcHAsIG9wdGlvbnMpIHtcbiAgYXBwLmNyZWF0ZUxpYnJhcnkoY29uZmlnLCBvcHRpb25zKTtcbn07XG59KShcIi91aS9pbmRleC5qc1wiKSIsImV4cG9ydHMuc2V0dXAgPSBmdW5jdGlvbihsaWJyYXJ5KSB7XG4gIGxpYnJhcnkudmlldy5mbignc2VudGVuY2VDYXNlJywgZnVuY3Rpb24odGV4dCkge1xuICAgIHJldHVybiB0ZXh0ICYmICh0ZXh0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4dC5zbGljZSgxKSk7XG4gIH0pO1xufTtcblxuZXhwb3J0cy5yZWNvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgbW9kZWwuc2V0KCdoaWRlUmVjb25uZWN0JywgdHJ1ZSk7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgbW9kZWwuc2V0KCdoaWRlUmVjb25uZWN0JywgZmFsc2UpO1xuICB9LCAxMDAwKTtcbiAgbW9kZWwucmVjb25uZWN0KCk7XG59O1xuXG5leHBvcnRzLnJlbG9hZCA9IGZ1bmN0aW9uKCkge1xuICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG59OyIsIihmdW5jdGlvbihnbG9iYWwpe3ZhciByYWNlciA9IHJlcXVpcmUoJ3JhY2VyJylcbiAgLCB0cmFja3MgPSByZXF1aXJlKCd0cmFja3MnKVxuICAsIHNoYXJlZENyZWF0ZUFwcCA9IHJlcXVpcmUoJy4vYXBwJykuY3JlYXRlXG4gICwgZGVyYnlNb2RlbCA9IHJlcXVpcmUoJy4vZGVyYnkuTW9kZWwnKVxuICAsIERvbSA9IHJlcXVpcmUoJy4vRG9tJylcbiAgLCB2aWV3TW9kZWwgPSByZXF1aXJlKCcuL3ZpZXdNb2RlbCcpXG4gICwgcmVmcmVzaCA9IHJlcXVpcmUoJy4vcmVmcmVzaCcpXG5cbm1vZHVsZS5leHBvcnRzID0gZGVyYnlCcm93c2VyO1xuXG5mdW5jdGlvbiBkZXJieUJyb3dzZXIoZGVyYnkpIHtcbiAgLy8gVGhpcyBhc3N1bWVzIHRoYXQgb25seSBhIHNpbmdsZSBpbnN0YW5jZSBvZiB0aGlzIG1vZHVsZSBjYW4gcnVuIGF0IGEgdGltZSxcbiAgLy8gd2hpY2ggaXMgcmVhc29uYWJsZSBpbiB0aGUgYnJvd3Nlci4gVGhpcyBpcyB3cml0dGVuIGxpa2UgdGhpcyBzbyB0aGF0XG4gIC8vIHRoZSBERVJCWSBnbG9iYWwgY2FuIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZSB0ZW1wbGF0ZXMgYW5kIGRhdGEuXG4gIGdsb2JhbC5ERVJCWSA9IGRlcmJ5O1xuICBkZXJieS5jcmVhdGVBcHAgPSBjcmVhdGVBcHA7XG4gIGRlcmJ5LmluaXQgPSBpbml0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBcHAoYXBwTW9kdWxlKSB7XG4gIGlmIChkZXJieUJyb3dzZXIuY3JlYXRlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZGVyYnkuY3JlYXRlQXBwKCkgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGluIHRoZSBicm93c2VyJyk7XG4gIH0gZWxzZSB7XG4gICAgZGVyYnlCcm93c2VyLmNyZWF0ZWQgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGFwcCA9IHNoYXJlZENyZWF0ZUFwcCh0aGlzLCBhcHBNb2R1bGUpXG4gIGdsb2JhbC5ERVJCWS5hcHAgPSBhcHA7XG5cbiAgcmFjZXIub25jZSgnbW9kZWwnLCBmdW5jdGlvbihtb2RlbCkge1xuICAgIGFwcC5lbWl0KCdtb2RlbCcsIG1vZGVsKTtcbiAgfSk7XG5cbiAgLy8gQWRkcyBnZXQsIHBvc3QsIHB1dCwgZGVsLCBlbnRlciwgYW5kIGV4aXQgbWV0aG9kc1xuICAvLyBhcyB3ZWxsIGFzIGhpc3RvcnkgdG8gYXBwXG4gIHRyYWNrcy5zZXR1cChhcHAsIGNyZWF0ZVBhZ2UsIG9uUm91dGUpO1xuXG4gIG9uUmVuZGVyRXJyb3IgPSBmdW5jdGlvbihlcnIsIHVybCkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24gPSB1cmw7XG4gICAgfSwgMCk7XG4gICAgdGhyb3cgZXJyO1xuICB9XG5cbiAgZnVuY3Rpb24gUGFnZShhcHApIHtcbiAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICB0aGlzLm1vZGVsID0gYXBwLm1vZGVsO1xuICAgIHRoaXMuZG9tID0gYXBwLmRvbTtcbiAgICB0aGlzLmhpc3RvcnkgPSBhcHAuaGlzdG9yeTtcbiAgICB0aGlzLl92aWV3TW9kZWxzID0gW107XG4gICAgdGhpcy5fcm91dGluZyA9IGZhbHNlO1xuICB9XG4gIFBhZ2UucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG5zLCBjdHgpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY3R4ID0gbnM7XG4gICAgICAgIG5zID0gJyc7XG4gICAgICB9XG4gICAgICBjdHggfHwgKGN0eCA9IHt9KTtcbiAgICAgIGN0eC4kdXJsID0gdGhpcy5wYXJhbXMudXJsO1xuICAgICAgYXBwLnZpZXcucmVuZGVyKHRoaXMubW9kZWwsIG5zLCBjdHgpO1xuICAgICAgdGhpcy5fcm91dGluZyA9IGZhbHNlO1xuICAgICAgdHJhY2tzLnJlbmRlcih0aGlzLCB7XG4gICAgICAgIHVybDogdGhpcy5wYXJhbXMudXJsXG4gICAgICAsIHByZXZpb3VzOiB0aGlzLnBhcmFtcy5wcmV2aW91c1xuICAgICAgLCBtZXRob2Q6ICdlbnRlcidcbiAgICAgICwgbm9OYXZpZ2F0ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBvblJlbmRlckVycm9yKGVyciwgdGhpcy5wYXJhbXMudXJsKTtcbiAgICB9XG4gIH07XG4gIFBhZ2UucHJvdG90eXBlLmluaXQgPSB2aWV3TW9kZWwucGFnZUluaXQ7XG5cbiAgZnVuY3Rpb24gY3JlYXRlUGFnZSgpIHtcbiAgICByZXR1cm4gbmV3IFBhZ2UoYXBwKTtcbiAgfVxuICBmdW5jdGlvbiBvblJvdXRlKGNhbGxiYWNrLCBwYWdlLCBwYXJhbXMsIG5leHQsIGlzVHJhbnNpdGlvbmFsLCBkb25lKSB7XG4gICAgaWYgKCFhcHAuX2luaXRpYWxpemVkKSByZXR1cm47XG4gICAgdHJ5IHtcbiAgICAgIGlmIChpc1RyYW5zaXRpb25hbCkge1xuICAgICAgICBpZiAoY2FsbGJhY2subGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgY2FsbGJhY2socGFnZS5tb2RlbCwgcGFyYW1zLCBuZXh0LCBkb25lKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayhwYWdlLm1vZGVsLCBwYXJhbXMsIG5leHQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLm1ldGhvZCA9PT0gJ2VudGVyJyB8fCBwYXJhbXMubWV0aG9kID09PSAnZXhpdCcpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbChhcHAsIHBhZ2UubW9kZWwsIHBhcmFtcyk7XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXBhZ2UuX3JvdXRpbmcpIHtcbiAgICAgICAgdHJhY2tzLnJlbmRlcihwYWdlLCB7XG4gICAgICAgICAgdXJsOiBwYWdlLnBhcmFtcy5wcmV2aW91c1xuICAgICAgICAsIG1ldGhvZDogJ2V4aXQnXG4gICAgICAgICwgbm9OYXZpZ2F0ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgYXBwLnZpZXcuX2JlZm9yZVJvdXRlKCk7XG4gICAgICB9XG4gICAgICBwYWdlLl9yb3V0aW5nID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrKHBhZ2UsIHBhZ2UubW9kZWwsIHBhcmFtcywgbmV4dCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBvblJlbmRlckVycm9yKGVyciwgcGFnZS5wYXJhbXMudXJsKTtcbiAgICB9XG4gIH1cblxuICBhcHAucmVhZHkgPSBmdW5jdGlvbihmbikge1xuICAgIGlmIChhcHAuX2luaXRpYWxpemVkKSByZXR1cm4gZm4uY2FsbChhcHAucGFnZSwgYXBwLm1vZGVsKTtcbiAgICBhcHAub25jZSgncmVhZHknLCBmdW5jdGlvbigpIHtcbiAgICAgIGZuLmNhbGwoYXBwLnBhZ2UsIGFwcC5tb2RlbCk7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBhcHA7XG59XG5cbmZ1bmN0aW9uIGluaXQobW9kZWxCdW5kbGUsIGN0eCkge1xuICB2YXIgYXBwID0gZ2xvYmFsLkRFUkJZLmFwcFxuICAgICwgbnMgPSBjdHguJG5zXG4gICAgLCByZW5kZXJIYXNoID0gY3R4LiRyZW5kZXJIYXNoXG4gICAgLCBkZXJieSA9IHRoaXNcblxuICAvLyBUaGUgcmVhZHkgZXZlbnQgaXMgZmlyZWQgYWZ0ZXIgdGhlIG1vZGVsIGRhdGEgaXMgaW5pdGlhbGl6ZWRcbiAgcmFjZXIucmVhZHkoZnVuY3Rpb24obW9kZWwpIHtcbiAgICB2YXIgZG9tID0gbmV3IERvbShtb2RlbCk7XG5cbiAgICBhcHAubW9kZWwgPSBtb2RlbDtcbiAgICBhcHAuZG9tID0gZG9tO1xuXG4gICAgLy8gQ2FsbGluZyBoaXN0b3J5LnBhZ2UoKSBjcmVhdGVzIHRoZSBpbml0aWFsIHBhZ2UsIHdoaWNoIGlzIG9ubHlcbiAgICAvLyBjcmVhdGVkIG9uZSB0aW1lIG9uIHRoZSBjbGllbnRcbiAgICAvLyBUT0RPOiBUaGlzIGlzIGEgcmF0aGVyIG9idHVzZSBtZWNoYW5pc21cbiAgICB2YXIgcGFnZSA9IGFwcC5oaXN0b3J5LnBhZ2UoKTtcbiAgICBhcHAucGFnZSA9IHBhZ2U7XG4gICAgcGFnZS5tb2RlbCA9IG1vZGVsO1xuICAgIHBhZ2UuZG9tID0gZG9tO1xuXG4gICAgLy8gUmVpbml0aWFsaXplIGFueSB2aWV3TW9kZWxzIHdoaWNoIHdlcmUgYWxyZWFkeSBpbml0aWFsaXplZFxuICAgIC8vIGR1cmluZyByZW5kZXJpbmcgb24gdGhlIHNlcnZlclxuICAgIGlmIChjdHguJHZpZXdNb2RlbHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3R4LiR2aWV3TW9kZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gY3R4LiR2aWV3TW9kZWxzW2ldO1xuICAgICAgICB2YXIgdmlld01vZGVsID0gYXBwLl92aWV3TW9kZWxzW2l0ZW1bMF1dO1xuICAgICAgICBpdGVtWzFdLnVuc2hpZnQocGFnZSk7XG4gICAgICAgIHZpZXdNb2RlbC5pbml0LmFwcGx5KHZpZXdNb2RlbCwgaXRlbVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVyYnlNb2RlbC5pbml0KGRlcmJ5LCBhcHApO1xuICAgIC8vIENhdGNoIGVycm9ycyB0aHJvd24gd2hlbiByZW5kZXJpbmcgYW5kIHRoZW4gdGhyb3cgZnJvbSBhIHNldFRpbWVvdXQuXG4gICAgLy8gVGhpcyB3YXksIHRoZSByZW1haW5pbmcgaW5pdCBjb2RlIGNhbiBydW4gYW5kIHRoZSBhcHAgc3RpbGwgY29ubmVjdHNcbiAgICB0cnkge1xuICAgICAgLy8gUmVuZGVyIGltbWVkaWF0ZWx5IHVwb24gaW5pdGlhbGl6YXRpb24gc28gdGhhdCB0aGUgcGFnZSBpcyBpblxuICAgICAgLy8gRVhBQ1RMWSB0aGUgc2FtZSBzdGF0ZSBpdCB3YXMgd2hlbiByZW5kZXJlZCBvbiB0aGUgc2VydmVyXG4gICAgICBhcHAudmlldy5yZW5kZXIobW9kZWwsIG5zLCBjdHgsIHJlbmRlckhhc2gpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICAgIGFwcC5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgYXBwLmVtaXQoJ3JlYWR5Jyk7XG5cbiAgICB0cmFja3MucmVuZGVyKGFwcC5oaXN0b3J5LnBhZ2UoKSwge1xuICAgICAgdXJsOiB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoXG4gICAgLCBtZXRob2Q6ICdlbnRlcidcbiAgICAsIG5vTmF2aWdhdGU6IHRydWVcbiAgICB9KTtcblxuICAgIC8vIERlbGF5aW5nIGhlcmUgdG8gbWFrZSBzdXJlIHRoYXQgYWxsIHJlYWR5IGNhbGxiYWNrcyBhcmUgY2FsbGVkIGJlZm9yZVxuICAgIC8vIHRoZSBjcmVhdGUgZnVuY3Rpb25zIHJ1biBvbiB2YXJpb3VzIGNvbXBvbmVudHNcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgYXBwLnZpZXcuX2FmdGVyUmVuZGVyKG5zLCBjdHgpO1xuICAgIH0sIDApO1xuXG4gICAgaWYgKGN0eC4kc2NyaXB0UGF0aCkge1xuICAgICAgbW9kZWwuY2hhbm5lbC5zZW5kKCdkZXJieTphcHAnLCBjdHguJHNjcmlwdFBhdGgpO1xuICAgICAgcmVmcmVzaC5hdXRvUmVmcmVzaChhcHAudmlldywgbW9kZWwpO1xuICAgIH1cbiAgfSk7XG4gIHJhY2VyLmluaXQobW9kZWxCdW5kbGUpO1xufVxuXG59KSh3aW5kb3cpIiwidmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciByYWNlciA9IHJlcXVpcmUoJ3JhY2VyJyk7XG52YXIgY29tcG9uZW50ID0gcmVxdWlyZSgnLi9jb21wb25lbnQnKTtcbnZhciBWaWV3ID0gcmVxdWlyZSgnLi9WaWV3Jyk7XG52YXIgdmlld01vZGVsID0gcmVxdWlyZSgnLi92aWV3TW9kZWwnKTtcbnZhciBpc1NlcnZlciA9IHJhY2VyLnV0aWwuaXNTZXJ2ZXI7XG52YXIgcGF0aHMgPSByZXF1aXJlKCcuL3BhdGhzJyk7XG5cbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlQXBwO1xuXG5mdW5jdGlvbiBjcmVhdGVBcHAoZGVyYnksIGFwcE1vZHVsZSkge1xuICB2YXIgYXBwID0gcmFjZXIudXRpbC5tZXJnZUludG8oYXBwTW9kdWxlLmV4cG9ydHMsIEV2ZW50RW1pdHRlci5wcm90b3R5cGUpXG5cbiAgYXBwLnVzZSA9IHJhY2VyLnV0aWwudXNlO1xuICBjb21wb25lbnQoYXBwKTtcbiAgYXBwLmZpbGVuYW1lID0gYXBwTW9kdWxlLmZpbGVuYW1lO1xuICBhcHAudmlldyA9IG5ldyBWaWV3KGFwcC5fbGlicmFyaWVzLCBhcHAsIGFwcE1vZHVsZS5maWxlbmFtZSk7XG4gIGFwcC5mbiA9IGFwcEZuO1xuXG4gIGZ1bmN0aW9uIGFwcEZuKHZhbHVlLCBmbikge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBEb24ndCBiaW5kIHRoZSBmdW5jdGlvbiBvbiB0aGUgc2VydmVyLCBzaW5jZSBlYWNoXG4gICAgICAvLyByZW5kZXIgZ2V0cyBwYXNzZWQgYSBuZXcgbW9kZWwgYXMgcGFydCBvZiB0aGUgYXBwXG4gICAgICBwYXRocy5wYXRoTWVyZ2UoYXBwLCB2YWx1ZSwgZm4sIGJpbmRQYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aHMudHJlZU1lcmdlKGFwcCwgdmFsdWUsIGJpbmRQYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIGFwcDtcbiAgfVxuXG4gIGlmICghaXNTZXJ2ZXIpIHtcbiAgICB2YXIgYmluZFBhZ2UgPSBmdW5jdGlvbihmbikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkoYXBwLnBhZ2UsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICBhcHAuX3ZpZXdNb2RlbHMgPSB7fTtcbiAgYXBwLnZpZXdNb2RlbCA9IHZpZXdNb2RlbC5jb25zdHJ1Y3QuYmluZChhcHApO1xuXG4gIHJldHVybiBhcHA7XG59XG4iLCIoZnVuY3Rpb24oKXt2YXIgRXZlbnREaXNwYXRjaGVyID0gcmVxdWlyZSgnLi9FdmVudERpc3BhdGNoZXInKVxudmFyIFBhdGhNYXAgPSByZXF1aXJlKCcuL1BhdGhNYXAnKVxudmFyIE1vZGVsID0gcmVxdWlyZSgncmFjZXInKS5Nb2RlbFxudmFyIHZhbHVlQmluZGluZyA9IHJlcXVpcmUoJy4vVmlldycpLnZhbHVlQmluZGluZ1xudmFyIGFycmF5U2xpY2UgPSBbXS5zbGljZTtcblxuZXhwb3J0cy5pbml0ID0gaW5pdDtcblxuLy8gQWRkIHN1cHBvcnQgZm9yIGNyZWF0aW5nIGEgbW9kZWwgYWxpYXMgZnJvbSBhIERPTSBub2RlIG9yIGpRdWVyeSBvYmplY3Rcbk1vZGVsLnByb3RvdHlwZS5fX2F0ID0gTW9kZWwucHJvdG90eXBlLmF0O1xuTW9kZWwucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24obm9kZSkge1xuICB2YXIgaXNOb2RlID0gbm9kZSAmJiAobm9kZS5wYXJlbnROb2RlIHx8IG5vZGUuanF1ZXJ5ICYmIChub2RlID0gbm9kZVswXSkpO1xuICBpZiAoIWlzTm9kZSkgcmV0dXJuIHRoaXMuX19hdChub2RlKTtcblxuICB1cGRhdGVNYXJrZXJzKCk7XG5cbiAgdmFyIGJsb2NrUGF0aHMgPSB0aGlzLnJvb3QuX19ibG9ja1BhdGhzXG4gICAgLCBwYXRoTWFwID0gdGhpcy5yb290Ll9fcGF0aE1hcFxuICAgICwgY2hpbGQsIGksIGlkLCBsYXN0LCBwYXRoLCBibG9ja1BhdGgsIGNoaWxkcmVuLCBsZW47XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUuJGRlcmJ5TWFya2VyUGFyZW50ICYmIGxhc3QpIHtcbiAgICAgIG5vZGUgPSBsYXN0O1xuICAgICAgd2hpbGUgKG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZykge1xuICAgICAgICBpZiAoIShpZCA9IG5vZGUuJGRlcmJ5TWFya2VySWQpKSBjb250aW51ZTtcbiAgICAgICAgYmxvY2tQYXRoID0gYmxvY2tQYXRoc1tpZF07XG4gICAgICAgIGlmIChub2RlLiRkZXJieU1hcmtlckVuZCB8fCAhYmxvY2tQYXRoKSBicmVhaztcblxuICAgICAgICBwYXRoID0gcGF0aE1hcC5wYXRoc1tibG9ja1BhdGguaWRdO1xuICAgICAgICBpZiAoKGJsb2NrUGF0aC50eXBlID09PSAnZWFjaCcpICYmIGxhc3QpIHtcbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgICB3aGlsZSAobm9kZSA9IG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGlmIChub2RlID09PSBsYXN0KSB7XG4gICAgICAgICAgICAgIHBhdGggPSBwYXRoICsgJy4nICsgaTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlKHBhdGgpO1xuICAgICAgfVxuICAgICAgbGFzdCA9IGxhc3QucGFyZW50Tm9kZTtcbiAgICAgIG5vZGUgPSBsYXN0LnBhcmVudE5vZGU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKChpZCA9IG5vZGUuaWQpICYmIChibG9ja1BhdGggPSBibG9ja1BhdGhzW2lkXSkpIHtcbiAgICAgIHBhdGggPSBwYXRoTWFwLnBhdGhzW2Jsb2NrUGF0aC5pZF07XG4gICAgICBpZiAoKGJsb2NrUGF0aC50eXBlID09PSAnZWFjaCcpICYmIGxhc3QpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXM7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICBpZiAoY2hpbGQgPT09IGxhc3QpIHtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoICsgJy4nICsgaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc2NvcGUocGF0aCk7XG4gICAgfVxuICAgIGxhc3QgPSBub2RlO1xuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cblxuICAvLyBKdXN0IHJldHVybiB0aGUgcm9vdCBzY29wZSBpZiBhIHBhdGggY2FuJ3QgYmUgZm91bmRcbiAgcmV0dXJuIHRoaXMuc2NvcGUoKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTWFya2VycygpIHtcbiAgLy8gTm9kZUZpbHRlci5TSE9XX0NPTU1FTlQgPT0gMTI4XG4gIHZhciBjb21tZW50SXRlcmF0b3IgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGRvY3VtZW50LmJvZHksIDEyOCwgbnVsbCwgZmFsc2UpXG4gICAgLCBjb21tZW50LCBpZDtcbiAgd2hpbGUgKGNvbW1lbnQgPSBjb21tZW50SXRlcmF0b3IubmV4dE5vZGUoKSkge1xuICAgIGlmIChjb21tZW50LiRkZXJieUNoZWNrZWQpIGNvbnRpbnVlO1xuICAgIGNvbW1lbnQuJGRlcmJ5Q2hlY2tlZCA9IHRydWU7XG4gICAgaWQgPSBjb21tZW50LmRhdGE7XG4gICAgaWYgKGlkLmNoYXJBdCgwKSAhPT0gJyQnKSBjb250aW51ZTtcbiAgICBpZiAoaWQuY2hhckF0KDEpID09PSAnJCcpIHtcbiAgICAgIGNvbW1lbnQuJGRlcmJ5TWFya2VyRW5kID0gdHJ1ZTtcbiAgICAgIGlkID0gaWQuc2xpY2UoMSk7XG4gICAgfVxuICAgIGNvbW1lbnQuJGRlcmJ5TWFya2VySWQgPSBpZDtcbiAgICBjb21tZW50LnBhcmVudE5vZGUuJGRlcmJ5TWFya2VyUGFyZW50ID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0KGRlcmJ5LCBhcHApIHtcbiAgdmFyIG1vZGVsID0gYXBwLm1vZGVsO1xuICB2YXIgZG9tID0gYXBwLmRvbTtcbiAgdmFyIHBhdGhNYXAgPSBtb2RlbC5fX3BhdGhNYXAgPSBuZXcgUGF0aE1hcDtcbiAgdmFyIGV2ZW50cyA9IG1vZGVsLl9fZXZlbnRzID0gbmV3IEV2ZW50RGlzcGF0Y2hlcih7XG4gICAgb25UcmlnZ2VyOiBkZXJieU1vZGVsVHJpZ2dlclxuICAsIG9uQ2xlYW51cDogZGVyYnlNb2RlbEV2ZW50c0NsZWFudXBcbiAgfSk7XG5cbiAgZnVuY3Rpb24gZGVyYnlNb2RlbEV2ZW50c0NsZWFudXAocGF0aElkLCBsaXN0ZW5lcikge1xuICAgIHZhciBpZCA9IGxpc3RlbmVyWzBdO1xuICAgIHJldHVybiAhZG9tLml0ZW0oaWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVyYnlNb2RlbFRyaWdnZXIocGF0aElkLCBsaXN0ZW5lciwgdHlwZSwgcGFzcywgdmFsdWUsIGluZGV4LCBhcmcpIHtcbiAgICB2YXIgaWQgPSBsaXN0ZW5lclswXVxuICAgICAgLCBlbCA9IGRvbS5pdGVtKGlkKTtcblxuICAgIC8vIElnbm9yZSBpZiB0aGUgZWxlbWVudCBjYW4ndCBiZSBmb3VuZCwgYW5kIGNsZWFudXAgYWZ0ZXIgc29tZSBkZWxheVxuICAgIGlmICghZWwpIHJldHVybiBldmVudHMuZGVsYXllZENsZWFudXAocGF0aElkKTtcblxuICAgIHZhciBtZXRob2QgPSBsaXN0ZW5lclsxXVxuICAgICAgLCBwcm9wZXJ0eSA9IGxpc3RlbmVyWzJdXG4gICAgICAsIHBhcnRpYWwgPSBsaXN0ZW5lci5wYXJ0aWFsXG4gICAgICAsIHBhdGggPSBwYXRoTWFwLnBhdGhzW3BhdGhJZF1cbiAgICAgICwgdHJpZ2dlcklkO1xuXG4gICAgLy8gSGFuZGxlIHRleHQgT1QgZXZlbnRzXG4gICAgaWYgKHR5cGUgPT09ICdzdHJpbmdJbnNlcnQnIHx8IHR5cGUgPT09ICdzdHJpbmdSZW1vdmUnKSB7XG4gICAgICBpZiAobWV0aG9kICE9PSAncHJvcE90JyB8fCBlbCA9PT0gcGFzcy4kZWwpIHJldHVybjtcbiAgICAgIG1ldGhvZCA9IHR5cGU7XG4gICAgfVxuICAgIC8vIElnbm9yZSBzaWRlLWVmZmVjdCBjaGFuZ2UgZXZlbnRzIHRoYXQgd2VyZSBhbHJlYWR5IGhhbmRsZWRcbiAgICBpZiAobWV0aG9kID09PSAncHJvcE90JyAmJiAocGFzcy4kb3JpZ2luYWwgPT09ICdzdHJpbmdJbnNlcnQnIHx8IHBhc3MuJG9yaWdpbmFsID09PSAnc3RyaW5nUmVtb3ZlJykpIHJldHVybjtcblxuICAgIGlmIChwYXJ0aWFsKSB7XG4gICAgICB0cmlnZ2VySWQgPSBpZDtcbiAgICAgIGlmIChtZXRob2QgPT09ICdodG1sJyAmJiB0eXBlKSB7XG4gICAgICAgIGlmIChwYXJ0aWFsLnR5cGUgPT09ICdlYWNoJykge1xuICAgICAgICAgIC8vIEhhbmRsZSBhcnJheSB1cGRhdGVzXG4gICAgICAgICAgbWV0aG9kID0gdHlwZTtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2luc2VydCcpIHtcbiAgICAgICAgICAgIHRyaWdnZXJJZCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAncmVtb3ZlJykge1xuICAgICAgICAgICAgcGFydGlhbCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbW92ZScpIHtcbiAgICAgICAgICAgIHBhcnRpYWwgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IG1vZGVsLmdldChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGlzdGVuZXIuZ2V0VmFsdWUpIHtcbiAgICAgIHZhbHVlID0gbGlzdGVuZXIuZ2V0VmFsdWUobW9kZWwsIHBhdGgpO1xuICAgIH1cbiAgICBpZiAocGFydGlhbCkge1xuICAgICAgLy8gVE9ETyBHZXQgcmlkIG9mIG1vZGVsLl9fZm5DdHggY2FjaGVcbiAgICAgIC8vIFdhcyBjYXVzaW5nIGlzc3VlcyB3aXRoIG5vdCBlbWl0dGluZyBcImluaXQ6Y2hpbGRcIiBvciBcImNyZWF0ZTpjaGlsZFwiXG4gICAgICAvLyB3aGVuIGR5bmFtaWNhbGx5IHJlbmRlcmluZyBhIGNvbXBvbmVudCBpbnNpZGUgYSBwYXJlbnQgY29tcG9uZW50XG4gICAgICAvLyB3aXRoaW4gYW4gZWFjaCBibG9jay5cbiAgICAgIGRlbGV0ZSBtb2RlbC5fX2ZuQ3R4O1xuXG4gICAgICBpZiAobWV0aG9kID09PSAnaW5zZXJ0Jykge1xuICAgICAgICB2YXIgdmFsdWVzID0gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB2YWx1ZSArPSBwYXJ0aWFsKGxpc3RlbmVyLmN0eCwgbW9kZWwsIHRyaWdnZXJJZCwgdmFsdWVzW2ldLCBpbmRleCArIGksIGxpc3RlbmVyKSB8fCAnPCEtLWVtcHR5LS0+JztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBwYXJ0aWFsKGxpc3RlbmVyLmN0eCwgbW9kZWwsIHRyaWdnZXJJZCwgdmFsdWUsIGluZGV4LCBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfVxuICAgIHZhbHVlID0gdmFsdWVCaW5kaW5nKHZhbHVlKTtcbiAgICBkb20udXBkYXRlKGVsLCBtZXRob2QsIHBhc3MuaWdub3JlLCB2YWx1ZSwgcHJvcGVydHksIGluZGV4LCBhcmcpO1xuICAgIC8vIEhBQ0s6IFVzZSBvZiBnbG9iYWxcbiAgICBERVJCWS5hcHAudmlldy5fZmx1c2hVbmNyZWF0ZWQoKTtcbiAgfVxuXG4gIHZhciB0eXBlcyA9IE9iamVjdC5rZXlzKE1vZGVsLk1VVEFUT1JfRVZFTlRTKTtcbiAgdHlwZXMucHVzaCgnYWxsJyk7XG4gIHR5cGVzLmZvckVhY2goZnVuY3Rpb24odHlwZSkge1xuICAgIHZhciBiZWZvcmVUeXBlID0gJ2JlZm9yZUJpbmRpbmc6JyArIHR5cGU7XG4gICAgbW9kZWwub24odHlwZSwgZnVuY3Rpb24oc2VnbWVudHMsIGV2ZW50QXJncykge1xuICAgICAgbW9kZWwuZW1pdChiZWZvcmVUeXBlLCBzZWdtZW50cywgZXZlbnRBcmdzKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgbW9kZWwub24oJ2NoYW5nZScsICcqKicsIGZ1bmN0aW9uIGRlcmJ5T25DaGFuZ2UocGF0aCwgdmFsdWUsIHByZXZpb3VzLCBwYXNzKSB7XG4gICAgLy8gRm9yIHNldCBvcGVyYXRpb25zIG9uIGFycmF5IGl0ZW1zLCBhbHNvIGVtaXQgYSByZW1vdmUgYW5kIGluc2VydCBpbiBjYXNlIHRoZVxuICAgIC8vIGFycmF5IGlzIGJvdW5kXG4gICAgaWYgKC9cXC5cXGQrJC8udGVzdChwYXRoKSkge1xuICAgICAgdmFyIGkgPSBwYXRoLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgICB2YXIgYXJyYXlQYXRoID0gcGF0aC5zbGljZSgwLCBpKTtcbiAgICAgIHZhciBpbmRleCA9ICtwYXRoLnNsaWNlKGkgKyAxKTtcbiAgICAgIHRyaWdnZXJFYWNoKGFycmF5UGF0aCwgJ3JlbW92ZScsIHBhc3MsIGluZGV4KTtcbiAgICAgIHRyaWdnZXJFYWNoKGFycmF5UGF0aCwgJ2luc2VydCcsIHBhc3MsIFt2YWx1ZV0sIGluZGV4KTtcbiAgICB9XG4gICAgdHJpZ2dlckVhY2gocGF0aCwgJ2h0bWwnLCBwYXNzLCB2YWx1ZSk7XG4gIH0pO1xuXG4gIG1vZGVsLm9uKCdsb2FkJywgJyoqJywgZnVuY3Rpb24gZGVyYnlPbkxvYWQocGF0aCwgdmFsdWUsIHBhc3MpIHtcbiAgICB0cmlnZ2VyRWFjaChwYXRoLCAnaHRtbCcsIHBhc3MsIHZhbHVlKTtcbiAgfSk7XG5cbiAgbW9kZWwub24oJ3VubG9hZCcsICcqKicsIGZ1bmN0aW9uIGRlcmJ5T25Mb2FkKHBhdGgsIHByZXZpb3VzLCBwYXNzKSB7XG4gICAgdHJpZ2dlckVhY2gocGF0aCwgJ2h0bWwnLCBwYXNzLCB2b2lkIDApO1xuICB9KTtcblxuICBtb2RlbC5vbignaW5zZXJ0JywgJyoqJywgZnVuY3Rpb24gZGVyYnlPbkluc2VydChwYXRoLCBpbmRleCwgdmFsdWVzLCBwYXNzKSB7XG4gICAgcGF0aE1hcC5vbkluc2VydChwYXRoLCBpbmRleCwgdmFsdWVzLmxlbmd0aCk7XG4gICAgdHJpZ2dlckVhY2gocGF0aCwgJ2luc2VydCcsIHBhc3MsIHZhbHVlcywgaW5kZXgpO1xuICB9KTtcblxuICBtb2RlbC5vbigncmVtb3ZlJywgJyoqJywgZnVuY3Rpb24gZGVyYnlPblJlbW92ZShwYXRoLCBpbmRleCwgcmVtb3ZlZCwgcGFzcykge1xuICAgIHZhciBob3dNYW55ID0gcmVtb3ZlZC5sZW5ndGg7XG4gICAgdmFyIGVuZCA9IGluZGV4ICsgaG93TWFueTtcbiAgICBwYXRoTWFwLm9uUmVtb3ZlKHBhdGgsIGluZGV4LCBob3dNYW55KTtcblxuICAgIGZvciAodmFyIGkgPSBpbmRleDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB2YXIgaWQgPSBwYXRoTWFwLmlkc1twYXRoXTtcbiAgICAgIGlmIChpZCkgZXZlbnRzLnRyaWdnZXIoaWQsICdyZW1vdmUnLCBwYXNzLCBpbmRleCk7XG4gICAgfVxuICAgIHRyaWdnZXJQYXJlbnRzKHBhdGgsIHBhc3MpO1xuICB9KTtcblxuICBtb2RlbC5vbignbW92ZScsICcqKicsIGZ1bmN0aW9uIGRlcmJ5T25Nb3ZlKHBhdGgsIGZyb20sIHRvLCBob3dNYW55LCBwYXNzKSB7XG4gICAgcGF0aE1hcC5vbk1vdmUocGF0aCwgZnJvbSwgdG8sIGhvd01hbnkpO1xuICAgIHRyaWdnZXJFYWNoKHBhdGgsICdtb3ZlJywgcGFzcywgZnJvbSwgdG8sIGhvd01hbnkpO1xuICB9KTtcblxuICBtb2RlbC5vbignc3RyaW5nSW5zZXJ0JywgJyoqJywgZnVuY3Rpb24gZGVyYnlPblN0cmluZ0luc2VydChwYXRoLCBpbmRleCwgaW5zZXJ0ZWQsIHBhc3MpIHtcbiAgICB2YXIgdmFsdWUgPSBtb2RlbC5nZXQocGF0aCk7XG4gICAgdmFyIGlkID0gcGF0aE1hcC5pZHNbcGF0aF07XG4gICAgZXZlbnRzLnRyaWdnZXIoaWQsICdzdHJpbmdJbnNlcnQnLCBwYXNzLCB2YWx1ZSwgaW5kZXgsIGluc2VydGVkKTtcbiAgfSk7XG5cbiAgbW9kZWwub24oJ3N0cmluZ1JlbW92ZScsICcqKicsIGZ1bmN0aW9uIGRlcmJ5T25TdHJpbmdSZW1vdmUocGF0aCwgaW5kZXgsIGhvd01hbnksIHBhc3MpIHtcbiAgICB2YXIgdmFsdWUgPSBtb2RlbC5nZXQocGF0aCk7XG4gICAgdmFyIGlkID0gcGF0aE1hcC5pZHNbcGF0aF07XG4gICAgZXZlbnRzLnRyaWdnZXIoaWQsICdzdHJpbmdSZW1vdmUnLCBwYXNzLCB2YWx1ZSwgaW5kZXgsIGhvd01hbnkpO1xuICB9KTtcblxuICBmdW5jdGlvbiB0cmlnZ2VyRWFjaChwYXRoLCB0eXBlLCBwYXNzLCBhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgLy8gVHJpZ2dlciBhbiBldmVudCBvbiB0aGUgcGF0aCBpZiBpdCBoYXMgYSBwYXRoTWFwIElEXG4gICAgdmFyIGlkID0gcGF0aE1hcC5pZHNbcGF0aF07XG4gICAgaWYgKGlkKSBldmVudHMudHJpZ2dlcihpZCwgdHlwZSwgcGFzcywgYXJnMCwgYXJnMSwgYXJnMik7XG4gICAgLy8gVHJpZ2dlciBhIHBhdHRlcm4gZXZlbnQgZm9yIHRoZSBwYXRoIGFuZCBlYWNoIG9mIGl0cyBwYXJlbnQgcGF0aHNcbiAgICAvLyBUaGlzIGlzIHVzZWQgYnkgdmlldyBoZWxwZXIgZnVuY3Rpb25zIHRvIG1hdGNoIHVwZGF0ZXMgb24gYSBwYXRoXG4gICAgLy8gb3IgYW55IG9mIGl0cyBjaGlsZCBzZWdtZW50c1xuICAgIHRyaWdnZXJQYXJlbnRzKHBhdGgsIHBhc3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJpZ2dlclBhcmVudHMocGF0aCwgcGFzcykge1xuICAgIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gc2VnbWVudHMubGVuZ3RoOyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgcGF0dGVybiA9IHNlZ21lbnRzLnNsaWNlKDAsIGkpLmpvaW4oJy4nKSArICcqJztcbiAgICAgIHZhciBpZCA9IHBhdGhNYXAuaWRzW3BhdHRlcm5dO1xuICAgICAgaWYgKGlkKSBldmVudHMudHJpZ2dlcihpZCwgbnVsbCwgcGFzcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1vZGVsO1xufVxuXG59KSgpIiwidmFyIHBhdGhzID0gcmVxdWlyZSgnLi9wYXRocycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3Rcbn07XG5cbmZ1bmN0aW9uIFZpZXdNb2RlbChuYW1lLCBwcm90bykge1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLnByb3RvID0gcHJvdG87XG59XG5WaWV3TW9kZWwucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihwYWdlKSB7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgLy8gVmlld01vZGVscyBhcmUgYWN0dWFsbHkganVzdCBzY29wZWQgbW9kZWxzIGZvciBub3dcbiAgdmFyIF9zdXBlciA9IHBhZ2UubW9kZWwuYXQodGhpcy5uYW1lKTtcbiAgdmFyIHZpZXdNb2RlbCA9IF9zdXBlci5fY2hpbGQoKTtcblxuICAvLyBNaXhpbiB2aWV3TW9kZWwgc3BlY2lmaWMgbWV0aG9kc1xuICB2aWV3TW9kZWwuX3N1cGVyID0gX3N1cGVyO1xuICB2aWV3TW9kZWwucGFnZSA9IHBhZ2U7XG4gIHZpZXdNb2RlbC5tb2RlbCA9IHBhZ2UubW9kZWw7XG4gIGZvciAoa2V5IGluIHRoaXMucHJvdG8pIHtcbiAgICBpZiAoa2V5ID09PSAnaW5pdCcpIGNvbnRpbnVlO1xuICAgIHZpZXdNb2RlbFtrZXldID0gdGhpcy5wcm90b1trZXldLmJpbmQodmlld01vZGVsKTtcbiAgfVxuICBpZiAodGhpcy5wcm90by5pbml0KSB7XG4gICAgLy8gS2VlcCB0cmFjayBvZiB2aWV3TW9kZWxzIHRoYXQgd2VyZSBjcmVhdGVkIHNvIHRoYXRcbiAgICAvLyB0aGV5IGNhbiBiZSByZWNyZWF0ZWQgb24gdGhlIGNsaWVudCBpZiBmaXJzdCByZW5kZXJlZFxuICAgIC8vIG9uIHRoZSBzZXJ2ZXJcbiAgICBwYWdlLl92aWV3TW9kZWxzLnB1c2goW3RoaXMubmFtZSwgYXJnc10pO1xuICAgIHRoaXMucHJvdG8uaW5pdC5hcHBseSh2aWV3TW9kZWwsIGFyZ3MpO1xuICB9XG5cbiAgLy8gTWFrZSB2aWV3TW9kZWwgYXZhaWxhYmxlIG9uIHRoZSBwYWdlIGZvciB1c2UgaW5cbiAgLy8gZXZlbnQgY2FsbGJhY2tzIGFuZCBvdGhlciBmdW5jdGlvbnNcbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5uYW1lLnNwbGl0KCcuJyk7XG4gIHZhciBsYXN0ID0gc2VnbWVudHMucG9wKCk7XG4gIHZhciBub2RlID0gcGF0aHMudHJhdmVyc2VOb2RlKHBhZ2UsIHNlZ21lbnRzKTtcbiAgbm9kZVtsYXN0XSA9IHZpZXdNb2RlbDtcblxuICByZXR1cm4gdmlld01vZGVsO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3QobmFtZSwgcHJvdG8pIHtcbiAgLy8gS2VlcCBhIG1hcCBvZiBkZWZpbmVkIHZpZXdNb2RlbHMgc28gdGhhdCB0aGV5IGNhblxuICAvLyBiZSByZWluaXRpYWxpemVkIGZyb20gdGhlaXIgbmFtZSBvbiB0aGUgY2xpZW50XG4gIHZhciB2aWV3TW9kZWwgPSB0aGlzLl92aWV3TW9kZWxzW25hbWVdID0gbmV3IFZpZXdNb2RlbChuYW1lLCBwcm90byk7XG4gIHJldHVybiB2aWV3TW9kZWw7XG59XG4iLCIoZnVuY3Rpb24oX19kaXJuYW1lKXttb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG4vLyBFeHRlbmQgbW9kZWwgb24gYm90aCBzZXJ2ZXIgYW5kIGNsaWVudCAvL1xucmVxdWlyZSgnLi9ldmVudHMnKTtcbnJlcXVpcmUoJy4vcGF0aHMnKTtcbnJlcXVpcmUoJy4vY29sbGVjdGlvbnMnKTtcbnJlcXVpcmUoJy4vbXV0YXRvcnMnKTtcbnJlcXVpcmUoJy4vc2V0RGlmZicpO1xuXG5yZXF1aXJlKCcuL2Nvbm5lY3Rpb24nKTtcbnJlcXVpcmUoJy4vc3Vic2NyaXB0aW9ucycpO1xucmVxdWlyZSgnLi9RdWVyeScpO1xucmVxdWlyZSgnLi9jb250ZXh0cycpO1xuXG5yZXF1aXJlKCcuL2ZuJyk7XG5yZXF1aXJlKCcuL2ZpbHRlcicpO1xucmVxdWlyZSgnLi9yZWZMaXN0Jyk7XG5yZXF1aXJlKCcuL3JlZicpO1xuXG4vLyBFeHRlbmQgbW9kZWwgZm9yIHNlcnZlciAvL1xudXRpbC5zZXJ2ZXJSZXF1aXJlKF9fZGlybmFtZSArICcvYnVuZGxlJyk7XG51dGlsLnNlcnZlclJlcXVpcmUoX19kaXJuYW1lICsgJy9jb25uZWN0aW9uLnNlcnZlcicpO1xuXG59KShcIi9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL2xpYi9Nb2RlbFwiKSIsIm1vZHVsZS5leHBvcnRzID0ge1xuICB0cmF2ZXJzZU5vZGU6IHRyYXZlcnNlTm9kZVxuLCBwYXRoTWVyZ2U6IHBhdGhNZXJnZVxuLCB0cmVlTWVyZ2U6IHRyZWVNZXJnZVxufTtcblxuZnVuY3Rpb24gdHJhdmVyc2VOb2RlKG5vZGUsIHNlZ21lbnRzKSB7XG4gIHZhciBpLCBsZW4sIHNlZ21lbnRcbiAgZm9yIChpID0gMCwgbGVuID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgbm9kZSA9IG5vZGVbc2VnbWVudF0gfHwgKG5vZGVbc2VnbWVudF0gPSB7fSk7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8vIFJlY3Vyc2l2ZWx5IHNldCBuZXN0ZWQgb2JqZWN0cyBiYXNlZCBvbiBhIHBhdGhcbmZ1bmN0aW9uIHBhdGhNZXJnZShub2RlLCBwYXRoLCB2YWx1ZSwgbm9kZUZuKSB7XG4gIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKVxuICAgICwgbGFzdCwgaSwgbGVuLCBzZWdtZW50XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgbm9kZSA9IHRyYXZlcnNlTm9kZShub2RlLCBzZWdtZW50cyk7XG4gICAgdHJlZU1lcmdlKG5vZGUsIHZhbHVlLCBub2RlRm4pO1xuICAgIHJldHVybjtcbiAgfVxuICBsYXN0ID0gc2VnbWVudHMucG9wKCk7XG4gIG5vZGUgPSB0cmF2ZXJzZU5vZGUobm9kZSwgc2VnbWVudHMpO1xuICBub2RlW2xhc3RdID0gKG5vZGVGbikgPyBub2RlRm4odmFsdWUpIDogdmFsdWU7XG59XG5cbi8vIFJlY3Vyc2l2ZWx5IHNldCBvYmplY3RzIHN1Y2ggdGhhdCB0aGUgbm9uLW9iamVjdHMgYXJlXG4vLyBtZXJnZWQgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBzdHJ1Y3R1cmUgb2YgdGhlIGJhc2Ugbm9kZVxuZnVuY3Rpb24gdHJlZU1lcmdlKG5vZGUsIHRyZWUsIG5vZGVGbikge1xuICB2YXIga2V5LCBjaGlsZCwgdmFsdWVcbiAgZm9yIChrZXkgaW4gdHJlZSkge1xuICAgIHZhbHVlID0gdHJlZVtrZXldO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBjaGlsZCA9IG5vZGVba2V5XSB8fCAobm9kZVtrZXldID0ge30pO1xuICAgICAgdHJlZU1lcmdlKGNoaWxkLCB2YWx1ZSwgbm9kZUZuKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBub2RlW2tleV0gPSAobm9kZUZuKSA/IG5vZGVGbih2YWx1ZSkgOiB2YWx1ZTtcbiAgfVxufVxuIiwiZnVuY3Rpb24gZW1wdHkoKSB7fVxuZnVuY3Rpb24gRXZlbnREaXNwYXRjaGVyTmFtZXMoKSB7fVxuZnVuY3Rpb24gRXZlbnREaXNwYXRjaGVyTGlzdGVuZXJzKCkge31cbmZ1bmN0aW9uIENsZWFudXBQZW5kaW5nTWFwKCkge31cblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudERpc3BhdGNoZXI7XG5cbmZ1bmN0aW9uIEV2ZW50RGlzcGF0Y2hlcihvcHRpb25zKSB7XG4gIHRoaXMuX29uVHJpZ2dlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5vblRyaWdnZXIgfHwgZW1wdHk7XG4gIHRoaXMuX29uQmluZCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5vbkJpbmQgfHwgZW1wdHk7XG4gIHRoaXMuX29uQ2xlYW51cCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5vbkNsZWFudXA7XG4gIHRoaXMuX2NsZWFudXBQZW5kaW5nID0gbmV3IENsZWFudXBQZW5kaW5nTWFwKCk7XG4gIHRoaXMuY2xlYXIoKTtcbn1cblxuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLm5hbWVzID0gbmV3IEV2ZW50RGlzcGF0Y2hlck5hbWVzKCk7XG59O1xuXG5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihuYW1lLCBsaXN0ZW5lciwgYXJnMCkge1xuICB0aGlzLl9vbkJpbmQobmFtZSwgbGlzdGVuZXIsIGFyZzApO1xuICB2YXIgb2JqID0gdGhpcy5uYW1lc1tuYW1lXSB8fCAodGhpcy5uYW1lc1tuYW1lXSA9IG5ldyBFdmVudERpc3BhdGNoZXJMaXN0ZW5lcnMoKSk7XG4gIG9ialtKU09OLnN0cmluZ2lmeShsaXN0ZW5lcildID0gbGlzdGVuZXI7XG4gIHJldHVybiBvYmo7XG59O1xuXG5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSkge1xuICBpZiAoIW5hbWUpIHJldHVybjtcbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMubmFtZXNbbmFtZV07XG4gIHZhciBvblRyaWdnZXIgPSB0aGlzLl9vblRyaWdnZXI7XG4gIHZhciBjb3VudCA9IDA7XG4gIHZhciBrZXksIGxpc3RlbmVyO1xuICBmb3IgKGtleSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBsaXN0ZW5lciA9IGxpc3RlbmVyc1trZXldO1xuICAgIGNvdW50Kys7XG4gICAgaWYgKGZhbHNlICE9PSBvblRyaWdnZXIobmFtZSwgbGlzdGVuZXIsIHZhbHVlLCBhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGRlbGV0ZSBsaXN0ZW5lcnNba2V5XTtcbiAgICBjb3VudC0tO1xuICB9XG4gIGlmICghY291bnQpIGRlbGV0ZSB0aGlzLm5hbWVzW25hbWVdO1xuICByZXR1cm4gY291bnQ7XG59O1xuXG5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmRlbGF5ZWRDbGVhbnVwID0gZnVuY3Rpb24obmFtZSkge1xuICBpZiAodGhpcy5fY2xlYW51cFBlbmRpbmdbbmFtZV0pIHJldHVybjtcbiAgdGhpcy5fY2xlYW51cFBlbmRpbmdbbmFtZV0gPSB0cnVlO1xuICB2YXIgZXZlbnREaXNwYXRjaGVyID0gdGhpcztcbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBkZWxldGUgZXZlbnREaXNwYXRjaGVyLl9jbGVhbnVwUGVuZGluZ1tuYW1lXTtcbiAgICBldmVudERpc3BhdGNoZXIuY2xlYW51cChuYW1lKTtcbiAgfSwgMCk7XG59O1xuXG5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLm5hbWVzW25hbWVdO1xuICB2YXIgaGFzS2V5cyA9IGZhbHNlO1xuICB2YXIga2V5LCByZW1vdmU7XG4gIGZvciAoa2V5IGluIGxpc3RlbmVycykge1xuICAgIHJlbW92ZSA9IHRoaXMuX29uQ2xlYW51cChuYW1lLCBsaXN0ZW5lcnNba2V5XSk7XG4gICAgaWYgKHJlbW92ZSkge1xuICAgICAgZGVsZXRlIGxpc3RlbmVyc1trZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYXNLZXlzID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNLZXlzKSBkZWxldGUgdGhpcy5uYW1lc1tuYW1lXTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFBhdGhNYXA7XG5cbmZ1bmN0aW9uIFBhdGhNYXAoKSB7XG4gIHRoaXMuY2xlYXIoKTtcbiAgdGhpcy5jb3VudCA9IDA7XG59XG5cblBhdGhNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaWRzID0ge307XG4gIHRoaXMucGF0aHMgPSB7fTtcbiAgdGhpcy5hcnJheXMgPSB7fTtcbn07XG5cblBhdGhNYXAucHJvdG90eXBlLmlkID0gZnVuY3Rpb24ocGF0aCkge1xuICAvLyBSZXR1cm4gdGhlIHBhdGggZm9yIGFuIGlkLCBvciBjcmVhdGUgYSBuZXcgaWQgYW5kIGluZGV4IGl0XG4gIHZhciBpZCA9IHRoaXMuaWRzW3BhdGhdO1xuICBpZiAoaWQpIHJldHVybiBpZDtcbiAgaWQgPSAoKyt0aGlzLmNvdW50KS50b1N0cmluZygpO1xuICB0aGlzLnBhdGhzW2lkXSA9IHBhdGg7XG4gIHRoaXMuX2luZGV4QXJyYXkocGF0aCwgaWQpO1xuICB0aGlzLmlkc1twYXRoXSA9IGlkO1xuICByZXR1cm4gaWQ7XG59O1xuXG5QYXRoTWFwLnByb3RvdHlwZS5faW5kZXhBcnJheSA9IGZ1bmN0aW9uKHBhdGgsIGlkKSB7XG4gIHZhciBhcnIsIGluZGV4LCBtYXRjaCwgbmVzdGVkLCByZW1haW5kZXIsIHNldCwgc2V0QXJyYXlzO1xuICB3aGlsZSAobWF0Y2ggPSAvXiguKylcXC4oXFxkKykoXFwqPyg/OlxcLi4rfCQpKS8uZXhlYyhwYXRoKSkge1xuICAgIHBhdGggPSBtYXRjaFsxXTtcbiAgICBpbmRleCA9ICttYXRjaFsyXTtcbiAgICByZW1haW5kZXIgPSBtYXRjaFszXTtcbiAgICBhcnIgPSB0aGlzLmFycmF5c1twYXRoXSB8fCAodGhpcy5hcnJheXNbcGF0aF0gPSBbXSk7XG4gICAgc2V0ID0gYXJyW2luZGV4XSB8fCAoYXJyW2luZGV4XSA9IHt9KTtcbiAgICBpZiAobmVzdGVkKSB7XG4gICAgICBzZXRBcnJheXMgPSBzZXQuYXJyYXlzIHx8IChzZXQuYXJyYXlzID0ge30pO1xuICAgICAgc2V0QXJyYXlzW3JlbWFpbmRlcl0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRbaWRdID0gcmVtYWluZGVyO1xuICAgIH1cbiAgICBuZXN0ZWQgPSB0cnVlO1xuICB9XG59O1xuXG5QYXRoTWFwLnByb3RvdHlwZS5faW5jckl0ZW1zID0gZnVuY3Rpb24ocGF0aCwgbWFwLCBzdGFydCwgZW5kLCBieU51bSwgb2xkQXJyYXlzLCBvbGRQYXRoKSB7XG4gIHZhciBhcnJheU1hcCwgYXJyYXlQYXRoLCBhcnJheVBhdGhUbywgaSwgaWQsIGlkcywgaXRlbVBhdGgsIHJlbWFpbmRlcjtcbiAgaWYgKG9sZEFycmF5cyA9PSBudWxsKSBvbGRBcnJheXMgPSB7fTtcblxuICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWRzID0gbWFwW2ldO1xuICAgIGlmICghaWRzKSBjb250aW51ZTtcblxuICAgIGZvciAoaWQgaW4gaWRzKSB7XG4gICAgICByZW1haW5kZXIgPSBpZHNbaWRdO1xuICAgICAgaWYgKGlkID09PSAnYXJyYXlzJykge1xuICAgICAgICBmb3IgKHJlbWFpbmRlciBpbiBpZHNbaWRdKSB7XG4gICAgICAgICAgYXJyYXlQYXRoID0gKG9sZFBhdGggfHwgcGF0aCkgKyAnLicgKyBpICsgcmVtYWluZGVyO1xuICAgICAgICAgIGFycmF5TWFwID0gb2xkQXJyYXlzW2FycmF5UGF0aF0gfHwgdGhpcy5hcnJheXNbYXJyYXlQYXRoXTtcbiAgICAgICAgICBpZiAoYXJyYXlNYXApIHtcbiAgICAgICAgICAgIGFycmF5UGF0aFRvID0gcGF0aCArICcuJyArIChpICsgYnlOdW0pICsgcmVtYWluZGVyO1xuICAgICAgICAgICAgdGhpcy5hcnJheXNbYXJyYXlQYXRoVG9dID0gYXJyYXlNYXA7XG4gICAgICAgICAgICB0aGlzLl9pbmNySXRlbXMoYXJyYXlQYXRoVG8sIGFycmF5TWFwLCAwLCBhcnJheU1hcC5sZW5ndGgsIDAsIG9sZEFycmF5cywgYXJyYXlQYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGl0ZW1QYXRoID0gcGF0aCArICcuJyArIChpICsgYnlOdW0pICsgcmVtYWluZGVyO1xuICAgICAgdGhpcy5wYXRoc1tpZF0gPSBpdGVtUGF0aDtcbiAgICAgIHRoaXMuaWRzW2l0ZW1QYXRoXSA9ICtpZDtcbiAgICB9XG4gIH1cbn07XG5cblBhdGhNYXAucHJvdG90eXBlLl9kZWxJdGVtcyA9IGZ1bmN0aW9uKHBhdGgsIG1hcCwgc3RhcnQsIGVuZCwgbGVuLCBvbGRBcnJheXMpIHtcbiAgdmFyIGFycmF5TGVuLCBhcnJheU1hcCwgYXJyYXlQYXRoLCBpLCBpZCwgaWRzLCBpdGVtUGF0aCwgcmVtYWluZGVyO1xuICBpZiAob2xkQXJyYXlzID09IG51bGwpIG9sZEFycmF5cyA9IHt9O1xuXG4gIGZvciAoaSA9IHN0YXJ0OyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZHMgPSBtYXBbaV07XG4gICAgaWYgKCFpZHMpIGNvbnRpbnVlO1xuXG4gICAgZm9yIChpZCBpbiBpZHMpIHtcbiAgICAgIGlmIChpZCA9PT0gJ2FycmF5cycpIHtcbiAgICAgICAgZm9yIChyZW1haW5kZXIgaW4gaWRzW2lkXSkge1xuICAgICAgICAgIGFycmF5UGF0aCA9IHBhdGggKyAnLicgKyBpICsgcmVtYWluZGVyO1xuICAgICAgICAgIGlmIChhcnJheU1hcCA9IHRoaXMuYXJyYXlzW2FycmF5UGF0aF0pIHtcbiAgICAgICAgICAgIGFycmF5TGVuID0gYXJyYXlNYXAubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5fZGVsSXRlbXMoYXJyYXlQYXRoLCBhcnJheU1hcCwgMCwgYXJyYXlMZW4sIGFycmF5TGVuLCBvbGRBcnJheXMpO1xuICAgICAgICAgICAgb2xkQXJyYXlzW2FycmF5UGF0aF0gPSBhcnJheU1hcDtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmFycmF5c1thcnJheVBhdGhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaXRlbVBhdGggPSB0aGlzLnBhdGhzW2lkXTtcbiAgICAgIGRlbGV0ZSB0aGlzLmlkc1tpdGVtUGF0aF07XG4gICAgICBpZiAoaSA+IGVuZCkgY29udGludWU7XG4gICAgICBkZWxldGUgdGhpcy5wYXRoc1tpZF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9sZEFycmF5cztcbn07XG5cblBhdGhNYXAucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24ocGF0aCwgc3RhcnQsIGhvd01hbnkpIHtcbiAgdmFyIG1hcCA9IHRoaXMuYXJyYXlzW3BhdGhdXG4gICAgLCBlbmQsIGxlbiwgb2xkQXJyYXlzO1xuICBpZiAoIW1hcCkgcmV0dXJuO1xuICBlbmQgPSBzdGFydCArIGhvd01hbnk7XG4gIGxlbiA9IG1hcC5sZW5ndGg7XG4gIC8vIERlbGV0ZSBpbmRpY2llcyBmb3IgcmVtb3ZlZCBpdGVtc1xuICBvbGRBcnJheXMgPSB0aGlzLl9kZWxJdGVtcyhwYXRoLCBtYXAsIHN0YXJ0LCBlbmQgKyAxLCBsZW4pO1xuICAvLyBEZWNyZW1lbnQgaW5kaWNpZXMgb2YgbGF0ZXIgaXRlbXNcbiAgdGhpcy5faW5jckl0ZW1zKHBhdGgsIG1hcCwgZW5kLCBsZW4sIC1ob3dNYW55LCBvbGRBcnJheXMpO1xuICBtYXAuc3BsaWNlKHN0YXJ0LCBob3dNYW55KTtcbn07XG5cblBhdGhNYXAucHJvdG90eXBlLm9uSW5zZXJ0ID0gZnVuY3Rpb24ocGF0aCwgc3RhcnQsIGhvd01hbnkpIHtcbiAgdmFyIG1hcCA9IHRoaXMuYXJyYXlzW3BhdGhdXG4gICAgLCBlbmQsIGxlbiwgb2xkQXJyYXlzO1xuICBpZiAoIW1hcCkgcmV0dXJuO1xuICBlbmQgPSBzdGFydCArIGhvd01hbnk7XG4gIGxlbiA9IG1hcC5sZW5ndGg7XG4gIC8vIERlbGV0ZSBpbmRpY2llcyBmb3IgaXRlbXMgaW4gaW5zZXJ0ZWQgcG9zaXRpb25zXG4gIG9sZEFycmF5cyA9IHRoaXMuX2RlbEl0ZW1zKHBhdGgsIG1hcCwgc3RhcnQsIGVuZCArIDEsIGxlbik7XG4gIC8vIEluY3JlbWVudCBpbmRpY2llcyBvZiBsYXRlciBpdGVtc1xuICB0aGlzLl9pbmNySXRlbXMocGF0aCwgbWFwLCBzdGFydCwgbGVuLCBob3dNYW55LCBvbGRBcnJheXMpO1xuICB3aGlsZSAoaG93TWFueS0tKSB7XG4gICAgbWFwLnNwbGljZShzdGFydCwgMCwge30pO1xuICB9XG59O1xuXG5QYXRoTWFwLnByb3RvdHlwZS5vbk1vdmUgPSBmdW5jdGlvbihwYXRoLCBmcm9tLCB0bywgaG93TWFueSkge1xuICB2YXIgbWFwID0gdGhpcy5hcnJheXNbcGF0aF1cbiAgICAsIGFmdGVyRnJvbSwgYWZ0ZXJUbywgaXRlbXMsIG9sZEFycmF5cztcbiAgaWYgKCFtYXApIHJldHVybjtcbiAgYWZ0ZXJGcm9tID0gZnJvbSArIGhvd01hbnk7XG4gIGFmdGVyVG8gPSB0byArIGhvd01hbnk7XG4gIC8vIEFkanVzdCBwYXRocyBmb3IgaXRlbXMgYmV0d2VlbiBmcm9tIGFuZCB0b1xuICBpZiAoZnJvbSA+IHRvKSB7XG4gICAgb2xkQXJyYXlzID0gdGhpcy5fZGVsSXRlbXMocGF0aCwgbWFwLCB0bywgYWZ0ZXJGcm9tLCBhZnRlckZyb20pO1xuICAgIHRoaXMuX2luY3JJdGVtcyhwYXRoLCBtYXAsIHRvLCBmcm9tLCBob3dNYW55LCBvbGRBcnJheXMpO1xuICB9IGVsc2Uge1xuICAgIG9sZEFycmF5cyA9IHRoaXMuX2RlbEl0ZW1zKHBhdGgsIG1hcCwgZnJvbSwgYWZ0ZXJUbywgYWZ0ZXJUbyk7XG4gICAgdGhpcy5faW5jckl0ZW1zKHBhdGgsIG1hcCwgYWZ0ZXJGcm9tLCBhZnRlclRvLCAtaG93TWFueSwgb2xkQXJyYXlzKTtcbiAgfVxuICAvLyBBZGp1c3QgcGF0aHMgZm9yIHRoZSBtb3ZlZCBpdGVtKHMpXG4gIHRoaXMuX2luY3JJdGVtcyhwYXRoLCBtYXAsIGZyb20sIGFmdGVyRnJvbSwgdG8gLSBmcm9tLCBvbGRBcnJheXMpO1xuICAvLyBGaXggdGhlIGFycmF5IGluZGV4XG4gIGl0ZW1zID0gbWFwLnNwbGljZShmcm9tLCBob3dNYW55KTtcbiAgbWFwLnNwbGljZS5hcHBseShtYXAsIFt0bywgMF0uY29uY2F0KGl0ZW1zKSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIG9uU3RyaW5nSW5zZXJ0OiBvblN0cmluZ0luc2VydFxuLCBvblN0cmluZ1JlbW92ZTogb25TdHJpbmdSZW1vdmVcbiwgb25UZXh0SW5wdXQ6IG9uVGV4dElucHV0XG59O1xuXG5mdW5jdGlvbiBvblN0cmluZ0luc2VydChlbCwgcHJldmlvdXMsIGluZGV4LCB0ZXh0KSB7XG4gIGZ1bmN0aW9uIHRyYW5zZm9ybUN1cnNvcihjdXJzb3IpIHtcbiAgICByZXR1cm4gKGluZGV4IDwgY3Vyc29yKSA/IGN1cnNvciArIHRleHQubGVuZ3RoIDogY3Vyc29yO1xuICB9XG4gIHZhciBuZXdUZXh0ID0gcHJldmlvdXMuc2xpY2UoMCwgaW5kZXgpICsgdGV4dCArIHByZXZpb3VzLnNsaWNlKGluZGV4KTtcbiAgcmVwbGFjZVRleHQoZWwsIG5ld1RleHQsIHRyYW5zZm9ybUN1cnNvcik7XG59XG5cbmZ1bmN0aW9uIG9uU3RyaW5nUmVtb3ZlKGVsLCBwcmV2aW91cywgaW5kZXgsIGhvd01hbnkpIHtcbiAgZnVuY3Rpb24gdHJhbnNmb3JtQ3Vyc29yKGN1cnNvcikge1xuICAgIHJldHVybiAoaW5kZXggPCBjdXJzb3IpID8gY3Vyc29yIC0gTWF0aC5taW4oaG93TWFueSwgY3Vyc29yIC0gaW5kZXgpIDogY3Vyc29yO1xuICB9XG4gIHZhciBuZXdUZXh0ID0gcHJldmlvdXMuc2xpY2UoMCwgaW5kZXgpICsgcHJldmlvdXMuc2xpY2UoaW5kZXggKyBob3dNYW55KTtcbiAgcmVwbGFjZVRleHQoZWwsIG5ld1RleHQsIHRyYW5zZm9ybUN1cnNvcik7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VUZXh0KGVsLCBuZXdUZXh0LCB0cmFuc2Zvcm1DdXJzb3IpIHtcbiAgdmFyIHNlbGVjdGlvblN0YXJ0ID0gdHJhbnNmb3JtQ3Vyc29yKGVsLnNlbGVjdGlvblN0YXJ0KTtcbiAgdmFyIHNlbGVjdGlvbkVuZCA9IHRyYW5zZm9ybUN1cnNvcihlbC5zZWxlY3Rpb25FbmQpO1xuXG4gIHZhciBzY3JvbGxUb3AgPSBlbC5zY3JvbGxUb3A7XG4gIGVsLnZhbHVlID0gbmV3VGV4dDtcbiAgaWYgKGVsLnNjcm9sbFRvcCAhPT0gc2Nyb2xsVG9wKSB7XG4gICAgZWwuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICB9XG4gIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBlbCkge1xuICAgIGVsLnNlbGVjdGlvblN0YXJ0ID0gc2VsZWN0aW9uU3RhcnQ7XG4gICAgZWwuc2VsZWN0aW9uRW5kID0gc2VsZWN0aW9uRW5kO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uVGV4dElucHV0KG1vZGVsLCBwYXRoLCB2YWx1ZSkge1xuICB2YXIgcHJldmlvdXMgPSBtb2RlbC5nZXQocGF0aCkgfHwgJyc7XG4gIGlmIChwcmV2aW91cyA9PT0gdmFsdWUpIHJldHVybjtcbiAgdmFyIHN0YXJ0ID0gMDtcbiAgd2hpbGUgKHByZXZpb3VzLmNoYXJBdChzdGFydCkgPT0gdmFsdWUuY2hhckF0KHN0YXJ0KSkge1xuICAgIHN0YXJ0Kys7XG4gIH1cbiAgdmFyIGVuZCA9IDA7XG4gIHdoaWxlIChcbiAgICBwcmV2aW91cy5jaGFyQXQocHJldmlvdXMubGVuZ3RoIC0gMSAtIGVuZCkgPT09IHZhbHVlLmNoYXJBdCh2YWx1ZS5sZW5ndGggLSAxIC0gZW5kKSAmJlxuICAgIGVuZCArIHN0YXJ0IDwgcHJldmlvdXMubGVuZ3RoICYmXG4gICAgZW5kICsgc3RhcnQgPCB2YWx1ZS5sZW5ndGhcbiAgKSB7XG4gICAgZW5kKys7XG4gIH1cblxuICBpZiAocHJldmlvdXMubGVuZ3RoICE9PSBzdGFydCArIGVuZCkge1xuICAgIHZhciBob3dNYW55ID0gcHJldmlvdXMubGVuZ3RoIC0gc3RhcnQgLSBlbmQ7XG4gICAgbW9kZWwuc3RyaW5nUmVtb3ZlKHBhdGgsIHN0YXJ0LCBob3dNYW55KTtcbiAgfVxuICBpZiAodmFsdWUubGVuZ3RoICE9PSBzdGFydCArIGVuZCkge1xuICAgIHZhciBpbnNlcnRlZCA9IHZhbHVlLnNsaWNlKHN0YXJ0LCB2YWx1ZS5sZW5ndGggLSBlbmQpO1xuICAgIG1vZGVsLnN0cmluZ0luc2VydChwYXRoLCBzdGFydCwgaW5zZXJ0ZWQpO1xuICB9XG59XG4iLCIoZnVuY3Rpb24oX19maWxlbmFtZSl7dmFyIGNvbmZpZyA9IHtcbiAgZmlsZW5hbWU6IF9fZmlsZW5hbWUsXG4gIG5zOiAnZ2hidG5zJyxcbiAgc2NyaXB0czoge1xuICAgIGJ1dHRvbjogcmVxdWlyZSgnLi9idXR0b24nKVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCwgb3B0aW9ucykge1xuICBhcHAuY3JlYXRlTGlicmFyeShjb25maWcsIG9wdGlvbnMpO1xufVxufSkoXCIvbm9kZV9tb2R1bGVzL2RlcmJ5LXVpLWdpdGh1Yi1idXR0b25zL2luZGV4LmpzXCIpIiwiKGZ1bmN0aW9uKHByb2Nlc3Mpe2Z1bmN0aW9uIGZpbHRlciAoeHMsIGZuKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGZuKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gUmVnZXggdG8gc3BsaXQgYSBmaWxlbmFtZSBpbnRvIFsqLCBkaXIsIGJhc2VuYW1lLCBleHRdXG4vLyBwb3NpeCB2ZXJzaW9uXG52YXIgc3BsaXRQYXRoUmUgPSAvXiguK1xcLyg/ISQpfFxcLyk/KCg/Oi4rPyk/KFxcLlteLl0qKT8pJC87XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xudmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICB2YXIgcGF0aCA9IChpID49IDApXG4gICAgICA/IGFyZ3VtZW50c1tpXVxuICAgICAgOiBwcm9jZXNzLmN3ZCgpO1xuXG4gIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnIHx8ICFwYXRoKSB7XG4gICAgY29udGludWU7XG4gIH1cblxuICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn1cblxuLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbi8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxucmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xudmFyIGlzQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nLFxuICAgIHRyYWlsaW5nU2xhc2ggPSBwYXRoLnNsaWNlKC0xKSA9PT0gJy8nO1xuXG4vLyBOb3JtYWxpemUgdGhlIHBhdGhcbnBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cbiAgXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIHJldHVybiBwICYmIHR5cGVvZiBwID09PSAnc3RyaW5nJztcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgZGlyID0gc3BsaXRQYXRoUmUuZXhlYyhwYXRoKVsxXSB8fCAnJztcbiAgdmFyIGlzV2luZG93cyA9IGZhbHNlO1xuICBpZiAoIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWVcbiAgICByZXR1cm4gJy4nO1xuICB9IGVsc2UgaWYgKGRpci5sZW5ndGggPT09IDEgfHxcbiAgICAgIChpc1dpbmRvd3MgJiYgZGlyLmxlbmd0aCA8PSAzICYmIGRpci5jaGFyQXQoMSkgPT09ICc6JykpIHtcbiAgICAvLyBJdCBpcyBqdXN0IGEgc2xhc2ggb3IgYSBkcml2ZSBsZXR0ZXIgd2l0aCBhIHNsYXNoXG4gICAgcmV0dXJuIGRpcjtcbiAgfSBlbHNlIHtcbiAgICAvLyBJdCBpcyBhIGZ1bGwgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICByZXR1cm4gZGlyLnN1YnN0cmluZygwLCBkaXIubGVuZ3RoIC0gMSk7XG4gIH1cbn07XG5cblxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IHNwbGl0UGF0aFJlLmV4ZWMocGF0aClbMl0gfHwgJyc7XG4gIC8vIFRPRE86IG1ha2UgdGhpcyBjb21wYXJpc29uIGNhc2UtaW5zZW5zaXRpdmUgb24gd2luZG93cz9cbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhwYXRoKVszXSB8fCAnJztcbn07XG5cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfcHJvY2Vzc1wiKSkiLCIoZnVuY3Rpb24ocHJvY2Vzcyl7dmFyIGRlZXBJcyA9IHJlcXVpcmUoJ2RlZXAtaXMnKTtcblxudmFyIGlzU2VydmVyID0gcHJvY2Vzcy50aXRsZSAhPT0gJ2Jyb3dzZXInO1xudmFyIGlzUHJvZHVjdGlvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbic7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1NlcnZlcjogaXNTZXJ2ZXJcbiwgaXNQcm9kdWN0aW9uOiBpc1Byb2R1Y3Rpb25cblxuLCBhc3luY0dyb3VwOiBhc3luY0dyb3VwXG4sIGNvbnRhaW5zOiBjb250YWluc1xuLCBjb3B5T2JqZWN0OiBjb3B5T2JqZWN0XG4sIGRlZXBDb3B5OiBkZWVwQ29weVxuLCBkZWVwRXF1YWw6IGRlZXBJc1xuLCBlcXVhbDogZXF1YWxcbiwgZXF1YWxzTmFOOiBlcXVhbHNOYU5cbiwgbG9va3VwOiBsb29rdXBcbiwgbWVyZ2VJbnRvOiBtZXJnZUludG9cbiwgbWF5SW1wYWN0OiBtYXlJbXBhY3RcbiwgbWF5SW1wYWN0QW55OiBtYXlJbXBhY3RBbnlcbiwgc2VydmVyUmVxdWlyZTogc2VydmVyUmVxdWlyZVxuLCB1c2U6IHVzZVxufTtcblxuZnVuY3Rpb24gYXN5bmNHcm91cChjYikge1xuICB2YXIgZ3JvdXAgPSBuZXcgQXN5bmNHcm91cChjYik7XG4gIHJldHVybiBmdW5jdGlvbiBhc3luY0dyb3VwQWRkKCkge1xuICAgIHJldHVybiBncm91cC5hZGQoKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiKGVycilcbiAqL1xuZnVuY3Rpb24gQXN5bmNHcm91cChjYikge1xuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaXNEb25lID0gZmFsc2U7XG4gIHRoaXMuY291bnQgPSAwO1xufVxuQXN5bmNHcm91cC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY291bnQrKztcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gZnVuY3Rpb24oZXJyKSB7XG4gICAgc2VsZi5jb3VudC0tO1xuICAgIGlmIChzZWxmLmlzRG9uZSkgcmV0dXJuO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHNlbGYuaXNEb25lID0gdHJ1ZTtcbiAgICAgIHNlbGYuY2IoZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNlbGYuY291bnQgPiAwKSByZXR1cm47XG4gICAgc2VsZi5pc0RvbmUgPSB0cnVlO1xuICAgIHNlbGYuY2IoKTtcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKHNlZ21lbnRzLCB0ZXN0U2VnbWVudHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzZWdtZW50c1tpXSAhPT0gdGVzdFNlZ21lbnRzW2ldKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvcHlPYmplY3Qob2JqZWN0KSB7XG4gIHZhciBvdXQgPSBuZXcgb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBvdXRba2V5XSA9IG9iamVjdFtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBkZWVwQ29weSh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSByZXR1cm4gbmV3IERhdGUodmFsdWUpO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgdmFyIGNvcHk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBjb3B5ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gdmFsdWUubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIGNvcHlbaV0gPSBkZWVwQ29weSh2YWx1ZVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgY29weSA9IG5ldyB2YWx1ZS5jb25zdHJ1Y3RvcjtcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGNvcHlba2V5XSA9IGRlZXBDb3B5KHZhbHVlW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29weTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIChhID09PSBiKSB8fCAoZXF1YWxzTmFOKGEpICYmIGVxdWFsc05hTihiKSk7XG59XG5cbmZ1bmN0aW9uIGVxdWFsc05hTih4KSB7XG4gIHJldHVybiB4ICE9PSB4O1xufVxuXG5mdW5jdGlvbiBsb29rdXAoc2VnbWVudHMsIHZhbHVlKSB7XG4gIGlmICghc2VnbWVudHMpIHJldHVybiB2YWx1ZTtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHZhbHVlO1xuICAgIHZhbHVlID0gdmFsdWVbc2VnbWVudHNbaV1dO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gbWF5SW1wYWN0QW55KHNlZ21lbnRzTGlzdCwgdGVzdFNlZ21lbnRzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWdtZW50c0xpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAobWF5SW1wYWN0KHNlZ21lbnRzTGlzdFtpXSwgdGVzdFNlZ21lbnRzKSkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBtYXlJbXBhY3Qoc2VnbWVudHMsIHRlc3RTZWdtZW50cykge1xuICB2YXIgbGVuID0gTWF0aC5taW4oc2VnbWVudHMubGVuZ3RoLCB0ZXN0U2VnbWVudHMubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChzZWdtZW50c1tpXSAhPT0gdGVzdFNlZ21lbnRzW2ldKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG1lcmdlSW50byh0bywgZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgIHRvW2tleV0gPSBmcm9tW2tleV07XG4gIH1cbiAgcmV0dXJuIHRvO1xufVxuXG5mdW5jdGlvbiBzZXJ2ZXJSZXF1aXJlKG5hbWUpIHtcbiAgaWYgKCFpc1NlcnZlcikgcmV0dXJuO1xuICAvLyBUcmlja3MgQnJvd3NlcmlmeSBpbnRvIG5vdCBsb2dnaW5nIGEgd2FybmluZ1xuICB2YXIgX3JlcXVpcmUgPSByZXF1aXJlO1xuICByZXR1cm4gX3JlcXVpcmUobmFtZSk7XG59XG5cbmZ1bmN0aW9uIHVzZShwbHVnaW4sIG9wdGlvbnMpIHtcbiAgLy8gU2VydmVyLXNpZGUgcGx1Z2lucyBtYXkgYmUgaW5jbHVkZWQgdmlhIGZpbGVuYW1lXG4gIGlmICh0eXBlb2YgcGx1Z2luID09PSAnc3RyaW5nJykge1xuICAgIGlmICghaXNTZXJ2ZXIpIHJldHVybiB0aGlzO1xuICAgIHBsdWdpbiA9IHNlcnZlclJlcXVpcmUocGx1Z2luKTtcbiAgfVxuXG4gIC8vIERvbid0IGluY2x1ZGUgYSBwbHVnaW4gbW9yZSB0aGFuIG9uY2VcbiAgdmFyIHBsdWdpbnMgPSB0aGlzLl9wbHVnaW5zIHx8ICh0aGlzLl9wbHVnaW5zID0gW10pO1xuICBpZiAocGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPT09IC0xKSB7XG4gICAgcGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgcGx1Z2luKHRoaXMsIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG59KShyZXF1aXJlKFwiX19icm93c2VyaWZ5X3Byb2Nlc3NcIikpIiwidmFyIFJvdXRlID0gcmVxdWlyZSgnLi4vdmVuZG9yL2V4cHJlc3Mvcm91dGVyL3JvdXRlJylcbnZhciBIaXN0b3J5ID0gcmVxdWlyZSgnLi9IaXN0b3J5JylcbnZhciByb3V0ZXIgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcm91dGVyJylcbnZhciBjb21wb3NlID0gcmVxdWlyZSgnLi9jb21wb3NlJylcblxucm91dGVyLnNldHVwID0gc2V0dXBcblxuZnVuY3Rpb24gc2V0dXAoYXBwLCBjcmVhdGVQYWdlLCBvblJvdXRlKSB7XG4gIHZhciByb3V0ZXMgPSB7XG4gICAgcXVldWU6IHt9XG4gICwgdHJhbnNpdGlvbmFsOiB7fVxuICAsIG9uUm91dGU6IG9uUm91dGVcbiAgfVxuICBhcHAuaGlzdG9yeSA9IG5ldyBIaXN0b3J5KGNyZWF0ZVBhZ2UsIHJvdXRlcylcblxuICA7WydnZXQnLCAncG9zdCcsICdwdXQnLCAnZGVsJywgJ2VudGVyJywgJ2V4aXQnXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIHZhciBxdWV1ZSA9IHJvdXRlcy5xdWV1ZVttZXRob2RdID0gW11cbiAgICB2YXIgdHJhbnNpdGlvbmFsID0gcm91dGVzLnRyYW5zaXRpb25hbFttZXRob2RdID0gW11cbiAgICB2YXIgdHJhbnNpdGlvbmFsQ2FsbHMgPSBbXVxuXG4gICAgYXBwW21ldGhvZF0gPSBmdW5jdGlvbihwYXR0ZXJuLCBjYWxsYmFjaykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICAgICAgcGF0dGVybi5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICBhcHBbbWV0aG9kXShpdGVtLCBjYWxsYmFjaylcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIGFwcFxuICAgICAgfVxuXG4gICAgICBpZiAocm91dGVyLmlzVHJhbnNpdGlvbmFsKHBhdHRlcm4pKSB7XG4gICAgICAgIHZhciBmcm9tID0gcGF0dGVybi5mcm9tXG4gICAgICAgIHZhciB0byA9IHBhdHRlcm4udG9cbiAgICAgICAgdmFyIGZvcndhcmQgPSBwYXR0ZXJuLmZvcndhcmQgfHwgKGNhbGxiYWNrICYmIGNhbGxiYWNrLmZvcndhcmQpIHx8IGNhbGxiYWNrXG4gICAgICAgIHZhciBiYWNrID0gcGF0dGVybi5iYWNrIHx8IChjYWxsYmFjayAmJiBjYWxsYmFjay5iYWNrKVxuICAgICAgICB0cmFuc2l0aW9uYWxDYWxscy5wdXNoKHtcbiAgICAgICAgICBmcm9tOiBmcm9tXG4gICAgICAgICwgdG86IHRvXG4gICAgICAgICwgZm9yd2FyZDogZm9yd2FyZFxuICAgICAgICAsIGJhY2s6IGJhY2tcbiAgICAgICAgfSlcblxuICAgICAgICB2YXIgZnJvbVJvdXRlID0gbmV3IFJvdXRlKG1ldGhvZCwgZnJvbSwgYmFjaylcbiAgICAgICAgdmFyIHRvUm91dGUgPSBuZXcgUm91dGUobWV0aG9kLCB0bywgZm9yd2FyZClcbiAgICAgICAgZnJvbVJvdXRlLmlzVHJhbnNpdGlvbmFsID0gdHJ1ZVxuICAgICAgICB0b1JvdXRlLmlzVHJhbnNpdGlvbmFsID0gdHJ1ZVxuICAgICAgICB0cmFuc2l0aW9uYWwucHVzaCh7XG4gICAgICAgICAgZnJvbTogZnJvbVJvdXRlXG4gICAgICAgICwgdG86IHRvUm91dGVcbiAgICAgICAgfSlcbiAgICAgICAgaWYgKGJhY2spIHRyYW5zaXRpb25hbC5wdXNoKHtcbiAgICAgICAgICBmcm9tOiB0b1JvdXRlXG4gICAgICAgICwgdG86IGZyb21Sb3V0ZVxuICAgICAgICB9KVxuXG4gICAgICAgIGNvbXBvc2UudHJhbnNpdGlvbihhcHBbbWV0aG9kXSwgdHJhbnNpdGlvbmFsQ2FsbHMsIGZyb20sIHRvLCBmb3J3YXJkLCBiYWNrKVxuICAgICAgICByZXR1cm4gYXBwXG4gICAgICB9XG5cbiAgICAgIHF1ZXVlLnB1c2gobmV3IFJvdXRlKG1ldGhvZCwgcGF0dGVybiwgY2FsbGJhY2spKVxuICAgICAgcmV0dXJuIGFwcFxuICAgIH1cbiAgfSlcbn1cbiIsInZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG4gICwgdXRpbCA9IHJlcXVpcmUoJ3JhY2VyJykudXRpbFxuICAsIFZpZXcgPSByZXF1aXJlKCcuL1ZpZXcnKVxuICAsIGFycmF5U2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2VcblxubW9kdWxlLmV4cG9ydHMgPSBjb21wb25lbnRQbHVnaW47XG5cbmZ1bmN0aW9uIGNvbXBvbmVudFBsdWdpbihhcHApIHtcbiAgYXBwLl9saWJyYXJpZXMgPSBbXTtcbiAgYXBwLl9saWJyYXJpZXMubWFwID0ge307XG4gIGFwcC5jcmVhdGVMaWJyYXJ5ID0gY3JlYXRlTGlicmFyeTtcbn1cblxuZnVuY3Rpb24gQ29tcG9uZW50UHJvdG8oKSB7fVxudXRpbC5tZXJnZUludG8oQ29tcG9uZW50UHJvdG8ucHJvdG90eXBlLCBFdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblxuQ29tcG9uZW50UHJvdG8ucHJvdG90eXBlLmVtaXRDYW5jZWxsYWJsZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY2FuY2VsbGVkID0gZmFsc2VcbiAgICAsIGFyZ3MgPSBhcnJheVNsaWNlLmNhbGwoYXJndW1lbnRzKVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICB9XG5cbiAgYXJncy5wdXNoKGNhbmNlbCk7XG4gIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgcmV0dXJuIGNhbmNlbGxlZDtcbn07XG5cbkNvbXBvbmVudFByb3RvLnByb3RvdHlwZS5lbWl0RGVsYXlhYmxlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkZWxheWVkID0gZmFsc2VcbiAgICAsIGFyZ3MgPSBhcnJheVNsaWNlLmNhbGwoYXJndW1lbnRzLCAwLCAtMSlcbiAgICAsIGNhbGxiYWNrID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXVxuXG4gIGZ1bmN0aW9uIGRlbGF5KCkge1xuICAgIGRlbGF5ZWQgPSB0cnVlO1xuICB9XG5cbiAgYXJncy5wdXNoKGRlbGF5LCBjYWxsYmFjayk7XG4gIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgaWYgKCFkZWxheWVkKSBjYWxsYmFjaygpO1xuICByZXR1cm4gZGVsYXllZDtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpYnJhcnkoY29uZmlnLCBvcHRpb25zKSB7XG4gIGlmICghY29uZmlnIHx8ICFjb25maWcuZmlsZW5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IgKCdDb25maWd1cmF0aW9uIGFyZ3VtZW50IHdpdGggYSBmaWxlbmFtZSBpcyByZXF1aXJlZCcpO1xuICB9XG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICB2YXIgcm9vdCA9IHBhdGguZGlybmFtZShjb25maWcuZmlsZW5hbWUpO1xuICB2YXIgbnMgPSBvcHRpb25zLm5zIHx8IGNvbmZpZy5ucyB8fCBwYXRoLmJhc2VuYW1lKHJvb3QpO1xuICB2YXIgc2NyaXB0cyA9IGNvbmZpZy5zY3JpcHRzIHx8IHt9O1xuICB2YXIgdmlldyA9IG5ldyBWaWV3O1xuICB2YXIgY29uc3RydWN0b3JzID0ge307XG4gIHZhciBsaWJyYXJ5ID0ge1xuICAgIG5zOiBuc1xuICAsIHJvb3Q6IHJvb3RcbiAgLCB2aWV3OiB2aWV3XG4gICwgY29uc3RydWN0b3JzOiBjb25zdHJ1Y3RvcnNcbiAgLCBzdHlsZXM6IGNvbmZpZy5zdHlsZXNcbiAgfTtcblxuICB2aWV3LnBhcmVudCA9IHRoaXM7XG4gIHZpZXcuX3NlbGZOcyA9ICdsaWInO1xuICB2aWV3Ll9zZWxmTGlicmFyeSA9IGxpYnJhcnk7XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBzY3JpcHRzKSB7XG4gICAgdmFyIHNjcmlwdCA9IHNjcmlwdHNbbmFtZV07XG4gICAgc2NyaXB0LnNldHVwICYmIHNjcmlwdC5zZXR1cChsaWJyYXJ5KTtcblxuICAgIHZhciBDb21wb25lbnQgPSBmdW5jdGlvbihtb2RlbCwgc2NvcGUpIHtcbiAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgICB0aGlzLmhpc3RvcnkgPSBudWxsO1xuICAgICAgdGhpcy5kb20gPSBudWxsO1xuXG4gICAgICAvLyBEb24ndCBsaW1pdCB0aGUgbnVtYmVyIG9mIGxpc3RlbmVyc1xuICAgICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMoMCk7XG5cbiAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzO1xuICAgICAgbW9kZWwuX19vbiA9IG1vZGVsLl9vbjtcbiAgICAgIG1vZGVsLl9vbiA9IGZ1bmN0aW9uKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbXBvbmVudC5vbignZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIG1vZGVsLnJlbW92ZUxpc3RlbmVyKG5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIG1vZGVsLl9fb24obmFtZSwgbGlzdGVuZXIpO1xuICAgICAgfTtcbiAgICAgIGNvbXBvbmVudC5vbignZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBtb2RlbC5zaWxlbnQoKS5kZWwoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgcHJvdG8gPSBDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudFByb3RvKCk7XG4gICAgdXRpbC5tZXJnZUludG8ocHJvdG8sIHNjcmlwdCk7XG5cbiAgICBDb21wb25lbnQudmlldyA9IHZpZXc7XG4gICAgQ29tcG9uZW50Lm5zID0gQ29tcG9uZW50LnByb3RvdHlwZS5ucyA9IG5zO1xuICAgIENvbXBvbmVudC5uYW1lID0gQ29tcG9uZW50LnByb3RvdHlwZS5uYW1lID0gbmFtZTtcblxuICAgIC8vIE5vdGUgdGhhdCBjb21wb25lbnQgbmFtZXMgYXJlIGFsbCBsb3dlcmNhc2VkXG4gICAgY29uc3RydWN0b3JzW25hbWUudG9Mb3dlckNhc2UoKV0gPSBDb21wb25lbnQ7XG4gIH1cblxuICB2YXIgcmVwbGFjZWQgPSBmYWxzZTtcbiAgZm9yICh2YXIgaSA9IHRoaXMuX2xpYnJhcmllcy5sZW5ndGg7IGktLTspIHtcbiAgICBpZiAodGhpcy5fbGlicmFyaWVzW2ldLm5zID09PSBucykge1xuICAgICAgdGhpcy5fbGlicmFyaWVzW2ldID0gbGlicmFyeTtcbiAgICAgIHJlcGxhY2VkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKCFyZXBsYWNlZCkge1xuICAgIHRoaXMuX2xpYnJhcmllcy5wdXNoKGxpYnJhcnkpO1xuICB9XG4gIHRoaXMuX2xpYnJhcmllcy5tYXBbbnNdID0gbGlicmFyeTtcbiAgcmV0dXJuIGxpYnJhcnk7XG59XG4iLCJ2YXIgcmFjZXIgPSByZXF1aXJlKCdyYWNlcicpXG4gICwgZG9tU2hpbSA9IHJlcXVpcmUoJ2RvbS1zaGltJylcbiAgLCBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKCcuL0V2ZW50RGlzcGF0Y2hlcicpXG4gICwgdmlld1BhdGggPSByZXF1aXJlKCcuL3ZpZXdQYXRoJylcbiAgLCBlc2NhcGVIdG1sID0gcmVxdWlyZSgnaHRtbC11dGlsJykuZXNjYXBlSHRtbFxuICAsIHRleHRPdCA9IHJlcXVpcmUoJy4vdGV4dE90JylcbiAgLCBtZXJnZSA9IHJhY2VyLnV0aWwubWVyZ2VcbiAgLCBtYXJrZXJzID0ge31cbiAgLCBtYXJrZXJzRGlydHkgPSB0cnVlXG4gICwgZ2xvYmFsRWxlbWVudHMgPSB7XG4gICAgICAkX3dpbjogd2luZG93XG4gICAgLCAkX2RvYzogZG9jdW1lbnRcbiAgICB9XG4gICwgYWRkTGlzdGVuZXIsIHJlbW92ZUxpc3RlbmVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERvbTtcblxuZnVuY3Rpb24gRG9tKG1vZGVsKSB7XG4gIHZhciBkb20gPSB0aGlzXG4gIHZhciBmbnMgPSB0aGlzLmZuc1xuXG4gIC8vIE1hcCBkb20gZXZlbnQgbmFtZSAtPiB0cnVlXG4gIHZhciBsaXN0ZW5lckFkZGVkID0ge307XG4gIHZhciBjYXB0dXJlTGlzdGVuZXJBZGRlZCA9IHt9XG5cbiAgLy8gRE9NIGxpc3RlbmVyIGNhcHR1cmluZyBhbGxvd3MgYmx1ciBhbmQgZm9jdXMgdG8gYmUgZGVsZWdhdGVkXG4gIC8vIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDA4LzA0L2RlbGVnYXRpbmdfdGhlLmh0bWxcbiAgdmFyIGNhcHR1cmVFdmVudHMgPSB0aGlzLl9jYXB0dXJlRXZlbnRzID0gbmV3IEV2ZW50RGlzcGF0Y2hlcih7XG4gICAgb25UcmlnZ2VyOiBvbkNhcHR1cmVUcmlnZ2VyXG4gICwgb25CaW5kOiBvbkNhcHR1cmVCaW5kXG4gIH0pO1xuICBmdW5jdGlvbiBvbkNhcHR1cmVUcmlnZ2VyKG5hbWUsIGxpc3RlbmVyLCBlKSB7XG4gICAgdmFyIGlkID0gbGlzdGVuZXIuaWRcbiAgICAgICwgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG5cbiAgICAvLyBSZW1vdmUgbGlzdGVuZXIgaWYgZWxlbWVudCBpc24ndCBmb3VuZFxuICAgIGlmICghZWwpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChlbC50YWdOYW1lID09PSAnSFRNTCcgfHwgZWwuY29udGFpbnMoZS50YXJnZXQpKSB7XG4gICAgICBvbkRvbVRyaWdnZXIobmFtZSwgbGlzdGVuZXIsIGlkLCBlLCBlbCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG9uQ2FwdHVyZUJpbmQobmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoY2FwdHVyZUxpc3RlbmVyQWRkZWRbbmFtZV0pIHJldHVybjtcbiAgICBhZGRMaXN0ZW5lcihkb2N1bWVudCwgbmFtZSwgY2FwdHVyZVRyaWdnZXIsIHRydWUpO1xuICAgIGNhcHR1cmVMaXN0ZW5lckFkZGVkW25hbWVdID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnREaXNwYXRjaGVyKHtcbiAgICBvblRyaWdnZXI6IG9uRG9tVHJpZ2dlclxuICAsIG9uQmluZDogb25Eb21CaW5kXG4gIH0pO1xuICBmdW5jdGlvbiBvbkRvbVRyaWdnZXIobmFtZSwgbGlzdGVuZXIsIGlkLCBlLCBlbCwgbmV4dCkge1xuICAgIHZhciBkZWxheSA9IGxpc3RlbmVyLmRlbGF5XG4gICAgICAsIGZpbmlzaCA9IGxpc3RlbmVyLmZuO1xuXG4gICAgZS5wYXRoID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgaWYgKCFuYW1lKSByZXR1cm4gbW9kZWwuX19wYXRoTWFwLnBhdGhzW2xpc3RlbmVyLnBhdGhJZF07XG4gICAgICByZXR1cm4gdmlld1BhdGguY3R4UGF0aChsaXN0ZW5lci52aWV3LCBsaXN0ZW5lci5jdHgsIG5hbWUpO1xuICAgIH07XG4gICAgZS5nZXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgcGF0aCA9IGUucGF0aChuYW1lKTtcbiAgICAgIHJldHVybiB2aWV3UGF0aC5kYXRhVmFsdWUobGlzdGVuZXIudmlldywgbGlzdGVuZXIuY3R4LCBtb2RlbCwgcGF0aCk7XG4gICAgfTtcbiAgICBlLmF0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgcmV0dXJuIG1vZGVsLmF0KGUucGF0aChuYW1lKSk7XG4gICAgfTtcblxuICAgIGlmICghZmluaXNoKSB7XG4gICAgICAvLyBVcGRhdGUgdGhlIG1vZGVsIHdoZW4gdGhlIGVsZW1lbnQncyB2YWx1ZSBjaGFuZ2VzXG4gICAgICBmaW5pc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZG9tLmdldE1ldGhvZHNbbGlzdGVuZXIubWV0aG9kXShlbCwgbGlzdGVuZXIucHJvcGVydHkpXG4gICAgICAgICAgLCBzZXRWYWx1ZSA9IGxpc3RlbmVyLnNldFZhbHVlO1xuXG4gICAgICAgIC8vIEFsbG93IHRoZSBsaXN0ZW5lciB0byBvdmVycmlkZSB0aGUgc2V0dGluZyBmdW5jdGlvblxuICAgICAgICBpZiAoc2V0VmFsdWUpIHtcbiAgICAgICAgICBzZXRWYWx1ZShtb2RlbCwgdmFsdWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSB0aGlzIGxpc3RlbmVyIGlmIGl0cyBwYXRoIGlkIGlzIG5vIGxvbmdlciByZWdpc3RlcmVkXG4gICAgICAgIHZhciBwYXRoID0gbW9kZWwuX19wYXRoTWFwLnBhdGhzW2xpc3RlbmVyLnBhdGhJZF07XG4gICAgICAgIGlmICghcGF0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIC8vIFNldCB0aGUgdmFsdWUgaWYgY2hhbmdlZFxuICAgICAgICBpZiAobW9kZWwuZ2V0KHBhdGgpID09PSB2YWx1ZSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBzZXR0ZXJNb2RlbCA9IG1vZGVsLnBhc3MoeyRlOiBlLCAkZWw6IGVsfSk7XG4gICAgICAgIGlmIChsaXN0ZW5lci5tZXRob2QgPT09ICdwcm9wT3QnKSB7XG4gICAgICAgICAgcmV0dXJuIHRleHRPdC5vblRleHRJbnB1dChzZXR0ZXJNb2RlbCwgcGF0aCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHNldHRlck1vZGVsLnNldChwYXRoLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRlbGF5ICE9IG51bGwpIHtcbiAgICAgIHNldFRpbWVvdXQoZmluaXNoLCBkZWxheSwgZSwgZWwsIG5leHQsIGRvbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbmlzaChlLCBlbCwgbmV4dCwgZG9tKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25Eb21CaW5kKG5hbWUsIGxpc3RlbmVyLCBldmVudE5hbWUpIHtcbiAgICBpZiAobGlzdGVuZXJBZGRlZFtldmVudE5hbWVdKSByZXR1cm47XG4gICAgYWRkTGlzdGVuZXIoZG9jdW1lbnQsIGV2ZW50TmFtZSwgdHJpZ2dlckRvbSwgdHJ1ZSk7XG4gICAgbGlzdGVuZXJBZGRlZFtldmVudE5hbWVdID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyaWdnZXJEb20oZSwgZWwsIG5vQnViYmxlLCBjb250aW51ZWQpIHtcbiAgICBpZiAoIWVsKSBlbCA9IGUudGFyZ2V0O1xuICAgIHZhciBwcmVmaXggPSBlLnR5cGUgKyAnOidcbiAgICAgICwgaWQ7XG5cbiAgICAvLyBOZXh0IGNhbiBiZSBjYWxsZWQgZnJvbSBhIGxpc3RlbmVyIHRvIGNvbnRpbnVlIGJ1YmJsaW5nXG4gICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHRyaWdnZXJEb20oZSwgZWwucGFyZW50Tm9kZSwgZmFsc2UsIHRydWUpO1xuICAgIH1cbiAgICBuZXh0LmZpcnN0VHJpZ2dlciA9ICFjb250aW51ZWQ7XG4gICAgaWYgKG5vQnViYmxlICYmIChpZCA9IGVsLmlkKSkge1xuICAgICAgcmV0dXJuIGV2ZW50cy50cmlnZ2VyKHByZWZpeCArIGlkLCBpZCwgZSwgZWwsIG5leHQpO1xuICAgIH1cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgd2hpbGUgKCEoaWQgPSBlbC5pZCkpIHtcbiAgICAgICAgaWYgKCEoZWwgPSBlbC5wYXJlbnROb2RlKSkgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gU3RvcCBidWJibGluZyBvbmNlIHRoZSBldmVudCBpcyBoYW5kbGVkXG4gICAgICBpZiAoZXZlbnRzLnRyaWdnZXIocHJlZml4ICsgaWQsIGlkLCBlLCBlbCwgbmV4dCkpIHJldHVybjtcbiAgICAgIGlmICghKGVsID0gZWwucGFyZW50Tm9kZSkpIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjYXB0dXJlVHJpZ2dlcihlKSB7XG4gICAgY2FwdHVyZUV2ZW50cy50cmlnZ2VyKGUudHlwZSwgZSk7XG4gIH1cblxuICB0aGlzLnRyaWdnZXIgPSB0cmlnZ2VyRG9tO1xuICB0aGlzLmNhcHR1cmVUcmlnZ2VyID0gY2FwdHVyZVRyaWdnZXI7XG5cbiAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gIHRoaXMuX2NvbXBvbmVudHMgPSBbXTtcbiAgdGhpcy5fcGVuZGluZ1VwZGF0ZXMgPSBbXTtcblxuICBmdW5jdGlvbiBjb21wb25lbnRDbGVhbnVwKCkge1xuICAgIHZhciBjb21wb25lbnRzID0gZG9tLl9jb21wb25lbnRzXG4gICAgICAsIG1hcCA9IGdldE1hcmtlcnMoKVxuICAgICAgLCBpLCBjb21wb25lbnRcbiAgICBmb3IgKGkgPSBjb21wb25lbnRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcbiAgICAgIGlmIChjb21wb25lbnQgJiYgIWdldE1hcmtlcihtYXAsIGNvbXBvbmVudC5zY29wZSkpIHtcbiAgICAgICAgY29tcG9uZW50LmVtaXQoJ2Rlc3Ryb3knKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gVE9ETyBUaGlzICdjbGVhbnVwJyBldmVudCBpcyBuZXZlciBlbWl0dGVkOyBkZWFsIHdpdGggbGF0ZXJcbiAgLy8gVGhpcyBjbGVhbnVwIGxpc3RlbmVycyBpcyBwbGFjZWQgYXQgdGhlIGJlZ2lubmluZyBzbyB0aGF0IGNvbXBvbmVudFxuICAvLyBzY29wZXMgYXJlIGNsZWFyZWQgYmVmb3JlIGFueSByZWYgY2xlYW51cHMgYXJlIGNoZWNrZWRcbiAgbW9kZWwubGlzdGVuZXJzKCdjbGVhbnVwJykudW5zaGlmdChjb21wb25lbnRDbGVhbnVwKTtcbn1cblxuRG9tLnByb3RvdHlwZSA9IHtcbiAgY2xlYXI6IGRvbUNsZWFyXG4sIGJpbmQ6IGRvbUJpbmRcbiwgaXRlbTogZG9tSXRlbVxuLCBtYXJrZXI6IGRvbU1hcmtlclxuLCB1cGRhdGU6IGRvbVVwZGF0ZVxuLCBhZGRMaXN0ZW5lcjogZG9tQWRkTGlzdGVuZXJcbiwgcmVtb3ZlTGlzdGVuZXI6IGRvbVJlbW92ZUxpc3RlbmVyXG4sIGFkZENvbXBvbmVudDogYWRkQ29tcG9uZW50XG4sIF9zZXREaXJ0eTogc2V0RGlydHlcblxuLCBnZXRNZXRob2RzOiB7XG4gICAgYXR0cjogZ2V0QXR0clxuICAsIHByb3A6IGdldFByb3BcbiAgLCBwcm9wT3Q6IGdldFByb3BPdFxuICAsIHN0cmluZ0luc2VydDogZ2V0UHJvcE90XG4gICwgc3RyaW5nUmVtb3ZlOiBnZXRQcm9wT3RcbiAgLCBodG1sOiBnZXRIdG1sXG4gICAgLy8gVGhlc2UgbWV0aG9kcyByZXR1cm4gTmFOLCBiZWNhdXNlIGl0IG5ldmVyIGVxdWFscyBhbnl0aGluZyBlbHNlLiBUaHVzLFxuICAgIC8vIHdoZW4gY29tcGFyZWQgYWdhaW5zdCB0aGUgbmV3IHZhbHVlLCB0aGUgbmV3IHZhbHVlIHdpbGwgYWx3YXlzIGJlIHNldFxuICAsIGluc2VydDogZ2V0TmFOXG4gICwgcmVtb3ZlOiBnZXROYU5cbiAgLCBtb3ZlOiBnZXROYU5cbiAgfVxuXG4sIHNldE1ldGhvZHM6IHtcbiAgICBhdHRyOiBzZXRBdHRyXG4gICwgcHJvcDogc2V0UHJvcFxuICAsIHByb3BPdDogc2V0UHJvcE90XG4gICwgc3RyaW5nSW5zZXJ0OiBzZXRTdHJpbmdJbnNlcnRcbiAgLCBzdHJpbmdSZW1vdmU6IHNldFN0cmluZ1JlbW92ZVxuICAsIGh0bWw6IHNldEh0bWxcbiAgLCBpbnNlcnQ6IHNldEluc2VydFxuICAsIHJlbW92ZTogc2V0UmVtb3ZlXG4gICwgbW92ZTogc2V0TW92ZVxuICB9XG5cbiwgZm5zOiB7XG4gICAgJGZvckNoaWxkcmVuOiBmb3JDaGlsZHJlblxuICAsICRmb3JOYW1lOiBmb3JOYW1lXG4gIH1cbn1cblxuZnVuY3Rpb24gZG9tQ2xlYXIoKSB7XG4gIHRoaXMuX2V2ZW50cy5jbGVhcigpO1xuICB0aGlzLl9jYXB0dXJlRXZlbnRzLmNsZWFyKCk7XG4gIHZhciBjb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50c1xuICAgICwgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzXG4gICAgLCBpLCBjb21wb25lbnRcbiAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aDsgaS0tOykge1xuICAgIHJlbW92ZUxpc3RlbmVyLmFwcGx5KG51bGwsIGxpc3RlbmVyc1tpXSk7XG4gIH1cbiAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gIGZvciAoaSA9IGNvbXBvbmVudHMubGVuZ3RoOyBpLS07KSB7XG4gICAgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcbiAgICBjb21wb25lbnQgJiYgY29tcG9uZW50LmVtaXQoJ2Rlc3Ryb3knKTtcbiAgfVxuICB0aGlzLl9jb21wb25lbnRzID0gW107XG4gIG1hcmtlcnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gZG9tTGlzdGVuZXJIYXNoKCkge1xuICB2YXIgb3V0ID0ge31cbiAgICAsIGtleVxuICBmb3IgKGtleSBpbiB0aGlzKSB7XG4gICAgaWYgKGtleSA9PT0gJ3ZpZXcnIHx8IGtleSA9PT0gJ2N0eCcgfHwga2V5ID09PSAncGF0aElkJykgY29udGludWU7XG4gICAgb3V0W2tleV0gPSB0aGlzW2tleV07XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gZG9tQmluZChldmVudE5hbWUsIGlkLCBsaXN0ZW5lcikge1xuICBsaXN0ZW5lci50b0pTT04gPSBkb21MaXN0ZW5lckhhc2g7XG4gIGlmIChsaXN0ZW5lci5jYXB0dXJlKSB7XG4gICAgbGlzdGVuZXIuaWQgPSBpZDtcbiAgICB0aGlzLl9jYXB0dXJlRXZlbnRzLmJpbmQoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZXZlbnRzLmJpbmQoXCJcIiArIGV2ZW50TmFtZSArIFwiOlwiICsgaWQsIGxpc3RlbmVyLCBldmVudE5hbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRvbUl0ZW0oaWQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSB8fCBnbG9iYWxFbGVtZW50c1tpZF0gfHwgZ2V0UmFuZ2UoaWQpO1xufVxuXG4vLyBIQUNLOiBDcmFwcHkgaW50ZXJmYWNlLiBTaG91bGQgcmVmYWN0b3IgbWFya2VyIGdldHRpbmcgdG8gYmUgYSBwcm90b3R5cGVcbi8vIG1ldGhvZCBhbmQgbWFrZSBkaXJ0eSBhIHByb3BlcnR5IG9mIGRvbSBpbnN0YW5jZVxuZnVuY3Rpb24gc2V0RGlydHkodmFsdWUpIHtcbiAgbWFya2Vyc0RpcnR5ID0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGRvbVVwZGF0ZShlbCwgbWV0aG9kLCBpZ25vcmUsIHZhbHVlLCBwcm9wZXJ0eSwgaW5kZXgsIGFyZykge1xuICAvLyBXcmFwcGVkIGluIGEgdHJ5IC8gY2F0Y2ggc28gdGhhdCBlcnJvcnMgdGhyb3duIG9uIERPTSB1cGRhdGVzIGRvbid0XG4gIC8vIHN0b3Agc3Vic2VxdWVudCBjb2RlIGZyb20gcnVubmluZ1xuICB0cnkge1xuICAgIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIHRoZSBlbGVtZW50IGlzIGFscmVhZHkgdXAgdG8gZGF0ZVxuICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5nZXRNZXRob2RzW21ldGhvZF0oZWwsIHByb3BlcnR5KSkgcmV0dXJuO1xuICAgIHRoaXMuc2V0TWV0aG9kc1ttZXRob2RdKGVsLCBpZ25vcmUsIHZhbHVlLCBwcm9wZXJ0eSwgaW5kZXgsIGFyZyk7XG4gICAgbWFya2Vyc0RpcnR5ID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9LCAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkb21BZGRMaXN0ZW5lcihlbCwgbmFtZSwgY2FsbGJhY2ssIGNhcHR1cmVzKSB7XG4gIHRoaXMuX2xpc3RlbmVycy5wdXNoKFtlbCwgbmFtZSwgY2FsbGJhY2ssIGNhcHR1cmVzXSk7XG4gIGFkZExpc3RlbmVyKGVsLCBuYW1lLCBjYWxsYmFjaywgY2FwdHVyZXMpO1xufVxuZnVuY3Rpb24gZG9tUmVtb3ZlTGlzdGVuZXIoZWwsIG5hbWUsIGNhbGxiYWNrLCBjYXB0dXJlcykge1xuICByZW1vdmVMaXN0ZW5lcihlbCwgbmFtZSwgY2FsbGJhY2ssIGNhcHR1cmVzKTtcbn1cblxuZnVuY3Rpb24gYWRkQ29tcG9uZW50KGN0eCwgY29tcG9uZW50KSB7XG4gIHZhciBjb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50c1xuICAgICwgZG9tID0gY29tcG9uZW50LmRvbSA9IE9iamVjdC5jcmVhdGUodGhpcyk7XG5cbiAgY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gIGNvbXBvbmVudC5vbignZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbmRleCA9IGNvbXBvbmVudHMuaW5kZXhPZihjb21wb25lbnQpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHJldHVybjtcbiAgICAvLyBUaGUgY29tcG9uZW50cyBhcnJheSBnZXRzIHJlcGxhY2VkIG9uIGEgZG9tLmNsZWFyLCBzbyB3ZSBhbGxvd1xuICAgIC8vIGl0IHRvIGdldCBzcGFyc2UgYXMgaW5kaXZpZHVhbCBjb21wb25lbnRzIGFyZSBkZXN0cm95ZWRcbiAgICBkZWxldGUgY29tcG9uZW50c1tpbmRleF07XG4gIH0pO1xuXG4gIGRvbS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKGVsLCBuYW1lLCBjYWxsYmFjaywgY2FwdHVyZXMpIHtcbiAgICBjb21wb25lbnQub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGVsLCBuYW1lLCBjYWxsYmFjaywgY2FwdHVyZXMpO1xuICAgIH0pO1xuICAgIGFkZExpc3RlbmVyKGVsLCBuYW1lLCBjYWxsYmFjaywgY2FwdHVyZXMpO1xuICB9O1xuXG4gIGRvbS5lbGVtZW50ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBpZCA9IGN0eC4kZWxlbWVudHNbbmFtZV07XG4gICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgfTtcblxuICByZXR1cm4gZG9tO1xufVxuXG5cbmZ1bmN0aW9uIGdldEF0dHIoZWwsIGF0dHIpIHtcbiAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUoYXR0cik7XG59XG5mdW5jdGlvbiBnZXRQcm9wKGVsLCBwcm9wKSB7XG4gIHJldHVybiBlbFtwcm9wXTtcbn1cbmZ1bmN0aW9uIGdldFByb3BPdChlbCwgcHJvcCkge1xuICAvLyBJRSBhbmQgT3BlcmEgcmVwbGFjZSBcXG4gd2l0aCBcXHJcXG5cbiAgdmFyIHZhbHVlID0gZWxbcHJvcF07XG4gIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5yZXBsYWNlICYmIHZhbHVlLnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJyk7XG59XG5mdW5jdGlvbiBnZXRIdG1sKGVsKSB7XG4gIHJldHVybiBlbC5pbm5lckhUTUw7XG59XG5mdW5jdGlvbiBnZXROYU4oKSB7XG4gIHJldHVybiBOYU47XG59XG5cbmZ1bmN0aW9uIHNldEF0dHIoZWwsIGlnbm9yZSwgdmFsdWUsIGF0dHIpIHtcbiAgZWwuc2V0QXR0cmlidXRlICYmIGVsLnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBzZXRQcm9wKGVsLCBpZ25vcmUsIHZhbHVlLCBwcm9wKSB7XG4gIGVsW3Byb3BdID0gdmFsdWU7XG59XG5mdW5jdGlvbiBzZXRQcm9wT3QoZWwsIGlnbm9yZSwgdmFsdWUsIHByb3ApIHtcbiAgZWxbcHJvcF0gPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNldFN0cmluZ0luc2VydChlbCwgaWdub3JlLCB2YWx1ZSwgcHJvcCwgaW5kZXgsIHRleHQpIHtcbiAgdmFyIHByZXZpb3VzID0gZ2V0UHJvcE90KGVsLCBwcm9wKTtcbiAgdGV4dE90Lm9uU3RyaW5nSW5zZXJ0KGVsLCBwcmV2aW91cywgaW5kZXgsIHRleHQpO1xufVxuZnVuY3Rpb24gc2V0U3RyaW5nUmVtb3ZlKGVsLCBpZ25vcmUsIHZhbHVlLCBwcm9wLCBpbmRleCwgaG93TWFueSkge1xuICB2YXIgcHJldmlvdXMgPSBnZXRQcm9wT3QoZWwsIHByb3ApO1xuICB0ZXh0T3Qub25TdHJpbmdSZW1vdmUoZWwsIHByZXZpb3VzLCBpbmRleCwgaG93TWFueSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VTVkdGcmFnbWVudChmcmFnbWVudCwgc3ZnRWxlbWVudCkge1xuICAvLyBUT0RPOiBBbGxvdyBvcHRpb25hbCBuYW1lc3BhY2UgZGVjbGFyYXRpb25zXG4gIHZhciBwcmUgPSAnPHN2ZyB4bWxucz1odHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyB4bWxuczp4bGluaz1odHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rPicgXG4gICAgLCBwb3N0ID0gJzwvc3ZnPidcbiAgICAsIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKVxuICByYW5nZS5zZWxlY3ROb2RlKHN2Z0VsZW1lbnQpO1xuICByZXR1cm4gcmFuZ2UuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KHByZSArIGZyYWdtZW50ICsgcG9zdCk7XG59XG5mdW5jdGlvbiBhcHBlbmRTVkcoZWxlbWVudCwgZnJhZ21lbnQsIHN2Z0VsZW1lbnQpIHtcbiAgdmFyIGZyYWcgPSBtYWtlU1ZHRnJhZ21lbnQoZnJhZ21lbnQsIHN2Z0VsZW1lbnQpXG4gICAgLCBjaGlsZHJlbiA9IGZyYWcuY2hpbGROb2Rlc1swXS5jaGlsZE5vZGVzXG4gICAgLCBpXG4gIGZvciAoaSA9IGNoaWxkcmVuLmxlbmd0aDsgaS0tOykge1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoY2hpbGRyZW5bMF0pO1xuICB9XG59XG5mdW5jdGlvbiBpbnNlcnRCZWZvcmVTVkcoZWxlbWVudCwgZnJhZ21lbnQsIHN2Z0VsZW1lbnQpIHtcbiAgdmFyIGZyYWcgPSBtYWtlU1ZHRnJhZ21lbnQoZnJhZ21lbnQsIHN2Z0VsZW1lbnQpXG4gICAgLCBjaGlsZHJlbiA9IGZyYWcuY2hpbGROb2Rlc1swXS5jaGlsZE5vZGVzXG4gICAgLCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGVcbiAgICAsIGlcbiAgZm9yIChpID0gY2hpbGRyZW4ubGVuZ3RoOyBpLS07KSB7XG4gICAgcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZHJlblswXSwgZWxlbWVudCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkcmVuKGVsZW1lbnQpIHtcbiAgdmFyIGNoaWxkcmVuID0gZWxlbWVudC5jaGlsZE5vZGVzXG4gICAgLCBpXG4gIGZvciAoaSA9IGNoaWxkcmVuLmxlbmd0aDsgaS0tOykge1xuICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGRyZW5bMF0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzU1ZHKG9iaikge1xuICByZXR1cm4gISFvYmoub3duZXJTVkdFbGVtZW50IHx8IG9iai50YWdOYW1lID09PSBcInN2Z1wiO1xufVxuZnVuY3Rpb24gc3ZnUm9vdChvYmopIHtcbiAgcmV0dXJuIG9iai5vd25lclNWR0VsZW1lbnQgfHwgb2JqO1xufVxuZnVuY3Rpb24gaXNSYW5nZShvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNsb25lUmFuZ2U7XG59XG5cbmZ1bmN0aW9uIHNldEh0bWwob2JqLCBpZ25vcmUsIHZhbHVlLCBlc2NhcGUpIHtcbiAgaWYgKGVzY2FwZSkgdmFsdWUgPSBlc2NhcGVIdG1sKHZhbHVlKTtcbiAgaWYoaXNSYW5nZShvYmopKSB7XG4gICAgaWYoaXNTVkcob2JqLnN0YXJ0Q29udGFpbmVyKSkge1xuICAgICAgLy8gU1ZHIEVsZW1lbnRcbiAgICAgIG9iai5kZWxldGVDb250ZW50cygpO1xuICAgICAgdmFyIHN2Z0VsZW1lbnQgPSBzdmdSb290KG9iai5zdGFydENvbnRhaW5lcik7XG4gICAgICBvYmouaW5zZXJ0Tm9kZShtYWtlU1ZHRnJhZ21lbnQodmFsdWUsIHN2Z0VsZW1lbnQpKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmFuZ2VcbiAgICAgIG9iai5kZWxldGVDb250ZW50cygpO1xuICAgICAgb2JqLmluc2VydE5vZGUob2JqLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCh2YWx1ZSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBpZiAoaXNTVkcob2JqKSkge1xuICAgIC8vIFNWRyBFbGVtZW50XG4gICAgdmFyIHN2Z0VsZW1lbnQgPSBzdmdSb290KG9iaik7XG4gICAgcmVtb3ZlQ2hpbGRyZW4ob2JqKTtcbiAgICBhcHBlbmRTVkcob2JqLCB2YWx1ZSwgc3ZnRWxlbWVudCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIEhUTUwgRWxlbWVudFxuICBpZiAoaWdub3JlICYmIG9iai5pZCA9PT0gaWdub3JlKSByZXR1cm47XG4gIG9iai5pbm5lckhUTUwgPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNldEluc2VydChvYmosIGlnbm9yZSwgdmFsdWUsIGVzY2FwZSwgaW5kZXgpIHtcbiAgaWYgKGVzY2FwZSkgdmFsdWUgPSBlc2NhcGVIdG1sKHZhbHVlKTtcbiAgaWYgKG9iai5ub2RlVHlwZSkge1xuICAgIC8vIEVsZW1lbnRcbiAgICBpZiAocmVmID0gb2JqLmNoaWxkTm9kZXNbaW5kZXhdKSB7XG4gICAgICBpZiAoaXNTVkcob2JqKSkge1xuICAgICAgICB2YXIgc3ZnRWxlbWVudCA9IG9iai5vd25lclNWR0VsZW1lbnQgfHwgb2JqO1xuICAgICAgICBpbnNlcnRCZWZvcmVTVkcocmVmLCB2YWx1ZSwgc3ZnRWxlbWVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMob2JqKTtcbiAgICAgIG9iai5pbnNlcnRCZWZvcmUocmFuZ2UuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KHZhbHVlKSwgcmVmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzU1ZHKG9iaikpIHtcbiAgICAgICAgdmFyIHN2Z0VsZW1lbnQgPSBvYmoub3duZXJTVkdFbGVtZW50IHx8IG9iajtcbiAgICAgICAgYXBwZW5kU1ZHKG9iaiwgdmFsdWUsIHN2Z0VsZW1lbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG9iaik7XG4gICAgICBvYmouYXBwZW5kQ2hpbGQocmFuZ2UuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KHZhbHVlKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFJhbmdlXG4gICAgaWYgKGlzU1ZHKG9iai5zdGFydENvbnRhaW5lcikpIHtcbiAgICAgIHZhciBlbCA9IG9iai5zdGFydENvbnRhaW5lclxuICAgICAgLCByZWYgPSBlbC5jaGlsZE5vZGVzW29iai5zdGFydE9mZnNldCArIGluZGV4XTtcbiAgICAgIHZhciBzdmdFbGVtZW50ID0gc3ZnUm9vdChyZWYpO1xuICAgICAgZWwuaW5zZXJ0QmVmb3JlKG1ha2VTVkdGcmFnbWVudCh2YWx1ZSwgc3ZnRWxlbWVudCksIHJlZilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVsID0gb2JqLnN0YXJ0Q29udGFpbmVyXG4gICAgICAgICwgcmVmID0gZWwuY2hpbGROb2Rlc1tvYmouc3RhcnRPZmZzZXQgKyBpbmRleF07XG4gICAgICBlbC5pbnNlcnRCZWZvcmUob2JqLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCh2YWx1ZSksIHJlZik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRSZW1vdmUoZWwsIGlnbm9yZSwgaW5kZXgpIHtcbiAgaWYgKCFlbC5ub2RlVHlwZSkge1xuICAgIC8vIFJhbmdlXG4gICAgaW5kZXggKz0gZWwuc3RhcnRPZmZzZXQ7XG4gICAgZWwgPSBlbC5zdGFydENvbnRhaW5lcjtcbiAgfVxuICB2YXIgY2hpbGQgPSBlbC5jaGlsZE5vZGVzW2luZGV4XTtcbiAgaWYgKGNoaWxkKSBlbC5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5mdW5jdGlvbiBzZXRNb3ZlKGVsLCBpZ25vcmUsIGZyb20sIHByb3BlcnR5LCB0bywgaG93TWFueSkge1xuICB2YXIgY2hpbGQsIGZyYWdtZW50LCBuZXh0Q2hpbGQsIG9mZnNldCwgcmVmLCB0b0VsO1xuICBpZiAoIWVsLm5vZGVUeXBlKSB7XG4gICAgb2Zmc2V0ID0gZWwuc3RhcnRPZmZzZXQ7XG4gICAgZnJvbSArPSBvZmZzZXQ7XG4gICAgdG8gKz0gb2Zmc2V0O1xuICAgIGVsID0gZWwuc3RhcnRDb250YWluZXI7XG4gIH1cbiAgY2hpbGQgPSBlbC5jaGlsZE5vZGVzW2Zyb21dO1xuXG4gIC8vIERvbid0IG1vdmUgaWYgdGhlIGl0ZW0gYXQgdGhlIGRlc3RpbmF0aW9uIGlzIHBhc3NlZCBhcyB0aGUgaWdub3JlXG4gIC8vIG9wdGlvbiwgc2luY2UgdGhpcyBpbmRpY2F0ZXMgdGhlIGludGVuZGVkIGl0ZW0gd2FzIGFscmVhZHkgbW92ZWRcbiAgLy8gQWxzbyBkb24ndCBtb3ZlIGlmIHRoZSBjaGlsZCB0byBtb3ZlIG1hdGNoZXMgdGhlIGlnbm9yZSBvcHRpb25cbiAgaWYgKCFjaGlsZCB8fCBpZ25vcmUgJiYgKHRvRWwgPSBlbC5jaGlsZE5vZGVzW3RvXSkgJiZcbiAgICAgIHRvRWwuaWQgPT09IGlnbm9yZSB8fCBjaGlsZC5pZCA9PT0gaWdub3JlKSByZXR1cm47XG5cbiAgcmVmID0gZWwuY2hpbGROb2Rlc1t0byA+IGZyb20gPyB0byArIGhvd01hbnkgOiB0b107XG4gIGlmIChob3dNYW55ID4gMSkge1xuICAgIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIHdoaWxlIChob3dNYW55LS0pIHtcbiAgICAgIG5leHRDaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgaWYgKCEoY2hpbGQgPSBuZXh0Q2hpbGQpKSBicmVhaztcbiAgICB9XG4gICAgZWwuaW5zZXJ0QmVmb3JlKGZyYWdtZW50LCByZWYpO1xuICAgIHJldHVybjtcbiAgfVxuICBlbC5pbnNlcnRCZWZvcmUoY2hpbGQsIHJlZik7XG59XG5cbmZ1bmN0aW9uIGZvckNoaWxkcmVuKGUsIGVsLCBuZXh0LCBkb20pIHtcbiAgLy8gUHJldmVudCBpbmZpbnRlIGVtaXNzaW9uXG4gIGlmICghbmV4dC5maXJzdFRyaWdnZXIpIHJldHVybjtcblxuICAvLyBSZS10cmlnZ2VyIHRoZSBldmVudCBvbiBhbGwgY2hpbGQgZWxlbWVudHNcbiAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGROb2RlcztcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aCwgY2hpbGQ7IGkgPCBsZW47IGkrKykge1xuICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGNoaWxkLm5vZGVUeXBlICE9PSAxKSBjb250aW51ZTsgIC8vIE5vZGUuRUxFTUVOVF9OT0RFXG4gICAgZG9tLnRyaWdnZXIoZSwgY2hpbGQsIHRydWUsIHRydWUpO1xuICAgIGZvckNoaWxkcmVuKGUsIGNoaWxkLCBuZXh0LCBkb20pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvck5hbWUoZSwgZWwsIG5leHQsIGRvbSkge1xuICAvLyBQcmV2ZW50IGluZmludGUgZW1pc3Npb25cbiAgaWYgKCFuZXh0LmZpcnN0VHJpZ2dlcikgcmV0dXJuO1xuXG4gIHZhciBuYW1lID0gZWwuZ2V0QXR0cmlidXRlKCduYW1lJyk7XG4gIGlmICghbmFtZSkgcmV0dXJuO1xuXG4gIC8vIFJlLXRyaWdnZXIgdGhlIGV2ZW50IG9uIGFsbCBvdGhlciBlbGVtZW50cyB3aXRoXG4gIC8vIHRoZSBzYW1lICduYW1lJyBhdHRyaWJ1dGVcbiAgdmFyIGVsZW1lbnRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUobmFtZSlcbiAgICAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgaWYgKCEobGVuID4gMSkpIHJldHVybjtcbiAgZm9yICh2YXIgaSA9IDAsIGVsZW1lbnQ7IGkgPCBsZW47IGkrKykge1xuICAgIGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICBpZiAoZWxlbWVudCA9PT0gZWwpIGNvbnRpbnVlO1xuICAgIGRvbS50cmlnZ2VyKGUsIGVsZW1lbnQsIGZhbHNlLCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRNYXJrZXJzKCkge1xuICB2YXIgbWFwID0ge307XG4gIC8vIE5vZGVGaWx0ZXIuU0hPV19DT01NRU5UID09IDEyOFxuICB2YXIgY29tbWVudEl0ZXJhdG9yID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihkb2N1bWVudCwgMTI4LCBudWxsLCBmYWxzZSk7XG4gIHZhciBjb21tZW50O1xuICB3aGlsZSAoY29tbWVudCA9IGNvbW1lbnRJdGVyYXRvci5uZXh0Tm9kZSgpKSB7XG4gICAgbWFwW2NvbW1lbnQuZGF0YV0gPSBjb21tZW50O1xuICB9XG4gIHJldHVybiBtYXA7XG59XG5cbmZ1bmN0aW9uIGdldE1hcmtlcihtYXAsIG5hbWUpIHtcbiAgdmFyIG1hcmtlciA9IG1hcFtuYW1lXTtcbiAgaWYgKCFtYXJrZXIpIHJldHVybjtcblxuICAvLyBDb21tZW50IG5vZGVzIG1heSBjb250aW51ZSB0byBleGlzdCBldmVuIGlmIHRoZXkgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbVxuICAvLyB0aGUgcGFnZS4gVGh1cywgbWFrZSBzdXJlIHRoZXkgYXJlIHN0aWxsIHNvbWV3aGVyZSBpbiB0aGUgcGFnZSBib2R5XG4gIGlmICghZG9jdW1lbnQuY29udGFpbnMobWFya2VyKSkge1xuICAgIGRlbGV0ZSBtYXBbbmFtZV07XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiBtYXJrZXI7XG59XG5cbmZ1bmN0aW9uIGRvbU1hcmtlcihuYW1lKSB7XG4gIHZhciBtYXJrZXIgPSBnZXRNYXJrZXIobWFya2VycywgbmFtZSk7XG4gIGlmICghbWFya2VyICYmIG1hcmtlcnNEaXJ0eSkge1xuICAgIG1hcmtlcnMgPSBnZXRNYXJrZXJzKCk7XG4gICAgbWFya2Vyc0RpcnR5ID0gZmFsc2U7XG4gICAgbWFya2VyID0gZ2V0TWFya2VyKG1hcmtlcnMsIG5hbWUpO1xuICB9XG4gIHJldHVybiBtYXJrZXI7XG59XG5cbmZ1bmN0aW9uIGdldFJhbmdlKG5hbWUpIHtcbiAgdmFyIHN0YXJ0ID0gZG9tTWFya2VyKG5hbWUpO1xuICBpZiAoIXN0YXJ0KSByZXR1cm47XG4gIHZhciBlbmQgPSBkb21NYXJrZXIoJyQnICsgbmFtZSk7XG4gIGlmICghZW5kKSByZXR1cm47XG5cbiAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgcmFuZ2Uuc2V0U3RhcnRBZnRlcihzdGFydCk7XG4gIHJhbmdlLnNldEVuZEJlZm9yZShlbmQpO1xuICByZXR1cm4gcmFuZ2U7XG59XG5cbmlmIChkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG4gIGFkZExpc3RlbmVyID0gZnVuY3Rpb24oZWwsIG5hbWUsIGNhbGxiYWNrLCBjYXB0dXJlcykge1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgY2FsbGJhY2ssIGNhcHR1cmVzIHx8IGZhbHNlKTtcbiAgfTtcbiAgcmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbihlbCwgbmFtZSwgY2FsbGJhY2ssIGNhcHR1cmVzKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBjYWxsYmFjaywgY2FwdHVyZXMgfHwgZmFsc2UpO1xuICB9O1xufVxuIiwidmFyIGVzY2FwZUh0bWwgPSByZXF1aXJlKCdodG1sLXV0aWwnKS5lc2NhcGVIdG1sXG4gICwgZXJyb3JzID0ge307XG5cbmV4cG9ydHMuZXJyb3JIdG1sID0gZXJyb3JIdG1sO1xuZXhwb3J0cy5hdXRvUmVmcmVzaCA9IGF1dG9SZWZyZXNoO1xuXG5mdW5jdGlvbiBlcnJvckh0bWwoZXJyb3JzKSB7XG4gIHZhciB0ZXh0ID0gJydcbiAgICAsIHR5cGUsIGVycjtcbiAgZm9yICh0eXBlIGluIGVycm9ycykge1xuICAgIGVyciA9IGVycm9yc1t0eXBlXTtcbiAgICB0ZXh0ICs9ICc8aDM+JyArIGVzY2FwZUh0bWwodHlwZSkgKyAnIEVycm9yPC9oMz48cHJlPicgKyBlc2NhcGVIdG1sKGVycikgKyAnPC9wcmU+JztcbiAgfVxuICBpZiAoIXRleHQpIHJldHVybjtcbiAgcmV0dXJuICc8ZGl2IGlkPSRfZGVyYnlFcnJvciBzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlO2JhY2tncm91bmQ6cmdiYSgwLDAsMCwuNyk7dG9wOjA7bGVmdDowO3JpZ2h0OjA7Ym90dG9tOjA7dGV4dC1hbGlnbjpjZW50ZXJcIj4nICtcbiAgICAnPGRpdiBzdHlsZT1cImJhY2tncm91bmQ6I2ZmZjtwYWRkaW5nOjIwcHggNDBweDttYXJnaW46NjBweDtkaXNwbGF5OmlubGluZS1ibG9jazt0ZXh0LWFsaWduOmxlZnRcIj4nICtcbiAgICB0ZXh0ICsgJzwvZGl2PjwvZGl2Pic7XG59XG5cbmZ1bmN0aW9uIGF1dG9SZWZyZXNoKHZpZXcsIG1vZGVsKSB7XG5cbiAgbW9kZWwuY2hhbm5lbC5vbignZGVyYnk6cmVsb2FkJywgcmVsb2FkT25SZWFkeSk7XG4gIC8vIFdhaXQgdG8gcmVsb2FkIHVudGlsIHRoZSBzZXJ2ZXIgaXMgcmVzcG9uc2l2ZSBhZ2FpbiBhZnRlciByZXN0YXJ0aW5nXG4gIGZ1bmN0aW9uIHJlbG9hZE9uUmVhZHkoKSB7XG4gICAgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHhoci5yZWFkeVN0YXRlICE9PSA0KSByZXR1cm47XG4gICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ucmVsb2FkKHRydWUpO1xuICAgICAgfVxuICAgICAgcmVsb2FkT25SZWFkeSgpO1xuICAgIH07XG4gICAgeGhyLm9wZW4oJ0dFVCcsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICB4aHIuc2VuZCgpO1xuICB9XG5cbiAgbW9kZWwuY2hhbm5lbC5vbignZGVyYnk6cmVmcmVzaENzcycsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnJF9jc3MnKTtcbiAgICBpZiAoZWwpIGVsLmlubmVySFRNTCA9IGRhdGEuY3NzO1xuICAgIHVwZGF0ZUVycm9yKCdDU1MnLCBkYXRhLmVyclRleHQpO1xuICB9KTtcblxuICBtb2RlbC5jaGFubmVsLm9uKCdkZXJieTpyZWZyZXNoSHRtbCcsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2aWV3Ll9tYWtlQWxsKGRhdGEudGVtcGxhdGVzLCBkYXRhLmluc3RhbmNlcyk7XG4gICAgdmlldy5fbWFrZUNvbXBvbmVudHMoZGF0YS5saWJyYXJ5RGF0YSk7XG4gICAgdmFyIGVyclRleHQgPSBkYXRhLmVyclRleHQ7XG4gICAgdHJ5IHtcbiAgICAgIHZpZXcuYXBwLmhpc3RvcnkucmVmcmVzaCgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZXJyVGV4dCB8fCAoZXJyVGV4dCA9IGVyci5zdGFjayk7XG4gICAgfVxuICAgIHVwZGF0ZUVycm9yKCdUZW1wbGF0ZScsIGRhdGEuZXJyVGV4dCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVFcnJvcih0eXBlLCBlcnIpIHtcbiAgaWYgKGVycikge1xuICAgIGVycm9yc1t0eXBlXSA9IGVycjtcbiAgfSBlbHNlIHtcbiAgICBkZWxldGUgZXJyb3JzW3R5cGVdO1xuICB9XG4gIHZhciBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCckX2RlcmJ5RXJyb3InKVxuICAgICwgaHRtbCA9IGVycm9ySHRtbChlcnJvcnMpXG4gICAgLCBmcmFnbWVudCwgcmFuZ2U7XG4gIGlmIChodG1sKSB7XG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5vdXRlckhUTUwgPSBodG1sO1xuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICByYW5nZS5zZWxlY3ROb2RlKGRvY3VtZW50LmJvZHkpO1xuICAgICAgZnJhZ21lbnQgPSByYW5nZS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQoaHRtbCk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZyYWdtZW50KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGVsKSBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgfVxufVxuIiwidmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xuXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbiAobW9kZWwpIHtcbiAgdmFyIGZpbGVuYW1lID0gbW9kZWwuZ2V0KCdmaWxlbmFtZScpIHx8ICdnaXRodWItYnRuLmh0bWwnXG4gICAgLCBmaWxldXJsID0gbW9kZWwuZ2V0KCdmaWxldXJsJylcbiAgICAsIGRvbWFpbiA9IG1vZGVsLmdldCgnZG9tYWluJykgfHwgJ2doYnRucy5jb20nXG4gICAgLCBnaXR1cmwgPSBtb2RlbC5nZXQoJ2dpdHVybCcpXG4gICAgLCBoZWlnaHQgPSBtb2RlbC5nZXQoJ2hlaWdodCcpXG4gICAgLCBwcm90b2NvbCA9IG1vZGVsLmdldCgnc2VjdXJlJykgPyAnaHR0cHMnIDogJ2h0dHAnXG4gICAgLCByZXBvID0gbW9kZWwuZ2V0KCdyZXBvJylcbiAgICAsIHNpemUgPSBtb2RlbC5nZXQoJ3NpemUnKVxuICAgICwgdHlwZSA9IG1vZGVsLmdldCgndHlwZScpXG4gICAgLCB1c2VyID0gbW9kZWwuZ2V0KCd1c2VyJyk7XG5cbiAgaWYgKCFnaXR1cmwgJiYgKCF1c2VyIHx8ICFyZXBvKSkge1xuICAgIHJldHVybiBjb25zb2xlLmVycm9yKCdnaGJ0bnM6YnV0dG9uOiBnaXR1cmwgb3IgdXNlci9yZXBvIHJlcXVpcmVkJyk7XG4gIH1cblxuICBpZiAoIXR5cGUpIHtcbiAgICByZXR1cm4gY29uc29sZS5lcnJvcignZ2hidG5zOmJ1dHRvbjogdHlwZSByZXF1aXJlZCcpO1xuICB9XG5cbiAgaWYgKCFmaWxldXJsKSB7XG4gICAgbW9kZWwuc2V0KCdmaWxldXJsJywgcHJvdG9jb2wgKyAnOi8vJyArIGRvbWFpbiArICcvJyArIGZpbGVuYW1lKTtcbiAgfVxuXG4gIGlmIChnaXR1cmwpIHtcbiAgICB2YXIgZ2l0cGF0aCA9IHVybC5wYXJzZShnaXR1cmwpLnBhdGguc3BsaXQoJy8nKTtcbiAgICBtb2RlbC5zZXQoJ3JlcG8nLCBnaXRwYXRoWzJdLnNsaWNlKDAsIC00KSk7XG4gICAgbW9kZWwuc2V0KCd1c2VyJywgZ2l0cGF0aFsxXSk7XG4gIH1cblxuICBpZiAoIWhlaWdodCkge1xuICAgIG1vZGVsLnNldCgnaGVpZ2h0Jywgc2l6ZSA9PT0gJ2xhcmdlJyA/ICczMCcgOiAnMjAnKTtcbiAgfVxuXG4gIG1vZGVsLnNldCgnc2hvdycsIHRydWUpO1xufTsiLCJ2YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIE9iamVjdF9rZXlzID0gdHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nXG4gICAgPyBPYmplY3Qua2V5c1xuICAgIDogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuO1xuXG52YXIgZGVlcEVxdWFsID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYWN0dWFsLCBleHBlY3RlZCkge1xuICAvLyBlbmZvcmNlIE9iamVjdC5pcyArMCAhPT0gLTBcbiAgaWYgKGFjdHVhbCA9PT0gMCAmJiBleHBlY3RlZCA9PT0gMCkge1xuICAgIHJldHVybiBhcmVaZXJvc0VxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpO1xuXG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICB9IGVsc2UgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIERhdGUgJiYgZXhwZWN0ZWQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5nZXRUaW1lKCkgPT09IGV4cGVjdGVkLmdldFRpbWUoKTtcblxuICB9IGVsc2UgaWYgKGlzTnVtYmVyTmFOKGFjdHVhbCkpIHtcbiAgICByZXR1cm4gaXNOdW1iZXJOYU4oZXhwZWN0ZWQpO1xuXG4gIC8vIDcuMy4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICh0eXBlb2YgYWN0dWFsICE9ICdvYmplY3QnICYmIHR5cGVvZiBleHBlY3RlZCAhPSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy40LiBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZE9yTnVsbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaXNBcmd1bWVudHMob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXJOYU4odmFsdWUpIHtcbiAgLy8gTmFOID09PSBOYU4gLT4gZmFsc2VcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGFyZVplcm9zRXF1YWwoemVyb0EsIHplcm9CKSB7XG4gIC8vICgxIC8gKzB8MCkgLT4gSW5maW5pdHksIGJ1dCAoMSAvIC0wKSAtPiAtSW5maW5pdHkgYW5kIChJbmZpbml0eSAhPT0gLUluZmluaXR5KVxuICByZXR1cm4gKDEgLyB6ZXJvQSkgPT09ICgxIC8gemVyb0IpO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiKSB7XG4gIGlmIChpc1VuZGVmaW5lZE9yTnVsbChhKSB8fCBpc1VuZGVmaW5lZE9yTnVsbChiKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LlxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gIC8vfn5+SSd2ZSBtYW5hZ2VkIHRvIGJyZWFrIE9iamVjdC5rZXlzIHRocm91Z2ggc2NyZXd5IGFyZ3VtZW50cyBwYXNzaW5nLlxuICAvLyAgIENvbnZlcnRpbmcgdG8gYXJyYXkgc29sdmVzIHRoZSBwcm9ibGVtLlxuICBpZiAoaXNBcmd1bWVudHMoYSkpIHtcbiAgICBpZiAoIWlzQXJndW1lbnRzKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIGRlZXBFcXVhbChhLCBiKTtcbiAgfVxuICB0cnkge1xuICAgIHZhciBrYSA9IE9iamVjdF9rZXlzKGEpLFxuICAgICAgICBrYiA9IE9iamVjdF9rZXlzKGIpLFxuICAgICAgICBrZXksIGk7XG4gIH0gY2F0Y2ggKGUpIHsvL2hhcHBlbnMgd2hlbiBvbmUgaXMgYSBzdHJpbmcgbGl0ZXJhbCBhbmQgdGhlIG90aGVyIGlzbid0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIWRlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbiIsInZhciBkb2MgPSBkb2N1bWVudFxuICAsIGVsZW1lbnRQcm90byA9IEhUTUxFbGVtZW50LnByb3RvdHlwZVxuICAsIG5vZGVQcm90byA9IE5vZGUucHJvdG90eXBlXG5cbi8vIEFkZCBzdXBwb3J0IGZvciBOb2RlLmNvbnRhaW5zIGZvciBGaXJlZm94IDwgOVxuaWYgKCFkb2MuY29udGFpbnMpIHtcbiAgbm9kZVByb3RvLmNvbnRhaW5zID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiAhISh0aGlzLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG5vZGUpICYgMTYpXG4gIH1cbn1cblxuLy8gQWRkIHN1cHBvcnQgZm9yIGluc2VydEFkamFjZW50SFRNTCBmb3IgRmlyZWZveCA8IDhcbi8vIEJhc2VkIG9uIGluc2VydEFkamFjZW50SFRNTC5qcyBieSBFbGkgR3JleSwgaHR0cDovL2VsaWdyZXkuY29tXG5pZiAoIWRvYy5ib2R5Lmluc2VydEFkamFjZW50SFRNTCkge1xuICBlbGVtZW50UHJvdG8uaW5zZXJ0QWRqYWNlbnRIVE1MID0gZnVuY3Rpb24ocG9zaXRpb24sIGh0bWwpIHtcbiAgICB2YXIgcG9zaXRpb24gPSBwb3NpdGlvbi50b0xvd2VyQ2FzZSgpXG4gICAgICAsIHJlZiA9IHRoaXNcbiAgICAgICwgcGFyZW50ID0gcmVmLnBhcmVudE5vZGVcbiAgICAgICwgY29udGFpbmVyID0gZG9jLmNyZWF0ZUVsZW1lbnQocGFyZW50LnRhZ05hbWUpXG4gICAgICAsIGZpcnN0Q2hpbGQsIG5leHRTaWJsaW5nLCBub2RlXG5cbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gaHRtbFxuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2JlZm9yZWVuZCcpIHtcbiAgICAgIHdoaWxlIChub2RlID0gY29udGFpbmVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgcmVmLmFwcGVuZENoaWxkKG5vZGUpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JlZm9yZWJlZ2luJykge1xuICAgICAgd2hpbGUgKG5vZGUgPSBjb250YWluZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIHJlZilcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnYWZ0ZXJlbmQnKSB7XG4gICAgICBuZXh0U2libGluZyA9IHJlZi5uZXh0U2libGluZ1xuICAgICAgd2hpbGUgKG5vZGUgPSBjb250YWluZXIubGFzdENoaWxkKSB7XG4gICAgICAgIG5leHRTaWJsaW5nID0gcGFyZW50Lmluc2VydEJlZm9yZShub2RlLCBuZXh0U2libGluZylcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnYWZ0ZXJiZWdpbicpIHtcbiAgICAgIGZpcnN0Q2hpbGQgPSByZWYuZmlyc3RDaGlsZFxuICAgICAgd2hpbGUgKG5vZGUgPSBjb250YWluZXIubGFzdENoaWxkKSB7XG4gICAgICAgIGZpcnN0Q2hpbGQgPSByZWYuaW5zZXJ0QmVmb3JlKG5vZGUsIGZpcnN0Q2hpbGQpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmVsZW1lbnRQcm90by5tYXRjaGVzID1cbiAgZWxlbWVudFByb3RvLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuICBlbGVtZW50UHJvdG8ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG4gIGVsZW1lbnRQcm90by5vTWF0Y2hlc1NlbGVjdG9yIHx8XG4gIGVsZW1lbnRQcm90by5tc01hdGNoZXNTZWxlY3RvclxuIiwidmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xuXG4vLyBUaGlzIG1hcCBkZXRlcm1pbmVzIHdoaWNoIGV2ZW50cyBnZXQgcmUtZW1pdHRlZCBhcyBhbiAnYWxsJyBldmVudFxuTW9kZWwuTVVUQVRPUl9FVkVOVFMgPSB7XG4gIGNoYW5nZTogdHJ1ZVxuLCBpbnNlcnQ6IHRydWVcbiwgcmVtb3ZlOiB0cnVlXG4sIG1vdmU6IHRydWVcbiwgc3RyaW5nSW5zZXJ0OiB0cnVlXG4sIHN0cmluZ1JlbW92ZTogdHJ1ZVxuLCBsb2FkOiB0cnVlXG4sIHVubG9hZDogdHJ1ZVxufTtcblxuTW9kZWwuSU5JVFMucHVzaChmdW5jdGlvbihtb2RlbCkge1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAvLyBTZXQgbWF4IGxpc3RlbmVycyB0byB1bmxpbWl0ZWRcbiAgbW9kZWwuc2V0TWF4TGlzdGVuZXJzKDApO1xuXG4gIC8vIFVzZWQgaW4gYXN5bmMgbWV0aG9kcyB0byBlbWl0IGFuIGVycm9yIGV2ZW50IGlmIGEgY2FsbGJhY2sgaXMgbm90IHN1cHBsaWVkLlxuICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgdGhlcmUgaXMgbm8gaGFuZGxlciBmb3IgbW9kZWwub24oJ2Vycm9yJylcbiAgbW9kZWwucm9vdC5fZGVmYXVsdENhbGxiYWNrID0gZGVmYXVsdENhbGxiYWNrO1xuICBmdW5jdGlvbiBkZWZhdWx0Q2FsbGJhY2soZXJyKSB7XG4gICAgaWYgKHR5cGVvZiBlcnIgPT09ICdzdHJpbmcnKSBlcnIgPSBuZXcgRXJyb3IoZXJyKTtcbiAgICBpZiAoZXJyKSBtb2RlbC5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cblxuICBtb2RlbC5yb290Ll9tdXRhdG9yRXZlbnRRdWV1ZSA9IG51bGw7XG4gIG1vZGVsLl9wYXNzID0gbmV3IFBhc3NlZCh7fSwge30pO1xufSk7XG5cbnV0aWwubWVyZ2VJbnRvKE1vZGVsLnByb3RvdHlwZSwgRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5cbi8vIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24sIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIsIGFuZFxuLy8gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlIHJldHVybiBgdGhpc2AuIFRoZSBNb2RlbCBlcXVpdmFsZW50cyByZXR1cm5cbi8vIHRoZSBsaXN0ZW5lciBpbnN0ZWFkLCBzaW5jZSBpdCBpcyBtYWRlIGludGVybmFsbHkgZm9yIG1ldGhvZCBzdWJzY3JpcHRpb25zXG4vLyBhbmQgbWF5IG5lZWQgdG8gYmUgcGFzc2VkIHRvIHJlbW92ZUxpc3RlbmVyLlxuXG5Nb2RlbC5wcm90b3R5cGUuX2VtaXQgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ7XG5Nb2RlbC5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKE1vZGVsLk1VVEFUT1JfRVZFTlRTW3R5cGVdKSB7XG4gICAgaWYgKHRoaXMuX3NpbGVudCkgcmV0dXJuIHRoaXM7XG4gICAgdmFyIHNlZ21lbnRzID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBldmVudEFyZ3MgPSBhcmd1bWVudHNbMl07XG4gICAgaWYgKHRoaXMucm9vdC5fbXV0YXRvckV2ZW50UXVldWUpIHtcbiAgICAgIHRoaXMucm9vdC5fbXV0YXRvckV2ZW50UXVldWUucHVzaChbdHlwZSwgc2VnbWVudHMsIGV2ZW50QXJnc10pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMucm9vdC5fbXV0YXRvckV2ZW50UXVldWUgPSBbXTtcbiAgICB0aGlzLl9lbWl0KHR5cGUsIHNlZ21lbnRzLCBldmVudEFyZ3MpO1xuICAgIHRoaXMuX2VtaXQoJ2FsbCcsIHNlZ21lbnRzLCBbdHlwZV0uY29uY2F0KGV2ZW50QXJncykpO1xuICAgIHdoaWxlICh0aGlzLnJvb3QuX211dGF0b3JFdmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgdmFyIHF1ZXVlZCA9IHRoaXMucm9vdC5fbXV0YXRvckV2ZW50UXVldWUuc2hpZnQoKTtcbiAgICAgIHR5cGUgPSBxdWV1ZWRbMF07XG4gICAgICBzZWdtZW50cyA9IHF1ZXVlZFsxXTtcbiAgICAgIGV2ZW50QXJncyA9IHF1ZXVlZFsyXTtcbiAgICAgIHRoaXMuX2VtaXQodHlwZSwgc2VnbWVudHMsIGV2ZW50QXJncyk7XG4gICAgICB0aGlzLl9lbWl0KCdhbGwnLCBzZWdtZW50cywgW3R5cGVdLmNvbmNhdChldmVudEFyZ3MpKTtcbiAgICB9XG4gICAgdGhpcy5yb290Ll9tdXRhdG9yRXZlbnRRdWV1ZSA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2VtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5fb24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuTW9kZWwucHJvdG90eXBlLmFkZExpc3RlbmVyID1cbk1vZGVsLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKHR5cGUsIHBhdHRlcm4sIGNiKSB7XG4gIHZhciBsaXN0ZW5lciA9IGV2ZW50TGlzdGVuZXIodGhpcywgcGF0dGVybiwgY2IpO1xuICB0aGlzLl9vbih0eXBlLCBsaXN0ZW5lcik7XG4gIHJldHVybiBsaXN0ZW5lcjtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgcGF0dGVybiwgY2IpIHtcbiAgdmFyIGxpc3RlbmVyID0gZXZlbnRMaXN0ZW5lcih0aGlzLCBwYXR0ZXJuLCBjYik7XG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdmFyIG1hdGNoZXMgPSBsaXN0ZW5lci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGlmIChtYXRjaGVzKSB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuICB9XG4gIHRoaXMuX29uKHR5cGUsIGcpO1xuICByZXR1cm4gZztcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5fcmVtb3ZlQWxsTGlzdGVuZXJzID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnM7XG5Nb2RlbC5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSwgc3VicGF0dGVybikge1xuICBpZiAoIXRoaXMuX2V2ZW50cykgcmV0dXJuIHRoaXM7XG5cbiAgLy8gSWYgYSBwYXR0ZXJuIGlzIHNwZWNpZmllZCB3aXRob3V0IGFuIGV2ZW50IHR5cGUsIHJlbW92ZSBhbGwgbW9kZWwgZXZlbnRcbiAgLy8gbGlzdGVuZXJzIHVuZGVyIHRoYXQgcGF0dGVybiBmb3IgYWxsIGV2ZW50c1xuICBpZiAoIXR5cGUpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXksIHN1YnBhdHRlcm4pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBwYXR0ZXJuID0gdGhpcy5wYXRoKHN1YnBhdHRlcm4pO1xuICAvLyBJZiBubyBwYXR0ZXJuIGlzIHNwZWNpZmllZCwgcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgbGlrZSBub3JtYWxcbiAgaWYgKCFwYXR0ZXJuKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbW92ZUFsbExpc3RlbmVycyh0eXBlKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgYW4gZXZlbnQgdW5kZXIgYSBwYXR0ZXJuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycyh0eXBlKTtcbiAgdmFyIHNlZ21lbnRzID0gcGF0dGVybi5zcGxpdCgnLicpO1xuICAvLyBNYWtlIHN1cmUgdG8gaXRlcmF0ZSBpbiByZXZlcnNlLCBzaW5jZSB0aGUgYXJyYXkgbWlnaHQgYmVcbiAgLy8gbXV0YXRlZCBhcyBsaXN0ZW5lcnMgYXJlIHJlbW92ZWRcbiAgZm9yICh2YXIgaSA9IGxpc3RlbmVycy5sZW5ndGg7IGktLTspIHtcbiAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG4gICAgaWYgKHBhdHRlcm5Db250YWluZWQocGF0dGVybiwgc2VnbWVudHMsIGxpc3RlbmVyKSkge1xuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBwYXR0ZXJuQ29udGFpbmVkKHBhdHRlcm4sIHNlZ21lbnRzLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdGVuZXJTZWdtZW50cyA9IGxpc3RlbmVyLnBhdHRlcm5TZWdtZW50cztcbiAgaWYgKCFsaXN0ZW5lclNlZ21lbnRzKSByZXR1cm4gZmFsc2U7XG4gIGlmIChwYXR0ZXJuID09PSBsaXN0ZW5lci5wYXR0ZXJuIHx8IHBhdHRlcm4gPT09ICcqKicpIHJldHVybiB0cnVlO1xuICB2YXIgbGVuID0gc2VnbWVudHMubGVuZ3RoO1xuICBpZiAobGVuID4gbGlzdGVuZXJTZWdtZW50cy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChzZWdtZW50c1tpXSAhPT0gbGlzdGVuZXJTZWdtZW50c1tpXSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5Nb2RlbC5wcm90b3R5cGUucGFzcyA9IGZ1bmN0aW9uKG9iamVjdCwgaW52ZXJ0KSB7XG4gIHZhciBtb2RlbCA9IHRoaXMuX2NoaWxkKCk7XG4gIG1vZGVsLl9wYXNzID0gKGludmVydCkgP1xuICAgIG5ldyBQYXNzZWQob2JqZWN0LCB0aGlzLl9wYXNzKSA6XG4gICAgbmV3IFBhc3NlZCh0aGlzLl9wYXNzLCBvYmplY3QpO1xuICByZXR1cm4gbW9kZWw7XG59O1xuXG5mdW5jdGlvbiBQYXNzZWQocHJldmlvdXMsIHZhbHVlKSB7XG4gIGZvciAodmFyIGtleSBpbiBwcmV2aW91cykge1xuICAgIHRoaXNba2V5XSA9IHByZXZpb3VzW2tleV07XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgdGhpc1trZXldID0gdmFsdWVba2V5XTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSByZXR1cm5lZCBNb2RlbCB3aWxsIG9yIHdvbid0IHRyaWdnZXIgZXZlbnQgaGFuZGxlcnMgd2hlbiB0aGUgbW9kZWwgZW1pdHNcbiAqIGV2ZW50cywgZGVwZW5kaW5nIG9uIGB2YWx1ZWBcbiAqIEBwYXJhbSB7Qm9vbGVhbnxOdWxsfSB2YWx1ZSBkZWZhdWx0cyB0byB0cnVlXG4gKiBAcmV0dXJuIHtNb2RlbH1cbiAqL1xuTW9kZWwucHJvdG90eXBlLnNpbGVudCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBtb2RlbCA9IHRoaXMuX2NoaWxkKCk7XG4gIG1vZGVsLl9zaWxlbnQgPSAodmFsdWUgPT0gbnVsbCkgPyB0cnVlIDogdmFsdWU7XG4gIHJldHVybiBtb2RlbDtcbn07XG5cbmZ1bmN0aW9uIGV2ZW50TGlzdGVuZXIobW9kZWwsIHN1YnBhdHRlcm4sIGNiKSB7XG4gIGlmIChjYikge1xuICAgIC8vIEZvciBzaWduYXR1cmVzOlxuICAgIC8vIG1vZGVsLm9uKCdjaGFuZ2UnLCAnZXhhbXBsZS5zdWJwYXRoJywgY2FsbGJhY2spXG4gICAgLy8gbW9kZWwuYXQoJ2V4YW1wbGUnKS5vbignY2hhbmdlJywgJ3N1YnBhdGgnLCBjYWxsYmFjaylcbiAgICB2YXIgcGF0dGVybiA9IG1vZGVsLnBhdGgoc3VicGF0dGVybik7XG4gICAgcmV0dXJuIG1vZGVsRXZlbnRMaXN0ZW5lcihwYXR0ZXJuLCBjYik7XG4gIH1cbiAgdmFyIHBhdGggPSBtb2RlbC5wYXRoKCk7XG4gIGNiID0gYXJndW1lbnRzWzFdO1xuICAvLyBGb3Igc2lnbmF0dXJlOlxuICAvLyBtb2RlbC5hdCgnZXhhbXBsZScpLm9uKCdjaGFuZ2UnLCBjYWxsYmFjaylcbiAgaWYgKHBhdGgpIHJldHVybiBtb2RlbEV2ZW50TGlzdGVuZXIocGF0aCwgY2IpO1xuICAvLyBGb3Igc2lnbmF0dXJlOlxuICAvLyBtb2RlbC5vbignbm9ybWFsRXZlbnQnLCBjYWxsYmFjaylcbiAgcmV0dXJuIGNiO1xufVxuXG5mdW5jdGlvbiBtb2RlbEV2ZW50TGlzdGVuZXIocGF0dGVybiwgY2IpIHtcbiAgdmFyIHBhdHRlcm5TZWdtZW50cyA9IHBhdHRlcm4uc3BsaXQoJy4nKTtcbiAgdmFyIHRlc3RGbiA9IHRlc3RQYXR0ZXJuRm4ocGF0dGVybiwgcGF0dGVyblNlZ21lbnRzKTtcblxuICBmdW5jdGlvbiBtb2RlbExpc3RlbmVyKHNlZ21lbnRzLCBldmVudEFyZ3MpIHtcbiAgICB2YXIgY2FwdHVyZXMgPSB0ZXN0Rm4oc2VnbWVudHMpO1xuICAgIGlmICghY2FwdHVyZXMpIHJldHVybjtcblxuICAgIHZhciBhcmdzID0gKGNhcHR1cmVzLmxlbmd0aCkgPyBjYXB0dXJlcy5jb25jYXQoZXZlbnRBcmdzKSA6IGV2ZW50QXJncztcbiAgICBjYi5hcHBseShudWxsLCBhcmdzKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFVzZWQgaW4gTW9kZWwjcmVtb3ZlQWxsTGlzdGVuZXJzXG4gIG1vZGVsTGlzdGVuZXIucGF0dGVybiA9IHBhdHRlcm47XG4gIG1vZGVsTGlzdGVuZXIucGF0dGVyblNlZ21lbnRzID0gcGF0dGVyblNlZ21lbnRzO1xuXG4gIHJldHVybiBtb2RlbExpc3RlbmVyO1xufVxuXG5mdW5jdGlvbiB0ZXN0UGF0dGVybkZuKHBhdHRlcm4sIHBhdHRlcm5TZWdtZW50cykge1xuICBpZiAocGF0dGVybiA9PT0gJyoqJykge1xuICAgIHJldHVybiBmdW5jdGlvbiB0ZXN0UGF0dGVybihzZWdtZW50cykge1xuICAgICAgcmV0dXJuIFtzZWdtZW50cy5qb2luKCcuJyldO1xuICAgIH07XG4gIH1cblxuICB2YXIgZW5kaW5nUmVzdCA9IHN0cmlwUmVzdFdpbGRjYXJkKHBhdHRlcm5TZWdtZW50cyk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHRlc3RQYXR0ZXJuKHNlZ21lbnRzKSB7XG4gICAgLy8gQW55IHBhdHRlcm4gd2l0aCBtb3JlIHNlZ21lbnRzIGRvZXMgbm90IG1hdGNoXG4gICAgdmFyIHBhdHRlcm5MZW4gPSBwYXR0ZXJuU2VnbWVudHMubGVuZ3RoO1xuICAgIGlmIChwYXR0ZXJuTGVuID4gc2VnbWVudHMubGVuZ3RoKSByZXR1cm47XG5cbiAgICAvLyBBIHBhdHRlcm4gd2l0aCB0aGUgc2FtZSBudW1iZXIgb2Ygc2VnbWVudHMgbWF0Y2hlcyBpZiBlYWNoXG4gICAgLy8gb2YgdGhlIHNlZ21lbnRzIGFyZSB3aWxkY2FyZHMgb3IgZXF1YWwuIEEgc2hvcnRlciBwYXR0ZXJuIG1hdGNoZXNcbiAgICAvLyBpZiBpdCBlbmRzIGluIGEgcmVzdCB3aWxkY2FyZCBhbmQgZWFjaCBvZiB0aGUgY29ycmVzcG9uZGluZ1xuICAgIC8vIHNlZ21lbnRzIGFyZSB3aWxkY2FyZHMgb3IgZXF1YWwuXG4gICAgaWYgKHBhdHRlcm5MZW4gPT09IHNlZ21lbnRzLmxlbmd0aCB8fCBlbmRpbmdSZXN0KSB7XG4gICAgICB2YXIgY2FwdHVyZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0dGVybkxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBwYXR0ZXJuU2VnbWVudCA9IHBhdHRlcm5TZWdtZW50c1tpXTtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICAgICAgaWYgKHBhdHRlcm5TZWdtZW50ID09PSAnKicgfHwgcGF0dGVyblNlZ21lbnQgPT09ICcqKicpIHtcbiAgICAgICAgICBjYXB0dXJlcy5wdXNoKHNlZ21lbnQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXR0ZXJuU2VnbWVudCAhPT0gc2VnbWVudCkgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGVuZGluZ1Jlc3QpIHtcbiAgICAgICAgdmFyIHJlbWFpbmRlciA9IHNlZ21lbnRzLnNsaWNlKGkpLmpvaW4oJy4nKTtcbiAgICAgICAgY2FwdHVyZXMucHVzaChyZW1haW5kZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhcHR1cmVzO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gc3RyaXBSZXN0V2lsZGNhcmQoc2VnbWVudHMpIHtcbiAgLy8gWydleGFtcGxlJywgJyoqJ10gLT4gWydleGFtcGxlJ107IHJldHVybiB0cnVlXG4gIHZhciBsYXN0SW5kZXggPSBzZWdtZW50cy5sZW5ndGggLSAxO1xuICBpZiAoc2VnbWVudHNbbGFzdEluZGV4XSA9PT0gJyoqJykge1xuICAgIHNlZ21lbnRzLnBvcCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIFsnZXhhbXBsZScsICdzdWJwYXRoKionXSAtPiBbJ2V4YW1wbGUnLCAnc3VicGF0aCddOyByZXR1cm4gdHJ1ZVxuICB2YXIgbWF0Y2ggPSAvXihbXlxcKl0rKVxcKlxcKiQvLmV4ZWMoc2VnbWVudHNbbGFzdEluZGV4XSk7XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWxzZTtcbiAgc2VnbWVudHNbbGFzdEluZGV4XSA9IG1hdGNoWzFdO1xuICByZXR1cm4gdHJ1ZTtcbn1cbiIsInZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcblxuZXhwb3J0cy5taXhpbiA9IHt9O1xuXG5Nb2RlbC5wcm90b3R5cGUuX3NwbGl0UGF0aCA9IGZ1bmN0aW9uKHN1YnBhdGgpIHtcbiAgdmFyIHBhdGggPSB0aGlzLnBhdGgoc3VicGF0aCk7XG4gIHJldHVybiAocGF0aCAmJiBwYXRoLnNwbGl0KCcuJykpIHx8IFtdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXRoIGVxdWl2YWxlbnQgdG8gdGhlIHBhdGggb2YgdGhlIGN1cnJlbnQgc2NvcGVkIG1vZGVsIHBsdXNcbiAqIChvcHRpb25hbGx5KSBhIHN1ZmZpeCBzdWJwYXRoXG4gKlxuICogQG9wdGlvbmFsIEBwYXJhbSB7U3RyaW5nfSBzdWJwYXRoXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGFic29sdXRlIHBhdGhcbiAqIEBhcGkgcHVibGljXG4gKi9cbk1vZGVsLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24oc3VicGF0aCkge1xuICBpZiAoc3VicGF0aCA9PSBudWxsIHx8IHN1YnBhdGggPT09ICcnKSByZXR1cm4gKHRoaXMuX2F0KSA/IHRoaXMuX2F0IDogJyc7XG4gIGlmICh0eXBlb2Ygc3VicGF0aCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHN1YnBhdGggPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuICh0aGlzLl9hdCkgPyB0aGlzLl9hdCArICcuJyArIHN1YnBhdGggOiAnJyArIHN1YnBhdGg7XG4gIH1cbiAgaWYgKHR5cGVvZiBzdWJwYXRoLnBhdGggPT09ICdmdW5jdGlvbicpIHJldHVybiBzdWJwYXRoLnBhdGgoKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5pc1BhdGggPSBmdW5jdGlvbihzdWJwYXRoKSB7XG4gIHJldHVybiB0aGlzLnBhdGgoc3VicGF0aCkgIT0gbnVsbDtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5zY29wZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIG1vZGVsID0gdGhpcy5fY2hpbGQoKTtcbiAgbW9kZWwuX2F0ID0gcGF0aDtcbiAgcmV0dXJuIG1vZGVsO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBtb2RlbCBvYmplY3Qgc2NvcGVkIHRvIGEgcGFydGljdWxhciBwYXRoLlxuICogRXhhbXBsZTpcbiAqICAgICB2YXIgdXNlciA9IG1vZGVsLmF0KCd1c2Vycy4xJyk7XG4gKiAgICAgdXNlci5zZXQoJ3VzZXJuYW1lJywgJ2JyaWFuJyk7XG4gKiAgICAgdXNlci5vbigncHVzaCcsICd0b2RvcycsIGZ1bmN0aW9uICh0b2RvKSB7XG4gKiAgICAgICAvLyAuLi5cbiAqICAgICB9KTtcbiAqXG4gKiAgQHBhcmFtIHtTdHJpbmd9IHNlZ21lbnRcbiAqICBAcmV0dXJuIHtNb2RlbH0gYSBzY29wZWQgbW9kZWxcbiAqICBAYXBpIHB1YmxpY1xuICovXG5Nb2RlbC5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbihzdWJwYXRoKSB7XG4gIHZhciBwYXRoID0gdGhpcy5wYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5zY29wZShwYXRoKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIG1vZGVsIHNjb3BlIHRoYXQgaXMgYSBudW1iZXIgb2YgbGV2ZWxzIGFib3ZlIHRoZSBjdXJyZW50IHNjb3BlZFxuICogcGF0aC4gTnVtYmVyIG9mIGxldmVscyBkZWZhdWx0cyB0byAxLCBzbyB0aGlzIG1ldGhvZCBjYWxsZWQgd2l0aG91dFxuICogYXJndW1lbnRzIHJldHVybnMgdGhlIG1vZGVsIHNjb3BlJ3MgcGFyZW50IG1vZGVsIHNjb3BlLlxuICpcbiAqIEBvcHRpb25hbCBAcGFyYW0ge051bWJlcn0gbGV2ZWxzXG4gKiBAcmV0dXJuIHtNb2RlbH0gYSBzY29wZWQgbW9kZWxcbiAqL1xuTW9kZWwucHJvdG90eXBlLnBhcmVudCA9IGZ1bmN0aW9uKGxldmVscykge1xuICBpZiAobGV2ZWxzID09IG51bGwpIGxldmVscyA9IDE7XG4gIHZhciBzZWdtZW50cyA9IHRoaXMuX3NwbGl0UGF0aCgpO1xuICB2YXIgbGVuID0gTWF0aC5tYXgoMCwgc2VnbWVudHMubGVuZ3RoIC0gbGV2ZWxzKTtcbiAgdmFyIHBhdGggPSBzZWdtZW50cy5zbGljZSgwLCBsZW4pLmpvaW4oJy4nKTtcbiAgcmV0dXJuIHRoaXMuc2NvcGUocGF0aCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGxhc3QgcHJvcGVydHkgc2VnbWVudCBvZiB0aGUgY3VycmVudCBtb2RlbCBzY29wZSBwYXRoXG4gKlxuICogQG9wdGlvbmFsIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbk1vZGVsLnByb3RvdHlwZS5sZWFmID0gZnVuY3Rpb24ocGF0aCkge1xuICBpZiAoIXBhdGgpIHBhdGggPSB0aGlzLnBhdGgoKTtcbiAgdmFyIGkgPSBwYXRoLmxhc3RJbmRleE9mKCcuJyk7XG4gIHJldHVybiBwYXRoLnNsaWNlKGkgKyAxKTtcbn07XG4iLCJ2YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyk7XG52YXIgTG9jYWxEb2MgPSByZXF1aXJlKCcuL0xvY2FsRG9jJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxuZnVuY3Rpb24gQ29sbGVjdGlvbk1hcCgpIHt9XG5mdW5jdGlvbiBNb2RlbERhdGEoKSB7fVxuZnVuY3Rpb24gRG9jTWFwKCkge31cbmZ1bmN0aW9uIENvbGxlY3Rpb25EYXRhKCkge31cblxuTW9kZWwuSU5JVFMucHVzaChmdW5jdGlvbihtb2RlbCkge1xuICBtb2RlbC5yb290LmNvbGxlY3Rpb25zID0gbmV3IENvbGxlY3Rpb25NYXA7XG4gIG1vZGVsLnJvb3QuZGF0YSA9IG5ldyBNb2RlbERhdGE7XG59KTtcblxuTW9kZWwucHJvdG90eXBlLmdldENvbGxlY3Rpb24gPSBmdW5jdGlvbihjb2xsZWN0aW9uTmFtZSkge1xuICByZXR1cm4gdGhpcy5yb290LmNvbGxlY3Rpb25zW2NvbGxlY3Rpb25OYW1lXTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuZ2V0RG9jID0gZnVuY3Rpb24oY29sbGVjdGlvbk5hbWUsIGlkKSB7XG4gIHZhciBjb2xsZWN0aW9uID0gdGhpcy5yb290LmNvbGxlY3Rpb25zW2NvbGxlY3Rpb25OYW1lXTtcbiAgcmV0dXJuIGNvbGxlY3Rpb24gJiYgY29sbGVjdGlvbi5kb2NzW2lkXTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oc3VicGF0aCkge1xuICB2YXIgc2VnbWVudHMgPSB0aGlzLl9zcGxpdFBhdGgoc3VicGF0aCk7XG4gIHJldHVybiB0aGlzLl9nZXQoc2VnbWVudHMpO1xufTtcbk1vZGVsLnByb3RvdHlwZS5fZ2V0ID0gZnVuY3Rpb24oc2VnbWVudHMpIHtcbiAgcmV0dXJuIHV0aWwubG9va3VwKHNlZ21lbnRzLCB0aGlzLnJvb3QuZGF0YSk7XG59O1xuTW9kZWwucHJvdG90eXBlLmdldE9yQ3JlYXRlQ29sbGVjdGlvbiA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLnJvb3QuY29sbGVjdGlvbnNbbmFtZV07XG4gIGlmIChjb2xsZWN0aW9uKSByZXR1cm4gY29sbGVjdGlvbjtcbiAgdmFyIERvYyA9IHRoaXMuX2dldERvY0NvbnN0cnVjdG9yKG5hbWUpO1xuICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24odGhpcy5yb290LCBuYW1lLCBEb2MpO1xuICB0aGlzLnJvb3QuY29sbGVjdGlvbnNbbmFtZV0gPSBjb2xsZWN0aW9uO1xuICByZXR1cm4gY29sbGVjdGlvbjtcbn07XG5Nb2RlbC5wcm90b3R5cGUuX2dldERvY0NvbnN0cnVjdG9yID0gZnVuY3Rpb24oKSB7XG4gIC8vIE9ubHkgY3JlYXRlIGxvY2FsIGRvY3VtZW50cy4gVGhpcyBpcyBvdmVycmlkZW4gaW4gLi9jb25uZWN0aW9uLmpzLCBzbyB0aGF0XG4gIC8vIHRoZSBSZW1vdGVEb2MgYmVoYXZpb3IgY2FuIGJlIHNlbGVjdGl2ZWx5IGluY2x1ZGVkXG4gIHJldHVybiBMb2NhbERvYztcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBleGlzdGluZyBkb2N1bWVudCB3aXRoIGlkIGluIGEgY29sbGVjdGlvbi4gSWYgdGhlIGRvY3VtZW50IGRvZXNcbiAqIG5vdCBleGlzdCwgdGhlbiBjcmVhdGVzIHRoZSBkb2N1bWVudCB3aXRoIGlkIGluIGEgY29sbGVjdGlvbiBhbmQgcmV0dXJucyB0aGVcbiAqIG5ldyBkb2N1bWVudC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2xsZWN0aW9uTmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdIGRhdGEgdG8gY3JlYXRlIGlmIGRvYyB3aXRoIGlkIGRvZXMgbm90IGV4aXN0IGluIGNvbGxlY3Rpb25cbiAqL1xuTW9kZWwucHJvdG90eXBlLmdldE9yQ3JlYXRlRG9jID0gZnVuY3Rpb24oY29sbGVjdGlvbk5hbWUsIGlkLCBkYXRhKSB7XG4gIHZhciBjb2xsZWN0aW9uID0gdGhpcy5nZXRPckNyZWF0ZUNvbGxlY3Rpb24oY29sbGVjdGlvbk5hbWUpO1xuICByZXR1cm4gY29sbGVjdGlvbi5kb2NzW2lkXSB8fCBjb2xsZWN0aW9uLmFkZChpZCwgZGF0YSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2xsZWN0aW9uTmFtZVxuICovXG5Nb2RlbC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb25OYW1lKSB7XG4gIC8vIFRPRE86IG5vbi1jb2xsZWN0aW9uc1xuICB2YXIgY29sbGVjdGlvbiA9IHRoaXMuZ2V0Q29sbGVjdGlvbihjb2xsZWN0aW9uTmFtZSk7XG4gIGNvbGxlY3Rpb24gJiYgY29sbGVjdGlvbi5kZXN0cm95KCk7XG4gIHRoaXMucmVtb3ZlQWxsUmVmcyhjb2xsZWN0aW9uTmFtZSk7XG4gIHRoaXMuc3RvcEFsbChjb2xsZWN0aW9uTmFtZSk7XG4gIHRoaXMucmVtb3ZlQWxsRmlsdGVycyhjb2xsZWN0aW9uTmFtZSk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKG51bGwsIGNvbGxlY3Rpb25OYW1lKTtcbn07XG5cbmZ1bmN0aW9uIENvbGxlY3Rpb24obW9kZWwsIG5hbWUsIERvYykge1xuICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gIHRoaXMubmFtZSA9IG5hbWU7XG4gIHRoaXMuRG9jID0gRG9jO1xuICB0aGlzLmRvY3MgPSBuZXcgRG9jTWFwKCk7XG4gIHRoaXMuZGF0YSA9IG1vZGVsLmRhdGFbbmFtZV0gPSBuZXcgQ29sbGVjdGlvbkRhdGEoKTtcbn1cblxuLyoqXG4gKiBBZGRzIGEgZG9jdW1lbnQgd2l0aCBgaWRgIGFuZCBgZGF0YWAgdG8gYHRoaXNgIENvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcmV0dXJuIHtMb2NhbERvY3xSZW1vdGVEb2N9IGRvY1xuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihpZCwgZGF0YSkge1xuICB2YXIgZG9jID0gbmV3IHRoaXMuRG9jKHRoaXMubW9kZWwsIHRoaXMubmFtZSwgaWQsIGRhdGEpO1xuICB0aGlzLmRvY3NbaWRdID0gZG9jO1xuICByZXR1cm4gZG9jO1xufTtcbkNvbGxlY3Rpb24ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgZGVsZXRlIHRoaXMubW9kZWwuY29sbGVjdGlvbnNbdGhpcy5uYW1lXTtcbiAgZGVsZXRlIHRoaXMubW9kZWwuZGF0YVt0aGlzLm5hbWVdO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBkb2N1bWVudCB3aXRoIGBpZGAgZnJvbSBgdGhpc2AgQ29sbGVjdGlvbi4gSWYgdGhlcmUgYXJlIG5vIG1vcmVcbiAqIGRvY3VtZW50cyBpbiB0aGUgQ29sbGVjdGlvbiBhZnRlciB0aGUgZ2l2ZW4gZG9jdW1lbnQgaXMgcmVtb3ZlZCwgdGhlbiB0aGlzXG4gKiBhbHNvIGRlc3Ryb3lzIHRoZSBDb2xsZWN0aW9uLlxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKi9cbkNvbGxlY3Rpb24ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGlkKSB7XG4gIGRlbGV0ZSB0aGlzLmRvY3NbaWRdO1xuICBkZWxldGUgdGhpcy5kYXRhW2lkXTtcbiAgaWYgKG5vS2V5cyh0aGlzLmRvY3MpKSB0aGlzLmRlc3Ryb3koKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBtYXBzIGRvYyBpZHMgdG8gZnVsbHkgcmVzb2x2ZWQgZG9jdW1lbnRzLlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YTtcbn07XG5cbmZ1bmN0aW9uIG5vS2V5cyhvYmplY3QpIHtcbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xuXG5Nb2RlbC5wcm90b3R5cGUuX211dGF0ZSA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBmbiwgY2IpIHtcbiAgaWYgKCFjYikgY2IgPSB0aGlzLnJvb3QuX2RlZmF1bHRDYWxsYmFjaztcbiAgdmFyIGNvbGxlY3Rpb25OYW1lID0gc2VnbWVudHNbMF07XG4gIHZhciBpZCA9IHNlZ21lbnRzWzFdO1xuICBpZiAoIWNvbGxlY3Rpb25OYW1lIHx8ICFpZCkge1xuICAgIHZhciBtZXNzYWdlID0gZm4ubmFtZSArICcgbXVzdCBiZSBwZXJmb3JtZWQgdW5kZXIgYSBjb2xsZWN0aW9uICcgK1xuICAgICAgJ2FuZCBkb2N1bWVudCBpZC4gSW52YWxpZCBwYXRoOiAnICsgc2VnbWVudHMuam9pbignLicpO1xuICAgIHJldHVybiBjYihuZXcgRXJyb3IobWVzc2FnZSkpO1xuICB9XG4gIHZhciBkb2MgPSB0aGlzLmdldE9yQ3JlYXRlRG9jKGNvbGxlY3Rpb25OYW1lLCBpZCk7XG4gIHZhciBkb2NTZWdtZW50cyA9IHNlZ21lbnRzLnNsaWNlKDIpO1xuICByZXR1cm4gZm4oZG9jLCBkb2NTZWdtZW50cywgY2IpO1xufTtcblxuTW9kZWwucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3VicGF0aCwgdmFsdWUsIGNiO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzFdO1xuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgdmFsdWUgPSBhcmd1bWVudHNbMV07XG4gICAgY2IgPSBhcmd1bWVudHNbMl07XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fc2V0KHNlZ21lbnRzLCB2YWx1ZSwgY2IpO1xufTtcbk1vZGVsLnByb3RvdHlwZS5fc2V0ID0gZnVuY3Rpb24oc2VnbWVudHMsIHZhbHVlLCBjYikge1xuICBzZWdtZW50cyA9IHRoaXMuX2RlcmVmZXJlbmNlKHNlZ21lbnRzKTtcbiAgdmFyIG1vZGVsID0gdGhpcztcbiAgZnVuY3Rpb24gc2V0KGRvYywgZG9jU2VnbWVudHMsIGZuQ2IpIHtcbiAgICB2YXIgcHJldmlvdXMgPSBkb2Muc2V0KGRvY1NlZ21lbnRzLCB2YWx1ZSwgZm5DYik7XG4gICAgbW9kZWwuZW1pdCgnY2hhbmdlJywgc2VnbWVudHMsIFt2YWx1ZSwgcHJldmlvdXMsIG1vZGVsLl9wYXNzXSk7XG4gICAgcmV0dXJuIHByZXZpb3VzO1xuICB9XG4gIHJldHVybiB0aGlzLl9tdXRhdGUoc2VnbWVudHMsIHNldCwgY2IpO1xufTtcblxuTW9kZWwucHJvdG90eXBlLnNldEVhY2ggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN1YnBhdGgsIG9iamVjdCwgY2I7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgb2JqZWN0ID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIG9iamVjdCA9IGFyZ3VtZW50c1sxXTtcbiAgfSBlbHNlIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIG9iamVjdCA9IGFyZ3VtZW50c1sxXTtcbiAgICBjYiA9IGFyZ3VtZW50c1syXTtcbiAgfVxuICB2YXIgc2VnbWVudHMgPSB0aGlzLl9zcGxpdFBhdGgoc3VicGF0aCk7XG4gIHJldHVybiB0aGlzLl9zZXRFYWNoKHNlZ21lbnRzLCBvYmplY3QsIGNiKTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuX3NldEVhY2ggPSBmdW5jdGlvbihzZWdtZW50cywgb2JqZWN0LCBjYikge1xuICBzZWdtZW50cyA9IHRoaXMuX2RlcmVmZXJlbmNlKHNlZ21lbnRzKTtcbiAgdmFyIGdyb3VwID0gdXRpbC5hc3luY0dyb3VwKGNiIHx8IHRoaXMucm9vdC5fZGVmYXVsdENhbGxiYWNrKTtcbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgIHRoaXMuX3NldChzZWdtZW50cy5jb25jYXQoa2V5KSwgdmFsdWUsIGdyb3VwKCkpO1xuICB9XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWJwYXRoLCB2YWx1ZSwgY2I7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFsdWUgPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGNiID0gYXJndW1lbnRzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFsdWUgPSBhcmd1bWVudHNbMV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgdmFsdWUgPSBhcmd1bWVudHNbMV07XG4gICAgY2IgPSBhcmd1bWVudHNbMl07XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fYWRkKHNlZ21lbnRzLCB2YWx1ZSwgY2IpO1xufTtcbk1vZGVsLnByb3RvdHlwZS5fYWRkID0gZnVuY3Rpb24oc2VnbWVudHMsIHZhbHVlLCBjYikge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHZhciBtZXNzYWdlID0gJ2FkZCByZXF1aXJlcyBhbiBvYmplY3QgdmFsdWUuIEludmFsaWQgdmFsdWU6ICcgKyB2YWx1ZTtcbiAgICBjYiB8fCAoY2IgPSB0aGlzLnJvb3QuX2RlZmF1bHRDYWxsYmFjayk7XG4gICAgcmV0dXJuIGNiKG5ldyBFcnJvcihtZXNzYWdlKSk7XG4gIH1cbiAgdmFyIGlkID0gdmFsdWUuaWQgfHwgdGhpcy5pZCgpO1xuICB2YWx1ZS5pZCA9IGlkO1xuICB0aGlzLl9zZXQoc2VnbWVudHMuY29uY2F0KGlkKSwgdmFsdWUsIGNiKTtcbiAgcmV0dXJuIGlkO1xufTtcblxuTW9kZWwucHJvdG90eXBlLnNldE51bGwgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN1YnBhdGgsIHZhbHVlLCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YWx1ZSA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YWx1ZSA9IGFyZ3VtZW50c1sxXTtcbiAgfSBlbHNlIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzFdO1xuICAgIGNiID0gYXJndW1lbnRzWzJdO1xuICB9XG4gIHZhciBzZWdtZW50cyA9IHRoaXMuX3NwbGl0UGF0aChzdWJwYXRoKTtcbiAgcmV0dXJuIHRoaXMuX3NldE51bGwoc2VnbWVudHMsIHZhbHVlLCBjYik7XG59O1xuTW9kZWwucHJvdG90eXBlLl9zZXROdWxsID0gZnVuY3Rpb24oc2VnbWVudHMsIHZhbHVlLCBjYikge1xuICBzZWdtZW50cyA9IHRoaXMuX2RlcmVmZXJlbmNlKHNlZ21lbnRzKTtcbiAgdmFyIG1vZGVsID0gdGhpcztcbiAgZnVuY3Rpb24gc2V0TnVsbChkb2MsIGRvY1NlZ21lbnRzLCBmbkNiKSB7XG4gICAgdmFyIHByZXZpb3VzID0gZG9jLmdldChkb2NTZWdtZW50cyk7XG4gICAgaWYgKHByZXZpb3VzICE9IG51bGwpIHtcbiAgICAgIGZuQ2IoKTtcbiAgICAgIHJldHVybiBwcmV2aW91cztcbiAgICB9XG4gICAgZG9jLnNldChkb2NTZWdtZW50cywgdmFsdWUsIGZuQ2IpO1xuICAgIG1vZGVsLmVtaXQoJ2NoYW5nZScsIHNlZ21lbnRzLCBbdmFsdWUsIHByZXZpb3VzLCBtb2RlbC5fcGFzc10pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcy5fbXV0YXRlKHNlZ21lbnRzLCBzZXROdWxsLCBjYik7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWJwYXRoLCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgY2IgPSBhcmd1bWVudHNbMV07XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fZGVsKHNlZ21lbnRzLCBjYik7XG59O1xuTW9kZWwucHJvdG90eXBlLl9kZWwgPSBmdW5jdGlvbihzZWdtZW50cywgY2IpIHtcbiAgc2VnbWVudHMgPSB0aGlzLl9kZXJlZmVyZW5jZShzZWdtZW50cyk7XG4gIHZhciBtb2RlbCA9IHRoaXM7XG4gIGZ1bmN0aW9uIGRlbChkb2MsIGRvY1NlZ21lbnRzLCBmbkNiKSB7XG4gICAgdmFyIHByZXZpb3VzID0gZG9jLmRlbChkb2NTZWdtZW50cywgZm5DYik7XG4gICAgLy8gV2hlbiBkZWxldGluZyBhbiBlbnRpcmUgZG9jdW1lbnQsIGFsc28gcmVtb3ZlIHRoZSByZWZlcmVuY2UgdG8gdGhlXG4gICAgLy8gZG9jdW1lbnQgb2JqZWN0IGZyb20gaXRzIGNvbGxlY3Rpb25cbiAgICBpZiAoc2VnbWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgY29sbGVjdGlvbk5hbWUgPSBzZWdtZW50c1swXTtcbiAgICAgIHZhciBpZCA9IHNlZ21lbnRzWzFdO1xuICAgICAgbW9kZWwucm9vdC5jb2xsZWN0aW9uc1tjb2xsZWN0aW9uTmFtZV0ucmVtb3ZlKGlkKTtcbiAgICB9XG4gICAgbW9kZWwuZW1pdCgnY2hhbmdlJywgc2VnbWVudHMsIFt2b2lkIDAsIHByZXZpb3VzLCBtb2RlbC5fcGFzc10pO1xuICAgIHJldHVybiBwcmV2aW91cztcbiAgfVxuICByZXR1cm4gdGhpcy5fbXV0YXRlKHNlZ21lbnRzLCBkZWwsIGNiKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5pbmNyZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN1YnBhdGgsIGJ5TnVtYmVyLCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgYnlOdW1iZXIgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgYnlOdW1iZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgICAgYnlOdW1iZXIgPSBhcmd1bWVudHNbMV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgYnlOdW1iZXIgPSBhcmd1bWVudHNbMV07XG4gICAgY2IgPSBhcmd1bWVudHNbMl07XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5faW5jcmVtZW50KHNlZ21lbnRzLCBieU51bWJlciwgY2IpO1xufTtcbk1vZGVsLnByb3RvdHlwZS5faW5jcmVtZW50ID0gZnVuY3Rpb24oc2VnbWVudHMsIGJ5TnVtYmVyLCBjYikge1xuICBzZWdtZW50cyA9IHRoaXMuX2RlcmVmZXJlbmNlKHNlZ21lbnRzKTtcbiAgaWYgKGJ5TnVtYmVyID09IG51bGwpIGJ5TnVtYmVyID0gMTtcbiAgdmFyIG1vZGVsID0gdGhpcztcbiAgZnVuY3Rpb24gaW5jcmVtZW50KGRvYywgZG9jU2VnbWVudHMsIGZuQ2IpIHtcbiAgICB2YXIgdmFsdWUgPSBkb2MuaW5jcmVtZW50KGRvY1NlZ21lbnRzLCBieU51bWJlciwgZm5DYik7XG4gICAgdmFyIHByZXZpb3VzID0gdmFsdWUgLSBieU51bWJlcjtcbiAgICBtb2RlbC5lbWl0KCdjaGFuZ2UnLCBzZWdtZW50cywgW3ZhbHVlLCBwcmV2aW91cywgbW9kZWwuX3Bhc3NdKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX211dGF0ZShzZWdtZW50cywgaW5jcmVtZW50LCBjYik7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3VicGF0aCwgdmFsdWUsIGNiO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzFdO1xuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgdmFsdWUgPSBhcmd1bWVudHNbMV07XG4gICAgY2IgPSBhcmd1bWVudHNbMl07XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fcHVzaChzZWdtZW50cywgdmFsdWUsIGNiKTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuX3B1c2ggPSBmdW5jdGlvbihzZWdtZW50cywgdmFsdWUsIGNiKSB7XG4gIHZhciBmb3JBcnJheU11dGF0b3IgPSB0cnVlO1xuICBzZWdtZW50cyA9IHRoaXMuX2RlcmVmZXJlbmNlKHNlZ21lbnRzLCBmb3JBcnJheU11dGF0b3IpO1xuICB2YXIgbW9kZWwgPSB0aGlzO1xuICBmdW5jdGlvbiBwdXNoKGRvYywgZG9jU2VnbWVudHMsIGZuQ2IpIHtcbiAgICB2YXIgbGVuZ3RoID0gZG9jLnB1c2goZG9jU2VnbWVudHMsIHZhbHVlLCBmbkNiKTtcbiAgICBtb2RlbC5lbWl0KCdpbnNlcnQnLCBzZWdtZW50cywgW2xlbmd0aCAtIDEsIFt2YWx1ZV0sIG1vZGVsLl9wYXNzXSk7XG4gICAgcmV0dXJuIGxlbmd0aDtcbiAgfVxuICByZXR1cm4gdGhpcy5fbXV0YXRlKHNlZ21lbnRzLCBwdXNoLCBjYik7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3VicGF0aCwgdmFsdWUsIGNiO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzFdO1xuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgdmFsdWUgPSBhcmd1bWVudHNbMV07XG4gICAgY2IgPSBhcmd1bWVudHNbMl07XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fdW5zaGlmdChzZWdtZW50cywgdmFsdWUsIGNiKTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuX3Vuc2hpZnQgPSBmdW5jdGlvbihzZWdtZW50cywgdmFsdWUsIGNiKSB7XG4gIHZhciBmb3JBcnJheU11dGF0b3IgPSB0cnVlO1xuICBzZWdtZW50cyA9IHRoaXMuX2RlcmVmZXJlbmNlKHNlZ21lbnRzLCBmb3JBcnJheU11dGF0b3IpO1xuICB2YXIgbW9kZWwgPSB0aGlzO1xuICBmdW5jdGlvbiB1bnNoaWZ0KGRvYywgZG9jU2VnbWVudHMsIGZuQ2IpIHtcbiAgICB2YXIgbGVuZ3RoID0gZG9jLnVuc2hpZnQoZG9jU2VnbWVudHMsIHZhbHVlLCBmbkNiKTtcbiAgICBtb2RlbC5lbWl0KCdpbnNlcnQnLCBzZWdtZW50cywgWzAsIFt2YWx1ZV0sIG1vZGVsLl9wYXNzXSk7XG4gICAgcmV0dXJuIGxlbmd0aDtcbiAgfVxuICByZXR1cm4gdGhpcy5fbXV0YXRlKHNlZ21lbnRzLCB1bnNoaWZ0LCBjYik7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWJwYXRoLCBpbmRleCwgdmFsdWVzLCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdOb3QgZW5vdWdoIGFyZ3VtZW50cyBmb3IgaW5zZXJ0JykpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBpbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YWx1ZXMgPSBhcmd1bWVudHNbMV07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgaW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgdmFsdWVzID0gYXJndW1lbnRzWzJdO1xuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgaW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgdmFsdWVzID0gYXJndW1lbnRzWzJdO1xuICAgIGNiID0gYXJndW1lbnRzWzNdO1xuICB9XG4gIHZhciBzZWdtZW50cyA9IHRoaXMuX3NwbGl0UGF0aChzdWJwYXRoKTtcbiAgcmV0dXJuIHRoaXMuX2luc2VydChzZWdtZW50cywgK2luZGV4LCB2YWx1ZXMsIGNiKTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuX2luc2VydCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBpbmRleCwgdmFsdWVzLCBjYikge1xuICB2YXIgZm9yQXJyYXlNdXRhdG9yID0gdHJ1ZTtcbiAgc2VnbWVudHMgPSB0aGlzLl9kZXJlZmVyZW5jZShzZWdtZW50cywgZm9yQXJyYXlNdXRhdG9yKTtcbiAgdmFyIG1vZGVsID0gdGhpcztcbiAgZnVuY3Rpb24gaW5zZXJ0KGRvYywgZG9jU2VnbWVudHMsIGZuQ2IpIHtcbiAgICB2YXIgaW5zZXJ0ZWQgPSAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSA/IHZhbHVlcyA6IFt2YWx1ZXNdO1xuICAgIHZhciBsZW5ndGggPSBkb2MuaW5zZXJ0KGRvY1NlZ21lbnRzLCBpbmRleCwgaW5zZXJ0ZWQsIGZuQ2IpO1xuICAgIG1vZGVsLmVtaXQoJ2luc2VydCcsIHNlZ21lbnRzLCBbaW5kZXgsIGluc2VydGVkLCBtb2RlbC5fcGFzc10pO1xuICAgIHJldHVybiBsZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX211dGF0ZShzZWdtZW50cywgaW5zZXJ0LCBjYik7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWJwYXRoLCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgY2IgPSBhcmd1bWVudHNbMV07XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fcG9wKHNlZ21lbnRzLCBjYik7XG59O1xuTW9kZWwucHJvdG90eXBlLl9wb3AgPSBmdW5jdGlvbihzZWdtZW50cywgY2IpIHtcbiAgdmFyIGZvckFycmF5TXV0YXRvciA9IHRydWU7XG4gIHNlZ21lbnRzID0gdGhpcy5fZGVyZWZlcmVuY2Uoc2VnbWVudHMsIGZvckFycmF5TXV0YXRvcik7XG4gIHZhciBtb2RlbCA9IHRoaXM7XG4gIGZ1bmN0aW9uIHBvcChkb2MsIGRvY1NlZ21lbnRzLCBmbkNiKSB7XG4gICAgdmFyIGFyciA9IGRvYy5nZXQoZG9jU2VnbWVudHMpO1xuICAgIHZhciBsZW5ndGggPSBhcnIgJiYgYXJyLmxlbmd0aDtcbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgZm5DYigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBkb2MucG9wKGRvY1NlZ21lbnRzLCBmbkNiKTtcbiAgICBtb2RlbC5lbWl0KCdyZW1vdmUnLCBzZWdtZW50cywgW2xlbmd0aCAtIDEsIFt2YWx1ZV0sIG1vZGVsLl9wYXNzXSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzLl9tdXRhdGUoc2VnbWVudHMsIHBvcCwgY2IpO1xufTtcblxuTW9kZWwucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWJwYXRoLCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgY2IgPSBhcmd1bWVudHNbMV07XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fc2hpZnQoc2VnbWVudHMsIGNiKTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuX3NoaWZ0ID0gZnVuY3Rpb24oc2VnbWVudHMsIGNiKSB7XG4gIHZhciBmb3JBcnJheU11dGF0b3IgPSB0cnVlO1xuICBzZWdtZW50cyA9IHRoaXMuX2RlcmVmZXJlbmNlKHNlZ21lbnRzLCBmb3JBcnJheU11dGF0b3IpO1xuICB2YXIgbW9kZWwgPSB0aGlzO1xuICBmdW5jdGlvbiBzaGlmdChkb2MsIGRvY1NlZ21lbnRzLCBmbkNiKSB7XG4gICAgdmFyIGFyciA9IGRvYy5nZXQoZG9jU2VnbWVudHMpO1xuICAgIHZhciBsZW5ndGggPSBhcnIgJiYgYXJyLmxlbmd0aDtcbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgZm5DYigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBkb2Muc2hpZnQoZG9jU2VnbWVudHMsIGZuQ2IpO1xuICAgIG1vZGVsLmVtaXQoJ3JlbW92ZScsIHNlZ21lbnRzLCBbMCwgW3ZhbHVlXSwgbW9kZWwuX3Bhc3NdKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX211dGF0ZShzZWdtZW50cywgc2hpZnQsIGNiKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN1YnBhdGgsIGluZGV4LCBob3dNYW55LCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGluZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGluZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICBob3dNYW55ID0gYXJndW1lbnRzWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgaW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBhcmd1bWVudHNbMl07XG4gICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgICAgIGhvd01hbnkgPSBhcmd1bWVudHNbMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgICAgICBpbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGluZGV4ID0gYXJndW1lbnRzWzFdO1xuICAgICAgaG93TWFueSA9IGFyZ3VtZW50c1syXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICBpbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgICBob3dNYW55ID0gYXJndW1lbnRzWzJdO1xuICAgIGNiID0gYXJndW1lbnRzWzNdO1xuICB9XG4gIHZhciBzZWdtZW50cyA9IHRoaXMuX3NwbGl0UGF0aChzdWJwYXRoKTtcbiAgaWYgKGluZGV4ID09IG51bGwpIGluZGV4ID0gc2VnbWVudHMucG9wKCk7XG4gIHJldHVybiB0aGlzLl9yZW1vdmUoc2VnbWVudHMsICtpbmRleCwgaG93TWFueSwgY2IpO1xufTtcbk1vZGVsLnByb3RvdHlwZS5fcmVtb3ZlID0gZnVuY3Rpb24oc2VnbWVudHMsIGluZGV4LCBob3dNYW55LCBjYikge1xuICB2YXIgZm9yQXJyYXlNdXRhdG9yID0gdHJ1ZTtcbiAgc2VnbWVudHMgPSB0aGlzLl9kZXJlZmVyZW5jZShzZWdtZW50cywgZm9yQXJyYXlNdXRhdG9yKTtcbiAgaWYgKGhvd01hbnkgPT0gbnVsbCkgaG93TWFueSA9IDE7XG4gIHZhciBtb2RlbCA9IHRoaXM7XG4gIGZ1bmN0aW9uIHJlbW92ZShkb2MsIGRvY1NlZ21lbnRzLCBmbkNiKSB7XG4gICAgdmFyIHJlbW92ZWQgPSBkb2MucmVtb3ZlKGRvY1NlZ21lbnRzLCBpbmRleCwgaG93TWFueSwgZm5DYik7XG4gICAgbW9kZWwuZW1pdCgncmVtb3ZlJywgc2VnbWVudHMsIFtpbmRleCwgcmVtb3ZlZCwgbW9kZWwuX3Bhc3NdKTtcbiAgICByZXR1cm4gcmVtb3ZlZDtcbiAgfVxuICByZXR1cm4gdGhpcy5fbXV0YXRlKHNlZ21lbnRzLCByZW1vdmUsIGNiKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWJwYXRoLCBmcm9tLCB0bywgaG93TWFueSwgY2I7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignTm90IGVub3VnaCBhcmd1bWVudHMgZm9yIG1vdmUnKSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIGZyb20gPSBhcmd1bWVudHNbMF07XG4gICAgdG8gPSBhcmd1bWVudHNbMV07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmcm9tID0gYXJndW1lbnRzWzBdO1xuICAgICAgdG8gPSBhcmd1bWVudHNbMV07XG4gICAgICBjYiA9IGFyZ3VtZW50c1syXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICBmcm9tID0gYXJndW1lbnRzWzBdO1xuICAgICAgdG8gPSBhcmd1bWVudHNbMV07XG4gICAgICBob3dNYW55ID0gYXJndW1lbnRzWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgICAgZnJvbSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHRvID0gYXJndW1lbnRzWzJdO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gYXJndW1lbnRzWzNdO1xuICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGZyb20gPSBhcmd1bWVudHNbMF07XG4gICAgICAgIHRvID0gYXJndW1lbnRzWzFdO1xuICAgICAgICBob3dNYW55ID0gYXJndW1lbnRzWzJdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgZnJvbSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdG8gPSBhcmd1bWVudHNbMl07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgICBmcm9tID0gYXJndW1lbnRzWzFdO1xuICAgICAgdG8gPSBhcmd1bWVudHNbMl07XG4gICAgICBob3dNYW55ID0gYXJndW1lbnRzWzNdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIGZyb20gPSBhcmd1bWVudHNbMV07XG4gICAgdG8gPSBhcmd1bWVudHNbMl07XG4gICAgaG93TWFueSA9IGFyZ3VtZW50c1szXTtcbiAgICBjYiA9IGFyZ3VtZW50c1s0XTtcbiAgfVxuICB2YXIgc2VnbWVudHMgPSB0aGlzLl9zcGxpdFBhdGgoc3VicGF0aCk7XG4gIHJldHVybiB0aGlzLl9tb3ZlKHNlZ21lbnRzLCBmcm9tLCB0bywgaG93TWFueSwgY2IpO1xufTtcbk1vZGVsLnByb3RvdHlwZS5fbW92ZSA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBmcm9tLCB0bywgaG93TWFueSwgY2IpIHtcbiAgdmFyIGZvckFycmF5TXV0YXRvciA9IHRydWU7XG4gIHNlZ21lbnRzID0gdGhpcy5fZGVyZWZlcmVuY2Uoc2VnbWVudHMsIGZvckFycmF5TXV0YXRvcik7XG4gIGlmIChob3dNYW55ID09IG51bGwpIGhvd01hbnkgPSAxO1xuICB2YXIgbW9kZWwgPSB0aGlzO1xuICBmdW5jdGlvbiBtb3ZlKGRvYywgZG9jU2VnbWVudHMsIGZuQ2IpIHtcbiAgICAvLyBDYXN0IHRvIG51bWJlcnNcbiAgICBmcm9tID0gK2Zyb207XG4gICAgdG8gPSArdG87XG4gICAgLy8gQ29udmVydCBuZWdhdGl2ZSBpbmRpY2VzIGludG8gcG9zaXRpdmVcbiAgICBpZiAoZnJvbSA8IDAgfHwgdG8gPCAwKSB7XG4gICAgICB2YXIgbGVuID0gZG9jLmdldChkb2NTZWdtZW50cykubGVuZ3RoO1xuICAgICAgaWYgKGZyb20gPCAwKSBmcm9tICs9IGxlbjtcbiAgICAgIGlmICh0byA8IDApIHRvICs9IGxlbjtcbiAgICB9XG4gICAgdmFyIG1vdmVkID0gZG9jLm1vdmUoZG9jU2VnbWVudHMsIGZyb20sIHRvLCBob3dNYW55LCBmbkNiKTtcbiAgICBtb2RlbC5lbWl0KCdtb3ZlJywgc2VnbWVudHMsIFtmcm9tLCB0bywgbW92ZWQubGVuZ3RoLCBtb2RlbC5fcGFzc10pO1xuICAgIHJldHVybiBtb3ZlZDtcbiAgfVxuICByZXR1cm4gdGhpcy5fbXV0YXRlKHNlZ21lbnRzLCBtb3ZlLCBjYik7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuc3RyaW5nSW5zZXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWJwYXRoLCBpbmRleCwgdGV4dCwgY2I7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignTm90IGVub3VnaCBhcmd1bWVudHMgZm9yIHN0cmluZ0luc2VydCcpKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgaW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgdGV4dCA9IGFyZ3VtZW50c1sxXTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGV4dCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGNiID0gYXJndW1lbnRzWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgICAgaW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgICB0ZXh0ID0gYXJndW1lbnRzWzJdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIGluZGV4ID0gYXJndW1lbnRzWzFdO1xuICAgIHRleHQgPSBhcmd1bWVudHNbMl07XG4gICAgY2IgPSBhcmd1bWVudHNbM107XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fc3RyaW5nSW5zZXJ0KHNlZ21lbnRzLCBpbmRleCwgdGV4dCwgY2IpO1xufTtcbk1vZGVsLnByb3RvdHlwZS5fc3RyaW5nSW5zZXJ0ID0gZnVuY3Rpb24oc2VnbWVudHMsIGluZGV4LCB0ZXh0LCBjYikge1xuICBzZWdtZW50cyA9IHRoaXMuX2RlcmVmZXJlbmNlKHNlZ21lbnRzKTtcbiAgdmFyIG1vZGVsID0gdGhpcztcbiAgZnVuY3Rpb24gc3RyaW5nSW5zZXJ0KGRvYywgZG9jU2VnbWVudHMsIGZuQ2IpIHtcbiAgICB2YXIgcHJldmlvdXMgPSBkb2Muc3RyaW5nSW5zZXJ0KGRvY1NlZ21lbnRzLCBpbmRleCwgdGV4dCwgZm5DYik7XG4gICAgbW9kZWwuZW1pdCgnc3RyaW5nSW5zZXJ0Jywgc2VnbWVudHMsIFtpbmRleCwgdGV4dCwgbW9kZWwuX3Bhc3NdKTtcbiAgICB2YXIgdmFsdWUgPSBkb2MuZ2V0KGRvY1NlZ21lbnRzKTtcbiAgICB2YXIgcGFzcyA9IG1vZGVsLnBhc3MoeyRvcmlnaW5hbDogJ3N0cmluZ0luc2VydCd9KS5fcGFzcztcbiAgICBtb2RlbC5lbWl0KCdjaGFuZ2UnLCBzZWdtZW50cywgW3ZhbHVlLCBwcmV2aW91cywgcGFzc10pO1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gdGhpcy5fbXV0YXRlKHNlZ21lbnRzLCBzdHJpbmdJbnNlcnQsIGNiKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5zdHJpbmdSZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN1YnBhdGgsIGluZGV4LCBob3dNYW55LCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdOb3QgZW5vdWdoIGFyZ3VtZW50cyBmb3Igc3RyaW5nUmVtb3ZlJykpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBpbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgICBob3dNYW55ID0gYXJndW1lbnRzWzFdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgICBob3dNYW55ID0gYXJndW1lbnRzWzFdO1xuICAgICAgY2IgPSBhcmd1bWVudHNbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgICBpbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGhvd01hbnkgPSBhcmd1bWVudHNbMl07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgaW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgaG93TWFueSA9IGFyZ3VtZW50c1syXTtcbiAgICBjYiA9IGFyZ3VtZW50c1szXTtcbiAgfVxuICB2YXIgc2VnbWVudHMgPSB0aGlzLl9zcGxpdFBhdGgoc3VicGF0aCk7XG4gIHJldHVybiB0aGlzLl9zdHJpbmdSZW1vdmUoc2VnbWVudHMsIGluZGV4LCBob3dNYW55LCBjYik7XG59O1xuTW9kZWwucHJvdG90eXBlLl9zdHJpbmdSZW1vdmUgPSBmdW5jdGlvbihzZWdtZW50cywgaW5kZXgsIGhvd01hbnksIGNiKSB7XG4gIHNlZ21lbnRzID0gdGhpcy5fZGVyZWZlcmVuY2Uoc2VnbWVudHMpO1xuICB2YXIgbW9kZWwgPSB0aGlzO1xuICBmdW5jdGlvbiBzdHJpbmdSZW1vdmUoZG9jLCBkb2NTZWdtZW50cywgZm5DYikge1xuICAgIHZhciBwcmV2aW91cyA9IGRvYy5zdHJpbmdSZW1vdmUoZG9jU2VnbWVudHMsIGluZGV4LCBob3dNYW55LCBmbkNiKTtcbiAgICBtb2RlbC5lbWl0KCdzdHJpbmdSZW1vdmUnLCBzZWdtZW50cywgW2luZGV4LCBob3dNYW55LCBtb2RlbC5fcGFzc10pO1xuICAgIHZhciB2YWx1ZSA9IGRvYy5nZXQoZG9jU2VnbWVudHMpO1xuICAgIHZhciBwYXNzID0gbW9kZWwucGFzcyh7JG9yaWdpbmFsOiAnc3RyaW5nUmVtb3ZlJ30pLl9wYXNzO1xuICAgIG1vZGVsLmVtaXQoJ2NoYW5nZScsIHNlZ21lbnRzLCBbdmFsdWUsIHByZXZpb3VzLCBwYXNzXSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiB0aGlzLl9tdXRhdGUoc2VnbWVudHMsIHN0cmluZ1JlbW92ZSwgY2IpO1xufTtcbiIsIihmdW5jdGlvbihwcm9jZXNzKXt2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcbnZhciBRdWVyeSA9IHJlcXVpcmUoJy4vUXVlcnknKTtcblxuTW9kZWwuSU5JVFMucHVzaChmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICBtb2RlbC5yb290LmZldGNoT25seSA9IG9wdGlvbnMuZmV0Y2hPbmx5O1xuICBtb2RlbC5yb290LnVubG9hZERlbGF5ID0gb3B0aW9ucy51bmxvYWREZWxheSB8fCAxMDAwO1xuXG4gIC8vIEtlZXBzIHRyYWNrIG9mIHRoZSBjb3VudCBvZiBmZXRjaGVzICh0aGF0IGhhdmVuJ3QgYmVlbiB1bmRvbmUgYnkgYW5cbiAgLy8gdW5mZXRjaCkgcGVyIGRvYy4gTWFwcyBkb2MgaWQgdG8gdGhlIGZldGNoIGNvdW50LlxuICBtb2RlbC5yb290Ll9mZXRjaGVkRG9jcyA9IG5ldyBGZXRjaGVkRG9jcztcblxuICAvLyBLZWVwcyB0cmFjayBvZiB0aGUgY291bnQgb2Ygc3Vic2NyaWJlcyAodGhhdCBoYXZlbid0IGJlZW4gdW5kb25lIGJ5IGFuXG4gIC8vIHVuc3Vic2NyaWJlKSBwZXIgZG9jLiBNYXBzIGRvYyBpZCB0byB0aGUgc3Vic2NyaWJlIGNvdW50LlxuICBtb2RlbC5yb290Ll9zdWJzY3JpYmVkRG9jcyA9IG5ldyBTdWJzY3JpYmVkRG9jcztcblxuICAvLyBNYXBzIGRvYyBwYXRoIHRvIGRvYyB2ZXJzaW9uXG4gIG1vZGVsLnJvb3QuX2xvYWRWZXJzaW9ucyA9IG5ldyBMb2FkVmVyc2lvbnM7XG59KTtcblxuZnVuY3Rpb24gRmV0Y2hlZERvY3MoKSB7fVxuZnVuY3Rpb24gU3Vic2NyaWJlZERvY3MoKSB7fVxuZnVuY3Rpb24gTG9hZFZlcnNpb25zKCkge31cblxuTW9kZWwucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2ZvclN1YnNjcmliYWJsZShhcmd1bWVudHMsICdmZXRjaCcpO1xuICByZXR1cm4gdGhpcztcbn07XG5Nb2RlbC5wcm90b3R5cGUudW5mZXRjaCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9mb3JTdWJzY3JpYmFibGUoYXJndW1lbnRzLCAndW5mZXRjaCcpO1xuICByZXR1cm4gdGhpcztcbn07XG5Nb2RlbC5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2ZvclN1YnNjcmliYWJsZShhcmd1bWVudHMsICdzdWJzY3JpYmUnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuTW9kZWwucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2ZvclN1YnNjcmliYWJsZShhcmd1bWVudHMsICd1bnN1YnNjcmliZScpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJndW1lbnRzfSBhcmd1bWVudHNPYmplY3QgY2FuIHRha2UgMSBvZiB0d28gZm9ybXNcbiAqICAgMS4gW1tzdWJzY3JpYmFibGVPYmplY3RzLi4uXSwgY2JdXG4gKiAgIDIuIFtzdWJzY3JpYmFibGVPYmplY3RzLi4uLCBjYl1cbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgY2FuIGJlICdmZXRjaCcsICd1bmZldGNoJywgJ3N1YnNjcmliZScsICd1bnN1YnNjcmliZSdcbiAqL1xuTW9kZWwucHJvdG90eXBlLl9mb3JTdWJzY3JpYmFibGUgPSBmdW5jdGlvbihhcmd1bWVudHNPYmplY3QsIG1ldGhvZCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcmd1bWVudHNPYmplY3RbMF0pKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHNPYmplY3RbMF07XG4gICAgdmFyIGNiID0gYXJndW1lbnRzT2JqZWN0WzFdIHx8IHRoaXMucm9vdC5fZGVmYXVsdENhbGxiYWNrO1xuICB9IGVsc2Uge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzT2JqZWN0KTtcbiAgICB2YXIgbGFzdCA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICB2YXIgY2IgPSAodHlwZW9mIGxhc3QgPT09ICdmdW5jdGlvbicpID8gYXJncy5wb3AoKSA6IHRoaXMucm9vdC5fZGVmYXVsdENhbGxiYWNrO1xuICB9XG4gIC8vIElmIG5vIHF1ZXJpZXMgb3IgcGF0aHMgYXJlIHBhc3NlZCBpbiwgdHJ5IHRvIHVzZSB0aGlzIG1vZGVsJ3Mgc2NvcGVcbiAgaWYgKCFhcmdzLmxlbmd0aCkgYXJncy5wdXNoKG51bGwpO1xuICB2YXIgZ3JvdXAgPSB1dGlsLmFzeW5jR3JvdXAoY2IpO1xuICB2YXIgZG9jTWV0aG9kID0gbWV0aG9kICsgJ0RvYyc7XG5cbiAgdmFyIGZpbmlzaGVkID0gZ3JvdXAoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBhcmdzW2ldO1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUXVlcnkpIHtcbiAgICAgIGl0ZW1bbWV0aG9kXShncm91cCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5fZGVyZWZlcmVuY2UodGhpcy5fc3BsaXRQYXRoKGl0ZW0pKTtcbiAgICAgIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgLy8gRG8gdGhlIGFwcHJvcHJpYXRlIG1ldGhvZCBmb3IgYSBzaW5nbGUgZG9jdW1lbnQuXG4gICAgICAgIHRoaXNbZG9jTWV0aG9kXShzZWdtZW50c1swXSwgc2VnbWVudHNbMV0sIGdyb3VwKCkpO1xuICAgICAgfSBlbHNlIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gTWFrZSBhIHF1ZXJ5IHRvIGFuIGVudGlyZSBjb2xsZWN0aW9uLlxuICAgICAgICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5KHNlZ21lbnRzWzBdLCB7fSk7XG4gICAgICAgIHF1ZXJ5W21ldGhvZF0oZ3JvdXAoKSk7XG4gICAgICB9IGVsc2UgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYihuZXcgRXJyb3IoJ05vIHBhdGggc3BlY2lmaWVkIGZvciAnICsgbWV0aG9kKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYihuZXcgRXJyb3IoJ0Nhbm5vdCAnICsgbWV0aG9kICsgJyB0byBhIHBhdGggd2l0aGluIGEgZG9jdW1lbnQ6ICcgK1xuICAgICAgICAgICAgc2VnbWVudHMuam9pbignLicpKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZpbmlzaGVkKCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfVxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYihlcnIpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFscmVhZHlMb2FkZWRcbiAqL1xuTW9kZWwucHJvdG90eXBlLmZldGNoRG9jID0gZnVuY3Rpb24oY29sbGVjdGlvbk5hbWUsIGlkLCBjYiwgYWxyZWFkeUxvYWRlZCkge1xuICBpZiAoIWNiKSBjYiA9IHRoaXMucm9vdC5fZGVmYXVsdENhbGxiYWNrO1xuXG4gIC8vIE1haW50YWluIGEgY291bnQgb2YgZmV0Y2hlcyBzbyB0aGF0IHdlIGNhbiB1bmxvYWQgdGhlIGRvY3VtZW50IHdoZW5cbiAgLy8gdGhlcmUgYXJlIG5vIHJlbWFpbmluZyBmZXRjaGVzIG9yIHN1YnNjcmliZXMgZm9yIHRoYXQgZG9jdW1lbnRcbiAgdmFyIHBhdGggPSBjb2xsZWN0aW9uTmFtZSArICcuJyArIGlkO1xuICB0aGlzLmVtaXQoJ2ZldGNoRG9jJywgcGF0aCwgdGhpcy5fY29udGV4dCwgdGhpcy5fcGFzcyk7XG4gIHRoaXMucm9vdC5fZmV0Y2hlZERvY3NbcGF0aF0gPSAodGhpcy5yb290Ll9mZXRjaGVkRG9jc1twYXRoXSB8fCAwKSArIDE7XG5cbiAgdmFyIG1vZGVsID0gdGhpcztcbiAgdmFyIGRvYyA9IHRoaXMuZ2V0T3JDcmVhdGVEb2MoY29sbGVjdGlvbk5hbWUsIGlkKTtcbiAgaWYgKGFscmVhZHlMb2FkZWQpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZldGNoRG9jQ2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIGRvYy5zaGFyZURvYy5mZXRjaChmZXRjaERvY0NhbGxiYWNrKTtcbiAgfVxuICBmdW5jdGlvbiBmZXRjaERvY0NhbGxiYWNrKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuICAgIGlmIChkb2Muc2hhcmVEb2MudmVyc2lvbiAhPT0gbW9kZWwucm9vdC5fbG9hZFZlcnNpb25zW3BhdGhdKSB7XG4gICAgICBtb2RlbC5yb290Ll9sb2FkVmVyc2lvbnNbcGF0aF0gPSBkb2Muc2hhcmVEb2MudmVyc2lvbjtcbiAgICAgIGRvYy5fdXBkYXRlQ29sbGVjdGlvbkRhdGEoKTtcbiAgICAgIG1vZGVsLmVtaXQoJ2xvYWQnLCBbY29sbGVjdGlvbk5hbWUsIGlkXSwgW2RvYy5nZXQoKSwgbW9kZWwuX3Bhc3NdKTtcbiAgICB9XG4gICAgY2IoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sbGVjdGlvbk5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCBvZiB0aGUgZG9jdW1lbnQgd2Ugd2FudCB0byBzdWJzY3JpYmUgdG9cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiKGVycilcbiAqL1xuTW9kZWwucHJvdG90eXBlLnN1YnNjcmliZURvYyA9IGZ1bmN0aW9uKGNvbGxlY3Rpb25OYW1lLCBpZCwgY2IpIHtcbiAgaWYgKCFjYikgY2IgPSB0aGlzLnJvb3QuX2RlZmF1bHRDYWxsYmFjaztcblxuICB2YXIgcGF0aCA9IGNvbGxlY3Rpb25OYW1lICsgJy4nICsgaWQ7XG4gIHRoaXMuZW1pdCgnc3Vic2NyaWJlRG9jJywgcGF0aCwgdGhpcy5fY29udGV4dCwgdGhpcy5fcGFzcyk7XG4gIHZhciBjb3VudCA9IHRoaXMucm9vdC5fc3Vic2NyaWJlZERvY3NbcGF0aF0gPSAodGhpcy5yb290Ll9zdWJzY3JpYmVkRG9jc1twYXRoXSB8fCAwKSArIDE7XG4gIC8vIEFscmVhZHkgcmVxdWVzdGVkIGEgc3Vic2NyaWJlLCBzbyBqdXN0IHJldHVyblxuICBpZiAoY291bnQgPiAxKSByZXR1cm4gY2IoKTtcblxuICAvLyBTdWJzY3JpYmUgaWYgY3VycmVudGx5IHVuc3Vic2NyaWJlZFxuICB2YXIgbW9kZWwgPSB0aGlzO1xuICB2YXIgZG9jID0gdGhpcy5nZXRPckNyZWF0ZURvYyhjb2xsZWN0aW9uTmFtZSwgaWQpO1xuICBpZiAodGhpcy5yb290LmZldGNoT25seSkge1xuICAgIC8vIE9ubHkgZmV0Y2ggaWYgdGhlIGRvY3VtZW50IGlzbid0IGFscmVhZHkgbG9hZGVkXG4gICAgaWYgKGRvYy5nZXQoKSA9PT0gdm9pZCAwKSB7XG4gICAgICBkb2Muc2hhcmVEb2MuZmV0Y2goc3Vic2NyaWJlRG9jQ2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKHN1YnNjcmliZURvY0NhbGxiYWNrKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZG9jLnNoYXJlRG9jLnN1YnNjcmliZShzdWJzY3JpYmVEb2NDYWxsYmFjayk7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlRG9jQ2FsbGJhY2soZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgaWYgKCFkb2MuY3JlYXRlZExvY2FsbHkgJiYgZG9jLnNoYXJlRG9jLnZlcnNpb24gIT09IG1vZGVsLnJvb3QuX2xvYWRWZXJzaW9uc1twYXRoXSkge1xuICAgICAgbW9kZWwucm9vdC5fbG9hZFZlcnNpb25zW3BhdGhdID0gZG9jLnNoYXJlRG9jLnZlcnNpb247XG4gICAgICBkb2MuX3VwZGF0ZUNvbGxlY3Rpb25EYXRhKCk7XG4gICAgICBtb2RlbC5lbWl0KCdsb2FkJywgW2NvbGxlY3Rpb25OYW1lLCBpZF0sIFtkb2MuZ2V0KCksIG1vZGVsLl9wYXNzXSk7XG4gICAgfVxuICAgIGNiKCk7XG4gIH1cbn07XG5cbk1vZGVsLnByb3RvdHlwZS51bmZldGNoRG9jID0gZnVuY3Rpb24oY29sbGVjdGlvbk5hbWUsIGlkLCBjYikge1xuICBpZiAoIWNiKSBjYiA9IHRoaXMucm9vdC5fZGVmYXVsdENhbGxiYWNrO1xuICB2YXIgcGF0aCA9IGNvbGxlY3Rpb25OYW1lICsgJy4nICsgaWQ7XG4gIHRoaXMuZW1pdCgndW5mZXRjaERvYycsIHBhdGgsIHRoaXMuX2NvbnRleHQsIHRoaXMuX3Bhc3MpO1xuICB2YXIgZmV0Y2hlZERvY3MgPSB0aGlzLnJvb3QuX2ZldGNoZWREb2NzO1xuXG4gIC8vIE5vIGVmZmVjdCBpZiB0aGUgZG9jdW1lbnQgaGFzIG5vIGZldGNoIGNvdW50XG4gIGlmICghZmV0Y2hlZERvY3NbcGF0aF0pIHJldHVybiBjYigpO1xuXG4gIHZhciBtb2RlbCA9IHRoaXM7XG4gIGlmICh0aGlzLnJvb3QudW5sb2FkRGVsYXkgJiYgIXRoaXMuX3Bhc3MuJHF1ZXJ5KSB7XG4gICAgc2V0VGltZW91dChmaW5pc2hVbmZldGNoRG9jLCB0aGlzLnJvb3QudW5sb2FkRGVsYXkpO1xuICB9IGVsc2Uge1xuICAgIGZpbmlzaFVuZmV0Y2hEb2MoKTtcbiAgfVxuICBmdW5jdGlvbiBmaW5pc2hVbmZldGNoRG9jKCkge1xuICAgIHZhciBjb3VudCA9IC0tZmV0Y2hlZERvY3NbcGF0aF07XG4gICAgaWYgKGNvdW50KSByZXR1cm4gY2IobnVsbCwgY291bnQpO1xuICAgIGRlbGV0ZSBmZXRjaGVkRG9jc1twYXRoXTtcbiAgICBtb2RlbC5fbWF5YmVVbmxvYWREb2MoY29sbGVjdGlvbk5hbWUsIGlkLCBwYXRoKTtcbiAgICBjYihudWxsLCAwKTtcbiAgfVxufTtcblxuTW9kZWwucHJvdG90eXBlLnVuc3Vic2NyaWJlRG9jID0gZnVuY3Rpb24oY29sbGVjdGlvbk5hbWUsIGlkLCBjYikge1xuICBpZiAoIWNiKSBjYiA9IHRoaXMucm9vdC5fZGVmYXVsdENhbGxiYWNrO1xuICB2YXIgcGF0aCA9IGNvbGxlY3Rpb25OYW1lICsgJy4nICsgaWQ7XG4gIHRoaXMuZW1pdCgndW5zdWJzY3JpYmVEb2MnLCBwYXRoLCB0aGlzLl9jb250ZXh0LCB0aGlzLl9wYXNzKTtcbiAgdmFyIHN1YnNjcmliZWREb2NzID0gdGhpcy5yb290Ll9zdWJzY3JpYmVkRG9jcztcblxuICAvLyBObyBlZmZlY3QgaWYgdGhlIGRvY3VtZW50IGlzIG5vdCBjdXJyZW50bHkgc3Vic2NyaWJlZFxuICBpZiAoIXN1YnNjcmliZWREb2NzW3BhdGhdKSByZXR1cm4gY2IoKTtcblxuICB2YXIgbW9kZWwgPSB0aGlzO1xuICBpZiAodGhpcy5yb290LnVubG9hZERlbGF5ICYmICF0aGlzLl9wYXNzLiRxdWVyeSkge1xuICAgIHNldFRpbWVvdXQoZmluaXNoVW5zdWJzY3JpYmVEb2MsIHRoaXMucm9vdC51bmxvYWREZWxheSk7XG4gIH0gZWxzZSB7XG4gICAgZmluaXNoVW5zdWJzY3JpYmVEb2MoKTtcbiAgfVxuICBmdW5jdGlvbiBmaW5pc2hVbnN1YnNjcmliZURvYygpIHtcbiAgICB2YXIgY291bnQgPSAtLXN1YnNjcmliZWREb2NzW3BhdGhdO1xuICAgIC8vIElmIHRoZXJlIGFyZSBtb3JlIHJlbWFpbmluZyBzdWJzY3JpcHRpb25zLCBvbmx5IGRlY3JlbWVudCB0aGUgY291bnRcbiAgICAvLyBhbmQgY2FsbGJhY2sgd2l0aCBob3cgbWFueSBzdWJzY3JpcHRpb25zIGFyZSByZW1haW5pbmdcbiAgICBpZiAoY291bnQpIHJldHVybiBjYihudWxsLCBjb3VudCk7XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBvbmx5IG9uZSByZW1haW5pbmcgc3Vic2NyaXB0aW9uLCBhY3R1YWxseSB1bnN1YnNjcmliZVxuICAgIGRlbGV0ZSBzdWJzY3JpYmVkRG9jc1twYXRoXTtcbiAgICBpZiAobW9kZWwucm9vdC5mZXRjaE9ubHkpIHtcbiAgICAgIHVuc3Vic2NyaWJlRG9jQ2FsbGJhY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNoYXJlRG9jID0gbW9kZWwucm9vdC5zaGFyZUNvbm5lY3Rpb24uZ2V0KGNvbGxlY3Rpb25OYW1lLCBpZCk7XG4gICAgICBpZiAoIXNoYXJlRG9jKSB7XG4gICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ1NoYXJlIGRvY3VtZW50IG5vdCBmb3VuZCBmb3I6ICcgKyBwYXRoKSk7XG4gICAgICB9XG4gICAgICBzaGFyZURvYy51bnN1YnNjcmliZSh1bnN1YnNjcmliZURvY0NhbGxiYWNrKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdW5zdWJzY3JpYmVEb2NDYWxsYmFjayhlcnIpIHtcbiAgICBtb2RlbC5fbWF5YmVVbmxvYWREb2MoY29sbGVjdGlvbk5hbWUsIGlkLCBwYXRoKTtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcbiAgICBjYihudWxsLCAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBkb2N1bWVudCBmcm9tIHRoZSBsb2NhbCBtb2RlbCBpZiB0aGUgbW9kZWwgbm8gbG9uZ2VyIGhhcyBhbnlcbiAqIHJlbWFpbmluZyBmZXRjaGVzIG9yIHN1YnNjcmliZXMgb24gcGF0aC5cbiAqIENhbGxlZCBmcm9tIE1vZGVsLnByb3RvdHlwZS51bmZldGNoRG9jIGFuZCBNb2RlbC5wcm90b3R5cGUudW5zdWJzY3JpYmVEb2MgYXNcbiAqIHBhcnQgb2YgYXR0ZW1wdGVkIGNsZWFudXAuXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sbGVjdGlvbk5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqL1xuTW9kZWwucHJvdG90eXBlLl9tYXliZVVubG9hZERvYyA9IGZ1bmN0aW9uKGNvbGxlY3Rpb25OYW1lLCBpZCwgcGF0aCkge1xuICB2YXIgZG9jID0gdGhpcy5nZXREb2MoY29sbGVjdGlvbk5hbWUsIGlkKTtcbiAgaWYgKCFkb2MpIHJldHVybjtcbiAgLy8gUmVtb3ZlIHRoZSBkb2N1bWVudCBmcm9tIHRoZSBsb2NhbCBtb2RlbCBpZiBpdCBubyBsb25nZXIgaGFzIGFueVxuICAvLyByZW1haW5pbmcgZmV0Y2hlcyBvciBzdWJzY3JpYmVzXG4gIGlmICh0aGlzLnJvb3QuX2ZldGNoZWREb2NzW3BhdGhdIHx8IHRoaXMucm9vdC5fc3Vic2NyaWJlZERvY3NbcGF0aF0pIHJldHVybjtcbiAgdmFyIHByZXZpb3VzID0gZG9jLmdldCgpO1xuICB0aGlzLnJvb3QuY29sbGVjdGlvbnNbY29sbGVjdGlvbk5hbWVdLnJlbW92ZShpZCk7XG4gIGlmIChkb2Muc2hhcmVEb2MpIGRvYy5zaGFyZURvYy5kZXN0cm95KCk7XG4gIGRlbGV0ZSB0aGlzLnJvb3QuX2xvYWRWZXJzaW9uc1twYXRoXTtcbiAgdGhpcy5lbWl0KCd1bmxvYWQnLCBbY29sbGVjdGlvbk5hbWUsIGlkXSwgW3ByZXZpb3VzLCB0aGlzLl9wYXNzXSk7XG59O1xuXG59KShyZXF1aXJlKFwiX19icm93c2VyaWZ5X3Byb2Nlc3NcIikpIiwiLyoqXG4gKiBDb250ZXh0cyBhcmUgdXNlZnVsIGZvciBrZWVwaW5nIHRyYWNrIG9mIHRoZSBvcmlnaW4gb2Ygc3Vic2NyaWJlcy5cbiAqL1xuXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyk7XG52YXIgUXVlcnkgPSByZXF1aXJlKCcuL1F1ZXJ5Jyk7XG5cbk1vZGVsLklOSVRTLnB1c2goZnVuY3Rpb24obW9kZWwpIHtcbiAgbW9kZWwucm9vdC5fY29udGV4dHMgPSBuZXcgQ29udGV4dHM7XG4gIG1vZGVsLnNldENvbnRleHQoJ3Jvb3QnKTtcbiAgWyAnZmV0Y2hEb2MnLCAnc3Vic2NyaWJlRG9jJywgJ3VuZmV0Y2hEb2MnLCAndW5zdWJzY3JpYmVEb2MnXG4gICwgJ2ZldGNoUXVlcnknLCAnc3Vic2NyaWJlUXVlcnknLCAndW5mZXRjaFF1ZXJ5JywgJ3Vuc3Vic2NyaWJlUXVlcnknXG4gIF0uZm9yRWFjaChmdW5jdGlvbihldmVudCkge1xuICAgIG1vZGVsLm9uKGV2ZW50LCBmdW5jdGlvbihpdGVtLCBjb250ZXh0LCBwYXNzKSB7XG4gICAgICBjb250ZXh0W2V2ZW50XShpdGVtLCBwYXNzKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuTW9kZWwucHJvdG90eXBlLmNvbnRleHQgPSBmdW5jdGlvbihpZCkge1xuICB2YXIgbW9kZWwgPSB0aGlzLl9jaGlsZCgpO1xuICBtb2RlbC5zZXRDb250ZXh0KGlkKTtcbiAgcmV0dXJuIG1vZGVsO1xufTtcblxuTW9kZWwucHJvdG90eXBlLnNldENvbnRleHQgPSBmdW5jdGlvbihpZCkge1xuICB2YXIgY29udGV4dCA9IHRoaXMucm9vdC5fY29udGV4dHNbaWRdIHx8IG5ldyBDb250ZXh0KHRoaXMsIGlkKTtcbiAgdGhpcy5fY29udGV4dCA9IHRoaXMucm9vdC5fY29udGV4dHNbaWRdID0gY29udGV4dDtcbiAgcmV0dXJuIGNvbnRleHQ7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUudW5sb2FkID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIGNvbnRleHQgPSAoaWQpID8gdGhpcy5yb290Ll9jb250ZXh0c1tpZF0gOiB0aGlzLl9jb250ZXh0O1xuICBjb250ZXh0LnVubG9hZCgpO1xufTtcblxuZnVuY3Rpb24gQ29udGV4dHMoKSB7fVxuXG5mdW5jdGlvbiBGZXRjaGVkRG9jcygpIHt9XG5mdW5jdGlvbiBTdWJzY3JpYmVkRG9jcygpIHt9XG5mdW5jdGlvbiBGZXRjaGVkUXVlcmllcygpIHt9XG5mdW5jdGlvbiBTdWJzY3JpYmVkUXVlcmllcygpIHt9XG5cbmZ1bmN0aW9uIENvbnRleHQobW9kZWwsIGlkKSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgdGhpcy5pZCA9IGlkO1xuICB0aGlzLmZldGNoZWREb2NzID0gbmV3IEZldGNoZWREb2NzO1xuICB0aGlzLnN1YnNjcmliZWREb2NzID0gbmV3IFN1YnNjcmliZWREb2NzO1xuICB0aGlzLmZldGNoZWRRdWVyaWVzID0gbmV3IEZldGNoZWRRdWVyaWVzO1xuICB0aGlzLnN1YnNjcmliZWRRdWVyaWVzID0gbmV3IFN1YnNjcmliZWRRdWVyaWVzO1xufVxuXG5Db250ZXh0LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBmZXRjaGVkRG9jczogdGhpcy5mZXRjaGVkRG9jc1xuICAsIHN1YnNjcmliZWREb2NzOiB0aGlzLnN1YnNjcmliZWREb2NzXG4gICwgZmV0Y2hlZFF1ZXJpZXM6IHRoaXMuZmV0Y2hlZFF1ZXJpZXNcbiAgLCBzdWJzY3JpYmVkUXVlcmllczogdGhpcy5zdWJzY3JpYmVkUXVlcmllc1xuICB9O1xufTtcblxuQ29udGV4dC5wcm90b3R5cGUuZmV0Y2hEb2MgPSBmdW5jdGlvbihwYXRoLCBwYXNzKSB7XG4gIGlmIChwYXNzLiRxdWVyeSkgcmV0dXJuO1xuICBtYXBJbmNyZW1lbnQodGhpcy5mZXRjaGVkRG9jcywgcGF0aCk7XG59O1xuQ29udGV4dC5wcm90b3R5cGUuc3Vic2NyaWJlRG9jID0gZnVuY3Rpb24ocGF0aCwgcGFzcykge1xuICBpZiAocGFzcy4kcXVlcnkpIHJldHVybjtcbiAgbWFwSW5jcmVtZW50KHRoaXMuc3Vic2NyaWJlZERvY3MsIHBhdGgpO1xufTtcbkNvbnRleHQucHJvdG90eXBlLnVuZmV0Y2hEb2MgPSBmdW5jdGlvbihwYXRoLCBwYXNzKSB7XG4gIGlmIChwYXNzLiRxdWVyeSkgcmV0dXJuO1xuICBtYXBEZWNyZW1lbnQodGhpcy5mZXRjaGVkRG9jcywgcGF0aCk7XG59O1xuQ29udGV4dC5wcm90b3R5cGUudW5zdWJzY3JpYmVEb2MgPSBmdW5jdGlvbihwYXRoLCBwYXNzKSB7XG4gIGlmIChwYXNzLiRxdWVyeSkgcmV0dXJuO1xuICBtYXBEZWNyZW1lbnQodGhpcy5zdWJzY3JpYmVkRG9jcywgcGF0aCk7XG59O1xuQ29udGV4dC5wcm90b3R5cGUuZmV0Y2hRdWVyeSA9IGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gIG1hcEluY3JlbWVudCh0aGlzLmZldGNoZWRRdWVyaWVzLCBxdWVyeS5oYXNoKTtcbn07XG5Db250ZXh0LnByb3RvdHlwZS5zdWJzY3JpYmVRdWVyeSA9IGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gIG1hcEluY3JlbWVudCh0aGlzLnN1YnNjcmliZWRRdWVyaWVzLCBxdWVyeS5oYXNoKTtcbn07XG5Db250ZXh0LnByb3RvdHlwZS51bmZldGNoUXVlcnkgPSBmdW5jdGlvbihxdWVyeSkge1xuICBtYXBEZWNyZW1lbnQodGhpcy5mZXRjaGVkUXVlcmllcywgcXVlcnkuaGFzaCk7XG59O1xuQ29udGV4dC5wcm90b3R5cGUudW5zdWJzY3JpYmVRdWVyeSA9IGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gIG1hcERlY3JlbWVudCh0aGlzLnN1YnNjcmliZWRRdWVyaWVzLCBxdWVyeS5oYXNoKTtcbn07XG5mdW5jdGlvbiBtYXBJbmNyZW1lbnQobWFwLCBrZXkpIHtcbiAgbWFwW2tleV0gPSAobWFwW2tleV0gfHwgMCkgKyAxO1xufVxuZnVuY3Rpb24gbWFwRGVjcmVtZW50KG1hcCwga2V5KSB7XG4gIG1hcFtrZXldICYmIG1hcFtrZXldLS07XG4gIGlmICghbWFwW2tleV0pIGRlbGV0ZSBtYXBba2V5XTtcbn1cblxuQ29udGV4dC5wcm90b3R5cGUudW5sb2FkID0gZnVuY3Rpb24oKSB7XG4gIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gIGZvciAodmFyIGhhc2ggaW4gdGhpcy5mZXRjaGVkUXVlcmllcykge1xuICAgIHZhciBxdWVyeSA9IG1vZGVsLnJvb3QuX3F1ZXJpZXMubWFwW2hhc2hdO1xuICAgIGlmICghcXVlcnkpIGNvbnRpbnVlO1xuICAgIHZhciBjb3VudCA9IHRoaXMuZmV0Y2hlZFF1ZXJpZXNbaGFzaF07XG4gICAgd2hpbGUgKGNvdW50LS0pIHF1ZXJ5LnVuZmV0Y2gobnVsbCk7XG4gIH1cbiAgZm9yICh2YXIgaGFzaCBpbiB0aGlzLnN1YnNjcmliZWRRdWVyaWVzKSB7XG4gICAgdmFyIHF1ZXJ5ID0gbW9kZWwucm9vdC5fcXVlcmllcy5tYXBbaGFzaF07XG4gICAgaWYgKCFxdWVyeSkgY29udGludWU7XG4gICAgdmFyIGNvdW50ID0gdGhpcy5zdWJzY3JpYmVkUXVlcmllc1toYXNoXTtcbiAgICB3aGlsZSAoY291bnQtLSkgcXVlcnkudW5zdWJzY3JpYmUobnVsbCk7XG4gIH1cbiAgZm9yICh2YXIgcGF0aCBpbiB0aGlzLmZldGNoZWREb2NzKSB7XG4gICAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICAgIHZhciBjb3VudCA9IHRoaXMuZmV0Y2hlZERvY3NbcGF0aF07XG4gICAgd2hpbGUgKGNvdW50LS0pIG1vZGVsLnVuZmV0Y2hEb2Moc2VnbWVudHNbMF0sIHNlZ21lbnRzWzFdKTtcbiAgfVxuICBmb3IgKHZhciBwYXRoIGluIHRoaXMuc3Vic2NyaWJlZERvY3MpIHtcbiAgICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgdmFyIGNvdW50ID0gdGhpcy5zdWJzY3JpYmVkRG9jc1twYXRoXTtcbiAgICB3aGlsZSAoY291bnQtLSkgbW9kZWwudW5zdWJzY3JpYmVEb2Moc2VnbWVudHNbMF0sIHNlZ21lbnRzWzFdKTtcbiAgfVxuICBtb2RlbC5fY29udGV4dCA9IG1vZGVsLnJvb3QuX2NvbnRleHRzW3RoaXMuaWRdID0gbmV3IENvbnRleHQobW9kZWwsIHRoaXMuaWQpO1xufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xudmFyIGRlZmF1bHRGbnMgPSByZXF1aXJlKCcuL2RlZmF1bHRGbnMnKTtcblxuZnVuY3Rpb24gTmFtZWRGbnMoKSB7fVxuXG5Nb2RlbC5JTklUUy5wdXNoKGZ1bmN0aW9uKG1vZGVsKSB7XG4gIG1vZGVsLnJvb3QuX25hbWVkRm5zID0gbmV3IE5hbWVkRm5zKCk7XG4gIG1vZGVsLnJvb3QuX2ZucyA9IG5ldyBGbnMobW9kZWwpO1xuICBtb2RlbC5vbignYWxsJywgZm5MaXN0ZW5lcik7XG4gIGZ1bmN0aW9uIGZuTGlzdGVuZXIoc2VnbWVudHMsIGV2ZW50QXJncykge1xuICAgIHZhciBwYXNzID0gZXZlbnRBcmdzW2V2ZW50QXJncy5sZW5ndGggLSAxXTtcbiAgICB2YXIgbWFwID0gbW9kZWwucm9vdC5fZm5zLmZyb21NYXA7XG4gICAgZm9yICh2YXIgcGF0aCBpbiBtYXApIHtcbiAgICAgIHZhciBmbiA9IG1hcFtwYXRoXTtcbiAgICAgIGlmIChwYXNzLiRmbiA9PT0gZm4pIGNvbnRpbnVlO1xuICAgICAgaWYgKHV0aWwubWF5SW1wYWN0QW55KGZuLmlucHV0c1NlZ21lbnRzLCBzZWdtZW50cykpIHtcbiAgICAgICAgLy8gTXV0YXRpb24gYWZmZWN0aW5nIGlucHV0IHBhdGhcbiAgICAgICAgZm4ub25JbnB1dChwYXNzKTtcbiAgICAgIH0gZWxzZSBpZiAodXRpbC5tYXlJbXBhY3QoZm4uZnJvbVNlZ21lbnRzLCBzZWdtZW50cykpIHtcbiAgICAgICAgLy8gTXV0YXRpb24gYWZmZWN0aW5nIG91dHB1dCBwYXRoXG4gICAgICAgIGZuLm9uT3V0cHV0KHBhc3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbk1vZGVsLnByb3RvdHlwZS5mbiA9IGZ1bmN0aW9uKG5hbWUsIGZucykge1xuICB0aGlzLnJvb3QuX25hbWVkRm5zW25hbWVdID0gZm5zO1xufTtcblxuZnVuY3Rpb24gcGFyc2VTdGFydEFyZ3VtZW50cyhtb2RlbCwgYXJncywgaGFzUGF0aCkge1xuICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZm5zID0gYXJnc1swXTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmFtZSA9IGFyZ3NbMF07XG4gIH1cbiAgaWYgKGhhc1BhdGgpIHtcbiAgICB2YXIgcGF0aCA9IG1vZGVsLnBhdGgoYXJnc1sxXSk7XG4gICAgdmFyIGlucHV0UGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAyKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaW5wdXRQYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpO1xuICB9XG4gIHZhciBpID0gaW5wdXRQYXRocy5sZW5ndGggLSAxO1xuICBpZiAobW9kZWwuaXNQYXRoKGlucHV0UGF0aHNbaV0pKSB7XG4gICAgaW5wdXRQYXRoc1tpXSA9IG1vZGVsLnBhdGgoaW5wdXRQYXRoc1tpXSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG9wdGlvbnMgPSBpbnB1dFBhdGhzLnBvcCgpO1xuICB9XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpbnB1dFBhdGhzW2ldID0gbW9kZWwucGF0aChpbnB1dFBhdGhzW2ldKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWVcbiAgLCBwYXRoOiBwYXRoXG4gICwgaW5wdXRQYXRoczogaW5wdXRQYXRoc1xuICAsIGZuczogZm5zXG4gICwgb3B0aW9uczogb3B0aW9uc1xuICB9O1xufVxuXG5Nb2RlbC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBhcmdzID0gcGFyc2VTdGFydEFyZ3VtZW50cyh0aGlzLCBhcmd1bWVudHMsIGZhbHNlKTtcbiAgcmV0dXJuIHRoaXMucm9vdC5fZm5zLmdldChhcmdzLm5hbWUsIGFyZ3MuaW5wdXRQYXRocywgYXJncy5mbnMsIGFyZ3Mub3B0aW9ucyk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihuYW1lLCBzdWJwYXRoKSB7XG4gIHZhciBhcmdzID0gcGFyc2VTdGFydEFyZ3VtZW50cyh0aGlzLCBhcmd1bWVudHMsIHRydWUpO1xuICByZXR1cm4gdGhpcy5yb290Ll9mbnMuc3RhcnQoYXJncy5uYW1lLCBhcmdzLnBhdGgsIGFyZ3MuaW5wdXRQYXRocywgYXJncy5mbnMsIGFyZ3Mub3B0aW9ucyk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKHN1YnBhdGgpIHtcbiAgdmFyIHBhdGggPSB0aGlzLnBhdGgoc3VicGF0aCk7XG4gIHRoaXMucm9vdC5fZm5zLnN0b3AocGF0aCk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuc3RvcEFsbCA9IGZ1bmN0aW9uKHN1YnBhdGgpIHtcbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICB2YXIgZm5zID0gdGhpcy5yb290Ll9mbnMuZnJvbU1hcDtcbiAgZm9yICh2YXIgZnJvbSBpbiBmbnMpIHtcbiAgICBpZiAodXRpbC5jb250YWlucyhzZWdtZW50cywgZm5zW2Zyb21dLmZyb21TZWdtZW50cykpIHtcbiAgICAgIHRoaXMuc3RvcChmcm9tKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIEZyb21NYXAoKSB7fVxuZnVuY3Rpb24gRm5zKG1vZGVsKSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgdGhpcy5uYW1lTWFwID0gbW9kZWwucm9vdC5fbmFtZWRGbnM7XG4gIHRoaXMuZnJvbU1hcCA9IG5ldyBGcm9tTWFwO1xufVxuXG5GbnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUsIGlucHV0UGF0aHMsIGZucywgb3B0aW9ucykge1xuICBmbnMgfHwgKGZucyA9IHRoaXMubmFtZU1hcFtuYW1lXSB8fCBkZWZhdWx0Rm5zW25hbWVdKTtcbiAgdmFyIGZuID0gbmV3IEZuKHRoaXMubW9kZWwsIG5hbWUsIG51bGwsIGlucHV0UGF0aHMsIGZucywgb3B0aW9ucyk7XG4gIHJldHVybiBmbi5nZXQoKTtcbn07XG5cbkZucy5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihuYW1lLCBwYXRoLCBpbnB1dFBhdGhzLCBmbnMsIG9wdGlvbnMpIHtcbiAgZm5zIHx8IChmbnMgPSB0aGlzLm5hbWVNYXBbbmFtZV0gfHwgZGVmYXVsdEZuc1tuYW1lXSk7XG4gIHZhciBmbiA9IG5ldyBGbih0aGlzLm1vZGVsLCBuYW1lLCBwYXRoLCBpbnB1dFBhdGhzLCBmbnMsIG9wdGlvbnMpO1xuICB0aGlzLmZyb21NYXBbcGF0aF0gPSBmbjtcbiAgcmV0dXJuIGZuLm9uSW5wdXQoKTtcbn07XG5cbkZucy5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGZuID0gdGhpcy5mcm9tTWFwW3BhdGhdO1xuICBkZWxldGUgdGhpcy5mcm9tTWFwW3BhdGhdO1xuICByZXR1cm4gZm47XG59O1xuXG5GbnMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3V0ID0gW107XG4gIGZvciAodmFyIGZyb20gaW4gdGhpcy5mcm9tTWFwKSB7XG4gICAgdmFyIGZuID0gdGhpcy5mcm9tTWFwW2Zyb21dO1xuICAgIC8vIERvbid0IHRyeSB0byBidW5kbGUgbm9uLW5hbWVkIGZ1bmN0aW9ucyB0aGF0IHdlcmUgc3RhcnRlZCB2aWFcbiAgICAvLyBtb2RlbC5zdGFydCBkaXJlY3RseSBpbnN0ZWFkIG9mIGJ5IG5hbWVcbiAgICBpZiAoIWZuLm5hbWUpIGNvbnRpbnVlO1xuICAgIG91dC5wdXNoKFtmbi5uYW1lLCBmbi5mcm9tXS5jb25jYXQoZm4uaW5wdXRQYXRocykpO1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG5mdW5jdGlvbiBGbihtb2RlbCwgbmFtZSwgZnJvbSwgaW5wdXRQYXRocywgZm5zLCBvcHRpb25zKSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbC5wYXNzKHskZm46IHRoaXN9KTtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5mcm9tID0gZnJvbTtcbiAgdGhpcy5pbnB1dFBhdGhzID0gaW5wdXRQYXRocztcbiAgaWYgKCFmbnMpIHtcbiAgICB2YXIgZXJyID0gbmV3IFR5cGVFcnJvcignTW9kZWwgZnVuY3Rpb24gbm90IGZvdW5kOiAnICsgbmFtZSk7XG4gICAgbW9kZWwuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG4gIHRoaXMuZ2V0Rm4gPSBmbnMuZ2V0IHx8IGZucztcbiAgdGhpcy5zZXRGbiA9IGZucy5zZXQ7XG4gIHRoaXMuZnJvbVNlZ21lbnRzID0gZnJvbSAmJiBmcm9tLnNwbGl0KCcuJyk7XG4gIHRoaXMuaW5wdXRzU2VnbWVudHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmlucHV0UGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2VnbWVudHMgPSB0aGlzLmlucHV0UGF0aHNbaV0uc3BsaXQoJy4nKTtcbiAgICB0aGlzLmlucHV0c1NlZ21lbnRzLnB1c2goc2VnbWVudHMpO1xuICB9XG4gIHZhciBjb3B5ID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5jb3B5KSB8fCAnb3V0cHV0JztcbiAgdGhpcy5jb3B5SW5wdXQgPSAoY29weSA9PT0gJ2lucHV0JyB8fCBjb3B5ID09PSAnYm90aCcpO1xuICB0aGlzLmNvcHlPdXRwdXQgPSAoY29weSA9PT0gJ291dHB1dCcgfHwgY29weSA9PT0gJ2JvdGgnKTtcbn1cblxuRm4ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24oZm4sIGlucHV0cykge1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5pbnB1dHNTZWdtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBpbnB1dCA9IHRoaXMubW9kZWwuX2dldCh0aGlzLmlucHV0c1NlZ21lbnRzW2ldKTtcbiAgICBpbnB1dHMucHVzaCh0aGlzLmNvcHlJbnB1dCA/IHV0aWwuZGVlcENvcHkoaW5wdXQpIDogaW5wdXQpO1xuICB9XG4gIHJldHVybiBmbi5hcHBseSh0aGlzLm1vZGVsLCBpbnB1dHMpO1xufTtcblxuRm4ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5hcHBseSh0aGlzLmdldEZuLCBbXSk7XG59O1xuXG52YXIgZGlmZk9wdGlvbnMgPSB7ZXF1YWw6IHV0aWwuZGVlcEVxdWFsfTtcbnZhciBlYWNoRGlmZk9wdGlvbnMgPSB7ZWFjaDogdHJ1ZSwgZXF1YWw6IHV0aWwuZGVlcEVxdWFsfTtcblxuRm4ucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHZhbHVlLCBwYXNzKSB7XG4gIGlmICghdGhpcy5zZXRGbikgcmV0dXJuO1xuICB2YXIgb3V0ID0gdGhpcy5hcHBseSh0aGlzLnNldEZuLCBbdmFsdWVdKTtcbiAgaWYgKCFvdXQpIHJldHVybjtcbiAgdmFyIGlucHV0c1NlZ21lbnRzID0gdGhpcy5pbnB1dHNTZWdtZW50cztcbiAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbC5wYXNzKHBhc3MsIHRydWUpO1xuICBmb3IgKHZhciBrZXkgaW4gb3V0KSB7XG4gICAgaWYgKGtleSA9PT0gJ2VhY2gnKSB7XG4gICAgICB2YXIgZWFjaCA9IG91dFtrZXldO1xuICAgICAgZm9yIChrZXkgaW4gZWFjaCkge1xuICAgICAgICB2YXIgdmFsdWUgPSAodGhpcy5jb3B5T3V0cHV0KSA/IHV0aWwuZGVlcENvcHkoZWFjaFtrZXldKSA6IGVhY2hba2V5XTtcbiAgICAgICAgbW9kZWwuX3NldERpZmYoaW5wdXRzU2VnbWVudHNba2V5XSwgdmFsdWUsIGVhY2hEaWZmT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIHZhbHVlID0gKHRoaXMuY29weU91dHB1dCkgPyB1dGlsLmRlZXBDb3B5KG91dFtrZXldKSA6IG91dFtrZXldO1xuICAgIG1vZGVsLl9zZXREaWZmKGlucHV0c1NlZ21lbnRzW2tleV0sIHZhbHVlLCBkaWZmT3B0aW9ucyk7XG4gIH1cbn07XG5cbkZuLnByb3RvdHlwZS5vbklucHV0ID0gZnVuY3Rpb24ocGFzcykge1xuICB2YXIgdmFsdWUgPSAodGhpcy5jb3B5T3V0cHV0KSA/IHV0aWwuZGVlcENvcHkodGhpcy5nZXQoKSkgOiB0aGlzLmdldCgpO1xuICB0aGlzLm1vZGVsLnBhc3MocGFzcywgdHJ1ZSkuX3NldERpZmYodGhpcy5mcm9tU2VnbWVudHMsIHZhbHVlLCBkaWZmT3B0aW9ucyk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbkZuLnByb3RvdHlwZS5vbk91dHB1dCA9IGZ1bmN0aW9uKHBhc3MpIHtcbiAgdmFyIHZhbHVlID0gdGhpcy5tb2RlbC5fZ2V0KHRoaXMuZnJvbVNlZ21lbnRzKTtcbiAgcmV0dXJuIHRoaXMuc2V0KHZhbHVlLCBwYXNzKTtcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcbnZhciBkZWZhdWx0Rm5zID0gcmVxdWlyZSgnLi9kZWZhdWx0Rm5zJyk7XG5cbk1vZGVsLklOSVRTLnB1c2goZnVuY3Rpb24obW9kZWwpIHtcbiAgbW9kZWwucm9vdC5fZmlsdGVycyA9IG5ldyBGaWx0ZXJzKG1vZGVsKTtcbiAgbW9kZWwub24oJ2FsbCcsIGZpbHRlckxpc3RlbmVyKTtcbiAgZnVuY3Rpb24gZmlsdGVyTGlzdGVuZXIoc2VnbWVudHMsIGV2ZW50QXJncykge1xuICAgIHZhciBwYXNzID0gZXZlbnRBcmdzW2V2ZW50QXJncy5sZW5ndGggLSAxXTtcbiAgICB2YXIgbWFwID0gbW9kZWwucm9vdC5fZmlsdGVycy5mcm9tTWFwO1xuICAgIGZvciAodmFyIHBhdGggaW4gbWFwKSB7XG4gICAgICB2YXIgZmlsdGVyID0gbWFwW3BhdGhdO1xuICAgICAgaWYgKHBhc3MuJGZpbHRlciA9PT0gZmlsdGVyKSBjb250aW51ZTtcbiAgICAgIGlmICh1dGlsLm1heUltcGFjdChmaWx0ZXIuaW5wdXRTZWdtZW50cywgc2VnbWVudHMpKSB7XG4gICAgICAgIGZpbHRlci51cGRhdGUocGFzcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcblxuTW9kZWwucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uKGlucHV0LCBmbikge1xuICB2YXIgaW5wdXRQYXRoID0gdGhpcy5wYXRoKGlucHV0KTtcbiAgcmV0dXJuIHRoaXMucm9vdC5fZmlsdGVycy5hZGQoaW5wdXRQYXRoLCBmbik7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uKGlucHV0LCBmbikge1xuICB2YXIgaW5wdXRQYXRoID0gdGhpcy5wYXRoKGlucHV0KTtcbiAgcmV0dXJuIHRoaXMucm9vdC5fZmlsdGVycy5hZGQoaW5wdXRQYXRoLCBudWxsLCBmbiB8fCAnYXNjJyk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUucmVtb3ZlQWxsRmlsdGVycyA9IGZ1bmN0aW9uKHN1YnBhdGgpIHtcbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICB2YXIgZmlsdGVycyA9IHRoaXMucm9vdC5fZmlsdGVycy5mcm9tTWFwO1xuICBmb3IgKHZhciBmcm9tIGluIGZpbHRlcnMpIHtcbiAgICBpZiAodXRpbC5jb250YWlucyhzZWdtZW50cywgZmlsdGVyc1tmcm9tXS5mcm9tU2VnbWVudHMpKSB7XG4gICAgICBmaWx0ZXJzW2Zyb21dLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIEZyb21NYXAoKSB7fVxuZnVuY3Rpb24gRmlsdGVycyhtb2RlbCkge1xuICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gIHRoaXMuZnJvbU1hcCA9IG5ldyBGcm9tTWFwO1xufVxuXG5GaWx0ZXJzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihpbnB1dFBhdGgsIGZpbHRlckZuLCBzb3J0Rm4pIHtcbiAgcmV0dXJuIG5ldyBGaWx0ZXIodGhpcywgaW5wdXRQYXRoLCBmaWx0ZXJGbiwgc29ydEZuKTtcbn07XG5cbkZpbHRlcnMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3V0ID0gW107XG4gIGZvciAodmFyIGZyb20gaW4gdGhpcy5mcm9tTWFwKSB7XG4gICAgdmFyIGZpbHRlciA9IHRoaXMuZnJvbU1hcFtmcm9tXTtcbiAgICAvLyBEb24ndCB0cnkgdG8gYnVuZGxlIGlmIGZ1bmN0aW9ucyB3ZXJlIHBhc3NlZCBkaXJlY3RseSBpbnN0ZWFkIG9mIGJ5IG5hbWVcbiAgICBpZiAoIWZpbHRlci5idW5kbGUpIGNvbnRpbnVlO1xuICAgIG91dC5wdXNoKFtmaWx0ZXIuaW5wdXRQYXRoLCBmaWx0ZXIuZmlsdGVyTmFtZSwgZmlsdGVyLnNvcnROYW1lLCBmcm9tXSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbmZ1bmN0aW9uIEZpbHRlcihmaWx0ZXJzLCBpbnB1dFBhdGgsIGZpbHRlckZuLCBzb3J0Rm4pIHtcbiAgdGhpcy5maWx0ZXJzID0gZmlsdGVycztcbiAgdGhpcy5tb2RlbCA9IGZpbHRlcnMubW9kZWwucGFzcyh7JGZpbHRlcjogdGhpc30pO1xuICB0aGlzLmlucHV0UGF0aCA9IGlucHV0UGF0aDtcbiAgdGhpcy5pbnB1dFNlZ21lbnRzID0gaW5wdXRQYXRoLnNwbGl0KCcuJyk7XG4gIHRoaXMuZmlsdGVyTmFtZSA9IG51bGw7XG4gIHRoaXMuc29ydE5hbWUgPSBudWxsO1xuICB0aGlzLmJ1bmRsZSA9IHRydWU7XG4gIHRoaXMuZmlsdGVyRm4gPSBudWxsO1xuICB0aGlzLnNvcnRGbiA9IG51bGw7XG4gIGlmIChmaWx0ZXJGbikgdGhpcy5maWx0ZXIoZmlsdGVyRm4pO1xuICBpZiAoc29ydEZuKSB0aGlzLnNvcnQoc29ydEZuKTtcbiAgdGhpcy5pZHNTZWdtZW50cyA9IG51bGw7XG4gIHRoaXMuZnJvbSA9IG51bGw7XG4gIHRoaXMuZnJvbVNlZ21lbnRzID0gbnVsbDtcbn1cblxuRmlsdGVyLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbihmbikge1xuICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5maWx0ZXJGbiA9IGZuO1xuICAgIHRoaXMuYnVuZGxlID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaWYgKHR5cGVvZiBmbiA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLmZpbHRlck5hbWUgPSBmbjtcbiAgICB0aGlzLmZpbHRlckZuID0gdGhpcy5tb2RlbC5yb290Ll9uYW1lZEZuc1tmbl0gfHwgZGVmYXVsdEZuc1tmbl07XG4gICAgaWYgKCF0aGlzLmZpbHRlckZuKSB7XG4gICAgICB2YXIgZXJyID0gbmV3IFR5cGVFcnJvcignRmlsdGVyIGZ1bmN0aW9uIG5vdCBmb3VuZDogJyArIGZuKTtcbiAgICAgIHRoaXMubW9kZWwuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbkZpbHRlci5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uKGZuKSB7XG4gIGlmICghZm4pIGZuID0gJ2FzYyc7XG4gIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLnNvcnRGbiA9IGZuO1xuICAgIHRoaXMuYnVuZGxlID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaWYgKHR5cGVvZiBmbiA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLnNvcnROYW1lID0gZm47XG4gICAgdGhpcy5zb3J0Rm4gPSB0aGlzLm1vZGVsLnJvb3QuX25hbWVkRm5zW2ZuXSB8fCBkZWZhdWx0Rm5zW2ZuXTtcbiAgICBpZiAoIXRoaXMuc29ydEZuKSB7XG4gICAgICB2YXIgZXJyID0gbmV3IFR5cGVFcnJvcignU29ydCBmdW5jdGlvbiBub3QgZm91bmQ6ICcgKyBmbik7XG4gICAgICB0aGlzLm1vZGVsLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5GaWx0ZXIucHJvdG90eXBlLmlkcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbXMgPSB0aGlzLm1vZGVsLl9nZXQodGhpcy5pbnB1dFNlZ21lbnRzKTtcbiAgdmFyIGlkcyA9IFtdO1xuICBpZiAoIWl0ZW1zKSByZXR1cm4gaWRzO1xuICBpZiAoQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICBpZiAodGhpcy5maWx0ZXJGbikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5maWx0ZXJGbi5jYWxsKHRoaXMubW9kZWwsIGl0ZW1zW2ldLCBpLCBpdGVtcykpIHtcbiAgICAgICAgICBpZHMucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSBpZHMucHVzaChpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuZmlsdGVyRm4pIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBpdGVtcykge1xuICAgICAgICBpZiAoaXRlbXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJlxuICAgICAgICAgIHRoaXMuZmlsdGVyRm4uY2FsbCh0aGlzLm1vZGVsLCBpdGVtc1trZXldLCBrZXksIGl0ZW1zKVxuICAgICAgICApIHtcbiAgICAgICAgICBpZHMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlkcyA9IE9iamVjdC5rZXlzKGl0ZW1zKTtcbiAgICB9XG4gIH1cbiAgdmFyIHNvcnRGbiA9IHRoaXMuc29ydEZuO1xuICBpZiAoc29ydEZuKSB7XG4gICAgaWRzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIHNvcnRGbihpdGVtc1thXSwgaXRlbXNbYl0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBpZHM7XG59O1xuXG5GaWx0ZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbXMgPSB0aGlzLm1vZGVsLl9nZXQodGhpcy5pbnB1dFNlZ21lbnRzKTtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgaWYgKHRoaXMuZmlsdGVyRm4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyRm4uY2FsbCh0aGlzLm1vZGVsLCBpdGVtc1tpXSwgaSwgaXRlbXMpKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKGl0ZW1zW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRzID0gaXRlbXMuc2xpY2UoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuZmlsdGVyRm4pIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBpdGVtcykge1xuICAgICAgICBpZiAoaXRlbXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJlxuICAgICAgICAgIHRoaXMuZmlsdGVyRm4uY2FsbCh0aGlzLm1vZGVsLCBpdGVtc1trZXldLCBrZXksIGl0ZW1zKVxuICAgICAgICApIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2goaXRlbXNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIga2V5IGluIGl0ZW1zKSB7XG4gICAgICAgIGlmIChpdGVtcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKGl0ZW1zW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh0aGlzLnNvcnRGbikgcmVzdWx0cy5zb3J0KHRoaXMuc29ydEZuKTtcbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG5GaWx0ZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKHBhc3MpIHtcbiAgdmFyIGlkcyA9IHRoaXMuaWRzKCk7XG4gIHRoaXMubW9kZWwucGFzcyhwYXNzLCB0cnVlKS5fc2V0RGlmZih0aGlzLmlkc1NlZ21lbnRzLCBpZHMpO1xufTtcblxuRmlsdGVyLnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbihmcm9tKSB7XG4gIGZyb20gPSB0aGlzLm1vZGVsLnBhdGgoZnJvbSk7XG4gIHRoaXMuZnJvbSA9IGZyb207XG4gIHRoaXMuZnJvbVNlZ21lbnRzID0gZnJvbS5zcGxpdCgnLicpO1xuICB0aGlzLmZpbHRlcnMuZnJvbU1hcFtmcm9tXSA9IHRoaXM7XG4gIHRoaXMuaWRzU2VnbWVudHMgPSBbJyRmaWx0ZXJzJywgZnJvbS5yZXBsYWNlKC9cXC4vZywgJ3wnKV07XG4gIHRoaXMudXBkYXRlKCk7XG4gIHJldHVybiB0aGlzLm1vZGVsLnJlZkxpc3QoZnJvbSwgdGhpcy5pbnB1dFBhdGgsIHRoaXMuaWRzU2VnbWVudHMuam9pbignLicpKTtcbn07XG5cbkZpbHRlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICBkZWxldGUgdGhpcy5maWx0ZXJzLmZyb21NYXBbdGhpcy5mcm9tXTtcbiAgdGhpcy5tb2RlbC5yZW1vdmVSZWZMaXN0KHRoaXMuZnJvbSk7XG4gIHRoaXMubW9kZWwuX2RlbCh0aGlzLmlkc1NlZ21lbnRzKTtcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcblxuTW9kZWwuSU5JVFMucHVzaChmdW5jdGlvbihtb2RlbCkge1xuICB2YXIgcm9vdCA9IG1vZGVsLnJvb3Q7XG4gIHJvb3QuX3JlZkxpc3RzID0gbmV3IFJlZkxpc3RzKHJvb3QpO1xuICBmb3IgKHZhciB0eXBlIGluIE1vZGVsLk1VVEFUT1JfRVZFTlRTKSB7XG4gICAgYWRkTGlzdGVuZXIocm9vdCwgdHlwZSk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihtb2RlbCwgdHlwZSkge1xuICBtb2RlbC5vbih0eXBlLCByZWZMaXN0TGlzdGVuZXIpO1xuICBmdW5jdGlvbiByZWZMaXN0TGlzdGVuZXIoc2VnbWVudHMsIGV2ZW50QXJncykge1xuICAgIHZhciBwYXNzID0gZXZlbnRBcmdzW2V2ZW50QXJncy5sZW5ndGggLSAxXTtcbiAgICAvLyBDaGVjayBmb3IgdXBkYXRlcyBvbiBvciB1bmRlcm5lYXRoIHBhdGhzXG4gICAgdmFyIGZyb21NYXAgPSBtb2RlbC5fcmVmTGlzdHMuZnJvbU1hcDtcbiAgICBmb3IgKHZhciBmcm9tIGluIGZyb21NYXApIHtcbiAgICAgIHZhciByZWZMaXN0ID0gZnJvbU1hcFtmcm9tXTtcbiAgICAgIGlmIChwYXNzLiRyZWZMaXN0ID09PSByZWZMaXN0KSBjb250aW51ZTtcbiAgICAgIHJlZkxpc3Qub25NdXRhdGlvbih0eXBlLCBzZWdtZW50cywgZXZlbnRBcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtBcnJheX0gc2VnbWVudHNcbiAqIEBwYXJhbSB7QXJyYXl9IGV2ZW50QXJnc1xuICogQHBhcmFtIHtSZWZMaXN0fSByZWZMaXN0XG4gKi9cbmZ1bmN0aW9uIHBhdGNoRnJvbUV2ZW50KHR5cGUsIHNlZ21lbnRzLCBldmVudEFyZ3MsIHJlZkxpc3QpIHtcbiAgdmFyIGZyb21MZW5ndGggPSByZWZMaXN0LmZyb21TZWdtZW50cy5sZW5ndGg7XG4gIHZhciBzZWdtZW50c0xlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgdmFyIHBhc3MgPSBldmVudEFyZ3NbZXZlbnRBcmdzLmxlbmd0aCAtIDFdO1xuICB2YXIgbW9kZWwgPSByZWZMaXN0Lm1vZGVsLnBhc3MocGFzcywgdHJ1ZSk7XG5cbiAgLy8gTXV0YXRpb24gb24gdGhlIGBmcm9tYCBvdXRwdXQgaXRzZWxmXG4gIGlmIChzZWdtZW50c0xlbmd0aCA9PT0gZnJvbUxlbmd0aCkge1xuICAgIGlmICh0eXBlID09PSAnaW5zZXJ0Jykge1xuICAgICAgdmFyIGluZGV4ID0gZXZlbnRBcmdzWzBdO1xuICAgICAgdmFyIHZhbHVlcyA9IGV2ZW50QXJnc1sxXTtcbiAgICAgIHZhciBpZHMgPSBzZXROZXdUb1ZhbHVlcyhtb2RlbCwgcmVmTGlzdCwgdmFsdWVzKTtcbiAgICAgIG1vZGVsLl9pbnNlcnQocmVmTGlzdC5pZHNTZWdtZW50cywgaW5kZXgsIGlkcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdyZW1vdmUnKSB7XG4gICAgICB2YXIgaW5kZXggPSBldmVudEFyZ3NbMF07XG4gICAgICB2YXIgaG93TWFueSA9IGV2ZW50QXJnc1sxXS5sZW5ndGg7XG4gICAgICB2YXIgaWRzID0gbW9kZWwuX3JlbW92ZShyZWZMaXN0Lmlkc1NlZ21lbnRzLCBpbmRleCwgaG93TWFueSk7XG4gICAgICAvLyBEZWxldGUgdGhlIGFwcHJvcHJpYXRlIGl0ZW1zIHVuZGVybmVhdGggYHRvYCBpZiB0aGUgYGRlbGV0ZVJlbW92ZWRgXG4gICAgICAvLyBvcHRpb24gd2FzIHNldCB0cnVlXG4gICAgICBpZiAocmVmTGlzdC5kZWxldGVSZW1vdmVkKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSByZWZMaXN0Lml0ZW1CeUlkKGlkc1tpXSk7XG4gICAgICAgICAgbW9kZWwuX2RlbChyZWZMaXN0LnRvU2VnbWVudHNCeUl0ZW0oaXRlbSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdtb3ZlJykge1xuICAgICAgdmFyIGZyb20gPSBldmVudEFyZ3NbMF07XG4gICAgICB2YXIgdG8gPSBldmVudEFyZ3NbMV07XG4gICAgICB2YXIgaG93TWFueSA9IGV2ZW50QXJnc1syXTtcbiAgICAgIG1vZGVsLl9tb3ZlKHJlZkxpc3QuaWRzU2VnbWVudHMsIGZyb20sIHRvLCBob3dNYW55KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGFuZ2Ugb2YgdGhlIGVudGlyZSBvdXRwdXRcbiAgICB2YXIgdmFsdWVzID0gKHR5cGUgPT09ICdjaGFuZ2UnKSA/XG4gICAgICBldmVudEFyZ3NbMF0gOiBtb2RlbC5fZ2V0KHJlZkxpc3QuZnJvbVNlZ21lbnRzKTtcbiAgICAvLyBTZXQgaWRzIHRvIGVtcHR5IGxpc3QgaWYgb3V0cHV0IGlzIHNldCB0byBudWxsXG4gICAgaWYgKCF2YWx1ZXMpIHtcbiAgICAgIG1vZGVsLl9zZXQocmVmTGlzdC5pZHNTZWdtZW50cywgW10pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgZW50aXJlIG91dHB1dCBpcyBzZXQsIGNyZWF0ZSBhIGxpc3Qgb2YgaWRzIGJhc2VkIG9uIHRoZSBvdXRwdXQsXG4gICAgLy8gYW5kIHVwZGF0ZSB0aGUgY29ycmVzcG9uZGluZyBpdGVtc1xuICAgIHZhciBpZHMgPSBzZXROZXdUb1ZhbHVlcyhtb2RlbCwgcmVmTGlzdCwgdmFsdWVzKTtcbiAgICBtb2RlbC5fc2V0KHJlZkxpc3QuaWRzU2VnbWVudHMsIGlkcyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgbXV0YXRpb24gaXMgb24gYSBwYXJlbnQgb2YgYGZyb21gLCB3ZSBtaWdodCBuZWVkIHRvIHJlLWNyZWF0ZSB0aGVcbiAgLy8gZW50aXJlIHJlZkxpc3Qgb3V0cHV0XG4gIGlmIChzZWdtZW50c0xlbmd0aCA8IGZyb21MZW5ndGgpIHtcbiAgICBtb2RlbC5fc2V0QXJyYXlEaWZmKHJlZkxpc3QuZnJvbVNlZ21lbnRzLCByZWZMaXN0LmdldCgpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaW5kZXggPSBzZWdtZW50c1tmcm9tTGVuZ3RoXTtcbiAgdmFyIHZhbHVlID0gbW9kZWwuX2dldChyZWZMaXN0LmZyb21TZWdtZW50cy5jb25jYXQoaW5kZXgpKTtcbiAgdmFyIHRvU2VnbWVudHMgPSByZWZMaXN0LnRvU2VnbWVudHNCeUl0ZW0odmFsdWUpO1xuXG4gIC8vIE11dGF0aW9uIHVuZGVybmVhdGggYSBjaGlsZCBvZiB0aGUgYGZyb21gIG9iamVjdC5cbiAgaWYgKHNlZ21lbnRzTGVuZ3RoID4gZnJvbUxlbmd0aCArIDEpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdNdXRhdGlvbiBvbiBkZXNjZW5kYW50IG9mIHJlZkxpc3QgYGZyb21gIHNob3VsZCBoYXZlIGJlZW4gZGVyZWZlcmVuY2VkOiAnICsgc2VnbWVudHMuam9pbignLicpO1xuICAgIG1vZGVsLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKG1lc3NhZ2UpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBPdGhlcndpc2UsIG11dGF0aW9uIG9mIGEgY2hpbGQgb2YgdGhlIGBmcm9tYCBvYmplY3RcblxuICAvLyBJZiBjaGFuZ2luZyB0aGUgaXRlbSBpdHNlbGYsIGl0IHdpbGwgYWxzbyBoYXZlIHRvIGJlIHJlLXNldCBvbiB0aGVcbiAgLy8gb3JpZ2luYWwgb2JqZWN0XG4gIGlmICh0eXBlID09PSAnY2hhbmdlJykge1xuICAgIG1vZGVsLl9zZXQodG9TZWdtZW50cywgdmFsdWUpO1xuICAgIHVwZGF0ZUlkRm9yVmFsdWUobW9kZWwsIHJlZkxpc3QsIGluZGV4LCB2YWx1ZSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIFRoZSBzYW1lIGdvZXMgZm9yIHN0cmluZyBtdXRhdGlvbnMsIHNpbmNlIHN0cmluZ3MgYXJlIGltbXV0YWJsZVxuICBpZiAodHlwZSA9PT0gJ3N0cmluZ0luc2VydCcpIHtcbiAgICB2YXIgc3RyaW5nSW5kZXggPSBldmVudEFyZ3NbMF07XG4gICAgdmFyIHN0cmluZ1ZhbHVlID0gZXZlbnRBcmdzWzFdO1xuICAgIG1vZGVsLl9zdHJpbmdJbnNlcnQodG9TZWdtZW50cywgc3RyaW5nSW5kZXgsIHN0cmluZ1ZhbHVlKTtcbiAgICB1cGRhdGVJZEZvclZhbHVlKG1vZGVsLCByZWZMaXN0LCBpbmRleCwgdmFsdWUpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZSA9PT0gJ3N0cmluZ1JlbW92ZScpIHtcbiAgICB2YXIgc3RyaW5nSW5kZXggPSBldmVudEFyZ3NbMF07XG4gICAgdmFyIGhvd01hbnkgPSBldmVudEFyZ3NbMV07XG4gICAgbW9kZWwuX3N0cmluZ1JlbW92ZSh0b1NlZ21lbnRzLCBzdHJpbmdJbmRleCwgaG93TWFueSk7XG4gICAgdXBkYXRlSWRGb3JWYWx1ZShtb2RlbCwgcmVmTGlzdCwgaW5kZXgsIHZhbHVlKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdpbnNlcnQnIHx8IHR5cGUgPT09ICdyZW1vdmUnIHx8IHR5cGUgPT09ICdtb3ZlJykge1xuICAgIHZhciBtZXNzYWdlID0gJ0FycmF5IG11dGF0aW9uIG9uIGNoaWxkIG9mIHJlZkxpc3QgYGZyb21gIHNob3VsZCBoYXZlIGJlZW4gZGVyZWZlcmVuY2VkOiAnICsgc2VnbWVudHMuam9pbignLicpO1xuICAgIG1vZGVsLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKG1lc3NhZ2UpKTtcbiAgICByZXR1cm47XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtNb2RlbH0gbW9kZWxcbiAqIEBwYXJhbSB7UmVmTGlzdH0gcmVmTGlzdFxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzXG4gKi9cbmZ1bmN0aW9uIHNldE5ld1RvVmFsdWVzKG1vZGVsLCByZWZMaXN0LCB2YWx1ZXMsIGZuKSB7XG4gIHZhciBpZHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgdmFyIGlkID0gcmVmTGlzdC5pZEJ5SXRlbSh2YWx1ZSk7XG4gICAgaWYgKGlkID09PSB2b2lkIDAgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWQgPSB2YWx1ZS5pZCA9IG1vZGVsLmlkKCk7XG4gICAgfVxuICAgIHZhciB0b1NlZ21lbnRzID0gcmVmTGlzdC50b1NlZ21lbnRzQnlJdGVtKHZhbHVlKTtcbiAgICBpZiAoaWQgPT09IHZvaWQgMCB8fCB0b1NlZ21lbnRzID09PSB2b2lkIDApIHtcbiAgICAgIHZhciBtZXNzYWdlID0gJ1VuYWJsZSB0byBhZGQgaXRlbSB0byByZWZMaXN0OiAnICsgdmFsdWU7XG4gICAgICByZXR1cm4gbW9kZWwuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IobWVzc2FnZSkpO1xuICAgIH1cbiAgICBpZiAobW9kZWwuX2dldCh0b1NlZ21lbnRzKSAhPT0gdmFsdWUpIHtcbiAgICAgIG1vZGVsLl9zZXQodG9TZWdtZW50cywgdmFsdWUpO1xuICAgIH1cbiAgICBpZHMucHVzaChpZCk7XG4gIH1cbiAgcmV0dXJuIGlkcztcbn1cbmZ1bmN0aW9uIHVwZGF0ZUlkRm9yVmFsdWUobW9kZWwsIHJlZkxpc3QsIGluZGV4LCB2YWx1ZSkge1xuICB2YXIgaWQgPSByZWZMaXN0LmlkQnlJdGVtKHZhbHVlKTtcbiAgdmFyIG91dFNlZ21lbnRzID0gcmVmTGlzdC5pZHNTZWdtZW50cy5jb25jYXQoaW5kZXgpO1xuICBtb2RlbC5fc2V0KG91dFNlZ21lbnRzLCBpZCk7XG59XG5cbmZ1bmN0aW9uIHBhdGNoVG9FdmVudCh0eXBlLCBzZWdtZW50cywgZXZlbnRBcmdzLCByZWZMaXN0KSB7XG4gIHZhciB0b0xlbmd0aCA9IHJlZkxpc3QudG9TZWdtZW50cy5sZW5ndGg7XG4gIHZhciBzZWdtZW50c0xlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgdmFyIHBhc3MgPSBldmVudEFyZ3NbZXZlbnRBcmdzLmxlbmd0aCAtIDFdO1xuICB2YXIgbW9kZWwgPSByZWZMaXN0Lm1vZGVsLnBhc3MocGFzcywgdHJ1ZSk7XG5cbiAgLy8gTXV0YXRpb24gb24gdGhlIGB0b2Agb2JqZWN0IGl0c2VsZlxuICBpZiAoc2VnbWVudHNMZW5ndGggPT09IHRvTGVuZ3RoKSB7XG4gICAgaWYgKHR5cGUgPT09ICdpbnNlcnQnKSB7XG4gICAgICB2YXIgaW5zZXJ0SW5kZXggPSBldmVudEFyZ3NbMF07XG4gICAgICB2YXIgdmFsdWVzID0gZXZlbnRBcmdzWzFdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICB2YXIgaW5kaWNlcyA9IHJlZkxpc3QuaW5kaWNlc0J5SXRlbSh2YWx1ZSk7XG4gICAgICAgIGlmICghaW5kaWNlcykgY29udGludWU7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW5kaWNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBvdXRTZWdtZW50cyA9IHJlZkxpc3QuZnJvbVNlZ21lbnRzLmNvbmNhdChpbmRpY2VzW2pdKTtcbiAgICAgICAgICBtb2RlbC5fc2V0KG91dFNlZ21lbnRzLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ3JlbW92ZScpIHtcbiAgICAgIHZhciByZW1vdmVJbmRleCA9IGV2ZW50QXJnc1swXTtcbiAgICAgIHZhciB2YWx1ZXMgPSBldmVudEFyZ3NbMV07XG4gICAgICB2YXIgaG93TWFueSA9IHZhbHVlcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gcmVtb3ZlSW5kZXgsIGxlbiA9IHJlbW92ZUluZGV4ICsgaG93TWFueTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBpbmRpY2VzID0gcmVmTGlzdC5pbmRpY2VzQnlJdGVtKHZhbHVlc1tpXSk7XG4gICAgICAgIGlmICghaW5kaWNlcykgY29udGludWU7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBpbmRpY2VzTGVuID0gaW5kaWNlcy5sZW5ndGg7IGogPCBpbmRpY2VzTGVuOyBqKyspIHtcbiAgICAgICAgICB2YXIgb3V0U2VnbWVudHMgPSByZWZMaXN0LmZyb21TZWdtZW50cy5jb25jYXQoaW5kaWNlc1tqXSk7XG4gICAgICAgICAgbW9kZWwuX3NldChvdXRTZWdtZW50cywgdm9pZCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnbW92ZScpIHtcbiAgICAgIC8vIE1vdmluZyBpdGVtcyBpbiB0aGUgYHRvYCBvYmplY3Qgc2hvdWxkIGhhdmUgbm8gZWZmZWN0IG9uIHRoZSBvdXRwdXRcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICAvLyBNdXRhdGlvbiBvbiBvciBhYm92ZSB0aGUgYHRvYCBvYmplY3RcbiAgaWYgKHNlZ21lbnRzTGVuZ3RoIDw9IHRvTGVuZ3RoKSB7XG4gICAgLy8gSWYgdGhlIGVudGlyZSBgdG9gIG9iamVjdCBpcyB1cGRhdGVkLCB3ZSBuZWVkIHRvIHJlLWNyZWF0ZSB0aGVcbiAgICAvLyBlbnRpcmUgcmVmTGlzdCBvdXRwdXQgYW5kIGFwcGx5IHdoYXQgaXMgZGlmZmVyZW50XG4gICAgbW9kZWwuX3NldEFycmF5RGlmZihyZWZMaXN0LmZyb21TZWdtZW50cywgcmVmTGlzdC5nZXQoKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gTXV0YXRpb24gdW5kZXJuZWF0aCBhIGNoaWxkIG9mIHRoZSBgdG9gIG9iamVjdC4gVGhlIGl0ZW0gd2lsbCBhbHJlYWR5XG4gIC8vIGJlIHVwIHRvIGRhdGUsIHNpbmNlIGl0IGlzIHVuZGVyIGFuIG9iamVjdCByZWZlcmVuY2UuIEp1c3QgcmUtZW1pdFxuICBpZiAoc2VnbWVudHNMZW5ndGggPiB0b0xlbmd0aCArIDEpIHtcbiAgICB2YXIgdmFsdWUgPSBtb2RlbC5fZ2V0KHNlZ21lbnRzLnNsaWNlKDAsIHRvTGVuZ3RoICsgMSkpO1xuICAgIHZhciBpbmRpY2VzID0gcmVmTGlzdC5pbmRpY2VzQnlJdGVtKHZhbHVlKTtcbiAgICBpZiAoIWluZGljZXMpIHJldHVybjtcbiAgICB2YXIgcmVtYWluaW5nID0gc2VnbWVudHMuc2xpY2UodG9MZW5ndGggKyAxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpbmRleCA9IGluZGljZXNbaV07XG4gICAgICB2YXIgZGVyZWZlcmVuY2VkID0gcmVmTGlzdC5mcm9tU2VnbWVudHMuY29uY2F0KGluZGV4LCByZW1haW5pbmcpO1xuICAgICAgZGVyZWZlcmVuY2VkID0gbW9kZWwuX2RlcmVmZXJlbmNlKGRlcmVmZXJlbmNlZCwgbnVsbCwgcmVmTGlzdCk7XG4gICAgICBldmVudEFyZ3MgPSBldmVudEFyZ3Muc2xpY2UoKTtcbiAgICAgIGV2ZW50QXJnc1tldmVudEFyZ3MubGVuZ3RoIC0gMV0gPSBtb2RlbC5fcGFzcztcbiAgICAgIG1vZGVsLmVtaXQodHlwZSwgZGVyZWZlcmVuY2VkLCBldmVudEFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBPdGhlcndpc2UsIG11dGF0aW9uIG9mIGEgY2hpbGQgb2YgdGhlIGB0b2Agb2JqZWN0XG5cbiAgLy8gSWYgY2hhbmdpbmcgdGhlIGl0ZW0gaXRzZWxmLCBpdCB3aWxsIGFsc28gaGF2ZSB0byBiZSByZS1zZXQgb24gdGhlXG4gIC8vIGFycmF5IGNyZWF0ZWQgYnkgdGhlIHJlZkxpc3RcbiAgaWYgKHR5cGUgPT09ICdjaGFuZ2UnIHx8IHR5cGUgPT09ICdsb2FkJyB8fCB0eXBlID09PSAndW5sb2FkJykge1xuICAgIHZhciB2YWx1ZSwgcHJldmlvdXM7XG4gICAgaWYgKHR5cGUgPT09ICdjaGFuZ2UnKSB7XG4gICAgICB2YWx1ZSA9IGV2ZW50QXJnc1swXTtcbiAgICAgIHByZXZpb3VzID0gZXZlbnRBcmdzWzFdO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2xvYWQnKSB7XG4gICAgICB2YWx1ZSA9IGV2ZW50QXJnc1swXTtcbiAgICAgIHByZXZpb3VzID0gdm9pZCAwO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3VubG9hZCcpIHtcbiAgICAgIHZhbHVlID0gdm9pZCAwO1xuICAgICAgcHJldmlvdXMgPSBldmVudEFyZ3NbMF07XG4gICAgfVxuICAgIHZhciBuZXdJbmRpY2VzID0gcmVmTGlzdC5pbmRpY2VzQnlJdGVtKHZhbHVlKTtcbiAgICB2YXIgb2xkSW5kaWNlcyA9IHJlZkxpc3QuaW5kaWNlc0J5SXRlbShwcmV2aW91cyk7XG4gICAgaWYgKCFuZXdJbmRpY2VzICYmICFvbGRJbmRpY2VzKSByZXR1cm47XG4gICAgaWYgKG9sZEluZGljZXMgJiYgIWVxdWl2YWxlbnRBcnJheXMob2xkSW5kaWNlcywgbmV3SW5kaWNlcykpIHtcbiAgICAgIC8vIFRoZSBjaGFuZ2VkIGl0ZW0gdXNlZCB0byByZWZlciB0byBzb21lIGluZGljZXMsIGJ1dCBubyBsb25nZXIgZG9lc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbGRJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvdXRTZWdtZW50cyA9IHJlZkxpc3QuZnJvbVNlZ21lbnRzLmNvbmNhdChvbGRJbmRpY2VzW2ldKTtcbiAgICAgICAgbW9kZWwuX3NldChvdXRTZWdtZW50cywgdm9pZCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5ld0luZGljZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3SW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgb3V0U2VnbWVudHMgPSByZWZMaXN0LmZyb21TZWdtZW50cy5jb25jYXQobmV3SW5kaWNlc1tpXSk7XG4gICAgICAgIG1vZGVsLl9zZXQob3V0U2VnbWVudHMsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gbW9kZWwuX2dldChzZWdtZW50cy5zbGljZSgwLCB0b0xlbmd0aCArIDEpKTtcbiAgdmFyIGluZGljZXMgPSByZWZMaXN0LmluZGljZXNCeUl0ZW0odmFsdWUpO1xuICBpZiAoIWluZGljZXMpIHJldHVybjtcblxuICAvLyBUaGUgc2FtZSBnb2VzIGZvciBzdHJpbmcgbXV0YXRpb25zLCBzaW5jZSBzdHJpbmdzIGFyZSBpbW11dGFibGVcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmdJbnNlcnQnKSB7XG4gICAgdmFyIHN0cmluZ0luZGV4ID0gZXZlbnRBcmdzWzBdO1xuICAgIHZhciB2YWx1ZSA9IGV2ZW50QXJnc1sxXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdXRTZWdtZW50cyA9IHJlZkxpc3QuZnJvbVNlZ21lbnRzKGluZGljZXNbaV0pO1xuICAgICAgbW9kZWwuX3N0cmluZ0luc2VydChvdXRTZWdtZW50cywgc3RyaW5nSW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlID09PSAnc3RyaW5nUmVtb3ZlJykge1xuICAgIHZhciBzdHJpbmdJbmRleCA9IGV2ZW50QXJnc1swXTtcbiAgICB2YXIgaG93TWFueSA9IGV2ZW50QXJnc1sxXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdXRTZWdtZW50cyA9IHJlZkxpc3QuZnJvbVNlZ21lbnRzKGluZGljZXNbaV0pO1xuICAgICAgbW9kZWwuX3N0cmluZ1JlbW92ZShvdXRTZWdtZW50cywgc3RyaW5nSW5kZXgsIGhvd01hbnkpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdpbnNlcnQnIHx8IHR5cGUgPT09ICdyZW1vdmUnIHx8IHR5cGUgPT09ICdtb3ZlJykge1xuICAgIC8vIEFycmF5IG11dGF0aW9ucyB3aWxsIGhhdmUgYWxyZWFkeSBiZWVuIHVwZGF0ZWQgdmlhIGFuIG9iamVjdFxuICAgIC8vIHJlZmVyZW5jZSwgc28gb25seSByZS1lbWl0XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVyZWZlcmVuY2VkID0gcmVmTGlzdC5mcm9tU2VnbWVudHMuY29uY2F0KGluZGljZXNbaV0pO1xuICAgICAgZGVyZWZlcmVuY2VkID0gbW9kZWwuX2RlcmVmZXJlbmNlKGRlcmVmZXJlbmNlZCwgbnVsbCwgcmVmTGlzdCk7XG4gICAgICBldmVudEFyZ3MgPSBldmVudEFyZ3Muc2xpY2UoKTtcbiAgICAgIGV2ZW50QXJnc1tldmVudEFyZ3MubGVuZ3RoIC0gMV0gPSBtb2RlbC5fcGFzcztcbiAgICAgIG1vZGVsLmVtaXQodHlwZSwgZGVyZWZlcmVuY2VkLCBldmVudEFyZ3MpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZXF1aXZhbGVudEFycmF5cyhhLCBiKSB7XG4gIGlmICghYSB8fCAhYikgcmV0dXJuIGZhbHNlO1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHBhdGNoSWRzRXZlbnQodHlwZSwgc2VnbWVudHMsIGV2ZW50QXJncywgcmVmTGlzdCkge1xuICB2YXIgaWRzTGVuZ3RoID0gcmVmTGlzdC5pZHNTZWdtZW50cy5sZW5ndGg7XG4gIHZhciBzZWdtZW50c0xlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgdmFyIHBhc3MgPSBldmVudEFyZ3NbZXZlbnRBcmdzLmxlbmd0aCAtIDFdO1xuICB2YXIgbW9kZWwgPSByZWZMaXN0Lm1vZGVsLnBhc3MocGFzcywgdHJ1ZSk7XG5cbiAgLy8gQW4gYXJyYXkgbXV0YXRpb24gb2YgdGhlIGlkcyBzaG91bGQgYmUgbWlycm9yZWQgd2l0aCBhIGxpa2UgY2hhbmdlIGluXG4gIC8vIHRoZSBvdXRwdXQgYXJyYXlcbiAgaWYgKHNlZ21lbnRzTGVuZ3RoID09PSBpZHNMZW5ndGgpIHtcbiAgICBpZiAodHlwZSA9PT0gJ2luc2VydCcpIHtcbiAgICAgIHZhciBpbmRleCA9IGV2ZW50QXJnc1swXTtcbiAgICAgIHZhciBpbnNlcnRlZCA9IGV2ZW50QXJnc1sxXTtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5zZXJ0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcmVmTGlzdC5pdGVtQnlJZChpbnNlcnRlZFtpXSk7XG4gICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIG1vZGVsLl9pbnNlcnQocmVmTGlzdC5mcm9tU2VnbWVudHMsIGluZGV4LCB2YWx1ZXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAncmVtb3ZlJykge1xuICAgICAgdmFyIGluZGV4ID0gZXZlbnRBcmdzWzBdO1xuICAgICAgdmFyIGhvd01hbnkgPSBldmVudEFyZ3NbMV0ubGVuZ3RoO1xuICAgICAgbW9kZWwuX3JlbW92ZShyZWZMaXN0LmZyb21TZWdtZW50cywgaW5kZXgsIGhvd01hbnkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnbW92ZScpIHtcbiAgICAgIHZhciBmcm9tID0gZXZlbnRBcmdzWzBdO1xuICAgICAgdmFyIHRvID0gZXZlbnRBcmdzWzFdO1xuICAgICAgdmFyIGhvd01hbnkgPSBldmVudEFyZ3NbMl07XG4gICAgICBtb2RlbC5fbW92ZShyZWZMaXN0LmZyb21TZWdtZW50cywgZnJvbSwgdG8sIGhvd01hbnkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIC8vIE11dGF0aW9uIG9uIHRoZSBgaWRzYCBsaXN0IGl0c2VsZlxuICBpZiAoc2VnbWVudHNMZW5ndGggPD0gaWRzTGVuZ3RoKSB7XG4gICAgLy8gSWYgdGhlIGVudGlyZSBgaWRzYCBhcnJheSBpcyB1cGRhdGVkLCB3ZSBuZWVkIHRvIHJlLWNyZWF0ZSB0aGVcbiAgICAvLyBlbnRpcmUgcmVmTGlzdCBvdXRwdXQgYW5kIGFwcGx5IHdoYXQgaXMgZGlmZmVyZW50XG4gICAgbW9kZWwuX3NldEFycmF5RGlmZihyZWZMaXN0LmZyb21TZWdtZW50cywgcmVmTGlzdC5nZXQoKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlLCBkaXJlY3QgbXV0YXRpb24gb2YgYSBjaGlsZCBpbiB0aGUgYGlkc2Agb2JqZWN0IG9yIG11dGF0aW9uXG4gIC8vIHVuZGVybmVhdGggYW4gaXRlbSBpbiB0aGUgYGlkc2AgbGlzdC4gVXBkYXRlIHRoZSBpdGVtIGZvciB0aGUgYXBwcm9wcmlhdGVcbiAgLy8gaWQgaWYgaXQgaGFzIGNoYW5nZWRcbiAgdmFyIGluZGV4ID0gc2VnbWVudHNbaWRzTGVuZ3RoXTtcbiAgdmFyIGlkID0gcmVmTGlzdC5pZEJ5SW5kZXgoaW5kZXgpO1xuICB2YXIgaXRlbSA9IHJlZkxpc3QuaXRlbUJ5SWQoaWQpO1xuICB2YXIgaXRlbVNlZ21lbnRzID0gcmVmTGlzdC5mcm9tU2VnbWVudHMuY29uY2F0KGluZGV4KTtcbiAgaWYgKG1vZGVsLl9nZXQoaXRlbVNlZ21lbnRzKSAhPT0gaXRlbSkge1xuICAgIG1vZGVsLl9zZXQoaXRlbVNlZ21lbnRzLCBpdGVtKTtcbiAgfVxufVxuXG5Nb2RlbC5wcm90b3R5cGUucmVmTGlzdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZnJvbSwgdG8sIGlkcywgb3B0aW9ucztcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB0byA9IGFyZ3VtZW50c1swXTtcbiAgICBpZHMgPSBhcmd1bWVudHNbMV07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIGlmICh0aGlzLmlzUGF0aChhcmd1bWVudHNbMl0pKSB7XG4gICAgICBmcm9tID0gYXJndW1lbnRzWzBdO1xuICAgICAgdG8gPSBhcmd1bWVudHNbMV07XG4gICAgICBpZHMgPSBhcmd1bWVudHNbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvID0gYXJndW1lbnRzWzBdO1xuICAgICAgaWRzID0gYXJndW1lbnRzWzFdO1xuICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50c1syXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZnJvbSA9IGFyZ3VtZW50c1swXTtcbiAgICB0byA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZHMgPSBhcmd1bWVudHNbMl07XG4gICAgb3B0aW9ucyA9IGFyZ3VtZW50c1szXTtcbiAgfVxuICB2YXIgZnJvbVBhdGggPSB0aGlzLnBhdGgoZnJvbSk7XG4gIGlmIChBcnJheS5pc0FycmF5KHRvKSkge1xuICAgIHZhciB0b1BhdGggPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b1BhdGgucHVzaCh0aGlzLnBhdGgodG9baV0pKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRvUGF0aCA9IHRoaXMucGF0aCh0byk7XG4gIH1cbiAgdmFyIGlkc1BhdGggPSB0aGlzLnBhdGgoaWRzKTtcbiAgdmFyIHJlZkxpc3QgPSB0aGlzLnJvb3QuX3JlZkxpc3RzLmFkZChmcm9tUGF0aCwgdG9QYXRoLCBpZHNQYXRoLCBvcHRpb25zKTtcbiAgdGhpcy5wYXNzKHskcmVmTGlzdDogcmVmTGlzdH0pLl9zZXRBcnJheURpZmYocmVmTGlzdC5mcm9tU2VnbWVudHMsIHJlZkxpc3QuZ2V0KCkpO1xuICByZXR1cm4gdGhpcy5zY29wZShmcm9tUGF0aCk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUucmVtb3ZlUmVmTGlzdCA9IGZ1bmN0aW9uKGZyb20pIHtcbiAgdmFyIGZyb21QYXRoID0gdGhpcy5wYXRoKGZyb20pO1xuICB2YXIgcmVmTGlzdCA9IHRoaXMucm9vdC5fcmVmTGlzdHMucmVtb3ZlKGZyb21QYXRoKTtcbiAgaWYgKHJlZkxpc3QpIHRoaXMuX2RlbChyZWZMaXN0LmZyb21TZWdtZW50cyk7XG59O1xuXG5mdW5jdGlvbiBSZWZMaXN0KG1vZGVsLCBmcm9tLCB0bywgaWRzLCBvcHRpb25zKSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbCAmJiBtb2RlbC5wYXNzKHskcmVmTGlzdDogdGhpc30pO1xuICB0aGlzLmZyb20gPSBmcm9tO1xuICB0aGlzLnRvID0gdG87XG4gIHRoaXMuaWRzID0gaWRzO1xuICB0aGlzLmZyb21TZWdtZW50cyA9IGZyb20gJiYgZnJvbS5zcGxpdCgnLicpO1xuICB0aGlzLnRvU2VnbWVudHMgPSB0byAmJiB0by5zcGxpdCgnLicpO1xuICB0aGlzLmlkc1NlZ21lbnRzID0gaWRzICYmIGlkcy5zcGxpdCgnLicpO1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLmRlbGV0ZVJlbW92ZWQgPSBvcHRpb25zICYmIG9wdGlvbnMuZGVsZXRlUmVtb3ZlZDtcbn1cblxuLy8gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gYXNzdW1lcyB0aGF0IHRoZSBpZHMgYXJyYXkgaXMgYSBmbGF0IGxpc3Qgb2Zcbi8vIGtleXMgb24gdGhlIHRvIG9iamVjdC4gSWRlYWxseSwgdGhpcyBtYXBwaW5nIGNvdWxkIGJlIGN1c3RvbWl6ZWQgdmlhXG4vLyBpbmhlcml0aW5nIGZyb20gUmVmTGlzdCBhbmQgb3ZlcnJpZGluZyB0aGVzZSBtZXRob2RzIHdpdGhvdXQgaGF2aW5nIHRvXG4vLyBtb2RpZnkgdGhlIGFib3ZlIGV2ZW50IGhhbmRsaW5nIGNvZGUuXG4vLyBcbi8vIEluIHRoZSBkZWZhdWx0IHJlZkxpc3QgaW1wbGVtZW50YXRpb24sIGBrZXlgIGFuZCBgaWRgIGFyZSBlcXVhbC5cbi8vIFxuLy8gVGVybXMgaW4gdGhlIGJlbG93IG1ldGhvZHM6XG4vLyAgIGBpdGVtYCAgLSBPYmplY3Qgb24gdGhlIGB0b2AgcGF0aCwgd2hpY2ggZ2V0cyBtaXJyb3JlZCBvbiB0aGUgYGZyb21gIHBhdGhcbi8vICAgYGtleWAgICAtIFRoZSBwcm9wZXJ0eSB1bmRlciBgdG9gIGF0IHdoaWNoIGFuIGl0ZW0gaXMgbG9jYXRlZFxuLy8gICBgaWRgICAgIC0gU3RyaW5nIG9yIG9iamVjdCBpbiB0aGUgYXJyYXkgYXQgdGhlIGBpZHNgIHBhdGhcbi8vICAgYGluZGV4YCAtIFRoZSBpbmRleCBvZiBhbiBpZCwgd2hpY2ggY29ycmVzcG9uZHMgdG8gYW4gaW5kZXggb24gYGZyb21gXG5SZWZMaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGlkcyA9IHRoaXMubW9kZWwuX2dldCh0aGlzLmlkc1NlZ21lbnRzKTtcbiAgaWYgKCFpZHMpIHJldHVybiBbXTtcbiAgdmFyIGl0ZW1zID0gdGhpcy5tb2RlbC5fZ2V0KHRoaXMudG9TZWdtZW50cyk7XG4gIHZhciBvdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gaWRzW2ldO1xuICAgIG91dC5wdXNoKGl0ZW1zICYmIGl0ZW1zW2tleV0pO1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuUmVmTGlzdC5wcm90b3R5cGUuZGVyZWZlcmVuY2UgPSBmdW5jdGlvbihzZWdtZW50cywgaSkge1xuICB2YXIgcmVtYWluaW5nID0gc2VnbWVudHMuc2xpY2UoaSArIDEpO1xuICB2YXIga2V5ID0gdGhpcy5pZEJ5SW5kZXgocmVtYWluaW5nWzBdKTtcbiAgaWYgKGtleSA9PSBudWxsKSByZXR1cm4gW107XG4gIHJlbWFpbmluZ1swXSA9IGtleTtcbiAgcmV0dXJuIHRoaXMudG9TZWdtZW50cy5jb25jYXQocmVtYWluaW5nKTtcbn07XG5SZWZMaXN0LnByb3RvdHlwZS50b1NlZ21lbnRzQnlJdGVtID0gZnVuY3Rpb24oaXRlbSkge1xuICB2YXIga2V5ID0gdGhpcy5pZEJ5SXRlbShpdGVtKTtcbiAgaWYgKGtleSA9PT0gdm9pZCAwKSByZXR1cm47XG4gIHJldHVybiB0aGlzLnRvU2VnbWVudHMuY29uY2F0KGtleSk7XG59O1xuUmVmTGlzdC5wcm90b3R5cGUuaWRCeUl0ZW0gPSBmdW5jdGlvbihpdGVtKSB7XG4gIGlmIChpdGVtICYmIGl0ZW0uaWQpIHJldHVybiBpdGVtLmlkO1xuICB2YXIgaXRlbXMgPSB0aGlzLm1vZGVsLl9nZXQodGhpcy50b1NlZ21lbnRzKTtcbiAgZm9yICh2YXIga2V5IGluIGl0ZW1zKSB7XG4gICAgaWYgKGl0ZW0gPT09IGl0ZW1zW2tleV0pIHJldHVybiBrZXk7XG4gIH1cbn07XG5SZWZMaXN0LnByb3RvdHlwZS5pbmRpY2VzQnlJdGVtID0gZnVuY3Rpb24oaXRlbSkge1xuICB2YXIgaWQgPSB0aGlzLmlkQnlJdGVtKGl0ZW0pO1xuICB2YXIgaWRzID0gdGhpcy5tb2RlbC5fZ2V0KHRoaXMuaWRzU2VnbWVudHMpO1xuICBpZiAoIWlkcykgcmV0dXJuO1xuICB2YXIgaW5kaWNlcztcbiAgdmFyIGluZGV4ID0gLTE7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaW5kZXggPSBpZHMuaW5kZXhPZihpZCwgaW5kZXggKyAxKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSBicmVhaztcbiAgICBpZiAoaW5kaWNlcykge1xuICAgICAgaW5kaWNlcy5wdXNoKGluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kaWNlcyA9IFtpbmRleF07XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmRpY2VzO1xufTtcblJlZkxpc3QucHJvdG90eXBlLml0ZW1CeUlkID0gZnVuY3Rpb24oaWQpIHtcbiAgcmV0dXJuIHRoaXMubW9kZWwuX2dldCh0aGlzLnRvU2VnbWVudHMuY29uY2F0KGlkKSk7XG59O1xuUmVmTGlzdC5wcm90b3R5cGUuaWRCeUluZGV4ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgcmV0dXJuIHRoaXMubW9kZWwuX2dldCh0aGlzLmlkc1NlZ21lbnRzLmNvbmNhdChpbmRleCkpO1xufTtcblJlZkxpc3QucHJvdG90eXBlLm9uTXV0YXRpb24gPSBmdW5jdGlvbih0eXBlLCBzZWdtZW50cywgZXZlbnRBcmdzKSB7XG4gIGlmICh1dGlsLm1heUltcGFjdCh0aGlzLnRvU2VnbWVudHMsIHNlZ21lbnRzKSkge1xuICAgIHBhdGNoVG9FdmVudCh0eXBlLCBzZWdtZW50cywgZXZlbnRBcmdzLCB0aGlzKTtcbiAgfSBlbHNlIGlmICh1dGlsLm1heUltcGFjdCh0aGlzLmlkc1NlZ21lbnRzLCBzZWdtZW50cykpIHtcbiAgICBwYXRjaElkc0V2ZW50KHR5cGUsIHNlZ21lbnRzLCBldmVudEFyZ3MsIHRoaXMpO1xuICB9IGVsc2UgaWYgKHV0aWwubWF5SW1wYWN0KHRoaXMuZnJvbVNlZ21lbnRzLCBzZWdtZW50cykpIHtcbiAgICBwYXRjaEZyb21FdmVudCh0eXBlLCBzZWdtZW50cywgZXZlbnRBcmdzLCB0aGlzKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gRnJvbU1hcCgpIHt9XG5cbmZ1bmN0aW9uIFJlZkxpc3RzKG1vZGVsKSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgdGhpcy5mcm9tTWFwID0gbmV3IEZyb21NYXA7XG59XG5cblJlZkxpc3RzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihmcm9tLCB0bywgaWRzLCBvcHRpb25zKSB7XG4gIHZhciByZWZMaXN0ID0gbmV3IFJlZkxpc3QodGhpcy5tb2RlbCwgZnJvbSwgdG8sIGlkcywgb3B0aW9ucyk7XG4gIHRoaXMuZnJvbU1hcFtmcm9tXSA9IHJlZkxpc3Q7XG4gIHJldHVybiByZWZMaXN0O1xufTtcblxuUmVmTGlzdHMucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGZyb20pIHtcbiAgdmFyIHJlZkxpc3QgPSB0aGlzLmZyb21NYXBbZnJvbV07XG4gIGRlbGV0ZSB0aGlzLmZyb21NYXBbZnJvbV07XG4gIHJldHVybiByZWZMaXN0O1xufTtcblxuUmVmTGlzdHMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3V0ID0gW107XG4gIGZvciAodmFyIGZyb20gaW4gdGhpcy5mcm9tTWFwKSB7XG4gICAgdmFyIHJlZkxpc3QgPSB0aGlzLmZyb21NYXBbZnJvbV07XG4gICAgb3V0LnB1c2goW3JlZkxpc3QuZnJvbSwgcmVmTGlzdC50bywgcmVmTGlzdC5pZHMsIHJlZkxpc3Qub3B0aW9uc10pO1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyk7XG5cbk1vZGVsLklOSVRTLnB1c2goZnVuY3Rpb24obW9kZWwpIHtcbiAgdmFyIHJvb3QgPSBtb2RlbC5yb290O1xuICByb290Ll9yZWZzID0gbmV3IFJlZnMocm9vdCk7XG4gIGFkZEluZGV4TGlzdGVuZXJzKHJvb3QpO1xuICBhZGRMaXN0ZW5lcihyb290LCAnY2hhbmdlJywgcmVmQ2hhbmdlKTtcbiAgYWRkTGlzdGVuZXIocm9vdCwgJ2xvYWQnLCByZWZMb2FkKTtcbiAgYWRkTGlzdGVuZXIocm9vdCwgJ3VubG9hZCcsIHJlZlVubG9hZCk7XG4gIGFkZExpc3RlbmVyKHJvb3QsICdpbnNlcnQnLCByZWZJbnNlcnQpO1xuICBhZGRMaXN0ZW5lcihyb290LCAncmVtb3ZlJywgcmVmUmVtb3ZlKTtcbiAgYWRkTGlzdGVuZXIocm9vdCwgJ21vdmUnLCByZWZNb3ZlKTtcbiAgYWRkTGlzdGVuZXIocm9vdCwgJ3N0cmluZ0luc2VydCcsIHJlZlN0cmluZ0luc2VydCk7XG4gIGFkZExpc3RlbmVyKHJvb3QsICdzdHJpbmdSZW1vdmUnLCByZWZTdHJpbmdSZW1vdmUpO1xufSk7XG5cbmZ1bmN0aW9uIGFkZEluZGV4TGlzdGVuZXJzKG1vZGVsKSB7XG4gIG1vZGVsLm9uKCdpbnNlcnQnLCBmdW5jdGlvbiByZWZJbnNlcnRJbmRleChzZWdtZW50cywgZXZlbnRBcmdzKSB7XG4gICAgdmFyIGluZGV4ID0gZXZlbnRBcmdzWzBdO1xuICAgIHZhciBob3dNYW55ID0gZXZlbnRBcmdzWzFdLmxlbmd0aDtcbiAgICBmdW5jdGlvbiBwYXRjaEluc2VydChyZWZJbmRleCkge1xuICAgICAgcmV0dXJuIChpbmRleCA8PSByZWZJbmRleCkgPyByZWZJbmRleCArIGhvd01hbnkgOiByZWZJbmRleDtcbiAgICB9XG4gICAgb25JbmRleENoYW5nZShzZWdtZW50cywgcGF0Y2hJbnNlcnQpO1xuICB9KTtcbiAgbW9kZWwub24oJ3JlbW92ZScsIGZ1bmN0aW9uIHJlZlJlbW92ZUluZGV4KHNlZ21lbnRzLCBldmVudEFyZ3MpIHtcbiAgICB2YXIgaW5kZXggPSBldmVudEFyZ3NbMF07XG4gICAgdmFyIGhvd01hbnkgPSBldmVudEFyZ3NbMV0ubGVuZ3RoO1xuICAgIGZ1bmN0aW9uIHBhdGNoUmVtb3ZlKHJlZkluZGV4KSB7XG4gICAgICByZXR1cm4gKGluZGV4IDw9IHJlZkluZGV4KSA/IHJlZkluZGV4IC0gaG93TWFueSA6IHJlZkluZGV4O1xuICAgIH1cbiAgICBvbkluZGV4Q2hhbmdlKHNlZ21lbnRzLCBwYXRjaFJlbW92ZSk7XG4gIH0pO1xuICBtb2RlbC5vbignbW92ZScsIGZ1bmN0aW9uIHJlZk1vdmVJbmRleChzZWdtZW50cywgZXZlbnRBcmdzKSB7XG4gICAgdmFyIGZyb20gPSBldmVudEFyZ3NbMF07XG4gICAgdmFyIHRvID0gZXZlbnRBcmdzWzFdO1xuICAgIHZhciBob3dNYW55ID0gZXZlbnRBcmdzWzJdO1xuICAgIGZ1bmN0aW9uIHBhdGNoTW92ZShyZWZJbmRleCkge1xuICAgICAgLy8gSWYgdGhlIGluZGV4IHdhcyBtb3ZlZCBpdHNlbGZcbiAgICAgIGlmIChmcm9tIDw9IHJlZkluZGV4ICYmIHJlZkluZGV4IDwgZnJvbSArIGhvd01hbnkpIHtcbiAgICAgICAgcmV0dXJuIHJlZkluZGV4ICsgdG8gLSBmcm9tO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIHBhcnQgb2YgYSBtb3ZlXG4gICAgICBpZiAoZnJvbSA8PSByZWZJbmRleCkgcmVmSW5kZXggLT0gaG93TWFueTtcbiAgICAgIC8vIEluc2VydCBwYXJ0IG9mIGEgbW92ZVxuICAgICAgaWYgKHRvIDw9IHJlZkluZGV4KSByZWZJbmRleCArPSBob3dNYW55O1xuICAgICAgcmV0dXJuIHJlZkluZGV4O1xuICAgIH1cbiAgICBvbkluZGV4Q2hhbmdlKHNlZ21lbnRzLCBwYXRjaE1vdmUpO1xuICB9KTtcbiAgZnVuY3Rpb24gb25JbmRleENoYW5nZShzZWdtZW50cywgcGF0Y2gpIHtcbiAgICB2YXIgZnJvbU1hcCA9IG1vZGVsLl9yZWZzLmZyb21NYXA7XG4gICAgZm9yICh2YXIgZnJvbSBpbiBmcm9tTWFwKSB7XG4gICAgICB2YXIgcmVmID0gZnJvbU1hcFtmcm9tXTtcbiAgICAgIGlmICghKHJlZi51cGRhdGVJbmRpY2VzICYmXG4gICAgICAgIHV0aWwuY29udGFpbnMoc2VnbWVudHMsIHJlZi50b1NlZ21lbnRzKSAmJlxuICAgICAgICByZWYudG9TZWdtZW50cy5sZW5ndGggPiBzZWdtZW50cy5sZW5ndGgpKSBjb250aW51ZTtcbiAgICAgIHZhciBpbmRleCA9ICtyZWYudG9TZWdtZW50c1tzZWdtZW50cy5sZW5ndGhdO1xuICAgICAgdmFyIHBhdGNoZWQgPSBwYXRjaChpbmRleCk7XG4gICAgICBpZiAoaW5kZXggPT09IHBhdGNoZWQpIGNvbnRpbnVlO1xuICAgICAgbW9kZWwuX3JlZnMucmVtb3ZlKGZyb20pO1xuICAgICAgcmVmLnRvU2VnbWVudHNbc2VnbWVudHMubGVuZ3RoXSA9ICcnICsgcGF0Y2hlZDtcbiAgICAgIHJlZi50byA9IHJlZi50b1NlZ21lbnRzLmpvaW4oJy4nKTtcbiAgICAgIG1vZGVsLl9yZWZzLl9hZGQocmVmKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVmQ2hhbmdlKG1vZGVsLCBkZXJlZmVyZW5jZWQsIGV2ZW50QXJncykge1xuICB2YXIgdmFsdWUgPSBldmVudEFyZ3NbMF07XG4gIG1vZGVsLl9zZXQoZGVyZWZlcmVuY2VkLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiByZWZMb2FkKG1vZGVsLCBkZXJlZmVyZW5jZWQsIGV2ZW50QXJncykge1xuICB2YXIgdmFsdWUgPSBldmVudEFyZ3NbMF07XG4gIG1vZGVsLl9zZXQoZGVyZWZlcmVuY2VkLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiByZWZVbmxvYWQobW9kZWwsIGRlcmVmZXJlbmNlZCwgZXZlbnRBcmdzKSB7XG4gIG1vZGVsLl9kZWwoZGVyZWZlcmVuY2VkKTtcbn1cbmZ1bmN0aW9uIHJlZkluc2VydChtb2RlbCwgZGVyZWZlcmVuY2VkLCBldmVudEFyZ3MpIHtcbiAgdmFyIGluZGV4ID0gZXZlbnRBcmdzWzBdO1xuICB2YXIgdmFsdWVzID0gZXZlbnRBcmdzWzFdO1xuICBtb2RlbC5faW5zZXJ0KGRlcmVmZXJlbmNlZCwgaW5kZXgsIHZhbHVlcyk7XG59XG5mdW5jdGlvbiByZWZSZW1vdmUobW9kZWwsIGRlcmVmZXJlbmNlZCwgZXZlbnRBcmdzKSB7XG4gIHZhciBpbmRleCA9IGV2ZW50QXJnc1swXTtcbiAgdmFyIGhvd01hbnkgPSBldmVudEFyZ3NbMV0ubGVuZ3RoO1xuICBtb2RlbC5fcmVtb3ZlKGRlcmVmZXJlbmNlZCwgaW5kZXgsIGhvd01hbnkpO1xufVxuZnVuY3Rpb24gcmVmTW92ZShtb2RlbCwgZGVyZWZlcmVuY2VkLCBldmVudEFyZ3MpIHtcbiAgdmFyIGZyb20gPSBldmVudEFyZ3NbMF07XG4gIHZhciB0byA9IGV2ZW50QXJnc1sxXTtcbiAgdmFyIGhvd01hbnkgPSBldmVudEFyZ3NbMl07XG4gIG1vZGVsLl9tb3ZlKGRlcmVmZXJlbmNlZCwgZnJvbSwgdG8sIGhvd01hbnkpO1xufVxuZnVuY3Rpb24gcmVmU3RyaW5nSW5zZXJ0KG1vZGVsLCBkZXJlZmVyZW5jZWQsIGV2ZW50QXJncykge1xuICB2YXIgaW5kZXggPSBldmVudEFyZ3NbMF07XG4gIHZhciB0ZXh0ID0gZXZlbnRBcmdzWzFdO1xuICBtb2RlbC5fc3RyaW5nSW5zZXJ0KGRlcmVmZXJlbmNlZCwgaW5kZXgsIHRleHQpO1xufVxuZnVuY3Rpb24gcmVmU3RyaW5nUmVtb3ZlKG1vZGVsLCBkZXJlZmVyZW5jZWQsIGV2ZW50QXJncykge1xuICB2YXIgaW5kZXggPSBldmVudEFyZ3NbMF07XG4gIHZhciBob3dNYW55ID0gZXZlbnRBcmdzWzFdO1xuICBtb2RlbC5fc3RyaW5nUmVtb3ZlKGRlcmVmZXJlbmNlZCwgaW5kZXgsIGhvd01hbnkpO1xufVxuXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihtb2RlbCwgdHlwZSwgZm4pIHtcbiAgbW9kZWwub24odHlwZSwgcmVmTGlzdGVuZXIpO1xuICBmdW5jdGlvbiByZWZMaXN0ZW5lcihzZWdtZW50cywgZXZlbnRBcmdzKSB7XG4gICAgdmFyIHBhc3MgPSBldmVudEFyZ3NbZXZlbnRBcmdzLmxlbmd0aCAtIDFdO1xuICAgIC8vIEZpbmQgY2FzZXMgd2hlcmUgYW4gZXZlbnQgaXMgZW1pdHRlZCBvbiBhIHBhdGggd2hlcmUgYSByZWZlcmVuY2VcbiAgICAvLyBpcyBwb2ludGluZy4gQWxsIG9yaWdpbmFsIG11dGF0aW9ucyBoYXBwZW4gb24gdGhlIGZ1bGx5IGRlcmVmZXJlbmNlZFxuICAgIC8vIGxvY2F0aW9uLCBzbyB0aGlzIGRldGVjdGlvbiBvbmx5IG5lZWRzIHRvIGhhcHBlbiBpbiBvbmUgZGlyZWN0aW9uXG4gICAgdmFyIHRvTWFwID0gbW9kZWwuX3JlZnMudG9NYXA7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgc3VicGF0aCA9IChzdWJwYXRoKSA/IHN1YnBhdGggKyAnLicgKyBzZWdtZW50c1tpXSA6IHNlZ21lbnRzW2ldO1xuICAgICAgLy8gSWYgYSByZWYgaXMgZm91bmQgcG9pbnRpbmcgdG8gYSBtYXRjaGluZyBzdWJwYXRoLCByZS1lbWl0IG9uIHRoZVxuICAgICAgLy8gcGxhY2Ugd2hlcmUgdGhlIHJlZmVyZW5jZSBpcyBjb21pbmcgZnJvbSBhcyBpZiB0aGUgbXV0YXRpb24gYWxzb1xuICAgICAgLy8gb2NjdXJlZCBhdCB0aGF0IHBhdGhcbiAgICAgIHZhciByZWZzID0gdG9NYXBbc3VicGF0aF07XG4gICAgICBpZiAoIXJlZnMpIGNvbnRpbnVlO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IHNlZ21lbnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgIGZvciAodmFyIHJlZkluZGV4ID0gMCwgbnVtUmVmcyA9IHJlZnMubGVuZ3RoOyByZWZJbmRleCA8IG51bVJlZnM7IHJlZkluZGV4KyspIHtcbiAgICAgICAgdmFyIHJlZiA9IHJlZnNbcmVmSW5kZXhdO1xuICAgICAgICB2YXIgZGVyZWZlcmVuY2VkID0gcmVmLmZyb21TZWdtZW50cy5jb25jYXQocmVtYWluaW5nKTtcbiAgICAgICAgLy8gVGhlIHZhbHVlIG1heSBhbHJlYWR5IGJlIHVwIHRvIGRhdGUgdmlhIG9iamVjdCByZWZlcmVuY2UuIElmIHNvLFxuICAgICAgICAvLyBzaW1wbHkgcmUtZW1pdCB0aGUgZXZlbnQuIE90aGVyd2lzZSwgcGVyZm9ybSB0aGUgc2FtZSBtdXRhdGlvbiBvblxuICAgICAgICAvLyB0aGUgcmVmJ3MgcGF0aFxuICAgICAgICBpZiAocGFzcy4kb3JpZ2luYWwgfHwgbW9kZWwuX2dldChkZXJlZmVyZW5jZWQpID09PSBtb2RlbC5fZ2V0KHNlZ21lbnRzKSkge1xuICAgICAgICAgIG1vZGVsLmVtaXQodHlwZSwgZGVyZWZlcmVuY2VkLCBldmVudEFyZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzZXR0ZXJNb2RlbCA9IHJlZi5tb2RlbC5wYXNzKHBhc3MsIHRydWUpO1xuICAgICAgICAgIHNldHRlck1vZGVsLl9kZXJlZmVyZW5jZSA9IG5vb3BEZXJlZmVyZW5jZTtcbiAgICAgICAgICBmbihzZXR0ZXJNb2RlbCwgZGVyZWZlcmVuY2VkLCBldmVudEFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIElmIGEgcmVmIHBvaW50cyB0byBhIGNoaWxkIG9mIGEgbWF0Y2hpbmcgc3VicGF0aCwgZ2V0IHRoZSB2YWx1ZSBpblxuICAgIC8vIGNhc2UgaXQgaGFzIGNoYW5nZWQgYW5kIHNldCBpZiBkaWZmZXJlbnRcbiAgICB2YXIgcGFyZW50VG9NYXAgPSBtb2RlbC5fcmVmcy5wYXJlbnRUb01hcDtcbiAgICB2YXIgcmVmcyA9IHBhcmVudFRvTWFwW3N1YnBhdGhdO1xuICAgIGlmICghcmVmcykgcmV0dXJuO1xuICAgIGZvciAodmFyIHJlZkluZGV4ID0gMCwgbnVtUmVmcyA9IHJlZnMubGVuZ3RoOyByZWZJbmRleCA8IG51bVJlZnM7IHJlZkluZGV4KyspIHtcbiAgICAgIHZhciByZWYgPSByZWZzW3JlZkluZGV4XTtcbiAgICAgIHZhciB2YWx1ZSA9IG1vZGVsLl9nZXQocmVmLnRvU2VnbWVudHMpO1xuICAgICAgdmFyIHByZXZpb3VzID0gbW9kZWwuX2dldChyZWYuZnJvbVNlZ21lbnRzKTtcbiAgICAgIGlmIChwcmV2aW91cyAhPT0gdmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRlck1vZGVsID0gcmVmLm1vZGVsLnBhc3MocGFzcywgdHJ1ZSk7XG4gICAgICAgIHNldHRlck1vZGVsLl9kZXJlZmVyZW5jZSA9IG5vb3BEZXJlZmVyZW5jZTtcbiAgICAgICAgc2V0dGVyTW9kZWwuX3NldChyZWYuZnJvbVNlZ21lbnRzLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbk1vZGVsLnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGZyb20sIHRvLCBvcHRpb25zO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHRvID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBpZiAodGhpcy5pc1BhdGgoYXJndW1lbnRzWzFdKSkge1xuICAgICAgZnJvbSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHRvID0gYXJndW1lbnRzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0byA9IGFyZ3VtZW50c1swXTtcbiAgICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZyb20gPSBhcmd1bWVudHNbMF07XG4gICAgdG8gPSBhcmd1bWVudHNbMV07XG4gICAgb3B0aW9ucyA9IGFyZ3VtZW50c1syXTtcbiAgfVxuICB2YXIgZnJvbVBhdGggPSB0aGlzLnBhdGgoZnJvbSk7XG4gIHZhciB0b1BhdGggPSB0aGlzLnBhdGgodG8pO1xuICB2YXIgZnJvbVNlZ21lbnRzID0gZnJvbVBhdGguc3BsaXQoJy4nKTtcbiAgaWYgKGZyb21TZWdtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAncmVmIG11c3QgYmUgcGVyZm9ybWVkIHVuZGVyIGEgY29sbGVjdGlvbiAnICtcbiAgICAgICdhbmQgZG9jdW1lbnQgaWQuIEludmFsaWQgcGF0aDogJyArIGZyb21QYXRoO1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IobWVzc2FnZSkpO1xuICB9XG4gIHRoaXMucm9vdC5fcmVmcy5yZW1vdmUoZnJvbVBhdGgpO1xuICB2YXIgdmFsdWUgPSB0aGlzLmdldCh0byk7XG4gIHRoaXMuX3NldChmcm9tU2VnbWVudHMsIHZhbHVlKTtcbiAgdGhpcy5yb290Ll9yZWZzLmFkZChmcm9tUGF0aCwgdG9QYXRoLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXMuc2NvcGUoZnJvbVBhdGgpO1xufTtcblxuTW9kZWwucHJvdG90eXBlLnJlbW92ZVJlZiA9IGZ1bmN0aW9uKGZyb20pIHtcbiAgdmFyIGZyb21QYXRoID0gdGhpcy5wYXRoKGZyb20pO1xuICB0aGlzLnJvb3QuX3JlZnMucmVtb3ZlKGZyb21QYXRoKTtcbiAgdGhpcy5kZWwoZnJvbSk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUucmVtb3ZlQWxsUmVmcyA9IGZ1bmN0aW9uKHN1YnBhdGgpIHtcbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICB2YXIgcmVmcyA9IHRoaXMucm9vdC5fcmVmcy5mcm9tTWFwO1xuICB2YXIgcmVmTGlzdHMgPSB0aGlzLnJvb3QuX3JlZkxpc3RzLmZyb21NYXA7XG4gIGZvciAodmFyIGZyb20gaW4gcmVmcykge1xuICAgIGlmICh1dGlsLmNvbnRhaW5zKHNlZ21lbnRzLCByZWZzW2Zyb21dLmZyb21TZWdtZW50cykpIHtcbiAgICAgIHRoaXMucmVtb3ZlUmVmKGZyb20pO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBmcm9tIGluIHJlZkxpc3RzKSB7XG4gICAgaWYgKHV0aWwuY29udGFpbnMoc2VnbWVudHMsIHJlZkxpc3RzW2Zyb21dLmZyb21TZWdtZW50cykpIHtcbiAgICAgIHRoaXMucmVtb3ZlUmVmTGlzdChmcm9tKTtcbiAgICB9XG4gIH1cbn07XG5cbk1vZGVsLnByb3RvdHlwZS5kZXJlZmVyZW5jZSA9IGZ1bmN0aW9uKHN1YnBhdGgpIHtcbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fZGVyZWZlcmVuY2Uoc2VnbWVudHMpLmpvaW4oJy4nKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5fZGVyZWZlcmVuY2UgPSBmdW5jdGlvbihzZWdtZW50cywgZm9yQXJyYXlNdXRhdG9yLCBpZ25vcmUpIHtcbiAgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHNlZ21lbnRzO1xuICB2YXIgcmVmcyA9IHRoaXMucm9vdC5fcmVmcy5mcm9tTWFwO1xuICB2YXIgcmVmTGlzdHMgPSB0aGlzLnJvb3QuX3JlZkxpc3RzLmZyb21NYXA7XG4gIGRvIHtcbiAgICB2YXIgc3VicGF0aCA9ICcnO1xuICAgIHZhciBkb0FnYWluID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzdWJwYXRoID0gKHN1YnBhdGgpID8gc3VicGF0aCArICcuJyArIHNlZ21lbnRzW2ldIDogc2VnbWVudHNbaV07XG5cbiAgICAgIHZhciByZWYgPSByZWZzW3N1YnBhdGhdO1xuICAgICAgaWYgKHJlZikge1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gc2VnbWVudHMuc2xpY2UoaSArIDEpO1xuICAgICAgICBzZWdtZW50cyA9IHJlZi50b1NlZ21lbnRzLmNvbmNhdChyZW1haW5pbmcpO1xuICAgICAgICBkb0FnYWluID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWZMaXN0ID0gcmVmTGlzdHNbc3VicGF0aF07XG4gICAgICBpZiAocmVmTGlzdCAmJiByZWZMaXN0ICE9PSBpZ25vcmUpIHtcbiAgICAgICAgdmFyIGJlbG93RGVzY2VuZGFudCA9IGkgKyAyIDwgbGVuO1xuICAgICAgICB2YXIgYmVsb3dDaGlsZCA9IGkgKyAxIDwgbGVuO1xuICAgICAgICBpZiAoIShiZWxvd0Rlc2NlbmRhbnQgfHwgZm9yQXJyYXlNdXRhdG9yICYmIGJlbG93Q2hpbGQpKSBjb250aW51ZTtcbiAgICAgICAgc2VnbWVudHMgPSByZWZMaXN0LmRlcmVmZXJlbmNlKHNlZ21lbnRzLCBpKTtcbiAgICAgICAgZG9BZ2FpbiA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSB3aGlsZSAoZG9BZ2Fpbik7XG4gIC8vIElmIGEgZGVyZWZlcmVuY2UgZmFpbHMsIHJldHVybiBhIHBhdGggdGhhdCB3aWxsIHJlc3VsdCBpbiBhIG51bGwgdmFsdWVcbiAgLy8gaW5zdGVhZCBvZiBhIHBhdGggdG8gZXZlcnl0aGluZyBpbiB0aGUgbW9kZWxcbiAgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFsnJG51bGwnXTtcbiAgcmV0dXJuIHNlZ21lbnRzO1xufTtcblxuZnVuY3Rpb24gbm9vcERlcmVmZXJlbmNlKHNlZ21lbnRzKSB7XG4gIHJldHVybiBzZWdtZW50cztcbn1cblxuZnVuY3Rpb24gUmVmKG1vZGVsLCBmcm9tLCB0bywgb3B0aW9ucykge1xuICB0aGlzLm1vZGVsID0gbW9kZWwgJiYgbW9kZWwucGFzcyh7JHJlZjogdGhpc30pO1xuICB0aGlzLmZyb20gPSBmcm9tO1xuICB0aGlzLnRvID0gdG87XG4gIHRoaXMuZnJvbVNlZ21lbnRzID0gZnJvbS5zcGxpdCgnLicpO1xuICB0aGlzLnRvU2VnbWVudHMgPSB0by5zcGxpdCgnLicpO1xuICB0aGlzLnBhcmVudFRvcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMSwgbGVuID0gdGhpcy50b1NlZ21lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHBhcmVudFRvID0gdGhpcy50b1NlZ21lbnRzLnNsaWNlKDAsIGkpLmpvaW4oJy4nKTtcbiAgICB0aGlzLnBhcmVudFRvcy5wdXNoKHBhcmVudFRvKTtcbiAgfVxuICB0aGlzLnVwZGF0ZUluZGljZXMgPSBvcHRpb25zICYmIG9wdGlvbnMudXBkYXRlSW5kaWNlcztcbn1cbmZ1bmN0aW9uIEZyb21NYXAoKSB7fVxuZnVuY3Rpb24gVG9NYXAoKSB7fVxuXG5mdW5jdGlvbiBSZWZzKG1vZGVsKSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgdGhpcy5mcm9tTWFwID0gbmV3IEZyb21NYXA7XG4gIHRoaXMudG9NYXAgPSBuZXcgVG9NYXA7XG4gIHRoaXMucGFyZW50VG9NYXAgPSBuZXcgVG9NYXA7XG59XG5cblJlZnMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGZyb20sIHRvLCBvcHRpb25zKSB7XG4gIHZhciByZWYgPSBuZXcgUmVmKHRoaXMubW9kZWwsIGZyb20sIHRvLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXMuX2FkZChyZWYpO1xufTtcblxuUmVmcy5wcm90b3R5cGUuX2FkZCA9IGZ1bmN0aW9uKHJlZikge1xuICB0aGlzLmZyb21NYXBbcmVmLmZyb21dID0gcmVmO1xuICBsaXN0TWFwQWRkKHRoaXMudG9NYXAsIHJlZi50bywgcmVmKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJlZi5wYXJlbnRUb3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBsaXN0TWFwQWRkKHRoaXMucGFyZW50VG9NYXAsIHJlZi5wYXJlbnRUb3NbaV0sIHJlZik7XG4gIH1cbiAgcmV0dXJuIHJlZjtcbn07XG5cblJlZnMucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGZyb20pIHtcbiAgdmFyIHJlZiA9IHRoaXMuZnJvbU1hcFtmcm9tXTtcbiAgaWYgKCFyZWYpIHJldHVybjtcbiAgZGVsZXRlIHRoaXMuZnJvbU1hcFtmcm9tXTtcbiAgbGlzdE1hcFJlbW92ZSh0aGlzLnRvTWFwLCByZWYudG8sIHJlZik7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSByZWYucGFyZW50VG9zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbGlzdE1hcFJlbW92ZSh0aGlzLnBhcmVudFRvTWFwLCByZWYucGFyZW50VG9zW2ldLCByZWYpO1xuICB9XG4gIHJldHVybiByZWY7XG59O1xuXG5SZWZzLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgdmFyIG91dCA9IFtdO1xuICBmb3IgKHZhciBmcm9tIGluIHRoaXMuZnJvbU1hcCkge1xuICAgIHZhciByZWYgPSB0aGlzLmZyb21NYXBbZnJvbV07XG4gICAgb3V0LnB1c2goW3JlZi5mcm9tLCByZWYudG9dKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuZnVuY3Rpb24gbGlzdE1hcEFkZChtYXAsIG5hbWUsIGl0ZW0pIHtcbiAgbWFwW25hbWVdIHx8IChtYXBbbmFtZV0gPSBbXSk7XG4gIG1hcFtuYW1lXS5wdXNoKGl0ZW0pO1xufVxuXG5mdW5jdGlvbiBsaXN0TWFwUmVtb3ZlKG1hcCwgbmFtZSwgaXRlbSkge1xuICB2YXIgaXRlbXMgPSBtYXBbbmFtZV07XG4gIGlmICghaXRlbXMpIHJldHVybjtcbiAgdmFyIGluZGV4ID0gaXRlbXMuaW5kZXhPZihpdGVtKTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuO1xuICBpdGVtcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBpZiAoIWl0ZW1zLmxlbmd0aCkgZGVsZXRlIG1hcFtuYW1lXTtcbn1cbiIsInZhciBkZWZhdWx0Rm5zID0gbW9kdWxlLmV4cG9ydHMgPSBuZXcgRGVmYXVsdEZucztcblxuZGVmYXVsdEZucy5yZXZlcnNlID0gbmV3IEZuUGFpcihnZXRSZXZlcnNlLCBzZXRSZXZlcnNlKTtcbmRlZmF1bHRGbnMuYXNjID0gYXNjO1xuZGVmYXVsdEZucy5kZXNjID0gZGVzYztcblxuZnVuY3Rpb24gRGVmYXVsdEZucygpIHt9XG5mdW5jdGlvbiBGblBhaXIoZ2V0LCBzZXQpIHtcbiAgdGhpcy5nZXQgPSBnZXQ7XG4gIHRoaXMuc2V0ID0gc2V0O1xufVxuXG5mdW5jdGlvbiBnZXRSZXZlcnNlKGFycmF5KSB7XG4gIHJldHVybiBhcnJheSAmJiBhcnJheS5zbGljZSgpLnJldmVyc2UoKTtcbn1cbmZ1bmN0aW9uIHNldFJldmVyc2UodmFsdWVzKSB7XG4gIHJldHVybiB7MDogZ2V0UmV2ZXJzZSh2YWx1ZXMpfTtcbn1cblxuZnVuY3Rpb24gYXNjKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gIGlmIChhID4gYikgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gZGVzYyhhLCBiKSB7XG4gIGlmIChhID4gYikgcmV0dXJuIC0xO1xuICBpZiAoYSA8IGIpIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cbiIsInZhciByb3V0ZXIgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcm91dGVyJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHRyYW5zaXRpb246IHRyYW5zaXRpb25cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhZGQgKGUuZy4sIGFwcC5nZXQsIGFwcC5wb3N0LCBldGMuKVxuICogQHBhcmFtIHtBcnJheX0gdHJhbnNpdGlvbkNhbGxzIGlzIGFuIGFycmF5IG9mIG9iamVjdHMgdGhhdCBsb29rIFxuICogICBsaWtlIHtmcm9tLCB0bywgZm9yd2FyZCwgYmFja31cbiAqIEBwYXJhbSB7U3RyaW5nfSBmcm9tXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZvcndhcmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGJhY2tcbiAqL1xuZnVuY3Rpb24gdHJhbnNpdGlvbihhZGQsIGNhbGxzLCBmcm9tLCB0bywgZm9yd2FyZCwgYmFjaykge1xuICBpZiAoZnJvbSA9PT0gdG8pIHJldHVyblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgY2FsbCA9IGNhbGxzW2ldXG4gICAgaWYgKGNhbGwuZnJvbSA9PT0gdG8pIHtcbiAgICAgIGlmIChoYXNUcmFuc2l0aW9uKGNhbGxzLCBmcm9tLCBjYWxsLnRvKSkgY29udGludWVcbiAgICAgIHZhciBjb21wb3NlZEZvcndhcmQgPSBjb21wb3NlQ2FsbGJhY2tzKGZvcndhcmQsIGNhbGwuZm9yd2FyZCwgdG8pXG4gICAgICBpZiAoYmFjayAmJiBjYWxsLmJhY2spIHtcbiAgICAgICAgdmFyIGNvbXBvc2VkQmFjayA9IGNvbXBvc2VDYWxsYmFja3MoY2FsbC5iYWNrLCBiYWNrLCB0bylcbiAgICAgIH1cbiAgICAgIGFkZCh7XG4gICAgICAgIGZyb206IGZyb21cbiAgICAgICwgdG86IGNhbGwudG9cbiAgICAgICwgZm9yd2FyZDogY29tcG9zZWRGb3J3YXJkXG4gICAgICAsIGJhY2s6IGNvbXBvc2VkQmFja1xuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKGNhbGwudG8gPT09IGZyb20pIHtcbiAgICAgIGlmIChoYXNUcmFuc2l0aW9uKGNhbGxzLCBjYWxsLmZyb20sIHRvKSkgY29udGludWVcbiAgICAgIHZhciBjb21wb3NlZEZvcndhcmQgPSBjb21wb3NlQ2FsbGJhY2tzKGNhbGwuZm9yd2FyZCwgZm9yd2FyZCwgZnJvbSlcbiAgICAgIGlmIChiYWNrICYmIGNhbGwuYmFjaykge1xuICAgICAgICB2YXIgY29tcG9zZWRCYWNrID0gY29tcG9zZUNhbGxiYWNrcyhiYWNrLCBjYWxsLmJhY2ssIGZyb20pXG4gICAgICB9XG4gICAgICBhZGQoe1xuICAgICAgICBmcm9tOiBjYWxsLmZyb21cbiAgICAgICwgdG86IHRvXG4gICAgICAsIGZvcndhcmQ6IGNvbXBvc2VkRm9yd2FyZFxuICAgICAgLCBiYWNrOiBjb21wb3NlZEJhY2tcbiAgICAgIH0pXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1RyYW5zaXRpb24oY2FsbHMsIGZyb20sIHRvKSB7XG4gIGZvciAodmFyIGkgPSBjYWxscy5sZW5ndGg7IGktLTspIHtcbiAgICB2YXIgY2FsbCA9IGNhbGxzW2ldO1xuICAgIGlmIChjYWxsLmZyb20gPT09IGZyb20gJiYgY2FsbC50byA9PT0gdG8pIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8vIFRPRE86IEFzeW5jIHN1cHBvcnRcbmZ1bmN0aW9uIGNvbXBvc2VDYWxsYmFja3MoZmlyc3QsIHNlY29uZCwgaW50ZXJtZWRpYXRlUGF0aCkge1xuICBmdW5jdGlvbiBjb21wb3NlZChzZWxmLCBtb2RlbCwgcGFyYW1zLCBuZXh0LCBkb25lKSB7XG4gICAgdmFyIGludGVybWVkaWF0ZVVybCA9IHJvdXRlci5tYXBSb3V0ZShpbnRlcm1lZGlhdGVQYXRoLCBwYXJhbXMpXG4gICAgdmFyIHVybCA9IHBhcmFtcy51cmxcbiAgICB2YXIgc2tpcHBlZCA9IGZhbHNlXG4gICAgZnVuY3Rpb24gd3JhcE5leHQoZXJyKSB7XG4gICAgICBza2lwcGVkID0gdHJ1ZVxuICAgICAgbmV4dChlcnIpXG4gICAgfVxuICAgIHBhcmFtcy51cmwgPSBpbnRlcm1lZGlhdGVVcmxcbiAgICBpZiAoZmlyc3QubGVuZ3RoID09PSA0KSB7XG4gICAgICBmaXJzdC5jYWxsKHNlbGYsIG1vZGVsLCBwYXJhbXMsIHdyYXBOZXh0LCBkb25lRmlyc3QpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZpcnN0LmNhbGwoc2VsZiwgbW9kZWwsIHBhcmFtcywgd3JhcE5leHQpXG4gICAgICBkb25lRmlyc3QoKVxuICAgIH1cbiAgICBmdW5jdGlvbiBkb25lRmlyc3QoKSB7XG4gICAgICBpZiAoc2tpcHBlZCkgcmV0dXJuXG4gICAgICBwYXJhbXMucHJldmlvdXMgPSBpbnRlcm1lZGlhdGVVcmxcbiAgICAgIHBhcmFtcy51cmwgPSB1cmxcbiAgICAgIGlmIChzZWNvbmQubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHNlY29uZC5jYWxsKHNlbGYsIG1vZGVsLCBwYXJhbXMsIG5leHQsIGRvbmUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWNvbmQuY2FsbChzZWxmLCBtb2RlbCwgcGFyYW1zLCBuZXh0KVxuICAgICAgICBkb25lICYmIGRvbmUoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBUaGVzZSBuZWVkIHRvIGJlIGRlZmluZWQgaW5kaXZpZHVhbGx5LCBzaW5jZSB0aGVpclxuICAvLyBhcmd1bWVudCBsZW5ndGggd2lsbCBiZSBjaGVja2VkXG4gIGZ1bmN0aW9uIGFzeW5jQ29tcG9zZWRDYWxsYmFjayhtb2RlbCwgcGFyYW1zLCBuZXh0LCBkb25lKSB7XG4gICAgY29tcG9zZWQodGhpcywgbW9kZWwsIHBhcmFtcywgbmV4dCwgZG9uZSk7XG4gIH1cbiAgZnVuY3Rpb24gY29tcG9zZWRDYWxsYmFjayhtb2RlbCwgcGFyYW1zLCBuZXh0KSB7XG4gICAgY29tcG9zZWQodGhpcywgbW9kZWwsIHBhcmFtcywgbmV4dCk7XG4gIH1cbiAgcmV0dXJuIChmaXJzdC5sZW5ndGggPT09IDQgfHwgc2Vjb25kLmxlbmd0aCA9PT0gNCkgP1xuICAgIGFzeW5jQ29tcG9zZWRDYWxsYmFjayA6IGNvbXBvc2VkQ2FsbGJhY2s7XG59XG4iLCIoZnVuY3Rpb24oZ2xvYmFsKXt2YXIgaHRtbFV0aWwgPSByZXF1aXJlKCdodG1sLXV0aWwnKVxudmFyIG1kNSA9IHJlcXVpcmUoJ01ENScpXG52YXIgcGFyc2VIdG1sID0gaHRtbFV0aWwucGFyc2VcbnZhciB0cmltVGV4dCA9IGh0bWxVdGlsLnRyaW1UZXh0XG52YXIgdW5lc2NhcGVFbnRpdGllcyA9IGh0bWxVdGlsLnVuZXNjYXBlRW50aXRpZXNcbnZhciBlc2NhcGVIdG1sID0gaHRtbFV0aWwuZXNjYXBlSHRtbFxudmFyIGVzY2FwZUF0dHJpYnV0ZSA9IGh0bWxVdGlsLmVzY2FwZUF0dHJpYnV0ZVxudmFyIGlzVm9pZCA9IGh0bWxVdGlsLmlzVm9pZFxudmFyIGNvbmRpdGlvbmFsQ29tbWVudCA9IGh0bWxVdGlsLmNvbmRpdGlvbmFsQ29tbWVudFxudmFyIG1hcmt1cCA9IHJlcXVpcmUoJy4vbWFya3VwJylcbnZhciB2aWV3UGF0aCA9IHJlcXVpcmUoJy4vdmlld1BhdGgnKVxudmFyIHdyYXBSZW1haW5kZXIgPSB2aWV3UGF0aC53cmFwUmVtYWluZGVyXG52YXIgY3R4UGF0aCA9IHZpZXdQYXRoLmN0eFBhdGhcbnZhciBleHRyYWN0UGxhY2Vob2xkZXIgPSB2aWV3UGF0aC5leHRyYWN0UGxhY2Vob2xkZXJcbnZhciBkYXRhVmFsdWUgPSB2aWV3UGF0aC5kYXRhVmFsdWVcbnZhciBwYXRoRm5BcmdzID0gdmlld1BhdGgucGF0aEZuQXJnc1xudmFyIGlzQm91bmQgPSB2aWV3UGF0aC5pc0JvdW5kXG52YXIgZXZlbnRCaW5kaW5nID0gcmVxdWlyZSgnLi9ldmVudEJpbmRpbmcnKVxudmFyIHNwbGl0RXZlbnRzID0gZXZlbnRCaW5kaW5nLnNwbGl0RXZlbnRzXG52YXIgZm5MaXN0ZW5lciA9IGV2ZW50QmluZGluZy5mbkxpc3RlbmVyXG52YXIgZGVyYnkgPSByZXF1aXJlKCcuL2RlcmJ5JylcblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3O1xuXG5mdW5jdGlvbiBlbXB0eSgpIHtcbiAgcmV0dXJuICcnO1xufVxuXG52YXIgZGVmYXVsdEN0eCA9IHtcbiAgJGFsaWFzZXM6IHt9XG4sICRwYXRoczogW11cbiwgJGluZGljZXM6IFtdXG59O1xuXG52YXIgQ0FNRUxfUkVHRVhQID0gLyhbYS16XSkoW0EtWl0pL2c7XG5cbnZhciBkZWZhdWx0R2V0Rm5zID0ge1xuICBlcXVhbDogZnVuY3Rpb24gZ2V0RXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhID09PSBiO1xuICB9XG4sIG5vdDogZnVuY3Rpb24gZ2V0Tm90KHZhbHVlKSB7XG4gICAgcmV0dXJuICF2YWx1ZTtcbiAgfVxuLCBvcjogZnVuY3Rpb24gZ2V0T3IoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgICBpZiAoYXJnKSByZXR1cm4gYXJnO1xuICAgIH07XG4gICAgcmV0dXJuIGFyZztcbiAgfVxuLCBhbmQ6IGZ1bmN0aW9uIGdldEFuZCgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGlmICghYXJnKSByZXR1cm4gYXJnO1xuICAgIH07XG4gICAgcmV0dXJuIGFyZztcbiAgfVxuLCBndDogZnVuY3Rpb24gZ2V0R3QoYSwgYikge1xuICAgIHJldHVybiBhID4gYjtcbiAgfVxuLCBsdDogZnVuY3Rpb24gZ2V0THQoYSwgYikge1xuICAgIHJldHVybiBhIDwgYjtcbiAgfVxuLCBndGU6IGZ1bmN0aW9uIGdldEd0ZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPj0gYjtcbiAgfVxuLCBsdGU6IGZ1bmN0aW9uIGdldEx0ZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPD0gYjtcbiAgfVxuLCBkYXNoOiBmdW5jdGlvbiBnZXREYXNoKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlXG4gICAgICAucmVwbGFjZSgvWzpfXFxzXS9nLCAnLScpXG4gICAgICAucmVwbGFjZShDQU1FTF9SRUdFWFAsICckMS0kMicpXG4gICAgICAudG9Mb3dlckNhc2UoKVxuICB9XG4sIGpvaW46IGZ1bmN0aW9uIGdldEpvaW4oaXRlbXMsIHByb3BlcnR5LCBzZXBhcmF0b3IpIHtcbiAgICB2YXIgbGlzdCwgaTtcbiAgICBpZiAoIWl0ZW1zKSByZXR1cm47XG4gICAgaWYgKHByb3BlcnR5KSB7XG4gICAgICBsaXN0ID0gW107XG4gICAgICBmb3IgKGkgPSBpdGVtcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgbGlzdFtpXSA9IGl0ZW1zW2ldW3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdCA9IGl0ZW1zO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdC5qb2luKHNlcGFyYXRvciB8fCAnLCAnKTtcbiAgfVxuLCBsb2c6IGZ1bmN0aW9uIGdldExvZygpIHtcbiAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICB9XG4sIHRyYWNlOiBmdW5jdGlvbiBnZXRUcmFjZSgpIHtcbiAgICBjb25zb2xlLnRyYWNlKCk7XG4gIH1cbiwgZGVidWdnZXI6IGZ1bmN0aW9uIGdldERlYnVnZ2VyKCkge1xuICAgIGRlYnVnZ2VyO1xuICB9XG4sIHBhdGg6IGZ1bmN0aW9uIGdldFBhdGgobmFtZSkge1xuICAgIHJldHVybiBjdHhQYXRoKHRoaXMudmlldywgdGhpcy5jdHgsIG5hbWUpO1xuICB9XG4sIG5vb3A6IGZ1bmN0aW9uIG5vb3AoKSB7fVxuLCBsb29rdXA6IHZpZXdQYXRoLmxvb2t1cFxufTtcblxudmFyIGRlZmF1bHRTZXRGbnMgPSB7XG4gIGVxdWFsOiBmdW5jdGlvbiBzZXRFcXVhbCh2YWx1ZSwgYSwgYikge1xuICAgIHJldHVybiB2YWx1ZSAmJiBbYl07XG4gIH1cbiwgbm90OiBmdW5jdGlvbiBzZXROb3QodmFsdWUpIHtcbiAgICByZXR1cm4gWyF2YWx1ZV07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFZpZXcobGlicmFyaWVzLCBhcHAsIGFwcEZpbGVuYW1lKSB7XG4gIHRoaXMuX2xpYnJhcmllcyA9IGxpYnJhcmllcyB8fCBbXTtcbiAgdGhpcy5hcHAgPSBhcHAgfHwge307XG4gIHRoaXMuX2FwcEZpbGVuYW1lID0gYXBwRmlsZW5hbWU7XG4gIHRoaXMuX2lubGluZSA9ICcnO1xuICB0aGlzLmNsZWFyKCk7XG4gIHRoaXMuZ2V0Rm5zID0gZGVyYnkudXRpbC5jb3B5T2JqZWN0KGRlZmF1bHRHZXRGbnMpO1xuICB0aGlzLnNldEZucyA9IGRlcmJ5LnV0aWwuY29weU9iamVjdChkZWZhdWx0U2V0Rm5zKTtcbiAgaWYgKHRoaXMuX2luaXQpIHRoaXMuX2luaXQoKTtcbiAgdGhpcy5faWRDb3VudCA9IDA7XG4gIHRoaXMuX3VuY3JlYXRlZCA9IFtdO1xufVxuVmlldy5wcm90b3R5cGUgPSB7XG4gIGRlZmF1bHRWaWV3czoge1xuICAgIGRvY3R5cGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICc8IURPQ1RZUEUgaHRtbD4nO1xuICAgIH1cbiAgLCByb290OiBlbXB0eVxuICAsIGNoYXJzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICc8bWV0YSBjaGFyc2V0PXV0Zi04Pic7XG4gICAgfVxuICAsIHRpdGxlJHM6IGVtcHR5XG4gICwgaGVhZDogZW1wdHlcbiAgLCBoZWFkZXI6IGVtcHR5XG4gICwgYm9keTogZW1wdHlcbiAgLCBmb290ZXI6IGVtcHR5XG4gICwgc2NyaXB0czogZW1wdHlcbiAgLCB0YWlsOiBlbXB0eVxuICB9XG5cbiwgX3NlbGZOczogJ2FwcCdcblxuICAvLyBBbGwgYXV0b21hdGljYWxseSBjcmVhdGVkIGlkcyBzdGFydCB3aXRoIGEgZG9sbGFyIHNpZ25cbiAgLy8gVE9ETzogY2hhbmdlIHRoaXMgc2luY2UgaXQgbWVzc2VzIHVwIHF1ZXJ5IHNlbGVjdG9ycyB1bmxlc3MgZXNjYXBlZFxuLCBfdW5pcXVlSWQ6IHVuaXF1ZUlkXG5cbiwgY2xlYXI6IGNsZWFyXG4sIF9yZXNldEZvclJlbmRlcjogcmVzZXRGb3JSZW5kZXJcbiwgbWFrZTogbWFrZVxuLCBfbWFrZUFsbDogbWFrZUFsbFxuLCBfbWFrZUNvbXBvbmVudHM6IG1ha2VDb21wb25lbnRzXG4sIF9maW5kVmlldzogZmluZFZpZXdcbiwgX2ZpbmQ6IGZpbmRcbiwgZ2V0OiBnZXRcbiwgZm46IGZuXG4sIHJlbmRlcjogcmVuZGVyXG4sIGNvbXBvbmVudHNCeU5hbWU6IGNvbXBvbmVudHNCeU5hbWVcbiwgX2NvbXBvbmVudENvbnN0cnVjdG9yOiBjb21wb25lbnRDb25zdHJ1Y3RvclxuLCBfZmx1c2hVbmNyZWF0ZWQ6IGZsdXNoVW5jcmVhdGVkXG4sIF9iZWZvcmVSZW5kZXI6IGJlZm9yZVJlbmRlclxuLCBfYWZ0ZXJSZW5kZXI6IGFmdGVyUmVuZGVyXG4sIF9iZWZvcmVSb3V0ZTogYmVmb3JlUm91dGVcblxuLCBpbmxpbmU6IGVtcHR5XG5cbiwgZXNjYXBlSHRtbDogZXNjYXBlSHRtbFxuLCBlc2NhcGVBdHRyaWJ1dGU6IGVzY2FwZUF0dHJpYnV0ZVxufVxuXG5WaWV3LnZhbHVlQmluZGluZyA9IHZhbHVlQmluZGluZztcblxuZnVuY3Rpb24gY2xlYXIoKSB7XG4gIHRoaXMuX3ZpZXdzID0gZGVyYnkudXRpbC5jb3B5T2JqZWN0KHRoaXMuZGVmYXVsdFZpZXdzKTtcbiAgdGhpcy5fcmVuZGVycyA9IHt9O1xuICB0aGlzLl9yZXNldEZvclJlbmRlcigpO1xufVxuXG5mdW5jdGlvbiByZXNldEZvclJlbmRlcihtb2RlbCwgY29tcG9uZW50SW5zdGFuY2VzKSB7XG4gIGNvbXBvbmVudEluc3RhbmNlcyB8fCAoY29tcG9uZW50SW5zdGFuY2VzID0ge30pO1xuICBpZiAobW9kZWwpIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgdGhpcy5fY29tcG9uZW50SW5zdGFuY2VzID0gY29tcG9uZW50SW5zdGFuY2VzO1xuICB2YXIgbGlicmFyaWVzID0gdGhpcy5fbGlicmFyaWVzXG4gICAgLCBpXG4gIGZvciAoaSA9IGxpYnJhcmllcy5sZW5ndGg7IGktLTspIHtcbiAgICBsaWJyYXJpZXNbaV0udmlldy5fcmVzZXRGb3JSZW5kZXIobW9kZWwsIGNvbXBvbmVudEluc3RhbmNlcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcG9uZW50c0J5TmFtZShuYW1lKSB7XG4gIHJldHVybiB0aGlzLl9jb21wb25lbnRJbnN0YW5jZXNbbmFtZV0gfHwgW107XG59XG5cbmZ1bmN0aW9uIGNvbXBvbmVudENvbnN0cnVjdG9yKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuX3NlbGZMaWJyYXJ5ICYmIHRoaXMuX3NlbGZMaWJyYXJ5LmNvbnN0cnVjdG9yc1tuYW1lXTtcbn1cblxuZnVuY3Rpb24gdW5pcXVlSWQoKSB7XG4gIHJldHVybiAnJCcgKyAodGhpcy5faWRDb3VudCsrKS50b1N0cmluZygzNik7XG59XG5cbmZ1bmN0aW9uIG1ha2UobmFtZSwgdGVtcGxhdGUsIG9wdGlvbnMsIHRlbXBsYXRlUGF0aCkge1xuICB2YXIgdmlldyA9IHRoaXNcbiAgICAsIGlzU3RyaW5nID0gb3B0aW9ucyAmJiBvcHRpb25zLmxpdGVyYWxcbiAgICAsIG5vTWluaWZ5ID0gaXNTdHJpbmdcbiAgICAsIG9uQmluZCwgcmVuZGVyZXIsIHJlbmRlciwgbWF0Y2hUaXRsZTtcblxuICBpZiAodGVtcGxhdGVQYXRoICYmIChyZW5kZXIgPSB0aGlzLl9yZW5kZXJzW3RlbXBsYXRlUGF0aF0pKSB7XG4gICAgdGhpcy5fdmlld3NbbmFtZV0gPSByZW5kZXI7XG4gICAgcmV0dXJuXG4gIH1cblxuICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICBtYXRjaFRpdGxlID0gLyg/Ol58XFw6KXRpdGxlKFxcJHMpPyQvLmV4ZWMobmFtZSk7XG4gIGlmIChtYXRjaFRpdGxlKSB7XG4gICAgaXNTdHJpbmcgPSAhIW1hdGNoVGl0bGVbMV07XG4gICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICBvbkJpbmQgPSBmdW5jdGlvbihldmVudHMsIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGJpbmRFdmVudHMoZXZlbnRzLCBuYW1lLCByZW5kZXIsIFsnJF9kb2MnLCAncHJvcCcsICd0aXRsZSddKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWFrZShuYW1lICsgJyRzJywgdGVtcGxhdGUsIG9wdGlvbnMsIHRlbXBsYXRlUGF0aCk7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyID0gZnVuY3Rpb24oY3R4LCBtb2RlbCwgdHJpZ2dlcklkKSB7XG4gICAgaWYgKCFyZW5kZXJlcikge1xuICAgICAgcmVuZGVyZXIgPSBwYXJzZSh2aWV3LCBuYW1lLCB0ZW1wbGF0ZSwgaXNTdHJpbmcsIG9uQmluZCwgbm9NaW5pZnkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVuZGVyZXIoY3R4LCBtb2RlbCwgdHJpZ2dlcklkKTtcbiAgfVxuXG4gIHJlbmRlci5ub252b2lkID0gb3B0aW9ucyAmJiBvcHRpb25zLm5vbnZvaWQ7XG5cbiAgdGhpcy5fdmlld3NbbmFtZV0gPSByZW5kZXI7XG4gIGlmICh0ZW1wbGF0ZVBhdGgpIHRoaXMuX3JlbmRlcnNbdGVtcGxhdGVQYXRoXSA9IHJlbmRlcjtcbn1cblxuZnVuY3Rpb24gbWFrZUFsbCh0ZW1wbGF0ZXMsIGluc3RhbmNlcykge1xuICB2YXIgbmFtZSwgaW5zdGFuY2UsIG9wdGlvbnMsIHRlbXBsYXRlUGF0aDtcbiAgaWYgKCFpbnN0YW5jZXMpIHJldHVybjtcbiAgdGhpcy5jbGVhcigpO1xuICBmb3IgKG5hbWUgaW4gaW5zdGFuY2VzKSB7XG4gICAgaW5zdGFuY2UgPSBpbnN0YW5jZXNbbmFtZV07XG4gICAgdGVtcGxhdGVQYXRoID0gaW5zdGFuY2VbMF07XG4gICAgb3B0aW9ucyA9IGluc3RhbmNlWzFdO1xuICAgIHRoaXMubWFrZShuYW1lLCB0ZW1wbGF0ZXNbdGVtcGxhdGVQYXRoXSwgb3B0aW9ucywgdGVtcGxhdGVQYXRoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlQ29tcG9uZW50cyhjb21wb25lbnRzKSB7XG4gIHZhciBsaWJyYXJpZXNNYXAgPSB0aGlzLl9saWJyYXJpZXMubWFwXG4gICAgLCBuYW1lLCBjb21wb25lbnQsIGxpYnJhcnk7XG4gIGZvciAobmFtZSBpbiBjb21wb25lbnRzKSB7XG4gICAgY29tcG9uZW50ID0gY29tcG9uZW50c1tuYW1lXTtcbiAgICBsaWJyYXJ5ID0gbGlicmFyaWVzTWFwW25hbWVdO1xuICAgIGxpYnJhcnkgJiYgbGlicmFyeS52aWV3Ll9tYWtlQWxsKGNvbXBvbmVudC50ZW1wbGF0ZXMsIGNvbXBvbmVudC5pbnN0YW5jZXMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRWaWV3KG5hbWUsIG5zKSB7XG4gIHZhciBpdGVtcyA9IHRoaXMuX3ZpZXdzXG4gICAgLCBpdGVtLCBpLCBzZWdtZW50cywgdGVzdE5zO1xuICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICBpZiAobnMpIHtcbiAgICBucyA9IG5zLnRvTG93ZXJDYXNlKCk7XG4gICAgaXRlbSA9IGl0ZW1zW25zICsgJzonICsgbmFtZV07XG4gICAgaWYgKGl0ZW0pIHJldHVybiBpdGVtO1xuXG4gICAgc2VnbWVudHMgPSBucy5zcGxpdCgnOicpO1xuICAgIGZvciAoaSA9IHNlZ21lbnRzLmxlbmd0aDsgaS0tID4gMTspIHtcbiAgICAgIHRlc3ROcyA9IHNlZ21lbnRzLnNsaWNlKDAsIGkpLmpvaW4oJzonKTtcbiAgICAgIGl0ZW0gPSBpdGVtc1t0ZXN0TnMgKyAnOicgKyBuYW1lXTtcbiAgICAgIGlmIChpdGVtKSByZXR1cm4gaXRlbTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGl0ZW1zW25hbWVdO1xufVxuXG5mdW5jdGlvbiBmaW5kKG5hbWUsIG5zLCBvcHRpb25hbCkge1xuICB2YXIgdmlldyA9IHRoaXMuX2ZpbmRWaWV3KG5hbWUsIG5zKTtcbiAgaWYgKHZpZXcpIHJldHVybiB2aWV3O1xuICBpZiAob3B0aW9uYWwpIHJldHVybiBlbXB0eTtcbiAgaWYgKG5zKSBuYW1lID0gbnMgKyAnOicgKyBuYW1lO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBmaW5kIHRlbXBsYXRlOiBcXG4gIFwiICsgbmFtZSArICdcXG5cXG4nICtcbiAgICAnQXZhaWxhYmxlIHRlbXBsYXRlczogXFxuICAnICsgT2JqZWN0LmtleXModGhpcy5fdmlld3MpLmpvaW4oJ1xcbiAgJylcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0KG5hbWUsIG5zLCBjdHgpIHtcbiAgaWYgKHR5cGVvZiBucyA9PT0gJ29iamVjdCcpIHtcbiAgICBjdHggPSBucztcbiAgICBucyA9ICcnO1xuICB9XG4gIGN0eCA9IGN0eCA/IGV4dGVuZChjdHgsIGRlZmF1bHRDdHgpIDogZGVyYnkudXRpbC5jb3B5T2JqZWN0KGRlZmF1bHRDdHgpO1xuICB0aGlzLmFwcC5tb2RlbCA9IHRoaXMubW9kZWw7XG4gIGN0eC4kZm5DdHggPSBbdGhpcy5hcHBdO1xuICBjdHguJHBhdGhJZHMgPSB7fTtcbiAgcmV0dXJuIHRoaXMuX2ZpbmQobmFtZSwgbnMpKGN0eCk7XG59XG5cbmZ1bmN0aW9uIGZuKG5hbWUsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKHZhciBrIGluIG5hbWUpIHtcbiAgICAgIHRoaXMuZm4oaywgbmFtZVtrXSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICB2YXIgZ2V0LCBzZXQ7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgZ2V0ID0gdmFsdWUuZ2V0O1xuICAgIHNldCA9IHZhbHVlLnNldDtcbiAgfSBlbHNlIHtcbiAgICBnZXQgPSB2YWx1ZTtcbiAgfVxuICB0aGlzLmdldEZuc1tuYW1lXSA9IGdldDtcbiAgaWYgKHNldCkgdGhpcy5zZXRGbnNbbmFtZV0gPSBzZXQ7XG59XG5cbmZ1bmN0aW9uIGVtaXRSZW5kZXIodmlldywgbnMsIGN0eCwgbmFtZSkge1xuICBpZiAodmlldy5pc1NlcnZlcikgcmV0dXJuO1xuICB2aWV3LmFwcC5lbWl0KG5hbWUsIGN0eCk7XG4gIGlmIChucykgdmlldy5hcHAuZW1pdChuYW1lICsgJzonICsgbnMsIGN0eCk7XG59XG5mdW5jdGlvbiBiZWZvcmVSZW5kZXIobW9kZWwsIG5zLCBjdHgpIHtcbiAgY3R4ID0gKGN0eCAmJiBPYmplY3QuY3JlYXRlKGN0eCkpIHx8IHt9O1xuICBjdHguJG5zID0gbnM7XG4gIGVtaXRSZW5kZXIodGhpcywgbnMsIGN0eCwgJ3ByZTpyZW5kZXInKTtcbiAgcmV0dXJuIGN0eDtcbn1cbmZ1bmN0aW9uIGFmdGVyUmVuZGVyKG5zLCBjdHgpIHtcbiAgZW1pdFJlbmRlcih0aGlzLCBucywgY3R4LCAncmVuZGVyJyk7XG59XG5mdW5jdGlvbiBiZWZvcmVSb3V0ZSgpIHtcbiAgdGhpcy5hcHAuZG9tLmNsZWFyKCk7XG4gIC8vIFJlbW92ZSBhbGwgZGF0YSwgcmVmcywgbGlzdGVuZXJzLCBhbmQgcmVhY3RpdmUgZnVuY3Rpb25zXG4gIC8vIGZvciB0aGUgcHJldmlvdXMgcGFnZVxuICB2YXIgc2lsZW50TW9kZWwgPSB0aGlzLm1vZGVsLnNpbGVudCgpO1xuICBzaWxlbnRNb2RlbC5kZXN0cm95KCdfcGFnZScpO1xuICBzaWxlbnRNb2RlbC5kZXN0cm95KCckY29tcG9uZW50cycpO1xuICAvLyBVbmZldGNoIGFuZCB1bnN1YnNjcmliZSBmcm9tIGFsbCBxdWVyaWVzIGFuZCBkb2N1bWVudHNcbiAgc2lsZW50TW9kZWwudW5sb2FkKCk7XG4gIHZhciBsYXN0UmVuZGVyID0gdGhpcy5fbGFzdFJlbmRlcjtcbiAgaWYgKCFsYXN0UmVuZGVyKSByZXR1cm47XG4gIGVtaXRSZW5kZXIodGhpcywgbGFzdFJlbmRlci5ucywgbGFzdFJlbmRlci5jdHgsICdyZXBsYWNlJyk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlcihtb2RlbCwgbnMsIGN0eCwgcmVuZGVySGFzaCkge1xuICBpZiAodHlwZW9mIG5zID09PSAnb2JqZWN0Jykge1xuICAgIHJlbmRlckhhc2ggPSBjdHg7XG4gICAgY3R4ID0gbnM7XG4gICAgbnMgPSAnJztcbiAgfVxuICB0aGlzLm1vZGVsID0gbW9kZWw7XG5cbiAgaWYgKCFjdHguJGlzU2VydmVyKSBjdHggPSB0aGlzLl9iZWZvcmVSZW5kZXIobW9kZWwsIG5zLCBjdHgpO1xuICB0aGlzLl9sYXN0UmVuZGVyID0ge1xuICAgIG5zOiBuc1xuICAsIGN0eDogY3R4XG4gIH07XG5cbiAgdGhpcy5fcmVzZXRGb3JSZW5kZXIoKTtcbiAgbW9kZWwuX19wYXRoTWFwLmNsZWFyKCk7XG4gIG1vZGVsLl9fZXZlbnRzLmNsZWFyKCk7XG4gIG1vZGVsLl9fYmxvY2tQYXRocyA9IHt9O1xuICB0aGlzLmFwcC5kb20uY2xlYXIoKTtcbiAgbW9kZWwuc2lsZW50KCkuZGVzdHJveSgnJGNvbXBvbmVudHMnKTtcblxuICB2YXIgdGl0bGUgPSB0aGlzLmdldCgndGl0bGUkcycsIG5zLCBjdHgpXG4gICAgLCBoZWFkSHRtbCA9IHRoaXMuZ2V0KCdoZWFkJywgbnMsIGN0eClcbiAgICAsIHJvb3RIdG1sID0gdGhpcy5nZXQoJ3Jvb3QnLCBucywgY3R4KVxuICAgICwgYm9keUh0bWwgPSB0aGlzLmdldCgnaGVhZGVyJywgbnMsIGN0eCkgK1xuICAgICAgICB0aGlzLmdldCgnYm9keScsIG5zLCBjdHgpICtcbiAgICAgICAgdGhpcy5nZXQoJ2Zvb3RlcicsIG5zLCBjdHgpXG4gICAgLCBkb2MgPSB3aW5kb3cuZG9jdW1lbnRcbiAgICAsIGVyclxuXG4gIGlmIChyZW5kZXJIYXNoKSB7XG4gICAgLy8gQ2hlY2sgaGFzaGVzIGluIGRldmVsb3BtZW50IHRvIGhlbHAgZmluZCByZW5kZXJpbmcgYnVnc1xuICAgIGlmIChyZW5kZXJIYXNoID09PSBtZDUoYm9keUh0bWwpKSB7XG4gICAgICB0aGlzLl9mbHVzaFVuY3JlYXRlZCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlcnIgPSBuZXcgRXJyb3IoJ1NlcnZlciBhbmQgY2xpZW50IHBhZ2UgcmVuZGVycyBkbyBub3QgbWF0Y2gnKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0sIDApO1xuICB9IGVsc2UgaWYgKGN0eC4kaXNTZXJ2ZXIpIHtcbiAgICAvLyBEb24ndCBmaW5pc2ggcmVuZGVyaW5nIGNsaWVudCBzaWRlIG9uIHRoZSB2ZXJ5IGZpcnN0IGxvYWQsIHNpbmNlXG4gICAgLy8gdGhlIHBhZ2Ugc2hvdWxkIGFscmVhZHkgaGF2ZSB0aGUgc2FtZSBIVE1MIGZyb20gdGhlIHNlcnZlclxuICAgIHRoaXMuX2ZsdXNoVW5jcmVhdGVkKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGRvYy5kb2N1bWVudEVsZW1lbnRcbiAgICAsIGF0dHJzID0gZG9jdW1lbnRFbGVtZW50LmF0dHJpYnV0ZXNcbiAgICAsIGksIGF0dHIsIGZha2VSb290LCBib2R5O1xuXG4gIC8vIFJlbW92ZSBhbGwgY3VycmVudCBhdHRyaWJ1dGVzIG9uIHRoZSBkb2N1bWVudEVsZW1lbnQgYW5kIHJlcGxhY2VcbiAgLy8gdGhlbSB3aXRoIHRoZSBhdHRyaWJ1dGVzIGluIHRoZSByZW5kZXJlZCByb290SHRtbFxuICBmb3IgKGkgPSBhdHRycy5sZW5ndGg7IGktLTspIHtcbiAgICBhdHRyID0gYXR0cnNbaV07XG4gICAgZG9jdW1lbnRFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyLm5hbWUpO1xuICB9XG4gIC8vIFVzaW5nIHRoZSBET00gdG8gZ2V0IHRoZSBhdHRyaWJ1dGVzIG9uIGFuIDxodG1sPiB0YWcgd291bGQgcmVxdWlyZVxuICAvLyBzb21lIHNvcnQgb2YgaWZyYW1lIGhhY2sgdW50aWwgRE9NUGFyc2VyIGhhcyBiZXR0ZXIgYnJvd3NlciBzdXBwb3J0LlxuICAvLyBTdHJpbmcgcGFyc2luZyB0aGUgaHRtbCBzaG91bGQgYmUgc2ltcGxlciBhbmQgbW9yZSBlZmZpY2llbnRcbiAgcGFyc2VIdG1sKHJvb3RIdG1sLCB7XG4gICAgc3RhcnQ6IGZ1bmN0aW9uKHRhZywgdGFnTmFtZSwgYXR0cnMpIHtcbiAgICAgIGlmICh0YWdOYW1lICE9PSAnaHRtbCcpIHJldHVybjtcbiAgICAgIGZvciAodmFyIGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgICAgZG9jdW1lbnRFbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyLCBhdHRyc1thdHRyXSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBmYWtlUm9vdCA9IGRvYy5jcmVhdGVFbGVtZW50KCdodG1sJyk7XG4gIGZha2VSb290LmlubmVySFRNTCA9IGJvZHlIdG1sO1xuICBib2R5ID0gZmFrZVJvb3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2JvZHknKVswXTtcbiAgZG9jdW1lbnRFbGVtZW50LnJlcGxhY2VDaGlsZChib2R5LCBkb2MuYm9keSk7XG4gIGRvYy50aXRsZSA9IHRpdGxlO1xuXG4gIHRoaXMuYXBwLmRvbS5fc2V0RGlydHkodHJ1ZSk7XG4gIHRoaXMuX2ZsdXNoVW5jcmVhdGVkKCk7XG4gIHRoaXMuX2FmdGVyUmVuZGVyKG5zLCBjdHgpO1xufVxuXG5cbmZ1bmN0aW9uIGV4dGVuZChwYXJlbnQsIG9iaikge1xuICB2YXIgb3V0ID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpXG4gICAgLCBrZXk7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIGZvciAoa2V5IGluIG9iaikge1xuICAgIG91dFtrZXldID0gb2JqW2tleV07XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gbW9kZWxMaXN0ZW5lcihwYXJhbXMsIHRyaWdnZXJJZCwgYmxvY2tQYXRocywgcGF0aElkLCBwYXJ0aWFsLCBjdHgsIHNhdmVCbG9ja1BhdGgpIHtcbiAgdmFyIGxpc3RlbmVyID0gdHlwZW9mIHBhcmFtcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gcGFyYW1zKHRyaWdnZXJJZCwgYmxvY2tQYXRocywgc2F2ZUJsb2NrUGF0aCAmJiBwYXRoSWQpXG4gICAgOiBwYXJhbXM7XG4gIGxpc3RlbmVyLnBhcnRpYWwgPSBwYXJ0aWFsO1xuICBsaXN0ZW5lci5jdHggPSBjdHguJHN0cmluZ0N0eCB8fCBjdHg7XG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cblxuZnVuY3Rpb24gYmluZFBhdGhFdmVudChldmVudHMsIGJpbmROYW1lLCBnZXROYW1lLCBwYXJ0aWFsLCBwYXJhbXMsIHNhdmVCbG9ja1BhdGgpIHtcbiAgZXZlbnRzLnB1c2goZnVuY3Rpb24oY3R4LCBtb2RlbEV2ZW50cywgZG9tLCBwYXRoTWFwLCB2aWV3LCBibG9ja1BhdGhzLCB0cmlnZ2VySWQpIHtcbiAgICB2YXIgcGF0aCA9IGN0eFBhdGgodmlldywgY3R4LCBiaW5kTmFtZSlcbiAgICBpZiAoIXBhdGgpIHJldHVybjtcbiAgICB2YXIgcGF0aElkID0gcGF0aE1hcC5pZChwYXRoKTtcbiAgICB2YXIgbGlzdGVuZXIgPSBtb2RlbExpc3RlbmVyKHBhcmFtcywgdHJpZ2dlcklkLCBibG9ja1BhdGhzLCBwYXRoSWQsIHBhcnRpYWwsIGN0eCwgc2F2ZUJsb2NrUGF0aCk7XG4gICAgaWYgKGJpbmROYW1lICE9PSBnZXROYW1lKSB7XG4gICAgICBsaXN0ZW5lci5nZXRWYWx1ZSA9IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgIHJldHVybiBkYXRhVmFsdWUodmlldywgY3R4LCBtb2RlbCwgZ2V0TmFtZSk7XG4gICAgICB9O1xuICAgIH1cbiAgICBtb2RlbEV2ZW50cy5iaW5kKHBhdGhJZCwgbGlzdGVuZXIpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGJpbmRFYWNoUGF0aEV2ZW50KGV2ZW50cywgbmFtZSwgZ2V0TmFtZSwgcGFydGlhbCwgcGFyYW1zKSB7XG4gIHZhciBicmFja2V0SW5kZXggPSBuYW1lLmluZGV4T2YoJ1snKTtcbiAgaWYgKH5icmFja2V0SW5kZXgpIHtcbiAgICAvLyBCaW5kIHRvIGVhY2ggb2YgdGhlIGl0ZW1zIGluc2lkZSBicmFja2V0c1xuICAgIHZhciBwYXRocyA9IHZpZXdQYXRoLnNxdWFyZUJyYWNrZXRzQXJncyhuYW1lKTtcbiAgICBmb3IgKHZhciBpID0gcGF0aHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICBiaW5kRWFjaFBhdGhFdmVudChldmVudHMsIHBhdGhzW2ldLCBnZXROYW1lLCBwYXJ0aWFsLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvLyBCaW5kIHRvIGFueXRoaW5nIHVuZGVyIHRoZSByb290LiBUaGlzIGlucyd0IHZlcnkgZWZmaWNlbnQsIGJ1dCBpdFxuICAgIC8vIHNob3VsZCBjb3ZlciB2YXJpb3VzIGNhc2VzIHRoYXQgd291bGQgcmVxdWlyZSB1cGRhdGluZyB0aGUgYmluZGluZ3NcbiAgICAvLyB3aGVuIHRoZSBhcmd1bWVudHMgaW5zaWRlIG9mIHRoZSBicmFja2V0cyBjaGFuZ2UsIHdoaWNoIEkgZG9uJ3QgZmVlbFxuICAgIC8vIGxpa2UgZmlndXJpbmcgb3V0IGF0IHRoZSBtb21lbnRcbiAgICB2YXIgYmVmb3JlID0gbmFtZS5zbGljZSgwLCBicmFja2V0SW5kZXgpO1xuICAgIGlmIChiZWZvcmUpIGJpbmRFYWNoUGF0aEV2ZW50KGV2ZW50cywgYmVmb3JlICsgJyonLCBnZXROYW1lLCBwYXJ0aWFsLCBwYXJhbXMpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvKFxcLiopKC4qKS8uZXhlYyhuYW1lKTtcbiAgdmFyIHByZWZpeCA9IG1hdGNoWzFdIHx8ICcnO1xuICB2YXIgcmVsYXRpdmVOYW1lID0gbWF0Y2hbMl0gfHwgJyc7XG4gIHZhciBzZWdtZW50cyA9IHJlbGF0aXZlTmFtZS5zcGxpdCgnLicpO1xuICAvLyBUaGlzIGxvb3Agc3RvcHMgYmVmb3JlIHJlYWNoaW5nIHplcm9cbiAgdmFyIHNhdmVCbG9ja1BhdGggPSB0cnVlO1xuICBmb3IgKHZhciBpID0gc2VnbWVudHMubGVuZ3RoOyBpOyBpLS0pIHtcbiAgICB2YXIgYmluZE5hbWUgPSBwcmVmaXggKyBzZWdtZW50cy5zbGljZSgwLCBpKS5qb2luKCcuJyk7XG4gICAgYmluZFBhdGhFdmVudChldmVudHMsIGJpbmROYW1lLCBnZXROYW1lLCBwYXJ0aWFsLCBwYXJhbXMsIHNhdmVCbG9ja1BhdGgpO1xuICAgIHNhdmVCbG9ja1BhdGggPSBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gYmluZEV2ZW50cyhldmVudHMsIG5hbWUsIHBhcnRpYWwsIHBhcmFtcykge1xuICBpZiAofm5hbWUuaW5kZXhPZignKCcpKSB7XG4gICAgdmFyIGFyZ3MgPSBwYXRoRm5BcmdzKG5hbWUpO1xuICAgIGZvciAodmFyIGkgPSBhcmdzLmxlbmd0aDsgaS0tOykge1xuICAgICAgYmluZEVhY2hQYXRoRXZlbnQoZXZlbnRzLCBhcmdzW2ldICsgJyonLCBuYW1lLCBwYXJ0aWFsLCBwYXJhbXMpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgYmluZEVhY2hQYXRoRXZlbnQoZXZlbnRzLCBuYW1lLCBuYW1lLCBwYXJ0aWFsLCBwYXJhbXMpO1xufVxuXG5mdW5jdGlvbiBiaW5kRXZlbnRzQnlJZChldmVudHMsIG5hbWUsIHBhcnRpYWwsIGF0dHJzLCBtZXRob2QsIHByb3AsIGJsb2NrVHlwZSkge1xuICBmdW5jdGlvbiBwYXJhbXModHJpZ2dlcklkLCBibG9ja1BhdGhzLCBwYXRoSWQpIHtcbiAgICB2YXIgaWQgPSBhdHRycy5faWQgfHwgYXR0cnMuaWQ7XG4gICAgaWYgKGJsb2NrVHlwZSAmJiBwYXRoSWQpIHtcbiAgICAgIGJsb2NrUGF0aHNbaWRdID0ge2lkOiBwYXRoSWQsIHR5cGU6IGJsb2NrVHlwZX07XG4gICAgfVxuICAgIHJldHVybiBbaWQsIG1ldGhvZCwgcHJvcF07XG4gIH1cbiAgYmluZEV2ZW50cyhldmVudHMsIG5hbWUsIHBhcnRpYWwsIHBhcmFtcyk7XG59XG5cbmZ1bmN0aW9uIGJpbmRFdmVudHNCeUlkU3RyaW5nKGV2ZW50cywgbmFtZSwgcGFydGlhbCwgYXR0cnMsIG1ldGhvZCwgcHJvcCkge1xuICBmdW5jdGlvbiBwYXJhbXModHJpZ2dlcklkKSB7XG4gICAgdmFyIGlkID0gdHJpZ2dlcklkIHx8IGF0dHJzLl9pZCB8fCBhdHRycy5pZDtcbiAgICByZXR1cm4gW2lkLCBtZXRob2QsIHByb3BdO1xuICB9XG4gIGJpbmRFdmVudHMoZXZlbnRzLCBuYW1lLCBwYXJ0aWFsLCBwYXJhbXMpO1xufVxuXG5mdW5jdGlvbiBhZGRJZCh2aWV3LCBhdHRycykge1xuICBpZiAoYXR0cnMuaWQgPT0gbnVsbCkge1xuICAgIGF0dHJzLmlkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYXR0cnMuX2lkID0gdmlldy5fdW5pcXVlSWQoKTtcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hWYWx1ZShodG1sLCBpLCB2YWx1ZSwgaXNBdHRyKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpID0gaHRtbC5wdXNoKHZhbHVlLCAnJykgLSAxO1xuICB9IGVsc2Uge1xuICAgIGh0bWxbaV0gKz0gaXNBdHRyID8gZXNjYXBlQXR0cmlidXRlKHZhbHVlKSA6IHZhbHVlO1xuICB9XG4gIHJldHVybiBpO1xufVxuXG5mdW5jdGlvbiByZWR1Y2VTdGFjayhzdGFjaykge1xuICB2YXIgaHRtbCA9IFsnJ11cbiAgICAsIGkgPSAwXG4gICAgLCBhdHRycywgYm9vbCwgaXRlbSwga2V5LCB2YWx1ZSwgaiwgbGVuO1xuXG4gIGZvciAoaiA9IDAsIGxlbiA9IHN0YWNrLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgaXRlbSA9IHN0YWNrW2pdO1xuICAgIHN3aXRjaCAoaXRlbVswXSkge1xuICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICBodG1sW2ldICs9ICc8JyArIGl0ZW1bMV07XG4gICAgICAgIGF0dHJzID0gaXRlbVsyXTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIGlkIGF0dHJpYnV0ZSBpcyByZW5kZXJlZCBmaXJzdFxuICAgICAgICBpZiAoJ2lkJyBpbiBhdHRycykge1xuICAgICAgICAgIGh0bWxbaV0gKz0gJyBpZD0nO1xuICAgICAgICAgIGkgPSBwdXNoVmFsdWUoaHRtbCwgaSwgYXR0cnMuaWQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ2lkJykgY29udGludWU7XG4gICAgICAgICAgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoYm9vbCA9IHZhbHVlLmJvb2wpIHtcbiAgICAgICAgICAgICAgaSA9IHB1c2hWYWx1ZShodG1sLCBpLCBib29sKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBodG1sW2ldICs9ICcgJyArIGtleSArICc9JztcbiAgICAgICAgICAgIGkgPSBwdXNoVmFsdWUoaHRtbCwgaSwgdmFsdWUsIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBodG1sW2ldICs9ICcgJyArIGtleTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaHRtbFtpXSArPSAnPic7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgIGkgPSBwdXNoVmFsdWUoaHRtbCwgaSwgaXRlbVsxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgaHRtbFtpXSArPSAnPC8nICsgaXRlbVsxXSArICc+JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtYXJrZXInOlxuICAgICAgICBodG1sW2ldICs9ICc8IS0tJyArIGl0ZW1bMV07XG4gICAgICAgIGkgPSBwdXNoVmFsdWUoaHRtbCwgaSwgaXRlbVsyXS5pZCk7XG4gICAgICAgIGh0bWxbaV0gKz0gJy0tPic7XG4gICAgfVxuICB9XG4gIHJldHVybiBodG1sO1xufVxuXG5mdW5jdGlvbiByZW5kZXJlcih2aWV3LCBpdGVtcywgZXZlbnRzLCBvblJlbmRlcikge1xuICByZXR1cm4gZnVuY3Rpb24oY3R4LCBtb2RlbCwgdHJpZ2dlcklkKSB7XG4gICAgaWYgKCFtb2RlbCkgbW9kZWwgPSB2aWV3Lm1vZGVsOyAgLy8gTmVlZGVkLCBzaW5jZSBtb2RlbCBwYXJhbWV0ZXIgaXMgb3B0aW9uYWxcblxuICAgIGlmIChvblJlbmRlcikgY3R4ID0gb25SZW5kZXIoY3R4KTtcblxuICAgIHZhciBodG1sID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICBodG1sICs9ICh0eXBlb2YgaXRlbSA9PT0gJ2Z1bmN0aW9uJykgPyBpdGVtKGN0eCwgbW9kZWwpIHx8ICcnIDogaXRlbTtcbiAgICB9XG4gICAgaWYgKHZpZXcuaXNTZXJ2ZXIpIHJldHVybiBodG1sO1xuXG4gICAgdmFyIHBhdGhNYXAgPSBtb2RlbC5fX3BhdGhNYXA7XG4gICAgdmFyIG1vZGVsRXZlbnRzID0gbW9kZWwuX19ldmVudHM7XG4gICAgdmFyIGJsb2NrUGF0aHMgPSBtb2RlbC5fX2Jsb2NrUGF0aHM7XG4gICAgdmFyIGRvbSA9IGdsb2JhbC5ERVJCWSAmJiBnbG9iYWwuREVSQlkuYXBwLmRvbTtcbiAgICAvLyBOb3RlIHRoYXQgdGhlIGV2ZW50cyBhcnJheSBjYW4gZ3JvdyBkdXJpbmcgcmVuZGVyaW5nXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBldmVudDtcbiAgICB3aGlsZSAoZXZlbnQgPSBldmVudHNbaSsrXSkge1xuICAgICAgZXZlbnQoY3R4LCBtb2RlbEV2ZW50cywgZG9tLCBwYXRoTWFwLCB2aWV3LCBibG9ja1BhdGhzLCB0cmlnZ2VySWQpO1xuICAgIH1cbiAgICByZXR1cm4gaHRtbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBiaW5kQ29tcG9uZW50RXZlbnQoY29tcG9uZW50LCBuYW1lLCBsaXN0ZW5lcikge1xuICBpZiAobmFtZSA9PT0gJ2luaXQnIHx8IG5hbWUgPT09ICdjcmVhdGUnKSB7XG4gICAgY29tcG9uZW50Lm9uY2UobmFtZSwgbGlzdGVuZXIuZm4pO1xuICB9IGVsc2Uge1xuICAgIC8vIEV4dHJhIGluZGlyZWN0aW9uIGFsbG93cyBsaXN0ZW5lciB0byBvdmVyd3JpdGUgaXRzZWxmIGFmdGVyIGZpcnN0IHJ1blxuICAgIGNvbXBvbmVudC5vbihuYW1lLCBmdW5jdGlvbigpIHtcbiAgICAgIGxpc3RlbmVyLmZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGJpbmRDb21wb25lbnRFdmVudHMoY3R4LCBjb21wb25lbnQsIGV2ZW50cykge1xuICB2YXIgdmlldyA9IGV2ZW50cy4kdmlld1xuICAgICwgaXRlbXMgPSBldmVudHMuJGV2ZW50c1xuICAgICwgbGlzdGVuZXJDdHggPSBPYmplY3QuY3JlYXRlKGN0eClcbiAgICAsIGksIGl0ZW0sIG5hbWUsIGxpc3RlbmVyXG4gIC8vIFRoZSBmbkN0eCB3aWxsIGluY2x1ZGUgdGhpcyBjb21wb25lbnQsIGJ1dCB3ZSB3YW50IHRvIGVtaXRcbiAgLy8gb24gdGhlIHBhcmVudCBjb21wb25lbnQgb3IgYXBwXG4gIGxpc3RlbmVyQ3R4LiRmbkN0eCA9IGxpc3RlbmVyQ3R4LiRmbkN0eC5zbGljZSgwLCAtMSk7XG4gIGZvciAoaSA9IGl0ZW1zLmxlbmd0aDsgaS0tOykge1xuICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICBuYW1lID0gaXRlbVswXTtcbiAgICBsaXN0ZW5lciA9IGZuTGlzdGVuZXIodmlldywgbGlzdGVuZXJDdHgsIGl0ZW1bMl0pO1xuICAgIGJpbmRDb21wb25lbnRFdmVudChjb21wb25lbnQsIG5hbWUsIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQodmlldywgbW9kZWwsIENvbXBvbmVudCwgc2NvcGUsIGN0eCwgbWFjcm9DdHgpIHtcbiAgdmFyIHNjb3BlZCA9IG1vZGVsLnNjb3BlKHNjb3BlKTtcbiAgdmFyIG1hcmtlciA9ICc8IS0tJyArIHNjb3BlICsgJy0tPic7XG4gIHZhciBwcmVmaXggPSBzY29wZSArICcuJztcbiAgdmFyIGNvbXBvbmVudCA9IG5ldyBDb21wb25lbnQoc2NvcGVkLCBzY29wZSk7XG4gIHZhciBwYXJlbnRGbkN0eCA9IG1vZGVsLl9fZm5DdHggfHwgY3R4LiRmbkN0eDtcbiAgdmFyIHNpbGVudEN0eCA9IE9iamVjdC5jcmVhdGUoY3R4KTtcbiAgc2lsZW50Q3R4LiRzaWxlbnQgPSB0cnVlO1xuICB2YXIgc2lsZW50TW9kZWwgPSBtb2RlbC5zaWxlbnQoKTtcbiAgdmFyIGksIGtleSwgcGF0aCwgdmFsdWUsIGluc3RhbmNlTmFtZSwgaW5zdGFuY2VzO1xuXG4gIGN0eC4kZm5DdHggPSBtb2RlbC5fX2ZuQ3R4ID0gcGFyZW50Rm5DdHguY29uY2F0KGNvbXBvbmVudCk7XG5cbiAgLy8gSEFDSzogRW5zdXJlIHRoYXQgc2NvcGVkIG1vZGVsIGhhcyBzb21ldGhpbmcgc2V0XG4gIHNjb3BlZC5zZXQoJyRudWxsJywgbnVsbCk7XG5cbiAgZm9yIChrZXkgaW4gbWFjcm9DdHgpIHtcbiAgICB2YWx1ZSA9IG1hY3JvQ3R4W2tleV07XG4gICAgaWYgKGtleSA9PT0gJ2JpbmQnKSB7XG4gICAgICBiaW5kQ29tcG9uZW50RXZlbnRzKGN0eCwgY29tcG9uZW50LCB2YWx1ZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLiRtYXRjaE5hbWUpIHtcbiAgICAgIHBhdGggPSBjdHhQYXRoKHZpZXcsIGN0eCwgdmFsdWUuJG1hdGNoTmFtZSk7XG4gICAgICBpZiAodmFsdWUuJGJvdW5kKSB7XG4gICAgICAgIHNpbGVudE1vZGVsLnJlZihwcmVmaXggKyBrZXksIHBhdGgsIHt1cGRhdGVJbmRpY2VzOiB0cnVlfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSBkYXRhVmFsdWUodmlldywgY3R4LCBtb2RlbCwgcGF0aCk7XG4gICAgICBzaWxlbnRNb2RlbC5zZXQocHJlZml4ICsga2V5LCB2YWx1ZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gVE9ETzogRmlndXJlIG91dCBob3cgdG8gZ2V0IHZhbHVlIG9mIHRlbXBsYXRpemVkIGF0dHJpYnV0ZXNcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSBjb250aW51ZTtcbiAgICBzaWxlbnRNb2RlbC5zZXQocHJlZml4ICsga2V5LCB2YWx1ZSk7XG4gIH1cblxuICBpbnN0YW5jZU5hbWUgPSBzY29wZWQuZ2V0KCduYW1lJyk7XG4gIGlmIChpbnN0YW5jZU5hbWUpIHtcbiAgICBpbnN0YW5jZXMgPSB2aWV3Ll9jb21wb25lbnRJbnN0YW5jZXNbaW5zdGFuY2VOYW1lXSB8fFxuICAgICAgKHZpZXcuX2NvbXBvbmVudEluc3RhbmNlc1tpbnN0YW5jZU5hbWVdID0gW10pO1xuICAgIGluc3RhbmNlcy5wdXNoKGNvbXBvbmVudCk7XG4gIH1cblxuICBpZiAoY29tcG9uZW50LmluaXQpIGNvbXBvbmVudC5pbml0KHNjb3BlZCk7XG4gIGNvbXBvbmVudC5lbWl0KCdpbml0JywgY29tcG9uZW50KTtcblxuICBpZiAodmlldy5pc1NlcnZlciB8fCBjdHguJHNpbGVudCkgcmV0dXJuIG1hcmtlcjtcblxuICB2YXIgYXBwID0gZ2xvYmFsLkRFUkJZICYmIGdsb2JhbC5ERVJCWS5hcHBcbiAgICAsIGRvbSA9IGFwcC5kb21cbiAgY29tcG9uZW50LmRvbSA9IGRvbTtcbiAgY29tcG9uZW50Lmhpc3RvcnkgPSBhcHAuaGlzdG9yeTtcblxuICB2YXIgdW5jcmVhdGVkID0gbmV3IFVuY3JlYXRlZENvbXBvbmVudChjb21wb25lbnQsIHNjb3BlZCwgZG9tLCBzY29wZSwgY3R4KTtcbiAgdmlldy5fdW5jcmVhdGVkLnB1c2godW5jcmVhdGVkKTtcblxuICByZXR1cm4gbWFya2VyO1xufVxuXG5mdW5jdGlvbiBVbmNyZWF0ZWRDb21wb25lbnQoY29tcG9uZW50LCBtb2RlbCwgZG9tLCBzY29wZSwgY3R4KSB7XG4gIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gIHRoaXMuZG9tID0gZG9tO1xuICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gIHRoaXMuY3R4ID0gY3R4O1xufVxuVW5jcmVhdGVkQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gVE9ETzogRmlndXJlIG91dCB1bmRlcmx5aW5nIGlzc3VlIGFuZCByZW1vdmVcbiAgLy8gSWYgZm9yIHNvbWUgcmVhc29uLCBjb21wb25lbnQncyBzY29wZWQgbW9kZWwgZG9lcyBub3QgaGF2ZSBhbnkgZGF0YSxcbiAgLy8gZG8gbm90aGluZy4gTm90IHN1cmUgd2h5IGl0IHdvdWxkIGdldCB0byB0aGlzIHN0YXRlLCBidXQgaXQgZG9lcy5cbiAgaWYgKCF0aGlzLm1vZGVsLmdldCgpKSByZXR1cm47XG5cbiAgLy8gRGVzdHJveSBpbiBjYXNlIGNvbXBvbmVudCB3YXMgY3JlYXRlZCBhbmQgcmVwbGFjZWQgd2l0aGluIHJlbmRlcmluZ1xuICBpZiAoIXRoaXMuZG9tLm1hcmtlcih0aGlzLnNjb3BlKSkge1xuICAgIHRoaXMuY29tcG9uZW50LmVtaXQoJ2Rlc3Ryb3knKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmRvbS5hZGRDb21wb25lbnQodGhpcy5jdHgsIHRoaXMuY29tcG9uZW50KTtcbiAgaWYgKHRoaXMuY29tcG9uZW50LmNyZWF0ZSkgdGhpcy5jb21wb25lbnQuY3JlYXRlKHRoaXMubW9kZWwsIHRoaXMuY29tcG9uZW50LmRvbSk7XG4gIHRoaXMuY29tcG9uZW50LmVtaXQoJ2NyZWF0ZScsIHRoaXMuY29tcG9uZW50KTtcbn07XG5cbmZ1bmN0aW9uIGZsdXNoVW5jcmVhdGVkKCkge1xuICB2YXIgdW5jcmVhdGVkO1xuICB3aGlsZSAodW5jcmVhdGVkID0gdGhpcy5fdW5jcmVhdGVkLnNoaWZ0KCkpIHtcbiAgICB1bmNyZWF0ZWQuY3JlYXRlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGV4dGVuZEN0eCh2aWV3LCBjdHgsIHZhbHVlLCBuYW1lLCBhbGlhcywgaXNFYWNoKSB7XG4gIHZhciBwYXRoID0gY3R4UGF0aCh2aWV3LCBjdHgsIG5hbWUpXG4gICAgLCBhbGlhc2VzO1xuICBjdHggPSBleHRlbmQoY3R4LCB2YWx1ZSk7XG4gIGN0eFsndGhpcyddID0gdmFsdWU7XG4gIGlmIChhbGlhcykge1xuICAgIGFsaWFzZXMgPSBjdHguJGFsaWFzZXMgPSBPYmplY3QuY3JlYXRlKGN0eC4kYWxpYXNlcyk7XG4gICAgYWxpYXNlc1thbGlhc10gPSBjdHguJHBhdGhzLmxlbmd0aDtcbiAgICBpZiAoaXNFYWNoKSBhbGlhc2VzW2FsaWFzXSsrO1xuICB9XG4gIGlmIChwYXRoKSB7XG4gICAgY3R4LiRwYXRocyA9IFtwYXRoXS5jb25jYXQoY3R4LiRwYXRocyk7XG4gIH1cbiAgY3R4LiRwYXRoSWRzID0gT2JqZWN0LmNyZWF0ZShjdHguJHBhdGhJZHMpO1xuICByZXR1cm4gY3R4O1xufVxuXG5mdW5jdGlvbiBwYXJ0aWFsVmFsdWUodmlldywgY3R4LCBtb2RlbCwgbmFtZSwgdmFsdWUsIGxpc3RlbmVyKSB7XG4gIGlmIChsaXN0ZW5lcikgcmV0dXJuIHZhbHVlO1xuICByZXR1cm4gbmFtZSA/IGRhdGFWYWx1ZSh2aWV3LCBjdHgsIG1vZGVsLCBuYW1lKSA6IHRydWU7XG59XG5cbmZ1bmN0aW9uIHBhcnRpYWxGbih2aWV3LCBuYW1lLCB0eXBlLCBhbGlhcywgcmVuZGVyLCBucywgbWFjcm9DdHgpIHtcbiAgZnVuY3Rpb24gcGFydGlhbEJsb2NrIChjdHgsIG1vZGVsLCB0cmlnZ2VySWQsIHZhbHVlLCBpbmRleCwgbGlzdGVuZXIpIHtcbiAgICAvLyBJbmhlcml0ICYgcmVuZGVyIGF0dHJpYnV0ZSBjb250ZXh0IHZhbHVlc1xuICAgIHZhciByZW5kZXJNYWNyb0N0eCA9IHt9XG4gICAgICAsIHBhcmVudE1hY3JvQ3R4ID0gY3R4LiRtYWNyb0N0eFxuICAgICAgLCBtZXJnZWRNYWNyb0N0eCA9IG1hY3JvQ3R4XG4gICAgICAsIGtleSwgdmFsLCBtYXRjaE5hbWVcbiAgICBpZiAobWFjcm9DdHguaW5oZXJpdCkge1xuICAgICAgbWVyZ2VkTWFjcm9DdHggPSB7fTtcbiAgICAgIGRlcmJ5LnV0aWwubWVyZ2VJbnRvKG1lcmdlZE1hY3JvQ3R4LCBwYXJlbnRNYWNyb0N0eCk7XG4gICAgICBkZXJieS51dGlsLm1lcmdlSW50byhtZXJnZWRNYWNyb0N0eCwgbWFjcm9DdHgpO1xuICAgICAgZGVsZXRlIG1lcmdlZE1hY3JvQ3R4LmluaGVyaXQ7XG4gICAgfVxuICAgIGZvciAoa2V5IGluIG1lcmdlZE1hY3JvQ3R4KSB7XG4gICAgICB2YWwgPSBtZXJnZWRNYWNyb0N0eFtrZXldO1xuICAgICAgaWYgKHZhbCAmJiB2YWwuJG1hdGNoTmFtZSkge1xuICAgICAgICBtYXRjaE5hbWUgPSBjdHhQYXRoKHZpZXcsIGN0eCwgdmFsLiRtYXRjaE5hbWUpO1xuICAgICAgICBpZiAobWF0Y2hOYW1lLmNoYXJBdCgwKSA9PT0gJ0AnKSB7XG4gICAgICAgICAgdmFsID0gZGF0YVZhbHVlKHZpZXcsIGN0eCwgbW9kZWwsIG1hdGNoTmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gZGVyYnkudXRpbC5jb3B5T2JqZWN0KHZhbCk7XG4gICAgICAgICAgdmFsLiRtYXRjaE5hbWUgPSBtYXRjaE5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlbmRlck1hY3JvQ3R4W2tleV0gPSB2YWw7XG4gICAgfVxuXG4gICAgLy8gRmluZCB0aGUgYXBwcm9wcmlhdGUgcGFydGlhbCB0ZW1wbGF0ZVxuICAgIHZhciBwYXJ0aWFsTnMsIHBhcnRpYWxOYW1lLCBwYXJ0aWFsT3B0aW9uYWwsIGFycjtcbiAgICBpZiAobmFtZSA9PT0gJ2RlcmJ5OnZpZXcnKSB7XG4gICAgICBwYXJ0aWFsTnMgPSBtZXJnZWRNYWNyb0N0eC5ucyB8fCB2aWV3Ll9zZWxmTnM7XG4gICAgICBwYXJ0aWFsTmFtZSA9IG1lcmdlZE1hY3JvQ3R4LnZpZXc7XG4gICAgICBwYXJ0aWFsT3B0aW9uYWwgPSBtZXJnZWRNYWNyb0N0eC5vcHRpb25hbDtcbiAgICAgIGlmICghcGFydGlhbE5hbWUpIHRocm93IG5ldyBFcnJvcignPGRlcmJ5OnZpZXc+IHRhZyB3aXRob3V0IGEgXCJ2aWV3XCIgYXR0cmlidXRlJylcbiAgICAgIGlmIChwYXJ0aWFsTnMuJG1hdGNoTmFtZSkge1xuICAgICAgICBwYXJ0aWFsTnMgPSBkYXRhVmFsdWUodmlldywgY3R4LCBtb2RlbCwgcGFydGlhbE5zLiRtYXRjaE5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnRpYWxOYW1lLiRtYXRjaE5hbWUpIHtcbiAgICAgICAgcGFydGlhbE5hbWUgPSBkYXRhVmFsdWUodmlldywgY3R4LCBtb2RlbCwgcGFydGlhbE5hbWUuJG1hdGNoTmFtZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyciA9IHNwbGl0UGFydGlhbChuYW1lKTtcbiAgICAgIHBhcnRpYWxOcyA9IGFyclswXTtcbiAgICAgIHBhcnRpYWxOYW1lID0gYXJyWzFdO1xuICAgIH1cbiAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB1c2luZyA8ZGVyYnk6dmlldyB2aWV3PXt7Li4ufX0+XG4gICAgaWYgKHR5cGVvZiBwYXJ0aWFsTmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGFydGlhbE5hbWUgPSBwYXJ0aWFsTmFtZShPYmplY3QuY3JlYXRlKGN0eCksIG1vZGVsKTtcbiAgICB9XG4gICAgdmFyIHBhcnRpYWxWaWV3ID0gbnNWaWV3KHZpZXcsIHBhcnRpYWxOcylcbiAgICAgICwgcmVuZGVyID0gcGFydGlhbFZpZXcuX2ZpbmQocGFydGlhbE5hbWUsIG5zLCBwYXJ0aWFsT3B0aW9uYWwpXG4gICAgICAsIENvbXBvbmVudCA9IHBhcnRpYWxWaWV3Ll9jb21wb25lbnRDb25zdHJ1Y3RvcihwYXJ0aWFsTmFtZSlcbiAgICAgICwgcmVuZGVyQ3R4LCBzY29wZSwgb3V0LCBtYXJrZXJcblxuICAgIC8vIFByZXBhcmUgdGhlIGNvbnRleHQgZm9yIHJlbmRlcmluZ1xuICAgIGlmIChDb21wb25lbnQpIHtcbiAgICAgIHNjb3BlID0gJyRjb21wb25lbnRzLicgKyB2aWV3Ll91bmlxdWVJZCgpO1xuICAgICAgcmVuZGVyQ3R4ID0gZXh0ZW5kQ3R4KHZpZXcsIGN0eCwgbnVsbCwgc2NvcGUsICdzZWxmJyk7XG4gICAgICByZW5kZXJDdHguJGVsZW1lbnRzID0ge307XG4gICAgICBtYXJrZXIgPSBjcmVhdGVDb21wb25lbnQodmlldywgbW9kZWwsIENvbXBvbmVudCwgc2NvcGUsIHJlbmRlckN0eCwgcmVuZGVyTWFjcm9DdHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW5kZXJDdHggPSBPYmplY3QuY3JlYXRlKGN0eCk7XG4gICAgfVxuICAgIHJlbmRlckN0eC4kbWFjcm9DdHggPSByZW5kZXJNYWNyb0N0eDtcblxuICAgIG91dCA9IHJlbmRlcihyZW5kZXJDdHgsIG1vZGVsKTtcbiAgICBpZiAoQ29tcG9uZW50KSB7XG4gICAgICBpZiAobW9kZWwuX19mbkN0eCkge1xuICAgICAgICBtb2RlbC5fX2ZuQ3R4ID0gbW9kZWwuX19mbkN0eC5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgICBvdXQgPSBtYXJrZXIgKyBvdXQ7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICBmdW5jdGlvbiB3aXRoQmxvY2soY3R4LCBtb2RlbCwgdHJpZ2dlcklkLCB2YWx1ZSwgaW5kZXgsIGxpc3RlbmVyKSB7XG4gICAgdmFsdWUgPSBwYXJ0aWFsVmFsdWUodmlldywgY3R4LCBtb2RlbCwgbmFtZSwgdmFsdWUsIGxpc3RlbmVyKTtcbiAgICB2YXIgcmVuZGVyQ3R4ID0gZXh0ZW5kQ3R4KHZpZXcsIGN0eCwgdmFsdWUsIG5hbWUsIGFsaWFzKTtcbiAgICByZXR1cm4gcmVuZGVyKHJlbmRlckN0eCwgbW9kZWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gaWZCbG9jayhjdHgsIG1vZGVsLCB0cmlnZ2VySWQsIHZhbHVlLCBpbmRleCwgbGlzdGVuZXIpIHtcbiAgICB2YWx1ZSA9IHBhcnRpYWxWYWx1ZSh2aWV3LCBjdHgsIG1vZGVsLCBuYW1lLCB2YWx1ZSwgbGlzdGVuZXIpO1xuICAgIGlmICghKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubGVuZ3RoIDogdmFsdWUpKSByZXR1cm47XG4gICAgdmFyIHJlbmRlckN0eCA9IGV4dGVuZEN0eCh2aWV3LCBjdHgsIHZhbHVlLCBuYW1lLCBhbGlhcyk7XG4gICAgcmV0dXJuIHJlbmRlcihyZW5kZXJDdHgsIG1vZGVsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVubGVzc0Jsb2NrKGN0eCwgbW9kZWwsIHRyaWdnZXJJZCwgdmFsdWUsIGluZGV4LCBsaXN0ZW5lcikge1xuICAgIHZhbHVlID0gcGFydGlhbFZhbHVlKHZpZXcsIGN0eCwgbW9kZWwsIG5hbWUsIHZhbHVlLCBsaXN0ZW5lcik7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubGVuZ3RoIDogdmFsdWUpIHJldHVybjtcbiAgICB2YXIgcmVuZGVyQ3R4ID0gZXh0ZW5kQ3R4KHZpZXcsIGN0eCwgdmFsdWUsIG5hbWUsIGFsaWFzKTtcbiAgICByZXR1cm4gcmVuZGVyKHJlbmRlckN0eCwgbW9kZWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gZWFjaEJsb2NrKGN0eCwgbW9kZWwsIHRyaWdnZXJJZCwgdmFsdWUsIGluZGV4LCBsaXN0ZW5lcikge1xuICAgIHZhbHVlID0gcGFydGlhbFZhbHVlKHZpZXcsIGN0eCwgbW9kZWwsIG5hbWUsIHZhbHVlLCBsaXN0ZW5lcik7XG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcblxuICAgIGlmIChsaXN0ZW5lciAmJiAhaXNBcnJheSkge1xuICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHJldHVybjtcbiAgICAgIHZhciBsaXN0Q3R4ID0gZXh0ZW5kQ3R4KHZpZXcsIGN0eCwgbnVsbCwgbmFtZSwgYWxpYXMsIHRydWUpO1xuICAgICAgdmFyIGl0ZW1QYXRoID0gbGlzdEN0eC4kcGF0aHNbMF0gKyAnLicgKyBpbmRleDtcbiAgICAgIHZhciBpdGVtID0gcGFydGlhbFZhbHVlKHZpZXcsIGxpc3RDdHgsIG1vZGVsLCBpdGVtUGF0aCwgdmFsdWUsIGxpc3RlbmVyKTtcbiAgICAgIHJlbmRlckN0eCA9IGV4dGVuZChsaXN0Q3R4LCBpdGVtKTtcbiAgICAgIHJlbmRlckN0eFsndGhpcyddID0gaXRlbTtcbiAgICAgIHJlbmRlckN0eC4kaW5kaWNlcyA9IFtpbmRleF0uY29uY2F0KHJlbmRlckN0eC4kaW5kaWNlcyk7XG4gICAgICByZW5kZXJDdHguJGluZGV4ID0gaW5kZXg7XG4gICAgICByZW5kZXJDdHguJHBhdGhzID0gW2l0ZW1QYXRoXS5jb25jYXQocmVuZGVyQ3R4LiRwYXRocyk7XG4gICAgICByZXR1cm4gcmVuZGVyKHJlbmRlckN0eCwgbW9kZWwpO1xuICAgIH1cblxuICAgIGlmICghaXNBcnJheSB8fCAhdmFsdWUubGVuZ3RoKSByZXR1cm47XG5cbiAgICB2YXIgbGlzdEN0eCA9IGV4dGVuZEN0eCh2aWV3LCBjdHgsIG51bGwsIG5hbWUsIGFsaWFzLCB0cnVlKTtcblxuICAgIHZhciBvdXQgPSAnJztcbiAgICB2YXIgaW5kaWNlcyA9IGxpc3RDdHguJGluZGljZXM7XG4gICAgdmFyIHBhdGhzID0gbGlzdEN0eC4kcGF0aHM7XG4gICAgdmFyIGJhc2VQYXRoID0gcGF0aHNbMF07XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbHVlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IHZhbHVlW2ldO1xuICAgICAgdmFyIHJlbmRlckN0eCA9IGV4dGVuZChsaXN0Q3R4LCBpdGVtKTtcbiAgICAgIHJlbmRlckN0eFsndGhpcyddID0gaXRlbTtcbiAgICAgIHJlbmRlckN0eC4kaW5kaWNlcyA9IFtpXS5jb25jYXQoaW5kaWNlcyk7XG4gICAgICByZW5kZXJDdHguJGluZGV4ID0gaTtcbiAgICAgIHJlbmRlckN0eC4kcGF0aHMgPSBbYmFzZVBhdGggKyAnLicgKyBpXS5jb25jYXQocGF0aHMpO1xuICAgICAgb3V0ICs9IChpdGVtID09PSB2b2lkIDApID9cbiAgICAgICAgJzwhLS1lbXB0eS0tPicgOlxuICAgICAgICByZW5kZXIocmVuZGVyQ3R4LCBtb2RlbCk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICB2YXIgYmxvY2sgPVxuICAgICAgKHR5cGUgPT09ICdwYXJ0aWFsJykgPyBwYXJ0aWFsQmxvY2tcbiAgICA6ICh0eXBlID09PSAnd2l0aCcgfHwgdHlwZSA9PT0gJ2Vsc2UnKSA/IHdpdGhCbG9ja1xuICAgIDogKHR5cGUgPT09ICdpZicgfHwgdHlwZSA9PT0gJ2Vsc2UgaWYnKSA/IGlmQmxvY2tcbiAgICA6ICh0eXBlID09PSAndW5sZXNzJykgPyB1bmxlc3NCbG9ja1xuICAgIDogKHR5cGUgPT09ICdlYWNoJykgPyBlYWNoQmxvY2tcbiAgICA6IG51bGxcblxuICBpZiAoIWJsb2NrKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gYmxvY2sgdHlwZTogJyArIHR5cGUpO1xuICBibG9jay50eXBlID0gdHlwZTtcbiAgcmV0dXJuIGJsb2NrO1xufVxuXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGFycmF5VG9TdHJpbmcgPSBBcnJheS5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHZhbHVlQmluZGluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDpcbiAgICAodmFsdWUudG9TdHJpbmcgPT09IG9iamVjdFRvU3RyaW5nIHx8IHZhbHVlLnRvU3RyaW5nID09PSBhcnJheVRvU3RyaW5nKSA/XG4gICAgSlNPTi5zdHJpbmdpZnkodmFsdWUpIDogdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHZhbHVlVGV4dCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWVCaW5kaW5nKHZhbHVlKS50b1N0cmluZygpO1xufVxuXG5mdW5jdGlvbiB0ZXh0Rm4odmlldywgbmFtZSwgZXNjYXBlLCBmb3JjZSkge1xuICB2YXIgZmlsdGVyID0gZXNjYXBlID8gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZXNjYXBlKHZhbHVlVGV4dCh2YWx1ZSkpO1xuICB9IDogdmFsdWVUZXh0O1xuICByZXR1cm4gZnVuY3Rpb24oY3R4LCBtb2RlbCkge1xuICAgIHJldHVybiBkYXRhVmFsdWUodmlldywgY3R4LCBtb2RlbCwgbmFtZSwgZmlsdGVyLCBmb3JjZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2VjdGlvbkZuKHZpZXcsIHF1ZXVlKSB7XG4gIHZhciByZW5kZXIgPSByZW5kZXJlcih2aWV3LCByZWR1Y2VTdGFjayhxdWV1ZS5zdGFjayksIHF1ZXVlLmV2ZW50cyk7XG4gIHZhciBibG9jayA9IHF1ZXVlLmJsb2NrO1xuICByZXR1cm4gcGFydGlhbEZuKHZpZXcsIGJsb2NrLm5hbWUsIGJsb2NrLnR5cGUsIGJsb2NrLmFsaWFzLCByZW5kZXIpO1xufVxuXG5mdW5jdGlvbiBibG9ja0ZuKHZpZXcsIHNlY3Rpb25zKSB7XG4gIHZhciBsZW4gPSBzZWN0aW9ucy5sZW5ndGg7XG4gIGlmICghbGVuKSByZXR1cm47XG4gIGlmIChsZW4gPT09IDEpIHtcbiAgICByZXR1cm4gc2VjdGlvbkZuKHZpZXcsIHNlY3Rpb25zWzBdKTtcblxuICB9IGVsc2Uge1xuICAgIHZhciBmbnMgPSBbXVxuICAgICAgLCBpLCBvdXQ7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBmbnMucHVzaChzZWN0aW9uRm4odmlldywgc2VjdGlvbnNbaV0pKTtcbiAgICB9XG4gICAgb3V0ID0gZnVuY3Rpb24oY3R4LCBtb2RlbCwgdHJpZ2dlcklkLCB2YWx1ZSwgaW5kZXgsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgb3V0O1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG91dCA9IGZuc1tpXShjdHgsIG1vZGVsLCB0cmlnZ2VySWQsIHZhbHVlLCBpbmRleCwgbGlzdGVuZXIpO1xuICAgICAgICBpZiAob3V0ICE9IG51bGwpIHJldHVybiBvdXQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VNYXJrdXAodHlwZSwgYXR0ciwgdGFnTmFtZSwgZXZlbnRzLCBhdHRycywgdmFsdWUpIHtcbiAgdmFyIHBhcnNlciA9IG1hcmt1cFt0eXBlXVthdHRyXVxuICAgICwgYW55T3V0LCBhbnlQYXJzZXIsIGVsT3V0LCBlbFBhcnNlciwgb3V0O1xuICBpZiAoIXBhcnNlcikgcmV0dXJuO1xuICBpZiAoYW55UGFyc2VyID0gcGFyc2VyWycqJ10pIHtcbiAgICBhbnlPdXQgPSBhbnlQYXJzZXIoZXZlbnRzLCBhdHRycywgdmFsdWUpO1xuICB9XG4gIGlmIChlbFBhcnNlciA9IHBhcnNlclt0YWdOYW1lXSkge1xuICAgIGVsT3V0ID0gZWxQYXJzZXIoZXZlbnRzLCBhdHRycywgdmFsdWUpO1xuICB9XG4gIG91dCA9IGFueU91dCA/IGV4dGVuZChhbnlPdXQsIGVsT3V0KSA6IGVsT3V0O1xuICBpZiAob3V0ICYmIG91dC5kZWwpIGRlbGV0ZSBhdHRyc1thdHRyXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gcHVzaFRleHQoc3RhY2ssIHRleHQpIHtcbiAgaWYgKHRleHQpIHN0YWNrLnB1c2goWyd0ZXh0JywgdGV4dF0pO1xufVxuXG5mdW5jdGlvbiBwdXNoVmFyRm4odmlldywgc3RhY2ssIGZuLCBuYW1lLCBlc2NhcGVGbikge1xuICBpZiAoZm4pIHtcbiAgICBwdXNoVGV4dChzdGFjaywgZm4pO1xuICB9IGVsc2Uge1xuICAgIHB1c2hUZXh0KHN0YWNrLCB0ZXh0Rm4odmlldywgbmFtZSwgZXNjYXBlRm4pKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1BhcnRpYWwodmlldywgdGFnTmFtZSkge1xuICBpZiAodGFnTmFtZSA9PT0gJ2RlcmJ5OnZpZXcnKSByZXR1cm4gdHJ1ZTtcbiAgdmFyIHNwbGl0ID0gc3BsaXRQYXJ0aWFsKHRhZ05hbWUpO1xuICBpZiAoIXNwbGl0KSByZXR1cm4gZmFsc2U7XG4gIHZhciB0YWdOcyA9IHNwbGl0WzBdO1xuICByZXR1cm4gKFxuICAgIHRhZ05zID09PSAnYXBwJyB8fFxuICAgIHRhZ05zID09PSAnbGliJyB8fFxuICAgICEhbGlicmFyeUZvck5zKHZpZXcsIHRhZ05zKVxuICApO1xufVxuXG5mdW5jdGlvbiBpc1BhcnRpYWxTZWN0aW9uKHRhZ05hbWUpIHtcbiAgcmV0dXJuIHRhZ05hbWUuY2hhckF0KDApID09PSAnQCc7XG59XG5cbmZ1bmN0aW9uIHBhcnRpYWxTZWN0aW9uTmFtZSh0YWdOYW1lKSB7XG4gIHJldHVybiBpc1BhcnRpYWxTZWN0aW9uKHRhZ05hbWUpID8gdGFnTmFtZS5zbGljZSgxKSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGxpYnJhcnlGb3JOcyh2aWV3LCBucykge1xuICB2YXIgbGlicmFyeSA9IHZpZXcuX2xpYnJhcmllcy5tYXBbbnNdO1xuICBpZiAobGlicmFyeSkgcmV0dXJuIGxpYnJhcnk7XG4gIGlmICh2aWV3LnBhcmVudCkgcmV0dXJuIHZpZXcucGFyZW50LnZpZXcuX2xpYnJhcmllcy5tYXBbbnNdO1xufVxuXG5mdW5jdGlvbiBuc1ZpZXcodmlldywgbnMpIHtcbiAgaWYgKG5zID09PSB2aWV3Ll9zZWxmTnMpIHJldHVybiB2aWV3O1xuICBpZiAodmlldy5wYXJlbnQgJiYgbnMgPT09IHZpZXcucGFyZW50LnZpZXcuX3NlbGZOcykgcmV0dXJuIHZpZXcucGFyZW50LnZpZXc7XG4gIHZhciBsaWJyYXJ5ID0gbGlicmFyeUZvck5zKHZpZXcsIG5zKTtcbiAgaWYgKCFsaWJyYXJ5KSB0aHJvdyBuZXcgRXJyb3IoJ05vIGxpYnJhcnkgZm91bmQgd2l0aCBuYW1lc3BhY2UgJyArIG5zKTtcbiAgdmFyIHBhcnRpYWxWaWV3ID0gbGlicmFyeS52aWV3O1xuICBwYXJ0aWFsVmlldy5fdW5pcXVlSWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmlldy5fdW5pcXVlSWQoKTtcbiAgfTtcbiAgcGFydGlhbFZpZXcubW9kZWwgPSB2aWV3Lm1vZGVsO1xuICBwYXJ0aWFsVmlldy5fdW5jcmVhdGVkID0gdmlldy5fdW5jcmVhdGVkO1xuICByZXR1cm4gcGFydGlhbFZpZXc7XG59XG5cbmZ1bmN0aW9uIHNwbGl0UGFydGlhbChwYXJ0aWFsKSB7XG4gIHZhciBpID0gcGFydGlhbC5pbmRleE9mKCc6Jyk7XG4gIGlmIChpID09PSAtMSkgcmV0dXJuO1xuICB2YXIgcGFydGlhbE5zID0gcGFydGlhbC5zbGljZSgwLCBpKTtcbiAgdmFyIHBhcnRpYWxOYW1lID0gcGFydGlhbC5zbGljZShpICsgMSk7XG4gIHJldHVybiBbcGFydGlhbE5zLCBwYXJ0aWFsTmFtZV07XG59XG5cbmZ1bmN0aW9uIGZpbmRDb21wb25lbnQodmlldywgcGFydGlhbCwgbnMpIHtcbiAgdmFyIGFyciA9IHNwbGl0UGFydGlhbChwYXJ0aWFsKVxuICAgICwgcGFydGlhbE5zID0gYXJyWzBdXG4gICAgLCBwYXJ0aWFsTmFtZSA9IGFyclsxXVxuICAgICwgcGFydGlhbFZpZXcgPSBuc1ZpZXcodmlldywgcGFydGlhbE5zKVxuICByZXR1cm4gcGFydGlhbFZpZXcuX2ZpbmQocGFydGlhbE5hbWUsIG5zKTtcbn1cblxuZnVuY3Rpb24gaXNWb2lkQ29tcG9uZW50KHZpZXcsIHBhcnRpYWwsIG5zKSB7XG4gIGlmIChwYXJ0aWFsID09PSAnZGVyYnk6dmlldycpIHJldHVybiB0cnVlO1xuICByZXR1cm4gIWZpbmRDb21wb25lbnQodmlldywgcGFydGlhbCwgbnMpLm5vbnZvaWQ7XG59XG5cbmZ1bmN0aW9uIHB1c2hWYXIodmlldywgbnMsIHN0YWNrLCBldmVudHMsIHJlbWFpbmRlciwgbWF0Y2gsIGZuKSB7XG4gIHZhciBuYW1lID0gbWF0Y2gubmFtZVxuICAgICwgcGFydGlhbCA9IG1hdGNoLnBhcnRpYWxcbiAgICAsIGVzY2FwZUZuID0gbWF0Y2guZXNjYXBlZCAmJiBlc2NhcGVIdG1sXG4gICAgLCBhdHRyLCBhdHRycywgYm91bmRPdXQsIGxhc3QsIHRhZ05hbWUsIHdyYXA7XG5cbiAgaWYgKHBhcnRpYWwpIHtcbiAgICBmbiA9IHBhcnRpYWxGbih2aWV3LCBwYXJ0aWFsLCAncGFydGlhbCcsIG51bGwsIG51bGwsIG5zLCBtYXRjaC5tYWNyb0N0eCk7XG4gIH1cblxuICBlbHNlIGlmIChtYXRjaC5ib3VuZCkge1xuICAgIGxhc3QgPSBsYXN0SXRlbShzdGFjayk7XG4gICAgd3JhcCA9IG1hdGNoLnByZSB8fFxuICAgICAgIWxhc3QgfHxcbiAgICAgIChsYXN0WzBdICE9PSAnc3RhcnQnKSB8fFxuICAgICAgaXNWb2lkKHRhZ05hbWUgPSBsYXN0WzFdKSB8fFxuICAgICAgd3JhcFJlbWFpbmRlcih0YWdOYW1lLCByZW1haW5kZXIpO1xuXG4gICAgaWYgKHdyYXApIHtcbiAgICAgIHN0YWNrLnB1c2goWydtYXJrZXInLCAnJywgYXR0cnMgPSB7fV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdHRycyA9IGxhc3RbMl07XG4gICAgICBmb3IgKGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgICAgcGFyc2VNYXJrdXAoJ2JvdW5kUGFyZW50JywgYXR0ciwgdGFnTmFtZSwgZXZlbnRzLCBhdHRycywgbWF0Y2gpO1xuICAgICAgfVxuICAgICAgYm91bmRPdXQgPSBwYXJzZU1hcmt1cCgnYm91bmRQYXJlbnQnLCAnKicsIHRhZ05hbWUsIGV2ZW50cywgYXR0cnMsIG1hdGNoKTtcbiAgICAgIGlmIChib3VuZE91dCkge1xuICAgICAgICBiaW5kRXZlbnRzQnlJZChldmVudHMsIG5hbWUsIG51bGwsIGF0dHJzLCBib3VuZE91dC5tZXRob2QsIGJvdW5kT3V0LnByb3BlcnR5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgYWRkSWQodmlldywgYXR0cnMpO1xuXG4gICAgaWYgKCFib3VuZE91dCkge1xuICAgICAgYmluZEV2ZW50c0J5SWQoZXZlbnRzLCBuYW1lLCBmbiwgYXR0cnMsICdodG1sJywgIWZuICYmIGVzY2FwZUZuLCBtYXRjaC50eXBlKTtcbiAgICB9XG4gIH1cblxuICBwdXNoVmFyRm4odmlldywgc3RhY2ssIGZuLCBuYW1lLCBlc2NhcGVGbik7XG4gIGlmICh3cmFwKSB7XG4gICAgc3RhY2sucHVzaChbXG4gICAgICAnbWFya2VyJ1xuICAgICwgJyQnXG4gICAgLCB7IGlkOiBmdW5jdGlvbigpIHsgcmV0dXJuIGF0dHJzLl9pZCB9IH1cbiAgICBdKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoVmFyU3RyaW5nKHZpZXcsIG5zLCBzdGFjaywgZXZlbnRzLCByZW1haW5kZXIsIG1hdGNoLCBmbikge1xuICB2YXIgbmFtZSA9IG1hdGNoLm5hbWVcbiAgICAsIGVzY2FwZUZuID0gIW1hdGNoLmVzY2FwZWQgJiYgdW5lc2NhcGVFbnRpdGllcztcbiAgZnVuY3Rpb24gYmluZE9uY2UoY3R4KSB7XG4gICAgY3R4LiRvbkJpbmQoZXZlbnRzLCBuYW1lKTtcbiAgICBiaW5kT25jZSA9IGVtcHR5O1xuICB9XG4gIGlmIChtYXRjaC5ib3VuZCkge1xuICAgIGV2ZW50cy5wdXNoKGZ1bmN0aW9uKGN0eCkge1xuICAgICAgYmluZE9uY2UoY3R4KTtcbiAgICB9KTtcbiAgfVxuICBwdXNoVmFyRm4odmlldywgc3RhY2ssIGZuLCBuYW1lLCBlc2NhcGVGbik7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTWF0Y2hFcnJvcih0ZXh0LCBtZXNzYWdlKSB7XG4gIHRocm93IG5ldyBFcnJvcihtZXNzYWdlICsgJ1xcblxcbicgKyB0ZXh0ICsgJ1xcbicpO1xufVxuXG5mdW5jdGlvbiBvbkJsb2NrKHN0YXJ0LCBlbmQsIGJsb2NrLCBxdWV1ZXMsIGNhbGxiYWNrcykge1xuICB2YXIgbGFzdFF1ZXVlLCBxdWV1ZTtcbiAgaWYgKGVuZCkge1xuICAgIGxhc3RRdWV1ZSA9IHF1ZXVlcy5wb3AoKTtcbiAgICBxdWV1ZSA9IGxhc3RJdGVtKHF1ZXVlcyk7XG4gICAgcXVldWUuc2VjdGlvbnMucHVzaChsYXN0UXVldWUpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlID0gbGFzdEl0ZW0ocXVldWVzKTtcbiAgfVxuXG4gIGlmIChzdGFydCkge1xuICAgIHF1ZXVlID0ge1xuICAgICAgc3RhY2s6IFtdXG4gICAgLCBldmVudHM6IFtdXG4gICAgLCBibG9jazogYmxvY2tcbiAgICAsIHNlY3Rpb25zOiBbXVxuICAgIH07XG4gICAgcXVldWVzLnB1c2gocXVldWUpO1xuICAgIGNhbGxiYWNrcy5vblN0YXJ0KHF1ZXVlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZW5kKSB7XG4gICAgICBjYWxsYmFja3Mub25TdGFydChxdWV1ZSk7XG4gICAgICBjYWxsYmFja3Mub25FbmQocXVldWUuc2VjdGlvbnMpO1xuICAgICAgcXVldWUuc2VjdGlvbnMgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2tzLm9uQ29udGVudChibG9jayk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlTWF0Y2godGV4dCwgbWF0Y2gsIHF1ZXVlcywgY2FsbGJhY2tzKSB7XG4gIHZhciBoYXNoID0gbWF0Y2guaGFzaFxuICAgICwgdHlwZSA9IG1hdGNoLnR5cGVcbiAgICAsIG5hbWUgPSBtYXRjaC5uYW1lXG4gICAgLCBibG9jayA9IGxhc3RJdGVtKHF1ZXVlcykuYmxvY2tcbiAgICAsIGJsb2NrVHlwZSA9IGJsb2NrICYmIGJsb2NrLnR5cGVcbiAgICAsIHN0YXJ0QmxvY2ssIGVuZEJsb2NrO1xuXG4gIGlmICh0eXBlID09PSAnaWYnIHx8IHR5cGUgPT09ICd1bmxlc3MnIHx8IHR5cGUgPT09ICdlYWNoJyB8fCB0eXBlID09PSAnd2l0aCcpIHtcbiAgICBpZiAoaGFzaCA9PT0gJyMnKSB7XG4gICAgICBzdGFydEJsb2NrID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGhhc2ggPT09ICcvJykge1xuICAgICAgZW5kQmxvY2sgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZU1hdGNoRXJyb3IodGV4dCwgdHlwZSArICcgYmxvY2tzIG11c3QgYmVnaW4gd2l0aCBhICMnKTtcbiAgICB9XG5cbiAgfSBlbHNlIGlmICh0eXBlID09PSAnZWxzZScgfHwgdHlwZSA9PT0gJ2Vsc2UgaWYnKSB7XG4gICAgaWYgKGhhc2gpIHtcbiAgICAgIHBhcnNlTWF0Y2hFcnJvcih0ZXh0LCB0eXBlICsgJyBibG9ja3MgbWF5IG5vdCBzdGFydCB3aXRoICcgKyBoYXNoKTtcbiAgICB9XG4gICAgaWYgKGJsb2NrVHlwZSAhPT0gJ2lmJyAmJiBibG9ja1R5cGUgIT09ICdlbHNlIGlmJyAmJlxuICAgICAgICBibG9ja1R5cGUgIT09ICd1bmxlc3MnICYmIGJsb2NrVHlwZSAhPT0gJ2VhY2gnKSB7XG4gICAgICBwYXJzZU1hdGNoRXJyb3IodGV4dCwgdHlwZSArICcgbWF5IG9ubHkgZm9sbG93IGBpZmAsIGBlbHNlIGlmYCwgYHVubGVzc2AsIG9yIGBlYWNoYCcpO1xuICAgIH1cbiAgICBzdGFydEJsb2NrID0gdHJ1ZTtcbiAgICBlbmRCbG9jayA9IHRydWU7XG5cbiAgfSBlbHNlIGlmIChoYXNoID09PSAnLycpIHtcbiAgICBlbmRCbG9jayA9IHRydWU7XG5cbiAgfSBlbHNlIGlmIChoYXNoID09PSAnIycpIHtcbiAgICBwYXJzZU1hdGNoRXJyb3IodGV4dCwgJyMgbXVzdCBiZSBmb2xsb3dlZCBieSBgaWZgLCBgdW5sZXNzYCwgYGVhY2hgLCBvciBgd2l0aGAnKTtcbiAgfVxuXG4gIGlmIChlbmRCbG9jayAmJiAhYmxvY2spIHtcbiAgICBwYXJzZU1hdGNoRXJyb3IodGV4dCwgJ1VubWF0Y2hlZCB0ZW1wbGF0ZSBlbmQgdGFnJyk7XG4gIH1cblxuICBvbkJsb2NrKHN0YXJ0QmxvY2ssIGVuZEJsb2NrLCBtYXRjaCwgcXVldWVzLCBjYWxsYmFja3MpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUF0dHIodmlldywgdmlld05hbWUsIGV2ZW50cywgdGFnTmFtZSwgYXR0cnMsIGF0dHIpIHtcbiAgdmFyIHZhbHVlID0gYXR0cnNbYXR0cl07XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHJldHVybjtcblxuICB2YXIgYXR0ck91dCA9IHBhcnNlTWFya3VwKCdhdHRyJywgYXR0ciwgdGFnTmFtZSwgZXZlbnRzLCBhdHRycywgdmFsdWUpIHx8IHt9XG4gICAgLCBib3VuZE91dCwgbWF0Y2gsIG5hbWUsIHJlbmRlciwgbWV0aG9kLCBwcm9wZXJ0eTtcbiAgaWYgKGF0dHJPdXQuYWRkSWQpIGFkZElkKHZpZXcsIGF0dHJzKTtcblxuICBpZiAobWF0Y2ggPSBleHRyYWN0UGxhY2Vob2xkZXIodmFsdWUpKSB7XG4gICAgbmFtZSA9IG1hdGNoLm5hbWU7XG5cbiAgICBpZiAobWF0Y2gucHJlIHx8IG1hdGNoLnBvc3QpIHtcbiAgICAgIC8vIEF0dHJpYnV0ZXMgbXVzdCBiZSBhIHNpbmdsZSBzdHJpbmcsIHNvIGNyZWF0ZSBhIHN0cmluZyBwYXJ0aWFsXG4gICAgICBhZGRJZCh2aWV3LCBhdHRycyk7XG4gICAgICByZW5kZXIgPSBwYXJzZSh2aWV3LCB2aWV3TmFtZSwgdmFsdWUsIHRydWUsIGZ1bmN0aW9uKGV2ZW50cywgbmFtZSkge1xuICAgICAgICBiaW5kRXZlbnRzQnlJZFN0cmluZyhldmVudHMsIG5hbWUsIHJlbmRlciwgYXR0cnMsICdhdHRyJywgYXR0cik7XG4gICAgICB9KTtcblxuICAgICAgYXR0cnNbYXR0cl0gPSBhdHRyID09PSAnaWQnID8gZnVuY3Rpb24oY3R4LCBtb2RlbCkge1xuICAgICAgICByZXR1cm4gYXR0cnMuX2lkID0gZXNjYXBlQXR0cmlidXRlKHJlbmRlcihjdHgsIG1vZGVsKSk7XG4gICAgICB9IDogZnVuY3Rpb24oY3R4LCBtb2RlbCkge1xuICAgICAgICByZXR1cm4gZXNjYXBlQXR0cmlidXRlKHJlbmRlcihjdHgsIG1vZGVsKSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoLmJvdW5kKSB7XG4gICAgICBib3VuZE91dCA9IHBhcnNlTWFya3VwKCdib3VuZCcsIGF0dHIsIHRhZ05hbWUsIGV2ZW50cywgYXR0cnMsIG1hdGNoKSB8fCB7fTtcbiAgICAgIGFkZElkKHZpZXcsIGF0dHJzKTtcbiAgICAgIG1ldGhvZCA9IGJvdW5kT3V0Lm1ldGhvZCB8fCAnYXR0cic7XG4gICAgICBwcm9wZXJ0eSA9IGJvdW5kT3V0LnByb3BlcnR5IHx8IGF0dHI7XG4gICAgICBiaW5kRXZlbnRzQnlJZChldmVudHMsIG5hbWUsIG51bGwsIGF0dHJzLCBtZXRob2QsIHByb3BlcnR5KTtcbiAgICB9XG5cbiAgICBpZiAoIWF0dHJPdXQuZGVsKSB7XG4gICAgICBhdHRyc1thdHRyXSA9IGF0dHJPdXQuYm9vbCA/IHtcbiAgICAgICAgYm9vbDogZnVuY3Rpb24oY3R4LCBtb2RlbCkge1xuICAgICAgICAgIHJldHVybiAoZGF0YVZhbHVlKHZpZXcsIGN0eCwgbW9kZWwsIG5hbWUpKSA/ICcgJyArIGF0dHIgOiAnJztcbiAgICAgICAgfVxuICAgICAgfSA6IHRleHRGbih2aWV3LCBuYW1lLCBlc2NhcGVBdHRyaWJ1dGUsIHRydWUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVBhcnRpYWxBdHRyKHZpZXcsIHZpZXdOYW1lLCBldmVudHMsIGF0dHJzLCBhdHRyKSB7XG4gIHZhciB2YWx1ZSA9IGF0dHJzW2F0dHJdXG4gICAgLCBtYXRjaDtcblxuICBpZiAoIXZhbHVlKSB7XG4gICAgLy8gQSB0cnVlIGJvb2xlYW4gYXR0cmlidXRlIHdpbGwgaGF2ZSBhIHZhbHVlIG9mIG51bGxcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIGF0dHJzW2F0dHJdID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoYXR0ciA9PT0gJ2JpbmQnKSB7XG4gICAgYXR0cnNbYXR0cl0gPSB7JGV2ZW50czogc3BsaXRFdmVudHModmFsdWUpLCAkdmlldzogdmlld307XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG1hdGNoID0gZXh0cmFjdFBsYWNlaG9sZGVyKHZhbHVlKSkge1xuICAgIC8vIFRoaXMgYXR0cmlidXRlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXMgYSBzZWN0aW9uXG4gICAgaWYgKG1hdGNoLnByZSB8fCBtYXRjaC5wb3N0KSByZXR1cm4gdHJ1ZTtcblxuICAgIGF0dHJzW2F0dHJdID0geyRtYXRjaE5hbWU6IG1hdGNoLm5hbWUsICRib3VuZDogbWF0Y2guYm91bmR9O1xuXG4gIH0gZWxzZSBpZiAodmFsdWUgPT09ICd0cnVlJykge1xuICAgIGF0dHJzW2F0dHJdID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ2ZhbHNlJykge1xuICAgIGF0dHJzW2F0dHJdID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09ICdudWxsJykge1xuICAgIGF0dHJzW2F0dHJdID0gbnVsbDtcbiAgfSBlbHNlIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgYXR0cnNbYXR0cl0gPSArdmFsdWU7XG4gIH0gZWxzZSBpZiAoL15be1tdLy50ZXN0KHZhbHVlKSkge1xuICAgIHRyeSB7XG4gICAgICBhdHRyc1thdHRyXSA9IEpTT04ucGFyc2UodmFsdWUpXG4gICAgfSBjYXRjaCAoZXJyKSB7fVxuICB9XG59XG5cbmZ1bmN0aW9uIGxhc3RJdGVtKGFycikge1xuICByZXR1cm4gYXJyW2Fyci5sZW5ndGggLSAxXTtcbn1cblxuZnVuY3Rpb24gcGFyc2Uodmlldywgdmlld05hbWUsIHRlbXBsYXRlLCBpc1N0cmluZywgb25CaW5kLCBub01pbmlmeSkge1xuICB2YXIgcXVldWVzLCBzdGFjaywgZXZlbnRzLCBvblJlbmRlciwgcHVzaDtcblxuICBxdWV1ZXMgPSBbe1xuICAgIHN0YWNrOiBzdGFjayA9IFtdXG4gICwgZXZlbnRzOiBldmVudHMgPSBbXVxuICAsIHNlY3Rpb25zOiBbXVxuICB9XTtcblxuICBmdW5jdGlvbiBvblN0YXJ0KHF1ZXVlKSB7XG4gICAgc3RhY2sgPSBxdWV1ZS5zdGFjaztcbiAgICBldmVudHMgPSBxdWV1ZS5ldmVudHM7XG4gIH1cblxuICBpZiAoaXNTdHJpbmcpIHtcbiAgICBwdXNoID0gcHVzaFZhclN0cmluZztcbiAgICBvblJlbmRlciA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKGN0eC4kc3RyaW5nQ3R4KSByZXR1cm4gY3R4O1xuICAgICAgY3R4ID0gT2JqZWN0LmNyZWF0ZShjdHgpO1xuICAgICAgY3R4LiRvbkJpbmQgPSBvbkJpbmQ7XG4gICAgICBjdHguJHN0cmluZ0N0eCA9IGN0eDtcbiAgICAgIHJldHVybiBjdHg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHB1c2ggPSBwdXNoVmFyO1xuICB9XG5cbiAgdmFyIGluZGV4ID0gdmlld05hbWUubGFzdEluZGV4T2YoJzonKVxuICAgICwgbnMgPSB+aW5kZXggPyB2aWV3TmFtZS5zbGljZSgwLCBpbmRleCkgOiAnJ1xuXG4gIGZ1bmN0aW9uIHBhcnNlU3RhcnQodGFnLCB0YWdOYW1lLCBhdHRycykge1xuICAgIHZhciBhdHRyLCBibG9jaywgb3V0LCBwYXJzZXIsIGlzU2VjdGlvbiwgYXR0ckJsb2NrXG4gICAgaWYgKCd4LW5vLW1pbmlmeScgaW4gYXR0cnMpIHtcbiAgICAgIGRlbGV0ZSBhdHRyc1sneC1uby1taW5pZnknXTtcbiAgICAgIG5vTWluaWZ5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNQYXJ0aWFsKHZpZXcsIHRhZ05hbWUpKSB7XG4gICAgICBibG9jayA9IHtcbiAgICAgICAgcGFydGlhbDogdGFnTmFtZVxuICAgICAgLCBtYWNyb0N0eDogYXR0cnNcbiAgICAgIH07XG4gICAgICBvbkJsb2NrKHRydWUsIGZhbHNlLCBibG9jaywgcXVldWVzLCB7b25TdGFydDogb25TdGFydH0pO1xuXG4gICAgICBmb3IgKGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgICAgaXNTZWN0aW9uID0gcGFyc2VQYXJ0aWFsQXR0cih2aWV3LCB2aWV3TmFtZSwgZXZlbnRzLCBhdHRycywgYXR0cik7XG4gICAgICAgIGlmICghaXNTZWN0aW9uKSBjb250aW51ZTtcbiAgICAgICAgYXR0ckJsb2NrID0ge1xuICAgICAgICAgIHBhcnRpYWw6ICdAJyArIGF0dHJcbiAgICAgICAgLCBtYWNyb0N0eDogbGFzdEl0ZW0ocXVldWVzKS5ibG9jay5tYWNyb0N0eFxuICAgICAgICB9O1xuICAgICAgICBvbkJsb2NrKHRydWUsIGZhbHNlLCBhdHRyQmxvY2ssIHF1ZXVlcywge29uU3RhcnQ6IG9uU3RhcnR9KTtcbiAgICAgICAgcGFyc2VUZXh0KGF0dHJzW2F0dHJdKTtcbiAgICAgICAgcGFyc2VFbmQodGFnLCAnQCcgKyBhdHRyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzVm9pZENvbXBvbmVudCh2aWV3LCB0YWdOYW1lLCBucykpIHtcbiAgICAgICAgb25CbG9jayhmYWxzZSwgdHJ1ZSwgbnVsbCwgcXVldWVzLCB7XG4gICAgICAgICAgb25TdGFydDogb25TdGFydFxuICAgICAgICAsIG9uRW5kOiBmdW5jdGlvbihxdWV1ZXMpIHtcbiAgICAgICAgICAgIHB1c2godmlldywgbnMsIHN0YWNrLCBldmVudHMsICcnLCBibG9jayk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc1BhcnRpYWxTZWN0aW9uKHRhZ05hbWUpKSB7XG4gICAgICBibG9jayA9IHtcbiAgICAgICAgcGFydGlhbDogdGFnTmFtZVxuICAgICAgLCBtYWNyb0N0eDogbGFzdEl0ZW0ocXVldWVzKS5ibG9jay5tYWNyb0N0eFxuICAgICAgfTtcbiAgICAgIG9uQmxvY2sodHJ1ZSwgZmFsc2UsIGJsb2NrLCBxdWV1ZXMsIHtvblN0YXJ0OiBvblN0YXJ0fSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHBhcnNlciA9IG1hcmt1cC5lbGVtZW50W3RhZ05hbWVdKSB7XG4gICAgICBvdXQgPSBwYXJzZXIoZXZlbnRzLCBhdHRycyk7XG4gICAgICBpZiAob3V0ICE9IG51bGwgPyBvdXQuYWRkSWQgOiB2b2lkIDApIHtcbiAgICAgICAgYWRkSWQodmlldywgYXR0cnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoYXR0ciBpbiBhdHRycykge1xuICAgICAgcGFyc2VBdHRyKHZpZXcsIHZpZXdOYW1lLCBldmVudHMsIHRhZ05hbWUsIGF0dHJzLCBhdHRyKTtcbiAgICB9XG4gICAgc3RhY2sucHVzaChbJ3N0YXJ0JywgdGFnTmFtZSwgYXR0cnNdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlVGV4dCh0ZXh0LCBpc1Jhd1RleHQsIHJlbWFpbmRlcikge1xuICAgIHZhciBtYXRjaCA9IGV4dHJhY3RQbGFjZWhvbGRlcih0ZXh0KVxuICAgICAgLCBwb3N0LCBwcmU7XG4gICAgaWYgKCFtYXRjaCB8fCBpc1Jhd1RleHQpIHtcbiAgICAgIGlmICghbm9NaW5pZnkpIHtcbiAgICAgICAgdGV4dCA9IGlzU3RyaW5nID8gdW5lc2NhcGVFbnRpdGllcyh0cmltVGV4dCh0ZXh0KSkgOiB0cmltVGV4dCh0ZXh0KTtcbiAgICAgIH1cbiAgICAgIHB1c2hUZXh0KHN0YWNrLCB0ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwcmUgPSBtYXRjaC5wcmU7XG4gICAgcG9zdCA9IG1hdGNoLnBvc3Q7XG4gICAgaWYgKGlzU3RyaW5nKSBwcmUgPSB1bmVzY2FwZUVudGl0aWVzKHByZSk7XG4gICAgcHVzaFRleHQoc3RhY2ssIHByZSk7XG4gICAgcmVtYWluZGVyID0gcG9zdCB8fCByZW1haW5kZXI7XG5cbiAgICBwYXJzZU1hdGNoKHRleHQsIG1hdGNoLCBxdWV1ZXMsIHtcbiAgICAgIG9uU3RhcnQ6IG9uU3RhcnRcbiAgICAsIG9uRW5kOiBmdW5jdGlvbihzZWN0aW9ucykge1xuICAgICAgICB2YXIgZm4gPSBibG9ja0ZuKHZpZXcsIHNlY3Rpb25zKTtcbiAgICAgICAgcHVzaCh2aWV3LCBucywgc3RhY2ssIGV2ZW50cywgcmVtYWluZGVyLCBzZWN0aW9uc1swXS5ibG9jaywgZm4pO1xuICAgICAgfVxuICAgICwgb25Db250ZW50OiBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICBwdXNoKHZpZXcsIG5zLCBzdGFjaywgZXZlbnRzLCByZW1haW5kZXIsIG1hdGNoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChwb3N0KSByZXR1cm4gcGFyc2VUZXh0KHBvc3QpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFbmQodGFnLCB0YWdOYW1lKSB7XG4gICAgdmFyIHNlY3Rpb25OYW1lID0gcGFydGlhbFNlY3Rpb25OYW1lKHRhZ05hbWUpXG4gICAgICAsIGVuZHNQYXJ0aWFsID0gaXNQYXJ0aWFsKHZpZXcsIHRhZ05hbWUpXG4gICAgaWYgKGVuZHNQYXJ0aWFsICYmIGlzVm9pZENvbXBvbmVudCh2aWV3LCB0YWdOYW1lLCBucykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRW5kIHRhZyBcIicgKyB0YWcgKyAnXCIgaXMgbm90IGFsbG93ZWQgZm9yIHZvaWQgY29tcG9uZW50JylcbiAgICB9XG4gICAgaWYgKHNlY3Rpb25OYW1lIHx8IGVuZHNQYXJ0aWFsKSB7XG4gICAgICBvbkJsb2NrKGZhbHNlLCB0cnVlLCBudWxsLCBxdWV1ZXMsIHtcbiAgICAgICAgb25TdGFydDogb25TdGFydFxuICAgICAgLCBvbkVuZDogZnVuY3Rpb24ocXVldWVzKSB7XG4gICAgICAgICAgdmFyIHF1ZXVlID0gcXVldWVzWzBdXG4gICAgICAgICAgICAsIGJsb2NrID0gcXVldWUuYmxvY2tcbiAgICAgICAgICAgICwgZm4gPSByZW5kZXJlcih2aWV3LCByZWR1Y2VTdGFjayhxdWV1ZS5zdGFjayksIHF1ZXVlLmV2ZW50cylcbiAgICAgICAgICBmbi51bmVzY2FwZWQgPSB0cnVlO1xuICAgICAgICAgIGlmIChzZWN0aW9uTmFtZSkge1xuICAgICAgICAgICAgYmxvY2subWFjcm9DdHhbc2VjdGlvbk5hbWVdID0gZm47XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFB1dCB0aGUgcmVtYWluaW5nIGNvbnRlbnQgbm90IGluIGEgc2VjdGlvbiBpbiB0aGUgZGVmYXVsdCBcImNvbnRlbnRcIiBzZWN0aW9uLFxuICAgICAgICAgIC8vIHVubGVzcyBcImluaGVyaXRcIiBpcyBzcGVjaWZpZWQgYW5kIHRoZXJlIGlzIG5vIGNvbnRlbnQsIHNvIHRoYXQgdGhlIHBhcmVudFxuICAgICAgICAgIC8vIGNvbnRlbnQgY2FuIGJlIGluaGVyaXRlZFxuICAgICAgICAgIGlmIChxdWV1ZS5zdGFjay5sZW5ndGggfHwgIWJsb2NrLm1hY3JvQ3R4LmluaGVyaXQpIHtcbiAgICAgICAgICAgIGJsb2NrLm1hY3JvQ3R4LmNvbnRlbnQgPSBmbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHVzaCh2aWV3LCBucywgc3RhY2ssIGV2ZW50cywgJycsIGJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RhY2sucHVzaChbJ2VuZCcsIHRhZ05hbWVdKTtcbiAgfVxuXG4gIGlmIChpc1N0cmluZykge1xuICAgIHBhcnNlVGV4dCh0ZW1wbGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGFyc2VIdG1sKHRlbXBsYXRlLCB7XG4gICAgICBzdGFydDogcGFyc2VTdGFydFxuICAgICwgdGV4dDogcGFyc2VUZXh0XG4gICAgLCBlbmQ6IHBhcnNlRW5kXG4gICAgLCBjb21tZW50OiBmdW5jdGlvbih0YWcpIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbmFsQ29tbWVudCh0YWcpKSBwdXNoVGV4dChzdGFjaywgdGFnKTtcbiAgICAgIH1cbiAgICAsIG90aGVyOiBmdW5jdGlvbih0YWcpIHtcbiAgICAgICAgcHVzaFRleHQoc3RhY2ssIHRhZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlbmRlcmVyKHZpZXcsIHJlZHVjZVN0YWNrKHN0YWNrKSwgZXZlbnRzLCBvblJlbmRlcik7XG59XG5cbn0pKHdpbmRvdykiLCJ2YXIgZXZlbnRCaW5kaW5nID0gcmVxdWlyZSgnLi9ldmVudEJpbmRpbmcnKVxuICAsIHNwbGl0RXZlbnRzID0gZXZlbnRCaW5kaW5nLnNwbGl0RXZlbnRzXG4gICwgY29udGFpbnNFdmVudCA9IGV2ZW50QmluZGluZy5jb250YWluc0V2ZW50XG4gICwgYWRkRG9tRXZlbnQgPSBldmVudEJpbmRpbmcuYWRkRG9tRXZlbnRcbiAgLCBURVhUX0VWRU5UUyA9ICdrZXl1cCxrZXlkb3duLzAsY3V0LzAscGFzdGUvMCxkcmFnb3Zlci8wLGJsdXInXG4gICwgQVVUT0NPTVBMRVRFX09GRiA9IHtcbiAgICAgIGNoZWNrYm94OiB0cnVlXG4gICAgLCByYWRpbzogdHJ1ZVxuICAgIH1cbiAgLCBvbkJpbmRBLCBvbkJpbmRGb3JtO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYm91bmQ6IHtcbiAgICAndmFsdWUnOiB7XG4gICAgICAnaW5wdXQnOiBmdW5jdGlvbihldmVudHMsIGF0dHJzLCBtYXRjaCkge1xuICAgICAgICB2YXIgdHlwZSA9IGF0dHJzLnR5cGVcbiAgICAgICAgICAsIGV2ZW50TmFtZXMsIG1ldGhvZDtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdyYWRpbycgfHwgdHlwZSA9PT0gJ2NoZWNrYm94JykgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3JhbmdlJyB8fCAneC1ibHVyJyBpbiBhdHRycykge1xuICAgICAgICAgIC8vIE9ubHkgdXBkYXRlIGFmdGVyIHRoZSBlbGVtZW50IGxvc2VzIGZvY3VzXG4gICAgICAgICAgZGVsZXRlIGF0dHJzWyd4LWJsdXInXTtcbiAgICAgICAgICBldmVudE5hbWVzID0gJ2NoYW5nZSxibHVyJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBCeSBkZWZhdWx0LCB1cGRhdGUgYXMgdGhlIHVzZXIgdHlwZXNcbiAgICAgICAgICBldmVudE5hbWVzID0gVEVYVF9FVkVOVFM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCd4LWF0b21pYycgaW4gYXR0cnMpIHtcbiAgICAgICAgICBkZWxldGUgYXR0cnNbJ3gtYXRvbWljJ107XG4gICAgICAgICAgbWV0aG9kID0gJ3Byb3AnO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd0ZXh0JyB8fCAhdHlwZSkge1xuICAgICAgICAgIG1ldGhvZCA9ICdwcm9wT3QnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1ldGhvZCA9ICdwcm9wJztcbiAgICAgICAgfVxuICAgICAgICBhZGREb21FdmVudChldmVudHMsIGF0dHJzLCBldmVudE5hbWVzLCBtYXRjaCwge1xuICAgICAgICAgIG1ldGhvZDogbWV0aG9kXG4gICAgICAgICwgcHJvcGVydHk6ICd2YWx1ZSdcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7bWV0aG9kOiBtZXRob2R9O1xuICAgICAgfVxuICAgIH1cblxuICAsICdjaGVja2VkJzoge1xuICAgICAgJyonOiBmdW5jdGlvbihldmVudHMsIMKgYXR0cnMsIG1hdGNoKSB7XG4gICAgICAgIGFkZERvbUV2ZW50KGV2ZW50cywgYXR0cnMsICdjaGFuZ2UnLCBtYXRjaCwge1xuICAgICAgICAgIG1ldGhvZDogJ3Byb3AnXG4gICAgICAgICwgcHJvcGVydHk6ICdjaGVja2VkJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHttZXRob2Q6ICdwcm9wJ307XG4gICAgICB9XG4gICAgfVxuXG4gICwgJ3NlbGVjdGVkJzoge1xuICAgICAgJyonOiBmdW5jdGlvbihldmVudHMsIGF0dHJzLCBtYXRjaCkge1xuICAgICAgICBhZGREb21FdmVudChldmVudHMsIGF0dHJzLCAnY2hhbmdlJywgbWF0Y2gsIHtcbiAgICAgICAgICBtZXRob2Q6ICdwcm9wJ1xuICAgICAgICAsIHByb3BlcnR5OiAnc2VsZWN0ZWQnXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge21ldGhvZDogJ3Byb3AnfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgLCAnZGlzYWJsZWQnOiB7XG4gICAgICAnKic6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge21ldGhvZDogJ3Byb3AnfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuLCBib3VuZFBhcmVudDoge1xuICAgICdjb250ZW50ZWRpdGFibGUnOiB7XG4gICAgICAnKic6IGZ1bmN0aW9uKGV2ZW50cywgYXR0cnMsIG1hdGNoKSB7XG4gICAgICAgIGFkZERvbUV2ZW50KGV2ZW50cywgYXR0cnMsIFRFWFRfRVZFTlRTLCBtYXRjaCwge1xuICAgICAgICAgIG1ldGhvZDogJ2h0bWwnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAsICcqJzoge1xuICAgICAgJ3RleHRhcmVhJzogZnVuY3Rpb24oZXZlbnRzLCBhdHRycywgbWF0Y2gpIHtcbiAgICAgICAgaWYgKCd4LWF0b21pYycgaW4gYXR0cnMpIHtcbiAgICAgICAgICBkZWxldGUgYXR0cnNbJ3gtYXRvbWljJ107XG4gICAgICAgICAgdmFyIG1ldGhvZCA9ICdwcm9wJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbWV0aG9kID0gJ3Byb3BPdCc7XG4gICAgICAgIH1cbiAgICAgICAgYWRkRG9tRXZlbnQoZXZlbnRzLCBhdHRycywgVEVYVF9FVkVOVFMsIG1hdGNoLCB7XG4gICAgICAgICAgbWV0aG9kOiBtZXRob2RcbiAgICAgICAgLCBwcm9wZXJ0eTogJ3ZhbHVlJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHttZXRob2Q6IG1ldGhvZCwgcHJvcGVydHk6ICd2YWx1ZSd9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4sIGVsZW1lbnQ6IHtcbiAgICAnc2VsZWN0JzogZnVuY3Rpb24oZXZlbnRzLCBhdHRycykge1xuICAgICAgLy8gRGlzdHJpYnV0ZSBjaGFuZ2UgZXZlbnQgdG8gY2hpbGQgbm9kZXMgb2Ygc2VsZWN0IGVsZW1lbnRzXG4gICAgICBhZGREb21FdmVudChldmVudHMsIGF0dHJzLCAnY2hhbmdlOiRmb3JDaGlsZHJlbicpO1xuICAgICAgcmV0dXJuIHthZGRJZDogdHJ1ZX07XG4gICAgfVxuXG4gICwgJ2lucHV0JzogZnVuY3Rpb24oZXZlbnRzLCBhdHRycykge1xuICAgICAgaWYgKEFVVE9DT01QTEVURV9PRkZbYXR0cnMudHlwZV0gJiYgISgnYXV0b2NvbXBsZXRlJyBpbiBhdHRycykpIHtcbiAgICAgICAgYXR0cnMuYXV0b2NvbXBsZXRlID0gJ29mZic7XG4gICAgICB9XG4gICAgICBpZiAoYXR0cnMudHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgICAvLyBEaXN0cmlidXRlIGNoYW5nZSBldmVudHMgdG8gb3RoZXIgZWxlbWVudHMgd2l0aCB0aGUgc2FtZSBuYW1lXG4gICAgICAgIGFkZERvbUV2ZW50KGV2ZW50cywgYXR0cnMsICdjaGFuZ2U6JGZvck5hbWUnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuLCBhdHRyOiB7XG4gICAgJ3gtYmluZCc6IHtcbiAgICAgICcqJzogZnVuY3Rpb24oZXZlbnRzLCBhdHRycywgZXZlbnROYW1lcykge1xuICAgICAgICBhZGREb21FdmVudChldmVudHMsIGF0dHJzLCBldmVudE5hbWVzKTtcbiAgICAgICAgcmV0dXJuIHthZGRJZDogdHJ1ZSwgZGVsOiB0cnVlfTtcbiAgICAgIH1cblxuICAgICwgJ2EnOiBvbkJpbmRBID0gZnVuY3Rpb24oZXZlbnRzLCBhdHRycywgZXZlbnROYW1lcykge1xuICAgICAgICBpZiAoY29udGFpbnNFdmVudChldmVudE5hbWVzLCBbJ2NsaWNrJywgJ2ZvY3VzJ10pICYmICEoJ2hyZWYnIGluIGF0dHJzKSkge1xuICAgICAgICAgIGF0dHJzLmhyZWYgPSAnIyc7XG4gICAgICAgICAgaWYgKCEoJ29uY2xpY2snIGluIGF0dHJzKSkge1xuICAgICAgICAgICAgYXR0cnMub25jbGljayA9ICdyZXR1cm4gZmFsc2UnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgLCAnZm9ybSc6IG9uQmluZEZvcm0gPSBmdW5jdGlvbihldmVudHMsIGF0dHJzLCBldmVudE5hbWVzKSB7XG4gICAgICAgIGlmIChjb250YWluc0V2ZW50KGV2ZW50TmFtZXMsICdzdWJtaXQnKSkge1xuICAgICAgICAgIGlmICghKCdvbnN1Ym1pdCcgaW4gYXR0cnMpKSB7XG4gICAgICAgICAgICBhdHRycy5vbnN1Ym1pdCA9ICdyZXR1cm4gZmFsc2UnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAsICd4LWNhcHR1cmUnOiB7XG4gICAgICAnKic6IGZ1bmN0aW9uKGV2ZW50cywgYXR0cnMsIGV2ZW50TmFtZXMpIHtcbiAgICAgICAgYWRkRG9tRXZlbnQoZXZlbnRzLCBhdHRycywgZXZlbnROYW1lcywgbnVsbCwge2NhcHR1cmU6IHRydWV9KTtcbiAgICAgICAgcmV0dXJuIHthZGRJZDogdHJ1ZSwgZGVsOiB0cnVlfTtcbiAgICAgIH1cbiAgICAsICdhJzogb25CaW5kQVxuICAgICwgJ2Zvcm0nOiBvbkJpbmRGb3JtXG4gICAgfVxuXG4gICwgJ3gtYXMnOiB7XG4gICAgICAnKic6IGZ1bmN0aW9uKGV2ZW50cywgYXR0cnMsIG5hbWUpIHtcbiAgICAgICAgZXZlbnRzLnB1c2goZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgY3R4LiRlbGVtZW50c1tuYW1lXSA9IGF0dHJzLl9pZCB8fCBhdHRycy5pZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7YWRkSWQ6IHRydWUsIGRlbDogdHJ1ZX1cbiAgICAgIH1cbiAgfVxuXG4gICwgJ2NoZWNrZWQnOiB7XG4gICAgICAnKic6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge2Jvb2w6IHRydWV9O1xuICAgICAgfVxuICAgIH1cblxuICAsICdzZWxlY3RlZCc6IHtcbiAgICAgICcqJzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7Ym9vbDogdHJ1ZX07XG4gICAgICB9XG4gICAgfVxuXG4gICwgJ2Rpc2FibGVkJzoge1xuICAgICAgJyonOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtib29sOiB0cnVlfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgLCAnYXV0b2ZvY3VzJzoge1xuICAgICAgJyonOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtib29sOiB0cnVlfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuLCBURVhUX0VWRU5UUzogVEVYVF9FVkVOVFNcbiwgQVVUT0NPTVBMRVRFX09GRjogQVVUT0NPTVBMRVRFX09GRlxufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgncmFjZXInKS51dGlsXG4gICwgdmlld1BhdGggPSByZXF1aXJlKCcuL3ZpZXdQYXRoJylcbiAgLCBleHRyYWN0UGxhY2Vob2xkZXIgPSB2aWV3UGF0aC5leHRyYWN0UGxhY2Vob2xkZXJcbiAgLCBkYXRhVmFsdWUgPSB2aWV3UGF0aC5kYXRhVmFsdWVcbiAgLCBjdHhQYXRoID0gdmlld1BhdGguY3R4UGF0aFxuICAsIHBhdGhGbkFyZ3MgPSB2aWV3UGF0aC5wYXRoRm5BcmdzXG4gICwgc2V0Qm91bmRGbiA9IHZpZXdQYXRoLnNldEJvdW5kRm5cbiAgLCBhcnJheVNsaWNlID0gW10uc2xpY2VcblxuZXhwb3J0cy5zcGxpdEV2ZW50cyA9IHNwbGl0RXZlbnRzO1xuZXhwb3J0cy5mbkxpc3RlbmVyID0gZm5MaXN0ZW5lcjtcbmV4cG9ydHMuY29udGFpbnNFdmVudCA9IGNvbnRhaW5zRXZlbnQ7XG5leHBvcnRzLmFkZERvbUV2ZW50ID0gdXRpbC5pc1NlcnZlciA/IGVtcHR5IDogYWRkRG9tRXZlbnQ7XG5cbmZ1bmN0aW9uIHNwbGl0RXZlbnRzKGV2ZW50TmFtZXMpIHtcbiAgdmFyIHBhaXJzID0gZXZlbnROYW1lcy5zcGxpdCgnLCcpXG4gICAgLCBldmVudExpc3QgPSBbXVxuICAgICwgaSwgaiwgcGFpciwgc2VnbWVudHMsIG5hbWUsIGV2ZW50TmFtZSwgZGVsYXksIGZucywgZm47XG4gIGZvciAoaSA9IHBhaXJzLmxlbmd0aDsgaS0tOykge1xuICAgIHBhaXIgPSBwYWlyc1tpXTtcbiAgICBzZWdtZW50cyA9IHBhaXIuc3BsaXQoJzonKTtcbiAgICBuYW1lID0gc2VnbWVudHNbMF0uc3BsaXQoJy8nKTtcbiAgICBldmVudE5hbWUgPSBuYW1lWzBdLnRyaW0oKTtcbiAgICBkZWxheSA9IG5hbWVbMV07XG4gICAgZm5zID0gKHNlZ21lbnRzWzFdIHx8ICcnKS50cmltKCkuc3BsaXQoL1xccysvKTtcbiAgICBmb3IgKGogPSBmbnMubGVuZ3RoOyBqLS07KSB7XG4gICAgICBmbiA9IGZuc1tqXTtcbiAgICAgIGZuc1tqXSA9IGV4dHJhY3RQbGFjZWhvbGRlcihmbikgfHwgZm47XG4gICAgfVxuICAgIGV2ZW50TGlzdC5wdXNoKFtldmVudE5hbWUsIGRlbGF5LCBmbnNdKTtcbiAgfVxuICByZXR1cm4gZXZlbnRMaXN0O1xufVxuXG5mdW5jdGlvbiBjb250YWluc0V2ZW50KGV2ZW50TmFtZXMsIGV4cGVjdGVkKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZCkpIGV4cGVjdGVkID0gW2V4cGVjdGVkXTtcbiAgdmFyIGV2ZW50TGlzdCA9IHNwbGl0RXZlbnRzKGV2ZW50TmFtZXMpXG4gICAgLCBpLCBqLCBldmVudE5hbWVcbiAgZm9yIChpID0gZXZlbnRMaXN0Lmxlbmd0aDsgaS0tOykge1xuICAgIGV2ZW50TmFtZSA9IGV2ZW50TGlzdFtpXVswXTtcbiAgICBmb3IgKGogPSBleHBlY3RlZC5sZW5ndGg7IGotLTspIHtcbiAgICAgIGlmIChldmVudE5hbWUgPT09IGV4cGVjdGVkW2pdKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhZGREb21FdmVudChldmVudHMsIGF0dHJzLCBldmVudE5hbWVzLCBtYXRjaCwgb3B0aW9ucykge1xuICB2YXIgZXZlbnRMaXN0ID0gc3BsaXRFdmVudHMoZXZlbnROYW1lcylcbiAgICAsIGFyZ3MsIG5hbWU7XG5cbiAgaWYgKG1hdGNoKSB7XG4gICAgbmFtZSA9IG1hdGNoLm5hbWU7XG5cbiAgICBpZiAofm5hbWUuaW5kZXhPZignKCcpKSB7XG4gICAgICBhcmdzID0gcGF0aEZuQXJncyhuYW1lKTtcbiAgICAgIGlmICghYXJncy5sZW5ndGgpIHJldHVybjtcblxuICAgICAgZXZlbnRzLnB1c2goZnVuY3Rpb24oY3R4LCBtb2RlbEV2ZW50cywgZG9tLCBwYXRoTWFwLCB2aWV3KSB7XG4gICAgICAgIHZhciBpZCA9IGF0dHJzLl9pZCB8fCBhdHRycy5pZFxuICAgICAgICAgICwgcGF0aHMgPSBbXVxuICAgICAgICAgICwgYXJnLCBwYXRoLCBwYXRoSWQsIGV2ZW50LCBldmVudE5hbWUsIGV2ZW50T3B0aW9ucywgaSwgajtcbiAgICAgICAgb3B0aW9ucy5zZXRWYWx1ZSA9IGZ1bmN0aW9uKG1vZGVsLCB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBzZXRCb3VuZEZuKHZpZXcsIGN0eCwgbW9kZWwsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSBhcmdzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgIGFyZyA9IGFyZ3NbaV07XG4gICAgICAgICAgcGF0aCA9IGN0eFBhdGgodmlldywgY3R4LCBhcmcpO1xuICAgICAgICAgIHBhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgICAgcGF0aElkID0gcGF0aE1hcC5pZChwYXRoKTtcbiAgICAgICAgICBmb3IgKGogPSBldmVudExpc3QubGVuZ3RoOyBqLS07KSB7XG4gICAgICAgICAgICBldmVudCA9IGV2ZW50TGlzdFtqXTtcbiAgICAgICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50WzBdO1xuICAgICAgICAgICAgZXZlbnRPcHRpb25zID0gdXRpbC5tZXJnZUludG8oe3ZpZXc6IHZpZXcsIGN0eDogY3R4LCBwYXRoSWQ6IHBhdGhJZCwgZGVsYXk6IGV2ZW50WzFdfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBkb20uYmluZChldmVudE5hbWUsIGlkLCBldmVudE9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnRzLnB1c2goZnVuY3Rpb24oY3R4LCBtb2RlbEV2ZW50cywgZG9tLCBwYXRoTWFwLCB2aWV3KSB7XG4gICAgICB2YXIgaWQgPSBhdHRycy5faWQgfHwgYXR0cnMuaWRcbiAgICAgICAgLCBwYXRoSWQgPSBwYXRoTWFwLmlkKGN0eFBhdGgodmlldywgY3R4LCBuYW1lKSlcbiAgICAgICAgLCBldmVudCwgZXZlbnROYW1lLCBldmVudE9wdGlvbnMsIGk7XG4gICAgICBmb3IgKGkgPSBldmVudExpc3QubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIGV2ZW50ID0gZXZlbnRMaXN0W2ldO1xuICAgICAgICBldmVudE5hbWUgPSBldmVudFswXTtcbiAgICAgICAgZXZlbnRPcHRpb25zID0gdXRpbC5tZXJnZUludG8oe3ZpZXc6IHZpZXcsIGN0eDogY3R4LCBwYXRoSWQ6IHBhdGhJZCwgZGVsYXk6IGV2ZW50WzFdfSwgb3B0aW9ucyk7XG4gICAgICAgIGRvbS5iaW5kKGV2ZW50TmFtZSwgaWQsIGV2ZW50T3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZXZlbnRzLnB1c2goZnVuY3Rpb24oY3R4LCBtb2RlbEV2ZW50cywgZG9tLCBwYXRoTWFwLCB2aWV3KSB7XG4gICAgdmFyIGlkID0gYXR0cnMuX2lkIHx8IGF0dHJzLmlkXG4gICAgICAsIHBhdGhJZCA9IHBhdGhNYXAuaWQoY3R4UGF0aCh2aWV3LCBjdHgsICcuJykpXG4gICAgICAsIGV2ZW50LCBldmVudE5hbWUsIGV2ZW50T3B0aW9ucywgaTtcbiAgICBmb3IgKGkgPSBldmVudExpc3QubGVuZ3RoOyBpLS07KSB7XG4gICAgICBldmVudCA9IGV2ZW50TGlzdFtpXTtcbiAgICAgIGV2ZW50TmFtZSA9IGV2ZW50WzBdO1xuICAgICAgZXZlbnRPcHRpb25zID0gZm5MaXN0ZW5lcih2aWV3LCBjdHgsIGV2ZW50WzJdLCBkb20pO1xuICAgICAgZXZlbnRPcHRpb25zLmRlbGF5ID0gZXZlbnRbMV07XG4gICAgICB1dGlsLm1lcmdlSW50byhldmVudE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgdXRpbC5tZXJnZUludG8oZXZlbnRPcHRpb25zLCB7dmlldzogdmlldywgY3R4OiBjdHgsIHBhdGhJZDogcGF0aElkfSk7XG4gICAgICBkb20uYmluZChldmVudE5hbWUsIGlkLCBldmVudE9wdGlvbnMpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGVhY2hGbkxpc3RlbmVyKHZpZXcsIGN0eCwgZm5PYmosIGRvbSkge1xuICB2YXIgZm5OYW1lLCBmbiwgZm5DdHhzLCBpLCBmbkN0eDtcblxuICBmbk5hbWUgPSB0eXBlb2YgZm5PYmogPT09ICdvYmplY3QnXG4gICAgPyBkYXRhVmFsdWUodmlldywgY3R4LCB2aWV3Lm1vZGVsLCBmbk9iai5uYW1lKVxuICAgIDogZm5OYW1lID0gZm5PYmo7XG5cbiAgLy8gSWYgYSBwbGFjZWhvbGRlciBmb3IgYW4gZXZlbnQgbmFtZSBkb2VzIG5vdCBoYXZlIGEgdmFsdWUsIGRvIG5vdGhpbmdcbiAgaWYgKCFmbk5hbWUpIHJldHVybiBlbXB0eTtcblxuICAvLyBTZWUgaWYgaXQgaXMgYSBidWlsdC1pbiBmdW5jdGlvblxuICBmbiA9IGRvbSAmJiBkb20uZm5zW2ZuTmFtZV07XG5cbiAgLy8gTG9va3VwIHRoZSBmdW5jdGlvbiBuYW1lIG9uIHRoZSBjb21wb25lbnQgc2NyaXB0IG9yIGFwcFxuXG4gIC8vIFRPRE86IFRoaXMgc2ltcGx5IGxvb2tzIGluIHRoZSBsb2NhbCBzY29wZSBmb3IgdGhlIGZ1bmN0aW9uXG4gIC8vIGFuZCB0aGVuIGdvZXMgdXAgdGhlIHNjb3BlIGlmIGEgZnVuY3Rpb24gbmFtZSBpcyBub3QgZm91bmQuXG4gIC8vIEJldHRlciB3b3VsZCBiZSB0byBhY3R1YWxseSBmaWd1cmUgb3V0IHRoZSBzY29wZSBvZiB3aGVyZSB0aGVcbiAgLy8gZnVuY3Rpb24gbmFtZSBpcyBzcGVjZmllZCwgc2luY2UgdGhlcmUgY291bGQgZWFzaWx5IGJlIG5hbWVzcGFjZVxuICAvLyBjb25mbGljdHMgYmV0d2VlbiBmdW5jdGlvbnMgaW4gYSBjb21wb25lbnQgYW5kIGZ1bmN0aW9ucyBpbiBhblxuICAvLyBhcHAgdXNpbmcgdGhhdCBjb21wb25lbnQuIEhvdyB0byBpbXBsZW1lbnQgdGhpcyBjb3JyZWN0bHkgaXMgbm90XG4gIC8vIG9idmlvdXMgYXQgdGhlIG1vbWVudC5cbiAgaWYgKCFmbikge1xuICAgIGZuQ3R4cyA9IGN0eC4kZm5DdHg7XG4gICAgZm9yIChpID0gZm5DdHhzLmxlbmd0aDsgaS0tOykge1xuICAgICAgZm5DdHggPSBmbkN0eHNbaV07XG4gICAgICBmbiA9IGZuQ3R4W2ZuTmFtZV0gfHwgdmlld1BhdGgubG9va3VwKGZuTmFtZSwgZm5DdHgpO1xuICAgICAgaWYgKGZuKSBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKCFmbikgdGhyb3cgbmV3IEVycm9yKCdCb3VuZCBmdW5jdGlvbiBub3QgZm91bmQ6ICcgKyBmbk5hbWUpO1xuXG4gIC8vIEJpbmQgdGhlIGxpc3RlbmVyIHRvIHRoZSBhcHAgb3IgY29tcG9uZW50IG9iamVjdCBvbiB3aGljaCBpdFxuICAvLyB3YXMgZGVmaW5lZCBzbyB0aGF0IHRoZSBgdGhpc2AgY29udGV4dCB3aWxsIGJlIHRoZSBpbnN0YW5jZVxuICByZXR1cm4gZm4uYmluZChmbkN0eCk7XG59XG5cbmZ1bmN0aW9uIGZuTGlzdGVuZXIodmlldywgY3R4LCBmbk5hbWVzLCBkb20pIHtcbiAgdmFyIGxpc3RlbmVyID0ge1xuICAgIGZuOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsZW4gPSBmbk5hbWVzLmxlbmd0aFxuICAgICAgICAsIGFyZ3MgPSBhcnJheVNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgICAgICAsIGksIGZuLCBib3VuZEZuc1xuXG4gICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIG5vIGhhbmRsZXIgZnVuY3Rpb25zIHdlcmUgc3BlY2lmaWVkXG4gICAgICAgIHJldHVybiBsaXN0ZW5lci5mbiA9IGVtcHR5O1xuXG4gICAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgICBmbiA9IGVhY2hGbkxpc3RlbmVyKHZpZXcsIGN0eCwgZm5OYW1lc1swXSwgZG9tKTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYm91bmRGbnMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gbGVuOyBpLS07KSB7XG4gICAgICAgICAgYm91bmRGbnMucHVzaChlYWNoRm5MaXN0ZW5lcih2aWV3LCBjdHgsIGZuTmFtZXNbaV0sIGRvbSkpO1xuICAgICAgICB9XG4gICAgICAgIGZuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBhcnJheVNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgICAgICAgIGZvciAodmFyIGkgPSBib3VuZEZucy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgIGJvdW5kRm5zW2ldLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lci5mbiA9IGZuO1xuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gbGlzdGVuZXI7XG59XG5cbmZ1bmN0aW9uIGVtcHR5KCkge31cbiIsInZhciB0cmltTGVhZGluZyA9IHJlcXVpcmUoJ2h0bWwtdXRpbCcpLnRyaW1MZWFkaW5nO1xuXG5leHBvcnRzLndyYXBSZW1haW5kZXIgPSB3cmFwUmVtYWluZGVyO1xuZXhwb3J0cy5leHRyYWN0UGxhY2Vob2xkZXIgPSBleHRyYWN0UGxhY2Vob2xkZXI7XG5leHBvcnRzLnBhdGhGbkFyZ3MgPSBwYXRoRm5BcmdzO1xuZXhwb3J0cy5zcXVhcmVCcmFja2V0c0FyZ3MgPSBzcXVhcmVCcmFja2V0c0FyZ3M7XG5leHBvcnRzLmN0eFBhdGggPSBjdHhQYXRoO1xuZXhwb3J0cy5nZXRWYWx1ZSA9IGdldFZhbHVlO1xuZXhwb3J0cy5kYXRhVmFsdWUgPSBkYXRhVmFsdWU7XG5leHBvcnRzLnNldEJvdW5kRm4gPSBzZXRCb3VuZEZuO1xuZXhwb3J0cy5sb29rdXAgPSBsb29rdXA7XG5leHBvcnRzLnJlcGxhY2VTcXVhcmVCcmFja2V0cyA9IHJlcGxhY2VTcXVhcmVCcmFja2V0cztcblxuZnVuY3Rpb24gd3JhcFJlbWFpbmRlcih0YWdOYW1lLCByZW1haW5kZXIpIHtcbiAgaWYgKCFyZW1haW5kZXIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuICEobmV3IFJlZ0V4cCgnXjxcXC8nICsgdGFnTmFtZSwgJ2knKSkudGVzdChyZW1haW5kZXIpO1xufVxuXG52YXIgb3BlblBsYWNlaG9sZGVyID0gL14oW1xcc1xcU10qPykoXFx7ezEsM30pXFxzKihbXFxzXFxTXSopL1xuICAsIGFsaWFzQ29udGVudCA9IC9eKFtcXHNcXFNdKilcXHMrYXNcXHMrOihcXFMrKVxccyokL1xuICAsIGJsb2NrQ29udGVudCA9IC9eKFtcXCNcXC9dPykoZWxzZVxcc2lmfGlmfGVsc2V8dW5sZXNzfGVhY2h8d2l0aHx1bmVzY2FwZWQpP1xccyooW1xcc1xcU10qPylcXHMqJC9cbiAgLCBjbG9zZU1hcCA9IHsgMTogJ30nLCAyOiAnfX0nIH1cbmZ1bmN0aW9uIGV4dHJhY3RQbGFjZWhvbGRlcih0ZXh0KSB7XG4gIHZhciBtYXRjaCA9IG9wZW5QbGFjZWhvbGRlci5leGVjKHRleHQpO1xuICBpZiAoIW1hdGNoKSByZXR1cm47XG4gIHZhciBwcmUgPSBtYXRjaFsxXVxuICAgICwgb3BlbiA9IG1hdGNoWzJdXG4gICAgLCByZW1haW5kZXIgPSBtYXRjaFszXVxuICAgICwgb3BlbkxlbiA9IG9wZW4ubGVuZ3RoXG4gICAgLCBib3VuZCA9IG9wZW5MZW4gPT09IDFcbiAgICAsIGVuZCA9IG1hdGNoQnJhY2VzKHJlbWFpbmRlciwgb3BlbkxlbiwgMCwgJ3snLCAnfScpXG4gICAgLCBlbmRJbm5lciA9IGVuZCAtIG9wZW5MZW5cbiAgICAsIGlubmVyID0gcmVtYWluZGVyLnNsaWNlKDAsIGVuZElubmVyKVxuICAgICwgcG9zdCA9IHJlbWFpbmRlci5zbGljZShlbmQpXG4gICAgLCBhbGlhcywgaGFzaCwgdHlwZSwgbmFtZSwgZXNjYXBlZDtcblxuICBpZiAoL1tcIntbXS8udGVzdChpbm5lcikpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSBkaWRuJ3QgYWNjaWRlbnRhbGx5IG1hdGNoIGEgSlNPTiBsaXRlcmFsXG4gICAgdHJ5IHtcbiAgICAgIEpTT04ucGFyc2Uob3BlbiArIGlubmVyICsgY2xvc2VNYXBbb3Blbkxlbl0pO1xuICAgICAgcmV0dXJuO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cblxuICBtYXRjaCA9IGFsaWFzQ29udGVudC5leGVjKGlubmVyKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgaW5uZXIgPSBtYXRjaFsxXTtcbiAgICBhbGlhcyA9IG1hdGNoWzJdO1xuICB9XG5cbiAgbWF0Y2ggPSBibG9ja0NvbnRlbnQuZXhlYyhpbm5lcilcbiAgaWYgKCFtYXRjaCkgcmV0dXJuO1xuICBoYXNoID0gbWF0Y2hbMV07XG4gIHR5cGUgPSBtYXRjaFsyXTtcbiAgbmFtZSA9IG1hdGNoWzNdO1xuXG4gIGVzY2FwZWQgPSB0cnVlO1xuICBpZiAodHlwZSA9PT0gJ3VuZXNjYXBlZCcpIHtcbiAgICBlc2NhcGVkID0gZmFsc2U7XG4gICAgdHlwZSA9ICcnO1xuICB9XG4gIGlmIChib3VuZCkgbmFtZSA9IG5hbWUucmVwbGFjZSgvXFxidGhpc1xcYi8sICcuJyk7XG4gIHJldHVybiB7XG4gICAgcHJlOiBwcmVcbiAgLCBwb3N0OiBwb3N0XG4gICwgYm91bmQ6IGJvdW5kXG4gICwgYWxpYXM6IGFsaWFzXG4gICwgaGFzaDogaGFzaFxuICAsIHR5cGU6IHR5cGVcbiAgLCBuYW1lOiBuYW1lXG4gICwgZXNjYXBlZDogZXNjYXBlZFxuICAsIHNvdXJjZTogdGV4dFxuICB9O1xufVxuXG5mdW5jdGlvbiBtYXRjaEJyYWNlcyh0ZXh0LCBudW0sIGksIG9wZW5DaGFyLCBjbG9zZUNoYXIpIHtcbiAgdmFyIGNsb3NlLCBoYXNDbG9zZSwgaGFzT3Blbiwgb3BlbjtcbiAgaSsrO1xuICB3aGlsZSAobnVtKSB7XG4gICAgY2xvc2UgPSB0ZXh0LmluZGV4T2YoY2xvc2VDaGFyLCBpKTtcbiAgICBvcGVuID0gdGV4dC5pbmRleE9mKG9wZW5DaGFyLCBpKTtcbiAgICBoYXNDbG9zZSA9IH5jbG9zZTtcbiAgICBoYXNPcGVuID0gfm9wZW47XG4gICAgaWYgKGhhc0Nsb3NlICYmICghaGFzT3BlbiB8fCAoY2xvc2UgPCBvcGVuKSkpIHtcbiAgICAgIGkgPSBjbG9zZSArIDE7XG4gICAgICBudW0tLTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoaGFzT3Blbikge1xuICAgICAgaSA9IG9wZW4gKyAxO1xuICAgICAgbnVtKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaTtcbn1cblxudmFyIGZuQ2FsbCA9IC9eKFteKF0rKVxccypcXChcXHMqKFtcXHNcXFNdKj8pXFxzKlxcKVxccyokL1xuICAsIGFyZ1NlcGFyYXRvciA9IC9cXHMqKFssKF0pXFxzKi9nXG4gICwgbm90U2VwYXJhdG9yID0gL1teLFxcc10vZ1xuICAsIG5vdFBhdGhBcmcgPSAvKD86XlsnXCJcXGRcXC1be10pfCg/Ol5udWxsJCl8KD86XnRydWUkKXwoPzpeZmFsc2UkKS87XG5cbmZ1bmN0aW9uIGZuQXJncyhpbm5lcikge1xuICB2YXIgYXJncyA9IFtdXG4gICAgLCBsYXN0SW5kZXggPSAwXG4gICAgLCBtYXRjaCwgZW5kLCBsYXN0O1xuICB3aGlsZSAobWF0Y2ggPSBhcmdTZXBhcmF0b3IuZXhlYyhpbm5lcikpIHtcbiAgICBpZiAobWF0Y2hbMV0gPT09ICcoJykge1xuICAgICAgZW5kID0gbWF0Y2hCcmFjZXMoaW5uZXIsIDEsIGFyZ1NlcGFyYXRvci5sYXN0SW5kZXgsICcoJywgJyknKTtcbiAgICAgIGFyZ3MucHVzaChpbm5lci5zbGljZShsYXN0SW5kZXgsIGVuZCkpO1xuICAgICAgbm90U2VwYXJhdG9yLmxhc3RJbmRleCA9IGVuZDtcbiAgICAgIGxhc3RJbmRleCA9IGFyZ1NlcGFyYXRvci5sYXN0SW5kZXggPVxuICAgICAgICBub3RTZXBhcmF0b3IudGVzdChpbm5lcikgPyBub3RTZXBhcmF0b3IubGFzdEluZGV4IC0gMSA6IGVuZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBhcmdzLnB1c2goaW5uZXIuc2xpY2UobGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgIGxhc3RJbmRleCA9IGFyZ1NlcGFyYXRvci5sYXN0SW5kZXg7XG4gIH1cbiAgbGFzdCA9IGlubmVyLnNsaWNlKGxhc3RJbmRleCk7XG4gIGlmIChsYXN0KSBhcmdzLnB1c2gobGFzdCk7XG4gIHJldHVybiBhcmdzO1xufVxuXG5mdW5jdGlvbiBmbkNhbGxFcnJvcihuYW1lKSB7XG4gIHRocm93IG5ldyBFcnJvcignbWFsZm9ybWVkIHZpZXcgZnVuY3Rpb24gY2FsbDogJyArIG5hbWUpO1xufVxuXG5mdW5jdGlvbiBmbkFyZ1ZhbHVlKHZpZXcsIGN0eCwgbW9kZWwsIG5hbWUsIGFyZykge1xuICB2YXIgbGl0ZXJhbCA9IGxpdGVyYWxWYWx1ZShhcmcpO1xuICBpZiAobGl0ZXJhbCAhPT0gdm9pZCAwKSByZXR1cm4gbGl0ZXJhbDtcblxuICB2YXIgcGF0aE1hcCA9IG1vZGVsLl9fcGF0aE1hcDtcbiAgaWYgKCFwYXRoTWFwKSByZXR1cm4gZGF0YVZhbHVlKHZpZXcsIGN0eCwgbW9kZWwsIGFyZyk7XG5cbiAgdmFyIGFyZ0lkcyA9IGN0eC5oYXNPd25Qcm9wZXJ0eSgnJGZuQXJnSWRzJykgP1xuICAgIGN0eC4kZm5BcmdJZHMgOiAoY3R4LiRmbkFyZ0lkcyA9IHt9KTtcbiAgdmFyIHBhdGhJZCA9IGFyZ0lkc1thcmddO1xuICB2YXIgcGF0aDtcbiAgaWYgKHBhdGhJZCkge1xuICAgIHBhdGggPSBwYXRoTWFwLnBhdGhzW3BhdGhJZF07XG4gIH0gZWxzZSB7XG4gICAgcGF0aCA9IGN0eFBhdGgodmlldywgY3R4LCBhcmcpO1xuICAgIGFyZ0lkc1thcmddID0gcGF0aE1hcC5pZChwYXRoKTtcbiAgfVxuICByZXR1cm4gZGF0YVZhbHVlKHZpZXcsIGN0eCwgbW9kZWwsIHBhdGgpO1xufVxuXG5mdW5jdGlvbiBmblZhbHVlKHZpZXcsIGN0eCwgbW9kZWwsIG5hbWUpIHtcbiAgdmFyIG1hdGNoID0gZm5DYWxsLmV4ZWMobmFtZSkgfHwgZm5DYWxsRXJyb3IobmFtZSlcbiAgICAsIGZuTmFtZSA9IG1hdGNoWzFdXG4gICAgLCBhcmdzID0gZm5BcmdzKG1hdGNoWzJdKVxuICAgICwgZm4sIGZuTmFtZSwgaTtcbiAgZm9yIChpID0gYXJncy5sZW5ndGg7IGktLTspIHtcbiAgICBhcmdzW2ldID0gZm5BcmdWYWx1ZSh2aWV3LCBjdHgsIG1vZGVsLCBuYW1lLCBhcmdzW2ldKTtcbiAgfVxuICBpZiAoIShmbiA9IHZpZXcuZ2V0Rm5zW2ZuTmFtZV0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd2aWV3IGZ1bmN0aW9uIFwiJyArIGZuTmFtZSArICdcIiBub3QgZm91bmQgZm9yIGNhbGw6ICcgKyBuYW1lKTtcbiAgfVxuICByZXR1cm4gZm4uYXBwbHkoe3ZpZXc6IHZpZXcsIGN0eDogY3R4LCBtb2RlbDogbW9kZWx9LCBhcmdzKTtcbn1cblxuZnVuY3Rpb24gcGF0aEZuQXJncyhuYW1lLCBwYXRocykge1xuICB2YXIgbWF0Y2ggPSBmbkNhbGwuZXhlYyhuYW1lKSB8fCBmbkNhbGxFcnJvcihuYW1lKVxuICAgICwgYXJncyA9IGZuQXJncyhtYXRjaFsyXSlcbiAgICAsIGksIGFyZztcbiAgaWYgKHBhdGhzID09IG51bGwpIHBhdGhzID0gW107XG4gIGZvciAoaSA9IGFyZ3MubGVuZ3RoOyBpLS07KSB7XG4gICAgYXJnID0gYXJnc1tpXTtcbiAgICBpZiAobm90UGF0aEFyZy50ZXN0KGFyZykpIGNvbnRpbnVlO1xuICAgIGlmICh+YXJnLmluZGV4T2YoJygnKSkge1xuICAgICAgcGF0aEZuQXJncyhhcmcsIHBhdGhzKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBwYXRocy5wdXNoKGFyZyk7XG4gIH1cbiAgcmV0dXJuIHBhdGhzO1xufVxuXG5mdW5jdGlvbiByZWxhdGl2ZVBhdGgodmlldywgY3R4LCBpLCByZW1haW5kZXIpIHtcbiAgdmFyIG5hbWUgPSBjdHguJHBhdGhzW2kgLSAxXSArIHJlbWFpbmRlcjtcblxuICAvLyBwYXRoTWFwIGlzIG9ubHkgY3JlYXRlZCBpbiB0aGUgYnJvd3NlclxuICB2YXIgcGF0aE1hcCA9IHZpZXcubW9kZWwuX19wYXRoTWFwO1xuICBpZiAoIXBhdGhNYXApIHJldHVybiBuYW1lO1xuICB2YXIgcGF0aElkID0gY3R4LiRwYXRoSWRzW25hbWVdIHx8IChjdHguJHBhdGhJZHNbbmFtZV0gPSBwYXRoTWFwLmlkKG5hbWUpKTtcbiAgcmV0dXJuIHBhdGhNYXAucGF0aHNbcGF0aElkXTtcbn1cblxuZnVuY3Rpb24gbWFjcm9OYW1lKHZpZXcsIGN0eCwgbmFtZSkge1xuICBpZiAobmFtZS5jaGFyQXQoMCkgIT09ICdAJykgcmV0dXJuO1xuXG4gIHZhciBzZWdtZW50cyA9IG5hbWUuc2xpY2UoMSkuc3BsaXQoJy4nKTtcbiAgdmFyIGJhc2UgPSBzZWdtZW50cy5zaGlmdCgpLnRvTG93ZXJDYXNlKCk7XG4gIHZhciB2YWx1ZSA9IGxvb2t1cChiYXNlLCBjdHguJG1hY3JvQ3R4KTtcbiAgdmFyIG1hdGNoTmFtZSA9IHZhbHVlICYmIHZhbHVlLiRtYXRjaE5hbWU7XG4gIHZhciByZW1haW5kZXIgPSBzZWdtZW50cy5qb2luKCcuJyk7XG5cbiAgaWYgKG1hdGNoTmFtZSkge1xuICAgIGlmICghcmVtYWluZGVyKSByZXR1cm4gdmFsdWU7XG4gICAgcmV0dXJuIHskbWF0Y2hOYW1lOiBtYXRjaE5hbWUgKyAnLicgKyByZW1haW5kZXJ9O1xuICB9XG4gIHJldHVybiAocmVtYWluZGVyKSA/IGJhc2UgKyAnLicgKyByZW1haW5kZXIgOiBiYXNlO1xufVxuXG5mdW5jdGlvbiBjdHhQYXRoKHZpZXcsIGN0eCwgbmFtZSkge1xuICB2YXIgaXNXaWxkY2FyZCA9IG5hbWUuY2hhckF0KG5hbWUubGVuZ3RoIC0gMSkgPT09ICcqJztcbiAgaWYgKGlzV2lsZGNhcmQpIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC0xKTtcblxuICB2YXIgbWFjcm9QYXRoID0gbWFjcm9OYW1lKHZpZXcsIGN0eCwgbmFtZSk7XG4gIGlmIChtYWNyb1BhdGggJiYgbWFjcm9QYXRoLiRtYXRjaE5hbWUpIG5hbWUgPSBtYWNyb1BhdGguJG1hdGNoTmFtZTtcblxuICB2YXIgZmlyc3RDaGFyID0gbmFtZS5jaGFyQXQoMClcbiAgICAsIGksIGFsaWFzTmFtZSwgcmVtYWluZGVyXG5cbiAgLy8gUmVzb2x2ZSBwYXRoIGFsaWFzZXNcbiAgaWYgKGZpcnN0Q2hhciA9PT0gJzonKSB7XG4gICAgaWYgKH4oaSA9IG5hbWUuc2VhcmNoKC9bLltdLykpKSB7XG4gICAgICBhbGlhc05hbWUgPSBuYW1lLnNsaWNlKDEsIGkpO1xuICAgICAgcmVtYWluZGVyID0gbmFtZS5zbGljZShpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWxpYXNOYW1lID0gbmFtZS5zbGljZSgxKTtcbiAgICAgIHJlbWFpbmRlciA9ICcnO1xuICAgIH1cbiAgICBhbGlhc05hbWUgPSBhbGlhc05hbWU7XG4gICAgaSA9IGN0eC4kcGF0aHMubGVuZ3RoIC0gY3R4LiRhbGlhc2VzW2FsaWFzTmFtZV07XG4gICAgaWYgKGkgIT09IGkpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgYWxpYXM6ICcgKyBuYW1lKTtcblxuICAgIG5hbWUgPSByZWxhdGl2ZVBhdGgodmlldywgY3R4LCBpLCByZW1haW5kZXIpO1xuXG4gIC8vIFJlc29sdmUgcmVsYXRpdmUgcGF0aHNcbiAgfSBlbHNlIGlmIChmaXJzdENoYXIgPT09ICcuJykge1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChuYW1lLmNoYXJBdChpKSA9PT0gJy4nKSB7XG4gICAgICBpKys7XG4gICAgfVxuICAgIHJlbWFpbmRlciA9IGkgPT09IG5hbWUubGVuZ3RoID8gJycgOiBuYW1lLnNsaWNlKGkgLSAxKTtcblxuICAgIG5hbWUgPSByZWxhdGl2ZVBhdGgodmlldywgY3R4LCBpLCByZW1haW5kZXIpO1xuICB9XG5cbiAgbmFtZSA9IHJlcGxhY2VTcXVhcmVCcmFja2V0cyh2aWV3LCBjdHgsIG5hbWUpO1xuICBpZiAoaXNXaWxkY2FyZCkgbmFtZSArPSAnKic7XG4gIHJldHVybiBuYW1lO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlU3F1YXJlQnJhY2tldHModmlldywgY3R4LCBuYW1lKSB7XG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICB2YXIgaSA9IG5hbWUuaW5kZXhPZignWycpO1xuICBpZiAoaSA9PT0gLTEpIHJldHVybiBuYW1lO1xuXG4gIHZhciBlbmQgPSBtYXRjaEJyYWNlcyhuYW1lLCAxLCBpLCAnWycsICddJyk7XG4gIC8vIFRoaXMgc2hvdWxkbid0IG5vcm1hbGx5IGhhcHBlbiwgYnV0IGp1c3QgaW4gY2FzZSByZXR1cm5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybjtcbiAgdmFyIGJlZm9yZSA9IG5hbWUuc2xpY2UoMCwgaSk7XG4gIHZhciBpbnNpZGUgPSBuYW1lLnNsaWNlKGkgKyAxLCBlbmQgLSAxKTtcbiAgdmFyIGFmdGVyID0gbmFtZS5zbGljZShlbmQpO1xuXG4gIG5hbWUgPSByZXBsYWNlU3F1YXJlQnJhY2tldHModmlldywgY3R4LCBpbnNpZGUpO1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZSh2aWV3LCBjdHgsIHZpZXcubW9kZWwsIG5hbWUpO1xuICBuYW1lID0gKHZhbHVlID09IG51bGwpID8gJyRudWxsJyA6IHZhbHVlO1xuICB2YXIgb3V0ID0gKGJlZm9yZSkgPyBiZWZvcmUgKyAnLicgKyBuYW1lIDogbmFtZTtcblxuICB3aGlsZSAoYWZ0ZXIpIHtcbiAgICBpID0gYWZ0ZXIuaW5kZXhPZignWycpO1xuICAgIGlmIChpID09PSAtMSkgcmV0dXJuIG91dCArIGFmdGVyO1xuXG4gICAgbmFtZSA9IGFmdGVyO1xuICAgIGVuZCA9IG1hdGNoQnJhY2VzKG5hbWUsIDEsIGksICdbJywgJ10nKTtcbiAgICBpZiAoZW5kID09PSAtMSkgcmV0dXJuO1xuICAgIGJlZm9yZSA9IG5hbWUuc2xpY2UoMCwgaSk7XG4gICAgaW5zaWRlID0gbmFtZS5zbGljZShpICsgMSwgZW5kIC0gMSk7XG4gICAgYWZ0ZXIgPSBuYW1lLnNsaWNlKGVuZCk7XG5cbiAgICBpZiAoYmVmb3JlKSBvdXQgKz0gYmVmb3JlO1xuXG4gICAgbmFtZSA9IHJlcGxhY2VTcXVhcmVCcmFja2V0cyh2aWV3LCBjdHgsIGluc2lkZSk7XG4gICAgdmFsdWUgPSBnZXRWYWx1ZSh2aWV3LCBjdHgsIHZpZXcubW9kZWwsIG5hbWUpO1xuICAgIHZhbHVlID0gKHZhbHVlID09IG51bGwpID8gJyRudWxsJyA6IHZhbHVlO1xuICAgIG91dCArPSAnLicgKyB2YWx1ZTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBzcXVhcmVCcmFja2V0c0FyZ3MobmFtZSwgcGF0aHMpIHtcbiAgcGF0aHMgfHwgKHBhdGhzID0gW10pO1xuXG4gIHdoaWxlIChuYW1lKSB7XG4gICAgaSA9IG5hbWUuaW5kZXhPZignWycpO1xuICAgIGlmIChpID09PSAtMSkgcmV0dXJuIHBhdGhzO1xuXG4gICAgZW5kID0gbWF0Y2hCcmFjZXMobmFtZSwgMSwgaSwgJ1snLCAnXScpO1xuICAgIGlmIChlbmQgPT09IC0xKSByZXR1cm4gcGF0aHM7XG4gICAgaW5zaWRlID0gbmFtZS5zbGljZShpICsgMSwgZW5kIC0gMSk7XG4gICAgbmFtZSA9IG5hbWUuc2xpY2UoZW5kKTtcblxuICAgIGlmIChpbnNpZGUuaW5kZXhPZignWycpID09PSAtMSkge1xuICAgICAgcGF0aHMucHVzaChpbnNpZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzcXVhcmVCcmFja2V0c0FyZ3MoaW5zaWRlLCBwYXRocyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXRocztcbn1cblxuZnVuY3Rpb24gZXNjYXBlVmFsdWUodmFsdWUsIGVzY2FwZSkge1xuICByZXR1cm4gZXNjYXBlID8gZXNjYXBlKHZhbHVlKSA6IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBsaXRlcmFsVmFsdWUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSAnbnVsbCcpIHJldHVybiBudWxsO1xuICBpZiAodmFsdWUgPT09ICd0cnVlJykgcmV0dXJuIHRydWU7XG4gIGlmICh2YWx1ZSA9PT0gJ2ZhbHNlJykgcmV0dXJuIGZhbHNlO1xuICB2YXIgZmlyc3RDaGFyID0gdmFsdWUuY2hhckF0KDApXG4gICAgLCBtYXRjaDtcbiAgaWYgKGZpcnN0Q2hhciA9PT0gXCInXCIpIHtcbiAgICBtYXRjaCA9IC9eJyguKiknJC8uZXhlYyh2YWx1ZSkgfHwgZm5DYWxsRXJyb3IodmFsdWUpO1xuICAgIHJldHVybiBtYXRjaFsxXTtcbiAgfVxuICBpZiAoZmlyc3RDaGFyID09PSAnXCInKSB7XG4gICAgbWF0Y2ggPSAvXlwiKC4qKVwiJC8uZXhlYyh2YWx1ZSkgfHwgZm5DYWxsRXJyb3IodmFsdWUpO1xuICAgIHJldHVybiBtYXRjaFsxXTtcbiAgfVxuICBpZiAoL15bXFxkXFwtXS8udGVzdChmaXJzdENoYXIpICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICByZXR1cm4gK3ZhbHVlO1xuICB9XG4gIGlmIChmaXJzdENoYXIgPT09ICdbJyB8fCBmaXJzdENoYXIgPT09ICd7Jykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSh2aWV3LCBjdHgsIG1vZGVsLCBuYW1lLCBlc2NhcGUsIGZvcmNlRXNjYXBlKSB7XG4gIHZhciBsaXRlcmFsID0gbGl0ZXJhbFZhbHVlKG5hbWUpXG4gIGlmIChsaXRlcmFsID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZGF0YVZhbHVlKHZpZXcsIGN0eCwgbW9kZWwsIG5hbWUsIGVzY2FwZSwgZm9yY2VFc2NhcGUpO1xuICB9XG4gIHJldHVybiBsaXRlcmFsO1xufVxuXG5mdW5jdGlvbiBkYXRhVmFsdWUodmlldywgY3R4LCBtb2RlbCwgbmFtZSwgZXNjYXBlLCBmb3JjZUVzY2FwZSkge1xuICB2YXIgbWFjcm9QYXRoLCBwYXRoLCB2YWx1ZTtcbiAgaWYgKCFuYW1lKSByZXR1cm47XG4gIGlmICh+bmFtZS5pbmRleE9mKCcoJykpIHtcbiAgICB2YWx1ZSA9IGZuVmFsdWUodmlldywgY3R4LCBtb2RlbCwgbmFtZSk7XG4gICAgcmV0dXJuIGVzY2FwZVZhbHVlKHZhbHVlLCBlc2NhcGUpO1xuICB9XG4gIHBhdGggPSBjdHhQYXRoKHZpZXcsIGN0eCwgbmFtZSk7XG4gIG1hY3JvUGF0aCA9IG1hY3JvTmFtZSh2aWV3LCBjdHgsIHBhdGgpO1xuICBpZiAobWFjcm9QYXRoKSB7XG4gICAgaWYgKG1hY3JvUGF0aC4kbWF0Y2hOYW1lKSB7XG4gICAgICBwYXRoID0gbWFjcm9QYXRoLiRtYXRjaE5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gbG9va3VwKG1hY3JvUGF0aCwgY3R4LiRtYWNyb0N0eCk7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmICh2YWx1ZS51bmVzY2FwZWQgJiYgIWZvcmNlRXNjYXBlKSByZXR1cm4gdmFsdWUoY3R4LCBtb2RlbCk7XG4gICAgICAgIHZhbHVlID0gdmFsdWUoY3R4LCBtb2RlbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXNjYXBlVmFsdWUodmFsdWUsIGVzY2FwZSk7XG4gICAgfVxuICB9XG4gIHZhbHVlID0gbG9va3VwKHBhdGgsIGN0eCk7XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB2YWx1ZSA9IG1vZGVsLmdldChwYXRoKVxuICByZXR1cm4gZXNjYXBlVmFsdWUodmFsdWUsIGVzY2FwZSk7XG59XG5cbmZ1bmN0aW9uIHNldEJvdW5kRm4odmlldywgY3R4LCBtb2RlbCwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIG1hdGNoID0gZm5DYWxsLmV4ZWMobmFtZSkgfHwgZm5DYWxsRXJyb3IobmFtZSlcbiAgICAsIGZuTmFtZSA9IG1hdGNoWzFdXG4gICAgLCBhcmdzID0gZm5BcmdzKG1hdGNoWzJdKVxuICAgICwgZ2V0ID0gdmlldy5nZXRGbnNbZm5OYW1lXVxuICAgICwgc2V0ID0gdmlldy5zZXRGbnNbZm5OYW1lXVxuICAgICwgbnVtSW5wdXRzID0gc2V0ICYmIHNldC5sZW5ndGggLSAxXG4gICAgLCBhcmcsIGksIGlucHV0cywgb3V0LCBrZXksIHBhdGgsIGxlbjtcblxuICBpZiAoIShnZXQgJiYgc2V0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndmlldyBmdW5jdGlvbiBcIicgKyBmbk5hbWUgKyAnXCIgc2V0dGVyIG5vdCBmb3VuZCBmb3IgYmluZGluZyB0bzogJyArIG5hbWUpO1xuICB9XG5cbiAgaWYgKG51bUlucHV0cykge1xuICAgIGlucHV0cyA9IFt2YWx1ZV07XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBudW1JbnB1dHMpIHtcbiAgICAgIGlucHV0cy5wdXNoKGZuQXJnVmFsdWUodmlldywgY3R4LCBtb2RlbCwgbmFtZSwgYXJnc1tpKytdKSk7XG4gICAgfVxuICAgIG91dCA9IHNldC5hcHBseShudWxsLCBpbnB1dHMpO1xuICB9IGVsc2Uge1xuICAgIG91dCA9IHNldCh2YWx1ZSk7XG4gIH1cbiAgaWYgKCFvdXQpIHJldHVybjtcblxuICBmb3IgKGtleSBpbiBvdXQpIHtcbiAgICB2YWx1ZSA9IG91dFtrZXldO1xuICAgIGFyZyA9IGFyZ3Nba2V5XTtcbiAgICBpZiAofmFyZy5pbmRleE9mKCcoJykpIHtcbiAgICAgIHNldEJvdW5kRm4odmlldywgY3R4LCBtb2RlbCwgYXJnLCB2YWx1ZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDAgfHwgbm90UGF0aEFyZy50ZXN0KGFyZykpIGNvbnRpbnVlO1xuICAgIHBhdGggPSBjdHhQYXRoKHZpZXcsIGN0eCwgYXJnKTtcbiAgICBpZiAobW9kZWwuZ2V0KHBhdGgpID09PSB2YWx1ZSkgY29udGludWU7XG4gICAgbW9kZWwuc2V0KHBhdGgsIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsb29rdXAocGF0aCwgb2JqKSB7XG4gIGlmICghcGF0aCB8fCAhb2JqKSByZXR1cm47XG4gIGlmIChwYXRoLmluZGV4T2YoJy4nKSA9PT0gLTEpIHJldHVybiBvYmpbcGF0aF07XG5cbiAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICghb2JqKSByZXR1cm4gb2JqO1xuXG4gICAgdmFyIHByb3AgPSBwYXJ0c1tpXTtcbiAgICBvYmogPSBvYmpbcHJvcF07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbiIsInZhciBlbnRpdHlDb2RlID0gcmVxdWlyZSgnLi9lbnRpdHlDb2RlJylcbiAgLCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGFyc2U6IHBhcnNlXG4sIGVzY2FwZUh0bWw6IGVzY2FwZUh0bWxcbiwgZXNjYXBlQXR0cmlidXRlOiBlc2NhcGVBdHRyaWJ1dGVcbiwgdW5lc2NhcGVFbnRpdGllczogdW5lc2NhcGVFbnRpdGllc1xuLCBpc1ZvaWQ6IGlzVm9pZFxuLCBjb25kaXRpb25hbENvbW1lbnQ6IGNvbmRpdGlvbmFsQ29tbWVudFxuLCB0cmltTGVhZGluZzogdHJpbUxlYWRpbmdcbiwgdHJpbVRleHQ6IHRyaW1UZXh0XG4sIHRyaW1UYWc6IHRyaW1UYWdcbiwgbWluaWZ5OiBtaW5pZnlcbn1cblxuZnVuY3Rpb24gZXNjYXBlSHRtbCh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuICcnXG5cbiAgcmV0dXJuIHZhbHVlXG4gICAgLnRvU3RyaW5nKClcbiAgICAucmVwbGFjZSgvJig/IVxccyl8PC9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgcmV0dXJuIG1hdGNoID09PSAnJicgPyAnJmFtcDsnIDogJyZsdDsnXG4gICAgfSlcbn1cblxuZnVuY3Rpb24gZXNjYXBlQXR0cmlidXRlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlID09PSAnJykgcmV0dXJuICdcIlwiJ1xuXG4gIHZhbHVlID0gdmFsdWVcbiAgICAudG9TdHJpbmcoKVxuICAgIC5yZXBsYWNlKC8mKD8hXFxzKXxcIi9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgcmV0dXJuIG1hdGNoID09PSAnJicgPyAnJmFtcDsnIDogJyZxdW90OydcbiAgICB9KVxuICByZXR1cm4gL1sgPTw+J10vLnRlc3QodmFsdWUpID8gJ1wiJyArIHZhbHVlICsgJ1wiJyA6IHZhbHVlXG59XG5cbi8vIEJhc2VkIG9uOlxuLy8gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2pzbGlicy93aWtpL0phdmFzY3JpcHRUaXBzI0VzY2FwZV9hbmRfdW5lc2NhcGVfSFRNTF9lbnRpdGllc1xuZnVuY3Rpb24gdW5lc2NhcGVFbnRpdGllcyhodG1sKSB7XG4gIHJldHVybiBodG1sLnJlcGxhY2UoLyYoW147XSspOy9nLCBmdW5jdGlvbihtYXRjaCwgZW50aXR5KSB7XG4gICAgdmFyIGNoYXJDb2RlID0gZW50aXR5LmNoYXJBdCgwKSA9PT0gJyMnXG4gICAgICAgICAgPyBlbnRpdHkuY2hhckF0KDEpID09PSAneCdcbiAgICAgICAgICAgID8gZW50aXR5LnNsaWNlKDIsIDE3KVxuICAgICAgICAgICAgOiBlbnRpdHkuc2xpY2UoMSlcbiAgICAgICAgICA6IGVudGl0eUNvZGVbZW50aXR5XVxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKVxuICB9KVxufVxuXG52YXIgdm9pZEVsZW1lbnQgPSB7XG4gIGFyZWE6IDFcbiwgYmFzZTogMVxuLCBicjogMVxuLCBjb2w6IDFcbiwgY29tbWFuZDogMVxuLCBlbWJlZDogMVxuLCBocjogMVxuLCBpbWc6IDFcbiwgaW5wdXQ6IDFcbiwga2V5Z2VuOiAxXG4sIGxpbms6IDFcbiwgbWV0YTogMVxuLCBwYXJhbTogMVxuLCBzb3VyY2U6IDFcbiwgdHJhY2s6IDFcbiwgd2JyOiAxXG59XG5mdW5jdGlvbiBpc1ZvaWQobmFtZSkge1xuICByZXR1cm4gbmFtZSBpbiB2b2lkRWxlbWVudFxufVxuXG4vLyBBc3N1bWUgYW55IEhUTUwgY29tbWVudCB0aGF0IHN0YXJ0cyB3aXRoIGA8IS0tW2Agb3IgZW5kcyB3aXRoIGBdLS0+YFxuLy8gaXMgYSBjb25kaXRpb25hbCBjb21tZW50LiBUaGlzIGNhbiBhbHNvIGJlIHVzZWQgdG8ga2VlcCBjb21tZW50cyBpblxuLy8gbWluaWZpZWQgSFRNTCwgc3VjaCBhcyBgPCEtLVsgQ29weXJpZ2h0IEpvaG4gRG9lLCBNSVQgTGljZW5zZWQgXS0tPmBcbmZ1bmN0aW9uIGNvbmRpdGlvbmFsQ29tbWVudCh0YWcpIHtcbiAgcmV0dXJuIC8oPzpePCEtLVxcWyl8KD86XFxdLS0+JCkvLnRlc3QodGFnKVxufVxuXG4vLyBSZW1vdmUgbGVhZGluZyB3aGl0ZXNwYWNlIGFuZCBuZXdsaW5lcyBmcm9tIGEgc3RyaW5nLiBXaGl0ZXNwYWNlIGF0IHRoZSBlbmRcbi8vIG9mIGEgbGluZSB3aWxsIGJlIG1haW50YWluZWRcbmZ1bmN0aW9uIHRyaW1MZWFkaW5nKHRleHQpIHtcbiAgcmV0dXJuIHRleHQgPyB0ZXh0LnJlcGxhY2UoL1xccj9cXG5cXHMqL2csICcnKSA6ICcnXG59XG5cbi8vIFJlbW92ZSBsZWFkaW5nICYgdHJhaWxpbmcgd2hpdGVzcGFjZSBhbmQgbmV3bGluZXMgZnJvbSBhIHN0cmluZ1xuZnVuY3Rpb24gdHJpbVRleHQodGV4dCkge1xuICByZXR1cm4gdGV4dCA/IHRleHQucmVwbGFjZSgvXFxzKlxccj9cXG5cXHMqL2csICcnKSA6ICcnXG59XG5cbi8vIFdpdGhpbiBhIHRhZywgcmVtb3ZlIGxlYWRpbmcgJiB0cmFpbGluZyB3aGl0ZXNwYWNlLiBLZWVwIGEgbGluZWJyZWFrLCBzaW5jZVxuLy8gdGhpcyBjb3VsZCBiZSB0aGUgc2VwYXJhdG9yIGJldHdlZW4gYXR0cmlidXRlc1xuZnVuY3Rpb24gdHJpbVRhZyh0YWcpIHtcbiAgcmV0dXJuIHRhZy5yZXBsYWNlKC8oPzpcXHMqXFxyP1xcblxccyopKy9nLCAnXFxuJylcbn1cblxuLy8gUmVtb3ZlIGxpbmVicmVha3MsIGxlYWRpbmcgJiB0cmFpbGluZyBzcGFjZSwgYW5kIGNvbW1lbnRzLiBNYWludGFpbiBhXG4vLyBsaW5lYnJlYWsgYmV0d2VlbiBIVE1MIHRhZyBhdHRyaWJ1dGVzIGFuZCBtYWludGFpbiBjb25kaXRpb25hbCBjb21tZW50cy5cbmZ1bmN0aW9uIG1pbmlmeShodG1sKSB7XG4gIHZhciBtaW5pZmllZCA9ICcnXG4gICAgLCBtaW5pZnlDb250ZW50ID0gdHJ1ZVxuXG4gIHBhcnNlKGh0bWwsIHtcbiAgICBzdGFydDogZnVuY3Rpb24odGFnLCB0YWdOYW1lLCBhdHRycykge1xuICAgICAgbWluaWZ5Q29udGVudCA9ICEoJ3gtbm8tbWluaWZ5JyBpbiBhdHRycylcbiAgICAgIG1pbmlmaWVkICs9IHRyaW1UYWcodGFnKVxuICAgIH1cbiAgLCBlbmQ6IGZ1bmN0aW9uKHRhZykge1xuICAgICAgbWluaWZpZWQgKz0gdHJpbVRhZyh0YWcpXG4gICAgfVxuICAsIHRleHQ6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgIG1pbmlmaWVkICs9IG1pbmlmeUNvbnRlbnQgPyB0cmltVGV4dCh0ZXh0KSA6IHRleHRcbiAgICB9XG4gICwgY29tbWVudDogZnVuY3Rpb24odGFnKSB7XG4gICAgICBpZiAoY29uZGl0aW9uYWxDb21tZW50KHRhZykpIG1pbmlmaWVkICs9IHRhZ1xuICAgIH1cbiAgLCBvdGhlcjogZnVuY3Rpb24odGFnKSB7XG4gICAgICBtaW5pZmllZCArPSB0YWdcbiAgICB9XG4gIH0pXG4gIHJldHVybiBtaW5pZmllZFxufVxuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBFeHBvc2UgYFJvdXRlYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdXRlO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYFJvdXRlYCB3aXRoIHRoZSBnaXZlbiBIVFRQIGBtZXRob2RgLCBgcGF0aGAsXG4gKiBhbmQgYW4gYXJyYXkgb2YgYGNhbGxiYWNrc2AgYW5kIGBvcHRpb25zYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAgLSBgc2Vuc2l0aXZlYCAgICBlbmFibGUgY2FzZS1zZW5zaXRpdmUgcm91dGVzXG4gKiAgIC0gYHN0cmljdGAgICAgICAgZW5hYmxlIHN0cmljdCBtYXRjaGluZyBmb3IgdHJhaWxpbmcgc2xhc2hlc1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge0FycmF5fSBjYWxsYmFja3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gUm91dGUobWV0aG9kLCBwYXRoLCBjYWxsYmFja3MsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMucGF0aCA9IHBhdGg7XG4gIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgdGhpcy5yZWdleHAgPSB1dGlscy5wYXRoUmVnZXhwKHBhdGhcbiAgICAsIHRoaXMua2V5cyA9IFtdXG4gICAgLCBvcHRpb25zLnNlbnNpdGl2ZVxuICAgICwgb3B0aW9ucy5zdHJpY3QpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoaXMgcm91dGUgbWF0Y2hlcyBgcGF0aGAsIGlmIHNvXG4gKiBwb3B1bGF0ZSBgLnBhcmFtc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Sb3V0ZS5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbihwYXRoKXtcbiAgdmFyIGtleXMgPSB0aGlzLmtleXNcbiAgICAsIHBhcmFtcyA9IHRoaXMucGFyYW1zID0gW11cbiAgICAsIG0gPSB0aGlzLnJlZ2V4cC5leGVjKHBhdGgpO1xuXG4gIGlmICghbSkgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSAxLCBsZW4gPSBtLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaSAtIDFdO1xuXG4gICAgdmFyIHZhbCA9ICdzdHJpbmcnID09IHR5cGVvZiBtW2ldXG4gICAgICA/IGRlY29kZVVSSUNvbXBvbmVudChtW2ldKVxuICAgICAgOiBtW2ldO1xuXG4gICAgaWYgKGtleSkge1xuICAgICAgcGFyYW1zW2tleS5uYW1lXSA9IHZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyYW1zLnB1c2godmFsKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgcXVvdDogMHgwMDIyXG4sIGFtcDogMHgwMDI2XG4sIGFwb3M6IDB4MDAyN1xuLCBscGFyOiAweDAwMjhcbiwgcnBhcjogMHgwMDI5XG4sIGx0OiAweDAwM0NcbiwgZ3Q6IDB4MDAzRVxuLCBuYnNwOiAweDAwQTBcbiwgaWV4Y2w6IDB4MDBBMVxuLCBjZW50OiAweDAwQTJcbiwgcG91bmQ6IDB4MDBBM1xuLCBjdXJyZW46IDB4MDBBNFxuLCB5ZW46IDB4MDBBNVxuLCBicnZiYXI6IDB4MDBBNlxuLCBzZWN0OiAweDAwQTdcbiwgdW1sOiAweDAwQThcbiwgY29weTogMHgwMEE5XG4sIG9yZGY6IDB4MDBBQVxuLCBsYXF1bzogMHgwMEFCXG4sIG5vdDogMHgwMEFDXG4sIHNoeTogMHgwMEFEXG4sIHJlZzogMHgwMEFFXG4sIG1hY3I6IDB4MDBBRlxuLCBkZWc6IDB4MDBCMFxuLCBwbHVzbW46IDB4MDBCMVxuLCBzdXAyOiAweDAwQjJcbiwgc3VwMzogMHgwMEIzXG4sIGFjdXRlOiAweDAwQjRcbiwgbWljcm86IDB4MDBCNVxuLCBwYXJhOiAweDAwQjZcbiwgbWlkZG90OiAweDAwQjdcbiwgY2VkaWw6IDB4MDBCOFxuLCBzdXAxOiAweDAwQjlcbiwgb3JkbTogMHgwMEJBXG4sIHJhcXVvOiAweDAwQkJcbiwgZnJhYzE0OiAweDAwQkNcbiwgZnJhYzEyOiAweDAwQkRcbiwgZnJhYzM0OiAweDAwQkVcbiwgaXF1ZXN0OiAweDAwQkZcbiwgQWdyYXZlOiAweDAwQzBcbiwgQWFjdXRlOiAweDAwQzFcbiwgQWNpcmM6IDB4MDBDMlxuLCBBdGlsZGU6IDB4MDBDM1xuLCBBdW1sOiAweDAwQzRcbiwgQXJpbmc6IDB4MDBDNVxuLCBBRWxpZzogMHgwMEM2XG4sIENjZWRpbDogMHgwMEM3XG4sIEVncmF2ZTogMHgwMEM4XG4sIEVhY3V0ZTogMHgwMEM5XG4sIEVjaXJjOiAweDAwQ0FcbiwgRXVtbDogMHgwMENCXG4sIElncmF2ZTogMHgwMENDXG4sIElhY3V0ZTogMHgwMENEXG4sIEljaXJjOiAweDAwQ0VcbiwgSXVtbDogMHgwMENGXG4sIEVUSDogMHgwMEQwXG4sIE50aWxkZTogMHgwMEQxXG4sIE9ncmF2ZTogMHgwMEQyXG4sIE9hY3V0ZTogMHgwMEQzXG4sIE9jaXJjOiAweDAwRDRcbiwgT3RpbGRlOiAweDAwRDVcbiwgT3VtbDogMHgwMEQ2XG4sIHRpbWVzOiAweDAwRDdcbiwgT3NsYXNoOiAweDAwRDhcbiwgVWdyYXZlOiAweDAwRDlcbiwgVWFjdXRlOiAweDAwREFcbiwgVWNpcmM6IDB4MDBEQlxuLCBVdW1sOiAweDAwRENcbiwgWWFjdXRlOiAweDAwRERcbiwgVEhPUk46IDB4MDBERVxuLCBzemxpZzogMHgwMERGXG4sIGFncmF2ZTogMHgwMEUwXG4sIGFhY3V0ZTogMHgwMEUxXG4sIGFjaXJjOiAweDAwRTJcbiwgYXRpbGRlOiAweDAwRTNcbiwgYXVtbDogMHgwMEU0XG4sIGFyaW5nOiAweDAwRTVcbiwgYWVsaWc6IDB4MDBFNlxuLCBjY2VkaWw6IDB4MDBFN1xuLCBlZ3JhdmU6IDB4MDBFOFxuLCBlYWN1dGU6IDB4MDBFOVxuLCBlY2lyYzogMHgwMEVBXG4sIGV1bWw6IDB4MDBFQlxuLCBpZ3JhdmU6IDB4MDBFQ1xuLCBpYWN1dGU6IDB4MDBFRFxuLCBpY2lyYzogMHgwMEVFXG4sIGl1bWw6IDB4MDBFRlxuLCBldGg6IDB4MDBGMFxuLCBudGlsZGU6IDB4MDBGMVxuLCBvZ3JhdmU6IDB4MDBGMlxuLCBvYWN1dGU6IDB4MDBGM1xuLCBvY2lyYzogMHgwMEY0XG4sIG90aWxkZTogMHgwMEY1XG4sIG91bWw6IDB4MDBGNlxuLCBkaXZpZGU6IDB4MDBGN1xuLCBvc2xhc2g6IDB4MDBGOFxuLCB1Z3JhdmU6IDB4MDBGOVxuLCB1YWN1dGU6IDB4MDBGQVxuLCB1Y2lyYzogMHgwMEZCXG4sIHV1bWw6IDB4MDBGQ1xuLCB5YWN1dGU6IDB4MDBGRFxuLCB0aG9ybjogMHgwMEZFXG4sIHl1bWw6IDB4MDBGRlxuLCBPRWxpZzogMHgwMTUyXG4sIG9lbGlnOiAweDAxNTNcbiwgU2Nhcm9uOiAweDAxNjBcbiwgc2Nhcm9uOiAweDAxNjFcbiwgWXVtbDogMHgwMTc4XG4sIGZub2Y6IDB4MDE5MlxuLCBjaXJjOiAweDAyQzZcbiwgdGlsZGU6IDB4MDJEQ1xuLCBBbHBoYTogMHgwMzkxXG4sIEJldGE6IDB4MDM5MlxuLCBHYW1tYTogMHgwMzkzXG4sIERlbHRhOiAweDAzOTRcbiwgRXBzaWxvbjogMHgwMzk1XG4sIFpldGE6IDB4MDM5NlxuLCBFdGE6IDB4MDM5N1xuLCBUaGV0YTogMHgwMzk4XG4sIElvdGE6IDB4MDM5OVxuLCBLYXBwYTogMHgwMzlBXG4sIExhbWJkYTogMHgwMzlCXG4sIE11OiAweDAzOUNcbiwgTnU6IDB4MDM5RFxuLCBYaTogMHgwMzlFXG4sIE9taWNyb246IDB4MDM5RlxuLCBQaTogMHgwM0EwXG4sIFJobzogMHgwM0ExXG4sIFNpZ21hOiAweDAzQTNcbiwgVGF1OiAweDAzQTRcbiwgVXBzaWxvbjogMHgwM0E1XG4sIFBoaTogMHgwM0E2XG4sIENoaTogMHgwM0E3XG4sIFBzaTogMHgwM0E4XG4sIE9tZWdhOiAweDAzQTlcbiwgYWxwaGE6IDB4MDNCMVxuLCBiZXRhOiAweDAzQjJcbiwgZ2FtbWE6IDB4MDNCM1xuLCBkZWx0YTogMHgwM0I0XG4sIGVwc2lsb246IDB4MDNCNVxuLCB6ZXRhOiAweDAzQjZcbiwgZXRhOiAweDAzQjdcbiwgdGhldGE6IDB4MDNCOFxuLCBpb3RhOiAweDAzQjlcbiwga2FwcGE6IDB4MDNCQVxuLCBsYW1iZGE6IDB4MDNCQlxuLCBtdTogMHgwM0JDXG4sIG51OiAweDAzQkRcbiwgeGk6IDB4MDNCRVxuLCBvbWljcm9uOiAweDAzQkZcbiwgcGk6IDB4MDNDMFxuLCByaG86IDB4MDNDMVxuLCBzaWdtYWY6IDB4MDNDMlxuLCBzaWdtYTogMHgwM0MzXG4sIHRhdTogMHgwM0M0XG4sIHVwc2lsb246IDB4MDNDNVxuLCBwaGk6IDB4MDNDNlxuLCBjaGk6IDB4MDNDN1xuLCBwc2k6IDB4MDNDOFxuLCBvbWVnYTogMHgwM0M5XG4sIHRoZXRhc3ltOiAweDAzRDFcbiwgdXBzaWg6IDB4MDNEMlxuLCBwaXY6IDB4MDNENlxuLCBlbnNwOiAweDIwMDJcbiwgZW1zcDogMHgyMDAzXG4sIHRoaW5zcDogMHgyMDA5XG4sIHp3bmo6IDB4MjAwQ1xuLCB6d2o6IDB4MjAwRFxuLCBscm06IDB4MjAwRVxuLCBybG06IDB4MjAwRlxuLCBuZGFzaDogMHgyMDEzXG4sIG1kYXNoOiAweDIwMTRcbiwgbHNxdW86IDB4MjAxOFxuLCByc3F1bzogMHgyMDE5XG4sIHNicXVvOiAweDIwMUFcbiwgbGRxdW86IDB4MjAxQ1xuLCByZHF1bzogMHgyMDFEXG4sIGJkcXVvOiAweDIwMUVcbiwgZGFnZ2VyOiAweDIwMjBcbiwgRGFnZ2VyOiAweDIwMjFcbiwgYnVsbDogMHgyMDIyXG4sIGhlbGxpcDogMHgyMDI2XG4sIHBlcm1pbDogMHgyMDMwXG4sIHByaW1lOiAweDIwMzJcbiwgUHJpbWU6IDB4MjAzM1xuLCBsc2FxdW86IDB4MjAzOVxuLCByc2FxdW86IDB4MjAzQVxuLCBvbGluZTogMHgyMDNFXG4sIGZyYXNsOiAweDIwNDRcbiwgZXVybzogMHgyMEFDXG4sIGltYWdlOiAweDIxMTFcbiwgd2VpZXJwOiAweDIxMThcbiwgcmVhbDogMHgyMTFDXG4sIHRyYWRlOiAweDIxMjJcbiwgYWxlZnN5bTogMHgyMTM1XG4sIGxhcnI6IDB4MjE5MFxuLCB1YXJyOiAweDIxOTFcbiwgcmFycjogMHgyMTkyXG4sIGRhcnI6IDB4MjE5M1xuLCBoYXJyOiAweDIxOTRcbiwgY3JhcnI6IDB4MjFCNVxuLCBsQXJyOiAweDIxRDBcbiwgdUFycjogMHgyMUQxXG4sIHJBcnI6IDB4MjFEMlxuLCBkQXJyOiAweDIxRDNcbiwgaEFycjogMHgyMUQ0XG4sIGZvcmFsbDogMHgyMjAwXG4sIHBhcnQ6IDB4MjIwMlxuLCBleGlzdDogMHgyMjAzXG4sIGVtcHR5OiAweDIyMDVcbiwgbmFibGE6IDB4MjIwN1xuLCBpc2luOiAweDIyMDhcbiwgbm90aW46IDB4MjIwOVxuLCBuaTogMHgyMjBCXG4sIHByb2Q6IDB4MjIwRlxuLCBzdW06IDB4MjIxMVxuLCBtaW51czogMHgyMjEyXG4sIGxvd2FzdDogMHgyMjE3XG4sIHJhZGljOiAweDIyMUFcbiwgcHJvcDogMHgyMjFEXG4sIGluZmluOiAweDIyMUVcbiwgYW5nOiAweDIyMjBcbiwgYW5kOiAweDIyMjdcbiwgb3I6IDB4MjIyOFxuLCBjYXA6IDB4MjIyOVxuLCBjdXA6IDB4MjIyQVxuLCBpbnQ6IDB4MjIyQlxuLCB0aGVyZTQ6IDB4MjIzNFxuLCBzaW06IDB4MjIzQ1xuLCBjb25nOiAweDIyNDVcbiwgYXN5bXA6IDB4MjI0OFxuLCBuZTogMHgyMjYwXG4sIGVxdWl2OiAweDIyNjFcbiwgbGU6IDB4MjI2NFxuLCBnZTogMHgyMjY1XG4sIHN1YjogMHgyMjgyXG4sIHN1cDogMHgyMjgzXG4sIG5zdWI6IDB4MjI4NFxuLCBzdWJlOiAweDIyODZcbiwgc3VwZTogMHgyMjg3XG4sIG9wbHVzOiAweDIyOTVcbiwgb3RpbWVzOiAweDIyOTdcbiwgcGVycDogMHgyMkE1XG4sIHNkb3Q6IDB4MjJDNVxuLCBsY2VpbDogMHgyMzA4XG4sIHJjZWlsOiAweDIzMDlcbiwgbGZsb29yOiAweDIzMEFcbiwgcmZsb29yOiAweDIzMEJcbiwgbGFuZzogMHgyMzI5XG4sIHJhbmc6IDB4MjMyQVxuLCBsb3o6IDB4MjVDQVxuLCBzcGFkZXM6IDB4MjY2MFxuLCBjbHViczogMHgyNjYzXG4sIGhlYXJ0czogMHgyNjY1XG4sIGRpYW1zOiAweDI2NjZcbn1cbiIsInZhciBzdGFydFRhZyA9IC9ePChbXlxccz1cXC8hPl0rKSgoPzpcXHMrW15cXHM9XFwvPl0rKD86XFxzKj1cXHMqKD86KD86XCJbXlwiXSpcIil8KD86J1teJ10qJyl8W14+XFxzXSspPyk/KSopXFxzKihcXC8/KVxccyo+L1xuICAsIGVuZFRhZyA9IC9ePFxcLyhbXlxccz1cXC8hPl0rKVtePl0qPi9cbiAgLCBjb21tZW50ID0gL148IS0tKFtcXHNcXFNdKj8pLS0+L1xuICAsIGNvbW1lbnRJbnNpZGUgPSAvPCEtLVtcXHNcXFNdKj8tLT4vXG4gICwgb3RoZXIgPSAvXjwoW1xcc1xcU10qPyk+L1xuICAsIGF0dHIgPSAvKFteXFxzPV0rKSg/OlxccyooPSlcXHMqKD86KD86XCIoKD86XFxcXC58W15cIl0pKilcIil8KD86JygoPzpcXFxcLnxbXiddKSopJyl8KFtePlxcc10rKSk/KT8vZ1xuICAsIHJhd1RhZ3NEZWZhdWx0ID0gL14oc3R5bGV8c2NyaXB0KSQvaVxuXG5mdW5jdGlvbiBlbXB0eSgpIHt9XG5cbmZ1bmN0aW9uIG1hdGNoRW5kRGVmYXVsdCh0YWdOYW1lKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKCc8LycgKyB0YWdOYW1lLCAnaScpXG59XG5cbmZ1bmN0aW9uIG9uU3RhcnRUYWcoaHRtbCwgbWF0Y2gsIGhhbmRsZXIpIHtcbiAgdmFyIGF0dHJzID0ge31cbiAgICAsIHRhZyA9IG1hdGNoWzBdXG4gICAgLCB0YWdOYW1lID0gbWF0Y2hbMV1cbiAgICAsIHJlbWFpbmRlciA9IG1hdGNoWzJdXG4gIGh0bWwgPSBodG1sLnNsaWNlKHRhZy5sZW5ndGgpXG5cbiAgcmVtYWluZGVyLnJlcGxhY2UoYXR0ciwgZnVuY3Rpb24obWF0Y2gsIG5hbWUsIGVxdWFscywgYXR0cjAsIGF0dHIxLCBhdHRyMikge1xuICAgIGF0dHJzW25hbWUudG9Mb3dlckNhc2UoKV0gPSBhdHRyMCB8fCBhdHRyMSB8fCBhdHRyMiB8fCAoZXF1YWxzID8gJycgOiBudWxsKVxuICB9KVxuICBoYW5kbGVyKHRhZywgdGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBhdHRycywgaHRtbClcblxuICByZXR1cm4gaHRtbFxufVxuXG5mdW5jdGlvbiBvblRhZyhodG1sLCBtYXRjaCwgaGFuZGxlcikge1xuICB2YXIgdGFnID0gbWF0Y2hbMF1cbiAgICAsIGRhdGEgPSBtYXRjaFsxXVxuICBodG1sID0gaHRtbC5zbGljZSh0YWcubGVuZ3RoKVxuXG4gIGhhbmRsZXIodGFnLCBkYXRhLCBodG1sKVxuXG4gIHJldHVybiBodG1sXG59XG5cbmZ1bmN0aW9uIG9uVGV4dChodG1sLCBpbmRleCwgaXNSYXdUZXh0LCBoYW5kbGVyKSB7XG4gIHZhciB0ZXh0XG4gIGlmICh+aW5kZXgpIHtcbiAgICB0ZXh0ID0gaHRtbC5zbGljZSgwLCBpbmRleClcbiAgICBodG1sID0gaHRtbC5zbGljZShpbmRleClcbiAgfSBlbHNlIHtcbiAgICB0ZXh0ID0gaHRtbFxuICAgIGh0bWwgPSAnJ1xuICB9XG5cbiAgaWYgKHRleHQpIGhhbmRsZXIodGV4dCwgaXNSYXdUZXh0LCBodG1sKVxuXG4gIHJldHVybiBodG1sXG59XG5cbmZ1bmN0aW9uIHJhd0VuZChodG1sLCBlbmRpbmcsIG9mZnNldCkge1xuICBvZmZzZXQgfHwgKG9mZnNldCA9IDApXG4gIHZhciBpbmRleCA9IGh0bWwuc2VhcmNoKGVuZGluZylcbiAgICAsIGNvbW1lbnRNYXRjaCA9IGh0bWwubWF0Y2goY29tbWVudEluc2lkZSlcbiAgICAsIGNvbW1lbnRFbmRcbiAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIGVuZGluZyBjb25kaXRpb24gaXNuJ3QgaW5zaWRlIG9mIGFuIEhUTUwgY29tbWVudFxuICBpZiAoY29tbWVudE1hdGNoICYmIGNvbW1lbnRNYXRjaC5pbmRleCA8IGluZGV4KSB7XG4gICAgY29tbWVudEVuZCA9IGNvbW1lbnRNYXRjaC5pbmRleCArIGNvbW1lbnRNYXRjaFswXS5sZW5ndGhcbiAgICBvZmZzZXQgKz0gY29tbWVudEVuZFxuICAgIGh0bWwgPSBodG1sLnNsaWNlKGNvbW1lbnRFbmQpXG4gICAgcmV0dXJuIHJhd0VuZChodG1sLCBlbmRpbmcsIG9mZnNldClcbiAgfVxuICByZXR1cm4gaW5kZXggKyBvZmZzZXRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihodG1sLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09IG51bGwpIG9wdGlvbnMgPSB7fVxuXG4gIGlmICghaHRtbCkgcmV0dXJuXG5cbiAgdmFyIHN0YXJ0SGFuZGxlciA9IG9wdGlvbnMuc3RhcnQgfHwgZW1wdHlcbiAgICAsIGVuZEhhbmRsZXIgPSBvcHRpb25zLmVuZCB8fCBlbXB0eVxuICAgICwgdGV4dEhhbmRsZXIgPSBvcHRpb25zLnRleHQgfHwgZW1wdHlcbiAgICAsIGNvbW1lbnRIYW5kbGVyID0gb3B0aW9ucy5jb21tZW50IHx8IGVtcHR5XG4gICAgLCBvdGhlckhhbmRsZXIgPSBvcHRpb25zLm90aGVyIHx8IGVtcHR5XG4gICAgLCBtYXRjaEVuZCA9IG9wdGlvbnMubWF0Y2hFbmQgfHwgbWF0Y2hFbmREZWZhdWx0XG4gICAgLCBlcnJvckhhbmRsZXIgPSBvcHRpb25zLmVycm9yXG4gICAgLCByYXdUYWdzID0gb3B0aW9ucy5yYXdUYWdzIHx8IHJhd1RhZ3NEZWZhdWx0XG4gICAgLCBpbmRleCwgbGFzdCwgbWF0Y2gsIHRhZ05hbWUsIGVyclxuXG4gIHdoaWxlIChodG1sKSB7XG4gICAgaWYgKGh0bWwgPT09IGxhc3QpIHtcbiAgICAgIGVyciA9IG5ldyBFcnJvcignSFRNTCBwYXJzZSBlcnJvcjogJyArIGh0bWwpXG4gICAgICBpZiAoZXJyb3JIYW5kbGVyKSB7XG4gICAgICAgIGVycm9ySGFuZGxlcihlcnIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cbiAgICB9XG4gICAgbGFzdCA9IGh0bWxcblxuICAgIGlmIChodG1sWzBdID09PSAnPCcpIHtcbiAgICAgIGlmIChtYXRjaCA9IGh0bWwubWF0Y2goc3RhcnRUYWcpKSB7XG4gICAgICAgIGh0bWwgPSBvblN0YXJ0VGFnKGh0bWwsIG1hdGNoLCBzdGFydEhhbmRsZXIpXG5cbiAgICAgICAgdGFnTmFtZSA9IG1hdGNoWzFdXG4gICAgICAgIGlmIChyYXdUYWdzLnRlc3QodGFnTmFtZSkpIHtcbiAgICAgICAgICBpbmRleCA9IHJhd0VuZChodG1sLCBtYXRjaEVuZCh0YWdOYW1lKSlcbiAgICAgICAgICBodG1sID0gb25UZXh0KGh0bWwsIGluZGV4LCB0cnVlLCB0ZXh0SGFuZGxlcilcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPSBodG1sLm1hdGNoKGVuZFRhZykpIHtcbiAgICAgICAgbWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpICAvLyB0YWdOYW1lXG4gICAgICAgIGh0bWwgPSBvblRhZyhodG1sLCBtYXRjaCwgZW5kSGFuZGxlcilcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoID0gaHRtbC5tYXRjaChjb21tZW50KSkge1xuICAgICAgICBodG1sID0gb25UYWcoaHRtbCwgbWF0Y2gsIGNvbW1lbnRIYW5kbGVyKVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPSBodG1sLm1hdGNoKG90aGVyKSkge1xuICAgICAgICBodG1sID0gb25UYWcoaHRtbCwgbWF0Y2gsIG90aGVySGFuZGxlcilcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbmRleCA9IGh0bWwuaW5kZXhPZignPCcpXG4gICAgaHRtbCA9IG9uVGV4dChodG1sLCBpbmRleCwgZmFsc2UsIHRleHRIYW5kbGVyKVxuICB9XG59XG4iLCJ2YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaGFubmVsO1xuXG5mdW5jdGlvbiBDaGFubmVsKHNvY2tldCkge1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgdGhpcy5tZXNzYWdlcyA9IG5ldyBNZXNzYWdlcztcblxuICB2YXIgY2hhbm5lbCA9IHRoaXM7XG4gIHZhciBvbm1lc3NhZ2UgPSBzb2NrZXQub25tZXNzYWdlO1xuICBzb2NrZXQub25tZXNzYWdlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIGlmIChkYXRhICYmIGRhdGEucmFjZXIpIHJldHVybiBjaGFubmVsLl9vbk1lc3NhZ2UoZGF0YSk7XG4gICAgb25tZXNzYWdlICYmIG9ubWVzc2FnZS5jYWxsKHNvY2tldCwgZGF0YSk7XG4gIH07XG59XG5cbnV0aWwubWVyZ2VJbnRvKENoYW5uZWwucHJvdG90eXBlLCBFdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblxuQ2hhbm5lbC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG5hbWUsIGRhdGEsIGNiKSB7XG4gIHZhciBtZXNzYWdlID0gdGhpcy5tZXNzYWdlcy5hZGQobmFtZSwgZGF0YSwgY2IpO1xuICAvLyBQcm9hY3RpdmVseSBjYWxsIHRoZSB0b0pTT04gZnVuY3Rpb24sIHNpbmNlIHRoZSBHb29nbGUgQ2xvc3VyZSBKU09OXG4gIC8vIHNlcmlhbGl6ZXIgZG9lc24ndCBjaGVjayBmb3IgaXRcbiAgdGhpcy5zb2NrZXQuc2VuZChtZXNzYWdlLnRvSlNPTigpKTtcbn07XG5cbkNoYW5uZWwucHJvdG90eXBlLl9yZXBseSA9IGZ1bmN0aW9uKGlkLCBuYW1lLCBkYXRhKSB7XG4gIHZhciBtZXNzYWdlID0gbmV3IE1lc3NhZ2UoaWQsIHRydWUsIG5hbWUsIGRhdGEpO1xuICB0aGlzLnNvY2tldC5zZW5kKG1lc3NhZ2UudG9KU09OKCkpO1xufTtcblxuQ2hhbm5lbC5wcm90b3R5cGUuX29uTWVzc2FnZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgaWYgKGRhdGEuYWNrKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VzLnJlbW92ZShkYXRhLmlkKTtcbiAgICBpZiAobWVzc2FnZSAmJiBtZXNzYWdlLmNiKSBtZXNzYWdlLmNiLmFwcGx5KGRhdGEuZGF0YSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuYW1lID0gZGF0YS5yYWNlcjtcbiAgaWYgKGRhdGEuY2IpIHtcbiAgICB2YXIgY2hhbm5lbCA9IHRoaXM7XG4gICAgdmFyIGhhc0xpc3RlbmVycyA9IHRoaXMuZW1pdChuYW1lLCBkYXRhLmRhdGEsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgY2hhbm5lbC5fcmVwbHkoZGF0YS5pZCwgbmFtZSwgYXJncyk7XG4gICAgfSk7XG4gICAgaWYgKCFoYXNMaXN0ZW5lcnMpIHRoaXMuX3JlcGx5KGRhdGEuaWQsIG5hbWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZW1pdChuYW1lLCBkYXRhLmRhdGEpO1xuICAgIHRoaXMuX3JlcGx5KGRhdGEuaWQsIG5hbWUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBNZXNzYWdlc01hcCgpIHt9XG5cbmZ1bmN0aW9uIE1lc3NhZ2VzKCkge1xuICB0aGlzLm1hcCA9IG5ldyBNZXNzYWdlc01hcCgpO1xuICB0aGlzLmlkQ291bnQgPSAwO1xufVxuTWVzc2FnZXMucHJvdG90eXBlLmlkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoKyt0aGlzLmlkQ291bnQpLnRvU3RyaW5nKDM2KTtcbn07XG5NZXNzYWdlcy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24obmFtZSwgZGF0YSwgY2IpIHtcbiAgdmFyIG1lc3NhZ2UgPSBuZXcgTWVzc2FnZSh0aGlzLmlkKCksIGZhbHNlLCBuYW1lLCBkYXRhLCBjYik7XG4gIHRoaXMubWFwW21lc3NhZ2UuaWRdID0gbWVzc2FnZTtcbiAgcmV0dXJuIG1lc3NhZ2U7XG59O1xuTWVzc2FnZXMucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGlkKSB7XG4gIHZhciBtZXNzYWdlID0gdGhpcy5tYXBbaWRdO1xuICBkZWxldGUgdGhpcy5tYXBbaWRdO1xuICByZXR1cm4gbWVzc2FnZTtcbn07XG5cbmZ1bmN0aW9uIE1lc3NhZ2UoaWQsIGFjaywgbmFtZSwgZGF0YSwgY2IpIHtcbiAgdGhpcy5pZCA9IGlkO1xuICB0aGlzLmFjayA9IGFjaztcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5jYiA9IGNiO1xufVxuTWVzc2FnZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmFjZXI6IHRoaXMubmFtZVxuICAsIGlkOiB0aGlzLmlkXG4gICwgZGF0YTogdGhpcy5kYXRhXG4gICwgYWNrOiArdGhpcy5hY2tcbiAgLCBjYjogKHRoaXMuY2IpID8gMSA6IDBcbiAgfTtcbn07XG4iLCJ2YXIgRG9jID0gcmVxdWlyZSgnLi9Eb2MnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvY2FsRG9jO1xuXG5mdW5jdGlvbiBMb2NhbERvYyhtb2RlbCwgY29sbGVjdGlvbk5hbWUsIGlkLCBzbmFwc2hvdCkge1xuICBEb2MuY2FsbCh0aGlzLCBtb2RlbCwgY29sbGVjdGlvbk5hbWUsIGlkKTtcbiAgdGhpcy5zbmFwc2hvdCA9IHNuYXBzaG90O1xuICB0aGlzLl91cGRhdGVDb2xsZWN0aW9uRGF0YSgpO1xufVxuXG5Mb2NhbERvYy5wcm90b3R5cGUgPSBuZXcgRG9jO1xuXG5Mb2NhbERvYy5wcm90b3R5cGUuX3VwZGF0ZUNvbGxlY3Rpb25EYXRhID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY29sbGVjdGlvbkRhdGFbdGhpcy5pZF0gPSB0aGlzLnNuYXBzaG90O1xufTtcblxuTG9jYWxEb2MucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCB2YWx1ZSwgY2IpIHtcbiAgZnVuY3Rpb24gc2V0KG5vZGUsIGtleSkge1xuICAgIHZhciBwcmV2aW91cyA9IG5vZGVba2V5XTtcbiAgICBub2RlW2tleV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gcHJldmlvdXM7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FwcGx5KHNlZ21lbnRzLCBzZXQsIGNiKTtcbn07XG5cbkxvY2FsRG9jLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbihzZWdtZW50cywgY2IpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgdGhlIHZhbHVlIGlzIGFscmVhZHkgdW5kZWZpbmVkLCBzaW5jZVxuICAvLyBhcHBseSBjcmVhdGVzIG9iamVjdHMgYXMgaXQgdHJhdmVyc2VzLCBhbmQgdGhlIGRlbCBtZXRob2RcbiAgLy8gc2hvdWxkIG5vdCBjcmVhdGUgYW55dGhpbmdcbiAgdmFyIHByZXZpb3VzID0gdGhpcy5nZXQoc2VnbWVudHMpO1xuICBpZiAocHJldmlvdXMgPT09IHZvaWQgMCkge1xuICAgIGNiKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZ1bmN0aW9uIGRlbChub2RlLCBrZXkpIHtcbiAgICBkZWxldGUgbm9kZVtrZXldO1xuICAgIHJldHVybiBwcmV2aW91cztcbiAgfVxuICByZXR1cm4gdGhpcy5fYXBwbHkoc2VnbWVudHMsIGRlbCwgY2IpO1xufTtcblxuTG9jYWxEb2MucHJvdG90eXBlLmluY3JlbWVudCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBieU51bWJlciwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBmdW5jdGlvbiB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlID09IG51bGwpIHJldHVybjtcbiAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihzZWxmLl9lcnJvck1lc3NhZ2UoXG4gICAgICAnaW5jcmVtZW50IG9uIG5vbi1udW1iZXInLCBzZWdtZW50cywgdmFsdWVcbiAgICApKTtcbiAgfVxuICBmdW5jdGlvbiBpbmNyZW1lbnQobm9kZSwga2V5KSB7XG4gICAgdmFyIHZhbHVlID0gKG5vZGVba2V5XSB8fCAwKSArIGJ5TnVtYmVyO1xuICAgIG5vZGVba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcy5fdmFsaWRhdGVkQXBwbHkoc2VnbWVudHMsIHZhbGlkYXRlLCBpbmNyZW1lbnQsIGNiKTtcbn07XG5cbkxvY2FsRG9jLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oc2VnbWVudHMsIHZhbHVlLCBjYikge1xuICBmdW5jdGlvbiBwdXNoKGFycikge1xuICAgIHJldHVybiBhcnIucHVzaCh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FycmF5QXBwbHkoc2VnbWVudHMsIHB1c2gsIGNiKTtcbn07XG5cbkxvY2FsRG9jLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24oc2VnbWVudHMsIHZhbHVlLCBjYikge1xuICBmdW5jdGlvbiB1bnNoaWZ0KGFycikge1xuICAgIHJldHVybiBhcnIudW5zaGlmdCh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FycmF5QXBwbHkoc2VnbWVudHMsIHVuc2hpZnQsIGNiKTtcbn07XG5cbkxvY2FsRG9jLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbihzZWdtZW50cywgaW5kZXgsIHZhbHVlcywgY2IpIHtcbiAgZnVuY3Rpb24gaW5zZXJ0KGFycikge1xuICAgIGFyci5zcGxpY2UuYXBwbHkoYXJyLCBbaW5kZXgsIDBdLmNvbmNhdCh2YWx1ZXMpKTtcbiAgICByZXR1cm4gYXJyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyYXlBcHBseShzZWdtZW50cywgaW5zZXJ0LCBjYik7XG59O1xuXG5Mb2NhbERvYy5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oc2VnbWVudHMsIGNiKSB7XG4gIGZ1bmN0aW9uIHBvcChhcnIpIHtcbiAgICByZXR1cm4gYXJyLnBvcCgpO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJheUFwcGx5KHNlZ21lbnRzLCBwb3AsIGNiKTtcbn07XG5cbkxvY2FsRG9jLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBjYikge1xuICBmdW5jdGlvbiBzaGlmdChhcnIpIHtcbiAgICByZXR1cm4gYXJyLnNoaWZ0KCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FycmF5QXBwbHkoc2VnbWVudHMsIHNoaWZ0LCBjYik7XG59O1xuXG5Mb2NhbERvYy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oc2VnbWVudHMsIGluZGV4LCBob3dNYW55LCBjYikge1xuICBmdW5jdGlvbiByZW1vdmUoYXJyKSB7XG4gICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIGhvd01hbnkpO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJheUFwcGx5KHNlZ21lbnRzLCByZW1vdmUsIGNiKTtcbn07XG5cbkxvY2FsRG9jLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24oc2VnbWVudHMsIGZyb20sIHRvLCBob3dNYW55LCBjYikge1xuICBmdW5jdGlvbiBtb3ZlKGFycikge1xuICAgIC8vIFJlbW92ZSBmcm9tIG9sZCBsb2NhdGlvblxuICAgIHZhciB2YWx1ZXMgPSBhcnIuc3BsaWNlKGZyb20sIGhvd01hbnkpO1xuICAgIC8vIEluc2VydCBpbiBuZXcgbG9jYXRpb25cbiAgICBhcnIuc3BsaWNlLmFwcGx5KGFyciwgW3RvLCAwXS5jb25jYXQodmFsdWVzKSk7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyYXlBcHBseShzZWdtZW50cywgbW92ZSwgY2IpO1xufTtcblxuTG9jYWxEb2MucHJvdG90eXBlLnN0cmluZ0luc2VydCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBpbmRleCwgdmFsdWUsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB2YWx1ZSA9PSBudWxsKSByZXR1cm47XG4gICAgcmV0dXJuIG5ldyBUeXBlRXJyb3Ioc2VsZi5fZXJyb3JNZXNzYWdlKFxuICAgICAgJ3N0cmluZ0luc2VydCBvbiBub24tc3RyaW5nJywgc2VnbWVudHMsIHZhbHVlXG4gICAgKSk7XG4gIH1cbiAgZnVuY3Rpb24gc3RyaW5nSW5zZXJ0KG5vZGUsIGtleSkge1xuICAgIHZhciBwcmV2aW91cyA9IG5vZGVba2V5XTtcbiAgICBpZiAocHJldmlvdXMgPT0gbnVsbCkge1xuICAgICAgbm9kZVtrZXldID0gdmFsdWU7XG4gICAgICByZXR1cm4gcHJldmlvdXM7XG4gICAgfVxuICAgIG5vZGVba2V5XSA9IHByZXZpb3VzLnNsaWNlKDAsIGluZGV4KSArIHZhbHVlICsgcHJldmlvdXMuc2xpY2UoaW5kZXgpO1xuICAgIHJldHVybiBwcmV2aW91cztcbiAgfVxuICByZXR1cm4gdGhpcy5fdmFsaWRhdGVkQXBwbHkoc2VnbWVudHMsIHZhbGlkYXRlLCBzdHJpbmdJbnNlcnQsIGNiKTtcbn07XG5cbkxvY2FsRG9jLnByb3RvdHlwZS5zdHJpbmdSZW1vdmUgPSBmdW5jdGlvbihzZWdtZW50cywgaW5kZXgsIGhvd01hbnksIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB2YWx1ZSA9PSBudWxsKSByZXR1cm47XG4gICAgcmV0dXJuIG5ldyBUeXBlRXJyb3Ioc2VsZi5fZXJyb3JNZXNzYWdlKFxuICAgICAgJ3N0cmluZ1JlbW92ZSBvbiBub24tc3RyaW5nJywgc2VnbWVudHMsIHZhbHVlXG4gICAgKSk7XG4gIH1cbiAgZnVuY3Rpb24gc3RyaW5nUmVtb3ZlKG5vZGUsIGtleSkge1xuICAgIHZhciBwcmV2aW91cyA9IG5vZGVba2V5XTtcbiAgICBpZiAocHJldmlvdXMgPT0gbnVsbCkgcmV0dXJuIHByZXZpb3VzO1xuICAgIGlmIChpbmRleCA8IDApIGluZGV4ICs9IHByZXZpb3VzLmxlbmd0aDtcbiAgICBub2RlW2tleV0gPSBwcmV2aW91cy5zbGljZSgwLCBpbmRleCkgKyBwcmV2aW91cy5zbGljZShpbmRleCArIGhvd01hbnkpO1xuICAgIHJldHVybiBwcmV2aW91cztcbiAgfVxuICByZXR1cm4gdGhpcy5fdmFsaWRhdGVkQXBwbHkoc2VnbWVudHMsIHZhbGlkYXRlLCBzdHJpbmdSZW1vdmUsIGNiKTtcbn07XG5cbkxvY2FsRG9jLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihzZWdtZW50cykge1xuICByZXR1cm4gdXRpbC5sb29rdXAoc2VnbWVudHMsIHRoaXMuc25hcHNob3QpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5fSBzZWdtZW50cyBpcyB0aGUgYXJyYXkgcmVwcmVzZW50aW5nIGEgcGF0aFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4obm9kZSwga2V5KSBhcHBsaWVzIGEgbXV0YXRpb24gb24gbm9kZVtrZXldXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJldHVybnMgdGhlIHJldHVybiB2YWx1ZSBvZiBmbihub2RlLCBrZXkpXG4gKi9cbkxvY2FsRG9jLnByb3RvdHlwZS5fY3JlYXRlSW1wbGllZCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBmbikge1xuICB2YXIgbm9kZSA9IHRoaXM7XG4gIHZhciBrZXkgPSAnc25hcHNob3QnO1xuICB2YXIgaSA9IDA7XG4gIHZhciBuZXh0S2V5ID0gc2VnbWVudHNbaSsrXTtcbiAgd2hpbGUgKG5leHRLZXkgIT0gbnVsbCkge1xuICAgIC8vIEdldCBvciBjcmVhdGUgaW1wbGllZCBvYmplY3Qgb3IgYXJyYXlcbiAgICBub2RlID0gbm9kZVtrZXldIHx8IChub2RlW2tleV0gPSAvXlxcZCskLy50ZXN0KG5leHRLZXkpID8gW10gOiB7fSk7XG4gICAga2V5ID0gbmV4dEtleTtcbiAgICBuZXh0S2V5ID0gc2VnbWVudHNbaSsrXTtcbiAgfVxuICByZXR1cm4gZm4obm9kZSwga2V5KTtcbn07XG5cbkxvY2FsRG9jLnByb3RvdHlwZS5fYXBwbHkgPSBmdW5jdGlvbihzZWdtZW50cywgZm4sIGNiKSB7XG4gIHZhciBvdXQgPSB0aGlzLl9jcmVhdGVJbXBsaWVkKHNlZ21lbnRzLCBmbik7XG4gIHRoaXMuX3VwZGF0ZUNvbGxlY3Rpb25EYXRhKCk7XG4gIGNiKCk7XG4gIHJldHVybiBvdXQ7XG59O1xuXG5Mb2NhbERvYy5wcm90b3R5cGUuX3ZhbGlkYXRlZEFwcGx5ID0gZnVuY3Rpb24oc2VnbWVudHMsIHZhbGlkYXRlLCBmbiwgY2IpIHtcbiAgdmFyIG91dCA9IHRoaXMuX2NyZWF0ZUltcGxpZWQoc2VnbWVudHMsIGZ1bmN0aW9uKG5vZGUsIGtleSkge1xuICAgIHZhciBlcnIgPSB2YWxpZGF0ZShub2RlW2tleV0pO1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuICAgIHJldHVybiBmbihub2RlLCBrZXkpO1xuICB9KTtcbiAgdGhpcy5fdXBkYXRlQ29sbGVjdGlvbkRhdGEoKTtcbiAgY2IoKTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbkxvY2FsRG9jLnByb3RvdHlwZS5fYXJyYXlBcHBseSA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBmbiwgY2IpIHtcbiAgLy8gTG9va3VwIGEgcG9pbnRlciB0byB0aGUgcHJvcGVydHkgb3IgbmVzdGVkIHByb3BlcnR5ICZcbiAgLy8gcmV0dXJuIHRoZSBjdXJyZW50IHZhbHVlIG9yIGNyZWF0ZSBhIG5ldyBhcnJheVxuICB2YXIgYXJyID0gdGhpcy5fY3JlYXRlSW1wbGllZChzZWdtZW50cywgbm9kZUNyZWF0ZUFycmF5KTtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIHZhciBtZXNzYWdlID0gdGhpcy5fZXJyb3JNZXNzYWdlKGZuLm5hbWUgKyAnIG9uIG5vbi1hcnJheScsIHNlZ21lbnRzLCBhcnIpO1xuICAgIHZhciBlcnIgPSBuZXcgVHlwZUVycm9yKG1lc3NhZ2UpO1xuICAgIHJldHVybiBjYihlcnIpO1xuICB9XG4gIHZhciBvdXQgPSBmbihhcnIpO1xuICB0aGlzLl91cGRhdGVDb2xsZWN0aW9uRGF0YSgpO1xuICBjYigpO1xuICByZXR1cm4gb3V0O1xufTtcblxuZnVuY3Rpb24gbm9kZUNyZWF0ZUFycmF5KG5vZGUsIGtleSkge1xuICByZXR1cm4gbm9kZVtrZXldIHx8IChub2RlW2tleV0gPSBbXSk7XG59XG4iLCIvKipcbiAqIFJlbW90ZURvYyBhZGFwdHMgdGhlIFNoYXJlSlMgb3BlcmF0aW9uIHByb3RvY29sIHRvIFJhY2VyJ3MgbXV0YXRvclxuICogaW50ZXJmYWNlLlxuICpcbiAqIDEuIEl0IG1hcHMgUmFjZXIncyBtdXRhdG9yIG1ldGhvZHMgdG8gb3V0Z29pbmcgU2hhcmVKUyBvcGVyYXRpb25zLlxuICogMi4gSXQgbWFwcyBpbmNvbWluZyBTaGFyZUpTIG9wZXJhdGlvbnMgdG8gUmFjZXIgZXZlbnRzLlxuICovXG5cbnZhciBEb2MgPSByZXF1aXJlKCcuL0RvYycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVtb3RlRG9jO1xuXG5mdW5jdGlvbiBSZW1vdGVEb2MobW9kZWwsIGNvbGxlY3Rpb25OYW1lLCBpZCwgZGF0YSkge1xuICBEb2MuY2FsbCh0aGlzLCBtb2RlbCwgY29sbGVjdGlvbk5hbWUsIGlkKTtcbiAgdmFyIHNoYXJlRG9jID0gdGhpcy5zaGFyZURvYyA9IG1vZGVsLl9nZXRPckNyZWF0ZVNoYXJlRG9jKGNvbGxlY3Rpb25OYW1lLCBpZCwgZGF0YSk7XG4gIHRoaXMuY3JlYXRlZExvY2FsbHkgPSBmYWxzZTtcbiAgdGhpcy5tb2RlbCA9IG1vZGVsID0gbW9kZWwucGFzcyh7JHJlbW90ZTogdHJ1ZX0pO1xuICB0aGlzLl9wYXNzU3RyaW5nSW5zZXJ0ID0gbW9kZWwucGFzcyh7JG9yaWdpbmFsOiAnc3RyaW5nSW5zZXJ0J30pLl9wYXNzO1xuICB0aGlzLl9wYXNzU3RyaW5nUmVtb3ZlID0gbW9kZWwucGFzcyh7JG9yaWdpbmFsOiAnc3RyaW5nUmVtb3ZlJ30pLl9wYXNzO1xuICB0aGlzLl91cGRhdGVDb2xsZWN0aW9uRGF0YSgpO1xuXG4gIHZhciBkb2MgPSB0aGlzO1xuICBzaGFyZURvYy5vbignb3AnLCBmdW5jdGlvbihvcCwgaXNMb2NhbCkge1xuICAgIC8vIERvbid0IGVtaXQgb24gbG9jYWwgb3BlcmF0aW9ucywgc2luY2UgdGhleSBhcmUgZW1pdHRlZCBpbiB0aGUgbXV0YXRvclxuICAgIGlmIChpc0xvY2FsKSByZXR1cm47XG4gICAgZG9jLl91cGRhdGVDb2xsZWN0aW9uRGF0YSgpO1xuICAgIGRvYy5fb25PcChvcCk7XG4gIH0pO1xuICBzaGFyZURvYy5vbignZGVsJywgZnVuY3Rpb24oaXNMb2NhbCwgcHJldmlvdXMpIHtcbiAgICAvLyBDYWxsaW5nIHRoZSBzaGFyZURvYy5kZWwgbWV0aG9kIGRvZXMgbm90IGVtaXQgYW4gb3BlcmF0aW9uIGV2ZW50LFxuICAgIC8vIHNvIHdlIGNyZWF0ZSB0aGUgYXBwcm9wcmlhdGUgZXZlbnQgaGVyZS5cbiAgICBpZiAoaXNMb2NhbCkgcmV0dXJuO1xuICAgIGRvYy5fdXBkYXRlQ29sbGVjdGlvbkRhdGEoKTtcbiAgICBtb2RlbC5lbWl0KCdjaGFuZ2UnLCBbY29sbGVjdGlvbk5hbWUsIGlkXSwgW3ZvaWQgMCwgcHJldmlvdXMsIG1vZGVsLl9wYXNzXSk7XG4gIH0pO1xuICBzaGFyZURvYy5vbignY3JlYXRlJywgZnVuY3Rpb24oaXNMb2NhbCkge1xuICAgIC8vIExvY2FsIGNyZWF0ZXMgc2hvdWxkIG5vdCBlbWl0IGFuIGV2ZW50LCBzaW5jZSB0aGV5IG9ubHkgaGFwcGVuXG4gICAgLy8gaW1wbGljaXRseSBhcyBhIHJlc3VsdCBvZiBhbm90aGVyIG11dGF0aW9uLCBhbmQgdGhhdCBvcGVyYXRpb24gd2lsbFxuICAgIC8vIGVtaXQgdGhlIGFwcHJvcHJpYXRlIGV2ZW50LiBSZW1vdGUgY3JlYXRlcyBjYW4gc2V0IHRoZSBzbmFwc2hvdCBkYXRhXG4gICAgLy8gd2l0aG91dCBlbWl0dGluZyBhbiBvcGVyYXRpb24gZXZlbnQsIHNvIGFuIGV2ZW50IG5lZWRzIHRvIGJlIGVtaXR0ZWRcbiAgICAvLyBmb3IgdGhlbS5cbiAgICBpZiAoaXNMb2NhbCkge1xuICAgICAgLy8gVHJhY2sgd2hlbiBhIGRvY3VtZW50IHdhcyBjcmVhdGVkIGJ5IHRoaXMgY2xpZW50LCBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAvLyBlbWl0IGEgbG9hZCBldmVudCB3aGVuIHN1YnNlcXVlbnRseSBzdWJzY3JpYmVkXG4gICAgICBkb2MuY3JlYXRlZExvY2FsbHkgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkb2MuX3VwZGF0ZUNvbGxlY3Rpb25EYXRhKCk7XG4gICAgdmFyIHZhbHVlID0gc2hhcmVEb2Muc25hcHNob3Q7XG4gICAgbW9kZWwuZW1pdCgnY2hhbmdlJywgW2NvbGxlY3Rpb25OYW1lLCBpZF0sIFt2YWx1ZSwgdm9pZCAwLCBtb2RlbC5fcGFzc10pO1xuICB9KTtcbn1cblxuUmVtb3RlRG9jLnByb3RvdHlwZSA9IG5ldyBEb2M7XG5cblJlbW90ZURvYy5wcm90b3R5cGUuX3VwZGF0ZUNvbGxlY3Rpb25EYXRhID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY29sbGVjdGlvbkRhdGFbdGhpcy5pZF0gPSB0aGlzLnNoYXJlRG9jLnNuYXBzaG90O1xufTtcblxuUmVtb3RlRG9jLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihzZWdtZW50cywgdmFsdWUsIGNiKSB7XG4gIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDAgJiYgIXRoaXMuc2hhcmVEb2MudHlwZSkge1xuICAgIHRoaXMuc2hhcmVEb2MuY3JlYXRlKCdqc29uMCcsIHZhbHVlLCBjYik7XG4gICAgdGhpcy5fdXBkYXRlQ29sbGVjdGlvbkRhdGEoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHByZXZpb3VzID0gdGhpcy5fY3JlYXRlSW1wbGllZChzZWdtZW50cyk7XG4gIHZhciBsYXN0U2VnbWVudCA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xuICBpZiAocHJldmlvdXMgaW5zdGFuY2VvZiBJbXBsaWVkT3ApIHtcbiAgICBwcmV2aW91cy52YWx1ZVtsYXN0U2VnbWVudF0gPSB2YWx1ZTtcbiAgICB0aGlzLnNoYXJlRG9jLnN1Ym1pdE9wKHByZXZpb3VzLm9wLCBjYik7XG4gICAgdGhpcy5fdXBkYXRlQ29sbGVjdGlvbkRhdGEoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG9wID0gKGlzQXJyYXlJbmRleChsYXN0U2VnbWVudCkpID9cbiAgICAocHJldmlvdXMgPT0gbnVsbCkgP1xuICAgICAgW25ldyBMaXN0SW5zZXJ0T3Aoc2VnbWVudHMuc2xpY2UoMCwgLTEpLCBsYXN0U2VnbWVudCwgdmFsdWUpXSA6XG4gICAgICBbbmV3IExpc3RSZXBsYWNlT3Aoc2VnbWVudHMuc2xpY2UoMCwgLTEpLCBsYXN0U2VnbWVudCwgcHJldmlvdXMsIHZhbHVlKV0gOlxuICAgIChwcmV2aW91cyA9PSBudWxsKSA/XG4gICAgICBbbmV3IE9iamVjdEluc2VydE9wKHNlZ21lbnRzLCB2YWx1ZSldIDpcbiAgICAgIFtuZXcgT2JqZWN0UmVwbGFjZU9wKHNlZ21lbnRzLCBwcmV2aW91cywgdmFsdWUpXTtcbiAgdGhpcy5zaGFyZURvYy5zdWJtaXRPcChvcCwgY2IpO1xuICB0aGlzLl91cGRhdGVDb2xsZWN0aW9uRGF0YSgpO1xuICByZXR1cm4gcHJldmlvdXM7XG59O1xuXG5SZW1vdGVEb2MucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBjYikge1xuICBpZiAoc2VnbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdmFyIHByZXZpb3VzID0gdGhpcy5nZXQoKTtcbiAgICB0aGlzLnNoYXJlRG9jLmRlbChjYik7XG4gICAgdGhpcy5fdXBkYXRlQ29sbGVjdGlvbkRhdGEoKTtcbiAgICByZXR1cm4gcHJldmlvdXM7XG4gIH1cbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgdGhlIHZhbHVlIGlzIGFscmVhZHkgdW5kZWZpbmVkLCBzaW5jZVxuICAvLyB0aGUgZGVsIG1ldGhvZCBzaG91bGQgbm90IGNyZWF0ZSBhbnl0aGluZ1xuICB2YXIgcHJldmlvdXMgPSB0aGlzLmdldChzZWdtZW50cyk7XG4gIGlmIChwcmV2aW91cyA9PT0gdm9pZCAwKSB7XG4gICAgY2IoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG9wID0gW25ldyBPYmplY3REZWxldGVPcChzZWdtZW50cywgcHJldmlvdXMpXTtcbiAgdGhpcy5zaGFyZURvYy5zdWJtaXRPcChvcCwgY2IpO1xuICB0aGlzLl91cGRhdGVDb2xsZWN0aW9uRGF0YSgpO1xuICByZXR1cm4gcHJldmlvdXM7XG59O1xuXG5SZW1vdGVEb2MucHJvdG90eXBlLmluY3JlbWVudCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBieU51bWJlciwgY2IpIHtcbiAgdmFyIHByZXZpb3VzID0gdGhpcy5fY3JlYXRlSW1wbGllZChzZWdtZW50cyk7XG4gIGlmIChwcmV2aW91cyBpbnN0YW5jZW9mIEltcGxpZWRPcCkge1xuICAgIHZhciBsYXN0U2VnbWVudCA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgIHByZXZpb3VzLnZhbHVlW2xhc3RTZWdtZW50XSA9IGJ5TnVtYmVyO1xuICAgIHRoaXMuc2hhcmVEb2Muc3VibWl0T3AocHJldmlvdXMub3AsIGNiKTtcbiAgICB0aGlzLl91cGRhdGVDb2xsZWN0aW9uRGF0YSgpO1xuICAgIHJldHVybiBieU51bWJlcjtcbiAgfVxuICBpZiAocHJldmlvdXMgPT0gbnVsbCkge1xuICAgIHZhciBsYXN0U2VnbWVudCA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgIHZhciBvcCA9IChpc0FycmF5SW5kZXgobGFzdFNlZ21lbnQpKSA/XG4gICAgICBbbmV3IExpc3RJbnNlcnRPcChzZWdtZW50cy5zbGljZSgwLCAtMSksIGxhc3RTZWdtZW50LCBieU51bWJlcildIDpcbiAgICAgIFtuZXcgT2JqZWN0SW5zZXJ0T3Aoc2VnbWVudHMsIGJ5TnVtYmVyKV07XG4gICAgdGhpcy5zaGFyZURvYy5zdWJtaXRPcChvcCwgY2IpO1xuICAgIHRoaXMuX3VwZGF0ZUNvbGxlY3Rpb25EYXRhKCk7XG4gICAgcmV0dXJuIGJ5TnVtYmVyO1xuICB9XG4gIHZhciBvcCA9IFtuZXcgSW5jcmVtZW50T3Aoc2VnbWVudHMsIGJ5TnVtYmVyKV07XG4gIHRoaXMuc2hhcmVEb2Muc3VibWl0T3Aob3AsIGNiKTtcbiAgdGhpcy5fdXBkYXRlQ29sbGVjdGlvbkRhdGEoKTtcbiAgcmV0dXJuIHByZXZpb3VzICsgYnlOdW1iZXI7XG59O1xuXG5SZW1vdGVEb2MucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihzZWdtZW50cywgdmFsdWUsIGNiKSB7XG4gIHZhciBzaGFyZURvYyA9IHRoaXMuc2hhcmVEb2M7XG4gIGZ1bmN0aW9uIHB1c2goYXJyLCBmbkNiKSB7XG4gICAgdmFyIG9wID0gW25ldyBMaXN0SW5zZXJ0T3Aoc2VnbWVudHMsIGFyci5sZW5ndGgsIHZhbHVlKV07XG4gICAgc2hhcmVEb2Muc3VibWl0T3Aob3AsIGZuQ2IpO1xuICAgIHJldHVybiBhcnIubGVuZ3RoO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJheUFwcGx5KHNlZ21lbnRzLCBwdXNoLCBjYik7XG59O1xuXG5SZW1vdGVEb2MucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbihzZWdtZW50cywgdmFsdWUsIGNiKSB7XG4gIHZhciBzaGFyZURvYyA9IHRoaXMuc2hhcmVEb2M7XG4gIGZ1bmN0aW9uIHVuc2hpZnQoYXJyLCBmbkNiKSB7XG4gICAgdmFyIG9wID0gW25ldyBMaXN0SW5zZXJ0T3Aoc2VnbWVudHMsIDAsIHZhbHVlKV07XG4gICAgc2hhcmVEb2Muc3VibWl0T3Aob3AsIGZuQ2IpO1xuICAgIHJldHVybiBhcnIubGVuZ3RoO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJheUFwcGx5KHNlZ21lbnRzLCB1bnNoaWZ0LCBjYik7XG59O1xuXG5SZW1vdGVEb2MucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBpbmRleCwgdmFsdWVzLCBjYikge1xuICB2YXIgc2hhcmVEb2MgPSB0aGlzLnNoYXJlRG9jO1xuICBmdW5jdGlvbiBpbnNlcnQoYXJyLCBmbkNiKSB7XG4gICAgdmFyIG9wID0gY3JlYXRlSW5zZXJ0T3Aoc2VnbWVudHMsIGluZGV4LCB2YWx1ZXMpO1xuICAgIHNoYXJlRG9jLnN1Ym1pdE9wKG9wLCBmbkNiKTtcbiAgICByZXR1cm4gYXJyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyYXlBcHBseShzZWdtZW50cywgaW5zZXJ0LCBjYik7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVJbnNlcnRPcChzZWdtZW50cywgaW5kZXgsIHZhbHVlcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgIHJldHVybiBbbmV3IExpc3RJbnNlcnRPcChzZWdtZW50cywgaW5kZXgsIHZhbHVlcyldO1xuICB9XG4gIHZhciBvcCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgb3AucHVzaChuZXcgTGlzdEluc2VydE9wKHNlZ21lbnRzLCBpbmRleCsrLCB2YWx1ZXNbaV0pKTtcbiAgfVxuICByZXR1cm4gb3A7XG59XG5cblJlbW90ZURvYy5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oc2VnbWVudHMsIGNiKSB7XG4gIHZhciBzaGFyZURvYyA9IHRoaXMuc2hhcmVEb2M7XG4gIGZ1bmN0aW9uIHBvcChhcnIsIGZuQ2IpIHtcbiAgICB2YXIgaW5kZXggPSBhcnIubGVuZ3RoIC0gMTtcbiAgICB2YXIgdmFsdWUgPSBhcnJbaW5kZXhdO1xuICAgIHZhciBvcCA9IFtuZXcgTGlzdFJlbW92ZU9wKHNlZ21lbnRzLCBpbmRleCwgdmFsdWUpXTtcbiAgICBzaGFyZURvYy5zdWJtaXRPcChvcCwgZm5DYik7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJheUFwcGx5KHNlZ21lbnRzLCBwb3AsIGNiKTtcbn07XG5cblJlbW90ZURvYy5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbihzZWdtZW50cywgY2IpIHtcbiAgdmFyIHNoYXJlRG9jID0gdGhpcy5zaGFyZURvYztcbiAgZnVuY3Rpb24gc2hpZnQoYXJyLCBmbkNiKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyWzBdO1xuICAgIHZhciBvcCA9IFtuZXcgTGlzdFJlbW92ZU9wKHNlZ21lbnRzLCAwLCB2YWx1ZSldO1xuICAgIHNoYXJlRG9jLnN1Ym1pdE9wKG9wLCBmbkNiKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FycmF5QXBwbHkoc2VnbWVudHMsIHNoaWZ0LCBjYik7XG59O1xuXG5SZW1vdGVEb2MucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBpbmRleCwgaG93TWFueSwgY2IpIHtcbiAgdmFyIHNoYXJlRG9jID0gdGhpcy5zaGFyZURvYztcbiAgZnVuY3Rpb24gcmVtb3ZlKGFyciwgZm5DYikge1xuICAgIHZhciB2YWx1ZXMgPSBhcnIuc2xpY2UoaW5kZXgsIGluZGV4ICsgaG93TWFueSk7XG4gICAgdmFyIG9wID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgb3AucHVzaChuZXcgTGlzdFJlbW92ZU9wKHNlZ21lbnRzLCBpbmRleCwgdmFsdWVzW2ldKSk7XG4gICAgfVxuICAgIHNoYXJlRG9jLnN1Ym1pdE9wKG9wLCBmbkNiKTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJheUFwcGx5KHNlZ21lbnRzLCByZW1vdmUsIGNiKTtcbn07XG5cblJlbW90ZURvYy5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBmcm9tLCB0bywgaG93TWFueSwgY2IpIHtcbiAgdmFyIHNoYXJlRG9jID0gdGhpcy5zaGFyZURvYztcbiAgZnVuY3Rpb24gbW92ZShhcnIsIGZuQ2IpIHtcbiAgICAvLyBHZXQgdGhlIHJldHVybiB2YWx1ZVxuICAgIHZhciB2YWx1ZXMgPSBhcnIuc2xpY2UoZnJvbSwgZnJvbSArIGhvd01hbnkpO1xuXG4gICAgLy8gQnVpbGQgYW4gb3AgdGhhdCBtb3ZlcyBlYWNoIGl0ZW0gaW5kaXZpZHVhbGx5XG4gICAgdmFyIG9wID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3dNYW55OyBpKyspIHtcbiAgICAgIG9wLnB1c2gobmV3IExpc3RNb3ZlT3Aoc2VnbWVudHMsIChmcm9tIDwgdG8pID8gZnJvbSA6IGZyb20gKyBob3dNYW55IC0gMSwgKGZyb20gPCB0bykgPyB0byArIGhvd01hbnkgLSAxIDogdG8pKTtcbiAgICB9XG4gICAgc2hhcmVEb2Muc3VibWl0T3Aob3AsIGZuQ2IpO1xuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyYXlBcHBseShzZWdtZW50cywgbW92ZSwgY2IpO1xufTtcblxuUmVtb3RlRG9jLnByb3RvdHlwZS5zdHJpbmdJbnNlcnQgPSBmdW5jdGlvbihzZWdtZW50cywgaW5kZXgsIHZhbHVlLCBjYikge1xuICB2YXIgcHJldmlvdXMgPSB0aGlzLl9jcmVhdGVJbXBsaWVkKHNlZ21lbnRzKTtcbiAgaWYgKHByZXZpb3VzIGluc3RhbmNlb2YgSW1wbGllZE9wKSB7XG4gICAgdmFyIGxhc3RTZWdtZW50ID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgcHJldmlvdXMudmFsdWVbbGFzdFNlZ21lbnRdID0gdmFsdWU7XG4gICAgdGhpcy5zaGFyZURvYy5zdWJtaXRPcChwcmV2aW91cy5vcCwgY2IpO1xuICAgIHRoaXMuX3VwZGF0ZUNvbGxlY3Rpb25EYXRhKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwcmV2aW91cyA9PSBudWxsKSB7XG4gICAgdmFyIGxhc3RTZWdtZW50ID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgdmFyIG9wID0gKGlzQXJyYXlJbmRleChsYXN0U2VnbWVudCkpID9cbiAgICAgIFtuZXcgTGlzdEluc2VydE9wKHNlZ21lbnRzLnNsaWNlKDAsIC0xKSwgbGFzdFNlZ21lbnQsIHZhbHVlKV0gOlxuICAgICAgW25ldyBPYmplY3RJbnNlcnRPcChzZWdtZW50cywgdmFsdWUpXTtcbiAgICB0aGlzLnNoYXJlRG9jLnN1Ym1pdE9wKG9wLCBjYik7XG4gICAgdGhpcy5fdXBkYXRlQ29sbGVjdGlvbkRhdGEoKTtcbiAgICByZXR1cm4gcHJldmlvdXM7XG4gIH1cbiAgdmFyIG9wID0gW25ldyBTdHJpbmdJbnNlcnRPcChzZWdtZW50cywgaW5kZXgsIHZhbHVlKV07XG4gIHRoaXMuc2hhcmVEb2Muc3VibWl0T3Aob3AsIGNiKTtcbiAgdGhpcy5fdXBkYXRlQ29sbGVjdGlvbkRhdGEoKTtcbiAgcmV0dXJuIHByZXZpb3VzO1xufTtcblxuUmVtb3RlRG9jLnByb3RvdHlwZS5zdHJpbmdSZW1vdmUgPSBmdW5jdGlvbihzZWdtZW50cywgaW5kZXgsIGhvd01hbnksIGNiKSB7XG4gIHZhciBwcmV2aW91cyA9IHRoaXMuX2NyZWF0ZUltcGxpZWQoc2VnbWVudHMpO1xuICBpZiAocHJldmlvdXMgaW5zdGFuY2VvZiBJbXBsaWVkT3ApIHJldHVybjtcbiAgaWYgKHByZXZpb3VzID09IG51bGwpIHJldHVybiBwcmV2aW91cztcbiAgdmFyIHJlbW92ZWQgPSBwcmV2aW91cy5zbGljZShpbmRleCwgaW5kZXggKyBob3dNYW55KTtcbiAgdmFyIG9wID0gW25ldyBTdHJpbmdSZW1vdmVPcChzZWdtZW50cywgaW5kZXgsIHJlbW92ZWQpXTtcbiAgdGhpcy5zaGFyZURvYy5zdWJtaXRPcChvcCwgY2IpO1xuICB0aGlzLl91cGRhdGVDb2xsZWN0aW9uRGF0YSgpO1xuICByZXR1cm4gcHJldmlvdXM7XG59O1xuXG5SZW1vdGVEb2MucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHNlZ21lbnRzKSB7XG4gIHJldHVybiB1dGlsLmxvb2t1cChzZWdtZW50cywgdGhpcy5zaGFyZURvYy5zbmFwc2hvdCk7XG59O1xuXG5SZW1vdGVEb2MucHJvdG90eXBlLl9jcmVhdGVJbXBsaWVkID0gZnVuY3Rpb24oc2VnbWVudHMpIHtcbiAgaWYgKCF0aGlzLnNoYXJlRG9jLnR5cGUpIHtcbiAgICB0aGlzLnNoYXJlRG9jLmNyZWF0ZSgnanNvbjAnKTtcbiAgfVxuICB2YXIgcGFyZW50ID0gdGhpcy5zaGFyZURvYztcbiAgdmFyIGtleSA9ICdzbmFwc2hvdCc7XG4gIHZhciBub2RlID0gcGFyZW50W2tleV07XG4gIHZhciBpID0gMDtcbiAgdmFyIG5leHRLZXkgPSBzZWdtZW50c1tpKytdO1xuICB2YXIgb3AsIHZhbHVlO1xuICB3aGlsZSAobmV4dEtleSAhPSBudWxsKSB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICBpZiAob3ApIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZVtrZXldID0gaXNBcnJheUluZGV4KG5leHRLZXkpID8gW10gOiB7fTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gaXNBcnJheUluZGV4KG5leHRLZXkpID8gW10gOiB7fTtcbiAgICAgICAgb3AgPSAoQXJyYXkuaXNBcnJheShwYXJlbnQpKSA/XG4gICAgICAgICAgbmV3IExpc3RJbnNlcnRPcChzZWdtZW50cy5zbGljZSgwLCBpIC0gMiksIGtleSwgdmFsdWUpIDpcbiAgICAgICAgICBuZXcgT2JqZWN0SW5zZXJ0T3Aoc2VnbWVudHMuc2xpY2UoMCwgaSAtIDEpLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBub2RlID0gdmFsdWU7XG4gICAgfVxuICAgIHBhcmVudCA9IG5vZGU7XG4gICAga2V5ID0gbmV4dEtleTtcbiAgICBub2RlID0gcGFyZW50W2tleV07XG4gICAgbmV4dEtleSA9IHNlZ21lbnRzW2krK107XG4gIH1cbiAgaWYgKG9wKSByZXR1cm4gbmV3IEltcGxpZWRPcChvcCwgdmFsdWUpO1xuICByZXR1cm4gbm9kZTtcbn07XG5cbmZ1bmN0aW9uIEltcGxpZWRPcChvcCwgdmFsdWUpIHtcbiAgdGhpcy5vcCA9IG9wO1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG59XG5cblJlbW90ZURvYy5wcm90b3R5cGUuX2FycmF5QXBwbHkgPSBmdW5jdGlvbihzZWdtZW50cywgZm4sIGNiKSB7XG4gIHZhciBhcnIgPSB0aGlzLl9jcmVhdGVJbXBsaWVkKHNlZ21lbnRzKTtcbiAgaWYgKGFyciBpbnN0YW5jZW9mIEltcGxpZWRPcCkge1xuICAgIHRoaXMuc2hhcmVEb2Muc3VibWl0T3AoYXJyLm9wKTtcbiAgICBhcnIgPSB0aGlzLmdldChzZWdtZW50cyk7XG4gIH0gZWxzZSBpZiAoYXJyID09IG51bGwpIHtcbiAgICB2YXIgbGFzdFNlZ21lbnQgPSBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICB2YXIgb3AgPSAoaXNBcnJheUluZGV4KGxhc3RTZWdtZW50KSkgP1xuICAgICAgW25ldyBMaXN0SW5zZXJ0T3Aoc2VnbWVudHMuc2xpY2UoMCwgLTEpLCBsYXN0U2VnbWVudCwgW10pXSA6XG4gICAgICBbbmV3IE9iamVjdEluc2VydE9wKHNlZ21lbnRzLCBbXSldO1xuICAgIHRoaXMuc2hhcmVEb2Muc3VibWl0T3Aob3ApO1xuICAgIGFyciA9IHRoaXMuZ2V0KHNlZ21lbnRzKTtcbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSB0aGlzLl9lcnJvck1lc3NhZ2UoZm4ubmFtZSArICcgb24gbm9uLWFycmF5Jywgc2VnbWVudHMsIGFycik7XG4gICAgdmFyIGVyciA9IG5ldyBUeXBlRXJyb3IobWVzc2FnZSk7XG4gICAgcmV0dXJuIGNiKGVycik7XG4gIH1cbiAgdmFyIG91dCA9IGZuKGFyciwgY2IpO1xuICB0aGlzLl91cGRhdGVDb2xsZWN0aW9uRGF0YSgpO1xuICByZXR1cm4gb3V0O1xufTtcblxuUmVtb3RlRG9jLnByb3RvdHlwZS5fb25PcCA9IGZ1bmN0aW9uKG9wKSB7XG4gIHZhciBpdGVtID0gb3BbMF07XG4gIHZhciBzZWdtZW50cyA9IFt0aGlzLmNvbGxlY3Rpb25OYW1lLCB0aGlzLmlkXS5jb25jYXQoaXRlbS5wKTtcbiAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcblxuICAvLyBPYmplY3RSZXBsYWNlT3AsIE9iamVjdEluc2VydE9wLCBvciBPYmplY3REZWxldGVPcFxuICBpZiAoZGVmaW5lZChpdGVtLm9pKSB8fCBkZWZpbmVkKGl0ZW0ub2QpKSB7XG4gICAgdmFyIHZhbHVlID0gaXRlbS5vaTtcbiAgICB2YXIgcHJldmlvdXMgPSBpdGVtLm9kO1xuICAgIG1vZGVsLmVtaXQoJ2NoYW5nZScsIHNlZ21lbnRzLCBbdmFsdWUsIHByZXZpb3VzLCBtb2RlbC5fcGFzc10pO1xuXG4gIC8vIExpc3RSZXBsYWNlT3BcbiAgfSBlbHNlIGlmIChkZWZpbmVkKGl0ZW0ubGkpICYmIGRlZmluZWQoaXRlbS5sZCkpIHtcbiAgICB2YXIgdmFsdWUgPSBpdGVtLmxpO1xuICAgIHZhciBwcmV2aW91cyA9IGl0ZW0ubGQ7XG4gICAgbW9kZWwuZW1pdCgnY2hhbmdlJywgc2VnbWVudHMsIFt2YWx1ZSwgcHJldmlvdXMsIG1vZGVsLl9wYXNzXSk7XG5cbiAgLy8gTGlzdEluc2VydE9wXG4gIH0gZWxzZSBpZiAoZGVmaW5lZChpdGVtLmxpKSkge1xuICAgIHZhciBpbmRleCA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgIHZhciB2YWx1ZXMgPSBbaXRlbS5saV07XG4gICAgbW9kZWwuZW1pdCgnaW5zZXJ0Jywgc2VnbWVudHMuc2xpY2UoMCwgLTEpLCBbaW5kZXgsIHZhbHVlcywgbW9kZWwuX3Bhc3NdKTtcblxuICAvLyBMaXN0UmVtb3ZlT3BcbiAgfSBlbHNlIGlmIChkZWZpbmVkKGl0ZW0ubGQpKSB7XG4gICAgdmFyIGluZGV4ID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgdmFyIHJlbW92ZWQgPSBbaXRlbS5sZF07XG4gICAgbW9kZWwuZW1pdCgncmVtb3ZlJywgc2VnbWVudHMuc2xpY2UoMCwgLTEpLCBbaW5kZXgsIHJlbW92ZWQsIG1vZGVsLl9wYXNzXSk7XG5cbiAgLy8gTGlzdE1vdmVPcFxuICB9IGVsc2UgaWYgKGRlZmluZWQoaXRlbS5sbSkpIHtcbiAgICB2YXIgZnJvbSA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgIHZhciB0byA9IGl0ZW0ubG0gLSAxO1xuICAgIHZhciBob3dNYW55ID0gMTtcbiAgICBtb2RlbC5lbWl0KCdtb3ZlJywgc2VnbWVudHMuc2xpY2UoMCwgLTEpLCBbZnJvbSwgdG8sIGhvd01hbnksIG1vZGVsLl9wYXNzXSk7XG5cbiAgLy8gU3RyaW5nSW5zZXJ0T3BcbiAgfSBlbHNlIGlmIChkZWZpbmVkKGl0ZW0uc2kpKSB7XG4gICAgdmFyIGluZGV4ID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgdmFyIHRleHQgPSBpdGVtLnNpO1xuICAgIHNlZ21lbnRzID0gc2VnbWVudHMuc2xpY2UoMCwgLTEpO1xuICAgIG1vZGVsLmVtaXQoJ3N0cmluZ0luc2VydCcsIHNlZ21lbnRzLCBbaW5kZXgsIHRleHQsIG1vZGVsLl9wYXNzXSk7XG4gICAgdmFyIHZhbHVlID0gbW9kZWwuX2dldChzZWdtZW50cyk7XG4gICAgdmFyIHByZXZpb3VzID0gdmFsdWUuc2xpY2UoMCwgaW5kZXgpICsgdmFsdWUuc2xpY2UoaW5kZXggKyB0ZXh0Lmxlbmd0aCk7XG4gICAgbW9kZWwuZW1pdCgnY2hhbmdlJywgc2VnbWVudHMsIFt2YWx1ZSwgcHJldmlvdXMsIHRoaXMuX3Bhc3NTdHJpbmdJbnNlcnRdKTtcblxuICAvLyBTdHJpbmdSZW1vdmVPcFxuICB9IGVsc2UgaWYgKGRlZmluZWQoaXRlbS5zZCkpIHtcbiAgICB2YXIgaW5kZXggPSBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICB2YXIgdGV4dCA9IGl0ZW0uc2Q7XG4gICAgdmFyIGhvd01hbnkgPSB0ZXh0Lmxlbmd0aDtcbiAgICBzZWdtZW50cyA9IHNlZ21lbnRzLnNsaWNlKDAsIC0xKTtcbiAgICBtb2RlbC5lbWl0KCdzdHJpbmdSZW1vdmUnLCBzZWdtZW50cywgW2luZGV4LCBob3dNYW55LCBtb2RlbC5fcGFzc10pO1xuICAgIHZhciB2YWx1ZSA9IG1vZGVsLl9nZXQoc2VnbWVudHMpO1xuICAgIHZhciBwcmV2aW91cyA9IHZhbHVlLnNsaWNlKDAsIGluZGV4KSArIHRleHQgKyB2YWx1ZS5zbGljZShpbmRleCk7XG4gICAgbW9kZWwuZW1pdCgnY2hhbmdlJywgc2VnbWVudHMsIFt2YWx1ZSwgcHJldmlvdXMsIHRoaXMuX3Bhc3NTdHJpbmdSZW1vdmVdKTtcblxuICAvLyBJbmNyZW1lbnRPcFxuICB9IGVsc2UgaWYgKGRlZmluZWQoaXRlbS5uYSkpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldChpdGVtLnApO1xuICAgIHZhciBwcmV2aW91cyA9IHZhbHVlIC0gaXRlbS5uYTtcbiAgICBtb2RlbC5lbWl0KCdjaGFuZ2UnLCBzZWdtZW50cywgW3ZhbHVlLCBwcmV2aW91cywgbW9kZWwuX3Bhc3NdKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gT2JqZWN0UmVwbGFjZU9wKHNlZ21lbnRzLCBiZWZvcmUsIGFmdGVyKSB7XG4gIHRoaXMucCA9IGNhc3RTZWdtZW50cyhzZWdtZW50cyk7XG4gIHRoaXMub2QgPSBiZWZvcmU7XG4gIHRoaXMub2kgPSAoYWZ0ZXIgPT09IHZvaWQgMCkgPyBudWxsIDogYWZ0ZXI7XG59XG5mdW5jdGlvbiBPYmplY3RJbnNlcnRPcChzZWdtZW50cywgdmFsdWUpIHtcbiAgdGhpcy5wID0gY2FzdFNlZ21lbnRzKHNlZ21lbnRzKTtcbiAgdGhpcy5vaSA9ICh2YWx1ZSA9PT0gdm9pZCAwKSA/IG51bGwgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIE9iamVjdERlbGV0ZU9wKHNlZ21lbnRzLCB2YWx1ZSkge1xuICB0aGlzLnAgPSBjYXN0U2VnbWVudHMoc2VnbWVudHMpO1xuICB0aGlzLm9kID0gKHZhbHVlID09PSB2b2lkIDApID8gbnVsbCA6IHZhbHVlO1xufVxuZnVuY3Rpb24gTGlzdFJlcGxhY2VPcChzZWdtZW50cywgaW5kZXgsIGJlZm9yZSwgYWZ0ZXIpIHtcbiAgdGhpcy5wID0gY2FzdFNlZ21lbnRzKHNlZ21lbnRzLmNvbmNhdChpbmRleCkpO1xuICB0aGlzLmxkID0gYmVmb3JlO1xuICB0aGlzLmxpID0gKGFmdGVyID09PSB2b2lkIDApID8gbnVsbCA6IGFmdGVyO1xufVxuZnVuY3Rpb24gTGlzdEluc2VydE9wKHNlZ21lbnRzLCBpbmRleCwgdmFsdWUpIHtcbiAgdGhpcy5wID0gY2FzdFNlZ21lbnRzKHNlZ21lbnRzLmNvbmNhdChpbmRleCkpO1xuICB0aGlzLmxpID0gKHZhbHVlID09PSB2b2lkIDApID8gbnVsbCA6IHZhbHVlO1xufVxuZnVuY3Rpb24gTGlzdFJlbW92ZU9wKHNlZ21lbnRzLCBpbmRleCwgdmFsdWUpIHtcbiAgdGhpcy5wID0gY2FzdFNlZ21lbnRzKHNlZ21lbnRzLmNvbmNhdChpbmRleCkpO1xuICB0aGlzLmxkID0gKHZhbHVlID09PSB2b2lkIDApID8gbnVsbCA6IHZhbHVlO1xufVxuZnVuY3Rpb24gTGlzdE1vdmVPcChzZWdtZW50cywgZnJvbSwgdG8pIHtcbiAgdGhpcy5wID0gY2FzdFNlZ21lbnRzKHNlZ21lbnRzLmNvbmNhdChmcm9tKSk7XG4gIHRoaXMubG0gPSB0bztcbn1cbmZ1bmN0aW9uIFN0cmluZ0luc2VydE9wKHNlZ21lbnRzLCBpbmRleCwgdmFsdWUpIHtcbiAgdGhpcy5wID0gY2FzdFNlZ21lbnRzKHNlZ21lbnRzLmNvbmNhdChpbmRleCkpO1xuICB0aGlzLnNpID0gdmFsdWU7XG59XG5mdW5jdGlvbiBTdHJpbmdSZW1vdmVPcChzZWdtZW50cywgaW5kZXgsIHZhbHVlKSB7XG4gIHRoaXMucCA9IGNhc3RTZWdtZW50cyhzZWdtZW50cy5jb25jYXQoaW5kZXgpKTtcbiAgdGhpcy5zZCA9IHZhbHVlO1xufVxuZnVuY3Rpb24gSW5jcmVtZW50T3Aoc2VnbWVudHMsIGJ5TnVtYmVyKSB7XG4gIHRoaXMucCA9IGNhc3RTZWdtZW50cyhzZWdtZW50cyk7XG4gIHRoaXMubmEgPSBieU51bWJlcjtcbn1cblxuZnVuY3Rpb24gZGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gY2FzdFNlZ21lbnRzKHNlZ21lbnRzKSB7XG4gIC8vIENhc3QgbnVtYmVyIHBhdGggc2VnbWVudHMgZnJvbSBzdHJpbmdzIHRvIG51bWJlcnNcbiAgZm9yICh2YXIgaSA9IHNlZ21lbnRzLmxlbmd0aDsgaS0tOykge1xuICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgaWYgKHR5cGVvZiBzZWdtZW50ID09PSAnc3RyaW5nJyAmJiBpc0FycmF5SW5kZXgoc2VnbWVudCkpIHtcbiAgICAgIHNlZ21lbnRzW2ldID0gK3NlZ21lbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZWdtZW50cztcbn1cblxuZnVuY3Rpb24gaXNBcnJheUluZGV4KHNlZ21lbnQpIHtcbiAgcmV0dXJuICgvXlswLTldKyQvKS50ZXN0KHNlZ21lbnQpO1xufVxuIiwiKGZ1bmN0aW9uKCl7XG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuLyoqXG4gKiB0b1N0cmluZyByZWYuXG4gKi9cblxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbi8qKlxuICogUmV0dXJuIEVUYWcgZm9yIGBib2R5YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xCdWZmZXJ9IGJvZHlcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZXRhZyA9IGZ1bmN0aW9uKGJvZHkpe1xuICByZXR1cm4gJ1wiJyArIGNyYzMyLnNpZ25lZChib2R5KSArICdcIic7XG59O1xuXG4vKipcbiAqIE1ha2UgYGxvY2FscygpYCBib3VuZCB0byB0aGUgZ2l2ZW4gYG9iamAuXG4gKlxuICogVGhpcyBpcyB1c2VkIGZvciBgYXBwLmxvY2Fsc2AgYW5kIGByZXMubG9jYWxzYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMubG9jYWxzID0gZnVuY3Rpb24ob2JqKXtcbiAgZnVuY3Rpb24gbG9jYWxzKG9iail7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgbG9jYWxzW2tleV0gPSBvYmpba2V5XTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIHJldHVybiBsb2NhbHM7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGBwYXRoYCBsb29rcyBhYnNvbHV0ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpe1xuICBpZiAoJy8nID09IHBhdGhbMF0pIHJldHVybiB0cnVlO1xuICBpZiAoJzonID09IHBhdGhbMV0gJiYgJ1xcXFwnID09IHBhdGhbMl0pIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBGbGF0dGVuIHRoZSBnaXZlbiBgYXJyYC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5mbGF0dGVuID0gZnVuY3Rpb24oYXJyLCByZXQpe1xuICB2YXIgcmV0ID0gcmV0IHx8IFtdXG4gICAgLCBsZW4gPSBhcnIubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyW2ldKSkge1xuICAgICAgZXhwb3J0cy5mbGF0dGVuKGFycltpXSwgcmV0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0LnB1c2goYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBgdHlwZWAsIGZvciBleGFtcGxlIFwiaHRtbFwiIGJlY29tZXMgXCJ0ZXh0L2h0bWxcIi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5ub3JtYWxpemVUeXBlID0gZnVuY3Rpb24odHlwZSl7XG4gIHJldHVybiB+dHlwZS5pbmRleE9mKCcvJylcbiAgICA/IGFjY2VwdFBhcmFtcyh0eXBlKVxuICAgIDogeyB2YWx1ZTogbWltZS5sb29rdXAodHlwZSksIHBhcmFtczoge30gfTtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGB0eXBlc2AsIGZvciBleGFtcGxlIFwiaHRtbFwiIGJlY29tZXMgXCJ0ZXh0L2h0bWxcIi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB0eXBlc1xuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLm5vcm1hbGl6ZVR5cGVzID0gZnVuY3Rpb24odHlwZXMpe1xuICB2YXIgcmV0ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7ICsraSkge1xuICAgIHJldC5wdXNoKGV4cG9ydHMubm9ybWFsaXplVHlwZSh0eXBlc1tpXSkpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBhY2NlcHRhYmxlIHR5cGUgaW4gYHR5cGVzYCwgaWYgYW55LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmFjY2VwdHNBcnJheSA9IGZ1bmN0aW9uKHR5cGVzLCBzdHIpe1xuICAvLyBhY2NlcHQgYW55dGhpbmcgd2hlbiBBY2NlcHQgaXMgbm90IHByZXNlbnRcbiAgaWYgKCFzdHIpIHJldHVybiB0eXBlc1swXTtcblxuICAvLyBwYXJzZVxuICB2YXIgYWNjZXB0ZWQgPSBleHBvcnRzLnBhcnNlQWNjZXB0KHN0cilcbiAgICAsIG5vcm1hbGl6ZWQgPSBleHBvcnRzLm5vcm1hbGl6ZVR5cGVzKHR5cGVzKVxuICAgICwgbGVuID0gYWNjZXB0ZWQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IHR5cGVzLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuICAgICAgaWYgKGV4cG9ydHMuYWNjZXB0KG5vcm1hbGl6ZWRbal0sIGFjY2VwdGVkW2ldKSkge1xuICAgICAgICByZXR1cm4gdHlwZXNbal07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGB0eXBlKHMpYCBhcmUgYWNjZXB0YWJsZSBiYXNlZCBvblxuICogdGhlIGdpdmVuIGBzdHJgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSB0eXBlKHMpXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtCb29sZWFufFN0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuYWNjZXB0cyA9IGZ1bmN0aW9uKHR5cGUsIHN0cil7XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdHlwZSkgdHlwZSA9IHR5cGUuc3BsaXQoLyAqLCAqLyk7XG4gIHJldHVybiBleHBvcnRzLmFjY2VwdHNBcnJheSh0eXBlLCBzdHIpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgdHlwZWAgYXJyYXkgaXMgYWNjZXB0YWJsZSBmb3IgYG90aGVyYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZVxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5hY2NlcHQgPSBmdW5jdGlvbih0eXBlLCBvdGhlcil7XG4gIHZhciB0ID0gdHlwZS52YWx1ZS5zcGxpdCgnLycpO1xuICByZXR1cm4gKHRbMF0gPT0gb3RoZXIudHlwZSB8fCAnKicgPT0gb3RoZXIudHlwZSlcbiAgICAmJiAodFsxXSA9PSBvdGhlci5zdWJ0eXBlIHx8ICcqJyA9PSBvdGhlci5zdWJ0eXBlKVxuICAgICYmIHBhcmFtc0VxdWFsKHR5cGUucGFyYW1zLCBvdGhlci5wYXJhbXMpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhY2NlcHQgcGFyYW1zIGFyZSBlcXVhbC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHBhcmFtIHtPYmplY3R9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJhbXNFcXVhbChhLCBiKXtcbiAgcmV0dXJuICFPYmplY3Qua2V5cyhhKS5zb21lKGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gYVtrXSAhPSBiW2tdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBQYXJzZSBhY2NlcHQgYHN0cmAsIHJldHVybmluZ1xuICogYW4gYXJyYXkgb2JqZWN0cyBjb250YWluaW5nXG4gKiBgLnR5cGVgIGFuZCBgLnN1YnR5cGVgIGFsb25nXG4gKiB3aXRoIHRoZSB2YWx1ZXMgcHJvdmlkZWQgYnlcbiAqIGBwYXJzZVF1YWxpdHkoKWAuXG4gKlxuICogQHBhcmFtIHtUeXBlfSBuYW1lXG4gKiBAcmV0dXJuIHtUeXBlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5wYXJzZUFjY2VwdCA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBleHBvcnRzXG4gICAgLnBhcnNlUGFyYW1zKHN0cilcbiAgICAubWFwKGZ1bmN0aW9uKG9iail7XG4gICAgICB2YXIgcGFydHMgPSBvYmoudmFsdWUuc3BsaXQoJy8nKTtcbiAgICAgIG9iai50eXBlID0gcGFydHNbMF07XG4gICAgICBvYmouc3VidHlwZSA9IHBhcnRzWzFdO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogUGFyc2UgcXVhbGl0eSBgc3RyYCwgcmV0dXJuaW5nIGFuXG4gKiBhcnJheSBvZiBvYmplY3RzIHdpdGggYC52YWx1ZWAsXG4gKiBgLnF1YWxpdHlgIGFuZCBvcHRpb25hbCBgLnBhcmFtc2BcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMucGFyc2VQYXJhbXMgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gc3RyXG4gICAgLnNwbGl0KC8gKiwgKi8pXG4gICAgLm1hcChhY2NlcHRQYXJhbXMpXG4gICAgLmZpbHRlcihmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuIG9iai5xdWFsaXR5O1xuICAgIH0pXG4gICAgLnNvcnQoZnVuY3Rpb24oYSwgYil7XG4gICAgICBpZiAoYS5xdWFsaXR5ID09PSBiLnF1YWxpdHkpIHtcbiAgICAgICAgcmV0dXJuIGEub3JpZ2luYWxJbmRleCAtIGIub3JpZ2luYWxJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBiLnF1YWxpdHkgLSBhLnF1YWxpdHk7XG4gICAgICB9XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFBhcnNlIGFjY2VwdCBwYXJhbXMgYHN0cmAgcmV0dXJuaW5nIGFuXG4gKiBvYmplY3Qgd2l0aCBgLnZhbHVlYCwgYC5xdWFsaXR5YCBhbmQgYC5wYXJhbXNgLlxuICogYWxzbyBpbmNsdWRlcyBgLm9yaWdpbmFsSW5kZXhgIGZvciBzdGFibGUgc29ydGluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGFjY2VwdFBhcmFtcyhzdHIsIGluZGV4KSB7XG4gIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgvICo7ICovKTtcbiAgdmFyIHJldCA9IHsgdmFsdWU6IHBhcnRzWzBdLCBxdWFsaXR5OiAxLCBwYXJhbXM6IHt9LCBvcmlnaW5hbEluZGV4OiBpbmRleCB9O1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcG1zID0gcGFydHNbaV0uc3BsaXQoLyAqPSAqLyk7XG4gICAgaWYgKCdxJyA9PSBwbXNbMF0pIHtcbiAgICAgIHJldC5xdWFsaXR5ID0gcGFyc2VGbG9hdChwbXNbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXQucGFyYW1zW3Btc1swXV0gPSBwbXNbMV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBFc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIGluIHRoZSBnaXZlbiBzdHJpbmcgb2YgaHRtbC5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGh0bWxcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZXNjYXBlID0gZnVuY3Rpb24oaHRtbCkge1xuICByZXR1cm4gU3RyaW5nKGh0bWwpXG4gICAgLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgZ2l2ZW4gcGF0aCBzdHJpbmcsXG4gKiByZXR1cm5pbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQW4gZW1wdHkgYXJyYXkgc2hvdWxkIGJlIHBhc3NlZCxcbiAqIHdoaWNoIHdpbGwgY29udGFpbiB0aGUgcGxhY2Vob2xkZXJcbiAqIGtleSBuYW1lcy4gRm9yIGV4YW1wbGUgXCIvdXNlci86aWRcIiB3aWxsXG4gKiB0aGVuIGNvbnRhaW4gW1wiaWRcIl0uXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfFJlZ0V4cHxBcnJheX0gcGF0aFxuICogQHBhcmFtICB7QXJyYXl9IGtleXNcbiAqIEBwYXJhbSAge0Jvb2xlYW59IHNlbnNpdGl2ZVxuICogQHBhcmFtICB7Qm9vbGVhbn0gc3RyaWN0XG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnBhdGhSZWdleHAgPSBmdW5jdGlvbihwYXRoLCBrZXlzLCBzZW5zaXRpdmUsIHN0cmljdCkge1xuICBpZiAodG9TdHJpbmcuY2FsbChwYXRoKSA9PSAnW29iamVjdCBSZWdFeHBdJykgcmV0dXJuIHBhdGg7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSBwYXRoID0gJygnICsgcGF0aC5qb2luKCd8JykgKyAnKSc7XG4gIHBhdGggPSBwYXRoXG4gICAgLmNvbmNhdChzdHJpY3QgPyAnJyA6ICcvPycpXG4gICAgLnJlcGxhY2UoL1xcL1xcKC9nLCAnKD86LycpXG4gICAgLnJlcGxhY2UoLyhcXC8pPyhcXC4pPzooXFx3KykoPzooXFwoLio/XFwpKSk/KFxcPyk/KFxcKik/L2csIGZ1bmN0aW9uKF8sIHNsYXNoLCBmb3JtYXQsIGtleSwgY2FwdHVyZSwgb3B0aW9uYWwsIHN0YXIpe1xuICAgICAga2V5cy5wdXNoKHsgbmFtZToga2V5LCBvcHRpb25hbDogISEgb3B0aW9uYWwgfSk7XG4gICAgICBzbGFzaCA9IHNsYXNoIHx8ICcnO1xuICAgICAgcmV0dXJuICcnXG4gICAgICAgICsgKG9wdGlvbmFsID8gJycgOiBzbGFzaClcbiAgICAgICAgKyAnKD86J1xuICAgICAgICArIChvcHRpb25hbCA/IHNsYXNoIDogJycpXG4gICAgICAgICsgKGZvcm1hdCB8fCAnJykgKyAoY2FwdHVyZSB8fCAoZm9ybWF0ICYmICcoW14vLl0rPyknIHx8ICcoW14vXSs/KScpKSArICcpJ1xuICAgICAgICArIChvcHRpb25hbCB8fCAnJylcbiAgICAgICAgKyAoc3RhciA/ICcoLyopPycgOiAnJyk7XG4gICAgfSlcbiAgICAucmVwbGFjZSgvKFtcXC8uXSkvZywgJ1xcXFwkMScpXG4gICAgLnJlcGxhY2UoL1xcKi9nLCAnKC4qKScpO1xuICByZXR1cm4gbmV3IFJlZ0V4cCgnXicgKyBwYXRoICsgJyQnLCBzZW5zaXRpdmUgPyAnJyA6ICdpJyk7XG59XG5cbn0pKCkiLCJ2YXIgc2hhcmUgPSByZXF1aXJlKCdzaGFyZS9saWIvY2xpZW50Jyk7XG52YXIgQ2hhbm5lbCA9IHJlcXVpcmUoJy4uL0NoYW5uZWwnKTtcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcbnZhciBMb2NhbERvYyA9IHJlcXVpcmUoJy4vTG9jYWxEb2MnKTtcbnZhciBSZW1vdGVEb2MgPSByZXF1aXJlKCcuL1JlbW90ZURvYycpO1xuXG5Nb2RlbC5wcm90b3R5cGUuX2NyZWF0ZUNvbm5lY3Rpb24gPSBmdW5jdGlvbihidW5kbGUpIHtcbiAgLy8gTW9kZWw6Ol9jcmVhdGVTb2NrZXQgc2hvdWxkIGJlIGRlZmluZWQgYnkgdGhlIHNvY2tldCBwbHVnaW5cbiAgdGhpcy5yb290LnNvY2tldCA9IHRoaXMuX2NyZWF0ZVNvY2tldChidW5kbGUpO1xuXG4gIC8vIFRoZSBTaGFyZSBjb25uZWN0aW9uIHdpbGwgYmluZCB0byB0aGUgc29ja2V0IGJ5IGRlZmluaW5nIHRoZSBvbm9wZW4sXG4gIC8vIG9ubWVzc2FnZSwgZXRjLiBtZXRob2RzXG4gIHZhciBzaGFyZUNvbm5lY3Rpb24gPSB0aGlzLnJvb3Quc2hhcmVDb25uZWN0aW9uID0gbmV3IHNoYXJlLkNvbm5lY3Rpb24odGhpcy5yb290LnNvY2tldCk7XG4gIHZhciBzZWdtZW50cyA9IFsnJGNvbm5lY3Rpb24nLCAnc3RhdGUnXTtcbiAgdmFyIHN0YXRlcyA9IFsnY29ubmVjdGluZycsICdjb25uZWN0ZWQnLCAnZGlzY29ubmVjdGVkJywgJ3N0b3BwZWQnXTtcbiAgdmFyIG1vZGVsID0gdGhpcztcbiAgc3RhdGVzLmZvckVhY2goZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBzaGFyZUNvbm5lY3Rpb24ub24oc3RhdGUsIGZ1bmN0aW9uKCkge1xuICAgICAgbW9kZWwuX3NldChzZWdtZW50cywgc3RhdGUpO1xuICAgIH0pO1xuICB9KTtcbiAgdGhpcy5fc2V0KHNlZ21lbnRzLCAnY29ubmVjdGVkJyk7XG5cbiAgLy8gV3JhcCB0aGUgc29ja2V0IG1ldGhvZHMgb24gdG9wIG9mIFNoYXJlJ3MgbWV0aG9kc1xuICB0aGlzLl9jcmVhdGVDaGFubmVsKCk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJvb3Quc29ja2V0Lm9wZW4oKTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJvb3Quc29ja2V0LmNsb3NlKCk7XG59O1xuTW9kZWwucHJvdG90eXBlLnJlY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgdGhpcy5jb25uZWN0KCk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuX2NyZWF0ZUNoYW5uZWwgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yb290LmNoYW5uZWwgPSBuZXcgQ2hhbm5lbCh0aGlzLnJvb3Quc29ja2V0KTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5fZ2V0T3JDcmVhdGVTaGFyZURvYyA9IGZ1bmN0aW9uKGNvbGxlY3Rpb25OYW1lLCBpZCwgZGF0YSkge1xuICB2YXIgc2hhcmVEb2MgPSB0aGlzLnJvb3Quc2hhcmVDb25uZWN0aW9uLmdldChjb2xsZWN0aW9uTmFtZSwgaWQsIGRhdGEpO1xuICBzaGFyZURvYy5pbmNyZW1lbnRhbCA9IHRydWU7XG4gIHJldHVybiBzaGFyZURvYztcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5fZ2V0RG9jQ29uc3RydWN0b3IgPSBmdW5jdGlvbihuYW1lKSB7XG4gIC8vIFdoZXRoZXIgdGhlIGNvbGxlY3Rpb24gaXMgbG9jYWwgb3IgcmVtb3RlIGlzIGRldGVybWluZWQgYnkgaXRzIG5hbWUuXG4gIC8vIENvbGxlY3Rpb25zIHN0YXJ0aW5nIHdpdGggYW4gdW5kZXJzY29yZSAoJ18nKSBhcmUgZm9yIHVzZXItZGVmaW5lZCBsb2NhbFxuICAvLyBjb2xsZWN0aW9ucywgdGhvc2Ugc3RhcnRpbmcgd2l0aCBhIGRvbGxhciBzaWduICgnJCcnKSBhcmUgZm9yXG4gIC8vIGZyYW1ld29yay1kZWZpbmVkIGxvY2FsIGNvbGxlY3Rpb25zLCBhbmQgYWxsIG90aGVycyBhcmUgcmVtb3RlLlxuICB2YXIgZmlyc3RDaGFyY3RlciA9IG5hbWUuY2hhckF0KDApO1xuICB2YXIgaXNMb2NhbCA9IChmaXJzdENoYXJjdGVyID09PSAnXycgfHwgZmlyc3RDaGFyY3RlciA9PT0gJyQnKTtcbiAgcmV0dXJuIChpc0xvY2FsKSA/IExvY2FsRG9jIDogUmVtb3RlRG9jO1xufTtcbiIsInZhciB1dWlkID0gcmVxdWlyZSgnbm9kZS11dWlkJyk7XG5cbk1vZGVsLklOSVRTID0gW107XG5cbm1vZHVsZS5leHBvcnRzID0gTW9kZWw7XG5cbmZ1bmN0aW9uIE1vZGVsKG9wdGlvbnMpIHtcbiAgdGhpcy5yb290ID0gdGhpcztcblxuICB2YXIgaW5pdHMgPSBNb2RlbC5JTklUUztcbiAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0cy5sZW5ndGg7IGkrKykge1xuICAgIGluaXRzW2ldKHRoaXMsIG9wdGlvbnMpO1xuICB9XG59XG5cbk1vZGVsLnByb3RvdHlwZS5pZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdXVpZC52NCgpO1xufTtcblxuTW9kZWwucHJvdG90eXBlLl9jaGlsZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IENoaWxkTW9kZWwodGhpcyk7XG59O1xuXG5mdW5jdGlvbiBDaGlsZE1vZGVsKG1vZGVsKSB7XG4gIC8vIFNoYXJlZCBwcm9wZXJ0aWVzIHNob3VsZCBiZSBhY2Nlc3NlZCB2aWEgdGhlIHJvb3QuIFRoaXMgbWFrZXMgaW5oZXJpdGFuY2VcbiAgLy8gY2hlYXAgYW5kIGVhc2lseSBleHRlbnNpYmxlXG4gIHRoaXMucm9vdCA9IG1vZGVsLnJvb3Q7XG5cbiAgLy8gRXZlbnRFbWl0dGVyIG1ldGhvZHMgYWNjZXNzIHRoZXNlIHByb3BlcnRpZXMgZGlyZWN0bHksIHNvIHRoZXkgbXVzdCBiZVxuICAvLyBpbmhlcml0ZWQgbWFudWFsbHkgaW5zdGVhZCBvZiB2aWEgdGhlIHJvb3RcbiAgdGhpcy5fZXZlbnRzID0gbW9kZWwuX2V2ZW50cztcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbW9kZWwuX21heExpc3RlbmVycztcblxuICAvLyBQcm9wZXJ0aWVzIHNwZWNpZmljIHRvIGEgY2hpbGQgaW5zdGFuY2VcbiAgdGhpcy5fY29udGV4dCA9IG1vZGVsLl9jb250ZXh0O1xuICB0aGlzLl9hdCA9IG1vZGVsLl9hdDtcbiAgdGhpcy5fcGFzcyA9IG1vZGVsLl9wYXNzO1xuICB0aGlzLl9zaWxlbnQgPSBtb2RlbC5fc2lsZW50O1xufVxuQ2hpbGRNb2RlbC5wcm90b3R5cGUgPSBuZXcgTW9kZWw7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IERvYztcblxuZnVuY3Rpb24gRG9jKG1vZGVsLCBjb2xsZWN0aW9uTmFtZSwgaWQpIHtcbiAgdGhpcy5jb2xsZWN0aW9uTmFtZSA9IGNvbGxlY3Rpb25OYW1lO1xuICB0aGlzLmlkID0gaWQ7XG4gIHRoaXMuY29sbGVjdGlvbkRhdGEgPSBtb2RlbCAmJiBtb2RlbC5kYXRhW2NvbGxlY3Rpb25OYW1lXTtcbn1cblxuRG9jLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24oc2VnbWVudHMpIHtcbiAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbk5hbWUgKyAnLicgKyB0aGlzLmlkICsgJy4nICsgc2VnbWVudHMuam9pbignLicpO1xufTtcblxuRG9jLnByb3RvdHlwZS5fZXJyb3JNZXNzYWdlID0gZnVuY3Rpb24oZGVzY3JpcHRpb24sIHNlZ21lbnRzLCB2YWx1ZSkge1xuICByZXR1cm4gZGVzY3JpcHRpb24gKyAnIGF0ICcgKyB0aGlzLnBhdGgoc2VnbWVudHMpICsgJzogJyArXG4gICAgSlNPTi5zdHJpbmdpZnkodmFsdWUsIG51bGwsIDIpO1xufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xudmFyIGFycmF5RGlmZiA9IHJlcXVpcmUoJ2FycmF5ZGlmZicpO1xuXG5Nb2RlbC5wcm90b3R5cGUuc2V0RGlmZiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3VicGF0aCwgdmFsdWUsIG9wdGlvbnMsIGNiO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzFdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzFdO1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IGFyZ3VtZW50c1syXTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50c1syXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YWx1ZSA9IGFyZ3VtZW50c1sxXTtcbiAgICBvcHRpb25zID0gYXJndW1lbnRzWzJdO1xuICAgIGNiID0gYXJndW1lbnRzWzNdO1xuICB9XG4gIHZhciBzZWdtZW50cyA9IHRoaXMuX3NwbGl0UGF0aChzdWJwYXRoKTtcbiAgcmV0dXJuIHRoaXMuX3NldERpZmYoc2VnbWVudHMsIHZhbHVlLCBvcHRpb25zLCBjYik7XG59O1xuTW9kZWwucHJvdG90eXBlLl9zZXREaWZmID0gZnVuY3Rpb24oc2VnbWVudHMsIHZhbHVlLCBvcHRpb25zLCBjYikge1xuICBzZWdtZW50cyA9IHRoaXMuX2RlcmVmZXJlbmNlKHNlZ21lbnRzKTtcbiAgdmFyIGVxdWFsRm4gPSAob3B0aW9ucyAmJiBvcHRpb25zLmVxdWFsKSB8fCB1dGlsLmVxdWFsO1xuICB2YXIgaXNFYWNoID0gb3B0aW9ucyAmJiBvcHRpb25zLmVhY2g7XG4gIHZhciBtb2RlbCA9IHRoaXM7XG4gIGZ1bmN0aW9uIHNldERpZmYoZG9jLCBkb2NTZWdtZW50cywgZm5DYikge1xuICAgIHZhciBiZWZvcmUgPSBkb2MuZ2V0KGRvY1NlZ21lbnRzKTtcbiAgICBpZiAoZXF1YWxGbihiZWZvcmUsIHZhbHVlKSkgcmV0dXJuIGZuQ2IoKTtcbiAgICB2YXIgZ3JvdXAgPSB1dGlsLmFzeW5jR3JvdXAoZm5DYik7XG4gICAgZG9EaWZmKG1vZGVsLCBkb2MsIHNlZ21lbnRzLCBiZWZvcmUsIHZhbHVlLCBlcXVhbEZuLCBncm91cCwgaXNFYWNoKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fbXV0YXRlKHNlZ21lbnRzLCBzZXREaWZmLCBjYik7XG59O1xuTW9kZWwucHJvdG90eXBlLl9zZXRBcnJheURpZmYgPSBmdW5jdGlvbihzZWdtZW50cywgdmFsdWUsIGNiKSB7XG4gIHNlZ21lbnRzID0gdGhpcy5fZGVyZWZlcmVuY2Uoc2VnbWVudHMpO1xuICB2YXIgbW9kZWwgPSB0aGlzO1xuICBmdW5jdGlvbiBzZXRBcnJheURpZmYoZG9jLCBkb2NTZWdtZW50cywgZm5DYikge1xuICAgIHZhciBiZWZvcmUgPSBkb2MuZ2V0KGRvY1NlZ21lbnRzKTtcbiAgICBpZiAoYmVmb3JlID09PSB2YWx1ZSkgcmV0dXJuIGZuQ2IoKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYmVmb3JlKSB8fCAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGFwcGx5U2V0KG1vZGVsLCBkb2MsIHNlZ21lbnRzLCB2YWx1ZSwgZm5DYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBkaWZmID0gYXJyYXlEaWZmKGJlZm9yZSwgdmFsdWUpO1xuICAgIGlmICghZGlmZi5sZW5ndGgpIHJldHVybiBmbkNiKCk7XG4gICAgdmFyIGdyb3VwID0gdXRpbC5hc3luY0dyb3VwKGZuQ2IpO1xuICAgIGFwcGx5QXJyYXlEaWZmKG1vZGVsLCBkb2MsIHNlZ21lbnRzLCBkaWZmLCBncm91cCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX211dGF0ZShzZWdtZW50cywgc2V0QXJyYXlEaWZmLCBjYik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2NcbiAqIEBwYXJhbSB7U3RyaW5nfSBkb2MuY29sbGVjdGlvbk5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBkb2MuaWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2Muc25hcHNob3RcbiAqIEBwYXJhbSB7QXJyYXl9IHNlZ21lbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gYmVmb3JlXG4gKiBAcGFyYW0ge09iamVjdH0gYWZ0ZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdyb3VwXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzRWFjaFxuICovXG5mdW5jdGlvbiBkb0RpZmYobW9kZWwsIGRvYywgc2VnbWVudHMsIGJlZm9yZSwgYWZ0ZXIsIGVxdWFsRm4sIGdyb3VwLCBpc0VhY2gpIHtcbiAgaWYgKHR5cGVvZiBiZWZvcmUgIT09ICdvYmplY3QnIHx8ICFiZWZvcmUgfHxcbiAgICAgIHR5cGVvZiBhZnRlciAhPT0gJ29iamVjdCcgfHwgIWFmdGVyKSB7XG4gICAgLy8gU2V0IHRoZSBlbnRpcmUgdmFsdWUgaWYgbm90IGRpZmZhYmxlXG4gICAgYXBwbHlTZXQobW9kZWwsIGRvYywgc2VnbWVudHMsIGFmdGVyLCBncm91cCgpKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoYmVmb3JlKSAmJiBBcnJheS5pc0FycmF5KGFmdGVyKSkge1xuICAgIHZhciBkaWZmID0gYXJyYXlEaWZmKGJlZm9yZSwgYWZ0ZXIsIGVxdWFsRm4pO1xuICAgIGlmICghZGlmZi5sZW5ndGgpIHJldHVybiBncm91cCgpKCk7XG4gICAgLy8gSWYgdGhlIG9ubHkgY2hhbmdlIGlzIGEgc2luZ2xlIGl0ZW0gcmVwbGFjZW1lbnQsIGRpZmYgdGhlIGl0ZW0gaW5zdGVhZFxuICAgIGlmIChcbiAgICAgIGRpZmYubGVuZ3RoID09PSAyICYmXG4gICAgICBkaWZmWzBdLmluZGV4ID09PSBkaWZmWzFdLmluZGV4ICYmXG4gICAgICBkaWZmWzBdIGluc3RhbmNlb2YgYXJyYXlEaWZmLlJlbW92ZURpZmYgJiZcbiAgICAgIGRpZmZbMF0uaG93TWFueSA9PT0gMSAmJlxuICAgICAgZGlmZlsxXSBpbnN0YW5jZW9mIGFycmF5RGlmZi5JbnNlcnREaWZmICYmXG4gICAgICBkaWZmWzFdLnZhbHVlcy5sZW5ndGggPT09IDFcbiAgICApIHtcbiAgICAgIHZhciBpbmRleCA9IGRpZmZbMF0uaW5kZXg7XG4gICAgICB2YXIgaXRlbVNlZ21lbnRzID0gc2VnbWVudHMuY29uY2F0KGluZGV4KTtcbiAgICAgIGRvRGlmZihtb2RlbCwgZG9jLCBpdGVtU2VnbWVudHMsIGJlZm9yZVtpbmRleF0sIGFmdGVyW2luZGV4XSwgZXF1YWxGbiwgZ3JvdXApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhcHBseUFycmF5RGlmZihtb2RlbCwgZG9jLCBzZWdtZW50cywgZGlmZiwgZ3JvdXApO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIWlzRWFjaCkge1xuICAgIC8vIERlbGV0ZSBrZXlzIHRoYXQgd2VyZSBpbiBiZWZvcmUgYnV0IG5vdCBhZnRlclxuICAgIGZvciAodmFyIGtleSBpbiBiZWZvcmUpIHtcbiAgICAgIGlmIChrZXkgaW4gYWZ0ZXIpIGNvbnRpbnVlO1xuICAgICAgdmFyIGl0ZW1TZWdtZW50cyA9IHNlZ21lbnRzLmNvbmNhdChrZXkpO1xuICAgICAgdmFyIGRvY1NlZ21lbnRzID0gaXRlbVNlZ21lbnRzLnNsaWNlKDIpO1xuICAgICAgdmFyIHByZXZpb3VzID0gZG9jLmRlbChkb2NTZWdtZW50cywgZ3JvdXAoKSk7XG4gICAgICBtb2RlbC5lbWl0KCdjaGFuZ2UnLCBpdGVtU2VnbWVudHMsIFt2b2lkIDAsIHByZXZpb3VzLCBtb2RlbC5fcGFzc10pO1xuICAgIH1cbiAgfVxuICAvLyBEaWZmIGVhY2ggcHJvcGVydHkgaW4gYWZ0ZXJcbiAgZm9yICh2YXIga2V5IGluIGFmdGVyKSB7XG4gICAgaWYgKGVxdWFsRm4oYmVmb3JlW2tleV0sIGFmdGVyW2tleV0pKSBjb250aW51ZTtcbiAgICB2YXIgaXRlbVNlZ21lbnRzID0gc2VnbWVudHMuY29uY2F0KGtleSk7XG4gICAgZG9EaWZmKG1vZGVsLCBkb2MsIGl0ZW1TZWdtZW50cywgYmVmb3JlW2tleV0sIGFmdGVyW2tleV0sIGVxdWFsRm4sIGdyb3VwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVNldChtb2RlbCwgZG9jLCBzZWdtZW50cywgYWZ0ZXIsIGNiKSB7XG4gIHZhciBkb2NTZWdtZW50cyA9IHNlZ21lbnRzLnNsaWNlKDIpO1xuICB2YXIgcHJldmlvdXMgPSBkb2Muc2V0KGRvY1NlZ21lbnRzLCBhZnRlciwgY2IpO1xuICBtb2RlbC5lbWl0KCdjaGFuZ2UnLCBzZWdtZW50cywgW2FmdGVyLCBwcmV2aW91cywgbW9kZWwuX3Bhc3NdKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlBcnJheURpZmYobW9kZWwsIGRvYywgc2VnbWVudHMsIGRpZmYsIGdyb3VwKSB7XG4gIHZhciBkb2NTZWdtZW50cyA9IHNlZ21lbnRzLnNsaWNlKDIpO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGlmZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBpdGVtID0gZGlmZltpXTtcbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIGFycmF5RGlmZi5JbnNlcnREaWZmKSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIGRvYy5pbnNlcnQoZG9jU2VnbWVudHMsIGl0ZW0uaW5kZXgsIGl0ZW0udmFsdWVzLCBncm91cCgpKTtcbiAgICAgIG1vZGVsLmVtaXQoJ2luc2VydCcsIHNlZ21lbnRzLCBbaXRlbS5pbmRleCwgaXRlbS52YWx1ZXMsIG1vZGVsLl9wYXNzXSk7XG4gICAgfSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgYXJyYXlEaWZmLlJlbW92ZURpZmYpIHtcbiAgICAgIC8vIFJlbW92ZVxuICAgICAgdmFyIHJlbW92ZWQgPSBkb2MucmVtb3ZlKGRvY1NlZ21lbnRzLCBpdGVtLmluZGV4LCBpdGVtLmhvd01hbnksIGdyb3VwKCkpO1xuICAgICAgbW9kZWwuZW1pdCgncmVtb3ZlJywgc2VnbWVudHMsIFtpdGVtLmluZGV4LCByZW1vdmVkLCBtb2RlbC5fcGFzc10pO1xuICAgIH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIGFycmF5RGlmZi5Nb3ZlRGlmZikge1xuICAgICAgLy8gTW92ZVxuICAgICAgdmFyIG1vdmVkID0gZG9jLm1vdmUoZG9jU2VnbWVudHMsIGl0ZW0uZnJvbSwgaXRlbS50bywgaXRlbS5ob3dNYW55LCBncm91cCgpKTtcbiAgICAgIG1vZGVsLmVtaXQoJ21vdmUnLCBzZWdtZW50cywgW2l0ZW0uZnJvbSwgaXRlbS50bywgbW92ZWQubGVuZ3RoLCBtb2RlbC5fcGFzc10pO1xuICAgIH1cbiAgfVxufVxuIiwiKGZ1bmN0aW9uKHByb2Nlc3Mpe3ZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xudmFyIGFycmF5RGlmZiA9IHJlcXVpcmUoJ2FycmF5ZGlmZicpO1xudmFyIGRlZXBFcXVhbHMgPSByZXF1aXJlKCdkZWVwLWlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUXVlcnk7XG5cbk1vZGVsLklOSVRTLnB1c2goZnVuY3Rpb24obW9kZWwpIHtcbiAgbW9kZWwucm9vdC5fcXVlcmllcyA9IG5ldyBRdWVyaWVzO1xuICBpZiAobW9kZWwucm9vdC5mZXRjaE9ubHkpIHJldHVybjtcbiAgbW9kZWwub24oJ2FsbCcsIGZ1bmN0aW9uKHNlZ21lbnRzKSB7XG4gICAgLy8gVXBkYXRlZCBhc3luYywgc2luY2UgdGhpcyBpcyBsaWtlbHkgdGhlIHJlc3VsdCBvZiBhbiBvcGVyYXRpb24gdGhhdFxuICAgIC8vIGluY2x1ZGVzIGNyZWF0aW5nIHRoZSBkb2MsIGFuZCB3ZSB3b3VsZCBsaWtlIHRoYXQgdG8gaGFwcGVuIGJlZm9yZVxuICAgIC8vIHNlbmRpbmcgdGhlIHN1YnNjcmliZSBtZXNzYWdlXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtYXAgPSBtb2RlbC5yb290Ll9xdWVyaWVzLm1hcDtcbiAgICAgIGZvciAodmFyIGhhc2ggaW4gbWFwKSB7XG4gICAgICAgIHZhciBxdWVyeSA9IG1hcFtoYXNoXTtcbiAgICAgICAgaWYgKHF1ZXJ5LmlzUGF0aFF1ZXJ5ICYmIHF1ZXJ5LnNoYXJlUXVlcnkgJiYgdXRpbC5tYXlJbXBhY3QocXVlcnkuZXhwcmVzc2lvbiwgc2VnbWVudHMpKSB7XG4gICAgICAgICAgdmFyIGlkcyA9IHBhdGhJZHMobW9kZWwsIHF1ZXJ5LmV4cHJlc3Npb24pO1xuICAgICAgICAgIHZhciBwcmV2aW91c0lkcyA9IG1vZGVsLl9nZXQocXVlcnkuaWRTZWdtZW50cyk7XG4gICAgICAgICAgcXVlcnkuX29uQ2hhbmdlKGlkcywgcHJldmlvdXNJZHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufSk7XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbGxlY3Rpb25OYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gZXhwcmVzc2lvblxuICogQHBhcmFtIHtTdHJpbmd9IHNvdXJjZVxuICogQHJldHVybiB7UXVlcnl9XG4gKi9cbk1vZGVsLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb25OYW1lLCBleHByZXNzaW9uLCBzb3VyY2UpIHtcbiAgaWYgKHR5cGVvZiBleHByZXNzaW9uLnBhdGggPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGV4cHJlc3Npb24gIT09ICdvYmplY3QnKSB7XG4gICAgZXhwcmVzc2lvbiA9IHRoaXMuX3NwbGl0UGF0aChleHByZXNzaW9uKTtcbiAgfVxuICB2YXIgcXVlcnkgPSB0aGlzLnJvb3QuX3F1ZXJpZXMuZ2V0KGNvbGxlY3Rpb25OYW1lLCBleHByZXNzaW9uLCBzb3VyY2UpO1xuICBpZiAocXVlcnkpIHJldHVybiBxdWVyeTtcbiAgcXVlcnkgPSBuZXcgUXVlcnkodGhpcywgY29sbGVjdGlvbk5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZSk7XG4gIHRoaXMucm9vdC5fcXVlcmllcy5hZGQocXVlcnkpO1xuICByZXR1cm4gcXVlcnk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24gb2YgdGhlIGJ1bmRsZSBvbiBwYWdlIGxvYWQuXG4gKiBAcGFyYW0ge0FycmF5fSBpdGVtc1xuICogQHBhcmFtIHtBcnJheX0gaXRlbXNbKl1cbiAqIEBwYXJhbSB7U3RyaW5nfSBpdGVtc1sqXVswXSBjb2xsZWN0aW9uTmFtZVxuICogQHBhcmFtIHtPYmplY3R9IGl0ZW1zWypdWzFdIGV4cHJlc3Npb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBpdGVtc1sqXVsyXSBzb3VyY2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBpdGVtc1sqXVszXSBzdWJzY3JpYmVDb3VudFxuICogQHBhcmFtIHtOdW1iZXJ9IGl0ZW1zWypdWzRdIGZldGNoQ291bnRcbiAqIEBwYXJhbSB7QXJyYXl9ICBpdGVtc1sqXVs1XSBmZXRjaElkc1xuICovXG5Nb2RlbC5wcm90b3R5cGUuX2luaXRRdWVyaWVzID0gZnVuY3Rpb24oaXRlbXMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gaXRlbXNbaV07XG4gICAgdmFyIHF1ZXJ5ID0gbmV3IFF1ZXJ5KHRoaXMsIGl0ZW1bMF0sIGl0ZW1bMV0sIGl0ZW1bMl0sIGl0ZW1bM10sIGl0ZW1bNF0sIGl0ZW1bNV0pO1xuICAgIHZhciBjb3VudCA9IHF1ZXJ5LmZldGNoQ291bnQ7XG4gICAgd2hpbGUgKGNvdW50LS0pIHRoaXMuZW1pdCgnZmV0Y2hRdWVyeScsIHF1ZXJ5LCB0aGlzLl9jb250ZXh0KTtcbiAgICB2YXIgY291bnQgPSBxdWVyeS5zdWJzY3JpYmVDb3VudDtcbiAgICBxdWVyeS5zdWJzY3JpYmVDb3VudCA9IDA7XG4gICAgd2hpbGUgKGNvdW50LS0pIHF1ZXJ5LnN1YnNjcmliZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBRdWVyaWVzTWFwKCkge31cblxuZnVuY3Rpb24gUXVlcmllcygpIHtcbiAgdGhpcy5tYXAgPSBuZXcgUXVlcmllc01hcDtcbn1cblF1ZXJpZXMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gIHRoaXMubWFwW3F1ZXJ5Lmhhc2hdID0gcXVlcnk7XG59O1xuUXVlcmllcy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24ocXVlcnkpIHtcbiAgZGVsZXRlIHRoaXMubWFwW3F1ZXJ5Lmhhc2hdO1xufTtcblF1ZXJpZXMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGNvbGxlY3Rpb25OYW1lLCBleHByZXNzaW9uLCBzb3VyY2UpIHtcbiAgdmFyIGhhc2ggPSBxdWVyeUhhc2goY29sbGVjdGlvbk5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZSk7XG4gIHJldHVybiB0aGlzLm1hcFtoYXNoXTtcbn07XG5RdWVyaWVzLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgdmFyIG91dCA9IFtdO1xuICBmb3IgKHZhciBoYXNoIGluIHRoaXMubWFwKSB7XG4gICAgdmFyIHF1ZXJ5ID0gdGhpcy5tYXBbaGFzaF07XG4gICAgaWYgKHF1ZXJ5LnN1YnNjcmliZUNvdW50IHx8IHF1ZXJ5LmZldGNoQ291bnQpIHtcbiAgICAgIG91dC5wdXNoKHF1ZXJ5LnNlcmlhbGl6ZSgpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtNb2RlbH0gbW9kZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb2xsZWN0aW9uTmFtZVxuICogQHBhcmFtIHtPYmplY3R9IGV4cHJlc3Npb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBzb3VyY2UgKGUuZy4sICdzb2xyJylcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdWJzY3JpYmVDb3VudFxuICogQHBhcmFtIHtOdW1iZXJ9IGZldGNoQ291bnRcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8U3RyaW5nPj59IGZldGNoSWRzXG4gKi9cbmZ1bmN0aW9uIFF1ZXJ5KG1vZGVsLCBjb2xsZWN0aW9uTmFtZSwgZXhwcmVzc2lvbiwgc291cmNlLCBzdWJzY3JpYmVDb3VudCwgZmV0Y2hDb3VudCwgZmV0Y2hJZHMpIHtcbiAgdGhpcy5tb2RlbCA9IG1vZGVsLnBhc3MoeyRxdWVyeTogdGhpc30pO1xuICB0aGlzLmNvbGxlY3Rpb25OYW1lID0gY29sbGVjdGlvbk5hbWU7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gIHRoaXMuc291cmNlID0gc291cmNlO1xuICB0aGlzLmhhc2ggPSBxdWVyeUhhc2goY29sbGVjdGlvbk5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZSk7XG4gIHRoaXMuc2VnbWVudHMgPSBbJyRxdWVyaWVzJywgdGhpcy5oYXNoXTtcbiAgdGhpcy5pZFNlZ21lbnRzID0gWyckcXVlcmllcycsIHRoaXMuaGFzaCwgJ2lkcyddO1xuICB0aGlzLmV4dHJhU2VnbWVudHMgPSBbJyRxdWVyaWVzJywgdGhpcy5oYXNoLCAnZXh0cmEnXTtcbiAgdGhpcy5pc1BhdGhRdWVyeSA9IEFycmF5LmlzQXJyYXkoZXhwcmVzc2lvbik7XG5cbiAgdGhpcy5fcGVuZGluZ1N1YnNjcmliZUNhbGxiYWNrcyA9IFtdO1xuXG4gIC8vIFRoZXNlIGFyZSB1c2VkIHRvIGhlbHAgY2xlYW51cCBhcHByb3ByaWF0ZWx5IHdoZW4gY2FsbGluZyB1bnN1YnNjcmliZSBhbmRcbiAgLy8gdW5mZXRjaC4gQSBxdWVyeSB3b24ndCBiZSBmdWxseSBjbGVhbmVkIHVwIHVudGlsIHVuZmV0Y2ggYW5kIHVuc3Vic2NyaWJlXG4gIC8vIGFyZSBjYWxsZWQgdGhlIHNhbWUgbnVtYmVyIG9mIHRpbWVzIHRoYXQgZmV0Y2ggYW5kIHN1YnNjcmliZSB3ZXJlIGNhbGxlZC5cbiAgdGhpcy5zdWJzY3JpYmVDb3VudCA9IHN1YnNjcmliZUNvdW50IHx8IDA7XG4gIHRoaXMuZmV0Y2hDb3VudCA9IGZldGNoQ291bnQgfHwgMDtcbiAgLy8gVGhlIGxpc3Qgb2YgaWRzIGF0IHRoZSB0aW1lIG9mIGVhY2ggZmV0Y2ggaXMgcHVzaGVkIG9udG8gZmV0Y2hJZHMsIHNvXG4gIC8vIHRoYXQgdW5mZXRjaERvYyBjYW4gYmUgY2FsbGVkIHRoZSBzYW1lIG51bWJlciBvZiB0aW1lcyBhcyBmZXRjaERvY1xuICB0aGlzLmZldGNoSWRzID0gZmV0Y2hJZHMgfHwgW107XG5cbiAgdGhpcy5jcmVhdGVkID0gZmFsc2U7XG4gIHRoaXMuc2hhcmVRdWVyeSA9IG51bGw7XG59XG5cblF1ZXJ5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jcmVhdGVkID0gdHJ1ZTtcbiAgdGhpcy5tb2RlbC5yb290Ll9xdWVyaWVzLmFkZCh0aGlzKTtcbn07XG5cblF1ZXJ5LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY3JlYXRlZCA9IGZhbHNlO1xuICBpZiAodGhpcy5zaGFyZVF1ZXJ5KSB7XG4gICAgdGhpcy5zaGFyZVF1ZXJ5LmRlc3Ryb3koKTtcbiAgICB0aGlzLnNoYXJlUXVlcnkgPSBudWxsO1xuICB9XG4gIHRoaXMubW9kZWwucm9vdC5fcXVlcmllcy5yZW1vdmUodGhpcyk7XG4gIHRoaXMubW9kZWwuX2RlbCh0aGlzLnNlZ21lbnRzKTtcbn07XG5cblF1ZXJ5LnByb3RvdHlwZS5zb3VyY2VRdWVyeSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5pc1BhdGhRdWVyeSkge1xuICAgIHZhciBpZHMgPSBwYXRoSWRzKHRoaXMubW9kZWwsIHRoaXMuZXhwcmVzc2lvbik7XG4gICAgcmV0dXJuIHtfaWQ6IHskaW46IGlkc319O1xuICB9XG4gIHJldHVybiB0aGlzLmV4cHJlc3Npb247XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gY2IoZXJyKVxuICovXG5RdWVyeS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbihjYikge1xuICBpZiAoIWNiKSBjYiA9IHRoaXMubW9kZWwucm9vdC5fZGVmYXVsdENhbGxiYWNrO1xuICB0aGlzLm1vZGVsLmVtaXQoJ2ZldGNoUXVlcnknLCB0aGlzLCB0aGlzLm1vZGVsLl9jb250ZXh0KTtcblxuICB0aGlzLmZldGNoQ291bnQrKztcblxuICBpZiAoIXRoaXMuY3JlYXRlZCkgdGhpcy5jcmVhdGUoKTtcbiAgdmFyIHF1ZXJ5ID0gdGhpcztcblxuICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICB2YXIgc2hhcmVEb2NzID0gY29sbGVjdGlvblNoYXJlRG9jcyh0aGlzLm1vZGVsLCB0aGlzLmNvbGxlY3Rpb25OYW1lKTtcbiAgdmFyIG9wdGlvbnMgPSB7ZG9jTW9kZTogJ2ZldGNoJywga25vd25Eb2NzOiBzaGFyZURvY3N9O1xuICBpZiAodGhpcy5zb3VyY2UpIG9wdGlvbnMuc291cmNlID0gdGhpcy5zb3VyY2U7XG5cbiAgbW9kZWwucm9vdC5zaGFyZUNvbm5lY3Rpb24uY3JlYXRlRmV0Y2hRdWVyeShcbiAgICB0aGlzLmNvbGxlY3Rpb25OYW1lLCB0aGlzLnNvdXJjZVF1ZXJ5KCksIG9wdGlvbnMsIGZldGNoUXVlcnlDYWxsYmFja1xuICApO1xuICBmdW5jdGlvbiBmZXRjaFF1ZXJ5Q2FsbGJhY2soZXJyLCByZXN1bHRzLCBleHRyYSkge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuICAgIHZhciBpZHMgPSByZXN1bHRzSWRzKHJlc3VsdHMpO1xuXG4gICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgaWRzIGF0IGZldGNoIHRpbWUgZm9yIHVzZSBpbiB1bmZldGNoXG4gICAgcXVlcnkuZmV0Y2hJZHMucHVzaChpZHMuc2xpY2UoKSk7XG4gICAgLy8gVXBkYXRlIHRoZSByZXN1bHRzIGlkcyBhbmQgZXh0cmFcbiAgICBtb2RlbC5fc2V0RGlmZihxdWVyeS5pZFNlZ21lbnRzLCBpZHMpO1xuICAgIGlmIChleHRyYSAhPT0gdm9pZCAwKSB7XG4gICAgICBtb2RlbC5fc2V0RGlmZihxdWVyeS5leHRyYVNlZ21lbnRzLCBleHRyYSwge2VxdWFsOiBkZWVwRXF1YWxzfSk7XG4gICAgfVxuXG4gICAgaWYgKCFpZHMubGVuZ3RoKSByZXR1cm4gY2IoKTtcblxuICAgIC8vIENhbGwgZmV0Y2hEb2MgZm9yIGVhY2ggZG9jdW1lbnQgcmV0dXJuZWQgc28gdGhhdCB0aGUgcHJvcGVyIGxvYWQgZXZlbnRzXG4gICAgLy8gYW5kIGludGVybmFsIGNvdW50cyBhcmUgbWFpbnRhaW5lZC4gSG93ZXZlciwgc3BlY2lmeSB0aGF0IHdlIGFscmVhZHlcbiAgICAvLyBsb2FkZWQgdGhlIGRvY3VtZW50cyBhcyBwYXJ0IG9mIHRoZSBxdWVyeSwgc2luY2Ugd2UgZG9uJ3Qgd2FudCB0b1xuICAgIC8vIGFjdHVhbGx5IGZldGNoIHRoZSBkb2N1bWVudHMgYWdhaW5cbiAgICB2YXIgYWxyZWFkeUxvYWRlZCA9IHRydWU7XG4gICAgdmFyIGdyb3VwID0gdXRpbC5hc3luY0dyb3VwKGNiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgbW9kZWwuZmV0Y2hEb2MocXVlcnkuY29sbGVjdGlvbk5hbWUsIGlkc1tpXSwgZ3JvdXAoKSwgYWxyZWFkeUxvYWRlZCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHVwIGEgc3Vic2NyaXB0aW9uIHRvIGB0aGlzYCBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiKGVycilcbiAqL1xuUXVlcnkucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uKGNiKSB7XG4gIGlmICghY2IpIGNiID0gdGhpcy5tb2RlbC5yb290Ll9kZWZhdWx0Q2FsbGJhY2s7XG4gIHRoaXMubW9kZWwuZW1pdCgnc3Vic2NyaWJlUXVlcnknLCB0aGlzLCB0aGlzLm1vZGVsLl9jb250ZXh0KTtcblxuICB2YXIgcXVlcnkgPSB0aGlzO1xuXG4gIGlmICh0aGlzLnN1YnNjcmliZUNvdW50KyspIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkYXRhID0gcXVlcnkubW9kZWwuX2dldChxdWVyeS5zZWdtZW50cyk7XG4gICAgICBpZiAoZGF0YSkgY2IoKTtcbiAgICAgIGVsc2UgcXVlcnkuX3BlbmRpbmdTdWJzY3JpYmVDYWxsYmFja3MucHVzaChjYik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAoIXRoaXMuY3JlYXRlZCkgdGhpcy5jcmVhdGUoKTtcblxuICAvLyBXaGVuIGRvaW5nIHNlcnZlci1zaWRlIHJlbmRlcmluZywgd2UgYWN0dWFsbHkgZG8gYSBmZXRjaCB0aGUgZmlyc3QgdGltZVxuICAvLyB0aGF0IHN1YnNjcmliZSBpcyBjYWxsZWQsIGJ1dCBrZWVwIHRyYWNrIG9mIHRoZSBzdGF0ZSBhcyBpZiBzdWJzY3JpYmVcbiAgLy8gd2VyZSBjYWxsZWQgZm9yIHByb3BlciBpbml0aWFsaXphdGlvbiBpbiB0aGUgY2xpZW50XG4gIHZhciBzaGFyZURvY3MgPSBjb2xsZWN0aW9uU2hhcmVEb2NzKHRoaXMubW9kZWwsIHRoaXMuY29sbGVjdGlvbk5hbWUpO1xuICB2YXIgb3B0aW9ucyA9IHtkb2NNb2RlOiAnc3ViJywga25vd25Eb2NzOiBzaGFyZURvY3N9O1xuICBpZiAodGhpcy5zb3VyY2UpIG9wdGlvbnMuc291cmNlID0gdGhpcy5zb3VyY2U7XG5cbiAgaWYgKCF0aGlzLm1vZGVsLnJvb3QuZmV0Y2hPbmx5KSB7XG4gICAgdGhpcy5fc2hhcmVTdWJzY3JpYmUob3B0aW9ucywgY2IpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgb3B0aW9ucy5kb2NNb2RlID0gJ2ZldGNoJztcbiAgbW9kZWwucm9vdC5zaGFyZUNvbm5lY3Rpb24uY3JlYXRlRmV0Y2hRdWVyeShcbiAgICB0aGlzLmNvbGxlY3Rpb25OYW1lLCB0aGlzLnNvdXJjZVF1ZXJ5KCksIG9wdGlvbnMsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cywgZXh0cmEpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuICAgICAgdmFyIGlkcyA9IHJlc3VsdHNJZHMocmVzdWx0cyk7XG4gICAgICBpZiAoZXh0cmEgIT09IHZvaWQgMCkge1xuICAgICAgICBtb2RlbC5fc2V0RGlmZihxdWVyeS5leHRyYVNlZ21lbnRzLCBleHRyYSwge2VxdWFsOiBkZWVwRXF1YWxzfSk7XG4gICAgICB9XG4gICAgICBxdWVyeS5fb25DaGFuZ2UoaWRzLCBudWxsLCBjYik7XG4gICAgICB3aGlsZSAoY2IgPSBxdWVyeS5fcGVuZGluZ1N1YnNjcmliZUNhbGxiYWNrcy5zaGlmdCgpKSB7XG4gICAgICAgIHF1ZXJ5Ll9vbkNoYW5nZShpZHMsIG51bGwsIGNiKTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zb3VyY2VdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnBvbGxdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmRvY01vZGUgPSBmZXRjaCBvciBzdWJzY3JpYmVdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYihlcnIsIHJlc3VsdHMpXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fc2hhcmVTdWJzY3JpYmUgPSBmdW5jdGlvbihvcHRpb25zLCBjYikge1xuICB2YXIgcXVlcnkgPSB0aGlzO1xuICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICB0aGlzLnNoYXJlUXVlcnkgPSB0aGlzLm1vZGVsLnJvb3Quc2hhcmVDb25uZWN0aW9uLmNyZWF0ZVN1YnNjcmliZVF1ZXJ5KFxuICAgIHRoaXMuY29sbGVjdGlvbk5hbWUsIHRoaXMuc291cmNlUXVlcnkoKSwgb3B0aW9ucywgZnVuY3Rpb24gKGVyciwgcmVzdWx0cywgZXh0cmEpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuICAgICAgaWYgKGV4dHJhICE9PSB2b2lkIDApIHtcbiAgICAgICAgbW9kZWwuX3NldERpZmYocXVlcnkuZXh0cmFTZWdtZW50cywgZXh0cmEsIHtlcXVhbDogZGVlcEVxdWFsc30pO1xuICAgICAgfVxuICAgICAgLy8gUmVzdWx0cyBhcmUgbm90IHNldCBpbiB0aGUgY2FsbGJhY2ssIGJlY2F1c2UgdGhlIHNoYXJlUXVlcnkgc2hvdWxkXG4gICAgICAvLyBlbWl0IGEgJ2NoYW5nZScgZXZlbnQgYmVmb3JlIGNhbGxpbmcgYmFja1xuICAgICAgY2IoKTtcbiAgICB9XG4gICk7XG4gIHZhciBxdWVyeSA9IHRoaXM7XG4gIHRoaXMuc2hhcmVRdWVyeS5vbignaW5zZXJ0JywgZnVuY3Rpb24oc2hhcmVEb2NzLCBpbmRleCkge1xuICAgIHF1ZXJ5Ll9vbkluc2VydChzaGFyZURvY3MsIGluZGV4KTtcbiAgfSk7XG4gIHRoaXMuc2hhcmVRdWVyeS5vbigncmVtb3ZlJywgZnVuY3Rpb24oc2hhcmVEb2NzLCBpbmRleCkge1xuICAgIHF1ZXJ5Ll9vblJlbW92ZShzaGFyZURvY3MsIGluZGV4KTtcbiAgfSk7XG4gIHRoaXMuc2hhcmVRdWVyeS5vbignbW92ZScsIGZ1bmN0aW9uKHNoYXJlRG9jcywgZnJvbSwgdG8pIHtcbiAgICBxdWVyeS5fb25Nb3ZlKHNoYXJlRG9jcywgZnJvbSwgdG8pO1xuICB9KTtcbiAgdGhpcy5zaGFyZVF1ZXJ5Lm9uKCdjaGFuZ2UnLCBmdW5jdGlvbihyZXN1bHRzLCBwcmV2aW91cykge1xuICAgIC8vIEdldCB0aGUgbmV3IGFuZCBwcmV2aW91cyBsaXN0IG9mIGlkcyB3aGVuIHRoZSBlbnRpcmUgcmVzdWx0cyBzZXQgY2hhbmdlc1xuICAgIHZhciBpZHMgPSByZXN1bHRzSWRzKHJlc3VsdHMpO1xuICAgIHZhciBwcmV2aW91c0lkcyA9IHByZXZpb3VzICYmIHJlc3VsdHNJZHMocHJldmlvdXMpO1xuICAgIHF1ZXJ5Ll9vbkNoYW5nZShpZHMsIHByZXZpb3VzSWRzKTtcbiAgfSk7XG4gIHRoaXMuc2hhcmVRdWVyeS5vbignZXh0cmEnLCBmdW5jdGlvbiAoZXh0cmEpIHtcbiAgICBtb2RlbC5fc2V0RGlmZihxdWVyeS5leHRyYVNlZ21lbnRzLCBleHRyYSwge2VxdWFsOiBkZWVwRXF1YWxzfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYihlcnIsIG5ld0ZldGNoQ291bnQpXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS51bmZldGNoID0gZnVuY3Rpb24oY2IpIHtcbiAgaWYgKCFjYikgY2IgPSB0aGlzLm1vZGVsLnJvb3QuX2RlZmF1bHRDYWxsYmFjaztcbiAgdGhpcy5tb2RlbC5lbWl0KCd1bmZldGNoUXVlcnknLCB0aGlzLCB0aGlzLm1vZGVsLl9jb250ZXh0KTtcblxuICAvLyBObyBlZmZlY3QgaWYgdGhlIHF1ZXJ5IGlzIG5vdCBjdXJyZW50bHkgZmV0Y2hlZFxuICBpZiAoIXRoaXMuZmV0Y2hDb3VudCkge1xuICAgIGNiKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgaWRzID0gdGhpcy5mZXRjaElkcy5zaGlmdCgpIHx8IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMubW9kZWwudW5mZXRjaERvYyh0aGlzLmNvbGxlY3Rpb25OYW1lLCBpZHNbaV0pO1xuICB9XG5cbiAgdmFyIHF1ZXJ5ID0gdGhpcztcbiAgaWYgKHRoaXMubW9kZWwucm9vdC51bmxvYWREZWxheSkge1xuICAgIHNldFRpbWVvdXQoZmluaXNoVW5mZXRjaFF1ZXJ5LCB0aGlzLm1vZGVsLnJvb3QudW5sb2FkRGVsYXkpO1xuICB9IGVsc2Uge1xuICAgIGZpbmlzaFVuZmV0Y2hRdWVyeSgpO1xuICB9XG4gIGZ1bmN0aW9uIGZpbmlzaFVuZmV0Y2hRdWVyeSgpIHtcbiAgICB2YXIgY291bnQgPSAtLXF1ZXJ5LmZldGNoQ291bnQ7XG4gICAgaWYgKGNvdW50KSByZXR1cm4gY2IobnVsbCwgY291bnQpO1xuICAgIC8vIENsZWFudXAgd2hlbiBubyBmZXRjaGVzIG9yIHN1YnNjcmliZXMgcmVtYWluXG4gICAgaWYgKCFxdWVyeS5zdWJzY3JpYmVDb3VudCkgcXVlcnkuZGVzdHJveSgpO1xuICAgIGNiKG51bGwsIDApO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuUXVlcnkucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24oY2IpIHtcbiAgaWYgKCFjYikgY2IgPSB0aGlzLm1vZGVsLnJvb3QuX2RlZmF1bHRDYWxsYmFjaztcbiAgdGhpcy5tb2RlbC5lbWl0KCd1bnN1YnNjcmliZVF1ZXJ5JywgdGhpcywgdGhpcy5tb2RlbC5fY29udGV4dCk7XG5cbiAgLy8gTm8gZWZmZWN0IGlmIHRoZSBxdWVyeSBpcyBub3QgY3VycmVudGx5IHN1YnNjcmliZWRcbiAgaWYgKCF0aGlzLnN1YnNjcmliZUNvdW50KSB7XG4gICAgY2IoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBxdWVyeSA9IHRoaXM7XG4gIGlmICh0aGlzLm1vZGVsLnJvb3QudW5sb2FkRGVsYXkpIHtcbiAgICBzZXRUaW1lb3V0KGZpbmlzaFVuc3Vic2NyaWJlUXVlcnksIHRoaXMubW9kZWwucm9vdC51bmxvYWREZWxheSk7XG4gIH0gZWxzZSB7XG4gICAgZmluaXNoVW5zdWJzY3JpYmVRdWVyeSgpO1xuICB9XG4gIGZ1bmN0aW9uIGZpbmlzaFVuc3Vic2NyaWJlUXVlcnkoKSB7XG4gICAgdmFyIGNvdW50ID0gLS1xdWVyeS5zdWJzY3JpYmVDb3VudDtcbiAgICBpZiAoY291bnQpIHJldHVybiBjYihudWxsLCBjb3VudCk7XG5cbiAgICBpZiAocXVlcnkuc2hhcmVRdWVyeSkge1xuICAgICAgdmFyIGlkcyA9IHJlc3VsdHNJZHMocXVlcnkuc2hhcmVRdWVyeS5yZXN1bHRzKTtcbiAgICAgIHF1ZXJ5LnNoYXJlUXVlcnkuZGVzdHJveSgpO1xuICAgICAgcXVlcnkuc2hhcmVRdWVyeSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCFxdWVyeS5tb2RlbC5yb290LmZldGNoT25seSAmJiBpZHMgJiYgaWRzLmxlbmd0aCkge1xuICAgICAgLy8gVW5zdWJzY3JpYmUgYWxsIGRvY3VtZW50cyB0aGF0IHRoaXMgcXVlcnkgY3VycmVudGx5IGhhcyBpbiByZXN1bHRzXG4gICAgICB2YXIgZ3JvdXAgPSB1dGlsLmFzeW5jR3JvdXAodW5zdWJzY3JpYmVRdWVyeUNhbGxiYWNrKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHF1ZXJ5Lm1vZGVsLnVuc3Vic2NyaWJlRG9jKHF1ZXJ5LmNvbGxlY3Rpb25OYW1lLCBpZHNbaV0sIGdyb3VwKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICB1bnN1YnNjcmliZVF1ZXJ5Q2FsbGJhY2soKTtcbiAgfVxuICBmdW5jdGlvbiB1bnN1YnNjcmliZVF1ZXJ5Q2FsbGJhY2soZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgLy8gQ2xlYW51cCB3aGVuIG5vIGZldGNoZXMgb3Igc3Vic2NyaWJlcyByZW1haW5cbiAgICBpZiAoIXF1ZXJ5LmZldGNoQ291bnQpIHF1ZXJ5LmRlc3Ryb3koKTtcbiAgICBjYihudWxsLCAwKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblF1ZXJ5LnByb3RvdHlwZS5fb25JbnNlcnQgPSBmdW5jdGlvbihzaGFyZURvY3MsIGluZGV4KSB7XG4gIHZhciBpZHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaGFyZURvY3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaWQgPSBzaGFyZURvY3NbaV0ubmFtZTtcbiAgICBpZHMucHVzaChpZCk7XG4gICAgdGhpcy5tb2RlbC5zdWJzY3JpYmVEb2ModGhpcy5jb2xsZWN0aW9uTmFtZSwgaWQpO1xuICB9XG4gIHRoaXMubW9kZWwuX2luc2VydCh0aGlzLmlkU2VnbWVudHMsIGluZGV4LCBpZHMpO1xufTtcblF1ZXJ5LnByb3RvdHlwZS5fb25SZW1vdmUgPSBmdW5jdGlvbihzaGFyZURvY3MsIGluZGV4KSB7XG4gIHRoaXMubW9kZWwuX3JlbW92ZSh0aGlzLmlkU2VnbWVudHMsIGluZGV4LCBzaGFyZURvY3MubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaGFyZURvY3MubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLm1vZGVsLnVuc3Vic2NyaWJlRG9jKHRoaXMuY29sbGVjdGlvbk5hbWUsIHNoYXJlRG9jc1tpXS5uYW1lKTtcbiAgfVxufTtcblF1ZXJ5LnByb3RvdHlwZS5fb25Nb3ZlID0gZnVuY3Rpb24oc2hhcmVEb2NzLCBmcm9tLCB0bykge1xuICB0aGlzLm1vZGVsLl9tb3ZlKHRoaXMuaWRTZWdtZW50cywgZnJvbSwgdG8sIHNoYXJlRG9jcy5sZW5ndGgpO1xufTtcblxuUXVlcnkucHJvdG90eXBlLl9vbkNoYW5nZSA9IGZ1bmN0aW9uKGlkcywgcHJldmlvdXNJZHMsIGNiKSB7XG4gIC8vIERpZmYgdGhlIG5ldyBhbmQgcHJldmlvdXMgbGlzdCBvZiBpZHMsIHN1YnNjcmliaW5nIHRvIGRvY3VtZW50cyBmb3JcbiAgLy8gaW5zZXJ0ZWQgaWRzIGFuZCB1bnN1YnNjcmliaW5nIGZyb20gZG9jdW1lbnRzIGZvciByZW1vdmVkIGlkc1xuICB2YXIgZGlmZiA9IChwcmV2aW91c0lkcykgP1xuICAgIGFycmF5RGlmZihwcmV2aW91c0lkcywgaWRzKSA6XG4gICAgW25ldyBhcnJheURpZmYuSW5zZXJ0RGlmZigwLCBpZHMpXTtcbiAgdmFyIHByZXZpb3VzQ29weSA9IHByZXZpb3VzSWRzICYmIHByZXZpb3VzSWRzLnNsaWNlKCk7XG5cbiAgLy8gVGhlIHJlc3VsdHMgYXJlIHVwZGF0ZWQgdmlhIGEgZGlmZmVyZW50IGRpZmYsIHNpbmNlIHRoZXkgbWlnaHQgYWxyZWFkeVxuICAvLyBoYXZlIGEgdmFsdWUgZnJvbSBhIGZldGNoIG9yIHByZXZpb3VzIHNoYXJlUXVlcnkgaW5zdGFuY2VcbiAgdGhpcy5tb2RlbC5fc2V0RGlmZih0aGlzLmlkU2VnbWVudHMsIGlkcyk7XG5cbiAgaWYgKGNiKSB7XG4gICAgdmFyIGdyb3VwID0gdXRpbC5hc3luY0dyb3VwKGNiKTtcbiAgICB2YXIgZmluaXNoZWQgPSBncm91cCgpO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGlmZi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gZGlmZltpXTtcbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIGFycmF5RGlmZi5JbnNlcnREaWZmKSB7XG4gICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIGRvY3VtZW50IGZvciBlYWNoIGluc2VydGVkIGlkXG4gICAgICB2YXIgdmFsdWVzID0gaXRlbS52YWx1ZXM7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB0aGlzLm1vZGVsLnN1YnNjcmliZURvYyh0aGlzLmNvbGxlY3Rpb25OYW1lLCB2YWx1ZXNbal0sIGNiICYmIGdyb3VwKCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIGFycmF5RGlmZi5SZW1vdmVEaWZmKSB7XG4gICAgICB2YXIgdmFsdWVzID0gcHJldmlvdXNDb3B5LnNwbGljZShpdGVtLmluZGV4LCBpdGVtLmhvd01hbnkpO1xuICAgICAgLy8gVW5zdWJzY3JpYmUgZnJvbSB0aGUgZG9jdW1lbnQgZm9yIGVhY2ggcmVtb3ZlZCBpZFxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdGhpcy5tb2RlbC51bnN1YnNjcmliZURvYyh0aGlzLmNvbGxlY3Rpb25OYW1lLCB2YWx1ZXNbal0sIGNiICYmIGdyb3VwKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBNb3ZpbmcgZG9lc24ndCBjaGFuZ2UgZG9jdW1lbnQgc3Vic2NyaXB0aW9ucywgc28gdGhhdCBpcyBpZ25vcmVkLlxuICB9XG4gIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBjYWxsYmFjayBnZXRzIGNhbGxlZCBpZiB0aGUgZGlmZiBpcyBlbXB0eSBvciBpdFxuICAvLyBjb250YWlucyBubyBpbnNlcnRzIG9yIHJlbW92ZXNcbiAgZmluaXNoZWQgJiYgZmluaXNoZWQoKTtcbn07XG5cblF1ZXJ5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgdmFyIGRhdGEgPSB0aGlzLm1vZGVsLl9nZXQodGhpcy5zZWdtZW50cyk7XG4gIGlmICghZGF0YSkge1xuICAgIGNvbnNvbGUud2FybignWW91IG11c3QgZmV0Y2ggb3Igc3Vic2NyaWJlIHRvIGEgcXVlcnkgYmVmb3JlIGdldHRpbmcgaXRzIHJlc3VsdHMuJyk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgdmFyIGlkcyA9IGRhdGEuaWRzO1xuICBpZiAoIWlkcykgcmV0dXJuIHJlc3VsdHM7XG5cbiAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLm1vZGVsLmdldENvbGxlY3Rpb24odGhpcy5jb2xsZWN0aW9uTmFtZSk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaWRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBpZCA9IGlkc1tpXTtcbiAgICB2YXIgZG9jID0gY29sbGVjdGlvbiAmJiBjb2xsZWN0aW9uLmRvY3NbaWRdO1xuICAgIHJlc3VsdHMucHVzaChkb2MgJiYgZG9jLmdldCgpKTtcbiAgfVxuICByZXR1cm4gKGRhdGEuZXh0cmEgPT09IHZvaWQgMCkgP1xuICAgIHJlc3VsdHMgOlxuICAgIHtyZXN1bHRzOiByZXN1bHRzLCBleHRyYTogZGF0YS5leHRyYX07XG59O1xuXG4vKipcbiAqIExhemlseSBjcmVhdGVzIG9yIGdldHMgYSByZWYgdG8gb3VyIHJlc3VsdHNldCdzIHJlc3VsdHMuXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbihmcm9tKSB7XG4gIHZhciBpZHNQYXRoID0gdGhpcy5pZFNlZ21lbnRzLmpvaW4oJy4nKTtcbiAgcmV0dXJuIHRoaXMubW9kZWwucmVmTGlzdChmcm9tLCB0aGlzLmNvbGxlY3Rpb25OYW1lLCBpZHNQYXRoKTtcbn07XG5cbi8qKlxuICogTGF6aWx5IGNyZWF0ZXMgb3IgZ2V0cyBhIHJlZiB0byBvdXIgcmVzdWx0c2V0J3MgZXh0cmEgZGF0YS5cbiAqL1xuUXVlcnkucHJvdG90eXBlLmV4dHJhUmVmID0gZnVuY3Rpb24oZnJvbSwgcmVsUGF0aCkge1xuICB2YXIgZXh0cmFQYXRoID0gdGhpcy5leHRyYVNlZ21lbnRzLmpvaW4oJy4nKSArIChyZWxQYXRoID8gJy4nICsgcmVsUGF0aCA6ICcnKTtcbiAgcmV0dXJuIHRoaXMubW9kZWwucmVmKGZyb20sIGV4dHJhUGF0aCk7XG59O1xuXG5RdWVyeS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBbXG4gICAgdGhpcy5jb2xsZWN0aW9uTmFtZVxuICAsIHRoaXMuZXhwcmVzc2lvblxuICAsIHRoaXMuc291cmNlXG4gICwgdGhpcy5zdWJzY3JpYmVDb3VudFxuICAsIHRoaXMuZmV0Y2hDb3VudFxuICAsIHRoaXMuZmV0Y2hJZHNcbiAgXTtcbn07XG5cbmZ1bmN0aW9uIHF1ZXJ5SGFzaChjb2xsZWN0aW9uTmFtZSwgZXhwcmVzc2lvbiwgc291cmNlKSB7XG4gIHZhciBhcmdzID0gW2NvbGxlY3Rpb25OYW1lLCBleHByZXNzaW9uLCBzb3VyY2VdO1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJncykucmVwbGFjZSgvXFwuL2csICd8Jyk7XG59XG5cbmZ1bmN0aW9uIHJlc3VsdHNJZHMocmVzdWx0cykge1xuICB2YXIgaWRzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzaGFyZURvYyA9IHJlc3VsdHNbaV07XG4gICAgaWRzLnB1c2goc2hhcmVEb2MubmFtZSk7XG4gIH1cbiAgcmV0dXJuIGlkcztcbn1cblxuZnVuY3Rpb24gcGF0aElkcyhtb2RlbCwgc2VnbWVudHMpIHtcbiAgdmFyIHZhbHVlID0gbW9kZWwuX2dldChzZWdtZW50cyk7XG4gIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgPyBbdmFsdWVdIDpcbiAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpID8gdmFsdWUuc2xpY2UoKSA6IFtdO1xufVxuXG5mdW5jdGlvbiBjb2xsZWN0aW9uU2hhcmVEb2NzKG1vZGVsLCBjb2xsZWN0aW9uTmFtZSkge1xuICB2YXIgY29sbGVjdGlvbiA9IG1vZGVsLmdldENvbGxlY3Rpb24oY29sbGVjdGlvbk5hbWUpO1xuICBpZiAoIWNvbGxlY3Rpb24pIHJldHVybjtcblxuICB2YXIgcmVzdWx0cyA9IFtdO1xuICBmb3IgKHZhciBuYW1lIGluIGNvbGxlY3Rpb24uZG9jcykge1xuICAgIHJlc3VsdHMucHVzaChjb2xsZWN0aW9uLmRvY3NbbmFtZV0uc2hhcmVEb2MpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cblxufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9wcm9jZXNzXCIpKSIsInZhciBxcyA9IHJlcXVpcmUoJ3FzJylcbnZhciBwYXJzZVVybCA9IHJlcXVpcmUoJ3VybCcpLnBhcnNlXG52YXIgcmVzb2x2ZVVybCA9IHJlcXVpcmUoJ3VybCcpLnJlc29sdmVcbnZhciByZW5kZXJSb3V0ZSA9IHJlcXVpcmUoJy4vcm91dGVyJykucmVuZGVyXG52YXIgY3VycmVudFBhdGggPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoXG5cbi8vIFJlcGxhY2UgdGhlIGluaXRpYWwgc3RhdGUgd2l0aCB0aGUgY3VycmVudCBVUkwgaW1tZWRpYXRlbHksXG4vLyBzbyB0aGF0IGl0IHdpbGwgYmUgcmVuZGVyZWQgaWYgdGhlIHN0YXRlIGlzIGxhdGVyIHBvcHBlZFxuaWYgKHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSkge1xuICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoe1xuICAgICRyZW5kZXI6IHRydWUsXG4gICAgJG1ldGhvZDogJ2dldCdcbiAgfSwgbnVsbCwgd2luZG93LmxvY2F0aW9uLmhyZWYpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gSGlzdG9yeVxuXG5mdW5jdGlvbiBIaXN0b3J5KGNyZWF0ZVBhZ2UsIHJvdXRlcykge1xuICB0aGlzLl9jcmVhdGVQYWdlID0gY3JlYXRlUGFnZVxuICB0aGlzLl9yb3V0ZXMgPSByb3V0ZXNcblxuICBpZiAod2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKSB7XG4gICAgYWRkTGlzdGVuZXJzKHRoaXMpXG4gICAgcmV0dXJuXG4gIH1cbiAgdGhpcy5wdXNoID0gZnVuY3Rpb24odXJsKSB7XG4gICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbih1cmwpXG4gIH1cbiAgdGhpcy5yZXBsYWNlID0gZnVuY3Rpb24odXJsKSB7XG4gICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UodXJsKVxuICB9XG4gIHRoaXMucmVmcmVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICB9XG59XG5cbkhpc3RvcnkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbih1cmwsIHJlbmRlciwgc3RhdGUsIGUpIHtcbiAgdGhpcy5fdXBkYXRlKCdwdXNoU3RhdGUnLCB1cmwsIHJlbmRlciwgc3RhdGUsIGUpXG59XG5cbkhpc3RvcnkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbih1cmwsIHJlbmRlciwgc3RhdGUsIGUpIHtcbiAgdGhpcy5fdXBkYXRlKCdyZXBsYWNlU3RhdGUnLCB1cmwsIHJlbmRlciwgc3RhdGUsIGUpXG59XG5cbi8vIFJlcmVuZGVyIHRoZSBjdXJyZW50IHVybCBsb2NhbGx5XG5IaXN0b3J5LnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRoID0gcm91dGVQYXRoKHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICByZW5kZXJSb3V0ZSh0aGlzLnBhZ2UoKSwge3VybDogcGF0aCwgcHJldmlvdXM6IHBhdGgsIG1ldGhvZDogJ2dldCd9KVxufVxuXG5IaXN0b3J5LnByb3RvdHlwZS5iYWNrID0gZnVuY3Rpb24oKSB7XG4gIHdpbmRvdy5oaXN0b3J5LmJhY2soKVxufVxuXG5IaXN0b3J5LnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24oKSB7XG4gIHdpbmRvdy5oaXN0b3J5LmZvcndhcmQoKVxufVxuXG5IaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uKGkpIHtcbiAgd2luZG93Lmhpc3RvcnkuZ28oaSlcbn1cblxuSGlzdG9yeS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uKGhpc3RvcnlNZXRob2QsIHJlbGF0aXZlVXJsLCByZW5kZXIsIHN0YXRlLCBlKSB7XG4gIHZhciB1cmwgPSByZXNvbHZlVXJsKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCByZWxhdGl2ZVVybClcbiAgdmFyIHBhdGggPSByb3V0ZVBhdGgodXJsKVxuXG4gIC8vIFRPRE86IGhpc3RvcnkucHVzaCBzaG91bGQgc2V0IHRoZSB3aW5kb3cubG9jYXRpb24gd2l0aCBleHRlcm5hbCB1cmxzXG4gIGlmICghcGF0aCkgcmV0dXJuXG4gIGlmIChyZW5kZXIgPT0gbnVsbCkgcmVuZGVyID0gdHJ1ZVxuICBpZiAoc3RhdGUgPT0gbnVsbCkgc3RhdGUgPSB7fVxuXG4gIC8vIFVwZGF0ZSB0aGUgVVJMXG4gIHZhciBvcHRpb25zID0gcmVuZGVyT3B0aW9ucyhlLCBwYXRoKVxuICBzdGF0ZS4kcmVuZGVyID0gdHJ1ZVxuICBzdGF0ZS4kbWV0aG9kID0gb3B0aW9ucy5tZXRob2RcbiAgd2luZG93Lmhpc3RvcnlbaGlzdG9yeU1ldGhvZF0oc3RhdGUsIG51bGwsIG9wdGlvbnMudXJsKVxuICBjdXJyZW50UGF0aCA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2hcbiAgaWYgKHJlbmRlcikgcmVuZGVyUm91dGUodGhpcy5wYWdlKCksIG9wdGlvbnMsIGUpXG59XG5cbkhpc3RvcnkucHJvdG90eXBlLnBhZ2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3BhZ2UpIHJldHVybiB0aGlzLl9wYWdlXG5cbiAgdmFyIHBhZ2UgPSB0aGlzLl9wYWdlID0gdGhpcy5fY3JlYXRlUGFnZSgpXG4gIHZhciBoaXN0b3J5ID0gdGhpc1xuXG4gIGZ1bmN0aW9uIHJlZGlyZWN0KHVybCkge1xuICAgIGlmICh1cmwgPT09ICdiYWNrJykgcmV0dXJuIGhpc3RvcnkuYmFjaygpXG4gICAgLy8gVE9ETzogQWRkIHN1cHBvcnQgZm9yIGBiYXNlcGF0aGAgb3B0aW9uIGxpa2UgRXhwcmVzc1xuICAgIGlmICh1cmwgPT09ICdob21lJykgdXJsID0gJ1xcXFwnXG4gICAgaGlzdG9yeS5yZXBsYWNlKHVybCwgdHJ1ZSlcbiAgfVxuXG4gIHBhZ2UucmVkaXJlY3QgPSByZWRpcmVjdFxuICBwYWdlLl9yb3V0ZXMgPSB0aGlzLl9yb3V0ZXNcbiAgcmV0dXJuIHBhZ2Vcbn1cblxuLy8gR2V0IHRoZSBwYXRobmFtZSBpZiBpdCBpcyBvbiB0aGUgc2FtZSBwcm90b2NvbCBhbmQgZG9tYWluXG5mdW5jdGlvbiByb3V0ZVBhdGgodXJsKSB7XG4gIHZhciBtYXRjaCA9IHBhcnNlVXJsKHVybClcbiAgcmV0dXJuIG1hdGNoICYmXG4gICAgbWF0Y2gucHJvdG9jb2wgPT09IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCAmJlxuICAgIG1hdGNoLmhvc3QgPT09IHdpbmRvdy5sb2NhdGlvbi5ob3N0ICYmXG4gICAgbWF0Y2gucGF0aG5hbWUgKyAobWF0Y2guc2VhcmNoIHx8ICcnKVxufVxuXG5mdW5jdGlvbiByZW5kZXJPcHRpb25zKGUsIHBhdGgpIHtcbiAgLy8gSWYgdGhpcyBpcyBhIGZvcm0gc3VibWlzc2lvbiwgZXh0cmFjdCB0aGUgZm9ybSBkYXRhIGFuZFxuICAvLyBhcHBlbmQgaXQgdG8gdGhlIHVybCBmb3IgYSBnZXQgb3IgcGFyYW1zLmJvZHkgZm9yIGEgcG9zdFxuICBpZiAoZSAmJiBlLnR5cGUgPT09ICdzdWJtaXQnKSB7XG4gICAgdmFyIGZvcm0gPSBlLnRhcmdldFxuICAgIHZhciBlbGVtZW50cyA9IGZvcm0uZWxlbWVudHNcbiAgICB2YXIgcXVlcnkgPSBbXVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbGVtZW50cy5sZW5ndGgsIGVsOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGVsID0gZWxlbWVudHNbaV1cbiAgICAgIHZhciBuYW1lID0gZWwubmFtZVxuICAgICAgaWYgKCFuYW1lKSBjb250aW51ZVxuICAgICAgdmFyIHZhbHVlID0gZWwudmFsdWVcbiAgICAgIHF1ZXJ5LnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSlcbiAgICAgIGlmIChuYW1lID09PSAnX21ldGhvZCcpIHtcbiAgICAgICAgdmFyIG92ZXJyaWRlID0gdmFsdWUudG9Mb3dlckNhc2UoKVxuICAgICAgICBpZiAob3ZlcnJpZGUgPT09ICdkZWxldGUnKSBvdmVycmlkZSA9ICdkZWwnXG4gICAgICB9XG4gICAgfVxuICAgIHF1ZXJ5ID0gcXVlcnkuam9pbignJicpXG4gICAgaWYgKGZvcm0ubWV0aG9kLnRvTG93ZXJDYXNlKCkgPT09ICdwb3N0Jykge1xuICAgICAgdmFyIG1ldGhvZCA9IG92ZXJyaWRlIHx8ICdwb3N0J1xuICAgICAgdmFyIGJvZHkgPSBxcy5wYXJzZShxdWVyeSlcbiAgICB9IGVsc2Uge1xuICAgICAgbWV0aG9kID0gJ2dldCdcbiAgICAgIHBhdGggKz0gJz8nICsgcXVlcnlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWV0aG9kID0gJ2dldCdcbiAgfVxuICByZXR1cm4ge1xuICAgIG1ldGhvZDogbWV0aG9kXG4gICwgdXJsOiBwYXRoXG4gICwgcHJldmlvdXM6IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2hcbiAgLCBib2R5OiBib2R5XG4gICwgZm9ybTogZm9ybVxuICAsIGxpbms6IGUgJiYgZS5fdHJhY2tzTGlua1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZExpc3RlbmVycyhoaXN0b3J5KSB7XG5cbiAgLy8gRGV0ZWN0IGNsaWNrcyBvbiBsaW5rc1xuICBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICB2YXIgZWwgPSBlLnRhcmdldFxuXG4gICAgLy8gSWdub3JlIGNvbW1hbmQgY2xpY2ssIGNvbnRyb2wgY2xpY2ssIGFuZCBub24tbGVmdCBjbGlja1xuICAgIGlmIChlLm1ldGFLZXkgfHwgZS53aGljaCAhPT0gMSkgcmV0dXJuXG5cbiAgICAvLyBJZ25vcmUgaWYgYWxyZWFkeSBwcmV2ZW50ZWRcbiAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkIHx8IGUucmV0dXJuVmFsdWUgPT09IGZhbHNlKSByZXR1cm5cblxuICAgIC8vIEFsc28gbG9vayB1cCBmb3IgcGFyZW50IGxpbmtzICg8YT48aW1nPjwvYT4pXG4gICAgd2hpbGUgKGVsKSB7XG4gICAgICB2YXIgdXJsID0gZWwuaHJlZlxuICAgICAgaWYgKHVybCkge1xuXG4gICAgICAgIC8vIElnbm9yZSBpZiBjcmVhdGVkIGJ5IFRyYWNrc1xuICAgICAgICBpZiAoZWwuaGFzQXR0cmlidXRlICYmIGVsLmhhc0F0dHJpYnV0ZSgnZGF0YS1yb3V0ZXItaWdub3JlJykpIHJldHVyblxuXG4gICAgICAgIC8vIElnbm9yZSBsaW5rcyBtZWFudCB0byBvcGVuIGluIGEgZGlmZmVyZW50IHdpbmRvdyBvciBmcmFtZVxuICAgICAgICBpZiAoZWwudGFyZ2V0ICYmIGVsLnRhcmdldCAhPT0gJ19zZWxmJykgcmV0dXJuXG5cbiAgICAgICAgLy8gSWdub3JlIGhhc2ggbGlua3MgdG8gdGhlIHNhbWUgcGFnZVxuICAgICAgICB2YXIgaGFzaEluZGV4ID0gdXJsLmluZGV4T2YoJyMnKVxuICAgICAgICBpZiAofmhhc2hJbmRleCAmJiB1cmwuc2xpY2UoMCwgaGFzaEluZGV4KSA9PT0gd2luZG93LmxvY2F0aW9uLmhyZWYucmVwbGFjZSgvIy4qLywgJycpKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBlLl90cmFja3NMaW5rID0gZWxcbiAgICAgICAgaGlzdG9yeS5wdXNoKHVybCwgdHJ1ZSwgbnVsbCwgZSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGVsID0gZWwucGFyZW50Tm9kZVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uU3VibWl0KGUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXRcblxuICAgIC8vIElnbm9yZSBpZiBhbHJlYWR5IHByZXZlbnRlZFxuICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQgfHwgZS5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UpIHJldHVyblxuXG4gICAgLy8gT25seSBoYW5kbGUgaWYgZW1pdHRlZCBvbiBhIGZvcm0gZWxlbWVudCB0aGF0IGlzbid0IG11bHRpcGFydFxuICAgIGlmICh0YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnZm9ybScpIHJldHVyblxuICAgIGlmICh0YXJnZXQuZW5jdHlwZSA9PT0gJ211bHRpcGFydC9mb3JtLWRhdGEnKSByZXR1cm5cblxuICAgIC8vIElnbm9yZSBpZiBjcmVhdGVkIGJ5IFRyYWNrc1xuICAgIGlmICh0YXJnZXQuaGFzQXR0cmlidXRlICYmIHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2RhdGEtcm91dGVyLWlnbm9yZScpKSByZXR1cm5cblxuICAgIC8vIFVzZSB0aGUgdXJsIGZyb20gdGhlIGZvcm0gYWN0aW9uLCBkZWZhdWx0aW5nIHRvIHRoZSBjdXJyZW50IHVybFxuICAgIHZhciB1cmwgPSB0YXJnZXQuYWN0aW9uIHx8IHdpbmRvdy5sb2NhdGlvbi5ocmVmXG4gICAgaGlzdG9yeS5wdXNoKHVybCwgdHJ1ZSwgbnVsbCwgZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUG9wU3RhdGUoZSkge1xuICAgIHZhciBwcmV2aW91cyA9IGN1cnJlbnRQYXRoXG4gICAgdmFyIHN0YXRlID0gZS5zdGF0ZVxuICAgIGN1cnJlbnRQYXRoID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaFxuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBwcmV2aW91czogcHJldmlvdXNcbiAgICAsIHVybDogY3VycmVudFBhdGhcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIGlmICghc3RhdGUuJHJlbmRlcikgcmV0dXJuXG4gICAgICBvcHRpb25zLm1ldGhvZCA9IHN0YXRlLiRtZXRob2RcbiAgICAgIC8vIE5vdGUgdGhhdCB0aGUgcG9zdCBib2R5IGlzIG9ubHkgc2VudCBvbiB0aGUgaW5pdGlhbCByZXFlc3RcbiAgICAgIC8vIGFuZCBpdCBpcyBlbXB0eSBpZiB0aGUgc3RhdGUgaXMgbGF0ZXIgcG9wcGVkXG4gICAgICByZXR1cm4gcmVuZGVyUm91dGUoaGlzdG9yeS5wYWdlKCksIG9wdGlvbnMpXG4gICAgfVxuXG4gICAgLy8gVGhlIHN0YXRlIG9iamVjdCB3aWxsIGJlIG51bGwgZm9yIHN0YXRlcyBjcmVhdGVkIGJ5IGp1bXAgbGlua3MuXG4gICAgLy8gd2luZG93LmxvY2F0aW9uLmhhc2ggY2Fubm90IGJlIHVzZWQsIGJlY2F1c2UgaXQgcmV0dXJucyBub3RoaW5nXG4gICAgLy8gaWYgdGhlIHVybCBlbmRzIGluIGp1c3QgYSBoYXNoIGNoYXJhY3RlclxuICAgIHZhciB1cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZlxuICAgICAgLCBoYXNoSW5kZXggPSB1cmwuaW5kZXhPZignIycpXG4gICAgICAsIGVsLCBpZFxuICAgIGlmICh+aGFzaEluZGV4ICYmIGN1cnJlbnRQYXRoICE9PSBwcmV2aW91cykge1xuICAgICAgb3B0aW9ucy5tZXRob2QgPSAnZ2V0J1xuICAgICAgcmVuZGVyUm91dGUoaGlzdG9yeS5wYWdlKCksIG9wdGlvbnMpXG4gICAgICBpZCA9IHVybC5zbGljZShoYXNoSW5kZXggKyAxKVxuICAgICAgaWYgKGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKGlkKVswXSkge1xuICAgICAgICBlbC5zY3JvbGxJbnRvVmlldygpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbkNsaWNrLCBmYWxzZSlcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc3VibWl0Jywgb25TdWJtaXQsIGZhbHNlKVxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBvblBvcFN0YXRlLCBmYWxzZSlcbn1cbiIsInZhciBxcyA9IHJlcXVpcmUoJ3FzJylcbnZhciBub2RlVXJsID0gcmVxdWlyZSgndXJsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByZW5kZXI6IHJlbmRlclxuLCBpc1RyYW5zaXRpb25hbDogaXNUcmFuc2l0aW9uYWxcbiwgbWFwUm91dGU6IG1hcFJvdXRlXG59XG5cbmZ1bmN0aW9uIGlzVHJhbnNpdGlvbmFsKHBhdHRlcm4pIHtcbiAgcmV0dXJuIHBhdHRlcm4uaGFzT3duUHJvcGVydHkoJ2Zyb20nKSAmJiBwYXR0ZXJuLmhhc093blByb3BlcnR5KCd0bycpXG59XG5cbmZ1bmN0aW9uIG1hcFJvdXRlKGZyb20sIHBhcmFtcykge1xuICB2YXIgaSA9IHBhcmFtcy51cmwuaW5kZXhPZignPycpXG4gIHZhciBxdWVyeVN0cmluZyA9ICh+aSkgPyBwYXJhbXMudXJsLnNsaWNlKGkpIDogJydcbiAgLy8gSWYgdGhlIHJvdXRlIGxvb2tzIGxpa2UgLzphLzpiPy86Yy86ZD9cbiAgLy8gYW5kIDpiIGFuZCA6ZCBhcmUgbWlzc2luZywgcmV0dXJuIC9hL2NcbiAgLy8gVGh1cywgc2tpcCB0aGUgLyBpZiB0aGUgdmFsdWUgaXMgbWlzc2luZ1xuICB2YXIgaSA9IDBcbiAgdmFyIHBhdGggPSBmcm9tLnJlcGxhY2UoL1xcLyg/Oig/OlxcOihbXj9cXC86Kl0rKSl8XFwqKShcXD8pPy9nLCBvbk1hdGNoKVxuICBmdW5jdGlvbiBvbk1hdGNoKG1hdGNoLCBrZXksIG9wdGlvbmFsKSB7XG4gICAgdmFyIHZhbHVlID0ga2V5ID8gcGFyYW1zW2tleV0gOiBwYXJhbXNbaSsrXVxuICAgIHJldHVybiAob3B0aW9uYWwgJiYgdmFsdWUgPT09IHZvaWQgMCkgPyAnJyA6ICcvJyArIHZhbHVlXG4gIH1cbiAgcmV0dXJuIHBhdGggKyBxdWVyeVN0cmluZ1xufVxuXG5mdW5jdGlvbiByZW5kZXIocGFnZSwgb3B0aW9ucywgZSkge1xuICB2YXIgcmVxID0gbmV3IFJlbmRlclJlcShwYWdlLCBvcHRpb25zLCBlKVxuICByZXEucm91dGVUcmFuc2l0aW9uYWwoMCwgZnVuY3Rpb24oKSB7XG4gICAgcmVxLnJvdXRlUXVldWUoMCwgZnVuY3Rpb24oKSB7XG4gICAgICByZXEucm91dGVBbmRUcmFuc2l0aW9uKDAsIGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBDYW5jZWwgcmVuZGVyaW5nIGJ5IHRoaXMgYXBwIGlmIG5vIHJvdXRlcyBtYXRjaFxuICAgICAgICByZXEuY2FuY2VsKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gUmVuZGVyUmVxKHBhZ2UsIG9wdGlvbnMsIGUpIHtcbiAgdGhpcy5wYWdlID0gcGFnZVxuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gIHRoaXMuZSA9IGVcbiAgdGhpcy5zZXRVcmwob3B0aW9ucy51cmwucmVwbGFjZSgvIy4qLywgJycpKVxuICB2YXIgcXVlcnlTdHJpbmcgPSBub2RlVXJsLnBhcnNlKHRoaXMudXJsKS5xdWVyeTtcbiAgdGhpcy5xdWVyeSA9IHF1ZXJ5U3RyaW5nID8gcXMucGFyc2UocXVlcnlTdHJpbmcpIDoge31cbiAgdGhpcy5tZXRob2QgPSBvcHRpb25zLm1ldGhvZFxuICB0aGlzLmJvZHkgPSBvcHRpb25zLmJvZHkgfHwge31cbiAgdGhpcy5wcmV2aW91cyA9IG9wdGlvbnMucHJldmlvdXNcbiAgdmFyIHJvdXRlcyA9IHBhZ2UuX3JvdXRlc1xuICB0aGlzLnRyYW5zaXRpb25hbCA9IHJvdXRlcy50cmFuc2l0aW9uYWxbdGhpcy5tZXRob2RdXG4gIHRoaXMucXVldWUgPSByb3V0ZXMucXVldWVbdGhpcy5tZXRob2RdXG4gIHRoaXMub25Sb3V0ZSA9IHJvdXRlcy5vblJvdXRlXG59XG5cblJlbmRlclJlcS5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIHRoaXMgaXMgdGhlIHJlc3VsdCBvZiBhbiBldmVudCwgc2luY2UgdGhlXG4gIC8vIGFwcHJvcHJpYXRlIGFjdGlvbiB3aWxsIGhhcHBlbiBieSBkZWZhdWx0XG4gIGlmICh0aGlzLmUgfHwgb3B0aW9ucy5ub05hdmlnYXRlKSByZXR1cm5cbiAgLy8gT3RoZXJ3aXNlLCBtYW51YWxseSBwZXJmb3JtIGFwcHJvcHJpYXRlIGFjdGlvblxuICBpZiAob3B0aW9ucy5mb3JtKSB7XG4gICAgb3B0aW9ucy5mb3JtLnNldEF0dHJpYnV0ZSgnZGF0YS1yb3V0ZXItaWdub3JlJywgJycpXG4gICAgb3B0aW9ucy5mb3JtLnN1Ym1pdCgpXG4gIH0gZWxzZSBpZiAob3B0aW9ucy5saW5rKSB7XG4gICAgb3B0aW9ucy5saW5rLnNldEF0dHJpYnV0ZSgnZGF0YS1yb3V0ZXItaWdub3JlJywgJycpXG4gICAgb3B0aW9ucy5saW5rLmNsaWNrKClcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKG9wdGlvbnMudXJsKVxuICB9XG59XG5cblJlbmRlclJlcS5wcm90b3R5cGUuc2V0VXJsID0gZnVuY3Rpb24odXJsKSB7XG4gIHRoaXMudXJsID0gdXJsXG4gIHRoaXMucGF0aCA9IHRoaXMudXJsLnJlcGxhY2UoL1xcPy4qLywgJycpXG59XG5cblJlbmRlclJlcS5wcm90b3R5cGUucm91dGVUcmFuc2l0aW9uYWwgPSBmdW5jdGlvbihpLCBuZXh0KSB7XG4gIGkgfHwgKGkgPSAwKVxuICB2YXIgaXRlbVxuICB3aGlsZSAoaXRlbSA9IHRoaXMudHJhbnNpdGlvbmFsW2krK10pIHtcbiAgICBpZiAoIWl0ZW0udG8ubWF0Y2godGhpcy5wYXRoKSB8fCAhaXRlbS5mcm9tLm1hdGNoKHRoaXMucHJldmlvdXMpKSBjb250aW51ZVxuICAgIHZhciByZXEgPSB0aGlzXG4gICAgdmFyIG90aGVyUGFyYW1zID0gdGhpcy5yb3V0ZVBhcmFtcyhpdGVtLmZyb20pXG4gICAgdmFyIHBhcmFtcyA9IHRoaXMucm91dGVQYXJhbXMoaXRlbS50bywgb3RoZXJQYXJhbXMpXG4gICAgLy8gRXZlbiB0aG91Z2ggd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZyBhZnRlciBhIGRvbmUsIHBhc3MgYVxuICAgIC8vIG5vIG9wIGZ1bmN0aW9uLCBzbyB0aGF0IHJvdXRlcyBjYW4gZXhwZWN0IGl0IHRvIGJlIGRlZmluZWRcbiAgICBmdW5jdGlvbiBkb25lKCkge31cbiAgICB0aGlzLm9uTWF0Y2goaXRlbS50bywgcGFyYW1zLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiByZXEuY2FuY2VsKClcbiAgICAgIHJlcS5yb3V0ZVRyYW5zaXRpb25hbChpLCBuZXh0KVxuICAgIH0sIGRvbmUpXG4gICAgcmV0dXJuXG4gIH1cbiAgbmV4dCgpXG59XG5cblJlbmRlclJlcS5wcm90b3R5cGUucm91dGVRdWV1ZSA9IGZ1bmN0aW9uKGksIG5leHQpIHtcbiAgaSB8fCAoaSA9IDApXG4gIHZhciByb3V0ZVxuICB3aGlsZSAocm91dGUgPSB0aGlzLnF1ZXVlW2krK10pIHtcbiAgICBpZiAoIXJvdXRlLm1hdGNoKHRoaXMucGF0aCkpIGNvbnRpbnVlXG4gICAgdmFyIHJlcSA9IHRoaXNcbiAgICB2YXIgcGFyYW1zID0gdGhpcy5yb3V0ZVBhcmFtcyhyb3V0ZSlcbiAgICB0aGlzLm9uTWF0Y2gocm91dGUsIHBhcmFtcywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gcmVxLmNhbmNlbCgpXG4gICAgICByZXEucm91dGVRdWV1ZShpLCBuZXh0KVxuICAgIH0pXG4gICAgcmV0dXJuXG4gIH1cbiAgbmV4dCgpXG59XG5cblJlbmRlclJlcS5wcm90b3R5cGUucm91dGVBbmRUcmFuc2l0aW9uID0gZnVuY3Rpb24oaSwgbmV4dCkge1xuICBpIHx8IChpID0gMClcbiAgdmFyIHJlbmRlciA9IHRoaXMucGFnZS5yZW5kZXJcbiAgdmFyIGl0ZW1cbiAgd2hpbGUgKGl0ZW0gPSB0aGlzLnRyYW5zaXRpb25hbFtpKytdKSB7XG4gICAgaWYgKCFpdGVtLnRvLm1hdGNoKHRoaXMucGF0aCkpIGNvbnRpbnVlXG4gICAgdmFyIHVybCA9IHRoaXMudXJsXG4gICAgdmFyIHBhcmFtcyA9IHRoaXMucm91dGVQYXJhbXMoaXRlbS50bylcbiAgICB0aGlzLnNldFVybChtYXBSb3V0ZShpdGVtLmZyb20ucGF0aCwgcGFyYW1zKSlcbiAgICB2YXIgcmVxID0gdGhpc1xuICAgIHZhciBza2lwcGVkID0gZmFsc2VcbiAgICBmdW5jdGlvbiBjb250aW51ZU5leHQoKSB7XG4gICAgICBza2lwcGVkID0gdHJ1ZVxuICAgICAgcmVxLnNldFVybCh1cmwpXG4gICAgICByZXEucGFnZS5yZW5kZXIgPSByZW5kZXJcbiAgICAgIHJlcS5yb3V0ZUFuZFRyYW5zaXRpb24oaSwgbmV4dClcbiAgICB9XG4gICAgdGhpcy5wYWdlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlbmRlckFyZ3VtZW50cyA9IGFyZ3VtZW50c1xuICAgICAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgICAgaWYgKHNraXBwZWQpIHJldHVyblxuICAgICAgICByZXEucGFnZS5yZW5kZXIgPSByZW5kZXJcbiAgICAgICAgcmVuZGVyLmFwcGx5KHJlcS5wYWdlLCByZW5kZXJBcmd1bWVudHMpXG4gICAgICB9XG4gICAgICByZXEuc2V0VXJsKHVybClcbiAgICAgIHZhciBpc0FzeW5jID0gcmVxLm9uTWF0Y2goaXRlbS50bywgcGFyYW1zLCBjb250aW51ZU5leHQsIGRvbmUpXG4gICAgICBpZiAoaXNBc3luYykgcmV0dXJuXG4gICAgICBkb25lKClcbiAgICB9XG4gICAgdGhpcy5yb3V0ZVF1ZXVlKDAsIGNvbnRpbnVlTmV4dClcbiAgICByZXR1cm5cbiAgfVxuICBuZXh0KClcbn1cblxuUmVuZGVyUmVxLnByb3RvdHlwZS5vbk1hdGNoID0gZnVuY3Rpb24ocm91dGUsIHBhcmFtcywgbmV4dCwgZG9uZSkge1xuICAvLyBTdG9wIHRoZSBkZWZhdWx0IGJyb3dzZXIgYWN0aW9uLCBzdWNoIGFzIGNsaWNraW5nIGEgbGluayBvciBzdWJtaXR0aW5nIGEgZm9ybVxuICBpZiAodGhpcy5lKSB7XG4gICAgdGhpcy5lLnByZXZlbnREZWZhdWx0KClcbiAgICB0aGlzLmUgPSBudWxsXG4gIH1cbiAgdGhpcy5wYWdlLnBhcmFtcyA9IHBhcmFtc1xuICByZXR1cm4gdGhpcy5vblJvdXRlKFxuICAgIHJvdXRlLmNhbGxiYWNrc1xuICAsIHRoaXMucGFnZVxuICAsIHRoaXMucGFnZS5wYXJhbXNcbiAgLCBuZXh0XG4gICwgcm91dGUuaXNUcmFuc2l0aW9uYWxcbiAgLCBkb25lXG4gIClcbn1cblxuUmVuZGVyUmVxLnByb3RvdHlwZS5yb3V0ZVBhcmFtcyA9IGZ1bmN0aW9uKHJvdXRlLCBvdGhlclBhcmFtcykge1xuICB2YXIgcm91dGVQYXJhbXMgPSByb3V0ZS5wYXJhbXNcbiAgdmFyIHBhcmFtcyA9IHJvdXRlUGFyYW1zLnNsaWNlKClcbiAgaWYgKG90aGVyUGFyYW1zKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG90aGVyUGFyYW1zKSB7XG4gICAgICBwYXJhbXNba2V5XSA9IG90aGVyUGFyYW1zW2tleV1cbiAgICB9XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIHJvdXRlUGFyYW1zKSB7XG4gICAgcGFyYW1zW2tleV0gPSByb3V0ZVBhcmFtc1trZXldXG4gIH1cbiAgcGFyYW1zLnByZXZpb3VzID0gdGhpcy5wcmV2aW91c1xuICBwYXJhbXMudXJsID0gdGhpcy51cmxcbiAgcGFyYW1zLmJvZHkgPSB0aGlzLmJvZHlcbiAgcGFyYW1zLnF1ZXJ5ID0gdGhpcy5xdWVyeVxuICBwYXJhbXMubWV0aG9kID0gdGhpcy5tZXRob2RcbiAgcmV0dXJuIHBhcmFtc1xufVxuIiwicmVxdWlyZT0oZnVuY3Rpb24oZSx0LG4scil7ZnVuY3Rpb24gaShyKXtpZighbltyXSl7aWYoIXRbcl0pe2lmKGUpcmV0dXJuIGUocik7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIityK1wiJ1wiKX12YXIgcz1uW3JdPXtleHBvcnRzOnt9fTt0W3JdWzBdKGZ1bmN0aW9uKGUpe3ZhciBuPXRbcl1bMV1bZV07cmV0dXJuIGkobj9uOmUpfSxzLHMuZXhwb3J0cyl9cmV0dXJuIG5bcl0uZXhwb3J0c31mb3IodmFyIHM9MDtzPHIubGVuZ3RoO3MrKylpKHJbc10pO3JldHVybiBpfSkodHlwZW9mIHJlcXVpcmUhPT1cInVuZGVmaW5lZFwiJiZyZXF1aXJlLHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmV4cG9ydHMucmVhZElFRUU3NTQgPSBmdW5jdGlvbihidWZmZXIsIG9mZnNldCwgaXNCRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIG5CaXRzID0gLTcsXG4gICAgICBpID0gaXNCRSA/IDAgOiAobkJ5dGVzIC0gMSksXG4gICAgICBkID0gaXNCRSA/IDEgOiAtMSxcbiAgICAgIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07XG5cbiAgaSArPSBkO1xuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBzID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gZUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIGUgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7XG59O1xuXG5leHBvcnRzLndyaXRlSUVFRTc1NCA9IGZ1bmN0aW9uKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKSxcbiAgICAgIGkgPSBpc0JFID8gKG5CeXRlcyAtIDEpIDogMCxcbiAgICAgIGQgPSBpc0JFID8gLTEgOiAxLFxuICAgICAgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDtcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn07XG5cbn0se31dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uKCl7Ly8gVVRJTElUWVxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7XG52YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG5mdW5jdGlvbiBvYmplY3RLZXlzKG9iamVjdCkge1xuICBpZiAoT2JqZWN0LmtleXMpIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIG5hbWUpKSB7XG4gICAgICByZXN1bHQucHVzaChuYW1lKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gIHRoaXMuYWN0dWFsID0gb3B0aW9ucy5hY3R1YWw7XG4gIHRoaXMuZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xuICB0aGlzLm9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcjtcbiAgdmFyIHN0YWNrU3RhcnRGdW5jdGlvbiA9IG9wdGlvbnMuc3RhY2tTdGFydEZ1bmN0aW9uIHx8IGZhaWw7XG5cbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgfVxufTtcbnV0aWwuaW5oZXJpdHMoYXNzZXJ0LkFzc2VydGlvbkVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIHJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gJycgKyB2YWx1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAoaXNOYU4odmFsdWUpIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdHJ1bmNhdGUocywgbikge1xuICBpZiAodHlwZW9mIHMgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPCBuID8gcyA6IHMuc2xpY2UoMCwgbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5tZXNzYWdlKSB7XG4gICAgcmV0dXJuIFt0aGlzLm5hbWUgKyAnOicsIHRoaXMubWVzc2FnZV0uam9pbignICcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbXG4gICAgICB0aGlzLm5hbWUgKyAnOicsXG4gICAgICB0cnVuY2F0ZShKU09OLnN0cmluZ2lmeSh0aGlzLmFjdHVhbCwgcmVwbGFjZXIpLCAxMjgpLFxuICAgICAgdGhpcy5vcGVyYXRvcixcbiAgICAgIHRydW5jYXRlKEpTT04uc3RyaW5naWZ5KHRoaXMuZXhwZWN0ZWQsIHJlcGxhY2VyKSwgMTI4KVxuICAgIF0uam9pbignICcpO1xuICB9XG59O1xuXG4vLyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IgaW5zdGFuY2VvZiBFcnJvclxuXG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IuX19wcm90b19fID0gRXJyb3IucHJvdG90eXBlO1xuXG4vLyBBdCBwcmVzZW50IG9ubHkgdGhlIHRocmVlIGtleXMgbWVudGlvbmVkIGFib3ZlIGFyZSB1c2VkIGFuZFxuLy8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzXG4vLyBvdGhlciBrZXlzIHRvIHRoZSBBc3NlcnRpb25FcnJvcidzIGNvbnN0cnVjdG9yIC0gdGhleSB3aWxsIGJlXG4vLyBpZ25vcmVkLlxuXG4vLyAzLiBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiAgQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcbiAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogc3RhY2tTdGFydEZ1bmN0aW9uXG4gIH0pO1xufVxuXG4vLyBFWFRFTlNJT04hIGFsbG93cyBmb3Igd2VsbCBiZWhhdmVkIGVycm9ycyBkZWZpbmVkIGVsc2V3aGVyZS5cbmFzc2VydC5mYWlsID0gZmFpbDtcblxuLy8gNC4gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISFndWFyZC5cbi8vIGFzc2VydC5vayhndWFyZCwgbWVzc2FnZV9vcHQpO1xuLy8gVGhpcyBzdGF0ZW1lbnQgaXMgZXF1aXZhbGVudCB0byBhc3NlcnQuZXF1YWwodHJ1ZSwgZ3VhcmQsXG4vLyBtZXNzYWdlX29wdCk7LiBUbyB0ZXN0IHN0cmljdGx5IGZvciB0aGUgdmFsdWUgdHJ1ZSwgdXNlXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwodHJ1ZSwgZ3VhcmQsIG1lc3NhZ2Vfb3B0KTsuXG5cbmZ1bmN0aW9uIG9rKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghISF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09JywgYXNzZXJ0Lm9rKTtcbn1cbmFzc2VydC5vayA9IG9rO1xuXG4vLyA1LiBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGhcbi8vID09LlxuLy8gYXNzZXJ0LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5lcXVhbCk7XG59O1xuXG4vLyA2LiBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90IGVxdWFsXG4vLyB3aXRoICE9IGFzc2VydC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9JywgYXNzZXJ0Lm5vdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG4vLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoYWN0dWFsKSAmJiBCdWZmZXIuaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgaWYgKGFjdHVhbC5sZW5ndGggIT0gZXhwZWN0ZWQubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdHVhbC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFjdHVhbFtpXSAhPT0gZXhwZWN0ZWRbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICAvLyA3LjIuIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIERhdGUgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIERhdGUgb2JqZWN0IHRoYXQgcmVmZXJzIHRvIHRoZSBzYW1lIHRpbWUuXG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgRGF0ZSAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMy4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICh0eXBlb2YgYWN0dWFsICE9ICdvYmplY3QnICYmIHR5cGVvZiBleHBlY3RlZCAhPSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy40LiBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiKSB7XG4gIGlmIChpc1VuZGVmaW5lZE9yTnVsbChhKSB8fCBpc1VuZGVmaW5lZE9yTnVsbChiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAvL35+fkkndmUgbWFuYWdlZCB0byBicmVhayBPYmplY3Qua2V5cyB0aHJvdWdoIHNjcmV3eSBhcmd1bWVudHMgcGFzc2luZy5cbiAgLy8gICBDb252ZXJ0aW5nIHRvIGFycmF5IHNvbHZlcyB0aGUgcHJvYmxlbS5cbiAgaWYgKGlzQXJndW1lbnRzKGEpKSB7XG4gICAgaWYgKCFpc0FyZ3VtZW50cyhiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBfZGVlcEVxdWFsKGEsIGIpO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgICAga2IgPSBvYmplY3RLZXlzKGIpLFxuICAgICAgICBrZXksIGk7XG4gIH0gY2F0Y2ggKGUpIHsvL2hhcHBlbnMgd2hlbiBvbmUgaXMgYSBzdHJpbmcgbGl0ZXJhbCBhbmQgdGhlIG90aGVyIGlzbid0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIV9kZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIDguIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuLy8gYXNzZXJ0Lm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBFcXVhbCcsIGFzc2VydC5ub3REZWVwRXF1YWwpO1xuICB9XG59O1xuXG4vLyA5LiBUaGUgc3RyaWN0IGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzdHJpY3QgZXF1YWxpdHksIGFzIGRldGVybWluZWQgYnkgPT09LlxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09PScsIGFzc2VydC5zdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDEwLiBUaGUgc3RyaWN0IG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHN0cmljdCBpbmVxdWFsaXR5LCBhc1xuLy8gZGV0ZXJtaW5lZCBieSAhPT0uICBhc3NlcnQubm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT09JywgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoZXhwZWN0ZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gZXhwZWN0ZWQudGVzdChhY3R1YWwpO1xuICB9IGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBfdGhyb3dzKHNob3VsZFRocm93LCBibG9jaywgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGFjdHVhbDtcblxuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJykge1xuICAgIG1lc3NhZ2UgPSBleHBlY3RlZDtcbiAgICBleHBlY3RlZCA9IG51bGw7XG4gIH1cblxuICB0cnkge1xuICAgIGJsb2NrKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBhY3R1YWwgPSBlO1xuICB9XG5cbiAgbWVzc2FnZSA9IChleHBlY3RlZCAmJiBleHBlY3RlZC5uYW1lID8gJyAoJyArIGV4cGVjdGVkLm5hbWUgKyAnKS4nIDogJy4nKSArXG4gICAgICAgICAgICAobWVzc2FnZSA/ICcgJyArIG1lc3NhZ2UgOiAnLicpO1xuXG4gIGlmIChzaG91bGRUaHJvdyAmJiAhYWN0dWFsKSB7XG4gICAgZmFpbCgnTWlzc2luZyBleHBlY3RlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICBpZiAoIXNob3VsZFRocm93ICYmIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbCgnR290IHVud2FudGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICgoc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmIGV4cGVjdGVkICYmXG4gICAgICAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8ICghc2hvdWxkVGhyb3cgJiYgYWN0dWFsKSkge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfVxufVxuXG4vLyAxMS4gRXhwZWN0ZWQgdG8gdGhyb3cgYW4gZXJyb3I6XG4vLyBhc3NlcnQudGhyb3dzKGJsb2NrLCBFcnJvcl9vcHQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzLmFwcGx5KHRoaXMsIFt0cnVlXS5jb25jYXQocFNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xufTtcblxuLy8gRVhURU5TSU9OISBUaGlzIGlzIGFubm95aW5nIHRvIHdyaXRlIG91dHNpZGUgdGhpcyBtb2R1bGUuXG5hc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MuYXBwbHkodGhpcywgW2ZhbHNlXS5jb25jYXQocFNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xufTtcblxuYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbihlcnIpIHsgaWYgKGVycikge3Rocm93IGVycjt9fTtcblxufSkoKVxufSx7XCJ1dGlsXCI6MyxcImJ1ZmZlclwiOjR9XSxcImJ1ZmZlci1icm93c2VyaWZ5XCI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHM9cmVxdWlyZSgncTlUeENDJyk7XG59LHt9XSxcInE5VHhDQ1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbigpe2Z1bmN0aW9uIFNsb3dCdWZmZXIgKHNpemUpIHtcbiAgICB0aGlzLmxlbmd0aCA9IHNpemU7XG59O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MDtcblxuXG5mdW5jdGlvbiB0b0hleChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpO1xufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKylcbiAgICBpZiAoc3RyLmNoYXJDb2RlQXQoaSkgPD0gMHg3RilcbiAgICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBoID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0ci5jaGFyQXQoaSkpLnN1YnN0cigxKS5zcGxpdCgnJScpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoLmxlbmd0aDsgaisrKVxuICAgICAgICBieXRlQXJyYXkucHVzaChwYXJzZUludChoW2pdLCAxNikpO1xuICAgIH1cblxuICByZXR1cm4gYnl0ZUFycmF5O1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKyApXG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goIHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRiApO1xuXG4gIHJldHVybiBieXRlQXJyYXk7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMoc3RyKSB7XG4gIHJldHVybiByZXF1aXJlKFwiYmFzZTY0LWpzXCIpLnRvQnl0ZUFycmF5KHN0cik7XG59XG5cblNsb3dCdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIChzdHIsIGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoZW5jb2RpbmcgfHwgXCJ1dGY4XCIpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIHN0ci5sZW5ndGggLyAyO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoO1xuXG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gc3RyLmxlbmd0aDtcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYmxpdEJ1ZmZlcihzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIHBvcywgaSA9IDA7XG4gIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgaWYgKChpK29mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSlcbiAgICAgIGJyZWFrO1xuXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldO1xuICAgIGkrKztcbiAgfVxuICByZXR1cm4gaTtcbn1cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUudXRmOFdyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGJ5dGVzLCBwb3M7XG4gIHJldHVybiBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSAgYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcpLCB0aGlzLCBvZmZzZXQsIGxlbmd0aCk7XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5hc2NpaVdyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGJ5dGVzLCBwb3M7XG4gIHJldHVybiBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSAgYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgdGhpcywgb2Zmc2V0LCBsZW5ndGgpO1xufTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuYmluYXJ5V3JpdGUgPSBTbG93QnVmZmVyLnByb3RvdHlwZS5hc2NpaVdyaXRlO1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5iYXNlNjRXcml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBieXRlcywgcG9zO1xuICByZXR1cm4gU2xvd0J1ZmZlci5fY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIHRoaXMsIG9mZnNldCwgbGVuZ3RoKTtcbn07XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmJhc2U2NFNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgcmV0dXJuIHJlcXVpcmUoXCJiYXNlNjQtanNcIikuZnJvbUJ5dGVBcnJheShieXRlcyk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKTsgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUudXRmOFNsaWNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdmFyIHJlcyA9IFwiXCI7XG4gIHZhciB0bXAgPSBcIlwiO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgaWYgKGJ5dGVzW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gICAgICB0bXAgPSBcIlwiO1xuICAgIH0gZWxzZVxuICAgICAgdG1wICs9IFwiJVwiICsgYnl0ZXNbaV0udG9TdHJpbmcoMTYpO1xuXG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcCk7XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmFzY2lpU2xpY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBieXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB2YXIgcmV0ID0gXCJcIjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKylcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gIHJldHVybiByZXQ7XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmJpbmFyeVNsaWNlID0gU2xvd0J1ZmZlci5wcm90b3R5cGUuYXNjaWlTbGljZTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3V0ID0gW10sXG4gICAgICBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dFtpXSA9IHRvSGV4KHRoaXNbaV0pO1xuICAgIGlmIChpID09IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMpIHtcbiAgICAgIG91dFtpICsgMV0gPSAnLi4uJztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJzxTbG93QnVmZmVyICcgKyBvdXQuam9pbignICcpICsgJz4nO1xufTtcblxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5oZXhTbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDA7XG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW47XG5cbiAgdmFyIG91dCA9ICcnO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleCh0aGlzW2ldKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKTtcbiAgc3RhcnQgPSArc3RhcnQgfHwgMDtcbiAgaWYgKHR5cGVvZiBlbmQgPT0gJ3VuZGVmaW5lZCcpIGVuZCA9IHRoaXMubGVuZ3RoO1xuXG4gIC8vIEZhc3RwYXRoIGVtcHR5IHN0cmluZ3NcbiAgaWYgKCtlbmQgPT0gc3RhcnQpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiB0aGlzLmhleFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHRoaXMudXRmOFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0dXJuIHRoaXMuYXNjaWlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gdGhpcy5iaW5hcnlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gdGhpcy5iYXNlNjRTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIHJldHVybiB0aGlzLnVjczJTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxufTtcblxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5oZXhXcml0ZSA9IGZ1bmN0aW9uKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gK29mZnNldCB8fCAwO1xuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9ICtsZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoO1xuICBpZiAoc3RyTGVuICUgMikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnl0ZSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNik7XG4gICAgaWYgKGlzTmFOKGJ5dGUpKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpO1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSBieXRlO1xuICB9XG4gIFNsb3dCdWZmZXIuX2NoYXJzV3JpdHRlbiA9IGkgKiAyO1xuICByZXR1cm4gaTtcbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aDtcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGxlbmd0aDtcbiAgICBsZW5ndGggPSBzd2FwO1xuICB9XG5cbiAgb2Zmc2V0ID0gK29mZnNldCB8fCAwO1xuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9ICtsZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG5cbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXR1cm4gdGhpcy5oZXhXcml0ZShzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB0aGlzLnV0ZjhXcml0ZShzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiB0aGlzLmFzY2lpV3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIHRoaXMuYmFzZTY0V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXR1cm4gdGhpcy51Y3MyV3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJyk7XG4gIH1cbn07XG5cblxuLy8gc2xpY2Uoc3RhcnQsIGVuZClcblNsb3dCdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIGVuZCA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignb29iJyk7XG4gIH1cbiAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgQnVmZmVyKHRoaXMsIGVuZCAtIHN0YXJ0LCArc3RhcnQpO1xufTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKHRhcmdldCwgdGFyZ2V0c3RhcnQsIHNvdXJjZXN0YXJ0LCBzb3VyY2VlbmQpIHtcbiAgdmFyIHRlbXAgPSBbXTtcbiAgZm9yICh2YXIgaT1zb3VyY2VzdGFydDsgaTxzb3VyY2VlbmQ7IGkrKykge1xuICAgIGFzc2VydC5vayh0eXBlb2YgdGhpc1tpXSAhPT0gJ3VuZGVmaW5lZCcsIFwiY29weWluZyB1bmRlZmluZWQgYnVmZmVyIGJ5dGVzIVwiKTtcbiAgICB0ZW1wLnB1c2godGhpc1tpXSk7XG4gIH1cblxuICBmb3IgKHZhciBpPXRhcmdldHN0YXJ0OyBpPHRhcmdldHN0YXJ0K3RlbXAubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXRbaV0gPSB0ZW1wW2ktdGFyZ2V0c3RhcnRdO1xuICB9XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24odmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgfVxuICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICB0aGlzW2ldID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29lcmNlKGxlbmd0aCkge1xuICAvLyBDb2VyY2UgbGVuZ3RoIHRvIGEgbnVtYmVyIChwb3NzaWJseSBOYU4pLCByb3VuZCB1cFxuICAvLyBpbiBjYXNlIGl0J3MgZnJhY3Rpb25hbCAoZS5nLiAxMjMuNDU2KSB0aGVuIGRvIGFcbiAgLy8gZG91YmxlIG5lZ2F0ZSB0byBjb2VyY2UgYSBOYU4gdG8gMC4gRWFzeSwgcmlnaHQ/XG4gIGxlbmd0aCA9IH5+TWF0aC5jZWlsKCtsZW5ndGgpO1xuICByZXR1cm4gbGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGg7XG59XG5cblxuLy8gQnVmZmVyXG5cbmZ1bmN0aW9uIEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgb2Zmc2V0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG9mZnNldCk7XG4gIH1cblxuICB2YXIgdHlwZTtcblxuICAvLyBBcmUgd2Ugc2xpY2luZz9cbiAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgdGhpcy5sZW5ndGggPSBjb2VyY2UoZW5jb2RpbmcpO1xuICAgIHRoaXMucGFyZW50ID0gc3ViamVjdDtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgfSBlbHNlIHtcbiAgICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgICBzd2l0Y2ggKHR5cGUgPSB0eXBlb2Ygc3ViamVjdCkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgdGhpcy5sZW5ndGggPSBjb2VyY2Uoc3ViamVjdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICB0aGlzLmxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN1YmplY3QsIGVuY29kaW5nKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6IC8vIEFzc3VtZSBvYmplY3QgaXMgYW4gYXJyYXlcbiAgICAgICAgdGhpcy5sZW5ndGggPSBjb2VyY2Uoc3ViamVjdC5sZW5ndGgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBuZWVkcyB0byBiZSBhIG51bWJlciwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXJyYXkgb3Igc3RyaW5nLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IEJ1ZmZlci5wb29sU2l6ZSkge1xuICAgICAgLy8gQmlnIGJ1ZmZlciwganVzdCBhbGxvYyBvbmUuXG4gICAgICB0aGlzLnBhcmVudCA9IG5ldyBTbG93QnVmZmVyKHRoaXMubGVuZ3RoKTtcbiAgICAgIHRoaXMub2Zmc2V0ID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTbWFsbCBidWZmZXIuXG4gICAgICBpZiAoIXBvb2wgfHwgcG9vbC5sZW5ndGggLSBwb29sLnVzZWQgPCB0aGlzLmxlbmd0aCkgYWxsb2NQb29sKCk7XG4gICAgICB0aGlzLnBhcmVudCA9IHBvb2w7XG4gICAgICB0aGlzLm9mZnNldCA9IHBvb2wudXNlZDtcbiAgICAgIHBvb2wudXNlZCArPSB0aGlzLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXkuXG4gICAgaWYgKGlzQXJyYXlJc2goc3ViamVjdCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3ViamVjdCBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICAgIHRoaXMucGFyZW50W2kgKyB0aGlzLm9mZnNldF0gPSBzdWJqZWN0LnJlYWRVSW50OChpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBhcmVudFtpICsgdGhpcy5vZmZzZXRdID0gc3ViamVjdFtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PSAnc3RyaW5nJykge1xuICAgICAgLy8gV2UgYXJlIGEgc3RyaW5nXG4gICAgICB0aGlzLmxlbmd0aCA9IHRoaXMud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpO1xuICAgIH1cbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlJc2goc3ViamVjdCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShzdWJqZWN0KSB8fCBCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkgfHxcbiAgICAgICAgIHN1YmplY3QgJiYgdHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICAgICB0eXBlb2Ygc3ViamVjdC5sZW5ndGggPT09ICdudW1iZXInO1xufVxuXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyO1xuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXI7XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDggKiAxMDI0O1xudmFyIHBvb2w7XG5cbmZ1bmN0aW9uIGFsbG9jUG9vbCgpIHtcbiAgcG9vbCA9IG5ldyBTbG93QnVmZmVyKEJ1ZmZlci5wb29sU2l6ZSk7XG4gIHBvb2wudXNlZCA9IDA7XG59XG5cblxuLy8gU3RhdGljIG1ldGhvZHNcbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyKGIpIHtcbiAgcmV0dXJuIGIgaW5zdGFuY2VvZiBCdWZmZXIgfHwgYiBpbnN0YW5jZW9mIFNsb3dCdWZmZXI7XG59O1xuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVzYWdlOiBCdWZmZXIuY29uY2F0KGxpc3QsIFt0b3RhbExlbmd0aF0pXFxuIFxcXG4gICAgICBsaXN0IHNob3VsZCBiZSBhbiBBcnJheS5cIik7XG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKTtcbiAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsaXN0WzBdO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0b3RhbExlbmd0aCAhPT0gJ251bWJlcicpIHtcbiAgICB0b3RhbExlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYnVmID0gbGlzdFtpXTtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGJ1Zi5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpO1xuICB2YXIgcG9zID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV07XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpO1xuICAgIHBvcyArPSBidWYubGVuZ3RoO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59O1xuXG4vLyBJbnNwZWN0XG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICB2YXIgb3V0ID0gW10sXG4gICAgICBsZW4gPSB0aGlzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgb3V0W2ldID0gdG9IZXgodGhpcy5wYXJlbnRbaSArIHRoaXMub2Zmc2V0XSk7XG4gICAgaWYgKGkgPT0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUykge1xuICAgICAgb3V0W2kgKyAxXSA9ICcuLi4nO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBvdXQuam9pbignICcpICsgJz4nO1xufTtcblxuXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldChpKSB7XG4gIGlmIChpIDwgMCB8fCBpID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICByZXR1cm4gdGhpcy5wYXJlbnRbdGhpcy5vZmZzZXQgKyBpXTtcbn07XG5cblxuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQoaSwgdikge1xuICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgcmV0dXJuIHRoaXMucGFyZW50W3RoaXMub2Zmc2V0ICsgaV0gPSB2O1xufTtcblxuXG4vLyB3cml0ZShzdHJpbmcsIG9mZnNldCA9IDAsIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgtb2Zmc2V0LCBlbmNvZGluZyA9ICd1dGY4JylcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aDtcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGxlbmd0aDtcbiAgICBsZW5ndGggPSBzd2FwO1xuICB9XG5cbiAgb2Zmc2V0ID0gK29mZnNldCB8fCAwO1xuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9ICtsZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG5cbiAgdmFyIHJldDtcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSB0aGlzLnBhcmVudC5oZXhXcml0ZShzdHJpbmcsIHRoaXMub2Zmc2V0ICsgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB0aGlzLnBhcmVudC51dGY4V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuYXNjaWlXcml0ZShzdHJpbmcsIHRoaXMub2Zmc2V0ICsgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuYmluYXJ5V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICByZXQgPSB0aGlzLnBhcmVudC5iYXNlNjRXcml0ZShzdHJpbmcsIHRoaXMub2Zmc2V0ICsgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXQgPSB0aGlzLnBhcmVudC51Y3MyV3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG5cbiAgQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW47XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cblxuLy8gdG9TdHJpbmcoZW5jb2RpbmcsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKTtcblxuICBpZiAodHlwZW9mIHN0YXJ0ID09ICd1bmRlZmluZWQnIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMDtcbiAgfSBlbHNlIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgc3RhcnQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5kID09ICd1bmRlZmluZWQnIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gIH0gZWxzZSBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCA9IDA7XG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ICsgdGhpcy5vZmZzZXQ7XG4gIGVuZCA9IGVuZCArIHRoaXMub2Zmc2V0O1xuXG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmhleFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnV0ZjhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5hc2NpaVNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5iaW5hcnlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuYmFzZTY0U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQudWNzMlNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG59O1xuXG5cbi8vIGJ5dGVMZW5ndGhcbkJ1ZmZlci5ieXRlTGVuZ3RoID0gU2xvd0J1ZmZlci5ieXRlTGVuZ3RoO1xuXG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICB2YWx1ZSB8fCAodmFsdWUgPSAwKTtcbiAgc3RhcnQgfHwgKHN0YXJ0ID0gMCk7XG4gIGVuZCB8fCAoZW5kID0gdGhpcy5sZW5ndGgpO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5jaGFyQ29kZUF0KDApO1xuICB9XG4gIGlmICghKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHx8IGlzTmFOKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndmFsdWUgaXMgbm90IGEgbnVtYmVyJyk7XG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBFcnJvcignZW5kIDwgc3RhcnQnKTtcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwO1xuICBpZiAodGhpcy5sZW5ndGggPT0gMCkgcmV0dXJuIDA7XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc3RhcnQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZCBvdXQgb2YgYm91bmRzJyk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5wYXJlbnQuZmlsbCh2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgKyB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kICsgdGhpcy5vZmZzZXQpO1xufTtcblxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbih0YXJnZXQsIHRhcmdldF9zdGFydCwgc3RhcnQsIGVuZCkge1xuICB2YXIgc291cmNlID0gdGhpcztcbiAgc3RhcnQgfHwgKHN0YXJ0ID0gMCk7XG4gIGVuZCB8fCAoZW5kID0gdGhpcy5sZW5ndGgpO1xuICB0YXJnZXRfc3RhcnQgfHwgKHRhcmdldF9zdGFydCA9IDApO1xuXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VFbmQgPCBzb3VyY2VTdGFydCcpO1xuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDA7XG4gIGlmICh0YXJnZXQubGVuZ3RoID09IDAgfHwgc291cmNlLmxlbmd0aCA9PSAwKSByZXR1cm4gMDtcblxuICBpZiAodGFyZ2V0X3N0YXJ0IDwgMCB8fCB0YXJnZXRfc3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJyk7XG4gIH1cblxuICBpZiAoZW5kIDwgMCB8fCBlbmQgPiBzb3VyY2UubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMucGFyZW50LmNvcHkodGFyZ2V0LnBhcmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0X3N0YXJ0ICsgdGFyZ2V0Lm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgKyB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kICsgdGhpcy5vZmZzZXQpO1xufTtcblxuXG4vLyBzbGljZShzdGFydCwgZW5kKVxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICBpZiAoc3RhcnQgPiBlbmQpIHRocm93IG5ldyBFcnJvcignb29iJyk7XG5cbiAgcmV0dXJuIG5ldyBCdWZmZXIodGhpcy5wYXJlbnQsIGVuZCAtIHN0YXJ0LCArc3RhcnQgKyB0aGlzLm9mZnNldCk7XG59O1xuXG5cbi8vIExlZ2FjeSBtZXRob2RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblxuQnVmZmVyLnByb3RvdHlwZS51dGY4U2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiB0aGlzLnRvU3RyaW5nKCd1dGY4Jywgc3RhcnQsIGVuZCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmJpbmFyeVNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygnYmluYXJ5Jywgc3RhcnQsIGVuZCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmFzY2lpU2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiB0aGlzLnRvU3RyaW5nKCdhc2NpaScsIHN0YXJ0LCBlbmQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS51dGY4V3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCkge1xuICByZXR1cm4gdGhpcy53cml0ZShzdHJpbmcsIG9mZnNldCwgJ3V0ZjgnKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuYmluYXJ5V3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCkge1xuICByZXR1cm4gdGhpcy53cml0ZShzdHJpbmcsIG9mZnNldCwgJ2JpbmFyeScpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5hc2NpaVdyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMud3JpdGUoc3RyaW5nLCBvZmZzZXQsICdhc2NpaScpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhciBidWZmZXIgPSB0aGlzO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkgcmV0dXJuO1xuXG4gIHJldHVybiBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdO1xufTtcblxuZnVuY3Rpb24gcmVhZFVJbnQxNihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciB2YWwgPSAwO1xuXG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgaWYgKG9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSByZXR1cm4gMDtcblxuICBpZiAoaXNCaWdFbmRpYW4pIHtcbiAgICB2YWwgPSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdIDw8IDg7XG4gICAgaWYgKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbCA9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF07XG4gICAgaWYgKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgODtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gcmVhZFVJbnQzMihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciB2YWwgPSAwO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkgcmV0dXJuIDA7XG5cbiAgaWYgKGlzQmlnRW5kaWFuKSB7XG4gICAgaWYgKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgMTY7XG4gICAgaWYgKG9mZnNldCArIDIgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDJdIDw8IDg7XG4gICAgaWYgKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDNdO1xuICAgIHZhbCA9IHZhbCArIChidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdIDw8IDI0ID4+PiAwKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGJ1ZmZlci5sZW5ndGgpXG4gICAgICB2YWwgPSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAyXSA8PCAxNjtcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgpXG4gICAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgODtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XTtcbiAgICBpZiAob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgpXG4gICAgICB2YWwgPSB2YWwgKyAoYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgM10gPDwgMjQgPj4+IDApO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFNpZ25lZCBpbnRlZ2VyIHR5cGVzLCB5YXkgdGVhbSEgQSByZW1pbmRlciBvbiBob3cgdHdvJ3MgY29tcGxlbWVudCBhY3R1YWxseVxuICogd29ya3MuIFRoZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ25lZCBiaXQsIGkuZS4gdGVsbHMgdXMgd2hldGhlciBvciBub3QgdGhlXG4gKiBudW1iZXIgc2hvdWxkIGJlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLiBJZiB0aGUgdHdvJ3MgY29tcGxlbWVudCB2YWx1ZSBpc1xuICogcG9zaXRpdmUsIHRoZW4gd2UncmUgZG9uZSwgYXMgaXQncyBlcXVpdmFsZW50IHRvIHRoZSB1bnNpZ25lZCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBOb3cgaWYgdGhlIG51bWJlciBpcyBwb3NpdGl2ZSwgeW91J3JlIHByZXR0eSBtdWNoIGRvbmUsIHlvdSBjYW4ganVzdCBsZXZlcmFnZVxuICogdGhlIHVuc2lnbmVkIHRyYW5zbGF0aW9ucyBhbmQgcmV0dXJuIHRob3NlLiBVbmZvcnR1bmF0ZWx5LCBuZWdhdGl2ZSBudW1iZXJzXG4gKiBhcmVuJ3QgcXVpdGUgdGhhdCBzdHJhaWdodGZvcndhcmQuXG4gKlxuICogQXQgZmlyc3QgZ2xhbmNlLCBvbmUgbWlnaHQgYmUgaW5jbGluZWQgdG8gdXNlIHRoZSB0cmFkaXRpb25hbCBmb3JtdWxhIHRvXG4gKiB0cmFuc2xhdGUgYmluYXJ5IG51bWJlcnMgYmV0d2VlbiB0aGUgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcyBpbiB0d28nc1xuICogY29tcGxlbWVudC4gKFRob3VnaCBpdCBkb2Vzbid0IHF1aXRlIHdvcmsgZm9yIHRoZSBtb3N0IG5lZ2F0aXZlIHZhbHVlKVxuICogTWFpbmx5OlxuICogIC0gaW52ZXJ0IGFsbCB0aGUgYml0c1xuICogIC0gYWRkIG9uZSB0byB0aGUgcmVzdWx0XG4gKlxuICogT2YgY291cnNlLCB0aGlzIGRvZXNuJ3QgcXVpdGUgd29yayBpbiBKYXZhc2NyaXB0LiBUYWtlIGZvciBleGFtcGxlIHRoZSB2YWx1ZVxuICogb2YgLTEyOC4gVGhpcyBjb3VsZCBiZSByZXByZXNlbnRlZCBpbiAxNiBiaXRzIChiaWctZW5kaWFuKSBhcyAweGZmODAuIEJ1dCBvZlxuICogY291cnNlLCBKYXZhc2NyaXB0IHdpbGwgZG8gdGhlIGZvbGxvd2luZzpcbiAqXG4gKiA+IH4weGZmODBcbiAqIC02NTQwOVxuICpcbiAqIFdob2ggdGhlcmUsIEphdmFzY3JpcHQsIHRoYXQncyBub3QgcXVpdGUgcmlnaHQuIEJ1dCB3YWl0LCBhY2NvcmRpbmcgdG9cbiAqIEphdmFzY3JpcHQgdGhhdCdzIHBlcmZlY3RseSBjb3JyZWN0LiBXaGVuIEphdmFzY3JpcHQgZW5kcyB1cCBzZWVpbmcgdGhlXG4gKiBjb25zdGFudCAweGZmODAsIGl0IGhhcyBubyBub3Rpb24gdGhhdCBpdCBpcyBhY3R1YWxseSBhIHNpZ25lZCBudW1iZXIuIEl0XG4gKiBhc3N1bWVzIHRoYXQgd2UndmUgaW5wdXQgdGhlIHVuc2lnbmVkIHZhbHVlIDB4ZmY4MC4gVGh1cywgd2hlbiBpdCBkb2VzIHRoZVxuICogYmluYXJ5IG5lZ2F0aW9uLCBpdCBjYXN0cyBpdCBpbnRvIGEgc2lnbmVkIHZhbHVlLCAocG9zaXRpdmUgMHhmZjgwKS4gVGhlblxuICogd2hlbiB5b3UgcGVyZm9ybSBiaW5hcnkgbmVnYXRpb24gb24gdGhhdCwgaXQgdHVybnMgaXQgaW50byBhIG5lZ2F0aXZlIG51bWJlci5cbiAqXG4gKiBJbnN0ZWFkLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIHVzZSB0aGUgZm9sbG93aW5nIGdlbmVyYWwgZm9ybXVsYSwgdGhhdCB3b3Jrc1xuICogaW4gYSByYXRoZXIgSmF2YXNjcmlwdCBmcmllbmRseSB3YXkuIEknbSBnbGFkIHdlIGRvbid0IHN1cHBvcnQgdGhpcyBraW5kIG9mXG4gKiB3ZWlyZCBudW1iZXJpbmcgc2NoZW1lIGluIHRoZSBrZXJuZWwuXG4gKlxuICogKEJJVC1NQVggLSAodW5zaWduZWQpdmFsICsgMSkgKiAtMVxuICpcbiAqIFRoZSBhc3R1dGUgb2JzZXJ2ZXIsIG1heSB0aGluayB0aGF0IHRoaXMgZG9lc24ndCBtYWtlIHNlbnNlIGZvciA4LWJpdCBudW1iZXJzXG4gKiAocmVhbGx5IGl0IGlzbid0IG5lY2Vzc2FyeSBmb3IgdGhlbSkuIEhvd2V2ZXIsIHdoZW4geW91IGdldCAxNi1iaXQgbnVtYmVycyxcbiAqIHlvdSBkby4gTGV0J3MgZ28gYmFjayB0byBvdXIgcHJpb3IgZXhhbXBsZSBhbmQgc2VlIGhvdyB0aGlzIHdpbGwgbG9vazpcbiAqXG4gKiAoMHhmZmZmIC0gMHhmZjgwICsgMSkgKiAtMVxuICogKDB4MDA3ZiArIDEpICogLTFcbiAqICgweDAwODApICogLTFcbiAqL1xuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG4gIHZhciBuZWc7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgaWYgKG9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSByZXR1cm47XG5cbiAgbmVnID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSAmIDB4ODA7XG4gIGlmICghbmVnKSB7XG4gICAgcmV0dXJuIChidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdKTtcbiAgfVxuXG4gIHJldHVybiAoKDB4ZmYgLSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdICsgMSkgKiAtMSk7XG59O1xuXG5mdW5jdGlvbiByZWFkSW50MTYoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YXIgbmVnLCB2YWw7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgdmFsID0gcmVhZFVJbnQxNihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgbmVnID0gdmFsICYgMHg4MDAwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICByZXR1cm4gKDB4ZmZmZiAtIHZhbCArIDEpICogLTE7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRJbnQzMihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciBuZWcsIHZhbDtcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICB2YWwgPSByZWFkVUludDMyKGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICBuZWcgPSB2YWwgJiAweDgwMDAwMDAwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiAodmFsKTtcbiAgfVxuXG4gIHJldHVybiAoMHhmZmZmZmZmZiAtIHZhbCArIDEpICogLTE7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRGbG9hdChidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLnJlYWRJRUVFNzU0KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDIzLCA0KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gcmVhZERvdWJsZShidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyA3IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLnJlYWRJRUVFNzU0KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDUyLCA4KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaW50ZWdlci4gVGhpcyBtZWFucyB0aGF0IGl0IGlzXG4gKiBub24tbmVnYXRpdmUuIEl0IGhhcyBubyBmcmFjdGlvbmFsIGNvbXBvbmVudCBhbmQgdGhhdCBpdCBkb2VzIG5vdCBleGNlZWQgdGhlXG4gKiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUuXG4gKlxuICogICAgICB2YWx1ZSAgICAgICAgICAgVGhlIG51bWJlciB0byBjaGVjayBmb3IgdmFsaWRpdHlcbiAqXG4gKiAgICAgIG1heCAgICAgICAgICAgICBUaGUgbWF4aW11bSB2YWx1ZVxuICovXG5mdW5jdGlvbiB2ZXJpZnVpbnQodmFsdWUsIG1heCkge1xuICBhc3NlcnQub2sodHlwZW9mICh2YWx1ZSkgPT0gJ251bWJlcicsXG4gICAgICAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA+PSAwLFxuICAgICAgJ3NwZWNpZmllZCBhIG5lZ2F0aXZlIHZhbHVlIGZvciB3cml0aW5nIGFuIHVuc2lnbmVkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGlzIGxhcmdlciB0aGFuIG1heGltdW0gdmFsdWUgZm9yIHR5cGUnKTtcblxuICBhc3NlcnQub2soTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmKTtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSA9IHZhbHVlO1xuICB9XG59O1xuXG5mdW5jdGlvbiB3cml0ZVVJbnQxNihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZik7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGgubWluKGJ1ZmZlci5sZW5ndGggLSBvZmZzZXQsIDIpOyBpKyspIHtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGlzQmlnRW5kaWFuID8gMSAtIGkgOiBpKSkpKSA+Pj5cbiAgICAgICAgICAgIChpc0JpZ0VuZGlhbiA/IDEgLSBpIDogaSkgKiA4O1xuICB9XG5cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlVUludDMyKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmZmZmZik7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGgubWluKGJ1ZmZlci5sZW5ndGggLSBvZmZzZXQsIDQpOyBpKyspIHtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSA+Pj4gKGlzQmlnRW5kaWFuID8gMyAtIGkgOiBpKSAqIDgpICYgMHhmZjtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuXG4vKlxuICogV2Ugbm93IG1vdmUgb250byBvdXIgZnJpZW5kcyBpbiB0aGUgc2lnbmVkIG51bWJlciBjYXRlZ29yeS4gVW5saWtlIHVuc2lnbmVkXG4gKiBudW1iZXJzLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIHdvcnJ5IGEgYml0IG1vcmUgYWJvdXQgaG93IHdlIHB1dCB2YWx1ZXMgaW50b1xuICogYXJyYXlzLiBTaW5jZSB3ZSBhcmUgb25seSB3b3JyeWluZyBhYm91dCBzaWduZWQgMzItYml0IHZhbHVlcywgd2UncmUgaW5cbiAqIHNsaWdodGx5IGJldHRlciBzaGFwZS4gVW5mb3J0dW5hdGVseSwgd2UgcmVhbGx5IGNhbid0IGRvIG91ciBmYXZvcml0ZSBiaW5hcnlcbiAqICYgaW4gdGhpcyBzeXN0ZW0uIEl0IHJlYWxseSBzZWVtcyB0byBkbyB0aGUgd3JvbmcgdGhpbmcuIEZvciBleGFtcGxlOlxuICpcbiAqID4gLTMyICYgMHhmZlxuICogMjI0XG4gKlxuICogV2hhdCdzIGhhcHBlbmluZyBhYm92ZSBpcyByZWFsbHk6IDB4ZTAgJiAweGZmID0gMHhlMC4gSG93ZXZlciwgdGhlIHJlc3VsdHMgb2ZcbiAqIHRoaXMgYXJlbid0IHRyZWF0ZWQgYXMgYSBzaWduZWQgbnVtYmVyLiBVbHRpbWF0ZWx5IGEgYmFkIHRoaW5nLlxuICpcbiAqIFdoYXQgd2UncmUgZ29pbmcgdG8gd2FudCB0byBkbyBpcyBiYXNpY2FsbHkgY3JlYXRlIHRoZSB1bnNpZ25lZCBlcXVpdmFsZW50IG9mXG4gKiBvdXIgcmVwcmVzZW50YXRpb24gYW5kIHBhc3MgdGhhdCBvZmYgdG8gdGhlIHd1aW50KiBmdW5jdGlvbnMuIFRvIGRvIHRoYXRcbiAqIHdlJ3JlIGdvaW5nIHRvIGRvIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogIC0gaWYgdGhlIHZhbHVlIGlzIHBvc2l0aXZlXG4gKiAgICAgIHdlIGNhbiBwYXNzIGl0IGRpcmVjdGx5IG9mZiB0byB0aGUgZXF1aXZhbGVudCB3dWludFxuICogIC0gaWYgdGhlIHZhbHVlIGlzIG5lZ2F0aXZlXG4gKiAgICAgIHdlIGRvIHRoZSBmb2xsb3dpbmcgY29tcHV0YXRpb246XG4gKiAgICAgICAgIG1iICsgdmFsICsgMSwgd2hlcmVcbiAqICAgICAgICAgbWIgICBpcyB0aGUgbWF4aW11bSB1bnNpZ25lZCB2YWx1ZSBpbiB0aGF0IGJ5dGUgc2l6ZVxuICogICAgICAgICB2YWwgIGlzIHRoZSBKYXZhc2NyaXB0IG5lZ2F0aXZlIGludGVnZXJcbiAqXG4gKlxuICogQXMgYSBjb25jcmV0ZSB2YWx1ZSwgdGFrZSAtMTI4LiBJbiBzaWduZWQgMTYgYml0cyB0aGlzIHdvdWxkIGJlIDB4ZmY4MC4gSWZcbiAqIHlvdSBkbyBvdXQgdGhlIGNvbXB1dGF0aW9uczpcbiAqXG4gKiAweGZmZmYgLSAxMjggKyAxXG4gKiAweGZmZmYgLSAxMjdcbiAqIDB4ZmY4MFxuICpcbiAqIFlvdSBjYW4gdGhlbiBlbmNvZGUgdGhpcyB2YWx1ZSBhcyB0aGUgc2lnbmVkIHZlcnNpb24uIFRoaXMgaXMgcmVhbGx5IHJhdGhlclxuICogaGFja3ksIGJ1dCBpdCBzaG91bGQgd29yayBhbmQgZ2V0IHRoZSBqb2IgZG9uZSB3aGljaCBpcyBvdXIgZ29hbCBoZXJlLlxuICovXG5cbi8qXG4gKiBBIHNlcmllcyBvZiBjaGVja3MgdG8gbWFrZSBzdXJlIHdlIGFjdHVhbGx5IGhhdmUgYSBzaWduZWQgMzItYml0IG51bWJlclxuICovXG5mdW5jdGlvbiB2ZXJpZnNpbnQodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydC5vayh0eXBlb2YgKHZhbHVlKSA9PSAnbnVtYmVyJyxcbiAgICAgICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSwgJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50Jyk7XG59XG5cbmZ1bmN0aW9uIHZlcmlmSUVFRTc1NCh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0Lm9rKHR5cGVvZiAodmFsdWUpID09ICdudW1iZXInLFxuICAgICAgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKTtcblxuICBhc3NlcnQub2sodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YXIgYnVmZmVyID0gdGhpcztcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2YsIC0weDgwKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgYnVmZmVyLndyaXRlVUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpO1xuICB9IGVsc2Uge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KDB4ZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbm9Bc3NlcnQpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB3cml0ZUludDE2KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmLCAtMHg4MDAwKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgd3JpdGVVSW50MTYoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9IGVsc2Uge1xuICAgIHdyaXRlVUludDE2KGJ1ZmZlciwgMHhmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCk7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVJbnQzMihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgd3JpdGVVSW50MzIoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9IGVsc2Uge1xuICAgIHdyaXRlVUludDMyKGJ1ZmZlciwgMHhmZmZmZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOCk7XG4gIH1cblxuICByZXF1aXJlKCcuL2J1ZmZlcl9pZWVlNzU0Jykud3JpdGVJRUVFNzU0KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sXG4gICAgICAyMywgNCk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgNyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCk7XG4gIH1cblxuICByZXF1aXJlKCcuL2J1ZmZlcl9pZWVlNzU0Jykud3JpdGVJRUVFNzU0KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sXG4gICAgICA1MiwgOCk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50ODtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4O1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDg7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDg7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRTtcblxufSkoKVxufSx7XCJhc3NlcnRcIjoyLFwiLi9idWZmZXJfaWVlZTc1NFwiOjEsXCJiYXNlNjQtanNcIjo1fV0sMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5leHBvcnRzLmlzRGF0ZSA9IGZ1bmN0aW9uKG9iail7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBEYXRlXSd9O1xuZXhwb3J0cy5pc1JlZ0V4cCA9IGZ1bmN0aW9uKG9iail7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBSZWdFeHBdJ307XG5cblxuZXhwb3J0cy5wcmludCA9IGZ1bmN0aW9uICgpIHt9O1xuZXhwb3J0cy5wdXRzID0gZnVuY3Rpb24gKCkge307XG5leHBvcnRzLmRlYnVnID0gZnVuY3Rpb24oKSB7fTtcblxuZXhwb3J0cy5pbnNwZWN0ID0gZnVuY3Rpb24ob2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKSB7XG4gIHZhciBzZWVuID0gW107XG5cbiAgdmFyIHN0eWxpemUgPSBmdW5jdGlvbihzdHIsIHN0eWxlVHlwZSkge1xuICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuICAgIHZhciBzdHlsZXMgPVxuICAgICAgICB7ICdib2xkJyA6IFsxLCAyMl0sXG4gICAgICAgICAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAgICAgICAgICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgICAgICAgICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAgICAgICAgICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgICAgICAgICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgICAgICAgICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICAgICAgICAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICAgICAgICAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICAgICAgICAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAgICAgICAgICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAgICAgICAgICdyZWQnIDogWzMxLCAzOV0sXG4gICAgICAgICAgJ3llbGxvdycgOiBbMzMsIDM5XSB9O1xuXG4gICAgdmFyIHN0eWxlID1cbiAgICAgICAgeyAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgICAgICAgICAnbnVtYmVyJzogJ2JsdWUnLFxuICAgICAgICAgICdib29sZWFuJzogJ3llbGxvdycsXG4gICAgICAgICAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgICAgICAgICAnbnVsbCc6ICdib2xkJyxcbiAgICAgICAgICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgICAgICAgICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgICAgICAgICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAgICAgICAgICdyZWdleHAnOiAncmVkJyB9W3N0eWxlVHlwZV07XG5cbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIHJldHVybiAnXFwwMzNbJyArIHN0eWxlc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAgICdcXDAzM1snICsgc3R5bGVzW3N0eWxlXVsxXSArICdtJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH07XG4gIGlmICghIGNvbG9ycykge1xuICAgIHN0eWxpemUgPSBmdW5jdGlvbihzdHIsIHN0eWxlVHlwZSkgeyByZXR1cm4gc3RyOyB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0KHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gICAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5pbnNwZWN0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgICB2YWx1ZSAhPT0gZXhwb3J0cyAmJlxuICAgICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzKTtcbiAgICB9XG5cbiAgICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgICAgICByZXR1cm4gc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcblxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuXG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgICB9XG4gICAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xuICAgIH1cblxuICAgIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgICB2YXIgdmlzaWJsZV9rZXlzID0gT2JqZWN0X2tleXModmFsdWUpO1xuICAgIHZhciBrZXlzID0gc2hvd0hpZGRlbiA/IE9iamVjdF9nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKSA6IHZpc2libGVfa2V5cztcblxuICAgIC8vIEZ1bmN0aW9ucyB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYga2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJycgKyB2YWx1ZSwgJ3JlZ2V4cCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERhdGVzIHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWRcbiAgICBpZiAoaXNEYXRlKHZhbHVlKSAmJiBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHN0eWxpemUodmFsdWUudG9VVENTdHJpbmcoKSwgJ2RhdGUnKTtcbiAgICB9XG5cbiAgICB2YXIgYmFzZSwgdHlwZSwgYnJhY2VzO1xuICAgIC8vIERldGVybWluZSB0aGUgb2JqZWN0IHR5cGVcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHR5cGUgPSAnQXJyYXknO1xuICAgICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZSA9ICdPYmplY3QnO1xuICAgICAgYnJhY2VzID0gWyd7JywgJ30nXTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgYmFzZSA9IChpc1JlZ0V4cCh2YWx1ZSkpID8gJyAnICsgdmFsdWUgOiAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlID0gJyc7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIGJhc2UgPSAnICcgKyB2YWx1ZS50b1VUQ1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gICAgfVxuXG4gICAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJycgKyB2YWx1ZSwgJ3JlZ2V4cCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWVuLnB1c2godmFsdWUpO1xuXG4gICAgdmFyIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIG5hbWUsIHN0cjtcbiAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cEdldHRlcl9fKSB7XG4gICAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cEdldHRlcl9fKGtleSkpIHtcbiAgICAgICAgICBpZiAodmFsdWUuX19sb29rdXBTZXR0ZXJfXyhrZXkpKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHIgPSBzdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cFNldHRlcl9fKGtleSkpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh2aXNpYmxlX2tleXMuaW5kZXhPZihrZXkpIDwgMCkge1xuICAgICAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHIpIHtcbiAgICAgICAgaWYgKHNlZW4uaW5kZXhPZih2YWx1ZVtrZXldKSA8IDApIHtcbiAgICAgICAgICBpZiAocmVjdXJzZVRpbWVzID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdHIgPSBmb3JtYXQodmFsdWVba2V5XSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ciA9IGZvcm1hdCh2YWx1ZVtrZXldLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9IHN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnQXJyYXknICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgICAgIG5hbWUgPSBzdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgICAgICBuYW1lID0gc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xuICAgIH0pO1xuXG4gICAgc2Vlbi5wb3AoKTtcblxuICAgIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgICBudW1MaW5lc0VzdCsrO1xuICAgICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgICAgcmV0dXJuIHByZXYgKyBjdXIubGVuZ3RoICsgMTtcbiAgICB9LCAwKTtcblxuICAgIGlmIChsZW5ndGggPiA1MCkge1xuICAgICAgb3V0cHV0ID0gYnJhY2VzWzBdICtcbiAgICAgICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgICAgYnJhY2VzWzFdO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dCA9IGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG4gIHJldHVybiBmb3JtYXQob2JqLCAodHlwZW9mIGRlcHRoID09PSAndW5kZWZpbmVkJyA/IDIgOiBkZXB0aCkpO1xufTtcblxuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBhciBpbnN0YW5jZW9mIEFycmF5IHx8XG4gICAgICAgICBBcnJheS5pc0FycmF5KGFyKSB8fFxuICAgICAgICAgKGFyICYmIGFyICE9PSBPYmplY3QucHJvdG90eXBlICYmIGlzQXJyYXkoYXIuX19wcm90b19fKSk7XG59XG5cblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIHJlIGluc3RhbmNlb2YgUmVnRXhwIHx8XG4gICAgKHR5cGVvZiByZSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXScpO1xufVxuXG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIGlmIChkIGluc3RhbmNlb2YgRGF0ZSkgcmV0dXJuIHRydWU7XG4gIGlmICh0eXBlb2YgZCAhPT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcbiAgdmFyIHByb3BlcnRpZXMgPSBEYXRlLnByb3RvdHlwZSAmJiBPYmplY3RfZ2V0T3duUHJvcGVydHlOYW1lcyhEYXRlLnByb3RvdHlwZSk7XG4gIHZhciBwcm90byA9IGQuX19wcm90b19fICYmIE9iamVjdF9nZXRPd25Qcm9wZXJ0eU5hbWVzKGQuX19wcm90b19fKTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHByb3RvKSA9PT0gSlNPTi5zdHJpbmdpZnkocHJvcGVydGllcyk7XG59XG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uIChtc2cpIHt9O1xuXG5leHBvcnRzLnB1bXAgPSBudWxsO1xuXG52YXIgT2JqZWN0X2tleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHJlcy5wdXNoKGtleSk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbnZhciBPYmplY3RfZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcblxudmFyIE9iamVjdF9jcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIChwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAvLyBmcm9tIGVzNS1zaGltXG4gICAgdmFyIG9iamVjdDtcbiAgICBpZiAocHJvdG90eXBlID09PSBudWxsKSB7XG4gICAgICAgIG9iamVjdCA9IHsgJ19fcHJvdG9fXycgOiBudWxsIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIHByb3RvdHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgJ3R5cGVvZiBwcm90b3R5cGVbJyArICh0eXBlb2YgcHJvdG90eXBlKSArICddICE9IFxcJ29iamVjdFxcJydcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFR5cGUgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgVHlwZS5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgICAgIG9iamVjdCA9IG5ldyBUeXBlKCk7XG4gICAgICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvcGVydGllcyAhPT0gJ3VuZGVmaW5lZCcgJiYgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMob2JqZWN0LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn07XG5cbmV4cG9ydHMuaW5oZXJpdHMgPSBmdW5jdGlvbihjdG9yLCBzdXBlckN0b3IpIHtcbiAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gIGN0b3IucHJvdG90eXBlID0gT2JqZWN0X2NyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAodHlwZW9mIGYgIT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGV4cG9ydHMuaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6IHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSl7XG4gICAgaWYgKHggPT09IG51bGwgfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGV4cG9ydHMuaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cbn0se1wiZXZlbnRzXCI6Nn1dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5KGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyO1xuXHRcblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyAnSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCc7XG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHBsYWNlSG9sZGVycyA9IGI2NC5pbmRleE9mKCc9Jyk7XG5cdFx0cGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSBwbGFjZUhvbGRlcnMgOiAwO1xuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gW107Ly9uZXcgVWludDhBcnJheShiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpO1xuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGxvb2t1cC5pbmRleE9mKGI2NFtpXSkgPDwgMTgpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pIDw8IDEyKSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDJdKSA8PCA2KSB8IGxvb2t1cC5pbmRleE9mKGI2NFtpICsgM10pO1xuXHRcdFx0YXJyLnB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNik7XG5cdFx0XHRhcnIucHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KTtcblx0XHRcdGFyci5wdXNoKHRtcCAmIDB4RkYpO1xuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChsb29rdXAuaW5kZXhPZihiNjRbaV0pIDw8IDIpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pID4+IDQpO1xuXHRcdFx0YXJyLnB1c2godG1wICYgMHhGRik7XG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChsb29rdXAuaW5kZXhPZihiNjRbaV0pIDw8IDEwKSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDFdKSA8PCA0KSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDJdKSA+PiAyKTtcblx0XHRcdGFyci5wdXNoKCh0bXAgPj4gOCkgJiAweEZGKTtcblx0XHRcdGFyci5wdXNoKHRtcCAmIDB4RkYpO1xuXHRcdH1cblxuXHRcdHJldHVybiBhcnI7XG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0KHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGg7XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdO1xuXHRcdH07XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKTtcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcCk7XG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbdGVtcCA+PiAyXTtcblx0XHRcdFx0b3V0cHV0ICs9IGxvb2t1cFsodGVtcCA8PCA0KSAmIDB4M0ZdO1xuXHRcdFx0XHRvdXRwdXQgKz0gJz09Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwW3RlbXAgPj4gMTBdO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwWyh0ZW1wID4+IDQpICYgMHgzRl07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbKHRlbXAgPDwgMikgJiAweDNGXTtcblx0XHRcdFx0b3V0cHV0ICs9ICc9Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXk7XG5cdG1vZHVsZS5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0O1xufSgpKTtcblxufSx7fV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5leHBvcnRzLnJlYWRJRUVFNzU0ID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGlzQkUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBuQml0cyA9IC03LFxuICAgICAgaSA9IGlzQkUgPyAwIDogKG5CeXRlcyAtIDEpLFxuICAgICAgZCA9IGlzQkUgPyAxIDogLTEsXG4gICAgICBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG4gIGkgKz0gZDtcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgcyA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IGVMZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pO1xufTtcblxuZXhwb3J0cy53cml0ZUlFRUU3NTQgPSBmdW5jdGlvbihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQkUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgYyxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCksXG4gICAgICBpID0gaXNCRSA/IChuQnl0ZXMgLSAxKSA6IDAsXG4gICAgICBkID0gaXNCRSA/IC0xIDogMSxcbiAgICAgIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7XG59O1xuXG59LHt9XSw4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBpZiAoZXYuc291cmNlID09PSB3aW5kb3cgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1cblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG59LHt9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbihwcm9jZXNzKXtpZiAoIXByb2Nlc3MuRXZlbnRFbWl0dGVyKSBwcm9jZXNzLkV2ZW50RW1pdHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuXG52YXIgRXZlbnRFbWl0dGVyID0gZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBwcm9jZXNzLkV2ZW50RW1pdHRlcjtcbnZhciBpc0FycmF5ID0gdHlwZW9mIEFycmF5LmlzQXJyYXkgPT09ICdmdW5jdGlvbidcbiAgICA/IEFycmF5LmlzQXJyYXlcbiAgICA6IGZ1bmN0aW9uICh4cykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgIH1cbjtcbmZ1bmN0aW9uIGluZGV4T2YgKHhzLCB4KSB7XG4gICAgaWYgKHhzLmluZGV4T2YpIHJldHVybiB4cy5pbmRleE9mKHgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHggPT09IHhzW2ldKSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuXG4vLyAxMCBsaXN0ZW5lcnMgYXJlIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2hcbi8vIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuLy9cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSB7fTtcbiAgdGhpcy5fZXZlbnRzLm1heExpc3RlbmVycyA9IG47XG59O1xuXG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzQXJyYXkodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpXG4gICAge1xuICAgICAgaWYgKGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGFyZ3VtZW50c1sxXTsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuY2F1Z2h0LCB1bnNwZWNpZmllZCAnZXJyb3InIGV2ZW50LlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRoaXMuX2V2ZW50cykgcmV0dXJuIGZhbHNlO1xuICB2YXIgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgaWYgKCFoYW5kbGVyKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09ICdmdW5jdGlvbicpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKGlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gRXZlbnRFbWl0dGVyIGlzIGRlZmluZWQgaW4gc3JjL25vZGVfZXZlbnRzLmNjXG4vLyBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQoKSBpcyBhbHNvIGRlZmluZWQgdGhlcmUuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBsaXN0ZW5lcikge1xuICAgIHRocm93IG5ldyBFcnJvcignYWRkTGlzdGVuZXIgb25seSB0YWtlcyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09IFwibmV3TGlzdGVuZXJzXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyc1wiLlxuICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIH0gZWxzZSBpZiAoaXNBcnJheSh0aGlzLl9ldmVudHNbdHlwZV0pKSB7XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgICAgdmFyIG07XG4gICAgICBpZiAodGhpcy5fZXZlbnRzLm1heExpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG0gPSB0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbSA9IGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgICB9XG5cbiAgICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLm9uKHR5cGUsIGZ1bmN0aW9uIGcoKSB7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcbiAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGxpc3RlbmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmVMaXN0ZW5lciBvbmx5IHRha2VzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpO1xuICB9XG5cbiAgLy8gZG9lcyBub3QgdXNlIGxpc3RlbmVycygpLCBzbyBubyBzaWRlIGVmZmVjdCBvZiBjcmVhdGluZyBfZXZlbnRzW3R5cGVdXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pIHJldHVybiB0aGlzO1xuXG4gIHZhciBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0FycmF5KGxpc3QpKSB7XG4gICAgdmFyIGkgPSBpbmRleE9mKGxpc3QsIGxpc3RlbmVyKTtcbiAgICBpZiAoaSA8IDApIHJldHVybiB0aGlzO1xuICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgIGlmIChsaXN0Lmxlbmd0aCA9PSAwKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgfSBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0gPT09IGxpc3RlbmVyKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBkb2VzIG5vdCB1c2UgbGlzdGVuZXJzKCksIHNvIG5vIHNpZGUgZWZmZWN0IG9mIGNyZWF0aW5nIF9ldmVudHNbdHlwZV1cbiAgaWYgKHR5cGUgJiYgdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1t0eXBlXSkgdGhpcy5fZXZlbnRzW3R5cGVdID0gbnVsbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMpIHRoaXMuX2V2ZW50cyA9IHt9O1xuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSkgdGhpcy5fZXZlbnRzW3R5cGVdID0gW107XG4gIGlmICghaXNBcnJheSh0aGlzLl9ldmVudHNbdHlwZV0pKSB7XG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2V2ZW50c1t0eXBlXTtcbn07XG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfcHJvY2Vzc1wiKSlcbn0se1wiX19icm93c2VyaWZ5X3Byb2Nlc3NcIjo4fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24oKXtmdW5jdGlvbiBTbG93QnVmZmVyIChzaXplKSB7XG4gICAgdGhpcy5sZW5ndGggPSBzaXplO1xufTtcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTA7XG5cblxuZnVuY3Rpb24gdG9IZXgobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNik7XG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KTtcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspXG4gICAgaWYgKHN0ci5jaGFyQ29kZUF0KGkpIDw9IDB4N0YpXG4gICAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSk7XG4gICAgZWxzZSB7XG4gICAgICB2YXIgaCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHIuY2hhckF0KGkpKS5zdWJzdHIoMSkuc3BsaXQoJyUnKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaC5sZW5ndGg7IGorKylcbiAgICAgICAgYnl0ZUFycmF5LnB1c2gocGFyc2VJbnQoaFtqXSwgMTYpKTtcbiAgICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheTtcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKysgKVxuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKCBzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYgKTtcblxuICByZXR1cm4gYnl0ZUFycmF5O1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzKHN0cikge1xuICByZXR1cm4gcmVxdWlyZShcImJhc2U2NC1qc1wiKS50b0J5dGVBcnJheShzdHIpO1xufVxuXG5TbG93QnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xuICBzd2l0Y2ggKGVuY29kaW5nIHx8IFwidXRmOFwiKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiBzdHIubGVuZ3RoIC8gMjtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aDtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiBzdHIubGVuZ3RoO1xuXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cikubGVuZ3RoO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBibGl0QnVmZmVyKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgcG9zLCBpID0gMDtcbiAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICBpZiAoKGkrb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKVxuICAgICAgYnJlYWs7XG5cbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV07XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiBpO1xufVxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS51dGY4V3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgYnl0ZXMsIHBvcztcbiAgcmV0dXJuIFNsb3dCdWZmZXIuX2NoYXJzV3JpdHRlbiA9ICBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZyksIHRoaXMsIG9mZnNldCwgbGVuZ3RoKTtcbn07XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmFzY2lpV3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgYnl0ZXMsIHBvcztcbiAgcmV0dXJuIFNsb3dCdWZmZXIuX2NoYXJzV3JpdHRlbiA9ICBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCB0aGlzLCBvZmZzZXQsIGxlbmd0aCk7XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5iYXNlNjRXcml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBieXRlcywgcG9zO1xuICByZXR1cm4gU2xvd0J1ZmZlci5fY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIHRoaXMsIG9mZnNldCwgbGVuZ3RoKTtcbn07XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmJhc2U2NFNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgcmV0dXJuIHJlcXVpcmUoXCJiYXNlNjQtanNcIikuZnJvbUJ5dGVBcnJheShieXRlcyk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKTsgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUudXRmOFNsaWNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdmFyIHJlcyA9IFwiXCI7XG4gIHZhciB0bXAgPSBcIlwiO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgaWYgKGJ5dGVzW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gICAgICB0bXAgPSBcIlwiO1xuICAgIH0gZWxzZVxuICAgICAgdG1wICs9IFwiJVwiICsgYnl0ZXNbaV0udG9TdHJpbmcoMTYpO1xuXG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcCk7XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmFzY2lpU2xpY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBieXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB2YXIgcmV0ID0gXCJcIjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKylcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gIHJldHVybiByZXQ7XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG91dCA9IFtdLFxuICAgICAgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBvdXRbaV0gPSB0b0hleCh0aGlzW2ldKTtcbiAgICBpZiAoaSA9PSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTKSB7XG4gICAgICBvdXRbaSArIDFdID0gJy4uLic7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICc8U2xvd0J1ZmZlciAnICsgb3V0LmpvaW4oJyAnKSArICc+Jztcbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuaGV4U2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwO1xuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuO1xuXG4gIHZhciBvdXQgPSAnJztcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgodGhpc1tpXSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG4gIHN0YXJ0ID0gK3N0YXJ0IHx8IDA7XG4gIGlmICh0eXBlb2YgZW5kID09ICd1bmRlZmluZWQnKSBlbmQgPSB0aGlzLmxlbmd0aDtcblxuICAvLyBGYXN0cGF0aCBlbXB0eSBzdHJpbmdzXG4gIGlmICgrZW5kID09IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXR1cm4gdGhpcy5oZXhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB0aGlzLnV0ZjhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiB0aGlzLmFzY2lpU2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIHRoaXMuYmFzZTY0U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXR1cm4gdGhpcy51Y3MyU2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJyk7XG4gIH1cbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuaGV4V3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9ICtvZmZzZXQgfHwgMDtcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSArbGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgaWYgKHN0ckxlbiAlIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpO1xuICB9XG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMjtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ5dGUgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpO1xuICAgIGlmIChpc05hTihieXRlKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKTtcbiAgICB0aGlzW29mZnNldCArIGldID0gYnl0ZTtcbiAgfVxuICBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSBpICogMjtcbiAgcmV0dXJuIGk7XG59O1xuXG5cblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gU3VwcG9ydCBib3RoIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZylcbiAgLy8gYW5kIHRoZSBsZWdhY3kgKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICBsZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG9mZnNldDtcbiAgICBvZmZzZXQgPSBsZW5ndGg7XG4gICAgbGVuZ3RoID0gc3dhcDtcbiAgfVxuXG4gIG9mZnNldCA9ICtvZmZzZXQgfHwgMDtcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSArbGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIHRoaXMuaGV4V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXR1cm4gdGhpcy51dGY4V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXR1cm4gdGhpcy5hc2NpaVdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldHVybiB0aGlzLmJpbmFyeVdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldHVybiB0aGlzLmJhc2U2NFdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgICAgcmV0dXJuIHRoaXMudWNzMldyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG59O1xuXG5cbi8vIHNsaWNlKHN0YXJ0LCBlbmQpXG5TbG93QnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSBlbmQgPSB0aGlzLmxlbmd0aDtcblxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICB9XG4gIGlmIChzdGFydCA+IGVuZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignb29iJyk7XG4gIH1cblxuICByZXR1cm4gbmV3IEJ1ZmZlcih0aGlzLCBlbmQgLSBzdGFydCwgK3N0YXJ0KTtcbn07XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbih0YXJnZXQsIHRhcmdldHN0YXJ0LCBzb3VyY2VzdGFydCwgc291cmNlZW5kKSB7XG4gIHZhciB0ZW1wID0gW107XG4gIGZvciAodmFyIGk9c291cmNlc3RhcnQ7IGk8c291cmNlZW5kOyBpKyspIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIHRoaXNbaV0gIT09ICd1bmRlZmluZWQnLCBcImNvcHlpbmcgdW5kZWZpbmVkIGJ1ZmZlciBieXRlcyFcIik7XG4gICAgdGVtcC5wdXNoKHRoaXNbaV0pO1xuICB9XG5cbiAgZm9yICh2YXIgaT10YXJnZXRzdGFydDsgaTx0YXJnZXRzdGFydCt0ZW1wLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFyZ2V0W2ldID0gdGVtcFtpLXRhcmdldHN0YXJ0XTtcbiAgfVxufTtcblxuZnVuY3Rpb24gY29lcmNlKGxlbmd0aCkge1xuICAvLyBDb2VyY2UgbGVuZ3RoIHRvIGEgbnVtYmVyIChwb3NzaWJseSBOYU4pLCByb3VuZCB1cFxuICAvLyBpbiBjYXNlIGl0J3MgZnJhY3Rpb25hbCAoZS5nLiAxMjMuNDU2KSB0aGVuIGRvIGFcbiAgLy8gZG91YmxlIG5lZ2F0ZSB0byBjb2VyY2UgYSBOYU4gdG8gMC4gRWFzeSwgcmlnaHQ/XG4gIGxlbmd0aCA9IH5+TWF0aC5jZWlsKCtsZW5ndGgpO1xuICByZXR1cm4gbGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGg7XG59XG5cblxuLy8gQnVmZmVyXG5cbmZ1bmN0aW9uIEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgb2Zmc2V0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG9mZnNldCk7XG4gIH1cblxuICB2YXIgdHlwZTtcblxuICAvLyBBcmUgd2Ugc2xpY2luZz9cbiAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgdGhpcy5sZW5ndGggPSBjb2VyY2UoZW5jb2RpbmcpO1xuICAgIHRoaXMucGFyZW50ID0gc3ViamVjdDtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgfSBlbHNlIHtcbiAgICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgICBzd2l0Y2ggKHR5cGUgPSB0eXBlb2Ygc3ViamVjdCkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgdGhpcy5sZW5ndGggPSBjb2VyY2Uoc3ViamVjdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICB0aGlzLmxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN1YmplY3QsIGVuY29kaW5nKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6IC8vIEFzc3VtZSBvYmplY3QgaXMgYW4gYXJyYXlcbiAgICAgICAgdGhpcy5sZW5ndGggPSBjb2VyY2Uoc3ViamVjdC5sZW5ndGgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBuZWVkcyB0byBiZSBhIG51bWJlciwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXJyYXkgb3Igc3RyaW5nLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IEJ1ZmZlci5wb29sU2l6ZSkge1xuICAgICAgLy8gQmlnIGJ1ZmZlciwganVzdCBhbGxvYyBvbmUuXG4gICAgICB0aGlzLnBhcmVudCA9IG5ldyBTbG93QnVmZmVyKHRoaXMubGVuZ3RoKTtcbiAgICAgIHRoaXMub2Zmc2V0ID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTbWFsbCBidWZmZXIuXG4gICAgICBpZiAoIXBvb2wgfHwgcG9vbC5sZW5ndGggLSBwb29sLnVzZWQgPCB0aGlzLmxlbmd0aCkgYWxsb2NQb29sKCk7XG4gICAgICB0aGlzLnBhcmVudCA9IHBvb2w7XG4gICAgICB0aGlzLm9mZnNldCA9IHBvb2wudXNlZDtcbiAgICAgIHBvb2wudXNlZCArPSB0aGlzLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXkuXG4gICAgaWYgKGlzQXJyYXlJc2goc3ViamVjdCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnBhcmVudFtpICsgdGhpcy5vZmZzZXRdID0gc3ViamVjdFtpXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFdlIGFyZSBhIHN0cmluZ1xuICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLndyaXRlKHN1YmplY3QsIDAsIGVuY29kaW5nKTtcbiAgICB9XG4gIH1cblxufVxuXG5mdW5jdGlvbiBpc0FycmF5SXNoKHN1YmplY3QpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoc3ViamVjdCkgfHwgQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpIHx8XG4gICAgICAgICBzdWJqZWN0ICYmIHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgdHlwZW9mIHN1YmplY3QubGVuZ3RoID09PSAnbnVtYmVyJztcbn1cblxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlcjtcbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyO1xuXG5CdWZmZXIucG9vbFNpemUgPSA4ICogMTAyNDtcbnZhciBwb29sO1xuXG5mdW5jdGlvbiBhbGxvY1Bvb2woKSB7XG4gIHBvb2wgPSBuZXcgU2xvd0J1ZmZlcihCdWZmZXIucG9vbFNpemUpO1xuICBwb29sLnVzZWQgPSAwO1xufVxuXG5cbi8vIFN0YXRpYyBtZXRob2RzXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlcihiKSB7XG4gIHJldHVybiBiIGluc3RhbmNlb2YgQnVmZmVyIHx8IGIgaW5zdGFuY2VvZiBTbG93QnVmZmVyO1xufTtcblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2FnZTogQnVmZmVyLmNvbmNhdChsaXN0LCBbdG90YWxMZW5ndGhdKVxcbiBcXFxuICAgICAgbGlzdCBzaG91bGQgYmUgYW4gQXJyYXkuXCIpO1xuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMCk7XG4gIH0gZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbGlzdFswXTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdG90YWxMZW5ndGggIT09ICdudW1iZXInKSB7XG4gICAgdG90YWxMZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGJ1ZiA9IGxpc3RbaV07XG4gICAgICB0b3RhbExlbmd0aCArPSBidWYubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKHRvdGFsTGVuZ3RoKTtcbiAgdmFyIHBvcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBidWYgPSBsaXN0W2ldO1xuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKTtcbiAgICBwb3MgKz0gYnVmLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gYnVmZmVyO1xufTtcblxuLy8gSW5zcGVjdFxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgdmFyIG91dCA9IFtdLFxuICAgICAgbGVuID0gdGhpcy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dFtpXSA9IHRvSGV4KHRoaXMucGFyZW50W2kgKyB0aGlzLm9mZnNldF0pO1xuICAgIGlmIChpID09IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMpIHtcbiAgICAgIG91dFtpICsgMV0gPSAnLi4uJztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgb3V0LmpvaW4oJyAnKSArICc+Jztcbn07XG5cblxuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQoaSkge1xuICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgcmV0dXJuIHRoaXMucGFyZW50W3RoaXMub2Zmc2V0ICsgaV07XG59O1xuXG5cbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KGksIHYpIHtcbiAgaWYgKGkgPCAwIHx8IGkgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignb29iJyk7XG4gIHJldHVybiB0aGlzLnBhcmVudFt0aGlzLm9mZnNldCArIGldID0gdjtcbn07XG5cblxuLy8gd3JpdGUoc3RyaW5nLCBvZmZzZXQgPSAwLCBsZW5ndGggPSBidWZmZXIubGVuZ3RoLW9mZnNldCwgZW5jb2RpbmcgPSAndXRmOCcpXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gU3VwcG9ydCBib3RoIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZylcbiAgLy8gYW5kIHRoZSBsZWdhY3kgKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICBsZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG9mZnNldDtcbiAgICBvZmZzZXQgPSBsZW5ndGg7XG4gICAgbGVuZ3RoID0gc3dhcDtcbiAgfVxuXG4gIG9mZnNldCA9ICtvZmZzZXQgfHwgMDtcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSArbGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHZhciByZXQ7XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuaGV4V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQudXRmOFdyaXRlKHN0cmluZywgdGhpcy5vZmZzZXQgKyBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IHRoaXMucGFyZW50LmFzY2lpV3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IHRoaXMucGFyZW50LmJpbmFyeVdyaXRlKHN0cmluZywgdGhpcy5vZmZzZXQgKyBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuYmFzZTY0V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQudWNzMldyaXRlKHN0cmluZywgdGhpcy5vZmZzZXQgKyBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxuXG4gIEJ1ZmZlci5fY2hhcnNXcml0dGVuID0gU2xvd0J1ZmZlci5fY2hhcnNXcml0dGVuO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5cbi8vIHRvU3RyaW5nKGVuY29kaW5nLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKHR5cGVvZiBzdGFydCA9PSAndW5kZWZpbmVkJyB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDA7XG4gIH0gZWxzZSBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHN0YXJ0ID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuZCA9PSAndW5kZWZpbmVkJyB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICB9IGVsc2UgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgPSAwO1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCArIHRoaXMub2Zmc2V0O1xuICBlbmQgPSBlbmQgKyB0aGlzLm9mZnNldDtcblxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5oZXhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC51dGY4U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuYXNjaWlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuYmluYXJ5U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmJhc2U2NFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnVjczJTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxufTtcblxuXG4vLyBieXRlTGVuZ3RoXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IFNsb3dCdWZmZXIuYnl0ZUxlbmd0aDtcblxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgdmFsdWUgfHwgKHZhbHVlID0gMCk7XG4gIHN0YXJ0IHx8IChzdGFydCA9IDApO1xuICBlbmQgfHwgKGVuZCA9IHRoaXMubGVuZ3RoKTtcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gdmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgfVxuICBpZiAoISh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB8fCBpc05hTih2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbHVlIGlzIG5vdCBhIG51bWJlcicpO1xuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgRXJyb3IoJ2VuZCA8IHN0YXJ0Jyk7XG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMDtcbiAgaWYgKHRoaXMubGVuZ3RoID09IDApIHJldHVybiAwO1xuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0IG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbmQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMucGFyZW50LmZpbGwodmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ICsgdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCArIHRoaXMub2Zmc2V0KTtcbn07XG5cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24odGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gIHN0YXJ0IHx8IChzdGFydCA9IDApO1xuICBlbmQgfHwgKGVuZCA9IHRoaXMubGVuZ3RoKTtcbiAgdGFyZ2V0X3N0YXJ0IHx8ICh0YXJnZXRfc3RhcnQgPSAwKTtcblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBFcnJvcignc291cmNlRW5kIDwgc291cmNlU3RhcnQnKTtcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwO1xuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PSAwIHx8IHNvdXJjZS5sZW5ndGggPT0gMCkgcmV0dXJuIDA7XG5cbiAgaWYgKHRhcmdldF9zdGFydCA8IDAgfHwgdGFyZ2V0X3N0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gc291cmNlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gc291cmNlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgKyBzdGFydDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLnBhcmVudC5jb3B5KHRhcmdldC5wYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldF9zdGFydCArIHRhcmdldC5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ICsgdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCArIHRoaXMub2Zmc2V0KTtcbn07XG5cblxuLy8gc2xpY2Uoc3RhcnQsIGVuZClcbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkgZW5kID0gdGhpcy5sZW5ndGg7XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgaWYgKHN0YXJ0ID4gZW5kKSB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuXG4gIHJldHVybiBuZXcgQnVmZmVyKHRoaXMucGFyZW50LCBlbmQgLSBzdGFydCwgK3N0YXJ0ICsgdGhpcy5vZmZzZXQpO1xufTtcblxuXG4vLyBMZWdhY3kgbWV0aG9kcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5cbkJ1ZmZlci5wcm90b3R5cGUudXRmOFNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygndXRmOCcsIHN0YXJ0LCBlbmQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5iaW5hcnlTbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHRoaXMudG9TdHJpbmcoJ2JpbmFyeScsIHN0YXJ0LCBlbmQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5hc2NpaVNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygnYXNjaWknLCBzdGFydCwgZW5kKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUudXRmOFdyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMud3JpdGUoc3RyaW5nLCBvZmZzZXQsICd1dGY4Jyk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmJpbmFyeVdyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMud3JpdGUoc3RyaW5nLCBvZmZzZXQsICdiaW5hcnknKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuYXNjaWlXcml0ZSA9IGZ1bmN0aW9uKHN0cmluZywgb2Zmc2V0KSB7XG4gIHJldHVybiB0aGlzLndyaXRlKHN0cmluZywgb2Zmc2V0LCAnYXNjaWknKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YXIgYnVmZmVyID0gdGhpcztcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRVSW50MTYoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YXIgdmFsID0gMDtcblxuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIGlmIChpc0JpZ0VuZGlhbikge1xuICAgIHZhbCA9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPDwgODtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV07XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XTtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgODtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQxNih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MTYodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiByZWFkVUludDMyKGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFyIHZhbCA9IDA7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgaWYgKGlzQmlnRW5kaWFuKSB7XG4gICAgdmFsID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgMTY7XG4gICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDJdIDw8IDg7XG4gICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDNdO1xuICAgIHZhbCA9IHZhbCArIChidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdIDw8IDI0ID4+PiAwKTtcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAyXSA8PCAxNjtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgODtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XTtcbiAgICB2YWwgPSB2YWwgKyAoYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgM10gPDwgMjQgPj4+IDApO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFNpZ25lZCBpbnRlZ2VyIHR5cGVzLCB5YXkgdGVhbSEgQSByZW1pbmRlciBvbiBob3cgdHdvJ3MgY29tcGxlbWVudCBhY3R1YWxseVxuICogd29ya3MuIFRoZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ25lZCBiaXQsIGkuZS4gdGVsbHMgdXMgd2hldGhlciBvciBub3QgdGhlXG4gKiBudW1iZXIgc2hvdWxkIGJlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLiBJZiB0aGUgdHdvJ3MgY29tcGxlbWVudCB2YWx1ZSBpc1xuICogcG9zaXRpdmUsIHRoZW4gd2UncmUgZG9uZSwgYXMgaXQncyBlcXVpdmFsZW50IHRvIHRoZSB1bnNpZ25lZCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBOb3cgaWYgdGhlIG51bWJlciBpcyBwb3NpdGl2ZSwgeW91J3JlIHByZXR0eSBtdWNoIGRvbmUsIHlvdSBjYW4ganVzdCBsZXZlcmFnZVxuICogdGhlIHVuc2lnbmVkIHRyYW5zbGF0aW9ucyBhbmQgcmV0dXJuIHRob3NlLiBVbmZvcnR1bmF0ZWx5LCBuZWdhdGl2ZSBudW1iZXJzXG4gKiBhcmVuJ3QgcXVpdGUgdGhhdCBzdHJhaWdodGZvcndhcmQuXG4gKlxuICogQXQgZmlyc3QgZ2xhbmNlLCBvbmUgbWlnaHQgYmUgaW5jbGluZWQgdG8gdXNlIHRoZSB0cmFkaXRpb25hbCBmb3JtdWxhIHRvXG4gKiB0cmFuc2xhdGUgYmluYXJ5IG51bWJlcnMgYmV0d2VlbiB0aGUgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcyBpbiB0d28nc1xuICogY29tcGxlbWVudC4gKFRob3VnaCBpdCBkb2Vzbid0IHF1aXRlIHdvcmsgZm9yIHRoZSBtb3N0IG5lZ2F0aXZlIHZhbHVlKVxuICogTWFpbmx5OlxuICogIC0gaW52ZXJ0IGFsbCB0aGUgYml0c1xuICogIC0gYWRkIG9uZSB0byB0aGUgcmVzdWx0XG4gKlxuICogT2YgY291cnNlLCB0aGlzIGRvZXNuJ3QgcXVpdGUgd29yayBpbiBKYXZhc2NyaXB0LiBUYWtlIGZvciBleGFtcGxlIHRoZSB2YWx1ZVxuICogb2YgLTEyOC4gVGhpcyBjb3VsZCBiZSByZXByZXNlbnRlZCBpbiAxNiBiaXRzIChiaWctZW5kaWFuKSBhcyAweGZmODAuIEJ1dCBvZlxuICogY291cnNlLCBKYXZhc2NyaXB0IHdpbGwgZG8gdGhlIGZvbGxvd2luZzpcbiAqXG4gKiA+IH4weGZmODBcbiAqIC02NTQwOVxuICpcbiAqIFdob2ggdGhlcmUsIEphdmFzY3JpcHQsIHRoYXQncyBub3QgcXVpdGUgcmlnaHQuIEJ1dCB3YWl0LCBhY2NvcmRpbmcgdG9cbiAqIEphdmFzY3JpcHQgdGhhdCdzIHBlcmZlY3RseSBjb3JyZWN0LiBXaGVuIEphdmFzY3JpcHQgZW5kcyB1cCBzZWVpbmcgdGhlXG4gKiBjb25zdGFudCAweGZmODAsIGl0IGhhcyBubyBub3Rpb24gdGhhdCBpdCBpcyBhY3R1YWxseSBhIHNpZ25lZCBudW1iZXIuIEl0XG4gKiBhc3N1bWVzIHRoYXQgd2UndmUgaW5wdXQgdGhlIHVuc2lnbmVkIHZhbHVlIDB4ZmY4MC4gVGh1cywgd2hlbiBpdCBkb2VzIHRoZVxuICogYmluYXJ5IG5lZ2F0aW9uLCBpdCBjYXN0cyBpdCBpbnRvIGEgc2lnbmVkIHZhbHVlLCAocG9zaXRpdmUgMHhmZjgwKS4gVGhlblxuICogd2hlbiB5b3UgcGVyZm9ybSBiaW5hcnkgbmVnYXRpb24gb24gdGhhdCwgaXQgdHVybnMgaXQgaW50byBhIG5lZ2F0aXZlIG51bWJlci5cbiAqXG4gKiBJbnN0ZWFkLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIHVzZSB0aGUgZm9sbG93aW5nIGdlbmVyYWwgZm9ybXVsYSwgdGhhdCB3b3Jrc1xuICogaW4gYSByYXRoZXIgSmF2YXNjcmlwdCBmcmllbmRseSB3YXkuIEknbSBnbGFkIHdlIGRvbid0IHN1cHBvcnQgdGhpcyBraW5kIG9mXG4gKiB3ZWlyZCBudW1iZXJpbmcgc2NoZW1lIGluIHRoZSBrZXJuZWwuXG4gKlxuICogKEJJVC1NQVggLSAodW5zaWduZWQpdmFsICsgMSkgKiAtMVxuICpcbiAqIFRoZSBhc3R1dGUgb2JzZXJ2ZXIsIG1heSB0aGluayB0aGF0IHRoaXMgZG9lc24ndCBtYWtlIHNlbnNlIGZvciA4LWJpdCBudW1iZXJzXG4gKiAocmVhbGx5IGl0IGlzbid0IG5lY2Vzc2FyeSBmb3IgdGhlbSkuIEhvd2V2ZXIsIHdoZW4geW91IGdldCAxNi1iaXQgbnVtYmVycyxcbiAqIHlvdSBkby4gTGV0J3MgZ28gYmFjayB0byBvdXIgcHJpb3IgZXhhbXBsZSBhbmQgc2VlIGhvdyB0aGlzIHdpbGwgbG9vazpcbiAqXG4gKiAoMHhmZmZmIC0gMHhmZjgwICsgMSkgKiAtMVxuICogKDB4MDA3ZiArIDEpICogLTFcbiAqICgweDAwODApICogLTFcbiAqL1xuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG4gIHZhciBuZWc7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgbmVnID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSAmIDB4ODA7XG4gIGlmICghbmVnKSB7XG4gICAgcmV0dXJuIChidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdKTtcbiAgfVxuXG4gIHJldHVybiAoKDB4ZmYgLSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdICsgMSkgKiAtMSk7XG59O1xuXG5mdW5jdGlvbiByZWFkSW50MTYoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YXIgbmVnLCB2YWw7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgdmFsID0gcmVhZFVJbnQxNihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgbmVnID0gdmFsICYgMHg4MDAwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICByZXR1cm4gKDB4ZmZmZiAtIHZhbCArIDEpICogLTE7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRJbnQzMihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciBuZWcsIHZhbDtcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICB2YWwgPSByZWFkVUludDMyKGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICBuZWcgPSB2YWwgJiAweDgwMDAwMDAwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiAodmFsKTtcbiAgfVxuXG4gIHJldHVybiAoMHhmZmZmZmZmZiAtIHZhbCArIDEpICogLTE7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRGbG9hdChidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLnJlYWRJRUVFNzU0KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDIzLCA0KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gcmVhZERvdWJsZShidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyA3IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLnJlYWRJRUVFNzU0KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDUyLCA4KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaW50ZWdlci4gVGhpcyBtZWFucyB0aGF0IGl0IGlzXG4gKiBub24tbmVnYXRpdmUuIEl0IGhhcyBubyBmcmFjdGlvbmFsIGNvbXBvbmVudCBhbmQgdGhhdCBpdCBkb2VzIG5vdCBleGNlZWQgdGhlXG4gKiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUuXG4gKlxuICogICAgICB2YWx1ZSAgICAgICAgICAgVGhlIG51bWJlciB0byBjaGVjayBmb3IgdmFsaWRpdHlcbiAqXG4gKiAgICAgIG1heCAgICAgICAgICAgICBUaGUgbWF4aW11bSB2YWx1ZVxuICovXG5mdW5jdGlvbiB2ZXJpZnVpbnQodmFsdWUsIG1heCkge1xuICBhc3NlcnQub2sodHlwZW9mICh2YWx1ZSkgPT0gJ251bWJlcicsXG4gICAgICAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA+PSAwLFxuICAgICAgJ3NwZWNpZmllZCBhIG5lZ2F0aXZlIHZhbHVlIGZvciB3cml0aW5nIGFuIHVuc2lnbmVkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGlzIGxhcmdlciB0aGFuIG1heGltdW0gdmFsdWUgZm9yIHR5cGUnKTtcblxuICBhc3NlcnQub2soTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmKTtcbiAgfVxuXG4gIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSB2YWx1ZTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlVUludDE2KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmKTtcbiAgfVxuXG4gIGlmIChpc0JpZ0VuZGlhbikge1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSAodmFsdWUgJiAweGZmMDApID4+PiA4O1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDFdID0gdmFsdWUgJiAweDAwZmY7XG4gIH0gZWxzZSB7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmMDApID4+PiA4O1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSB2YWx1ZSAmIDB4MDBmZjtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVVSW50MzIoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmZmZmZmKTtcbiAgfVxuXG4gIGlmIChpc0JpZ0VuZGlhbikge1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSAodmFsdWUgPj4+IDI0KSAmIDB4ZmY7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpICYgMHhmZjtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAzXSA9IHZhbHVlICYgMHhmZjtcbiAgfSBlbHNlIHtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpICYgMHhmZjtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpICYgMHhmZjtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCkgJiAweGZmO1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSB2YWx1ZSAmIDB4ZmY7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFdlIG5vdyBtb3ZlIG9udG8gb3VyIGZyaWVuZHMgaW4gdGhlIHNpZ25lZCBudW1iZXIgY2F0ZWdvcnkuIFVubGlrZSB1bnNpZ25lZFxuICogbnVtYmVycywgd2UncmUgZ29pbmcgdG8gaGF2ZSB0byB3b3JyeSBhIGJpdCBtb3JlIGFib3V0IGhvdyB3ZSBwdXQgdmFsdWVzIGludG9cbiAqIGFycmF5cy4gU2luY2Ugd2UgYXJlIG9ubHkgd29ycnlpbmcgYWJvdXQgc2lnbmVkIDMyLWJpdCB2YWx1ZXMsIHdlJ3JlIGluXG4gKiBzbGlnaHRseSBiZXR0ZXIgc2hhcGUuIFVuZm9ydHVuYXRlbHksIHdlIHJlYWxseSBjYW4ndCBkbyBvdXIgZmF2b3JpdGUgYmluYXJ5XG4gKiAmIGluIHRoaXMgc3lzdGVtLiBJdCByZWFsbHkgc2VlbXMgdG8gZG8gdGhlIHdyb25nIHRoaW5nLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiA+IC0zMiAmIDB4ZmZcbiAqIDIyNFxuICpcbiAqIFdoYXQncyBoYXBwZW5pbmcgYWJvdmUgaXMgcmVhbGx5OiAweGUwICYgMHhmZiA9IDB4ZTAuIEhvd2V2ZXIsIHRoZSByZXN1bHRzIG9mXG4gKiB0aGlzIGFyZW4ndCB0cmVhdGVkIGFzIGEgc2lnbmVkIG51bWJlci4gVWx0aW1hdGVseSBhIGJhZCB0aGluZy5cbiAqXG4gKiBXaGF0IHdlJ3JlIGdvaW5nIHRvIHdhbnQgdG8gZG8gaXMgYmFzaWNhbGx5IGNyZWF0ZSB0aGUgdW5zaWduZWQgZXF1aXZhbGVudCBvZlxuICogb3VyIHJlcHJlc2VudGF0aW9uIGFuZCBwYXNzIHRoYXQgb2ZmIHRvIHRoZSB3dWludCogZnVuY3Rpb25zLiBUbyBkbyB0aGF0XG4gKiB3ZSdyZSBnb2luZyB0byBkbyB0aGUgZm9sbG93aW5nOlxuICpcbiAqICAtIGlmIHRoZSB2YWx1ZSBpcyBwb3NpdGl2ZVxuICogICAgICB3ZSBjYW4gcGFzcyBpdCBkaXJlY3RseSBvZmYgdG8gdGhlIGVxdWl2YWxlbnQgd3VpbnRcbiAqICAtIGlmIHRoZSB2YWx1ZSBpcyBuZWdhdGl2ZVxuICogICAgICB3ZSBkbyB0aGUgZm9sbG93aW5nIGNvbXB1dGF0aW9uOlxuICogICAgICAgICBtYiArIHZhbCArIDEsIHdoZXJlXG4gKiAgICAgICAgIG1iICAgaXMgdGhlIG1heGltdW0gdW5zaWduZWQgdmFsdWUgaW4gdGhhdCBieXRlIHNpemVcbiAqICAgICAgICAgdmFsICBpcyB0aGUgSmF2YXNjcmlwdCBuZWdhdGl2ZSBpbnRlZ2VyXG4gKlxuICpcbiAqIEFzIGEgY29uY3JldGUgdmFsdWUsIHRha2UgLTEyOC4gSW4gc2lnbmVkIDE2IGJpdHMgdGhpcyB3b3VsZCBiZSAweGZmODAuIElmXG4gKiB5b3UgZG8gb3V0IHRoZSBjb21wdXRhdGlvbnM6XG4gKlxuICogMHhmZmZmIC0gMTI4ICsgMVxuICogMHhmZmZmIC0gMTI3XG4gKiAweGZmODBcbiAqXG4gKiBZb3UgY2FuIHRoZW4gZW5jb2RlIHRoaXMgdmFsdWUgYXMgdGhlIHNpZ25lZCB2ZXJzaW9uLiBUaGlzIGlzIHJlYWxseSByYXRoZXJcbiAqIGhhY2t5LCBidXQgaXQgc2hvdWxkIHdvcmsgYW5kIGdldCB0aGUgam9iIGRvbmUgd2hpY2ggaXMgb3VyIGdvYWwgaGVyZS5cbiAqL1xuXG4vKlxuICogQSBzZXJpZXMgb2YgY2hlY2tzIHRvIG1ha2Ugc3VyZSB3ZSBhY3R1YWxseSBoYXZlIGEgc2lnbmVkIDMyLWJpdCBudW1iZXJcbiAqL1xuZnVuY3Rpb24gdmVyaWZzaW50KHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQub2sodHlwZW9mICh2YWx1ZSkgPT0gJ251bWJlcicsXG4gICAgICAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKTtcblxuICBhc3NlcnQub2sodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpO1xuXG4gIGFzc2VydC5vayhNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpO1xufVxuXG5mdW5jdGlvbiB2ZXJpZklFRUU3NTQodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydC5vayh0eXBlb2YgKHZhbHVlKSA9PSAnbnVtYmVyJyxcbiAgICAgICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJyk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmLCAtMHg4MCk7XG4gIH1cblxuICBpZiAodmFsdWUgPj0gMCkge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KTtcbiAgfSBlbHNlIHtcbiAgICBidWZmZXIud3JpdGVVSW50OCgweGZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIG5vQXNzZXJ0KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gd3JpdGVJbnQxNihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZiwgLTB4ODAwMCk7XG4gIH1cblxuICBpZiAodmFsdWUgPj0gMCkge1xuICAgIHdyaXRlVUludDE2KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgfSBlbHNlIHtcbiAgICB3cml0ZVVJbnQxNihidWZmZXIsIDB4ZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlSW50MzIoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMCk7XG4gIH1cblxuICBpZiAodmFsdWUgPj0gMCkge1xuICAgIHdyaXRlVUludDMyKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgfSBlbHNlIHtcbiAgICB3cml0ZVVJbnQzMihidWZmZXIsIDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUZsb2F0KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpO1xuICB9XG5cbiAgcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLndyaXRlSUVFRTc1NChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLFxuICAgICAgMjMsIDQpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZURvdWJsZShidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDcgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpO1xuICB9XG5cbiAgcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLndyaXRlSUVFRTc1NChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLFxuICAgICAgNTIsIDgpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDg7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50ODtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4O1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4O1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkU7XG5cbn0pKClcbn0se1wiYXNzZXJ0XCI6MixcIi4vYnVmZmVyX2llZWU3NTRcIjo3LFwiYmFzZTY0LWpzXCI6OX1dLDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5KGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyO1xuXHRcblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyAnSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCc7XG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHBsYWNlSG9sZGVycyA9IGI2NC5pbmRleE9mKCc9Jyk7XG5cdFx0cGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSBwbGFjZUhvbGRlcnMgOiAwO1xuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gW107Ly9uZXcgVWludDhBcnJheShiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpO1xuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGxvb2t1cC5pbmRleE9mKGI2NFtpXSkgPDwgMTgpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pIDw8IDEyKSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDJdKSA8PCA2KSB8IGxvb2t1cC5pbmRleE9mKGI2NFtpICsgM10pO1xuXHRcdFx0YXJyLnB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNik7XG5cdFx0XHRhcnIucHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KTtcblx0XHRcdGFyci5wdXNoKHRtcCAmIDB4RkYpO1xuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChsb29rdXAuaW5kZXhPZihiNjRbaV0pIDw8IDIpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pID4+IDQpO1xuXHRcdFx0YXJyLnB1c2godG1wICYgMHhGRik7XG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChsb29rdXAuaW5kZXhPZihiNjRbaV0pIDw8IDEwKSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDFdKSA8PCA0KSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDJdKSA+PiAyKTtcblx0XHRcdGFyci5wdXNoKCh0bXAgPj4gOCkgJiAweEZGKTtcblx0XHRcdGFyci5wdXNoKHRtcCAmIDB4RkYpO1xuXHRcdH1cblxuXHRcdHJldHVybiBhcnI7XG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0KHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGg7XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdO1xuXHRcdH07XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKTtcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcCk7XG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbdGVtcCA+PiAyXTtcblx0XHRcdFx0b3V0cHV0ICs9IGxvb2t1cFsodGVtcCA8PCA0KSAmIDB4M0ZdO1xuXHRcdFx0XHRvdXRwdXQgKz0gJz09Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwW3RlbXAgPj4gMTBdO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwWyh0ZW1wID4+IDQpICYgMHgzRl07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbKHRlbXAgPDwgMikgJiAweDNGXTtcblx0XHRcdFx0b3V0cHV0ICs9ICc9Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXk7XG5cdG1vZHVsZS5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0O1xufSgpKTtcblxufSx7fV19LHt9LFtdKVxuOzttb2R1bGUuZXhwb3J0cz1yZXF1aXJlKFwiYnVmZmVyLWJyb3dzZXJpZnlcIilcbiIsIihmdW5jdGlvbihCdWZmZXIpey8vICAgICB1dWlkLmpzXG4vL1xuLy8gICAgIENvcHlyaWdodCAoYykgMjAxMC0yMDEyIFJvYmVydCBLaWVmZmVyXG4vLyAgICAgTUlUIExpY2Vuc2UgLSBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIF9nbG9iYWwgPSB0aGlzO1xuXG4gIC8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuICBXZSBmZWF0dXJlXG4gIC8vIGRldGVjdCB0byBkZXRlcm1pbmUgdGhlIGJlc3QgUk5HIHNvdXJjZSwgbm9ybWFsaXppbmcgdG8gYSBmdW5jdGlvbiB0aGF0XG4gIC8vIHJldHVybnMgMTI4LWJpdHMgb2YgcmFuZG9tbmVzcywgc2luY2UgdGhhdCdzIHdoYXQncyB1c3VhbGx5IHJlcXVpcmVkXG4gIHZhciBfcm5nO1xuXG4gIC8vIE5vZGUuanMgY3J5cHRvLWJhc2VkIFJORyAtIGh0dHA6Ly9ub2RlanMub3JnL2RvY3MvdjAuNi4yL2FwaS9jcnlwdG8uaHRtbFxuICAvL1xuICAvLyBNb2RlcmF0ZWx5IGZhc3QsIGhpZ2ggcXVhbGl0eVxuICBpZiAodHlwZW9mKHJlcXVpcmUpID09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIF9yYiA9IHJlcXVpcmUoJ2NyeXB0bycpLnJhbmRvbUJ5dGVzO1xuICAgICAgX3JuZyA9IF9yYiAmJiBmdW5jdGlvbigpIHtyZXR1cm4gX3JiKDE2KTt9O1xuICAgIH0gY2F0Y2goZSkge31cbiAgfVxuXG4gIGlmICghX3JuZyAmJiBfZ2xvYmFsLmNyeXB0byAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gV0hBVFdHIGNyeXB0by1iYXNlZCBSTkcgLSBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvQ3J5cHRvXG4gICAgLy9cbiAgICAvLyBNb2RlcmF0ZWx5IGZhc3QsIGhpZ2ggcXVhbGl0eVxuICAgIHZhciBfcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgX3JuZyA9IGZ1bmN0aW9uIHdoYXR3Z1JORygpIHtcbiAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoX3JuZHM4KTtcbiAgICAgIHJldHVybiBfcm5kczg7XG4gICAgfTtcbiAgfVxuXG4gIGlmICghX3JuZykge1xuICAgIC8vIE1hdGgucmFuZG9tKCktYmFzZWQgKFJORylcbiAgICAvL1xuICAgIC8vIElmIGFsbCBlbHNlIGZhaWxzLCB1c2UgTWF0aC5yYW5kb20oKS4gIEl0J3MgZmFzdCwgYnV0IGlzIG9mIHVuc3BlY2lmaWVkXG4gICAgLy8gcXVhbGl0eS5cbiAgICB2YXIgIF9ybmRzID0gbmV3IEFycmF5KDE2KTtcbiAgICBfcm5nID0gZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgcjsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgaWYgKChpICYgMHgwMykgPT09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICAgIF9ybmRzW2ldID0gciA+Pj4gKChpICYgMHgwMykgPDwgMykgJiAweGZmO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3JuZHM7XG4gICAgfTtcbiAgfVxuXG4gIC8vIEJ1ZmZlciBjbGFzcyB0byB1c2VcbiAgdmFyIEJ1ZmZlckNsYXNzID0gdHlwZW9mKEJ1ZmZlcikgPT0gJ2Z1bmN0aW9uJyA/IEJ1ZmZlciA6IEFycmF5O1xuXG4gIC8vIE1hcHMgZm9yIG51bWJlciA8LT4gaGV4IHN0cmluZyBjb252ZXJzaW9uXG4gIHZhciBfYnl0ZVRvSGV4ID0gW107XG4gIHZhciBfaGV4VG9CeXRlID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICBfYnl0ZVRvSGV4W2ldID0gKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKTtcbiAgICBfaGV4VG9CeXRlW19ieXRlVG9IZXhbaV1dID0gaTtcbiAgfVxuXG4gIC8vICoqYHBhcnNlKClgIC0gUGFyc2UgYSBVVUlEIGludG8gaXQncyBjb21wb25lbnQgYnl0ZXMqKlxuICBmdW5jdGlvbiBwYXJzZShzLCBidWYsIG9mZnNldCkge1xuICAgIHZhciBpID0gKGJ1ZiAmJiBvZmZzZXQpIHx8IDAsIGlpID0gMDtcblxuICAgIGJ1ZiA9IGJ1ZiB8fCBbXTtcbiAgICBzLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWzAtOWEtZl17Mn0vZywgZnVuY3Rpb24ob2N0KSB7XG4gICAgICBpZiAoaWkgPCAxNikgeyAvLyBEb24ndCBvdmVyZmxvdyFcbiAgICAgICAgYnVmW2kgKyBpaSsrXSA9IF9oZXhUb0J5dGVbb2N0XTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFplcm8gb3V0IHJlbWFpbmluZyBieXRlcyBpZiBzdHJpbmcgd2FzIHNob3J0XG4gICAgd2hpbGUgKGlpIDwgMTYpIHtcbiAgICAgIGJ1ZltpICsgaWkrK10gPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBidWY7XG4gIH1cblxuICAvLyAqKmB1bnBhcnNlKClgIC0gQ29udmVydCBVVUlEIGJ5dGUgYXJyYXkgKGFsYSBwYXJzZSgpKSBpbnRvIGEgc3RyaW5nKipcbiAgZnVuY3Rpb24gdW5wYXJzZShidWYsIG9mZnNldCkge1xuICAgIHZhciBpID0gb2Zmc2V0IHx8IDAsIGJ0aCA9IF9ieXRlVG9IZXg7XG4gICAgcmV0dXJuICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXTtcbiAgfVxuXG4gIC8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbiAgLy9cbiAgLy8gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL0xpb3NLL1VVSUQuanNcbiAgLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcblxuICAvLyByYW5kb20gIydzIHdlIG5lZWQgdG8gaW5pdCBub2RlIGFuZCBjbG9ja3NlcVxuICB2YXIgX3NlZWRCeXRlcyA9IF9ybmcoKTtcblxuICAvLyBQZXIgNC41LCBjcmVhdGUgYW5kIDQ4LWJpdCBub2RlIGlkLCAoNDcgcmFuZG9tIGJpdHMgKyBtdWx0aWNhc3QgYml0ID0gMSlcbiAgdmFyIF9ub2RlSWQgPSBbXG4gICAgX3NlZWRCeXRlc1swXSB8IDB4MDEsXG4gICAgX3NlZWRCeXRlc1sxXSwgX3NlZWRCeXRlc1syXSwgX3NlZWRCeXRlc1szXSwgX3NlZWRCeXRlc1s0XSwgX3NlZWRCeXRlc1s1XVxuICBdO1xuXG4gIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gIHZhciBfY2xvY2tzZXEgPSAoX3NlZWRCeXRlc1s2XSA8PCA4IHwgX3NlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG5cbiAgLy8gUHJldmlvdXMgdXVpZCBjcmVhdGlvbiB0aW1lXG4gIHZhciBfbGFzdE1TZWNzID0gMCwgX2xhc3ROU2VjcyA9IDA7XG5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9icm9vZmEvbm9kZS11dWlkIGZvciBBUEkgZGV0YWlsc1xuICBmdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICAgIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICAgIHZhciBiID0gYnVmIHx8IFtdO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9IG51bGwgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxO1xuXG4gICAgLy8gVVVJRCB0aW1lc3RhbXBzIGFyZSAxMDAgbmFuby1zZWNvbmQgdW5pdHMgc2luY2UgdGhlIEdyZWdvcmlhbiBlcG9jaCxcbiAgICAvLyAoMTU4Mi0xMC0xNSAwMDowMCkuICBKU051bWJlcnMgYXJlbid0IHByZWNpc2UgZW5vdWdoIGZvciB0aGlzLCBzb1xuICAgIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAgIC8vICgxMDAtbmFub3NlY29uZHMgb2Zmc2V0IGZyb20gbXNlY3MpIHNpbmNlIHVuaXggZXBvY2gsIDE5NzAtMDEtMDEgMDA6MDAuXG4gICAgdmFyIG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPSBudWxsID8gb3B0aW9ucy5tc2VjcyA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgLy8gUGVyIDQuMi4xLjIsIHVzZSBjb3VudCBvZiB1dWlkJ3MgZ2VuZXJhdGVkIGR1cmluZyB0aGUgY3VycmVudCBjbG9ja1xuICAgIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG4gICAgdmFyIG5zZWNzID0gb3B0aW9ucy5uc2VjcyAhPSBudWxsID8gb3B0aW9ucy5uc2VjcyA6IF9sYXN0TlNlY3MgKyAxO1xuXG4gICAgLy8gVGltZSBzaW5jZSBsYXN0IHV1aWQgY3JlYXRpb24gKGluIG1zZWNzKVxuICAgIHZhciBkdCA9IChtc2VjcyAtIF9sYXN0TVNlY3MpICsgKG5zZWNzIC0gX2xhc3ROU2VjcykvMTAwMDA7XG5cbiAgICAvLyBQZXIgNC4yLjEuMiwgQnVtcCBjbG9ja3NlcSBvbiBjbG9jayByZWdyZXNzaW9uXG4gICAgaWYgKGR0IDwgMCAmJiBvcHRpb25zLmNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICAgIH1cblxuICAgIC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gICAgLy8gdGltZSBpbnRlcnZhbFxuICAgIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PSBudWxsKSB7XG4gICAgICBuc2VjcyA9IDA7XG4gICAgfVxuXG4gICAgLy8gUGVyIDQuMi4xLjIgVGhyb3cgZXJyb3IgaWYgdG9vIG1hbnkgdXVpZHMgYXJlIHJlcXVlc3RlZFxuICAgIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1dWlkLnYxKCk6IENhblxcJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjJyk7XG4gICAgfVxuXG4gICAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICAgIF9sYXN0TlNlY3MgPSBuc2VjcztcbiAgICBfY2xvY2tzZXEgPSBjbG9ja3NlcTtcblxuICAgIC8vIFBlciA0LjEuNCAtIENvbnZlcnQgZnJvbSB1bml4IGVwb2NoIHRvIEdyZWdvcmlhbiBlcG9jaFxuICAgIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwO1xuXG4gICAgLy8gYHRpbWVfbG93YFxuICAgIHZhciB0bCA9ICgobXNlY3MgJiAweGZmZmZmZmYpICogMTAwMDAgKyBuc2VjcykgJSAweDEwMDAwMDAwMDtcbiAgICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICAgIGJbaSsrXSA9IHRsID4+PiAxNiAmIDB4ZmY7XG4gICAgYltpKytdID0gdGwgPj4+IDggJiAweGZmO1xuICAgIGJbaSsrXSA9IHRsICYgMHhmZjtcblxuICAgIC8vIGB0aW1lX21pZGBcbiAgICB2YXIgdG1oID0gKG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCkgJiAweGZmZmZmZmY7XG4gICAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgICBiW2krK10gPSB0bWggJiAweGZmO1xuXG4gICAgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcbiAgICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG4gICAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7XG5cbiAgICAvLyBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGAgKFBlciA0LjIuMiAtIGluY2x1ZGUgdmFyaWFudClcbiAgICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7XG5cbiAgICAvLyBgY2xvY2tfc2VxX2xvd2BcbiAgICBiW2krK10gPSBjbG9ja3NlcSAmIDB4ZmY7XG5cbiAgICAvLyBgbm9kZWBcbiAgICB2YXIgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgNjsgbisrKSB7XG4gICAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZiA/IGJ1ZiA6IHVucGFyc2UoYik7XG4gIH1cblxuICAvLyAqKmB2NCgpYCAtIEdlbmVyYXRlIHJhbmRvbSBVVUlEKipcblxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWQgZm9yIEFQSSBkZXRhaWxzXG4gIGZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgLy8gRGVwcmVjYXRlZCAtICdmb3JtYXQnIGFyZ3VtZW50LCBhcyBzdXBwb3J0ZWQgaW4gdjEuMlxuICAgIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuXG4gICAgaWYgKHR5cGVvZihvcHRpb25zKSA9PSAnc3RyaW5nJykge1xuICAgICAgYnVmID0gb3B0aW9ucyA9PSAnYmluYXJ5JyA/IG5ldyBCdWZmZXJDbGFzcygxNikgOiBudWxsO1xuICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgX3JuZykoKTtcblxuICAgIC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcbiAgICBybmRzWzZdID0gKHJuZHNbNl0gJiAweDBmKSB8IDB4NDA7XG4gICAgcm5kc1s4XSA9IChybmRzWzhdICYgMHgzZikgfCAweDgwO1xuXG4gICAgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG4gICAgaWYgKGJ1Zikge1xuICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IDE2OyBpaSsrKSB7XG4gICAgICAgIGJ1ZltpICsgaWldID0gcm5kc1tpaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZiB8fCB1bnBhcnNlKHJuZHMpO1xuICB9XG5cbiAgLy8gRXhwb3J0IHB1YmxpYyBBUElcbiAgdmFyIHV1aWQgPSB2NDtcbiAgdXVpZC52MSA9IHYxO1xuICB1dWlkLnY0ID0gdjQ7XG4gIHV1aWQucGFyc2UgPSBwYXJzZTtcbiAgdXVpZC51bnBhcnNlID0gdW5wYXJzZTtcbiAgdXVpZC5CdWZmZXJDbGFzcyA9IEJ1ZmZlckNsYXNzO1xuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBQdWJsaXNoIGFzIEFNRCBtb2R1bGVcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7cmV0dXJuIHV1aWQ7fSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mKG1vZHVsZSkgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAvLyBQdWJsaXNoIGFzIG5vZGUuanMgbW9kdWxlXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB1dWlkO1xuICB9IGVsc2Uge1xuICAgIC8vIFB1Ymxpc2ggYXMgZ2xvYmFsIChpbiBicm93c2VycylcbiAgICB2YXIgX3ByZXZpb3VzUm9vdCA9IF9nbG9iYWwudXVpZDtcblxuICAgIC8vICoqYG5vQ29uZmxpY3QoKWAgLSAoYnJvd3NlciBvbmx5KSB0byByZXNldCBnbG9iYWwgJ3V1aWQnIHZhcioqXG4gICAgdXVpZC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBfZ2xvYmFsLnV1aWQgPSBfcHJldmlvdXNSb290O1xuICAgICAgcmV0dXJuIHV1aWQ7XG4gICAgfTtcblxuICAgIF9nbG9iYWwudXVpZCA9IHV1aWQ7XG4gIH1cbn0pLmNhbGwodGhpcyk7XG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfYnVmZmVyXCIpLkJ1ZmZlcikiLCJtb2R1bGUuZXhwb3J0cyA9IGFycmF5RGlmZjtcblxuLy8gQmFzZWQgb24gc29tZSByb3VnaCBiZW5jaG1hcmtpbmcsIHRoaXMgYWxnb3JpdGhtIGlzIGFib3V0IE8oMm4pIHdvcnN0IGNhc2UsXG4vLyBhbmQgaXQgY2FuIGNvbXB1dGUgZGlmZnMgb24gcmFuZG9tIGFycmF5cyBvZiBsZW5ndGggMTAyNCBpbiBhYm91dCAzNG1zLFxuLy8gdGhvdWdoIGp1c3QgYSBmZXcgY2hhbmdlcyBvbiBhbiBhcnJheSBvZiBsZW5ndGggMTAyNCB0YWtlcyBhYm91dCAwLjVtc1xuXG5hcnJheURpZmYuSW5zZXJ0RGlmZiA9IEluc2VydERpZmY7XG5hcnJheURpZmYuUmVtb3ZlRGlmZiA9IFJlbW92ZURpZmY7XG5hcnJheURpZmYuTW92ZURpZmYgPSBNb3ZlRGlmZjtcblxuZnVuY3Rpb24gSW5zZXJ0RGlmZihpbmRleCwgdmFsdWVzKSB7XG4gIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG59XG5JbnNlcnREaWZmLnByb3RvdHlwZS50eXBlID0gJ2luc2VydCc7XG5JbnNlcnREaWZmLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0aGlzLnR5cGVcbiAgLCBpbmRleDogdGhpcy5pbmRleFxuICAsIHZhbHVlczogdGhpcy52YWx1ZXNcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIFJlbW92ZURpZmYoaW5kZXgsIGhvd01hbnkpIHtcbiAgdGhpcy5pbmRleCA9IGluZGV4O1xuICB0aGlzLmhvd01hbnkgPSBob3dNYW55O1xufVxuUmVtb3ZlRGlmZi5wcm90b3R5cGUudHlwZSA9ICdyZW1vdmUnO1xuUmVtb3ZlRGlmZi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdGhpcy50eXBlXG4gICwgaW5kZXg6IHRoaXMuaW5kZXhcbiAgLCBob3dNYW55OiB0aGlzLmhvd01hbnlcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIE1vdmVEaWZmKGZyb20sIHRvLCBob3dNYW55KSB7XG4gIHRoaXMuZnJvbSA9IGZyb207XG4gIHRoaXMudG8gPSB0bztcbiAgdGhpcy5ob3dNYW55ID0gaG93TWFueTtcbn1cbk1vdmVEaWZmLnByb3RvdHlwZS50eXBlID0gJ21vdmUnO1xuTW92ZURpZmYucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHRoaXMudHlwZVxuICAsIGZyb206IHRoaXMuZnJvbVxuICAsIHRvOiB0aGlzLnRvXG4gICwgaG93TWFueTogdGhpcy5ob3dNYW55XG4gIH07XG59O1xuXG5mdW5jdGlvbiBzdHJpY3RFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufVxuXG5mdW5jdGlvbiBhcnJheURpZmYoYmVmb3JlLCBhZnRlciwgZXF1YWxGbikge1xuICBpZiAoIWVxdWFsRm4pIGVxdWFsRm4gPSBzdHJpY3RFcXVhbDtcblxuICAvLyBGaW5kIGFsbCBpdGVtcyBpbiBib3RoIHRoZSBiZWZvcmUgYW5kIGFmdGVyIGFycmF5LCBhbmQgcmVwcmVzZW50IHRoZW1cbiAgLy8gYXMgbW92ZXMuIE1hbnkgb2YgdGhlc2UgXCJtb3Zlc1wiIG1heSBlbmQgdXAgYmVpbmcgZGlzY2FyZGVkIGluIHRoZSBsYXN0XG4gIC8vIHBhc3MgaWYgdGhleSBhcmUgZnJvbSBhbiBpbmRleCB0byB0aGUgc2FtZSBpbmRleCwgYnV0IHdlIGRvbid0IGtub3cgdGhpc1xuICAvLyB1cCBmcm9udCwgc2luY2Ugd2UgaGF2ZW4ndCB5ZXQgb2Zmc2V0IHRoZSBpbmRpY2VzLlxuICAvLyBcbiAgLy8gQWxzbyBrZWVwIGEgbWFwIG9mIGFsbCB0aGUgaW5kaWNpZXMgYWNjb3VudGVkIGZvciBpbiB0aGUgYmVmb3JlIGFuZCBhZnRlclxuICAvLyBhcnJheXMuIFRoZXNlIG1hcHMgYXJlIHVzZWQgbmV4dCB0byBjcmVhdGUgaW5zZXJ0IGFuZCByZW1vdmUgZGlmZnMuXG4gIHZhciBiZWZvcmVMZW5ndGggPSBiZWZvcmUubGVuZ3RoO1xuICB2YXIgYWZ0ZXJMZW5ndGggPSBhZnRlci5sZW5ndGg7XG4gIHZhciBtb3ZlcyA9IFtdO1xuICB2YXIgYmVmb3JlTWFya2VkID0ge307XG4gIHZhciBhZnRlck1hcmtlZCA9IHt9O1xuICBmb3IgKHZhciBiZWZvcmVJbmRleCA9IDA7IGJlZm9yZUluZGV4IDwgYmVmb3JlTGVuZ3RoOyBiZWZvcmVJbmRleCsrKSB7XG4gICAgdmFyIGJlZm9yZUl0ZW0gPSBiZWZvcmVbYmVmb3JlSW5kZXhdO1xuICAgIGZvciAodmFyIGFmdGVySW5kZXggPSAwOyBhZnRlckluZGV4IDwgYWZ0ZXJMZW5ndGg7IGFmdGVySW5kZXgrKykge1xuICAgICAgaWYgKGFmdGVyTWFya2VkW2FmdGVySW5kZXhdKSBjb250aW51ZTtcbiAgICAgIGlmICghZXF1YWxGbihiZWZvcmVJdGVtLCBhZnRlclthZnRlckluZGV4XSkpIGNvbnRpbnVlO1xuICAgICAgdmFyIGZyb20gPSBiZWZvcmVJbmRleDtcbiAgICAgIHZhciB0byA9IGFmdGVySW5kZXg7XG4gICAgICB2YXIgaG93TWFueSA9IDA7XG4gICAgICBkbyB7XG4gICAgICAgIGJlZm9yZU1hcmtlZFtiZWZvcmVJbmRleCsrXSA9IGFmdGVyTWFya2VkW2FmdGVySW5kZXgrK10gPSB0cnVlO1xuICAgICAgICBob3dNYW55Kys7XG4gICAgICB9IHdoaWxlIChcbiAgICAgICAgYmVmb3JlSW5kZXggPCBiZWZvcmVMZW5ndGggJiZcbiAgICAgICAgYWZ0ZXJJbmRleCA8IGFmdGVyTGVuZ3RoICYmXG4gICAgICAgIGVxdWFsRm4oYmVmb3JlW2JlZm9yZUluZGV4XSwgYWZ0ZXJbYWZ0ZXJJbmRleF0pICYmXG4gICAgICAgICFhZnRlck1hcmtlZFthZnRlckluZGV4XVxuICAgICAgKTtcbiAgICAgIG1vdmVzLnB1c2gobmV3IE1vdmVEaWZmKGZyb20sIHRvLCBob3dNYW55KSk7XG4gICAgICBiZWZvcmVJbmRleC0tO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlIGEgcmVtb3ZlIGZvciBhbGwgb2YgdGhlIGl0ZW1zIGluIHRoZSBiZWZvcmUgYXJyYXkgdGhhdCB3ZXJlXG4gIC8vIG5vdCBtYXJrZWQgYXMgYmVpbmcgbWF0Y2hlZCBpbiB0aGUgYWZ0ZXIgYXJyYXkgYXMgd2VsbFxuICB2YXIgcmVtb3ZlcyA9IFtdO1xuICBmb3IgKGJlZm9yZUluZGV4ID0gMDsgYmVmb3JlSW5kZXggPCBiZWZvcmVMZW5ndGg7KSB7XG4gICAgaWYgKGJlZm9yZU1hcmtlZFtiZWZvcmVJbmRleF0pIHtcbiAgICAgIGJlZm9yZUluZGV4Kys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gYmVmb3JlSW5kZXg7XG4gICAgdmFyIGhvd01hbnkgPSAwO1xuICAgIHdoaWxlIChiZWZvcmVJbmRleCA8IGJlZm9yZUxlbmd0aCAmJiAhYmVmb3JlTWFya2VkW2JlZm9yZUluZGV4KytdKSB7XG4gICAgICBob3dNYW55Kys7XG4gICAgfVxuICAgIHJlbW92ZXMucHVzaChuZXcgUmVtb3ZlRGlmZihpbmRleCwgaG93TWFueSkpO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGFuIGluc2VydCBmb3IgYWxsIG9mIHRoZSBpdGVtcyBpbiB0aGUgYWZ0ZXIgYXJyYXkgdGhhdCB3ZXJlXG4gIC8vIG5vdCBtYXJrZWQgYXMgYmVpbmcgbWF0Y2hlZCBpbiB0aGUgYmVmb3JlIGFycmF5IGFzIHdlbGxcbiAgdmFyIGluc2VydHMgPSBbXTtcbiAgZm9yIChhZnRlckluZGV4ID0gMDsgYWZ0ZXJJbmRleCA8IGFmdGVyTGVuZ3RoOykge1xuICAgIGlmIChhZnRlck1hcmtlZFthZnRlckluZGV4XSkge1xuICAgICAgYWZ0ZXJJbmRleCsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpbmRleCA9IGFmdGVySW5kZXg7XG4gICAgdmFyIGhvd01hbnkgPSAwO1xuICAgIHdoaWxlIChhZnRlckluZGV4IDwgYWZ0ZXJMZW5ndGggJiYgIWFmdGVyTWFya2VkW2FmdGVySW5kZXgrK10pIHtcbiAgICAgIGhvd01hbnkrKztcbiAgICB9XG4gICAgdmFyIHZhbHVlcyA9IGFmdGVyLnNsaWNlKGluZGV4LCBpbmRleCArIGhvd01hbnkpO1xuICAgIGluc2VydHMucHVzaChuZXcgSW5zZXJ0RGlmZihpbmRleCwgdmFsdWVzKSk7XG4gIH1cblxuICB2YXIgaW5zZXJ0c0xlbmd0aCA9IGluc2VydHMubGVuZ3RoO1xuICB2YXIgcmVtb3Zlc0xlbmd0aCA9IHJlbW92ZXMubGVuZ3RoO1xuICB2YXIgbW92ZXNMZW5ndGggPSBtb3Zlcy5sZW5ndGg7XG4gIHZhciBpLCBqO1xuXG4gIC8vIE9mZnNldCBzdWJzZXF1ZW50IHJlbW92ZXMgYW5kIG1vdmVzIGJ5IHJlbW92ZXNcbiAgdmFyIGNvdW50ID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IHJlbW92ZXNMZW5ndGg7IGkrKykge1xuICAgIHZhciByZW1vdmUgPSByZW1vdmVzW2ldO1xuICAgIHJlbW92ZS5pbmRleCAtPSBjb3VudDtcbiAgICBjb3VudCArPSByZW1vdmUuaG93TWFueTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW92ZXNMZW5ndGg7IGorKykge1xuICAgICAgdmFyIG1vdmUgPSBtb3Zlc1tqXTtcbiAgICAgIGlmIChtb3ZlLmZyb20gPj0gcmVtb3ZlLmluZGV4KSBtb3ZlLmZyb20gLT0gcmVtb3ZlLmhvd01hbnk7XG4gICAgfVxuICB9XG5cbiAgLy8gT2Zmc2V0IG1vdmVzIGJ5IGluc2VydHNcbiAgZm9yIChpID0gaW5zZXJ0c0xlbmd0aDsgaS0tOykge1xuICAgIHZhciBpbnNlcnQgPSBpbnNlcnRzW2ldO1xuICAgIHZhciBob3dNYW55ID0gaW5zZXJ0LnZhbHVlcy5sZW5ndGg7XG4gICAgZm9yIChqID0gbW92ZXNMZW5ndGg7IGotLTspIHtcbiAgICAgIHZhciBtb3ZlID0gbW92ZXNbal07XG4gICAgICBpZiAobW92ZS50byA+PSBpbnNlcnQuaW5kZXgpIG1vdmUudG8gLT0gaG93TWFueTtcbiAgICB9XG4gIH1cblxuICAvLyBPZmZzZXQgdGhlIHRvIG9mIG1vdmVzIGJ5IGxhdGVyIG1vdmVzXG4gIGZvciAoaSA9IG1vdmVzTGVuZ3RoOyBpLS0gPiAxOykge1xuICAgIHZhciBtb3ZlID0gbW92ZXNbaV07XG4gICAgaWYgKG1vdmUudG8gPT09IG1vdmUuZnJvbSkgY29udGludWU7XG4gICAgZm9yIChqID0gaTsgai0tOykge1xuICAgICAgdmFyIGVhcmxpZXIgPSBtb3Zlc1tqXTtcbiAgICAgIGlmIChlYXJsaWVyLnRvID49IG1vdmUudG8pIGVhcmxpZXIudG8gLT0gbW92ZS5ob3dNYW55O1xuICAgICAgaWYgKGVhcmxpZXIudG8gPj0gbW92ZS5mcm9tKSBlYXJsaWVyLnRvICs9IG1vdmUuaG93TWFueTtcbiAgICB9XG4gIH1cblxuICAvLyBPbmx5IG91dHB1dCBtb3ZlcyB0aGF0IGVuZCB1cCBoYXZpbmcgYW4gZWZmZWN0IGFmdGVyIG9mZnNldHRpbmdcbiAgdmFyIG91dHB1dE1vdmVzID0gW107XG5cbiAgLy8gT2Zmc2V0IHRoZSBmcm9tIG9mIG1vdmVzIGJ5IGVhcmxpZXIgbW92ZXNcbiAgZm9yIChpID0gMDsgaSA8IG1vdmVzTGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbW92ZSA9IG1vdmVzW2ldO1xuICAgIGlmIChtb3ZlLnRvID09PSBtb3ZlLmZyb20pIGNvbnRpbnVlO1xuICAgIG91dHB1dE1vdmVzLnB1c2gobW92ZSk7XG4gICAgZm9yIChqID0gaSArIDE7IGogPCBtb3Zlc0xlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgbGF0ZXIgPSBtb3Zlc1tqXTtcbiAgICAgIGlmIChsYXRlci5mcm9tID49IG1vdmUuZnJvbSkgbGF0ZXIuZnJvbSAtPSBtb3ZlLmhvd01hbnk7XG4gICAgICBpZiAobGF0ZXIuZnJvbSA+PSBtb3ZlLnRvKSBsYXRlci5mcm9tICs9IG1vdmUuaG93TWFueTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVtb3Zlcy5jb25jYXQob3V0cHV0TW92ZXMsIGluc2VydHMpO1xufVxuIiwiLyoqXG4gKiBPYmplY3QjdG9TdHJpbmcoKSByZWYgZm9yIHN0cmluZ2lmeSgpLlxuICovXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogT2JqZWN0I2hhc093blByb3BlcnR5IHJlZlxuICovXG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXJyYXkjaW5kZXhPZiBzaGltLlxuICovXG5cbnZhciBpbmRleE9mID0gdHlwZW9mIEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nXG4gID8gZnVuY3Rpb24oYXJyLCBlbCkgeyByZXR1cm4gYXJyLmluZGV4T2YoZWwpOyB9XG4gIDogZnVuY3Rpb24oYXJyLCBlbCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFycltpXSA9PT0gZWwpIHJldHVybiBpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG5cbi8qKlxuICogQXJyYXkuaXNBcnJheSBzaGltLlxuICovXG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuLyoqXG4gKiBPYmplY3Qua2V5cyBzaGltLlxuICovXG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ob2JqKSB7XG4gIHZhciByZXQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikgcmV0LnB1c2goa2V5KTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogQXJyYXkjZm9yRWFjaCBzaGltLlxuICovXG5cbnZhciBmb3JFYWNoID0gdHlwZW9mIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoID09PSAnZnVuY3Rpb24nXG4gID8gZnVuY3Rpb24oYXJyLCBmbikgeyByZXR1cm4gYXJyLmZvckVhY2goZm4pOyB9XG4gIDogZnVuY3Rpb24oYXJyLCBmbikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGZuKGFycltpXSk7XG4gICAgfTtcblxuLyoqXG4gKiBBcnJheSNyZWR1Y2Ugc2hpbS5cbiAqL1xuXG52YXIgcmVkdWNlID0gZnVuY3Rpb24oYXJyLCBmbiwgaW5pdGlhbCkge1xuICBpZiAodHlwZW9mIGFyci5yZWR1Y2UgPT09ICdmdW5jdGlvbicpIHJldHVybiBhcnIucmVkdWNlKGZuLCBpbml0aWFsKTtcbiAgdmFyIHJlcyA9IGluaXRpYWw7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSByZXMgPSBmbihyZXMsIGFycltpXSk7XG4gIHJldHVybiByZXM7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG51bGxhcnkgb2JqZWN0IGlmIHBvc3NpYmxlXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlT2JqZWN0KCkge1xuICByZXR1cm4gT2JqZWN0LmNyZWF0ZVxuICAgID8gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIDoge307XG59XG5cbi8qKlxuICogQ2FjaGUgbm9uLWludGVnZXIgdGVzdCByZWdleHAuXG4gKi9cblxudmFyIGlzaW50ID0gL15bMC05XSskLztcblxuZnVuY3Rpb24gcHJvbW90ZShwYXJlbnQsIGtleSkge1xuICBpZiAocGFyZW50W2tleV0ubGVuZ3RoID09IDApIHJldHVybiBwYXJlbnRba2V5XSA9IGNyZWF0ZU9iamVjdCgpO1xuICB2YXIgdCA9IGNyZWF0ZU9iamVjdCgpO1xuICBmb3IgKHZhciBpIGluIHBhcmVudFtrZXldKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocGFyZW50W2tleV0sIGkpKSB7XG4gICAgICB0W2ldID0gcGFyZW50W2tleV1baV07XG4gICAgfVxuICB9XG4gIHBhcmVudFtrZXldID0gdDtcbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlKHBhcnRzLCBwYXJlbnQsIGtleSwgdmFsKSB7XG4gIHZhciBwYXJ0ID0gcGFydHMuc2hpZnQoKTtcbiAgLy8gZW5kXG4gIGlmICghcGFydCkge1xuICAgIGlmIChpc0FycmF5KHBhcmVudFtrZXldKSkge1xuICAgICAgcGFyZW50W2tleV0ucHVzaCh2YWwpO1xuICAgIH0gZWxzZSBpZiAoJ29iamVjdCcgPT0gdHlwZW9mIHBhcmVudFtrZXldKSB7XG4gICAgICBwYXJlbnRba2V5XSA9IHZhbDtcbiAgICB9IGVsc2UgaWYgKCd1bmRlZmluZWQnID09IHR5cGVvZiBwYXJlbnRba2V5XSkge1xuICAgICAgcGFyZW50W2tleV0gPSB2YWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudFtrZXldID0gW3BhcmVudFtrZXldLCB2YWxdO1xuICAgIH1cbiAgICAvLyBhcnJheVxuICB9IGVsc2Uge1xuICAgIHZhciBvYmogPSBwYXJlbnRba2V5XSA9IHBhcmVudFtrZXldIHx8IFtdO1xuICAgIGlmICgnXScgPT0gcGFydCkge1xuICAgICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICBpZiAoJycgIT0gdmFsKSBvYmoucHVzaCh2YWwpO1xuICAgICAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PSB0eXBlb2Ygb2JqKSB7XG4gICAgICAgIG9ialtvYmplY3RLZXlzKG9iaikubGVuZ3RoXSA9IHZhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iaiA9IHBhcmVudFtrZXldID0gW3BhcmVudFtrZXldLCB2YWxdO1xuICAgICAgfVxuICAgICAgLy8gcHJvcFxuICAgIH0gZWxzZSBpZiAofmluZGV4T2YocGFydCwgJ10nKSkge1xuICAgICAgcGFydCA9IHBhcnQuc3Vic3RyKDAsIHBhcnQubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoIWlzaW50LnRlc3QocGFydCkgJiYgaXNBcnJheShvYmopKSBvYmogPSBwcm9tb3RlKHBhcmVudCwga2V5KTtcbiAgICAgIHBhcnNlKHBhcnRzLCBvYmosIHBhcnQsIHZhbCk7XG4gICAgICAvLyBrZXlcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFpc2ludC50ZXN0KHBhcnQpICYmIGlzQXJyYXkob2JqKSkgb2JqID0gcHJvbW90ZShwYXJlbnQsIGtleSk7XG4gICAgICBwYXJzZShwYXJ0cywgb2JqLCBwYXJ0LCB2YWwpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHBhcmVudCBrZXkvdmFsIHBhaXIuXG4gKi9cblxuZnVuY3Rpb24gbWVyZ2UocGFyZW50LCBrZXksIHZhbCl7XG4gIGlmICh+aW5kZXhPZihrZXksICddJykpIHtcbiAgICB2YXIgcGFydHMgPSBrZXkuc3BsaXQoJ1snKVxuICAgICAgLCBsZW4gPSBwYXJ0cy5sZW5ndGhcbiAgICAgICwgbGFzdCA9IGxlbiAtIDE7XG4gICAgcGFyc2UocGFydHMsIHBhcmVudCwgJ2Jhc2UnLCB2YWwpO1xuICAgIC8vIG9wdGltaXplXG4gIH0gZWxzZSB7XG4gICAgaWYgKCFpc2ludC50ZXN0KGtleSkgJiYgaXNBcnJheShwYXJlbnQuYmFzZSkpIHtcbiAgICAgIHZhciB0ID0gY3JlYXRlT2JqZWN0KCk7XG4gICAgICBmb3IgKHZhciBrIGluIHBhcmVudC5iYXNlKSB0W2tdID0gcGFyZW50LmJhc2Vba107XG4gICAgICBwYXJlbnQuYmFzZSA9IHQ7XG4gICAgfVxuICAgIHNldChwYXJlbnQuYmFzZSwga2V5LCB2YWwpO1xuICB9XG5cbiAgcmV0dXJuIHBhcmVudDtcbn1cblxuLyoqXG4gKiBDb21wYWN0IHNwYXJzZSBhcnJheXMuXG4gKi9cblxuZnVuY3Rpb24gY29tcGFjdChvYmopIHtcbiAgaWYgKCdvYmplY3QnICE9IHR5cGVvZiBvYmopIHJldHVybiBvYmo7XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIHZhciByZXQgPSBbXTtcblxuICAgIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSB7XG4gICAgICAgIHJldC5wdXNoKG9ialtpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBvYmpba2V5XSA9IGNvbXBhY3Qob2JqW2tleV0pO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBSZXN0b3JlIE9iamVjdC5wcm90b3R5cGUuXG4gKiBzZWUgcHVsbC1yZXF1ZXN0ICM1OFxuICovXG5cbmZ1bmN0aW9uIHJlc3RvcmVQcm90byhvYmopIHtcbiAgaWYgKCFPYmplY3QuY3JlYXRlKSByZXR1cm4gb2JqO1xuICBpZiAoaXNBcnJheShvYmopKSByZXR1cm4gb2JqO1xuICBpZiAob2JqICYmICdvYmplY3QnICE9IHR5cGVvZiBvYmopIHJldHVybiBvYmo7XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgb2JqW2tleV0gPSByZXN0b3JlUHJvdG8ob2JqW2tleV0pO1xuICAgIH1cbiAgfVxuXG4gIG9iai5fX3Byb3RvX18gPSBPYmplY3QucHJvdG90eXBlO1xuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBvYmouXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VPYmplY3Qob2JqKXtcbiAgdmFyIHJldCA9IHsgYmFzZToge30gfTtcblxuICBmb3JFYWNoKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24obmFtZSl7XG4gICAgbWVyZ2UocmV0LCBuYW1lLCBvYmpbbmFtZV0pO1xuICB9KTtcblxuICByZXR1cm4gY29tcGFjdChyZXQuYmFzZSk7XG59XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIHN0ci5cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVN0cmluZyhzdHIpe1xuICB2YXIgcmV0ID0gcmVkdWNlKFN0cmluZyhzdHIpLnNwbGl0KCcmJyksIGZ1bmN0aW9uKHJldCwgcGFpcil7XG4gICAgdmFyIGVxbCA9IGluZGV4T2YocGFpciwgJz0nKVxuICAgICAgLCBicmFjZSA9IGxhc3RCcmFjZUluS2V5KHBhaXIpXG4gICAgICAsIGtleSA9IHBhaXIuc3Vic3RyKDAsIGJyYWNlIHx8IGVxbClcbiAgICAgICwgdmFsID0gcGFpci5zdWJzdHIoYnJhY2UgfHwgZXFsLCBwYWlyLmxlbmd0aClcbiAgICAgICwgdmFsID0gdmFsLnN1YnN0cihpbmRleE9mKHZhbCwgJz0nKSArIDEsIHZhbC5sZW5ndGgpO1xuXG4gICAgLy8gP2Zvb1xuICAgIGlmICgnJyA9PSBrZXkpIGtleSA9IHBhaXIsIHZhbCA9ICcnO1xuICAgIGlmICgnJyA9PSBrZXkpIHJldHVybiByZXQ7XG5cbiAgICByZXR1cm4gbWVyZ2UocmV0LCBkZWNvZGUoa2V5KSwgZGVjb2RlKHZhbCkpO1xuICB9LCB7IGJhc2U6IGNyZWF0ZU9iamVjdCgpIH0pLmJhc2U7XG5cbiAgcmV0dXJuIHJlc3RvcmVQcm90byhjb21wYWN0KHJldCkpO1xufVxuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBxdWVyeSBgc3RyYCBvciBgb2JqYCwgcmV0dXJuaW5nIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIHwge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbihzdHIpe1xuICBpZiAobnVsbCA9PSBzdHIgfHwgJycgPT0gc3RyKSByZXR1cm4ge307XG4gIHJldHVybiAnb2JqZWN0JyA9PSB0eXBlb2Ygc3RyXG4gICAgPyBwYXJzZU9iamVjdChzdHIpXG4gICAgOiBwYXJzZVN0cmluZyhzdHIpO1xufTtcblxuLyoqXG4gKiBUdXJuIHRoZSBnaXZlbiBgb2JqYCBpbnRvIGEgcXVlcnkgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG52YXIgc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbihvYmosIHByZWZpeCkge1xuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KG9iaiwgcHJlZml4KTtcbiAgfSBlbHNlIGlmICgnW29iamVjdCBPYmplY3RdJyA9PSB0b1N0cmluZy5jYWxsKG9iaikpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KG9iaiwgcHJlZml4KTtcbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PSB0eXBlb2Ygb2JqKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeVN0cmluZyhvYmosIHByZWZpeCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByZWZpeCArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcob2JqKSk7XG4gIH1cbn07XG5cbi8qKlxuICogU3RyaW5naWZ5IHRoZSBnaXZlbiBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlTdHJpbmcoc3RyLCBwcmVmaXgpIHtcbiAgaWYgKCFwcmVmaXgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ2lmeSBleHBlY3RzIGFuIG9iamVjdCcpO1xuICByZXR1cm4gcHJlZml4ICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cik7XG59XG5cbi8qKlxuICogU3RyaW5naWZ5IHRoZSBnaXZlbiBgYXJyYC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXhcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5KGFyciwgcHJlZml4KSB7XG4gIHZhciByZXQgPSBbXTtcbiAgaWYgKCFwcmVmaXgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ2lmeSBleHBlY3RzIGFuIG9iamVjdCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIHJldC5wdXNoKHN0cmluZ2lmeShhcnJbaV0sIHByZWZpeCArICdbJyArIGkgKyAnXScpKTtcbiAgfVxuICByZXR1cm4gcmV0LmpvaW4oJyYnKTtcbn1cblxuLyoqXG4gKiBTdHJpbmdpZnkgdGhlIGdpdmVuIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXhcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdChvYmosIHByZWZpeCkge1xuICB2YXIgcmV0ID0gW11cbiAgICAsIGtleXMgPSBvYmplY3RLZXlzKG9iailcbiAgICAsIGtleTtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgaWYgKCcnID09IGtleSkgY29udGludWU7XG4gICAgaWYgKG51bGwgPT0gb2JqW2tleV0pIHtcbiAgICAgIHJldC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0LnB1c2goc3RyaW5naWZ5KG9ialtrZXldLCBwcmVmaXhcbiAgICAgICAgPyBwcmVmaXggKyAnWycgKyBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICddJ1xuICAgICAgICA6IGVuY29kZVVSSUNvbXBvbmVudChrZXkpKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldC5qb2luKCcmJyk7XG59XG5cbi8qKlxuICogU2V0IGBvYmpgJ3MgYGtleWAgdG8gYHZhbGAgcmVzcGVjdGluZ1xuICogdGhlIHdlaXJkIGFuZCB3b25kZXJmdWwgc3ludGF4IG9mIGEgcXMsXG4gKiB3aGVyZSBcImZvbz1iYXImZm9vPWJhelwiIGJlY29tZXMgYW4gYXJyYXkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2V0KG9iaiwga2V5LCB2YWwpIHtcbiAgdmFyIHYgPSBvYmpba2V5XTtcbiAgaWYgKHVuZGVmaW5lZCA9PT0gdikge1xuICAgIG9ialtrZXldID0gdmFsO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodikpIHtcbiAgICB2LnB1c2godmFsKTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IFt2LCB2YWxdO1xuICB9XG59XG5cbi8qKlxuICogTG9jYXRlIGxhc3QgYnJhY2UgaW4gYHN0cmAgd2l0aGluIHRoZSBrZXkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbGFzdEJyYWNlSW5LZXkoc3RyKSB7XG4gIHZhciBsZW4gPSBzdHIubGVuZ3RoXG4gICAgLCBicmFjZVxuICAgICwgYztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGMgPSBzdHJbaV07XG4gICAgaWYgKCddJyA9PSBjKSBicmFjZSA9IGZhbHNlO1xuICAgIGlmICgnWycgPT0gYykgYnJhY2UgPSB0cnVlO1xuICAgIGlmICgnPScgPT0gYyAmJiAhYnJhY2UpIHJldHVybiBpO1xuICB9XG59XG5cbi8qKlxuICogRGVjb2RlIGBzdHJgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGRlY29kZShzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0ci5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cbiIsIihmdW5jdGlvbigpe1xyXG4gIHZhciBjcnlwdCA9IHJlcXVpcmUoJ2NyeXB0JyksXHJcbiAgICAgIHV0ZjggPSByZXF1aXJlKCdjaGFyZW5jJykudXRmOCxcclxuICAgICAgYmluID0gcmVxdWlyZSgnY2hhcmVuYycpLmJpbixcclxuXHJcbiAgLy8gVGhlIGNvcmVcclxuICBtZDUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgLy8gQ29udmVydCB0byBieXRlIGFycmF5XHJcbiAgICBpZiAobWVzc2FnZS5jb25zdHJ1Y3RvciA9PSBTdHJpbmcpXHJcbiAgICAgIG1lc3NhZ2UgPSB1dGY4LnN0cmluZ1RvQnl0ZXMobWVzc2FnZSk7XHJcbiAgICBlbHNlIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlKSlcclxuICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UudG9TdHJpbmcoKTtcclxuICAgIC8vIGVsc2UsIGFzc3VtZSBieXRlIGFycmF5IGFscmVhZHlcclxuXHJcbiAgICB2YXIgbSA9IGNyeXB0LmJ5dGVzVG9Xb3JkcyhtZXNzYWdlKSxcclxuICAgICAgICBsID0gbWVzc2FnZS5sZW5ndGggKiA4LFxyXG4gICAgICAgIGEgPSAgMTczMjU4NDE5MyxcclxuICAgICAgICBiID0gLTI3MTczMzg3OSxcclxuICAgICAgICBjID0gLTE3MzI1ODQxOTQsXHJcbiAgICAgICAgZCA9ICAyNzE3MzM4Nzg7XHJcblxyXG4gICAgLy8gU3dhcCBlbmRpYW5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKykge1xyXG4gICAgICBtW2ldID0gKChtW2ldIDw8ICA4KSB8IChtW2ldID4+PiAyNCkpICYgMHgwMEZGMDBGRiB8XHJcbiAgICAgICAgICAgICAoKG1baV0gPDwgMjQpIHwgKG1baV0gPj4+ICA4KSkgJiAweEZGMDBGRjAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFBhZGRpbmdcclxuICAgIG1bbCA+Pj4gNV0gfD0gMHg4MCA8PCAobCAlIDMyKTtcclxuICAgIG1bKCgobCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSBsO1xyXG5cclxuICAgIC8vIE1ldGhvZCBzaG9ydGN1dHNcclxuICAgIHZhciBGRiA9IG1kNS5fZmYsXHJcbiAgICAgICAgR0cgPSBtZDUuX2dnLFxyXG4gICAgICAgIEhIID0gbWQ1Ll9oaCxcclxuICAgICAgICBJSSA9IG1kNS5faWk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSArPSAxNikge1xyXG5cclxuICAgICAgdmFyIGFhID0gYSxcclxuICAgICAgICAgIGJiID0gYixcclxuICAgICAgICAgIGNjID0gYyxcclxuICAgICAgICAgIGRkID0gZDtcclxuXHJcbiAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBtW2krIDBdLCAgNywgLTY4MDg3NjkzNik7XHJcbiAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBtW2krIDFdLCAxMiwgLTM4OTU2NDU4Nik7XHJcbiAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBtW2krIDJdLCAxNywgIDYwNjEwNTgxOSk7XHJcbiAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBtW2krIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xyXG4gICAgICBhID0gRkYoYSwgYiwgYywgZCwgbVtpKyA0XSwgIDcsIC0xNzY0MTg4OTcpO1xyXG4gICAgICBkID0gRkYoZCwgYSwgYiwgYywgbVtpKyA1XSwgMTIsICAxMjAwMDgwNDI2KTtcclxuICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIG1baSsgNl0sIDE3LCAtMTQ3MzIzMTM0MSk7XHJcbiAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBtW2krIDddLCAyMiwgLTQ1NzA1OTgzKTtcclxuICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIG1baSsgOF0sICA3LCAgMTc3MDAzNTQxNik7XHJcbiAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBtW2krIDldLCAxMiwgLTE5NTg0MTQ0MTcpO1xyXG4gICAgICBjID0gRkYoYywgZCwgYSwgYiwgbVtpKzEwXSwgMTcsIC00MjA2Myk7XHJcbiAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBtW2krMTFdLCAyMiwgLTE5OTA0MDQxNjIpO1xyXG4gICAgICBhID0gRkYoYSwgYiwgYywgZCwgbVtpKzEyXSwgIDcsICAxODA0NjAzNjgyKTtcclxuICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIG1baSsxM10sIDEyLCAtNDAzNDExMDEpO1xyXG4gICAgICBjID0gRkYoYywgZCwgYSwgYiwgbVtpKzE0XSwgMTcsIC0xNTAyMDAyMjkwKTtcclxuICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIG1baSsxNV0sIDIyLCAgMTIzNjUzNTMyOSk7XHJcblxyXG4gICAgICBhID0gR0coYSwgYiwgYywgZCwgbVtpKyAxXSwgIDUsIC0xNjU3OTY1MTApO1xyXG4gICAgICBkID0gR0coZCwgYSwgYiwgYywgbVtpKyA2XSwgIDksIC0xMDY5NTAxNjMyKTtcclxuICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIG1baSsxMV0sIDE0LCAgNjQzNzE3NzEzKTtcclxuICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIG1baSsgMF0sIDIwLCAtMzczODk3MzAyKTtcclxuICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIG1baSsgNV0sICA1LCAtNzAxNTU4NjkxKTtcclxuICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIG1baSsxMF0sICA5LCAgMzgwMTYwODMpO1xyXG4gICAgICBjID0gR0coYywgZCwgYSwgYiwgbVtpKzE1XSwgMTQsIC02NjA0NzgzMzUpO1xyXG4gICAgICBiID0gR0coYiwgYywgZCwgYSwgbVtpKyA0XSwgMjAsIC00MDU1Mzc4NDgpO1xyXG4gICAgICBhID0gR0coYSwgYiwgYywgZCwgbVtpKyA5XSwgIDUsICA1Njg0NDY0MzgpO1xyXG4gICAgICBkID0gR0coZCwgYSwgYiwgYywgbVtpKzE0XSwgIDksIC0xMDE5ODAzNjkwKTtcclxuICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIG1baSsgM10sIDE0LCAtMTg3MzYzOTYxKTtcclxuICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIG1baSsgOF0sIDIwLCAgMTE2MzUzMTUwMSk7XHJcbiAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBtW2krMTNdLCAgNSwgLTE0NDQ2ODE0NjcpO1xyXG4gICAgICBkID0gR0coZCwgYSwgYiwgYywgbVtpKyAyXSwgIDksIC01MTQwMzc4NCk7XHJcbiAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBtW2krIDddLCAxNCwgIDE3MzUzMjg0NzMpO1xyXG4gICAgICBiID0gR0coYiwgYywgZCwgYSwgbVtpKzEyXSwgMjAsIC0xOTI2NjA3NzM0KTtcclxuXHJcbiAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBtW2krIDVdLCAgNCwgLTM3ODU1OCk7XHJcbiAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBtW2krIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xyXG4gICAgICBjID0gSEgoYywgZCwgYSwgYiwgbVtpKzExXSwgMTYsICAxODM5MDMwNTYyKTtcclxuICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIG1baSsxNF0sIDIzLCAtMzUzMDk1NTYpO1xyXG4gICAgICBhID0gSEgoYSwgYiwgYywgZCwgbVtpKyAxXSwgIDQsIC0xNTMwOTkyMDYwKTtcclxuICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIG1baSsgNF0sIDExLCAgMTI3Mjg5MzM1Myk7XHJcbiAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBtW2krIDddLCAxNiwgLTE1NTQ5NzYzMik7XHJcbiAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBtW2krMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xyXG4gICAgICBhID0gSEgoYSwgYiwgYywgZCwgbVtpKzEzXSwgIDQsICA2ODEyNzkxNzQpO1xyXG4gICAgICBkID0gSEgoZCwgYSwgYiwgYywgbVtpKyAwXSwgMTEsIC0zNTg1MzcyMjIpO1xyXG4gICAgICBjID0gSEgoYywgZCwgYSwgYiwgbVtpKyAzXSwgMTYsIC03MjI1MjE5NzkpO1xyXG4gICAgICBiID0gSEgoYiwgYywgZCwgYSwgbVtpKyA2XSwgMjMsICA3NjAyOTE4OSk7XHJcbiAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBtW2krIDldLCAgNCwgLTY0MDM2NDQ4Nyk7XHJcbiAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBtW2krMTJdLCAxMSwgLTQyMTgxNTgzNSk7XHJcbiAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBtW2krMTVdLCAxNiwgIDUzMDc0MjUyMCk7XHJcbiAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBtW2krIDJdLCAyMywgLTk5NTMzODY1MSk7XHJcblxyXG4gICAgICBhID0gSUkoYSwgYiwgYywgZCwgbVtpKyAwXSwgIDYsIC0xOTg2MzA4NDQpO1xyXG4gICAgICBkID0gSUkoZCwgYSwgYiwgYywgbVtpKyA3XSwgMTAsICAxMTI2ODkxNDE1KTtcclxuICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIG1baSsxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XHJcbiAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBtW2krIDVdLCAyMSwgLTU3NDM0MDU1KTtcclxuICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIG1baSsxMl0sICA2LCAgMTcwMDQ4NTU3MSk7XHJcbiAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBtW2krIDNdLCAxMCwgLTE4OTQ5ODY2MDYpO1xyXG4gICAgICBjID0gSUkoYywgZCwgYSwgYiwgbVtpKzEwXSwgMTUsIC0xMDUxNTIzKTtcclxuICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIG1baSsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XHJcbiAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBtW2krIDhdLCAgNiwgIDE4NzMzMTMzNTkpO1xyXG4gICAgICBkID0gSUkoZCwgYSwgYiwgYywgbVtpKzE1XSwgMTAsIC0zMDYxMTc0NCk7XHJcbiAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBtW2krIDZdLCAxNSwgLTE1NjAxOTgzODApO1xyXG4gICAgICBiID0gSUkoYiwgYywgZCwgYSwgbVtpKzEzXSwgMjEsICAxMzA5MTUxNjQ5KTtcclxuICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIG1baSsgNF0sICA2LCAtMTQ1NTIzMDcwKTtcclxuICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIG1baSsxMV0sIDEwLCAtMTEyMDIxMDM3OSk7XHJcbiAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBtW2krIDJdLCAxNSwgIDcxODc4NzI1OSk7XHJcbiAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBtW2krIDldLCAyMSwgLTM0MzQ4NTU1MSk7XHJcblxyXG4gICAgICBhID0gKGEgKyBhYSkgPj4+IDA7XHJcbiAgICAgIGIgPSAoYiArIGJiKSA+Pj4gMDtcclxuICAgICAgYyA9IChjICsgY2MpID4+PiAwO1xyXG4gICAgICBkID0gKGQgKyBkZCkgPj4+IDA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNyeXB0LmVuZGlhbihbYSwgYiwgYywgZF0pO1xyXG4gIH07XHJcblxyXG4gIC8vIEF1eGlsaWFyeSBmdW5jdGlvbnNcclxuICBtZDUuX2ZmICA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XHJcbiAgICB2YXIgbiA9IGEgKyAoYiAmIGMgfCB+YiAmIGQpICsgKHggPj4+IDApICsgdDtcclxuICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XHJcbiAgfTtcclxuICBtZDUuX2dnICA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XHJcbiAgICB2YXIgbiA9IGEgKyAoYiAmIGQgfCBjICYgfmQpICsgKHggPj4+IDApICsgdDtcclxuICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XHJcbiAgfTtcclxuICBtZDUuX2hoICA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XHJcbiAgICB2YXIgbiA9IGEgKyAoYiBeIGMgXiBkKSArICh4ID4+PiAwKSArIHQ7XHJcbiAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xyXG4gIH07XHJcbiAgbWQ1Ll9paSAgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgeCwgcywgdCkge1xyXG4gICAgdmFyIG4gPSBhICsgKGMgXiAoYiB8IH5kKSkgKyAoeCA+Pj4gMCkgKyB0O1xyXG4gICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcclxuICB9O1xyXG5cclxuICAvLyBQYWNrYWdlIHByaXZhdGUgYmxvY2tzaXplXHJcbiAgbWQ1Ll9ibG9ja3NpemUgPSAxNjtcclxuICBtZDUuX2RpZ2VzdHNpemUgPSAxNjtcclxuXHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWVzc2FnZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIGRpZ2VzdGJ5dGVzID0gY3J5cHQud29yZHNUb0J5dGVzKG1kNShtZXNzYWdlKSk7XHJcbiAgICByZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLmFzQnl0ZXMgPyBkaWdlc3RieXRlcyA6XHJcbiAgICAgICAgb3B0aW9ucyAmJiBvcHRpb25zLmFzU3RyaW5nID8gYmluLmJ5dGVzVG9TdHJpbmcoZGlnZXN0Ynl0ZXMpIDpcclxuICAgICAgICBjcnlwdC5ieXRlc1RvSGV4KGRpZ2VzdGJ5dGVzKTtcclxuICB9O1xyXG5cclxufSkoKTtcclxuIiwiXG5leHBvcnRzLkNvbm5lY3Rpb24gPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24nKS5Db25uZWN0aW9uO1xuZXhwb3J0cy5Eb2MgPSByZXF1aXJlKCcuL2RvYycpLkRvYztcbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIGJhc2U2NG1hcFxuICAgICAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycsXG5cbiAgY3J5cHQgPSB7XG4gICAgLy8gQml0LXdpc2Ugcm90YXRpb24gbGVmdFxuICAgIHJvdGw6IGZ1bmN0aW9uKG4sIGIpIHtcbiAgICAgIHJldHVybiAobiA8PCBiKSB8IChuID4+PiAoMzIgLSBiKSk7XG4gICAgfSxcblxuICAgIC8vIEJpdC13aXNlIHJvdGF0aW9uIHJpZ2h0XG4gICAgcm90cjogZnVuY3Rpb24obiwgYikge1xuICAgICAgcmV0dXJuIChuIDw8ICgzMiAtIGIpKSB8IChuID4+PiBiKTtcbiAgICB9LFxuXG4gICAgLy8gU3dhcCBiaWctZW5kaWFuIHRvIGxpdHRsZS1lbmRpYW4gYW5kIHZpY2UgdmVyc2FcbiAgICBlbmRpYW46IGZ1bmN0aW9uKG4pIHtcbiAgICAgIC8vIElmIG51bWJlciBnaXZlbiwgc3dhcCBlbmRpYW5cbiAgICAgIGlmIChuLmNvbnN0cnVjdG9yID09IE51bWJlcikge1xuICAgICAgICByZXR1cm4gY3J5cHQucm90bChuLCA4KSAmIDB4MDBGRjAwRkYgfCBjcnlwdC5yb3RsKG4sIDI0KSAmIDB4RkYwMEZGMDA7XG4gICAgICB9XG5cbiAgICAgIC8vIEVsc2UsIGFzc3VtZSBhcnJheSBhbmQgc3dhcCBhbGwgaXRlbXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbi5sZW5ndGg7IGkrKylcbiAgICAgICAgbltpXSA9IGNyeXB0LmVuZGlhbihuW2ldKTtcbiAgICAgIHJldHVybiBuO1xuICAgIH0sXG5cbiAgICAvLyBHZW5lcmF0ZSBhbiBhcnJheSBvZiBhbnkgbGVuZ3RoIG9mIHJhbmRvbSBieXRlc1xuICAgIHJhbmRvbUJ5dGVzOiBmdW5jdGlvbihuKSB7XG4gICAgICBmb3IgKHZhciBieXRlcyA9IFtdOyBuID4gMDsgbi0tKVxuICAgICAgICBieXRlcy5wdXNoKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1NikpO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBiaWctZW5kaWFuIDMyLWJpdCB3b3Jkc1xuICAgIGJ5dGVzVG9Xb3JkczogZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGZvciAodmFyIHdvcmRzID0gW10sIGkgPSAwLCBiID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrLCBiICs9IDgpXG4gICAgICAgIHdvcmRzW2IgPj4+IDVdIHw9IGJ5dGVzW2ldIDw8ICgyNCAtIGIgJSAzMik7XG4gICAgICByZXR1cm4gd29yZHM7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYmlnLWVuZGlhbiAzMi1iaXQgd29yZHMgdG8gYSBieXRlIGFycmF5XG4gICAgd29yZHNUb0J5dGVzOiBmdW5jdGlvbih3b3Jkcykge1xuICAgICAgZm9yICh2YXIgYnl0ZXMgPSBbXSwgYiA9IDA7IGIgPCB3b3Jkcy5sZW5ndGggKiAzMjsgYiArPSA4KVxuICAgICAgICBieXRlcy5wdXNoKCh3b3Jkc1tiID4+PiA1XSA+Pj4gKDI0IC0gYiAlIDMyKSkgJiAweEZGKTtcbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIGJ5dGUgYXJyYXkgdG8gYSBoZXggc3RyaW5nXG4gICAgYnl0ZXNUb0hleDogZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGZvciAodmFyIGhleCA9IFtdLCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleC5wdXNoKChieXRlc1tpXSA+Pj4gNCkudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgaGV4LnB1c2goKGJ5dGVzW2ldICYgMHhGKS50b1N0cmluZygxNikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhleC5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIGhleCBzdHJpbmcgdG8gYSBieXRlIGFycmF5XG4gICAgaGV4VG9CeXRlczogZnVuY3Rpb24oaGV4KSB7XG4gICAgICBmb3IgKHZhciBieXRlcyA9IFtdLCBjID0gMDsgYyA8IGhleC5sZW5ndGg7IGMgKz0gMilcbiAgICAgICAgYnl0ZXMucHVzaChwYXJzZUludChoZXguc3Vic3RyKGMsIDIpLCAxNikpO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBhIGJhc2UtNjQgc3RyaW5nXG4gICAgYnl0ZXNUb0Jhc2U2NDogZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGZvciAodmFyIGJhc2U2NCA9IFtdLCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHZhciB0cmlwbGV0ID0gKGJ5dGVzW2ldIDw8IDE2KSB8IChieXRlc1tpICsgMV0gPDwgOCkgfCBieXRlc1tpICsgMl07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgNDsgaisrKVxuICAgICAgICAgIGlmIChpICogOCArIGogKiA2IDw9IGJ5dGVzLmxlbmd0aCAqIDgpXG4gICAgICAgICAgICBiYXNlNjQucHVzaChiYXNlNjRtYXAuY2hhckF0KCh0cmlwbGV0ID4+PiA2ICogKDMgLSBqKSkgJiAweDNGKSk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYmFzZTY0LnB1c2goJz0nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlNjQuam9pbignJyk7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBiYXNlLTY0IHN0cmluZyB0byBhIGJ5dGUgYXJyYXlcbiAgICBiYXNlNjRUb0J5dGVzOiBmdW5jdGlvbihiYXNlNjQpIHtcbiAgICAgIC8vIFJlbW92ZSBub24tYmFzZS02NCBjaGFyYWN0ZXJzXG4gICAgICBiYXNlNjQgPSBiYXNlNjQucmVwbGFjZSgvW15BLVowLTkrXFwvXS9pZywgJycpO1xuXG4gICAgICBmb3IgKHZhciBieXRlcyA9IFtdLCBpID0gMCwgaW1vZDQgPSAwOyBpIDwgYmFzZTY0Lmxlbmd0aDtcbiAgICAgICAgICBpbW9kNCA9ICsraSAlIDQpIHtcbiAgICAgICAgaWYgKGltb2Q0ID09IDApIGNvbnRpbnVlO1xuICAgICAgICBieXRlcy5wdXNoKCgoYmFzZTY0bWFwLmluZGV4T2YoYmFzZTY0LmNoYXJBdChpIC0gMSkpXG4gICAgICAgICAgICAmIChNYXRoLnBvdygyLCAtMiAqIGltb2Q0ICsgOCkgLSAxKSkgPDwgKGltb2Q0ICogMikpXG4gICAgICAgICAgICB8IChiYXNlNjRtYXAuaW5kZXhPZihiYXNlNjQuY2hhckF0KGkpKSA+Pj4gKDYgLSBpbW9kNCAqIDIpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gY3J5cHQ7XG59KSgpO1xuIiwidmFyIGNoYXJlbmMgPSB7XG4gIC8vIFVURi04IGVuY29kaW5nXG4gIHV0Zjg6IHtcbiAgICAvLyBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgYnl0ZSBhcnJheVxuICAgIHN0cmluZ1RvQnl0ZXM6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgcmV0dXJuIGNoYXJlbmMuYmluLnN0cmluZ1RvQnl0ZXModW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpKTtcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIGJ5dGUgYXJyYXkgdG8gYSBzdHJpbmdcbiAgICBieXRlc1RvU3RyaW5nOiBmdW5jdGlvbihieXRlcykge1xuICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoY2hhcmVuYy5iaW4uYnl0ZXNUb1N0cmluZyhieXRlcykpKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gQmluYXJ5IGVuY29kaW5nXG4gIGJpbjoge1xuICAgIC8vIENvbnZlcnQgYSBzdHJpbmcgdG8gYSBieXRlIGFycmF5XG4gICAgc3RyaW5nVG9CeXRlczogZnVuY3Rpb24oc3RyKSB7XG4gICAgICBmb3IgKHZhciBieXRlcyA9IFtdLCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKylcbiAgICAgICAgYnl0ZXMucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBhIHN0cmluZ1xuICAgIGJ5dGVzVG9TdHJpbmc6IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBmb3IgKHZhciBzdHIgPSBbXSwgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgc3RyLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSkpO1xuICAgICAgcmV0dXJuIHN0ci5qb2luKCcnKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY2hhcmVuYztcbiIsInZhciBzaGEgPSByZXF1aXJlKCcuL3NoYScpXG52YXIgcm5nID0gcmVxdWlyZSgnLi9ybmcnKVxudmFyIG1kNSA9IHJlcXVpcmUoJy4vbWQ1JylcblxudmFyIGFsZ29yaXRobXMgPSB7XG4gIHNoYTE6IHtcbiAgICBoZXg6IHNoYS5oZXhfc2hhMSxcbiAgICBiaW5hcnk6IHNoYS5iNjRfc2hhMSxcbiAgICBhc2NpaTogc2hhLnN0cl9zaGExXG4gIH0sXG4gIG1kNToge1xuICAgIGhleDogbWQ1LmhleF9tZDUsXG4gICAgYmluYXJ5OiBtZDUuYjY0X21kNSxcbiAgICBhc2NpaTogbWQ1LmFueV9tZDVcbiAgfVxufVxuXG5mdW5jdGlvbiBlcnJvciAoKSB7XG4gIHZhciBtID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oJyAnKVxuICB0aHJvdyBuZXcgRXJyb3IoW1xuICAgIG0sXG4gICAgJ3dlIGFjY2VwdCBwdWxsIHJlcXVlc3RzJyxcbiAgICAnaHR0cDovL2dpdGh1Yi5jb20vZG9taW5pY3RhcnIvY3J5cHRvLWJyb3dzZXJpZnknXG4gICAgXS5qb2luKCdcXG4nKSlcbn1cblxuZXhwb3J0cy5jcmVhdGVIYXNoID0gZnVuY3Rpb24gKGFsZykge1xuICBhbGcgPSBhbGcgfHwgJ3NoYTEnXG4gIGlmKCFhbGdvcml0aG1zW2FsZ10pXG4gICAgZXJyb3IoJ2FsZ29yaXRobTonLCBhbGcsICdpcyBub3QgeWV0IHN1cHBvcnRlZCcpXG4gIHZhciBzID0gJydcbiAgdmFyIF9hbGcgPSBhbGdvcml0aG1zW2FsZ11cbiAgcmV0dXJuIHtcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBzICs9IGRhdGFcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcbiAgICBkaWdlc3Q6IGZ1bmN0aW9uIChlbmMpIHtcbiAgICAgIGVuYyA9IGVuYyB8fCAnYmluYXJ5J1xuICAgICAgdmFyIGZuXG4gICAgICBpZighKGZuID0gX2FsZ1tlbmNdKSlcbiAgICAgICAgZXJyb3IoJ2VuY29kaW5nOicsIGVuYyAsICdpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgYWxnb3JpdGhtJywgYWxnKVxuICAgICAgdmFyIHIgPSBmbihzKVxuICAgICAgcyA9IG51bGwgLy9ub3QgbWVhbnQgdG8gdXNlIHRoZSBoYXNoIGFmdGVyIHlvdSd2ZSBjYWxsZWQgZGlnZXN0LlxuICAgICAgcmV0dXJuIHJcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uKHNpemUsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgdW5kZWZpbmVkLCBybmcoc2l6ZSkpO1xuICAgIH0gY2F0Y2ggKGVycikgeyBjYWxsYmFjayhlcnIpOyB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJuZyhzaXplKTtcbiAgfVxufVxuXG4vLyB0aGUgbGVhc3QgSSBjYW4gZG8gaXMgbWFrZSBlcnJvciBtZXNzYWdlcyBmb3IgdGhlIHJlc3Qgb2YgdGhlIG5vZGUuanMvY3J5cHRvIGFwaS5cbjtbJ2NyZWF0ZUNyZWRlbnRpYWxzJ1xuLCAnY3JlYXRlSG1hYydcbiwgJ2NyZWF0ZUN5cGhlcidcbiwgJ2NyZWF0ZUN5cGhlcml2J1xuLCAnY3JlYXRlRGVjaXBoZXInXG4sICdjcmVhdGVEZWNpcGhlcml2J1xuLCAnY3JlYXRlU2lnbidcbiwgJ2NyZWF0ZVZlcmlmeSdcbiwgJ2NyZWF0ZURlZmZpZUhlbGxtYW4nXG4sICdwYmtkZjInXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIGV4cG9ydHNbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgZXJyb3IoJ3NvcnJ5LCcsIG5hbWUsICdpcyBub3QgaW1wbGVtZW50ZWQgeWV0JylcbiAgfVxufSlcbiIsIi8qXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTEsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgUFVCIDE4MC0xXG4gKiBWZXJzaW9uIDIuMWEgQ29weXJpZ2h0IFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDIuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBkZXRhaWxzLlxuICovXG5cbmV4cG9ydHMuaGV4X3NoYTEgPSBoZXhfc2hhMTtcbmV4cG9ydHMuYjY0X3NoYTEgPSBiNjRfc2hhMTtcbmV4cG9ydHMuc3RyX3NoYTEgPSBzdHJfc2hhMTtcbmV4cG9ydHMuaGV4X2htYWNfc2hhMSA9IGhleF9obWFjX3NoYTE7XG5leHBvcnRzLmI2NF9obWFjX3NoYTEgPSBiNjRfaG1hY19zaGExO1xuZXhwb3J0cy5zdHJfaG1hY19zaGExID0gc3RyX2htYWNfc2hhMTtcblxuLypcbiAqIENvbmZpZ3VyYWJsZSB2YXJpYWJsZXMuIFlvdSBtYXkgbmVlZCB0byB0d2VhayB0aGVzZSB0byBiZSBjb21wYXRpYmxlIHdpdGhcbiAqIHRoZSBzZXJ2ZXItc2lkZSwgYnV0IHRoZSBkZWZhdWx0cyB3b3JrIGluIG1vc3QgY2FzZXMuXG4gKi9cbnZhciBoZXhjYXNlID0gMDsgIC8qIGhleCBvdXRwdXQgZm9ybWF0LiAwIC0gbG93ZXJjYXNlOyAxIC0gdXBwZXJjYXNlICAgICAgICAqL1xudmFyIGI2NHBhZCAgPSBcIlwiOyAvKiBiYXNlLTY0IHBhZCBjaGFyYWN0ZXIuIFwiPVwiIGZvciBzdHJpY3QgUkZDIGNvbXBsaWFuY2UgICAqL1xudmFyIGNocnN6ICAgPSA4OyAgLyogYml0cyBwZXIgaW5wdXQgY2hhcmFjdGVyLiA4IC0gQVNDSUk7IDE2IC0gVW5pY29kZSAgICAgICovXG5cbi8qXG4gKiBUaGVzZSBhcmUgdGhlIGZ1bmN0aW9ucyB5b3UnbGwgdXN1YWxseSB3YW50IHRvIGNhbGxcbiAqIFRoZXkgdGFrZSBzdHJpbmcgYXJndW1lbnRzIGFuZCByZXR1cm4gZWl0aGVyIGhleCBvciBiYXNlLTY0IGVuY29kZWQgc3RyaW5nc1xuICovXG5mdW5jdGlvbiBoZXhfc2hhMShzKXtyZXR1cm4gYmluYjJoZXgoY29yZV9zaGExKHN0cjJiaW5iKHMpLHMubGVuZ3RoICogY2hyc3opKTt9XG5mdW5jdGlvbiBiNjRfc2hhMShzKXtyZXR1cm4gYmluYjJiNjQoY29yZV9zaGExKHN0cjJiaW5iKHMpLHMubGVuZ3RoICogY2hyc3opKTt9XG5mdW5jdGlvbiBzdHJfc2hhMShzKXtyZXR1cm4gYmluYjJzdHIoY29yZV9zaGExKHN0cjJiaW5iKHMpLHMubGVuZ3RoICogY2hyc3opKTt9XG5mdW5jdGlvbiBoZXhfaG1hY19zaGExKGtleSwgZGF0YSl7IHJldHVybiBiaW5iMmhleChjb3JlX2htYWNfc2hhMShrZXksIGRhdGEpKTt9XG5mdW5jdGlvbiBiNjRfaG1hY19zaGExKGtleSwgZGF0YSl7IHJldHVybiBiaW5iMmI2NChjb3JlX2htYWNfc2hhMShrZXksIGRhdGEpKTt9XG5mdW5jdGlvbiBzdHJfaG1hY19zaGExKGtleSwgZGF0YSl7IHJldHVybiBiaW5iMnN0cihjb3JlX2htYWNfc2hhMShrZXksIGRhdGEpKTt9XG5cbi8qXG4gKiBQZXJmb3JtIGEgc2ltcGxlIHNlbGYtdGVzdCB0byBzZWUgaWYgdGhlIFZNIGlzIHdvcmtpbmdcbiAqL1xuZnVuY3Rpb24gc2hhMV92bV90ZXN0KClcbntcbiAgcmV0dXJuIGhleF9zaGExKFwiYWJjXCIpID09IFwiYTk5OTNlMzY0NzA2ODE2YWJhM2UyNTcxNzg1MGMyNmM5Y2QwZDg5ZFwiO1xufVxuXG4vKlxuICogQ2FsY3VsYXRlIHRoZSBTSEEtMSBvZiBhbiBhcnJheSBvZiBiaWctZW5kaWFuIHdvcmRzLCBhbmQgYSBiaXQgbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGNvcmVfc2hhMSh4LCBsZW4pXG57XG4gIC8qIGFwcGVuZCBwYWRkaW5nICovXG4gIHhbbGVuID4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbGVuICUgMzIpO1xuICB4WygobGVuICsgNjQgPj4gOSkgPDwgNCkgKyAxNV0gPSBsZW47XG5cbiAgdmFyIHcgPSBBcnJheSg4MCk7XG4gIHZhciBhID0gIDE3MzI1ODQxOTM7XG4gIHZhciBiID0gLTI3MTczMzg3OTtcbiAgdmFyIGMgPSAtMTczMjU4NDE5NDtcbiAgdmFyIGQgPSAgMjcxNzMzODc4O1xuICB2YXIgZSA9IC0xMDA5NTg5Nzc2O1xuXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNilcbiAge1xuICAgIHZhciBvbGRhID0gYTtcbiAgICB2YXIgb2xkYiA9IGI7XG4gICAgdmFyIG9sZGMgPSBjO1xuICAgIHZhciBvbGRkID0gZDtcbiAgICB2YXIgb2xkZSA9IGU7XG5cbiAgICBmb3IodmFyIGogPSAwOyBqIDwgODA7IGorKylcbiAgICB7XG4gICAgICBpZihqIDwgMTYpIHdbal0gPSB4W2kgKyBqXTtcbiAgICAgIGVsc2Ugd1tqXSA9IHJvbCh3W2otM10gXiB3W2otOF0gXiB3W2otMTRdIF4gd1tqLTE2XSwgMSk7XG4gICAgICB2YXIgdCA9IHNhZmVfYWRkKHNhZmVfYWRkKHJvbChhLCA1KSwgc2hhMV9mdChqLCBiLCBjLCBkKSksXG4gICAgICAgICAgICAgICAgICAgICAgIHNhZmVfYWRkKHNhZmVfYWRkKGUsIHdbal0pLCBzaGExX2t0KGopKSk7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgYyA9IHJvbChiLCAzMCk7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0O1xuICAgIH1cblxuICAgIGEgPSBzYWZlX2FkZChhLCBvbGRhKTtcbiAgICBiID0gc2FmZV9hZGQoYiwgb2xkYik7XG4gICAgYyA9IHNhZmVfYWRkKGMsIG9sZGMpO1xuICAgIGQgPSBzYWZlX2FkZChkLCBvbGRkKTtcbiAgICBlID0gc2FmZV9hZGQoZSwgb2xkZSk7XG4gIH1cbiAgcmV0dXJuIEFycmF5KGEsIGIsIGMsIGQsIGUpO1xuXG59XG5cbi8qXG4gKiBQZXJmb3JtIHRoZSBhcHByb3ByaWF0ZSB0cmlwbGV0IGNvbWJpbmF0aW9uIGZ1bmN0aW9uIGZvciB0aGUgY3VycmVudFxuICogaXRlcmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHNoYTFfZnQodCwgYiwgYywgZClcbntcbiAgaWYodCA8IDIwKSByZXR1cm4gKGIgJiBjKSB8ICgofmIpICYgZCk7XG4gIGlmKHQgPCA0MCkgcmV0dXJuIGIgXiBjIF4gZDtcbiAgaWYodCA8IDYwKSByZXR1cm4gKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpO1xuICByZXR1cm4gYiBeIGMgXiBkO1xufVxuXG4vKlxuICogRGV0ZXJtaW5lIHRoZSBhcHByb3ByaWF0ZSBhZGRpdGl2ZSBjb25zdGFudCBmb3IgdGhlIGN1cnJlbnQgaXRlcmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHNoYTFfa3QodClcbntcbiAgcmV0dXJuICh0IDwgMjApID8gIDE1MTg1MDAyNDkgOiAodCA8IDQwKSA/ICAxODU5Nzc1MzkzIDpcbiAgICAgICAgICh0IDwgNjApID8gLTE4OTQwMDc1ODggOiAtODk5NDk3NTE0O1xufVxuXG4vKlxuICogQ2FsY3VsYXRlIHRoZSBITUFDLVNIQTEgb2YgYSBrZXkgYW5kIHNvbWUgZGF0YVxuICovXG5mdW5jdGlvbiBjb3JlX2htYWNfc2hhMShrZXksIGRhdGEpXG57XG4gIHZhciBia2V5ID0gc3RyMmJpbmIoa2V5KTtcbiAgaWYoYmtleS5sZW5ndGggPiAxNikgYmtleSA9IGNvcmVfc2hhMShia2V5LCBrZXkubGVuZ3RoICogY2hyc3opO1xuXG4gIHZhciBpcGFkID0gQXJyYXkoMTYpLCBvcGFkID0gQXJyYXkoMTYpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgMTY7IGkrKylcbiAge1xuICAgIGlwYWRbaV0gPSBia2V5W2ldIF4gMHgzNjM2MzYzNjtcbiAgICBvcGFkW2ldID0gYmtleVtpXSBeIDB4NUM1QzVDNUM7XG4gIH1cblxuICB2YXIgaGFzaCA9IGNvcmVfc2hhMShpcGFkLmNvbmNhdChzdHIyYmluYihkYXRhKSksIDUxMiArIGRhdGEubGVuZ3RoICogY2hyc3opO1xuICByZXR1cm4gY29yZV9zaGExKG9wYWQuY29uY2F0KGhhc2gpLCA1MTIgKyAxNjApO1xufVxuXG4vKlxuICogQWRkIGludGVnZXJzLCB3cmFwcGluZyBhdCAyXjMyLiBUaGlzIHVzZXMgMTYtYml0IG9wZXJhdGlvbnMgaW50ZXJuYWxseVxuICogdG8gd29yayBhcm91bmQgYnVncyBpbiBzb21lIEpTIGludGVycHJldGVycy5cbiAqL1xuZnVuY3Rpb24gc2FmZV9hZGQoeCwgeSlcbntcbiAgdmFyIGxzdyA9ICh4ICYgMHhGRkZGKSArICh5ICYgMHhGRkZGKTtcbiAgdmFyIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xuICByZXR1cm4gKG1zdyA8PCAxNikgfCAobHN3ICYgMHhGRkZGKTtcbn1cblxuLypcbiAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cbiAqL1xuZnVuY3Rpb24gcm9sKG51bSwgY250KVxue1xuICByZXR1cm4gKG51bSA8PCBjbnQpIHwgKG51bSA+Pj4gKDMyIC0gY250KSk7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGFuIDgtYml0IG9yIDE2LWJpdCBzdHJpbmcgdG8gYW4gYXJyYXkgb2YgYmlnLWVuZGlhbiB3b3Jkc1xuICogSW4gOC1iaXQgZnVuY3Rpb24sIGNoYXJhY3RlcnMgPjI1NSBoYXZlIHRoZWlyIGhpLWJ5dGUgc2lsZW50bHkgaWdub3JlZC5cbiAqL1xuZnVuY3Rpb24gc3RyMmJpbmIoc3RyKVxue1xuICB2YXIgYmluID0gQXJyYXkoKTtcbiAgdmFyIG1hc2sgPSAoMSA8PCBjaHJzeikgLSAxO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aCAqIGNocnN6OyBpICs9IGNocnN6KVxuICAgIGJpbltpPj41XSB8PSAoc3RyLmNoYXJDb2RlQXQoaSAvIGNocnN6KSAmIG1hc2spIDw8ICgzMiAtIGNocnN6IC0gaSUzMik7XG4gIHJldHVybiBiaW47XG59XG5cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IG9mIGJpZy1lbmRpYW4gd29yZHMgdG8gYSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gYmluYjJzdHIoYmluKVxue1xuICB2YXIgc3RyID0gXCJcIjtcbiAgdmFyIG1hc2sgPSAoMSA8PCBjaHJzeikgLSAxO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYmluLmxlbmd0aCAqIDMyOyBpICs9IGNocnN6KVxuICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChiaW5baT4+NV0gPj4+ICgzMiAtIGNocnN6IC0gaSUzMikpICYgbWFzayk7XG4gIHJldHVybiBzdHI7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IG9mIGJpZy1lbmRpYW4gd29yZHMgdG8gYSBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiaW5iMmhleChiaW5hcnJheSlcbntcbiAgdmFyIGhleF90YWIgPSBoZXhjYXNlID8gXCIwMTIzNDU2Nzg5QUJDREVGXCIgOiBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbiAgdmFyIHN0ciA9IFwiXCI7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBiaW5hcnJheS5sZW5ndGggKiA0OyBpKyspXG4gIHtcbiAgICBzdHIgKz0gaGV4X3RhYi5jaGFyQXQoKGJpbmFycmF5W2k+PjJdID4+ICgoMyAtIGklNCkqOCs0KSkgJiAweEYpICtcbiAgICAgICAgICAgaGV4X3RhYi5jaGFyQXQoKGJpbmFycmF5W2k+PjJdID4+ICgoMyAtIGklNCkqOCAgKSkgJiAweEYpO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IG9mIGJpZy1lbmRpYW4gd29yZHMgdG8gYSBiYXNlLTY0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBiaW5iMmI2NChiaW5hcnJheSlcbntcbiAgdmFyIHRhYiA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xuICB2YXIgc3RyID0gXCJcIjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGJpbmFycmF5Lmxlbmd0aCAqIDQ7IGkgKz0gMylcbiAge1xuICAgIHZhciB0cmlwbGV0ID0gKCgoYmluYXJyYXlbaSAgID4+IDJdID4+IDggKiAoMyAtICBpICAgJTQpKSAmIDB4RkYpIDw8IDE2KVxuICAgICAgICAgICAgICAgIHwgKCgoYmluYXJyYXlbaSsxID4+IDJdID4+IDggKiAoMyAtIChpKzEpJTQpKSAmIDB4RkYpIDw8IDggKVxuICAgICAgICAgICAgICAgIHwgICgoYmluYXJyYXlbaSsyID4+IDJdID4+IDggKiAoMyAtIChpKzIpJTQpKSAmIDB4RkYpO1xuICAgIGZvcih2YXIgaiA9IDA7IGogPCA0OyBqKyspXG4gICAge1xuICAgICAgaWYoaSAqIDggKyBqICogNiA+IGJpbmFycmF5Lmxlbmd0aCAqIDMyKSBzdHIgKz0gYjY0cGFkO1xuICAgICAgZWxzZSBzdHIgKz0gdGFiLmNoYXJBdCgodHJpcGxldCA+PiA2KigzLWopKSAmIDB4M0YpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufVxuXG4iLCIvLyBPcmlnaW5hbCBjb2RlIGFkYXB0ZWQgZnJvbSBSb2JlcnQgS2llZmZlci5cbi8vIGRldGFpbHMgYXQgaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWRcbihmdW5jdGlvbigpIHtcbiAgdmFyIF9nbG9iYWwgPSB0aGlzO1xuXG4gIHZhciBtYXRoUk5HLCB3aGF0d2dSTkc7XG5cbiAgLy8gTk9URTogTWF0aC5yYW5kb20oKSBkb2VzIG5vdCBndWFyYW50ZWUgXCJjcnlwdG9ncmFwaGljIHF1YWxpdHlcIlxuICBtYXRoUk5HID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHZhciBieXRlcyA9IG5ldyBBcnJheShzaXplKTtcbiAgICB2YXIgcjtcblxuICAgIGZvciAodmFyIGkgPSAwLCByOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICBpZiAoKGkgJiAweDAzKSA9PSAwKSByID0gTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwO1xuICAgICAgYnl0ZXNbaV0gPSByID4+PiAoKGkgJiAweDAzKSA8PCAzKSAmIDB4ZmY7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9XG5cbiAgLy8gY3VycmVudGx5IG9ubHkgYXZhaWxhYmxlIGluIHdlYmtpdC1iYXNlZCBicm93c2Vycy5cbiAgaWYgKF9nbG9iYWwuY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICB2YXIgX3JuZHMgPSBuZXcgVWludDMyQXJyYXkoNCk7XG4gICAgd2hhdHdnUk5HID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgdmFyIGJ5dGVzID0gbmV3IEFycmF5KHNpemUpO1xuICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhfcm5kcyk7XG5cbiAgICAgIGZvciAodmFyIGMgPSAwIDsgYyA8IHNpemU7IGMrKykge1xuICAgICAgICBieXRlc1tjXSA9IF9ybmRzW2MgPj4gMl0gPj4+ICgoYyAmIDB4MDMpICogOCkgJiAweGZmO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgfVxuXG4gIG1vZHVsZS5leHBvcnRzID0gd2hhdHdnUk5HIHx8IG1hdGhSTkc7XG5cbn0oKSkiLCIvKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBSU0EgRGF0YSBTZWN1cml0eSwgSW5jLiBNRDUgTWVzc2FnZVxuICogRGlnZXN0IEFsZ29yaXRobSwgYXMgZGVmaW5lZCBpbiBSRkMgMTMyMS5cbiAqIFZlcnNpb24gMi4yIENvcHlyaWdodCAoQykgUGF1bCBKb2huc3RvbiAxOTk5IC0gMjAwOVxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgbW9yZSBpbmZvLlxuICovXG5cbi8qXG4gKiBDb25maWd1cmFibGUgdmFyaWFibGVzLiBZb3UgbWF5IG5lZWQgdG8gdHdlYWsgdGhlc2UgdG8gYmUgY29tcGF0aWJsZSB3aXRoXG4gKiB0aGUgc2VydmVyLXNpZGUsIGJ1dCB0aGUgZGVmYXVsdHMgd29yayBpbiBtb3N0IGNhc2VzLlxuICovXG52YXIgaGV4Y2FzZSA9IDA7ICAgLyogaGV4IG91dHB1dCBmb3JtYXQuIDAgLSBsb3dlcmNhc2U7IDEgLSB1cHBlcmNhc2UgICAgICAgICovXG52YXIgYjY0cGFkICA9IFwiXCI7ICAvKiBiYXNlLTY0IHBhZCBjaGFyYWN0ZXIuIFwiPVwiIGZvciBzdHJpY3QgUkZDIGNvbXBsaWFuY2UgICAqL1xuXG4vKlxuICogVGhlc2UgYXJlIHRoZSBmdW5jdGlvbnMgeW91J2xsIHVzdWFsbHkgd2FudCB0byBjYWxsXG4gKiBUaGV5IHRha2Ugc3RyaW5nIGFyZ3VtZW50cyBhbmQgcmV0dXJuIGVpdGhlciBoZXggb3IgYmFzZS02NCBlbmNvZGVkIHN0cmluZ3NcbiAqL1xuZnVuY3Rpb24gaGV4X21kNShzKSAgICB7IHJldHVybiByc3RyMmhleChyc3RyX21kNShzdHIycnN0cl91dGY4KHMpKSk7IH1cbmZ1bmN0aW9uIGI2NF9tZDUocykgICAgeyByZXR1cm4gcnN0cjJiNjQocnN0cl9tZDUoc3RyMnJzdHJfdXRmOChzKSkpOyB9XG5mdW5jdGlvbiBhbnlfbWQ1KHMsIGUpIHsgcmV0dXJuIHJzdHIyYW55KHJzdHJfbWQ1KHN0cjJyc3RyX3V0ZjgocykpLCBlKTsgfVxuZnVuY3Rpb24gaGV4X2htYWNfbWQ1KGssIGQpXG4gIHsgcmV0dXJuIHJzdHIyaGV4KHJzdHJfaG1hY19tZDUoc3RyMnJzdHJfdXRmOChrKSwgc3RyMnJzdHJfdXRmOChkKSkpOyB9XG5mdW5jdGlvbiBiNjRfaG1hY19tZDUoaywgZClcbiAgeyByZXR1cm4gcnN0cjJiNjQocnN0cl9obWFjX21kNShzdHIycnN0cl91dGY4KGspLCBzdHIycnN0cl91dGY4KGQpKSk7IH1cbmZ1bmN0aW9uIGFueV9obWFjX21kNShrLCBkLCBlKVxuICB7IHJldHVybiByc3RyMmFueShyc3RyX2htYWNfbWQ1KHN0cjJyc3RyX3V0ZjgoayksIHN0cjJyc3RyX3V0ZjgoZCkpLCBlKTsgfVxuXG4vKlxuICogUGVyZm9ybSBhIHNpbXBsZSBzZWxmLXRlc3QgdG8gc2VlIGlmIHRoZSBWTSBpcyB3b3JraW5nXG4gKi9cbmZ1bmN0aW9uIG1kNV92bV90ZXN0KClcbntcbiAgcmV0dXJuIGhleF9tZDUoXCJhYmNcIikudG9Mb3dlckNhc2UoKSA9PSBcIjkwMDE1MDk4M2NkMjRmYjBkNjk2M2Y3ZDI4ZTE3ZjcyXCI7XG59XG5cbi8qXG4gKiBDYWxjdWxhdGUgdGhlIE1ENSBvZiBhIHJhdyBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gcnN0cl9tZDUocylcbntcbiAgcmV0dXJuIGJpbmwycnN0cihiaW5sX21kNShyc3RyMmJpbmwocyksIHMubGVuZ3RoICogOCkpO1xufVxuXG4vKlxuICogQ2FsY3VsYXRlIHRoZSBITUFDLU1ENSwgb2YgYSBrZXkgYW5kIHNvbWUgZGF0YSAocmF3IHN0cmluZ3MpXG4gKi9cbmZ1bmN0aW9uIHJzdHJfaG1hY19tZDUoa2V5LCBkYXRhKVxue1xuICB2YXIgYmtleSA9IHJzdHIyYmlubChrZXkpO1xuICBpZihia2V5Lmxlbmd0aCA+IDE2KSBia2V5ID0gYmlubF9tZDUoYmtleSwga2V5Lmxlbmd0aCAqIDgpO1xuXG4gIHZhciBpcGFkID0gQXJyYXkoMTYpLCBvcGFkID0gQXJyYXkoMTYpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgMTY7IGkrKylcbiAge1xuICAgIGlwYWRbaV0gPSBia2V5W2ldIF4gMHgzNjM2MzYzNjtcbiAgICBvcGFkW2ldID0gYmtleVtpXSBeIDB4NUM1QzVDNUM7XG4gIH1cblxuICB2YXIgaGFzaCA9IGJpbmxfbWQ1KGlwYWQuY29uY2F0KHJzdHIyYmlubChkYXRhKSksIDUxMiArIGRhdGEubGVuZ3RoICogOCk7XG4gIHJldHVybiBiaW5sMnJzdHIoYmlubF9tZDUob3BhZC5jb25jYXQoaGFzaCksIDUxMiArIDEyOCkpO1xufVxuXG4vKlxuICogQ29udmVydCBhIHJhdyBzdHJpbmcgdG8gYSBoZXggc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHJzdHIyaGV4KGlucHV0KVxue1xuICB0cnkgeyBoZXhjYXNlIH0gY2F0Y2goZSkgeyBoZXhjYXNlPTA7IH1cbiAgdmFyIGhleF90YWIgPSBoZXhjYXNlID8gXCIwMTIzNDU2Nzg5QUJDREVGXCIgOiBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbiAgdmFyIG91dHB1dCA9IFwiXCI7XG4gIHZhciB4O1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspXG4gIHtcbiAgICB4ID0gaW5wdXQuY2hhckNvZGVBdChpKTtcbiAgICBvdXRwdXQgKz0gaGV4X3RhYi5jaGFyQXQoKHggPj4+IDQpICYgMHgwRilcbiAgICAgICAgICAgKyAgaGV4X3RhYi5jaGFyQXQoIHggICAgICAgICYgMHgwRik7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLypcbiAqIENvbnZlcnQgYSByYXcgc3RyaW5nIHRvIGEgYmFzZS02NCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gcnN0cjJiNjQoaW5wdXQpXG57XG4gIHRyeSB7IGI2NHBhZCB9IGNhdGNoKGUpIHsgYjY0cGFkPScnOyB9XG4gIHZhciB0YWIgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtcbiAgdmFyIG91dHB1dCA9IFwiXCI7XG4gIHZhciBsZW4gPSBpbnB1dC5sZW5ndGg7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMylcbiAge1xuICAgIHZhciB0cmlwbGV0ID0gKGlucHV0LmNoYXJDb2RlQXQoaSkgPDwgMTYpXG4gICAgICAgICAgICAgICAgfCAoaSArIDEgPCBsZW4gPyBpbnB1dC5jaGFyQ29kZUF0KGkrMSkgPDwgOCA6IDApXG4gICAgICAgICAgICAgICAgfCAoaSArIDIgPCBsZW4gPyBpbnB1dC5jaGFyQ29kZUF0KGkrMikgICAgICA6IDApO1xuICAgIGZvcih2YXIgaiA9IDA7IGogPCA0OyBqKyspXG4gICAge1xuICAgICAgaWYoaSAqIDggKyBqICogNiA+IGlucHV0Lmxlbmd0aCAqIDgpIG91dHB1dCArPSBiNjRwYWQ7XG4gICAgICBlbHNlIG91dHB1dCArPSB0YWIuY2hhckF0KCh0cmlwbGV0ID4+PiA2KigzLWopKSAmIDB4M0YpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKlxuICogQ29udmVydCBhIHJhdyBzdHJpbmcgdG8gYW4gYXJiaXRyYXJ5IHN0cmluZyBlbmNvZGluZ1xuICovXG5mdW5jdGlvbiByc3RyMmFueShpbnB1dCwgZW5jb2RpbmcpXG57XG4gIHZhciBkaXZpc29yID0gZW5jb2RpbmcubGVuZ3RoO1xuICB2YXIgaSwgaiwgcSwgeCwgcXVvdGllbnQ7XG5cbiAgLyogQ29udmVydCB0byBhbiBhcnJheSBvZiAxNi1iaXQgYmlnLWVuZGlhbiB2YWx1ZXMsIGZvcm1pbmcgdGhlIGRpdmlkZW5kICovXG4gIHZhciBkaXZpZGVuZCA9IEFycmF5KE1hdGguY2VpbChpbnB1dC5sZW5ndGggLyAyKSk7XG4gIGZvcihpID0gMDsgaSA8IGRpdmlkZW5kLmxlbmd0aDsgaSsrKVxuICB7XG4gICAgZGl2aWRlbmRbaV0gPSAoaW5wdXQuY2hhckNvZGVBdChpICogMikgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KGkgKiAyICsgMSk7XG4gIH1cblxuICAvKlxuICAgKiBSZXBlYXRlZGx5IHBlcmZvcm0gYSBsb25nIGRpdmlzaW9uLiBUaGUgYmluYXJ5IGFycmF5IGZvcm1zIHRoZSBkaXZpZGVuZCxcbiAgICogdGhlIGxlbmd0aCBvZiB0aGUgZW5jb2RpbmcgaXMgdGhlIGRpdmlzb3IuIE9uY2UgY29tcHV0ZWQsIHRoZSBxdW90aWVudFxuICAgKiBmb3JtcyB0aGUgZGl2aWRlbmQgZm9yIHRoZSBuZXh0IHN0ZXAuIEFsbCByZW1haW5kZXJzIGFyZSBzdG9yZWQgZm9yIGxhdGVyXG4gICAqIHVzZS5cbiAgICovXG4gIHZhciBmdWxsX2xlbmd0aCA9IE1hdGguY2VpbChpbnB1dC5sZW5ndGggKiA4IC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChNYXRoLmxvZyhlbmNvZGluZy5sZW5ndGgpIC8gTWF0aC5sb2coMikpKTtcbiAgdmFyIHJlbWFpbmRlcnMgPSBBcnJheShmdWxsX2xlbmd0aCk7XG4gIGZvcihqID0gMDsgaiA8IGZ1bGxfbGVuZ3RoOyBqKyspXG4gIHtcbiAgICBxdW90aWVudCA9IEFycmF5KCk7XG4gICAgeCA9IDA7XG4gICAgZm9yKGkgPSAwOyBpIDwgZGl2aWRlbmQubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgeCA9ICh4IDw8IDE2KSArIGRpdmlkZW5kW2ldO1xuICAgICAgcSA9IE1hdGguZmxvb3IoeCAvIGRpdmlzb3IpO1xuICAgICAgeCAtPSBxICogZGl2aXNvcjtcbiAgICAgIGlmKHF1b3RpZW50Lmxlbmd0aCA+IDAgfHwgcSA+IDApXG4gICAgICAgIHF1b3RpZW50W3F1b3RpZW50Lmxlbmd0aF0gPSBxO1xuICAgIH1cbiAgICByZW1haW5kZXJzW2pdID0geDtcbiAgICBkaXZpZGVuZCA9IHF1b3RpZW50O1xuICB9XG5cbiAgLyogQ29udmVydCB0aGUgcmVtYWluZGVycyB0byB0aGUgb3V0cHV0IHN0cmluZyAqL1xuICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgZm9yKGkgPSByZW1haW5kZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgIG91dHB1dCArPSBlbmNvZGluZy5jaGFyQXQocmVtYWluZGVyc1tpXSk7XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLypcbiAqIEVuY29kZSBhIHN0cmluZyBhcyB1dGYtOC5cbiAqIEZvciBlZmZpY2llbmN5LCB0aGlzIGFzc3VtZXMgdGhlIGlucHV0IGlzIHZhbGlkIHV0Zi0xNi5cbiAqL1xuZnVuY3Rpb24gc3RyMnJzdHJfdXRmOChpbnB1dClcbntcbiAgdmFyIG91dHB1dCA9IFwiXCI7XG4gIHZhciBpID0gLTE7XG4gIHZhciB4LCB5O1xuXG4gIHdoaWxlKCsraSA8IGlucHV0Lmxlbmd0aClcbiAge1xuICAgIC8qIERlY29kZSB1dGYtMTYgc3Vycm9nYXRlIHBhaXJzICovXG4gICAgeCA9IGlucHV0LmNoYXJDb2RlQXQoaSk7XG4gICAgeSA9IGkgKyAxIDwgaW5wdXQubGVuZ3RoID8gaW5wdXQuY2hhckNvZGVBdChpICsgMSkgOiAwO1xuICAgIGlmKDB4RDgwMCA8PSB4ICYmIHggPD0gMHhEQkZGICYmIDB4REMwMCA8PSB5ICYmIHkgPD0gMHhERkZGKVxuICAgIHtcbiAgICAgIHggPSAweDEwMDAwICsgKCh4ICYgMHgwM0ZGKSA8PCAxMCkgKyAoeSAmIDB4MDNGRik7XG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgLyogRW5jb2RlIG91dHB1dCBhcyB1dGYtOCAqL1xuICAgIGlmKHggPD0gMHg3RilcbiAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHgpO1xuICAgIGVsc2UgaWYoeCA8PSAweDdGRilcbiAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4QzAgfCAoKHggPj4+IDYgKSAmIDB4MUYpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICggeCAgICAgICAgICYgMHgzRikpO1xuICAgIGVsc2UgaWYoeCA8PSAweEZGRkYpXG4gICAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEUwIHwgKCh4ID4+PiAxMikgJiAweDBGKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKHggPj4+IDYgKSAmIDB4M0YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICggeCAgICAgICAgICYgMHgzRikpO1xuICAgIGVsc2UgaWYoeCA8PSAweDFGRkZGRilcbiAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RjAgfCAoKHggPj4+IDE4KSAmIDB4MDcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoeCA+Pj4gMTIpICYgMHgzRiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKCh4ID4+PiA2ICkgJiAweDNGKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoIHggICAgICAgICAmIDB4M0YpKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKlxuICogRW5jb2RlIGEgc3RyaW5nIGFzIHV0Zi0xNlxuICovXG5mdW5jdGlvbiBzdHIycnN0cl91dGYxNmxlKGlucHV0KVxue1xuICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKVxuICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCBpbnB1dC5jaGFyQ29kZUF0KGkpICAgICAgICAmIDB4RkYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGlucHV0LmNoYXJDb2RlQXQoaSkgPj4+IDgpICYgMHhGRik7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIHN0cjJyc3RyX3V0ZjE2YmUoaW5wdXQpXG57XG4gIHZhciBvdXRwdXQgPSBcIlwiO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspXG4gICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGlucHV0LmNoYXJDb2RlQXQoaSkgPj4+IDgpICYgMHhGRixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQuY2hhckNvZGVBdChpKSAgICAgICAgJiAweEZGKTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLypcbiAqIENvbnZlcnQgYSByYXcgc3RyaW5nIHRvIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHNcbiAqIENoYXJhY3RlcnMgPjI1NSBoYXZlIHRoZWlyIGhpZ2gtYnl0ZSBzaWxlbnRseSBpZ25vcmVkLlxuICovXG5mdW5jdGlvbiByc3RyMmJpbmwoaW5wdXQpXG57XG4gIHZhciBvdXRwdXQgPSBBcnJheShpbnB1dC5sZW5ndGggPj4gMik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBvdXRwdXQubGVuZ3RoOyBpKyspXG4gICAgb3V0cHV0W2ldID0gMDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aCAqIDg7IGkgKz0gOClcbiAgICBvdXRwdXRbaT4+NV0gfD0gKGlucHV0LmNoYXJDb2RlQXQoaSAvIDgpICYgMHhGRikgPDwgKGklMzIpO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKlxuICogQ29udmVydCBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzIHRvIGEgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGJpbmwycnN0cihpbnB1dClcbntcbiAgdmFyIG91dHB1dCA9IFwiXCI7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGggKiAzMjsgaSArPSA4KVxuICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChpbnB1dFtpPj41XSA+Pj4gKGkgJSAzMikpICYgMHhGRik7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qXG4gKiBDYWxjdWxhdGUgdGhlIE1ENSBvZiBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzLCBhbmQgYSBiaXQgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBiaW5sX21kNSh4LCBsZW4pXG57XG4gIC8qIGFwcGVuZCBwYWRkaW5nICovXG4gIHhbbGVuID4+IDVdIHw9IDB4ODAgPDwgKChsZW4pICUgMzIpO1xuICB4WygoKGxlbiArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSBsZW47XG5cbiAgdmFyIGEgPSAgMTczMjU4NDE5MztcbiAgdmFyIGIgPSAtMjcxNzMzODc5O1xuICB2YXIgYyA9IC0xNzMyNTg0MTk0O1xuICB2YXIgZCA9ICAyNzE3MzM4Nzg7XG5cbiAgZm9yKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpICs9IDE2KVxuICB7XG4gICAgdmFyIG9sZGEgPSBhO1xuICAgIHZhciBvbGRiID0gYjtcbiAgICB2YXIgb2xkYyA9IGM7XG4gICAgdmFyIG9sZGQgPSBkO1xuXG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krIDBdLCA3ICwgLTY4MDg3NjkzNik7XG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krIDFdLCAxMiwgLTM4OTU2NDU4Nik7XG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krIDJdLCAxNywgIDYwNjEwNTgxOSk7XG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKyA0XSwgNyAsIC0xNzY0MTg4OTcpO1xuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKyA1XSwgMTIsICAxMjAwMDgwNDI2KTtcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsgNl0sIDE3LCAtMTQ3MzIzMTM0MSk7XG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krIDddLCAyMiwgLTQ1NzA1OTgzKTtcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsgOF0sIDcgLCAgMTc3MDAzNTQxNik7XG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krIDldLCAxMiwgLTE5NTg0MTQ0MTcpO1xuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKzEwXSwgMTcsIC00MjA2Myk7XG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krMTFdLCAyMiwgLTE5OTA0MDQxNjIpO1xuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKzEyXSwgNyAsICAxODA0NjAzNjgyKTtcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsxM10sIDEyLCAtNDAzNDExMDEpO1xuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKzE0XSwgMTcsIC0xNTAyMDAyMjkwKTtcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsxNV0sIDIyLCAgMTIzNjUzNTMyOSk7XG5cbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsgMV0sIDUgLCAtMTY1Nzk2NTEwKTtcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsgNl0sIDkgLCAtMTA2OTUwMTYzMik7XG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krMTFdLCAxNCwgIDY0MzcxNzcxMyk7XG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krIDBdLCAyMCwgLTM3Mzg5NzMwMik7XG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krIDVdLCA1ICwgLTcwMTU1ODY5MSk7XG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krMTBdLCA5ICwgIDM4MDE2MDgzKTtcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsxNV0sIDE0LCAtNjYwNDc4MzM1KTtcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsgNF0sIDIwLCAtNDA1NTM3ODQ4KTtcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsgOV0sIDUgLCAgNTY4NDQ2NDM4KTtcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsxNF0sIDkgLCAtMTAxOTgwMzY5MCk7XG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krIDNdLCAxNCwgLTE4NzM2Mzk2MSk7XG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krIDhdLCAyMCwgIDExNjM1MzE1MDEpO1xuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKzEzXSwgNSAsIC0xNDQ0NjgxNDY3KTtcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsgMl0sIDkgLCAtNTE0MDM3ODQpO1xuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKyA3XSwgMTQsICAxNzM1MzI4NDczKTtcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsxMl0sIDIwLCAtMTkyNjYwNzczNCk7XG5cbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsgNV0sIDQgLCAtMzc4NTU4KTtcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsgOF0sIDExLCAtMjAyMjU3NDQ2Myk7XG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krMTFdLCAxNiwgIDE4MzkwMzA1NjIpO1xuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKzE0XSwgMjMsIC0zNTMwOTU1Nik7XG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krIDFdLCA0ICwgLTE1MzA5OTIwNjApO1xuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKyA0XSwgMTEsICAxMjcyODkzMzUzKTtcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsgN10sIDE2LCAtMTU1NDk3NjMyKTtcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsxMF0sIDIzLCAtMTA5NDczMDY0MCk7XG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krMTNdLCA0ICwgIDY4MTI3OTE3NCk7XG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krIDBdLCAxMSwgLTM1ODUzNzIyMik7XG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krIDNdLCAxNiwgLTcyMjUyMTk3OSk7XG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krIDZdLCAyMywgIDc2MDI5MTg5KTtcbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsgOV0sIDQgLCAtNjQwMzY0NDg3KTtcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsxMl0sIDExLCAtNDIxODE1ODM1KTtcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsxNV0sIDE2LCAgNTMwNzQyNTIwKTtcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsgMl0sIDIzLCAtOTk1MzM4NjUxKTtcblxuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKyAwXSwgNiAsIC0xOTg2MzA4NDQpO1xuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKyA3XSwgMTAsICAxMTI2ODkxNDE1KTtcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krIDVdLCAyMSwgLTU3NDM0MDU1KTtcbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsxMl0sIDYgLCAgMTcwMDQ4NTU3MSk7XG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krIDNdLCAxMCwgLTE4OTQ5ODY2MDYpO1xuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKzEwXSwgMTUsIC0xMDUxNTIzKTtcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krIDhdLCA2ICwgIDE4NzMzMTMzNTkpO1xuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKzE1XSwgMTAsIC0zMDYxMTc0NCk7XG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krIDZdLCAxNSwgLTE1NjAxOTgzODApO1xuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKzEzXSwgMjEsICAxMzA5MTUxNjQ5KTtcbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsgNF0sIDYgLCAtMTQ1NTIzMDcwKTtcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsxMV0sIDEwLCAtMTEyMDIxMDM3OSk7XG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krIDJdLCAxNSwgIDcxODc4NzI1OSk7XG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krIDldLCAyMSwgLTM0MzQ4NTU1MSk7XG5cbiAgICBhID0gc2FmZV9hZGQoYSwgb2xkYSk7XG4gICAgYiA9IHNhZmVfYWRkKGIsIG9sZGIpO1xuICAgIGMgPSBzYWZlX2FkZChjLCBvbGRjKTtcbiAgICBkID0gc2FmZV9hZGQoZCwgb2xkZCk7XG4gIH1cbiAgcmV0dXJuIEFycmF5KGEsIGIsIGMsIGQpO1xufVxuXG4vKlxuICogVGhlc2UgZnVuY3Rpb25zIGltcGxlbWVudCB0aGUgZm91ciBiYXNpYyBvcGVyYXRpb25zIHRoZSBhbGdvcml0aG0gdXNlcy5cbiAqL1xuZnVuY3Rpb24gbWQ1X2NtbihxLCBhLCBiLCB4LCBzLCB0KVxue1xuICByZXR1cm4gc2FmZV9hZGQoYml0X3JvbChzYWZlX2FkZChzYWZlX2FkZChhLCBxKSwgc2FmZV9hZGQoeCwgdCkpLCBzKSxiKTtcbn1cbmZ1bmN0aW9uIG1kNV9mZihhLCBiLCBjLCBkLCB4LCBzLCB0KVxue1xuICByZXR1cm4gbWQ1X2NtbigoYiAmIGMpIHwgKCh+YikgJiBkKSwgYSwgYiwgeCwgcywgdCk7XG59XG5mdW5jdGlvbiBtZDVfZ2coYSwgYiwgYywgZCwgeCwgcywgdClcbntcbiAgcmV0dXJuIG1kNV9jbW4oKGIgJiBkKSB8IChjICYgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xufVxuZnVuY3Rpb24gbWQ1X2hoKGEsIGIsIGMsIGQsIHgsIHMsIHQpXG57XG4gIHJldHVybiBtZDVfY21uKGIgXiBjIF4gZCwgYSwgYiwgeCwgcywgdCk7XG59XG5mdW5jdGlvbiBtZDVfaWkoYSwgYiwgYywgZCwgeCwgcywgdClcbntcbiAgcmV0dXJuIG1kNV9jbW4oYyBeIChiIHwgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xufVxuXG4vKlxuICogQWRkIGludGVnZXJzLCB3cmFwcGluZyBhdCAyXjMyLiBUaGlzIHVzZXMgMTYtYml0IG9wZXJhdGlvbnMgaW50ZXJuYWxseVxuICogdG8gd29yayBhcm91bmQgYnVncyBpbiBzb21lIEpTIGludGVycHJldGVycy5cbiAqL1xuZnVuY3Rpb24gc2FmZV9hZGQoeCwgeSlcbntcbiAgdmFyIGxzdyA9ICh4ICYgMHhGRkZGKSArICh5ICYgMHhGRkZGKTtcbiAgdmFyIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xuICByZXR1cm4gKG1zdyA8PCAxNikgfCAobHN3ICYgMHhGRkZGKTtcbn1cblxuLypcbiAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cbiAqL1xuZnVuY3Rpb24gYml0X3JvbChudW0sIGNudClcbntcbiAgcmV0dXJuIChudW0gPDwgY250KSB8IChudW0gPj4+ICgzMiAtIGNudCkpO1xufVxuXG5cbmV4cG9ydHMuaGV4X21kNSA9IGhleF9tZDU7XG5leHBvcnRzLmI2NF9tZDUgPSBiNjRfbWQ1O1xuZXhwb3J0cy5hbnlfbWQ1ID0gYW55X21kNTtcbiIsIi8vIFRoaXMgaXMgYSBzaW1wbGUgcmV3cml0ZSBvZiBtaWNyb2V2ZW50LmpzLiBJJ3ZlIGNoYW5nZWQgdGhlXG4vLyBmdW5jdGlvbiBuYW1lcyB0byBiZSBjb25zaXN0ZW50IHdpdGggbm9kZS5qcyBFdmVudEVtaXR0ZXIuXG4vL1xuLy8gbWljcm9ldmVudC5qcyBpcyBjb3B5cmlnaHQgSmVyb21lIEV0aWVubmUsIGFuZCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vamVyb21lZXRpZW5uZS9taWNyb2V2ZW50LmpzXG5cbnZhciBNaWNyb0V2ZW50ID0gZnVuY3Rpb24oKSB7fTtcblxuTWljcm9FdmVudC5wcm90b3R5cGUub24gPSBmdW5jdGlvbihldmVudCwgZm4pIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgKGV2ZW50c1tldmVudF0gPSBldmVudHNbZXZlbnRdIHx8IFtdKS5wdXNoKGZuKTtcbn07XG5cbk1pY3JvRXZlbnQucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHZhciBsaXN0ZW5lcnMgPSBldmVudHNbZXZlbnRdID0gZXZlbnRzW2V2ZW50XSB8fCBbXTtcblxuICAvLyBTYWRseSwgbm8gSUU4IHN1cHBvcnQgZm9yIGluZGV4T2YuXG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKGkgPCBsaXN0ZW5lcnMubGVuZ3RoKSB7XG4gICAgaWYgKGxpc3RlbmVyc1tpXSA9PT0gZm4pIHtcbiAgICAgIGxpc3RlbmVyc1tpXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaSsrO1xuICB9XG5cbiAgLy8gQ29tcGFjdCB0aGUgbGlzdCB3aGVuIG5vIGV2ZW50IGhhbmRsZXIgaXMgYWN0dWFsbHkgcnVubmluZy5cbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBldmVudHNbZXZlbnRdID0gW107XG4gICAgdmFyIGZuO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBPbmx5IGFkZCBiYWNrIGV2ZW50IGhhbmRsZXJzIHdoaWNoIGV4aXN0LlxuICAgICAgaWYgKChmbiA9IGxpc3RlbmVyc1tpXSkpIGV2ZW50c1tldmVudF0ucHVzaChmbik7XG4gICAgfVxuICB9LCAwKTtcbn07XG5cbk1pY3JvRXZlbnQucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zcGxpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIGlmICghZXZlbnRzIHx8ICFldmVudHNbZXZlbnRdKSB7XG4gICAgaWYgKGV2ZW50ID09ICdlcnJvcicpIHtcbiAgICAgIGlmIChjb25zb2xlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IuYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSBldmVudHNbZXZlbnRdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsaXN0ZW5lcnNbaV0pIHtcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH1cbn07XG5cbk1pY3JvRXZlbnQucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pIHtcbiAgdmFyIGxpc3RlbmVyLCBfdGhpcyA9IHRoaXM7XG4gIHRoaXMub24oZXZlbnQsIGxpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG4gICAgX3RoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICBmbi5hcHBseShfdGhpcywgYXJndW1lbnRzKTtcbiAgfSk7XG59O1xuXG5NaWNyb0V2ZW50Lm1peGluID0gZnVuY3Rpb24ob2JqKSB7XG4gIHZhciBwcm90byA9IG9iai5wcm90b3R5cGUgfHwgb2JqO1xuICBwcm90by5vbiA9IE1pY3JvRXZlbnQucHJvdG90eXBlLm9uO1xuICBwcm90by5yZW1vdmVMaXN0ZW5lciA9IE1pY3JvRXZlbnQucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuICBwcm90by5lbWl0ID0gTWljcm9FdmVudC5wcm90b3R5cGUuZW1pdDtcbiAgcHJvdG8ub25jZSA9IE1pY3JvRXZlbnQucHJvdG90eXBlLm9uY2U7XG4gIHJldHVybiBvYmo7XG59O1xuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIikgbW9kdWxlLmV4cG9ydHMgPSBNaWNyb0V2ZW50O1xuXG4iLCJ2YXIgRG9jO1xuaWYgKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykge1xuICBEb2MgPSByZXF1aXJlKCcuL2RvYycpLkRvYztcbn1cblxuLy8gUXVlcmllcyBhcmUgbGl2ZSByZXF1ZXN0cyB0byB0aGUgZGF0YWJhc2UgZm9yIHBhcnRpY3VsYXIgc2V0cyBvZiBmaWVsZHMuXG4vL1xuLy8gVGhlIHNlcnZlciBhY3RpdmVseSB0ZWxscyB0aGUgY2xpZW50IHdoZW4gdGhlcmUncyBuZXcgZGF0YSB0aGF0IG1hdGNoZXNcbi8vIGEgc2V0IG9mIGNvbmRpdGlvbnMuXG52YXIgUXVlcnkgPSBleHBvcnRzLlF1ZXJ5ID0gZnVuY3Rpb24odHlwZSwgY29ubmVjdGlvbiwgaWQsIGNvbGxlY3Rpb24sIHF1ZXJ5LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAvLyAnZmV0Y2gnIG9yICdzdWInXG4gIHRoaXMudHlwZSA9IHR5cGU7XG5cbiAgdGhpcy5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgdGhpcy5pZCA9IGlkO1xuICB0aGlzLmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuXG4gIC8vIFRoZSBxdWVyeSBpdHNlbGYuIEZvciBtb25nbywgdGhpcyBzaG91bGQgbG9vayBzb21ldGhpbmcgbGlrZSB7XCJkYXRhLnhcIjo1fVxuICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG5cbiAgLy8gUmVzdWx0YW50IGRvY3VtZW50IGFjdGlvbiBmb3IgdGhlIHNlcnZlci4gRmV0Y2ggbW9kZSB3aWxsIGF1dG9tYXRpY2FsbHlcbiAgLy8gZmV0Y2ggYWxsIHJlc3VsdHMuIFN1YnNjcmliZSBtb2RlIHdpbGwgYXV0b21hdGljYWxseSBzdWJzY3JpYmUgYWxsXG4gIC8vIHJlc3VsdHMuIFJlc3VsdHMgYXJlIG5ldmVyIHVuc3Vic2NyaWJlZC5cbiAgdGhpcy5kb2NNb2RlID0gb3B0aW9ucy5kb2NNb2RlOyAvLyB1bmRlZmluZWQsICdmZXRjaCcgb3IgJ3N1YicuXG4gIGlmICh0aGlzLmRvY01vZGUgPT09ICdzdWJzY3JpYmUnKSB0aGlzLmRvY01vZGUgPSAnc3ViJztcblxuICAvLyBEbyB3ZSByZXBvbGwgdGhlIGVudGlyZSBxdWVyeSB3aGVuZXZlciBhbnl0aGluZyBjaGFuZ2VzPyAoQXMgb3Bwb3NlZCB0b1xuICAvLyBqdXN0IHBvbGxpbmcgdGhlIGNoYW5nZWQgaXRlbSkuIFRoaXMgbmVlZHMgdG8gYmUgZW5hYmxlZCB0byBiZSBhYmxlIHRvIHVzZVxuICAvLyBvcmRlcmVkIHF1ZXJpZXMgKHNvcnRieTopIGFuZCBwYWdpbmF0ZWQgcXVlcmllcy4gU2V0IHRvIHVuZGVmaW5lZCwgaXQgd2lsbFxuICAvLyBiZSBlbmFibGVkIC8gZGlzYWJsZWQgYXV0b21hdGljYWxseSBiYXNlZCBvbiB0aGUgcXVlcnkncyBwcm9wZXJ0aWVzLlxuICB0aGlzLnBvbGwgPSBvcHRpb25zLnBvbGw7XG5cbiAgLy8gVGhlIGJhY2tlbmQgd2UgYWN0dWFsbHkgaGl0LiBJZiB0aGlzIGlzbid0IGRlZmluZWQsIGl0IGhpdHMgdGhlIHNuYXBzaG90XG4gIC8vIGRhdGFiYXNlLiBPdGhlcndpc2UgdGhpcyBjYW4gYmUgdXNlZCB0byBoaXQgYW5vdGhlciBjb25maWd1cmVkIHF1ZXJ5XG4gIC8vIGluZGV4LlxuICB0aGlzLmJhY2tlbmQgPSBvcHRpb25zLmJhY2tlbmQgfHwgb3B0aW9ucy5zb3VyY2U7XG5cbiAgLy8gQSBsaXN0IG9mIHJlc3VsdGluZyBkb2N1bWVudHMuIFRoZXNlIGFyZSBhY3R1YWwgZG9jdW1lbnRzLCBjb21wbGV0ZSB3aXRoXG4gIC8vIGRhdGEgYW5kIGFsbCB0aGUgcmVzdC4gSWYgZmV0Y2ggaXMgZmFsc2UsIHRoZXNlIGRvY3VtZW50cyB3aWxsIG5vdFxuICAvLyBoYXZlIGFueSBkYXRhLiBZb3Ugc2hvdWxkIG1hbnVhbGx5IGNhbGwgZmV0Y2goKSBvciBzdWJzY3JpYmUoKSBvbiB0aGVtLlxuICAvL1xuICAvLyBDYWxsaW5nIHN1YnNjcmliZSgpIG1pZ2h0IGJlIGEgZ29vZCBpZGVhIGFueXdheSwgYXMgeW91IHdvbid0IGJlXG4gIC8vIHN1YnNjcmliZWQgdG8gdGhlIGRvY3VtZW50cyBieSBkZWZhdWx0LlxuICB0aGlzLmtub3duRG9jcyA9IG9wdGlvbnMua25vd25Eb2NzIHx8IFtdO1xuICB0aGlzLnJlc3VsdHMgPSBbXTtcblxuICAvLyBEbyB3ZSBoYXZlIHNvbWUgaW5pdGlhbCBkYXRhP1xuICB0aGlzLnJlYWR5ID0gZmFsc2U7XG5cbiAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xufTtcblF1ZXJ5LnByb3RvdHlwZS5hY3Rpb24gPSAncXN1Yic7XG5cbi8vIEhlbHBlciBmb3Igc3Vic2NyaWJlICYgZmV0Y2gsIHNpbmNlIHRoZXkgc2hhcmUgdGhlIHNhbWUgbWVzc2FnZSBmb3JtYXQuXG4vL1xuLy8gVGhpcyBmdW5jdGlvbiBhY3R1YWxseSBpc3N1ZXMgdGhlIHF1ZXJ5LlxuUXVlcnkucHJvdG90eXBlLl9leGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5jb25uZWN0aW9uLmNhblNlbmQpIHJldHVybjtcblxuICBpZiAodGhpcy5kb2NNb2RlKSB7XG4gICAgdmFyIGNvbGxlY3Rpb25WZXJzaW9ucyA9IHt9O1xuICAgIC8vIENvbGxlY3QgdGhlIHZlcnNpb24gb2YgYWxsIHRoZSBkb2N1bWVudHMgaW4gdGhlIGN1cnJlbnQgcmVzdWx0IHNldCBzbyB3ZVxuICAgIC8vIGRvbid0IG5lZWQgdG8gYmUgc2VudCB0aGVpciBzbmFwc2hvdHMgYWdhaW4uXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmtub3duRG9jcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRvYyA9IHRoaXMua25vd25Eb2NzW2ldO1xuICAgICAgdmFyIGMgPSBjb2xsZWN0aW9uVmVyc2lvbnNbZG9jLmNvbGxlY3Rpb25dID0gY29sbGVjdGlvblZlcnNpb25zW2RvYy5jb2xsZWN0aW9uXSB8fCB7fTtcbiAgICAgIGNbZG9jLm5hbWVdID0gZG9jLnZlcnNpb247XG4gICAgfVxuICB9XG5cbiAgdmFyIG1zZyA9IHtcbiAgICBhOiAncScgKyB0aGlzLnR5cGUsXG4gICAgaWQ6IHRoaXMuaWQsXG4gICAgYzogdGhpcy5jb2xsZWN0aW9uLFxuICAgIG86IHt9LFxuICAgIHE6IHRoaXMucXVlcnksXG4gIH07XG5cbiAgaWYgKHRoaXMuZG9jTW9kZSkge1xuICAgIG1zZy5vLm0gPSB0aGlzLmRvY01vZGU7XG4gICAgLy8gVGhpcyBzaG91bGQgYmUgb21pdHRlZCBpZiBlbXB0eSwgYnV0IHdoYXRldmVyLlxuICAgIG1zZy5vLnZzID0gY29sbGVjdGlvblZlcnNpb25zO1xuICB9XG4gIGlmICh0aGlzLmJhY2tlbmQgIT0gbnVsbCkgbXNnLm8uYiA9IHRoaXMuYmFja2VuZDtcbiAgaWYgKHRoaXMucG9sbCAhPT0gdW5kZWZpbmVkKSBtc2cuby5wID0gdGhpcy5wb2xsO1xuXG4gIHRoaXMuY29ubmVjdGlvbi5zZW5kKG1zZyk7XG59O1xuXG4vLyBNYWtlIGEgbGlzdCBvZiBkb2N1bWVudHMgZnJvbSB0aGUgbGlzdCBvZiBzZXJ2ZXItcmV0dXJuZWQgZGF0YSBvYmplY3RzXG5RdWVyeS5wcm90b3R5cGUuX2RhdGFUb0RvY3MgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHZhciByZXN1bHRzID0gW107XG4gIHZhciBsYXN0VHlwZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRvY0RhdGEgPSBkYXRhW2ldO1xuXG4gICAgLy8gVHlwZXMgYXJlIG9ubHkgcHV0IGluIGZvciB0aGUgZmlyc3QgcmVzdWx0IGluIHRoZSBzZXQgYW5kIGV2ZXJ5IHRpbWUgdGhlIHR5cGUgY2hhbmdlcyBpbiB0aGUgbGlzdC5cbiAgICBpZiAoZG9jRGF0YS50eXBlKSB7XG4gICAgICBsYXN0VHlwZSA9IGRvY0RhdGEudHlwZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jRGF0YS50eXBlID0gbGFzdFR5cGU7XG4gICAgfVxuXG4gICAgdmFyIGRvYyA9IHRoaXMuY29ubmVjdGlvbi5nZXQoZG9jRGF0YS5jIHx8IHRoaXMuY29sbGVjdGlvbiwgZG9jRGF0YS5kLCBkb2NEYXRhKTtcbiAgICAvLyBGb3JjZSB0aGUgZG9jdW1lbnQgdG8ga25vdyBpdHMgc3Vic2NyaWJlZCBpZiB3ZSdyZSBpbiBkb2Ntb2RlOnN1YnNjcmliZS5cbiAgICBpZiAodGhpcy5kb2NNb2RlID09PSAnc3ViJykge1xuICAgICAgZG9jLnN1YnNjcmliZWQgPSB0cnVlOyAvLyBTZXQgYmVmb3JlIHNldFdhbnRTdWJzY3JpYmUoKSBzbyBmbHVzaCBkb2Vzbid0IHNlbmQgYSBzdWJzY3JpYmUgcmVxdWVzdC5cbiAgICAgIGRvYy5fc2V0V2FudFN1YnNjcmliZSh0cnVlKTsgLy8gdGhpcyB3aWxsIGNhbGwgYW55IHN1YnNjcmliZSBjYWxsYmFja3Mgb3Igd2hhdGV2ZXIuXG4gICAgICBkb2MuZW1pdCgnc3Vic2NyaWJlJyk7XG4gICAgICBkb2MuX2ZpbmlzaFN1Yih0cnVlKTsgLy8gdGhpcyBkb2Vzbid0IGFjdHVhbGx5IGRvIGFueXRoaW5nIGhlcmUsIGJ1dCBpdHMgbW9yZSBjb3JyZWN0IHRvIGhhdmUgaXQuXG4gICAgfVxuICAgIHJlc3VsdHMucHVzaChkb2MpO1xuICB9XG4gIHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gRGVzdHJveSB0aGUgcXVlcnkgb2JqZWN0LiBBbnkgc3Vic2VxdWVudCBtZXNzYWdlcyBmb3IgdGhlIHF1ZXJ5IHdpbGwgYmVcbi8vIGlnbm9yZWQgYnkgdGhlIGNvbm5lY3Rpb24uIFlvdSBzaG91bGQgdW5zdWJzY3JpYmUgZnJvbSB0aGUgcXVlcnkgYmVmb3JlXG4vLyBkZXN0cm95aW5nIGl0LlxuUXVlcnkucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY29ubmVjdGlvbi5jYW5TZW5kICYmIHRoaXMudHlwZSA9PT0gJ3N1YicpIHtcbiAgICB0aGlzLmNvbm5lY3Rpb24uc2VuZCh7YToncXVuc3ViJywgaWQ6dGhpcy5pZH0pO1xuICB9XG5cbiAgdGhpcy5jb25uZWN0aW9uLl9kZXN0cm95UXVlcnkodGhpcyk7XG59O1xuXG5RdWVyeS5wcm90b3R5cGUuX29uQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCA9IGZ1bmN0aW9uKHN0YXRlLCByZWFzb24pIHtcbiAgaWYgKHRoaXMuY29ubmVjdGlvbi5zdGF0ZSA9PT0gJ2Nvbm5lY3RpbmcnKSB7XG4gICAgdGhpcy5fZXhlY3V0ZSgpO1xuICB9XG59O1xuXG4vLyBJbnRlcm5hbCBtZXRob2QgY2FsbGVkIGZyb20gY29ubmVjdGlvbiB0byBwYXNzIHNlcnZlciBtZXNzYWdlcyB0byB0aGUgcXVlcnkuXG5RdWVyeS5wcm90b3R5cGUuX29uTWVzc2FnZSA9IGZ1bmN0aW9uKG1zZykge1xuICBpZiAoKG1zZy5hID09PSAncWZldGNoJykgIT09ICh0aGlzLnR5cGUgPT09ICdmZXRjaCcpKSB7XG4gICAgaWYgKGNvbnNvbGUpIGNvbnNvbGUud2FybignSW52YWxpZCBtZXNzYWdlIHNlbnQgdG8gcXVlcnknLCBtc2csIHRoaXMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChtc2cuZXJyb3IpIHRoaXMuZW1pdCgnZXJyb3InLCBtc2cuZXJyb3IpO1xuXG4gIHN3aXRjaCAobXNnLmEpIHtcbiAgICBjYXNlICdxZmV0Y2gnOlxuICAgICAgdmFyIHJlc3VsdHMgPSBtc2cuZGF0YSA/IHRoaXMuX2RhdGFUb0RvY3MobXNnLmRhdGEpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKHRoaXMuY2FsbGJhY2spIHRoaXMuY2FsbGJhY2sobXNnLmVycm9yLCByZXN1bHRzLCBtc2cuZXh0cmEpO1xuICAgICAgLy8gT25jZSBhIGZldGNoIHF1ZXJ5IGdldHMgaXRzIGRhdGEsIGl0IGlzIGRlc3Ryb3llZC5cbiAgICAgIHRoaXMuY29ubmVjdGlvbi5fZGVzdHJveVF1ZXJ5KHRoaXMpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdxJzpcbiAgICAgIC8vIFF1ZXJ5IGRpZmYgZGF0YSAoaW5zZXJ0cyBhbmQgcmVtb3ZlcylcbiAgICAgIGlmIChtc2cuZGlmZikge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGdvIHRocm91Z2ggdGhlIGxpc3QgdHdpY2UuIEZpcnN0LCB3ZSdsbCBpbmplc3QgYWxsIHRoZVxuICAgICAgICAvLyBuZXcgZG9jdW1lbnRzIGFuZCBzZXQgdGhlbSBhcyBzdWJzY3JpYmVkLiAgQWZ0ZXIgdGhhdCB3ZSdsbCBlbWl0XG4gICAgICAgIC8vIGV2ZW50cyBhbmQgYWN0dWFsbHkgdXBkYXRlIG91ciBsaXN0LiBUaGlzIGF2b2lkcyByYWNlIGNvbmRpdGlvbnNcbiAgICAgICAgLy8gYXJvdW5kIHNldHRpbmcgZG9jdW1lbnRzIHRvIGJlIHN1YnNjcmliZWQgJiB1bnN1YnNjcmliaW5nIGRvY3VtZW50c1xuICAgICAgICAvLyBpbiBldmVudCBjYWxsYmFja3MuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmRpZmYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZCA9IG1zZy5kaWZmW2ldO1xuICAgICAgICAgIGlmIChkLnR5cGUgPT09ICdpbnNlcnQnKSBkLnZhbHVlcyA9IHRoaXMuX2RhdGFUb0RvY3MoZC52YWx1ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cuZGlmZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBkID0gbXNnLmRpZmZbaV07XG4gICAgICAgICAgc3dpdGNoIChkLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2luc2VydCc6XG4gICAgICAgICAgICAgIHZhciBuZXdEb2NzID0gZC52YWx1ZXM7XG4gICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuYXBwbHkodGhpcy5yZXN1bHRzLCBbZC5pbmRleCwgMF0uY29uY2F0KG5ld0RvY3MpKTtcbiAgICAgICAgICAgICAgdGhpcy5lbWl0KCdpbnNlcnQnLCBuZXdEb2NzLCBkLmluZGV4KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyZW1vdmUnOlxuICAgICAgICAgICAgICB2YXIgaG93TWFueSA9IGQuaG93TWFueSB8fCAxO1xuICAgICAgICAgICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMucmVzdWx0cy5zcGxpY2UoZC5pbmRleCwgaG93TWFueSk7XG4gICAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlJywgcmVtb3ZlZCwgZC5pbmRleCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW92ZSc6XG4gICAgICAgICAgICAgIHZhciBob3dNYW55ID0gZC5ob3dNYW55IHx8IDE7XG4gICAgICAgICAgICAgIHZhciBkb2NzID0gdGhpcy5yZXN1bHRzLnNwbGljZShkLmZyb20sIGhvd01hbnkpO1xuICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmFwcGx5KHRoaXMucmVzdWx0cywgW2QudG8sIDBdLmNvbmNhdChkb2NzKSk7XG4gICAgICAgICAgICAgIHRoaXMuZW1pdCgnbW92ZScsIGRvY3MsIGQuZnJvbSwgZC50byk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobXNnLmV4dHJhKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZXh0cmEnLCBtc2cuZXh0cmEpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncXN1Yic6XG4gICAgICAvLyBUaGlzIG1lc3NhZ2UgcmVwbGFjZXMgdGhlIGVudGlyZSByZXN1bHQgc2V0IHdpdGggdGhlIHNldCBwYXNzZWQuXG4gICAgICBpZiAoIW1zZy5lcnJvcikge1xuICAgICAgICB2YXIgcHJldmlvdXMgPSB0aGlzLnJlc3VsdHM7XG5cbiAgICAgICAgLy8gVGhlbiBhZGQgZXZlcnl0aGluZyBpbiB0aGUgbmV3IHJlc3VsdCBzZXQuXG4gICAgICAgIHRoaXMucmVzdWx0cyA9IHRoaXMua25vd25Eb2NzID0gdGhpcy5fZGF0YVRvRG9jcyhtc2cuZGF0YSk7XG4gICAgICAgIHRoaXMuZXh0cmEgPSBtc2cuZXh0cmE7XG5cbiAgICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdCgnY2hhbmdlJywgdGhpcy5yZXN1bHRzLCBwcmV2aW91cyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbGxiYWNrKG1zZy5lcnJvciwgdGhpcy5yZXN1bHRzLCB0aGlzLmV4dHJhKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuY2FsbGJhY2s7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuLy8gQ2hhbmdlIHRoZSB0aGluZyB3ZSdyZSBzZWFyY2hpbmcgZm9yLiBUaGlzIGlzbid0IGZ1bGx5IHN1cHBvcnRlZCBvbiB0aGVcbi8vIGJhY2tlbmQgKGl0IGRlc3Ryb3lzIHRoZSBvbGQgcXVlcnkgYW5kIG1ha2VzIGEgbmV3IG9uZSkgLSBidXQgaXRzXG4vLyBwcm9ncmFtYXRpY2FsbHkgdXNlZnVsIGFuZCBJIG1pZ2h0IGFkZCBiYWNrZW5kIHN1cHBvcnQgYXQgc29tZSBwb2ludC5cblF1ZXJ5LnByb3RvdHlwZS5zZXRRdWVyeSA9IGZ1bmN0aW9uKHEpIHtcbiAgaWYgKHRoaXMudHlwZSAhPT0gJ3N1YicpIHRocm93IG5ldyBFcnJvcignY2Fubm90IGNoYW5nZSBhIGZldGNoIHF1ZXJ5Jyk7XG5cbiAgdGhpcy5xdWVyeSA9IHE7XG4gIGlmICh0aGlzLmNvbm5lY3Rpb24uY2FuU2VuZCkge1xuICAgIC8vIFRoZXJlJ3Mgbm8gJ2NoYW5nZScgbWVzc2FnZSB0byBzZW5kIHRvIHRoZSBzZXJ2ZXIuIEp1c3QgcmVzdWJzY3JpYmUuXG4gICAgdGhpcy5jb25uZWN0aW9uLnNlbmQoe2E6J3F1bnN1YicsIGlkOnRoaXMuaWR9KTtcbiAgICB0aGlzLl9leGVjdXRlKCk7XG4gIH1cbn07XG5cbnZhciBNaWNyb0V2ZW50O1xuaWYgKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykge1xuICBNaWNyb0V2ZW50ID0gcmVxdWlyZSgnLi9taWNyb2V2ZW50Jyk7XG59XG5cbk1pY3JvRXZlbnQubWl4aW4oUXVlcnkpO1xuXG4iLCIvLyBBIENvbm5lY3Rpb24gd3JhcHMgYSBwZXJzaXN0YW50IEJDIGNvbm5lY3Rpb24gdG8gYSBzaGFyZWpzIHNlcnZlci5cbi8vXG4vLyBUaGlzIGNsYXNzIGltcGxlbWVudHMgdGhlIGNsaWVudCBzaWRlIG9mIHRoZSBwcm90b2NvbCBkZWZpbmVkIGhlcmU6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vam9zZXBoZy9TaGFyZUpTL3dpa2kvV2lyZS1Qcm90b2NvbFxuLy9cbi8vIFRoZSBlcXVpdmFsZW50IHNlcnZlciBjb2RlIGlzIGluIHNyYy9zZXJ2ZXIvc2Vzc2lvbi5cbi8vXG4vLyBUaGlzIGZpbGUgaXMgYSBiaXQgb2YgYSBtZXNzLiBJJ20gZHJlYWRmdWxseSBzb3JyeSBhYm91dCB0aGF0LiBJdCBwYXNzZXMgYWxsIHRoZSB0ZXN0cyxcbi8vIHNvIEkgaGF2ZSBob3BlIHRoYXQgaXRzICpjb3JyZWN0KiBldmVuIGlmIGl0cyBub3QgY2xlYW4uXG4vL1xuLy8gVG8gbWFrZSBhIGNvbm5lY3Rpb24sIHVzZTpcbi8vICBuZXcgc2hhcmVqcy5Db25uZWN0aW9uKHNvY2tldClcbi8vXG4vLyBUaGUgc29ja2V0IHNob3VsZCBsb29rIGxpa2UgYSB3ZWJzb2NrZXQgY29ubmVjdGlvbi4gSXQgc2hvdWxkIGhhdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuLy8gIHNlbmQobXNnKTogU2VuZCB0aGUgZ2l2ZW4gbWVzc2FnZS4gbXNnIG1heSBiZSBhbiBvYmplY3QgLSBpZiBzbywgeW91IG1pZ2h0IG5lZWQgdG8gSlNPTi5zdHJpbmdpZnkgaXQuXG4vLyAgY2xvc2UoKTogRGlzY29ubmVjdCB0aGUgc2Vzc2lvblxuLy9cbi8vICBvbm1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpe306IEV2ZW50IGhhbmRsZXIgd2hpY2ggaXMgY2FsbGVkIHdoZW5ldmVyIGEgbWVzc2FnZSBpcyByZWNlaXZlZC4gVGhlIG1lc3NhZ2Vcbi8vICAgICBwYXNzZWQgaW4gc2hvdWxkIGFscmVhZHkgYmUgYW4gb2JqZWN0LiAoSXQgbWF5IG5lZWQgdG8gYmUgSlNPTi5wYXJzZWQpXG4vLyAgb25jbG9zZVxuLy8gIG9uZXJyb3Jcbi8vICBvbm9wZW5cbi8vICBvbmNvbm5lY3Rpbmdcbi8vXG4vLyBUaGUgc29ja2V0IHNob3VsZCBwcm9iYWJseSBhdXRvbWF0aWNhbGx5IHJlY29ubmVjdC4gSWYgc28sIGl0IHNob3VsZCBlbWl0IHRoZSBhcHByb3ByaWF0ZSBldmVudHMgYXMgaXRcbi8vIGRpc2Nvbm5lY3RzICYgcmVjb25uZWN0cy4gKG9uY2xvc2UoKSwgb25jb25uZWN0aW5nKCksIG9ub3BlbigpKS5cblxudmFyIHR5cGVzLCBEb2M7XG5pZiAodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSB7XG4gIHR5cGVzID0gcmVxdWlyZSgnb3R0eXBlcycpO1xuICBEb2MgPSByZXF1aXJlKCcuL2RvYycpLkRvYztcbiAgUXVlcnkgPSByZXF1aXJlKCcuL3F1ZXJ5JykuUXVlcnk7XG59IGVsc2Uge1xuICB0eXBlcyA9IHdpbmRvdy5vdHR5cGVzO1xuICBEb2MgPSBleHBvcnRzLkRvYztcbn1cblxudmFyIENvbm5lY3Rpb24gPSBleHBvcnRzLkNvbm5lY3Rpb24gPSBmdW5jdGlvbiAoc29ja2V0KSB7XG4gIHRoaXMuc29ja2V0ID0gc29ja2V0O1xuXG4gIC8vIE1hcCBvZiBjb2xsZWN0aW9uIC0+IGRvY05hbWUgLT4gZG9jIG9iamVjdCBmb3IgY3JlYXRlZCBkb2N1bWVudHMuXG4gIC8vIChjcmVhdGVkIGRvY3VtZW50cyBNVVNUIEJFIFVOSVFVRSlcbiAgdGhpcy5jb2xsZWN0aW9ucyA9IHt9O1xuXG4gIC8vIEVhY2ggcXVlcnkgaXMgY3JlYXRlZCB3aXRoIGFuIGlkIHRoYXQgdGhlIHNlcnZlciB1c2VzIHdoZW4gaXQgc2VuZHMgdXNcbiAgLy8gaW5mbyBhYm91dCB0aGUgcXVlcnkgKHVwZGF0ZXMsIGV0YykuXG4gIC8vdGhpcy5uZXh0UXVlcnlJZCA9IChNYXRoLnJhbmRvbSgpICogMTAwMCkgfDA7XG4gIHRoaXMubmV4dFF1ZXJ5SWQgPSAxO1xuXG4gIC8vIE1hcCBmcm9tIHF1ZXJ5IElEIC0+IHF1ZXJ5IG9iamVjdC5cbiAgdGhpcy5xdWVyaWVzID0ge307XG5cbiAgLy8gQ29ubmVjdGlvbiBzdGF0ZS5cbiAgLy8gXG4gIC8vIFN0YXRlczpcbiAgLy8gLSAnY29ubmVjdGluZyc6IFRoZSBjb25uZWN0aW9uIGhhcyBiZWVuIGVzdGFibGlzaGVkLCBidXQgd2UgZG9uJ3QgaGF2ZSBvdXIgY2xpZW50IElEIHlldFxuICAvLyAtICdjb25uZWN0ZWQnOiBXZSBoYXZlIGNvbm5lY3RlZCBhbmQgcmVjaWV2ZWQgb3VyIGNsaWVudCBJRC4gUmVhZHkgZm9yIGRhdGEuXG4gIC8vIC0gJ2Rpc2Nvbm5lY3RlZCc6IFRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZCwgYnV0IGl0IHdpbGwgcmVjb25uZWN0IGF1dG9tYXRpY2FsbHkuXG4gIC8vIC0gJ3N0b3BwZWQnOiBUaGUgY29ubmVjdGlvbiBpcyBjbG9zZWQsIGFuZCBzaG91bGQgbm90IHJlY29ubmVjdC5cbiAgdGhpcy5zdGF0ZSA9IChzb2NrZXQucmVhZHlTdGF0ZSA9PT0gMCB8fCBzb2NrZXQucmVhZHlTdGF0ZSA9PT0gMSkgPyAnY29ubmVjdGluZycgOiAnZGlzY29ubmVjdGVkJztcblxuICAvLyBUaGlzIGlzIGEgaGVscGVyIHZhcmlhYmxlIHRoZSBkb2N1bWVudCB1c2VzIHRvIHNlZSB3aGV0aGVyIHdlJ3JlIGN1cnJlbnRseVxuICAvLyBpbiBhICdsaXZlJyBzdGF0ZS4gSXQgaXMgdHJ1ZSBpZiB0aGUgc3RhdGUgaXMgJ2Nvbm5lY3RpbmcnIG9yICdjb25uZWN0ZWQnLlxuICB0aGlzLmNhblNlbmQgPSB0aGlzLnN0YXRlID09PSAnY29ubmVjdGluZyc7XG5cbiAgLy8gUmVzZXQgc29tZSBtb3JlIHN0YXRlIHZhcmlhYmxlcy5cbiAgdGhpcy5yZXNldCgpO1xuXG4gIHRoaXMuZGVidWcgPSBmYWxzZTtcbiAgLy8gSSdsbCBzdG9yZSB0aGUgbW9zdCByZWNlbnQgMTAwIG1lc3NhZ2VzIHNvIHdoZW4gZXJyb3JzIG9jY3VyIHdlIGNhbiBzZWUgd2hhdCBoYXBwZW5lZC5cbiAgdGhpcy5tZXNzYWdlQnVmZmVyID0gW107XG5cbiAgdmFyIGNvbm5lY3Rpb24gPSB0aGlzO1xuXG4gIHZhciBoYW5kbGVNZXNzYWdlID0gZnVuY3Rpb24obXNnKSB7XG4gICAgLy8gU3dpdGNoIG9uIHRoZSBtZXNzYWdlIGFjdGlvbi4gTW9zdCBtZXNzYWdlcyBhcmUgZm9yIGRvY3VtZW50cyBhbmQgYXJlXG4gICAgLy8gaGFuZGxlZCBpbiB0aGUgZG9jIGNsYXNzLlxuICAgIHN3aXRjaCAobXNnLmEpIHtcbiAgICAgIGNhc2UgJ2luaXQnOlxuICAgICAgICAvLyBDbGllbnQgaW5pdGlhbGl6YXRpb24gcGFja2V0LiBUaGlzIGJ1bmRsZSBvZiBqb3kgY29udGFpbnMgb3VyIGNsaWVudFxuICAgICAgICAvLyBJRC5cbiAgICAgICAgaWYgKG1zZy5wcm90b2NvbCAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHByb3RvY29sIHZlcnNpb24nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtc2cuaWQgIT0gJ3N0cmluZycpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjbGllbnQgaWQnKTtcblxuICAgICAgICBjb25uZWN0aW9uLmlkID0gbXNnLmlkO1xuICAgICAgICBjb25uZWN0aW9uLl9zZXRTdGF0ZSgnY29ubmVjdGVkJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdxZmV0Y2gnOlxuICAgICAgY2FzZSAncXN1Yic6XG4gICAgICBjYXNlICdxJzpcbiAgICAgIGNhc2UgJ3F1bnN1Yic6XG4gICAgICAgIC8vIFF1ZXJ5IG1lc3NhZ2UuIFBhc3MgdGhpcyB0byB0aGUgYXBwcm9wcmlhdGUgcXVlcnkgb2JqZWN0LlxuICAgICAgICB2YXIgcXVlcnkgPSBjb25uZWN0aW9uLnF1ZXJpZXNbbXNnLmlkXTtcbiAgICAgICAgaWYgKHF1ZXJ5KSBxdWVyeS5fb25NZXNzYWdlKG1zZyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdicyc6XG4gICAgICAgIC8vIEJ1bGsgc3Vic2NyaWJlIHJlc3BvbnNlLiBUaGUgcmVzcG9uc2VzIGZvciBlYWNoIGRvY3VtZW50IGFyZSBjb250YWluZWQgd2l0aGluLlxuICAgICAgICB2YXIgcmVzdWx0ID0gbXNnLnM7XG4gICAgICAgIGZvciAodmFyIGNOYW1lIGluIHJlc3VsdCkge1xuICAgICAgICAgIGZvciAodmFyIGRvY05hbWUgaW4gcmVzdWx0W2NOYW1lXSkge1xuICAgICAgICAgICAgdmFyIGRvYyA9IGNvbm5lY3Rpb24uZ2V0KGNOYW1lLCBkb2NOYW1lKTtcbiAgICAgICAgICAgIGlmICghZG9jKSB7XG4gICAgICAgICAgICAgIGlmIChjb25zb2xlKSBjb25zb2xlLmVycm9yKCdNZXNzYWdlIGZvciB1bmtub3duIGRvYy4gSWdub3JpbmcuJywgbXNnKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtc2cgPSByZXN1bHRbY05hbWVdW2RvY05hbWVdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtc2cgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgIGRvYy5faGFuZGxlU3Vic2NyaWJlKG1zZy5lcnJvciwgbXNnLmRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gVGhlIG1zZyB3aWxsIGJlIHRydWUgaWYgd2Ugc2ltcGx5IHJlc3Vic2NyaWJlZC5cbiAgICAgICAgICAgICAgZG9jLl9oYW5kbGVTdWJzY3JpYmUobnVsbCwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBEb2N1bWVudCBtZXNzYWdlLiBQdWxsIG91dCB0aGUgcmVmZXJlbmNlZCBkb2N1bWVudCBhbmQgZm9yd2FyZCB0aGVcbiAgICAgICAgLy8gbWVzc2FnZS5cbiAgICAgICAgdmFyIGNvbGxlY3Rpb24sIGRvY05hbWUsIGRvYztcbiAgICAgICAgaWYgKG1zZy5kKSB7XG4gICAgICAgICAgY29sbGVjdGlvbiA9IGNvbm5lY3Rpb24uX2xhc3RSZWNlaXZlZENvbGxlY3Rpb24gPSBtc2cuYztcbiAgICAgICAgICBkb2NOYW1lID0gY29ubmVjdGlvbi5fbGFzdFJlY2VpdmVkRG9jID0gbXNnLmQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29sbGVjdGlvbiA9IG1zZy5jID0gY29ubmVjdGlvbi5fbGFzdFJlY2VpdmVkQ29sbGVjdGlvbjtcbiAgICAgICAgICBkb2NOYW1lID0gbXNnLmQgPSBjb25uZWN0aW9uLl9sYXN0UmVjZWl2ZWREb2M7XG4gICAgICAgIH1cblxuICAgICAgICBkb2MgPSBjb25uZWN0aW9uLmdldChjb2xsZWN0aW9uLCBkb2NOYW1lKTtcbiAgICAgICAgaWYgKCFkb2MpIHtcbiAgICAgICAgICBpZiAoY29uc29sZSkgY29uc29sZS5lcnJvcignTWVzc2FnZSBmb3IgdW5rbm93biBkb2MuIElnbm9yaW5nLicsIG1zZyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZG9jLl9vbk1lc3NhZ2UobXNnKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQXR0YWNoIGV2ZW50IGhhbmRsZXJzIHRvIHRoZSBzb2NrZXQuXG4gIHNvY2tldC5vbm1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpIHtcbiAgICBpZiAoY29ubmVjdGlvbi5kZWJ1ZykgY29uc29sZS5sb2coJ1JFQ1YnLCBKU09OLnN0cmluZ2lmeShtc2cpKTtcbiAgICBjb25uZWN0aW9uLm1lc3NhZ2VCdWZmZXIucHVzaCh7dDoobmV3IERhdGUoKSkudG9UaW1lU3RyaW5nKCksIHJlY3Y6SlNPTi5zdHJpbmdpZnkobXNnKX0pO1xuICAgIHdoaWxlIChjb25uZWN0aW9uLm1lc3NhZ2VCdWZmZXIubGVuZ3RoID4gMTAwKSB7XG4gICAgICBjb25uZWN0aW9uLm1lc3NhZ2VCdWZmZXIuc2hpZnQoKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaGFuZGxlTWVzc2FnZShtc2cpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbm5lY3Rpb24uZW1pdCgnZXJyb3InLCBlKTtcbiAgICAgIC8vIFdlIGNvdWxkIGFsc28gcmVzdGFydCB0aGUgY29ubmVjdGlvbiBoZXJlLCBhbHRob3VnaCB0aGF0IG1pZ2h0IHJlc3VsdFxuICAgICAgLy8gaW4gaW5maW5pdGUgcmVjb25uZWN0aW9uIGJ1Z3MuXG4gICAgfVxuICB9XG5cbiAgc29ja2V0Lm9ub3BlbiA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbm5lY3Rpb24uX3NldFN0YXRlKCdjb25uZWN0aW5nJyk7XG4gIH07XG5cbiAgc29ja2V0Lm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgLy8gVGhpcyBpc24ndCB0aGUgc2FtZSBhcyBhIHJlZ3VsYXIgZXJyb3IsIGJlY2F1c2UgaXQgd2lsbCBoYXBwZW4gbm9ybWFsbHlcbiAgICAvLyBmcm9tIHRpbWUgdG8gdGltZS4gWW91ciBjb25uZWN0aW9uIHNob3VsZCBwcm9iYWJseSBhdXRvbWF0aWNhbGx5XG4gICAgLy8gcmVjb25uZWN0IGFueXdheSwgYnV0IHRoYXQgc2hvdWxkIGJlIHRyaWdnZXJlZCBvZmYgb25jbG9zZSBub3Qgb25lcnJvci5cbiAgICAvLyAob25jbG9zZSBoYXBwZW5zIHdoZW4gb25lcnJvciBnZXRzIGNhbGxlZCBhbnl3YXkpLlxuICAgIGNvbm5lY3Rpb24uZW1pdCgnY29ubmVjdGlvbiBlcnJvcicsIGUpO1xuICB9O1xuXG4gIHNvY2tldC5vbmNsb3NlID0gZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgY29ubmVjdGlvbi5fc2V0U3RhdGUoJ2Rpc2Nvbm5lY3RlZCcsIHJlYXNvbik7XG4gICAgaWYgKHJlYXNvbiA9PT0gJ0Nsb3NlZCcgfHwgcmVhc29uID09PSAnU3RvcHBlZCBieSBzZXJ2ZXInKSB7XG4gICAgICBjb25uZWN0aW9uLl9zZXRTdGF0ZSgnc3RvcHBlZCcsIHJlYXNvbik7XG4gICAgfVxuICB9O1xufVxuXG4vKiBXaHkgZG9lcyB0aGlzIGZ1bmN0aW9uIGV4aXN0PyBJcyBpdCBpbXBvcnRhbnQ/XG5Db25uZWN0aW9uLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gIHRoaXMuX3NldFN0YXRlKCdzdG9wcGVkJywgZSk7XG4gIHJldHVybiB0aGlzLmRpc2Nvbm5lY3QoZSk7XG59O1xuKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pZCA9IHRoaXMubGFzdEVycm9yID1cbiAgICB0aGlzLl9sYXN0UmVjZWl2ZWRDb2xsZWN0aW9uID0gdGhpcy5fbGFzdFJlY2VpdmVkRG9jID1cbiAgICB0aGlzLl9sYXN0U2VudENvbGxlY3Rpb24gPSB0aGlzLl9sYXN0U2VudERvYyA9IG51bGw7XG5cbiAgdGhpcy5zZXEgPSAxO1xufTtcblxuLy8gU2V0IHRoZSBjb25uZWN0aW9uJ3Mgc3RhdGUuIFRoZSBjb25uZWN0aW9uIGlzIGJhc2ljYWxseSBhIHN0YXRlIG1hY2hpbmUuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5fc2V0U3RhdGUgPSBmdW5jdGlvbihuZXdTdGF0ZSwgZGF0YSkge1xuICBpZiAodGhpcy5zdGF0ZSA9PT0gbmV3U3RhdGUpIHJldHVybjtcblxuICAvLyBJIG1hZGUgYSBzdGF0ZSBkaWFncmFtLiBUaGUgb25seSBpbnZhbGlkIHRyYW5zaXRpb25zIGFyZSBnZXR0aW5nIHRvXG4gIC8vICdjb25uZWN0aW5nJyBmcm9tIGFueXdoZXJlIG90aGVyIHRoYW4gJ2Rpc2Nvbm5lY3RlZCcgYW5kIGdldHRpbmcgdG9cbiAgLy8gJ2Nvbm5lY3RlZCcgZnJvbSBhbnl3aGVyZSBvdGhlciB0aGFuICdjb25uZWN0aW5nJy5cbiAgaWYgKChuZXdTdGF0ZSA9PT0gJ2Nvbm5lY3RpbmcnICYmICh0aGlzLnN0YXRlICE9PSAnZGlzY29ubmVjdGVkJyAmJiB0aGlzLnN0YXRlICE9PSAnc3RvcHBlZCcpKVxuICAgICAgfHwgKG5ld1N0YXRlID09PSAnY29ubmVjdGVkJyAmJiB0aGlzLnN0YXRlICE9PSAnY29ubmVjdGluZycpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHRyYW5zaXRpb24gZGlyZWN0bHkgZnJvbSBcIiArIHRoaXMuc3RhdGUgKyBcIiB0byBcIiArIG5ld1N0YXRlKTtcbiAgfVxuXG4gIHRoaXMuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgdGhpcy5jYW5TZW5kID0gbmV3U3RhdGUgPT09ICdjb25uZWN0aW5nJyB8fCBuZXdTdGF0ZSA9PT0gJ2Nvbm5lY3RlZCc7XG5cbiAgaWYgKG5ld1N0YXRlID09PSAnZGlzY29ubmVjdGVkJykgdGhpcy5yZXNldCgpO1xuXG4gIHRoaXMuZW1pdChuZXdTdGF0ZSwgZGF0YSk7XG5cbiAgLy8gJiBFbWl0IHRoZSBldmVudCB0byBhbGwgZG9jdW1lbnRzICYgcXVlcmllcy4gSXQgbWlnaHQgbWFrZSBzZW5zZSBmb3JcbiAgLy8gZG9jdW1lbnRzIHRvIGp1c3QgcmVnaXN0ZXIgZm9yIHRoaXMgc3R1ZmYgdXNpbmcgZXZlbnRzLCBidXQgdGhhdCBjb3VwbGVzXG4gIC8vIGNvbm5lY3Rpb25zIGFuZCBkb2N1bWVudHMgYSBiaXQgbXVjaC4gSXRzIG5vdCBhIGJpZyBkZWFsIGVpdGhlciB3YXkuXG4gIHRoaXMub3BRdWV1ZSA9IFtdO1xuICB0aGlzLnN1YnNjcmliZURhdGEgPSB7fTtcbiAgZm9yICh2YXIgYyBpbiB0aGlzLmNvbGxlY3Rpb25zKSB7XG4gICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLmNvbGxlY3Rpb25zW2NdO1xuICAgIGZvciAodmFyIGRvY05hbWUgaW4gY29sbGVjdGlvbikge1xuICAgICAgY29sbGVjdGlvbltkb2NOYW1lXS5fb25Db25uZWN0aW9uU3RhdGVDaGFuZ2VkKG5ld1N0YXRlLCBkYXRhKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIEl0cyBpbXBvcnRhbnQgdGhhdCBvcGVyYXRpb25zIGFyZSByZXNlbnQgaW4gdGhlIHNhbWUgb3JkZXIgdGhhdCB0aGV5IHdlcmVcbiAgLy8gb3JpZ2luYWxseSBzZW50LiBJZiB3ZSBkb24ndCBzb3J0LCBhbiBvcCB3aXRoIGEgaGlnaCBzZXF1ZW5jZSBudW1iZXIgd2lsbFxuICAvLyBjb252aW5jZSB0aGUgc2VydmVyIG5vdCB0byBhY2NlcHQgYW55IG9wcyB3aXRoIGVhcmxpZXIgc2VxdWVuY2UgbnVtYmVycy5cbiAgdGhpcy5vcFF1ZXVlLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYS5zZXEgLSBiLnNlcTsgfSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vcFF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5zZW5kKHRoaXMub3BRdWV1ZVtpXSk7XG4gIH1cblxuICAvLyBPbmx5IHNlbmQgYnVsayBzdWJzY3JpYmUgaWYgbm90IGVtcHR5LiBJdHMgd2VpcmQgdXNpbmcgYSBmb3IgbG9vcCBmb3JcbiAgLy8gdGhpcywgYnV0IGl0IHdvcmtzIHByZXR0eSB3ZWxsLlxuICBmb3IgKHZhciBfX3VudXNlZCBpbiB0aGlzLnN1YnNjcmliZURhdGEpIHsgXG4gICAgdGhpcy5zZW5kKHthOidicycsIHM6dGhpcy5zdWJzY3JpYmVEYXRhfSk7XG4gICAgYnJlYWs7XG4gIH1cblxuICB0aGlzLm9wUXVldWUgPSBudWxsO1xuICB0aGlzLnN1YnNjcmliZURhdGEgPSBudWxsO1xuICBcbiAgLy8gTm8gYnVsayBzdWJzY3JpYmUgZm9yIHF1ZXJpZXMgeWV0LlxuICBmb3IgKHZhciBpZCBpbiB0aGlzLnF1ZXJpZXMpIHtcbiAgICB0aGlzLnF1ZXJpZXNbaWRdLl9vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQobmV3U3RhdGUsIGRhdGEpO1xuICB9XG59O1xuXG4vLyBTbywgdGhlcmUncyBhbiBhd2Z1bCBlcnJvciBjYXNlIHdoZXJlIHRoZSBjbGllbnQgc2VuZHMgdHdvIHJlcXVlc3RzICh3aGljaFxuLy8gZmFpbCksIHRoZW4gcmVjb25uZWN0cy4gVGhlIGRvY3VtZW50cyBjb3VsZCBoYXZlIF9vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWRcbi8vIGNhbGxlZCBpbiB0aGUgd3Jvbmcgb3JkZXIgYW5kIHRoZSBvcGVyYXRpb25zIHRoZW4gZ2V0IHNlbnQgd2l0aCByZXZlcnNlZFxuLy8gc2VxdWVuY2UgbnVtYmVycy4gVGhpcyBjYXVzZXMgdGhlIHNlcnZlciB0byBpbmNvcnJlY3RseSByZWplY3QgdGhlIHNlY29uZFxuLy8gc2VudCBvcC4gU28gd2UgbmVlZCB0byBxdWV1ZSB0aGUgb3BlcmF0aW9ucyB3aGlsZSB3ZSdyZSByZWNvbm5lY3RpbmcgYW5kXG4vLyByZXNlbmQgdGhlbSBpbiB0aGUgY29ycmVjdCBvcmRlci5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmRPcCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgaWYgKHRoaXMub3BRdWV1ZSkge1xuICAgIHRoaXMub3BRdWV1ZS5wdXNoKGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc2VuZChkYXRhKTtcbiAgfVxufTtcblxuLy8gVGhpcyBpcyBjYWxsZWQgYnkgdGhlIGRvY3VtZW50IGNsYXNzIHdoZW4gdGhlIGRvY3VtZW50IHdhbnRzIHRvIHN1YnNjcmliZS5cbi8vIFdlIGNvdWxkIGp1c3Qgc2VuZCBhIHN1YnNjcmliZSBtZXNzYWdlLCBidXQgZHVyaW5nIHJlY29ubmVjdCB0aGF0IGNhdXNlcyBhXG4vLyBiYWppbGxpb24gbWVzc2FnZXMgb3ZlciBicm93c2VyY2hhbm5lbC4gRHVyaW5nIHJlY29ubmVjdCB3ZSdsbCBhZ2dyZWdhdGUsXG4vLyBzaW1pbGFyIHRvIHNlbmRPcC5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmRTdWJzY3JpYmUgPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBuYW1lLCB2KSB7XG4gIGlmICh0aGlzLnN1YnNjcmliZURhdGEpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuc3Vic2NyaWJlRGF0YTtcbiAgICBpZiAoIWRhdGFbY29sbGVjdGlvbl0pIGRhdGFbY29sbGVjdGlvbl0gPSB7fTtcblxuICAgIGRhdGFbY29sbGVjdGlvbl1bbmFtZV0gPSB2IHx8IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG1zZyA9IHthOidzdWInLCBjOmNvbGxlY3Rpb24sIGQ6bmFtZX07XG4gICAgaWYgKHYgIT0gbnVsbCkgbXNnLnYgPSB2O1xuICAgIHRoaXMuc2VuZChtc2cpO1xuICB9XG59O1xuXG4vLyBTZW5kIGEgbWVzc2FnZSB0byB0aGUgY29ubmVjdGlvbi5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtc2cpIHtcbiAgaWYgKHRoaXMuZGVidWcpIGNvbnNvbGUubG9nKFwiU0VORFwiLCBKU09OLnN0cmluZ2lmeShtc2cpKTtcbiAgdGhpcy5tZXNzYWdlQnVmZmVyLnB1c2goe3Q6RGF0ZS5ub3coKSwgc2VuZDpKU09OLnN0cmluZ2lmeShtc2cpfSk7XG4gIHdoaWxlICh0aGlzLm1lc3NhZ2VCdWZmZXIubGVuZ3RoID4gMTAwKSB7XG4gICAgdGhpcy5tZXNzYWdlQnVmZmVyLnNoaWZ0KCk7XG4gIH1cblxuICBpZiAobXNnLmQpIHsgLy8gVGhlIGRvY3VtZW50IHRoZSBtZXNzYWdlIHJlZmVycyB0by4gTm90IHNldCBmb3IgcXVlcmllcy5cbiAgICB2YXIgY29sbGVjdGlvbiA9IG1zZy5jO1xuICAgIHZhciBkb2NOYW1lID0gbXNnLmQ7XG4gICAgaWYgKGNvbGxlY3Rpb24gPT09IHRoaXMuX2xhc3RTZW50Q29sbGVjdGlvbiAmJiBkb2NOYW1lID09PSB0aGlzLl9sYXN0U2VudERvYykge1xuICAgICAgZGVsZXRlIG1zZy5jO1xuICAgICAgZGVsZXRlIG1zZy5kO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9sYXN0U2VudENvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICAgICAgdGhpcy5fbGFzdFNlbnREb2MgPSBkb2NOYW1lO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuc29ja2V0LnNlbmQobXNnKTtcbn07XG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgLy8gVGhpcyB3aWxsIGNhbGwgQHNvY2tldC5vbmNsb3NlKCksIHdoaWNoIGluIHR1cm4gd2lsbCBlbWl0IHRoZSAnZGlzY29ubmVjdGVkJyBldmVudC5cbiAgdGhpcy5zb2NrZXQuY2xvc2UoKTtcbn07XG5cblxuLy8gKioqKiogRG9jdW1lbnQgbWFuYWdlbWVudFxuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5nZXRFeGlzdGluZyA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIG5hbWUpIHtcbiAgaWYgKHRoaXMuY29sbGVjdGlvbnNbY29sbGVjdGlvbl0pIHJldHVybiB0aGlzLmNvbGxlY3Rpb25zW2NvbGxlY3Rpb25dW25hbWVdO1xufTtcblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0T3JDcmVhdGUgPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBuYW1lLCBkYXRhKSB7XG4gIGNvbnNvbGUudHJhY2UoJ2dldE9yQ3JlYXRlIGlzIGRlcHJlY2F0ZWQuIFVzZSBnZXQoKSBpbnN0ZWFkJyk7XG4gIHJldHVybiB0aGlzLmdldChjb2xsZWN0aW9uLCBuYW1lLCBkYXRhKTtcbn07XG5cbi8vIENyZWF0ZSBhIGRvY3VtZW50IGlmIGl0IGRvZXNuJ3QgZXhpc3QuIFJldHVybnMgdGhlIGRvY3VtZW50IHN5bmNocm9ub3VzbHkuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBuYW1lLCBkYXRhKSB7XG4gIHZhciBkb2MgPSB0aGlzLmdldEV4aXN0aW5nKGNvbGxlY3Rpb24sIG5hbWUpO1xuXG4gIGlmICghZG9jKSB7XG4gICAgLy8gQ3JlYXRlIGl0LlxuICAgIGRvYyA9IG5ldyBEb2ModGhpcywgY29sbGVjdGlvbiwgbmFtZSk7XG5cbiAgICB2YXIgY29sbGVjdGlvbk9iamVjdCA9IHRoaXMuY29sbGVjdGlvbnNbY29sbGVjdGlvbl0gPVxuICAgICAgKHRoaXMuY29sbGVjdGlvbnNbY29sbGVjdGlvbl0gfHwge30pO1xuICAgIGNvbGxlY3Rpb25PYmplY3RbbmFtZV0gPSBkb2M7XG4gIH1cblxuICAvLyBFdmVuIGlmIHRoZSBkb2N1bWVudCBpc24ndCBuZXcsIGl0cyBwb3NzaWJsZSB0aGUgZG9jdW1lbnQgd2FzIGNyZWF0ZWRcbiAgLy8gbWFudWFsbHkgYW5kIHRoZW4gdHJpZWQgdG8gYmUgcmUtY3JlYXRlZCB3aXRoIGRhdGEgKHN1cHBvc2UgYSBxdWVyeVxuICAvLyByZXR1cm5zIHdpdGggZGF0YSBmb3IgdGhlIGRvY3VtZW50KS4gV2Ugc2hvdWxkIGh5ZHJhdGUgdGhlIGRvY3VtZW50XG4gIC8vIGltbWVkaWF0ZWx5IGlmIHdlIGNhbiBiZWNhdXNlIHRoZSBxdWVyeSBjYWxsYmFjayB3aWxsIGV4cGVjdCB0aGUgZG9jdW1lbnRcbiAgLy8gdG8gaGF2ZSBkYXRhLlxuICBpZiAoZGF0YSAmJiBkYXRhLmRhdGEgIT09IHVuZGVmaW5lZCAmJiAhZG9jLnN0YXRlKSB7XG4gICAgZG9jLmluamVzdERhdGEoZGF0YSk7XG4gIH1cblxuICByZXR1cm4gZG9jO1xufTtcblxuLy8gQ2FsbCBkb2MuZGVzdHJveSgpXG5Db25uZWN0aW9uLnByb3RvdHlwZS5fZGVzdHJveURvYyA9IGZ1bmN0aW9uKGRvYykge1xuICB2YXIgY29sbGVjdGlvbk9iamVjdCA9IHRoaXMuY29sbGVjdGlvbnNbZG9jLmNvbGxlY3Rpb25dO1xuICBpZiAoIWNvbGxlY3Rpb25PYmplY3QpIHJldHVybjtcblxuICBkZWxldGUgY29sbGVjdGlvbk9iamVjdFtkb2MubmFtZV07XG5cbiAgLy8gRGVsZXRlIHRoZSBjb2xsZWN0aW9uIGNvbnRhaW5lciBpZiBpdHMgZW1wdHkuIFRoaXMgY291bGQgYmUgYSBzb3VyY2Ugb2ZcbiAgLy8gbWVtb3J5IGxlYWtzIGlmIHlvdSBzbG93bHkgbWFrZSBhIGJpbGxpb24gY29sbGVjdGlvbnMsIHdoaWNoIHlvdSBwcm9iYWJseVxuICAvLyB3b24ndCBkbyBhbnl3YXksIGJ1dCB3aGF0ZXZlci5cbiAgaWYgKCFoYXNLZXlzKGNvbGxlY3Rpb25PYmplY3QpKVxuICAgIGRlbGV0ZSB0aGlzLmNvbGxlY3Rpb25zW2RvYy5jb2xsZWN0aW9uXTtcbn07XG4gXG5mdW5jdGlvbiBoYXNLZXlzKG9iamVjdCkge1xuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gKioqKiBRdWVyaWVzLlxuXG4vLyBIZWxwZXIgZm9yIGNyZWF0ZUZldGNoUXVlcnkgYW5kIGNyZWF0ZVN1YnNjcmliZVF1ZXJ5LCBiZWxvdy5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLl9jcmVhdGVRdWVyeSA9IGZ1bmN0aW9uKHR5cGUsIGNvbGxlY3Rpb24sIHEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlICE9PSAnZmV0Y2gnICYmIHR5cGUgIT09ICdzdWInKVxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBxdWVyeSB0eXBlOiAnICsgdHlwZSk7XG5cbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gIHZhciBpZCA9IHRoaXMubmV4dFF1ZXJ5SWQrKztcbiAgdmFyIHF1ZXJ5ID0gbmV3IFF1ZXJ5KHR5cGUsIHRoaXMsIGlkLCBjb2xsZWN0aW9uLCBxLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gIHRoaXMucXVlcmllc1tpZF0gPSBxdWVyeTtcbiAgcXVlcnkuX2V4ZWN1dGUoKTtcbiAgcmV0dXJuIHF1ZXJ5O1xufTtcblxuLy8gSW50ZXJuYWwgZnVuY3Rpb24uIFVzZSBxdWVyeS5kZXN0cm95KCkgdG8gcmVtb3ZlIHF1ZXJpZXMuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5fZGVzdHJveVF1ZXJ5ID0gZnVuY3Rpb24ocXVlcnkpIHtcbiAgZGVsZXRlIHRoaXMucXVlcmllc1txdWVyeS5pZF07XG59O1xuXG4vLyBUaGUgcXVlcnkgb3B0aW9ucyBvYmplY3QgY2FuIGNvbnRhaW4gdGhlIGZvbGxvd2luZyBmaWVsZHM6XG4vL1xuLy8gZG9jTW9kZTogV2hhdCB0byBkbyB3aXRoIGRvY3VtZW50cyB0aGF0IGFyZSBpbiB0aGUgcmVzdWx0IHNldC4gQ2FuIGJlXG4vLyAgIG51bGwvdW5kZWZpbmVkIChkZWZhdWx0KSwgJ2ZldGNoJyBvciAnc3Vic2NyaWJlJy4gRmV0Y2ggbW9kZSBpbmRpY2F0ZXNcbi8vICAgdGhhdCB0aGUgc2VydmVyIHNob3VsZCBzZW5kIGRvY3VtZW50IHNuYXBzaG90cyB0byB0aGUgY2xpZW50IGZvciBhbGwgcXVlcnlcbi8vICAgcmVzdWx0cy4gVGhlc2Ugd2lsbCBiZSBoeWRyYXRlZCBpbnRvIHRoZSBkb2N1bWVudCBvYmplY3RzIGJlZm9yZSB0aGUgcXVlcnlcbi8vICAgcmVzdWx0IGNhbGxiYWNrcyBhcmUgcmV0dXJuZWQuIFN1YnNjcmliZSBtb2RlIGdldHMgZG9jdW1lbnQgc25hcHNob3RzIGFuZFxuLy8gICBhdXRvbWF0aWNhbGx5IHN1YnNjcmliZXMgdGhlIGNsaWVudCB0byBhbGwgcmVzdWx0cy4gTm90ZSB0aGF0IHRoZVxuLy8gICBkb2N1bWVudHMgKldJTEwgTk9UKiBiZSBhdXRvbWF0aWNhbGx5IHVuc3Vic2NyaWJlZCB3aGVuIHRoZSBxdWVyeSBpc1xuLy8gICBkZXN0cm95ZWQuIChTaGFyZUpTIGRvZXNuJ3QgaGF2ZSBlbm91Z2ggaW5mb3JtYXRpb24gdG8gZG8gdGhhdCBzYWZlbHkpLlxuLy8gICBCZXdhcmUgb2YgbWVtb3J5IGxlYWtzIHdoZW4gdXNpbmcgdGhpcyBvcHRpb24uXG4vL1xuLy8gcG9sbDogRm9yY2FibHkgZW5hYmxlIG9yIGRpc2FibGUgcG9sbGluZyBtb2RlLiBQb2xsaW5nIG1vZGUgd2lsbCByZWlzc3VlIHRoZSBxdWVyeVxuLy8gICBldmVyeSB0aW1lIGFueXRoaW5nIGluIHRoZSBjb2xsZWN0aW9uIGNoYW5nZXMgKCEhKSBzbywgaXRzIHF1aXRlXG4vLyAgIGV4cGVuc2l2ZS4gIEl0IGlzIGF1dG9tYXRpY2FsbHkgZW5hYmxlZCBmb3IgcGFnaW5hdGVkIGFuZCBzb3J0ZWQgcXVlcmllcy5cbi8vICAgQnkgZGVmYXVsdCBxdWVyaWVzIHJ1biB3aXRoIHBvbGxpbmcgbW9kZSBkaXNhYmxlZDsgd2hpY2ggd2lsbCBvbmx5IGNoZWNrXG4vLyAgIGNoYW5nZWQgZG9jdW1lbnRzIHRvIHRlc3QgaWYgdGhleSBub3cgbWF0Y2ggdGhlIHNwZWNpZmllZCBxdWVyeS5cbi8vICAgU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgcG9sbGluZyBtb2RlLCBvciB0cnVlIHRvIGVuYWJsZSBpdC4gSWYgeW91IGRvbid0XG4vLyAgIHNwZWNpZnkgYSBwb2xsIG9wdGlvbiwgcG9sbGluZyBtb2RlIGlzIGVuYWJsZWQgb3IgZGlzYWJsZWQgYXV0b21hdGljYWxseVxuLy8gICBieSB0aGUgcXVlcnkncyBiYWNrZW5kLlxuLy9cbi8vIGJhY2tlbmQ6IFNldCB0aGUgYmFja2VuZCBzb3VyY2UgZm9yIHRoZSBxdWVyeS4gWW91IGNhbiBhdHRhY2ggZGlmZmVyZW50XG4vLyAgIHF1ZXJ5IGJhY2tlbmRzIHRvIGxpdmVkYiBhbmQgcGljayB3aGljaCBvbmUgdGhlIHF1ZXJ5IHNob3VsZCBoaXQgdXNpbmdcbi8vICAgdGhpcyBwYXJhbWV0ZXIuXG4vL1xuLy8gcmVzdWx0czogKGV4cGVyaW1lbnRhbCkgSW5pdGlhbCBsaXN0IG9mIHJlc3VsdGFudCBkb2N1bWVudHMuIFRoaXMgaXNcbi8vICAgdXNlZnVsIGZvciByZWh5ZHJhdGluZyBxdWVyaWVzIHdoZW4geW91J3JlIHVzaW5nIGF1dG9GZXRjaCAvIGF1dG9TdWJzY3JpYmVcbi8vICAgc28gdGhlIHNlcnZlciBkb2Vzbid0IGhhdmUgdG8gc2VuZCBvdmVyIHNuYXBzaG90cyBmb3IgZG9jdW1lbnRzIHRoZSBjbGllbnRcbi8vICAgYWxyZWFkeSBrbm93cyBhYm91dC4gVGhpcyBpcyBleHBlcmltZW50YWwgLSB0aGUgQVBJIG1heSBjaGFuZ2UgaW4gdXBjb21pbmdcbi8vICAgdmVyc2lvbnMuXG5cbi8vIENyZWF0ZSBhIGZldGNoIHF1ZXJ5LiBGZXRjaCBxdWVyaWVzIGFyZSBvbmx5IGlzc3VlZCBvbmNlLCByZXR1cm5pbmcgdGhlXG4vLyByZXN1bHRzIGRpcmVjdGx5IGludG8gdGhlIGNhbGxiYWNrLlxuLy9cbi8vIFRoZSBpbmRleCBpcyBzcGVjaWZpYyB0byB0aGUgc291cmNlLCBidXQgaWYgeW91J3JlIHVzaW5nIG1vbmdvZGIgaXQnbGwgYmVcbi8vIHRoZSBjb2xsZWN0aW9uIHRvIHdoaWNoIHRoZSBxdWVyeSBpcyBtYWRlLlxuLy8gVGhlIGNhbGxiYWNrIHNob3VsZCBoYXZlIHRoZSBzaWduYXR1cmUgZnVuY3Rpb24oZXJyb3IsIHJlc3VsdHMsIGV4dHJhRGF0YSlcbi8vIHdoZXJlIHJlc3VsdHMgaXMgYSBsaXN0IG9mIERvYyBvYmplY3RzLlxuQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlRmV0Y2hRdWVyeSA9IGZ1bmN0aW9uKGluZGV4LCBxLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5fY3JlYXRlUXVlcnkoJ2ZldGNoJywgaW5kZXgsIHEsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn07XG5cbi8vIENyZWF0ZSBhIHN1YnNjcmliZSBxdWVyeS4gU3Vic2NyaWJlIHF1ZXJpZXMgcmV0dXJuIHdpdGggdGhlIGluaXRpYWwgZGF0YVxuLy8gdGhyb3VnaCB0aGUgY2FsbGJhY2ssIHRoZW4gdXBkYXRlIHRoZW1zZWx2ZXMgd2hlbmV2ZXIgdGhlIHF1ZXJ5IHJlc3VsdCBzZXRcbi8vIGNoYW5nZXMgdmlhIHRoZWlyIG93biBldmVudCBlbWl0dGVyLlxuLy9cbi8vIElmIHByZXNlbnQsIHRoZSBjYWxsYmFjayBzaG91bGQgaGF2ZSB0aGUgc2lnbmF0dXJlIGZ1bmN0aW9uKGVycm9yLCByZXN1bHRzLCBleHRyYURhdGEpXG4vLyB3aGVyZSByZXN1bHRzIGlzIGEgbGlzdCBvZiBEb2Mgb2JqZWN0cy5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZVN1YnNjcmliZVF1ZXJ5ID0gZnVuY3Rpb24oaW5kZXgsIHEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9jcmVhdGVRdWVyeSgnc3ViJywgaW5kZXgsIHEsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn07XG5cbmlmICh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgTWljcm9FdmVudCA9IHJlcXVpcmUoJy4vbWljcm9ldmVudCcpO1xufVxuXG5NaWNyb0V2ZW50Lm1peGluKENvbm5lY3Rpb24pO1xuXG4iLCJ2YXIgdHlwZXMsIE1pY3JvRXZlbnQ7XG5cbmlmICh0eXBlb2YgcmVxdWlyZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB0eXBlcyA9IHJlcXVpcmUoJ290dHlwZXMnKTtcbiAgTWljcm9FdmVudCA9IHJlcXVpcmUoJy4vbWljcm9ldmVudCcpO1xufSBlbHNlIHtcbiAgdHlwZXMgPSB3aW5kb3cub3R0eXBlcztcbn1cblxuLypcbiAqIEEgRG9jIGlzIGEgY2xpZW50J3MgdmlldyBvbiBhIHNoYXJlanMgZG9jdW1lbnQuXG4gKlxuICogRG9jdW1lbnRzIHNob3VsZCBub3QgYmUgY3JlYXRlZCBkaXJlY3RseS4gQ3JlYXRlIHRoZW0gYnkgY2FsbGluZyB0aGVcbiAqIGRvY3VtZW50IGdldHRpbmcgZnVuY3Rpb25zIGluIGNvbm5lY3Rpb24uXG4gKlxuICogRG9jdW1lbnRzIGFyZSBldmVudCBlbWl0dGVycy4gVXNlIGRvYy5vbihldmVudG5hbWUsIGZuKSB0byBzdWJzY3JpYmUuXG4gKlxuICogRG9jdW1lbnRzIGN1cnJlbnRseSBnZXQgbWl4ZWQgaW4gd2l0aCB0aGVpciB0eXBlJ3MgQVBJIG1ldGhvZHMuIFNvLCB5b3UgY2FuXG4gKiAuaW5zZXJ0KCdmb28nLCAwKSBpbnRvIGEgdGV4dCBkb2N1bWVudCBhbmQgc3R1ZmYgbGlrZSB0aGF0LlxuICpcbiAqIEV2ZW50czpcbiAqIC0gYmVmb3JlIG9wIChvcCwgbG9jYWxTaXRlKTogRmlyZWQgYmVmb3JlIGFuIG9wZXJhdGlvbiBpcyBhcHBsaWVkIHRvIHRoZVxuICogICBkb2N1bWVudC5cbiAqIC0gb3AgKG9wLCBsb2NhbFNpdGUpOiBGaXJlZCByaWdodCBhZnRlciBhbiBvcGVyYXRpb24gKG9yIHBhcnQgb2YgYW5cbiAqICAgb3BlcmF0aW9uKSBoYXMgYmVlbiBhcHBsaWVkIHRvIHRoZSBkb2N1bWVudC4gU3VibWl0dGluZyBhbm90aGVyIG9wIGhlcmUgaXNcbiAqICAgaW52YWxpZCAtIHdhaXQgdW50aWwgJ2FmdGVyIG9wJyBpZiB5b3Ugd2FudCB0byBzdWJtaXQgbW9yZSBvcGVyYXRpb25zLiAgLVxuICogICBjaGFuZ2VkIChvcClcbiAqIC0gYWZ0ZXIgb3AgKG9wLCBsb2NhbFNpdGUpOiBGaXJlZCBhZnRlciBhbiBvcGVyYXRpb24gaGFzIGJlZW4gYXBwbGllZC4gWW91XG4gKiAgIGNhbiBzdWJtaXQgbW9yZSBvcHMgaGVyZS5cbiAqIC0gc3Vic2NyaWJlZCAoZXJyb3IpOiBUaGUgZG9jdW1lbnQgd2FzIHN1YnNjcmliZWRcbiAqIC0gdW5zdWJzY3JpYmVkIChlcnJvcik6IFRoZSBkb2N1bWVudCB3YXMgdW5zdWJzY3JpYmVkXG4gKiAtIGNyZWF0ZWQ6IFRoZSBkb2N1bWVudCB3YXMgY3JlYXRlZC4gVGhhdCBtZWFucyBpdHMgdHlwZSB3YXMgc2V0IGFuZCBpdCBoYXNcbiAqICAgc29tZSBpbml0aWFsIGRhdGEuXG4gKiAtIGVycm9yXG4gKi9cbnZhciBEb2MgPSBleHBvcnRzLkRvYyA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24sIGNvbGxlY3Rpb24sIG5hbWUpIHtcbiAgdGhpcy5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcblxuICB0aGlzLmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuXG4gIHRoaXMudmVyc2lvbiA9IHRoaXMudHlwZSA9IG51bGw7XG5cbiAgLy8gKioqKiBTdGF0ZSBpbiBkb2N1bWVudDpcbiBcbiAgLy8gQWN0aW9uLiBUaGlzIGlzIGVpdGhlciBudWxsLCBvciBvbmUgb2YgdGhlIGFjdGlvbnMgKHN1YnNjcmliZSxcbiAgLy8gdW5zdWJzY3JpYmUsIGZldGNoLCBzdWJtaXQpLiBPbmx5IG9uZSBhY3Rpb24gY2FuIGJlIGhhcHBlbmluZyBhdCBhIHRpbWUgdG9cbiAgLy8gcHJldmVudCBtZSBmcm9tIGdvaW5nIG1hZC5cbiAgLy9cbiAgLy8gUG9zc2libGUgdmFsdWVzOlxuICAvLyAtIHN1YnNjcmliZVxuICAvLyAtIHVuc3Vic2NyaWJlXG4gIC8vIC0gZmV0Y2hcbiAgLy8gLSBzdWJtaXRcbiAgdGhpcy5hY3Rpb24gPSBudWxsO1xuIFxuICAvLyBUaGUgZGF0YSB0aGUgZG9jdW1lbnQgb2JqZWN0IHN0b3JlcyBjYW4gYmUgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgdGhyZWUgc3RhdGVzOlxuICAvLyAgIC0gTm8gZGF0YS4gKG51bGwpIFdlIGhvbmVzdGx5IGRvbid0IGtub3cgd2hhdHMgZ29pbmcgb24uXG4gIC8vICAgLSBGbG9hdGluZyAoJ2Zsb2F0aW5nJyk6IHdlIGhhdmUgYSBsb2NhbGx5IGNyZWF0ZWQgZG9jdW1lbnQgdGhhdCBoYXNuJ3RcbiAgLy8gICAgIGJlZW4gY3JlYXRlZCBvbiB0aGUgc2VydmVyIHlldClcbiAgLy8gICAtIExpdmUgKCdyZWFkeScpICh3ZSBoYXZlIGRhdGEgdGhhdHMgY3VycmVudCBvbiB0aGUgc2VydmVyIGF0IHNvbWUgdmVyc2lvbikuXG4gIHRoaXMuc3RhdGUgPSBudWxsO1xuXG4gIC8vIE91ciBzdWJzY3JpcHRpb24gc3RhdHVzLiBFaXRoZXIgd2UncmUgc3Vic2NyaWJlZCBvbiB0aGUgc2VydmVyLCBvciB3ZSBhcmVuJ3QuXG4gIHRoaXMuc3Vic2NyaWJlZCA9IGZhbHNlO1xuICAvLyBFaXRoZXIgd2Ugd2FudCB0byBiZSBzdWJzY3JpYmVkICh0cnVlKSwgd2Ugd2FudCBhIG5ldyBzbmFwc2hvdCBmcm9tIHRoZVxuICAvLyBzZXJ2ZXIgKCdmZXRjaCcpLCBvciB3ZSBkb24ndCBjYXJlIChmYWxzZSkuICBUaGlzIGlzIGFsc28gdXNlZCB3aGVuIHdlXG4gIC8vIGRpc2Nvbm5lY3QgJiByZWNvbm5lY3QgdG8gZGVjaWRlIHdoYXQgdG8gZG8uXG4gIHRoaXMud2FudFN1YnNjcmliZSA9IGZhbHNlO1xuICAvLyBUaGlzIGxpc3QgaXMgdXNlZCBmb3Igc3Vic2NyaWJlIGFuZCB1bnN1YnNjcmliZSwgc2luY2Ugd2UnbGwgb25seSB3YW50IHRvXG4gIC8vIGRvIG9uZSB0aGluZyBhdCBhIHRpbWUuXG4gIHRoaXMuX3N1YnNjcmliZUNhbGxiYWNrcyA9IFtdO1xuXG5cbiAgLy8gKioqIGVuZCBzdGF0ZSBzdHVmZi5cblxuICAvLyBUaGlzIGRvZXNuJ3QgcHJvdmlkZSBhbnkgc3RhbmRhcmQgQVBJIGFjY2VzcyByaWdodCBub3cuXG4gIHRoaXMucHJvdmlkZXMgPSB7fTtcblxuICAvLyBUaGUgZWRpdGluZyBjb250ZXh0cy4gVGhlc2UgYXJlIHVzdWFsbHkgaW5zdGFuY2VzIG9mIHRoZSB0eXBlIEFQSSB3aGVuIHRoZVxuICAvLyBkb2N1bWVudCBpcyByZWFkeSBmb3IgZWRpdHMuXG4gIHRoaXMuZWRpdGluZ0NvbnRleHRzID0gW107XG4gIFxuICAvLyBUaGUgb3AgdGhhdCBpcyBjdXJyZW50bHkgcm91bmR0cmlwcGluZyB0byB0aGUgc2VydmVyLCBvciBudWxsLlxuICAvL1xuICAvLyBXaGVuIHRoZSBjb25uZWN0aW9uIHJlY29ubmVjdHMsIHRoZSBpbmZsaWdodCBvcCBpcyByZXN1Ym1pdHRlZC5cbiAgLy9cbiAgLy8gVGhpcyBoYXMgdGhlIHNhbWUgZm9ybWF0IGFzIGFuIGVudHJ5IGluIHBlbmRpbmdEYXRhLCB3aGljaCBpczpcbiAgLy8ge1tjcmVhdGU6ey4uLn1dLCBbZGVsOnRydWVdLCBbb3A6Li4uXSwgY2FsbGJhY2tzOlsuLi5dLCBzcmM6LCBzZXE6fVxuICB0aGlzLmluZmxpZ2h0RGF0YSA9IG51bGw7XG5cbiAgLy8gQWxsIG9wcyB0aGF0IGFyZSB3YWl0aW5nIGZvciB0aGUgc2VydmVyIHRvIGFja25vd2xlZGdlIEBpbmZsaWdodERhdGFcbiAgLy8gVGhpcyB1c2VkIHRvIGp1c3QgYmUgYSBzaW5nbGUgb3BlcmF0aW9uLCBidXQgY3JlYXRlcyAmIGRlbGV0ZXMgY2FuJ3QgYmUgY29tcG9zZWQgd2l0aFxuICAvLyByZWd1bGFyIG9wZXJhdGlvbnMuXG4gIC8vXG4gIC8vIFRoaXMgaXMgYSBsaXN0IG9mIHtbY3JlYXRlOnsuLi59XSwgW2RlbDp0cnVlXSwgW29wOi4uLl0sIGNhbGxiYWNrczpbLi4uXX1cbiAgdGhpcy5wZW5kaW5nRGF0YSA9IFtdO1xufTtcblxuTWljcm9FdmVudC5taXhpbihEb2MpO1xuXG5Eb2MucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgZG9jID0gdGhpcztcbiAgdGhpcy51bnN1YnNjcmliZShmdW5jdGlvbigpIHtcbiAgICAvLyBEb24ndCBjYXJlIGlmIHRoZXJlJ3MgYW4gZXJyb3IgdW5zdWJzY3JpYmluZy5cblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAvLyBUaGVyZSdsbCBwcm9iYWJseSBiZSBub3RoaW5nIGhlcmUgc2VlaW5nIGFzIGhvdyB3ZSBqdXN0IHVuc3Vic2NyaWJlZC5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLl9zdWJzY3JpYmVDYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZG9jLl9zdWJzY3JpYmVDYWxsYmFja3NbaV0oJ0RvY3VtZW50IGRlc3Ryb3llZCcpO1xuICAgICAgfVxuICAgICAgZG9jLl9zdWJzY3JpYmVDYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICB9LCAwKTtcblxuICAgIGRvYy5jb25uZWN0aW9uLl9kZXN0cm95RG9jKGRvYyk7XG4gICAgZG9jLnJlbW92ZUNvbnRleHRzKCk7XG4gICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuICB9KTtcbn07XG5cblxuLy8gKioqKioqIE1hbmlwdWxhdGluZyB0aGUgZG9jdW1lbnQgc25hcHNob3QsIHZlcnNpb24gYW5kIHR5cGUuXG5cbi8vIFNldCB0aGUgZG9jdW1lbnQncyB0eXBlLCBhbmQgYXNzb2NpYXRlZCBwcm9wZXJ0aWVzLiBNb3N0IG9mIHRoZSBsb2dpYyBpblxuLy8gdGhpcyBmdW5jdGlvbiBleGlzdHMgdG8gdXBkYXRlIHRoZSBkb2N1bWVudCBiYXNlZCBvbiBhbnkgYWRkZWQgJiByZW1vdmVkIEFQSVxuLy8gbWV0aG9kcy5cbkRvYy5wcm90b3R5cGUuX3NldFR5cGUgPSBmdW5jdGlvbihuZXdUeXBlKSB7XG4gIGlmICh0eXBlb2YgbmV3VHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoIXR5cGVzW25ld1R5cGVdKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHR5cGUgXCIgKyBuZXdUeXBlKTtcbiAgICBuZXdUeXBlID0gdHlwZXNbbmV3VHlwZV07XG4gIH1cbiAgdGhpcy5yZW1vdmVDb250ZXh0cygpO1xuXG4gIC8vIFNldCB0aGUgbmV3IHR5cGVcbiAgdGhpcy50eXBlID0gbmV3VHlwZTtcblxuICAvLyBJZiB3ZSByZW1vdmVkIHRoZSB0eXBlIGZyb20gdGhlIG9iamVjdCwgYWxzbyByZW1vdmUgaXRzIHNuYXBzaG90LlxuICBpZiAoIW5ld1R5cGUpIHtcbiAgICB0aGlzLnByb3ZpZGVzID0ge307XG4gIH0gZWxzZSBpZiAobmV3VHlwZS5hcGkpIHtcbiAgICAvLyBSZWdpc3RlciB0aGUgbmV3IHR5cGUncyBBUEkuXG4gICAgdGhpcy5wcm92aWRlcyA9IG5ld1R5cGUuYXBpLnByb3ZpZGVzO1xuICB9XG59O1xuXG4vLyBJbmplc3Qgc25hcHNob3QgZGF0YS4gVGhpcyBkYXRhIG11c3QgaW5jbHVkZSBhIHZlcnNpb24sIHNuYXBzaG90IGFuZCB0eXBlLlxuLy8gVGhpcyBpcyB1c2VkIGJvdGggdG8gaW5qZXN0IGRhdGEgdGhhdCB3YXMgZXhwb3J0ZWQgd2l0aCBhIHdlYnBhZ2UgYW5kIGRhdGFcbi8vIHRoYXQgd2FzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciBkdXJpbmcgYSBmZXRjaC5cbkRvYy5wcm90b3R5cGUuaW5qZXN0RGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgaWYgKHRoaXMuc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpIGNvbnNvbGUud2FybignSWdub3JpbmcgYXR0ZW1wdCB0byBpbmplc3QgZGF0YSBpbiBzdGF0ZScsIHRoaXMuc3RhdGUpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIGRhdGEudiAhPT0gJ251bWJlcicpIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB2ZXJzaW9uIGluIGluamVzdGVkIGRhdGEnKTtcblxuXG4gIHRoaXMudmVyc2lvbiA9IGRhdGEudjtcbiAgLy8gZGF0YS5kYXRhIGlzIHdoYXQgdGhlIHNlcnZlciB3aWxsIGFjdHVhbGx5IHNlbmQuIGRhdGEuc25hcHNob3QgaXMgdGhlIG9sZFxuICAvLyBmaWVsZCBuYW1lIC0gc3VwcG9ydGVkIG5vdyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gIHRoaXMuc25hcHNob3QgPSBkYXRhLmRhdGEgfHwgZGF0YS5zbmFwc2hvdDtcbiAgdGhpcy5fc2V0VHlwZShkYXRhLnR5cGUpO1xuXG4gIHRoaXMuc3RhdGUgPSAncmVhZHknO1xuICB0aGlzLmVtaXQoJ3JlYWR5Jyk7XG59O1xuXG4vLyBHZXQgYW5kIHJldHVybiB0aGUgY3VycmVudCBkb2N1bWVudCBzbmFwc2hvdC5cbkRvYy5wcm90b3R5cGUuZ2V0U25hcHNob3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuc25hcHNob3Q7XG59O1xuXG4vLyBUaGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYXQgYSB0aW1lIHdoZW4gdGhlIGRvY3VtZW50IGhhcyBhIHNuYXBzaG90IGFuZFxuLy8geW91IGNhbiBzdGFydCBhcHBseWluZyBvcGVyYXRpb25zLiBUaGlzIG1heSBiZSBpbW1lZGlhdGVseS5cbkRvYy5wcm90b3R5cGUud2hlblJlYWR5ID0gZnVuY3Rpb24oZm4pIHtcbiAgaWYgKHRoaXMuc3RhdGUgPT09ICdyZWFkeScpIHtcbiAgICBmbigpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub24oJ3JlYWR5JywgZm4pO1xuICB9XG59O1xuXG5Eb2MucHJvdG90eXBlLmhhc1BlbmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuaW5mbGlnaHREYXRhICE9IG51bGwgfHwgISF0aGlzLnBlbmRpbmdEYXRhLmxlbmd0aDtcbn07XG5cblxuLy8gKioqKiBIZWxwZXJzIGZvciBuZXR3b3JrIG1lc3NhZ2VzXG5cbi8vIFNlbmQgYSBtZXNzYWdlIHRvIHRoZSBjb25uZWN0aW9uIGZyb20gdGhpcyBkb2N1bWVudC5cbkRvYy5wcm90b3R5cGUuX3NlbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIG1lc3NhZ2UuYyA9IHRoaXMuY29sbGVjdGlvbjtcbiAgbWVzc2FnZS5kID0gdGhpcy5uYW1lO1xuICB0aGlzLmNvbm5lY3Rpb24uc2VuZChtZXNzYWdlKTtcbn07XG5cbi8vIFRoaXMgZnVuY3Rpb24gZXhpc3RzIHNvIGNvbm5lY3Rpb24gY2FuIGNhbGwgaXQgZGlyZWN0bHkgZm9yIGJ1bGsgc3Vic2NyaWJlcy5cbi8vIEl0IGNvdWxkIGp1c3QgbWFrZSBhIHRlbXBvcmFyeSBvYmplY3QgbGl0ZXJhbCwgdGhhdHMgcHJldHR5IHNsb3cuXG5Eb2MucHJvdG90eXBlLl9oYW5kbGVTdWJzY3JpYmUgPSBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgaWYgKGVyciAmJiBlcnIgIT09ICdBbHJlYWR5IHN1YnNjcmliZWQnKSB7XG4gICAgaWYgKGNvbnNvbGUpIGNvbnNvbGUuZXJyb3IoXCJDb3VsZCBub3Qgc3Vic2NyaWJlOiBcIiArIGVycik7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgLy8gVGhlcmUncyBwcm9iYWJseSBhIHJlYXNvbiB3ZSBjb3VsZG4ndCBzdWJzY3JpYmUuIERvbid0IHJldHJ5LlxuICAgIHRoaXMuX3NldFdhbnRTdWJzY3JpYmUoZmFsc2UsIG51bGwsIGVycilcbiAgfSBlbHNlIHtcbiAgICBpZiAoZGF0YSkgdGhpcy5pbmplc3REYXRhKGRhdGEpO1xuICAgIHRoaXMuc3Vic2NyaWJlZCA9IHRydWU7XG4gICAgdGhpcy5lbWl0KCdzdWJzY3JpYmUnKTtcbiAgICB0aGlzLl9maW5pc2hTdWIodHJ1ZSk7XG4gIH1cblxuICB0aGlzLl9jbGVhckFjdGlvbignc3Vic2NyaWJlJyk7XG59O1xuXG4vLyBUaGlzIGlzIGNhbGxlZCBieSB0aGUgY29ubmVjdGlvbiB3aGVuIGl0IHJlY2VpdmVzIGEgbWVzc2FnZSBmb3IgdGhlIGRvY3VtZW50LlxuRG9jLnByb3RvdHlwZS5fb25NZXNzYWdlID0gZnVuY3Rpb24obXNnKSB7XG4gIGlmICghKG1zZy5jID09PSB0aGlzLmNvbGxlY3Rpb24gJiYgbXNnLmQgPT09IHRoaXMubmFtZSkpIHtcbiAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4gLSBpdHMgYSBzYW5pdHkgY2hlY2sgZm9yIGJ1Z3MgaW4gdGhlIGNvbm5lY3Rpb24gY29kZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJHb3QgbWVzc2FnZSBmb3Igd3JvbmcgZG9jdW1lbnQuXCIpO1xuICB9XG5cbiAgLy8gbXNnLmEgPSB0aGUgYWN0aW9uLlxuICBzd2l0Y2ggKG1zZy5hKSB7XG4gICAgY2FzZSAnZmV0Y2gnOlxuICAgICAgLy8gV2UncmUgZG9uZSBmZXRjaGluZy4gVGhpcyBtZXNzYWdlIGhhcyBubyBvdGhlciBpbmZvcm1hdGlvbi5cbiAgICAgIGlmIChtc2cuZGF0YSkgdGhpcy5pbmplc3REYXRhKG1zZy5kYXRhKTtcbiAgICAgIHRoaXMuX2ZpbmlzaFN1YignZmV0Y2gnLCBtc2cuZXJyb3IpO1xuICAgICAgaWYgKHRoaXMud2FudFN1YnNjcmliZSA9PT0gJ2ZldGNoJykgdGhpcy53YW50U3Vic2NyaWJlID0gZmFsc2U7XG4gICAgICB0aGlzLl9jbGVhckFjdGlvbignZmV0Y2gnKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc3ViJzpcbiAgICAgIC8vIFN1YnNjcmliZSByZXBseS5cbiAgICAgIHRoaXMuX2hhbmRsZVN1YnNjcmliZShtc2cuZXJyb3IsIG1zZy5kYXRhKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndW5zdWInOlxuICAgICAgLy8gVW5zdWJzY3JpYmUgcmVwbHlcbiAgICAgIHRoaXMuc3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5lbWl0KCd1bnN1YnNjcmliZScpO1xuXG4gICAgICB0aGlzLl9maW5pc2hTdWIoZmFsc2UsIG1zZy5lcnJvcik7XG4gICAgICB0aGlzLl9jbGVhckFjdGlvbigndW5zdWJzY3JpYmUnKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYWNrJzpcbiAgICAgIC8vIEFja25vd2xlZGdlIGEgbG9jYWxseSBzdWJtaXR0ZWQgb3BlcmF0aW9uLlxuICAgICAgLy9cbiAgICAgIC8vIFVzdWFsbHkgd2UgZG8gbm90aGluZyBoZXJlIC0gYWxsIHRoZSBpbnRlcmVzdGluZyBsb2dpYyBoYXBwZW5zIHdoZW4gd2VcbiAgICAgIC8vIGdldCBzZW50IG91ciBvcCBiYWNrIGluIHRoZSBvcCBzdHJlYW0gKHdoaWNoIGhhcHBlbnMgZXZlbiBpZiB3ZSBhcmVuJ3RcbiAgICAgIC8vIHN1YnNjcmliZWQpLiBIb3dldmVyLCBpZiB0aGUgb3AgZG9lc24ndCBnZXQgYWNjZXB0ZWQsIHdlIHN0aWxsIG5lZWQgdG9cbiAgICAgIC8vIGNsZWFyIHNvbWUgc3RhdGUuXG4gICAgICAvL1xuICAgICAgLy8gSWYgdGhlIG1lc3NhZ2UgZXJyb3IgaXMgJ09wIGFscmVhZHkgc3VibWl0dGVkJywgdGhhdCBtZWFucyB3ZSd2ZVxuICAgICAgLy8gcmVzZW50IGFuIG9wIHRoYXQgdGhlIHNlcnZlciBhbHJlYWR5IGdvdC4gSXQgd2lsbCBhbHNvIGJlIGNvbmZpcm1lZFxuICAgICAgLy8gbm9ybWFsbHkuXG4gICAgICBpZiAobXNnLmVycm9yICYmIG1zZy5lcnJvciAhPT0gJ09wIGFscmVhZHkgc3VibWl0dGVkJykge1xuICAgICAgICAvLyBUaGUgc2VydmVyIGhhcyByZWplY3RlZCBhbiBvcCBmcm9tIHRoZSBjbGllbnQgZm9yIHNvbWUgcmVhc29uLlxuICAgICAgICAvLyBXZSdsbCBzZW5kIHRoZSBlcnJvciBtZXNzYWdlIHRvIHRoZSB1c2VyIGFuZCB0cnkgdG8gcm9sbCBiYWNrIHRoZSBjaGFuZ2UuXG4gICAgICAgIGlmICh0aGlzLmluZmxpZ2h0RGF0YSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignT3BlcmF0aW9uIHdhcyByZWplY3RlZCAoJyArIG1zZy5lcnJvciArICcpLiBUcnlpbmcgdG8gcm9sbGJhY2sgY2hhbmdlIGxvY2FsbHkuJyk7XG4gICAgICAgICAgdGhpcy5fdHJ5Um9sbGJhY2sodGhpcy5pbmZsaWdodERhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEkgbWFuYWdlZCB0byBnZXQgaW50byB0aGlzIHN0YXRlIG9uY2UuIEknbSBub3Qgc3VyZSBob3cgaXQgaGFwcGVuZWQuXG4gICAgICAgICAgLy8gVGhlIG9wIHdhcyBtYXliZSBkb3VibGUtYWNrbm93bGVkZ2VkP1xuICAgICAgICAgIGlmIChjb25zb2xlKSBjb25zb2xlLndhcm4oJ1NlY29uZCBhY2tub3dsZWRnZW1lbnQgbWVzc2FnZSAoZXJyb3IpIHJlY2VpdmVkJywgbXNnLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICB0aGlzLl9jbGVhckluZmxpZ2h0T3AobXNnLmVycm9yKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnb3AnOlxuICAgICAgaWYgKHRoaXMuaW5mbGlnaHREYXRhICYmXG4gICAgICAgICAgbXNnLnNyYyA9PT0gdGhpcy5pbmZsaWdodERhdGEuc3JjICYmXG4gICAgICAgICAgbXNnLnNlcSA9PT0gdGhpcy5pbmZsaWdodERhdGEuc2VxKSB7XG4gICAgICAgIC8vIFRoaXMgb25lIGlzIG1pbmUuIEFjY2VwdCBpdCBhcyBhY2tub3dsZWRnZWQuXG4gICAgICAgIHRoaXMuX29wQWNrbm93bGVkZ2VkKG1zZyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAobXNnLnYgIT09IHRoaXMudmVyc2lvbikge1xuICAgICAgICAvLyBUaGlzIHdpbGwgaGFwcGVuIG5hdHVyYWxseSBpbiB0aGUgZm9sbG93aW5nIChvciBzaW1pbGFyKSBjYXNlczpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gQ2xpZW50IGlzIG5vdCBzdWJzY3JpYmVkIHRvIGRvY3VtZW50LlxuICAgICAgICAvLyAtPiBjbGllbnQgc3VibWl0cyBhbiBvcGVyYXRpb24gKHY9MTApXG4gICAgICAgIC8vIC0+IGNsaWVudCBzdWJzY3JpYmVzIHRvIGEgcXVlcnkgd2hpY2ggbWF0Y2hlcyB0aGlzIGRvY3VtZW50LiBTYXlzIHdlXG4gICAgICAgIC8vICAgIGhhdmUgdj0xMCBvZiB0aGUgZG9jLlxuICAgICAgICAvL1xuICAgICAgICAvLyA8LSBzZXJ2ZXIgYWNrbm93bGVkZ2VzIHRoZSBvcGVyYXRpb24gKHY9MTEpLiBTZXJ2ZXIgYWNrbm93bGVkZ2VzIHRoZVxuICAgICAgICAvLyAgICBvcGVyYXRpb24gYmVjYXVzZSB0aGUgZG9jIGlzbid0IHN1YnNjcmliZWRcbiAgICAgICAgLy8gPC0gc2VydmVyIHByb2Nlc3NlcyB0aGUgcXVlcnksIHdoaWNoIHNheXMgdGhlIGNsaWVudCBvbmx5IGhhcyB2PTEwLlxuICAgICAgICAvLyAgICBTZXJ2ZXIgc3Vic2NyaWJlcyBhdCB2PTEwIG5vdCB2PTExLCBzbyB3ZSBnZXQgYW5vdGhlciBjb3B5IG9mIHRoZVxuICAgICAgICAvLyAgICB2PTEwIG9wZXJhdGlvbi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCB3ZSBjYW4gc2FmZWx5IGlnbm9yZSB0aGUgb2xkIChkdXBsaWNhdGUpIG9wZXJhdGlvbi5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmluZmxpZ2h0RGF0YSkgeGYodGhpcy5pbmZsaWdodERhdGEsIG1zZyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wZW5kaW5nRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB4Zih0aGlzLnBlbmRpbmdEYXRhW2ldLCBtc2cpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnZlcnNpb24rKztcbiAgICAgIHRoaXMuX290QXBwbHkobXNnLCBmYWxzZSk7XG4gICAgICB0aGlzLl9hZnRlck90QXBwbHkobXNnLCBmYWxzZSk7XG4gICAgICAvL2NvbnNvbGUubG9nKCdhcHBsaWVkJywgSlNPTi5zdHJpbmdpZnkobXNnKSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ21ldGEnOlxuICAgICAgaWYgKGNvbnNvbGUpIGNvbnNvbGUud2FybignVW5oYW5kbGVkIG1ldGEgb3A6JywgbXNnKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChjb25zb2xlKSBjb25zb2xlLndhcm4oJ1VuaGFuZGxlZCBkb2N1bWVudCBtZXNzYWdlOicsIG1zZyk7XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuLy8gQ2FsbGVkIHdoZW5ldmVyICh5b3UgZ3Vlc3NlZCBpdCEpIHRoZSBjb25uZWN0aW9uIHN0YXRlIGNoYW5nZXMuIFRoaXMgd2lsbFxuLy8gaGFwcGVuIHdoZW4gd2UgZ2V0IGRpc2Nvbm5lY3RlZCAmIHJlY29ubmVjdC5cbkRvYy5wcm90b3R5cGUuX29uQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCA9IGZ1bmN0aW9uKHN0YXRlLCByZWFzb24pIHtcbiAgaWYgKHN0YXRlID09PSAnY29ubmVjdGluZycpIHtcbiAgICBpZiAodGhpcy5pbmZsaWdodERhdGEpIHtcbiAgICAgIHRoaXMuX3NlbmRPcERhdGEoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAvLyBXZSBnbyBpbnRvIHRoZSBjb25uZWN0ZWQgc3RhdGUgb25jZSB3ZSBoYXZlIGEgc2Vzc2lvbklELiBXZSBjYW4ndCBzZW5kXG4gICAgLy8gbmV3IG9wcyB1bnRpbCB0aGVuLCBzbyB3ZSBuZWVkIHRvIGZsdXNoIGFnYWluLlxuICAgIHRoaXMuZmx1c2goKTtcbiAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICB0aGlzLmFjdGlvbiA9IG51bGw7XG4gICAgdGhpcy5zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuc3Vic2NyaWJlZCkgdGhpcy5lbWl0KCd1bnN1YnNjcmliZWQnKTtcbiAgfVxufTtcblxuXG5cblxuLy8gKioqKioqIERlYWxpbmcgd2l0aCBhY3Rpb25zXG5cbkRvYy5wcm90b3R5cGUuX2NsZWFyQWN0aW9uID0gZnVuY3Rpb24oZXhwZWN0ZWRBY3Rpb24pIHtcbiAgaWYgKHRoaXMuYWN0aW9uICE9PSBleHBlY3RlZEFjdGlvbikge1xuICAgIGNvbnNvbGUud2FybignVW5leHBlY3RlZCBhY3Rpb24gJyArIHRoaXMuYWN0aW9uICsgJyBleHBlY3RlZDogJyArIGV4cGVjdGVkQWN0aW9uKTtcbiAgfVxuICB0aGlzLmFjdGlvbiA9IG51bGw7XG4gIHRoaXMuZmx1c2goKTtcbn07XG5cblxuXG4vLyBTZW5kIHRoZSBuZXh0IHBlbmRpbmcgb3AgdG8gdGhlIHNlcnZlciwgaWYgd2UgY2FuLlxuLy9cbi8vIE9ubHkgb25lIG9wZXJhdGlvbiBjYW4gYmUgaW4tZmxpZ2h0IGF0IGEgdGltZS4gSWYgYW4gb3BlcmF0aW9uIGlzIGFscmVhZHkgb25cbi8vIGl0cyB3YXksIG9yIHdlJ3JlIG5vdCBjdXJyZW50bHkgY29ubmVjdGVkLCB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuXG5Eb2MucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5jb25uZWN0aW9uLmNhblNlbmQgfHwgdGhpcy5hY3Rpb24pIHJldHVybjtcblxuICB2YXIgb3BEYXRhO1xuICAvLyBQdW1wIGFuZCBkdW1wIGFueSBuby1vcHMgZnJvbSB0aGUgZnJvbnQgb2YgdGhlIHBlbmRpbmcgb3AgbGlzdC5cbiAgd2hpbGUgKHRoaXMucGVuZGluZ0RhdGEubGVuZ3RoICYmIGlzTm9PcChvcERhdGEgPSB0aGlzLnBlbmRpbmdEYXRhWzBdKSkge1xuICAgIHZhciBjYWxsYmFja3MgPSBvcERhdGEuY2FsbGJhY2tzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjYWxsYmFja3NbaV0ob3BEYXRhLmVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5wZW5kaW5nRGF0YS5zaGlmdCgpO1xuICB9XG5cbiAgLy8gRmlyc3QgY29uc2lkZXIgY2hhbmdpbmcgc3RhdGVcbiAgaWYgKHRoaXMuc3Vic2NyaWJlZCAmJiAhdGhpcy53YW50U3Vic2NyaWJlKSB7XG4gICAgdGhpcy5hY3Rpb24gPSAndW5zdWJzY3JpYmUnO1xuICAgIHRoaXMuX3NlbmQoe2E6J3Vuc3ViJ30pO1xuICB9IGVsc2UgaWYgKCF0aGlzLnN1YnNjcmliZWQgJiYgdGhpcy53YW50U3Vic2NyaWJlID09PSAnZmV0Y2gnKSB7XG4gICAgdGhpcy5hY3Rpb24gPSAnZmV0Y2gnO1xuICAgIHRoaXMuX3NlbmQodGhpcy5zdGF0ZSA9PT0gJ3JlYWR5JyA/IHthOidmZXRjaCcsIHY6dGhpcy52ZXJzaW9ufSA6IHthOidmZXRjaCd9KTtcbiAgfSBlbHNlIGlmICghdGhpcy5zdWJzY3JpYmVkICYmIHRoaXMud2FudFN1YnNjcmliZSkge1xuICAgIHRoaXMuYWN0aW9uID0gJ3N1YnNjcmliZSc7XG4gICAgLy8gU3BlY2lhbCBzZW5kIG1ldGhvZCBuZWVkZWQgZm9yIGJ1bGsgc3Vic2NyaWJlcyBvbiByZWNvbm5lY3QuXG4gICAgdGhpcy5jb25uZWN0aW9uLnNlbmRTdWJzY3JpYmUodGhpcy5jb2xsZWN0aW9uLCB0aGlzLm5hbWUsIHRoaXMuc3RhdGUgPT09ICdyZWFkeScgPyB0aGlzLnZlcnNpb24gOiBudWxsKTtcbiAgfSBlbHNlIGlmICghdGhpcy5wYXVzZWQgJiYgdGhpcy5wZW5kaW5nRGF0YS5sZW5ndGggJiYgdGhpcy5jb25uZWN0aW9uLnN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgIC8vIFRyeSBhbmQgc2VuZCBhbnkgcGVuZGluZyBvcHMuIFdlIGNhbid0IHNlbmQgb3BzIHdoaWxlIGluIFxuICAgIHRoaXMuaW5mbGlnaHREYXRhID0gdGhpcy5wZW5kaW5nRGF0YS5zaGlmdCgpO1xuXG4gICAgLy8gRGVsYXkgZm9yIGRlYnVnZ2luZy5cbiAgICAvL3ZhciB0aGF0ID0gdGhpcztcbiAgICAvL3NldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRoYXQuX3NlbmRPcERhdGEoKTsgfSwgMTAwMCk7XG5cbiAgICAvLyBUaGlzIGFsc28gc2V0cyBhY3Rpb24gdG8gJ3N1Ym1pdCcuXG4gICAgdGhpcy5fc2VuZE9wRGF0YSgpO1xuICB9XG59O1xuXG5cbi8vICoqKioqKiBTdWJzY3JpYmluZywgdW5zdWJzY3JpYmluZyBhbmQgZmV0Y2hpbmdcblxuLy8gVGhlc2UgZnVuY3Rpb25zIGlhcmUgY29waWVkIGludG8gdGhlIHF1ZXJ5IGNsYXNzIGFzIHdlbGwsIHNvIGJlIGNhcmVmdWwgbWFraW5nXG4vLyBjaGFuZ2VzIGhlcmUuXG5cbi8vIFZhbHVlIGlzIHRydWUsIGZhbHNlIG9yICdmZXRjaCcuXG5Eb2MucHJvdG90eXBlLl9zZXRXYW50U3Vic2NyaWJlID0gZnVuY3Rpb24odmFsdWUsIGNhbGxiYWNrLCBlcnIpIHtcbiAgaWYgKHRoaXMuc3Vic2NyaWJlZCA9PT0gdGhpcy53YW50U3Vic2NyaWJlICYmXG4gICAgICAodGhpcy5zdWJzY3JpYmVkID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ2ZldGNoJyAmJiB0aGlzLnN1YnNjcmliZWQpKSB7XG4gICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIpO1xuICAgIHJldHVybjtcbiAgfVxuICBcbiAgaWYgKCF0aGlzLndhbnRTdWJzY3JpYmUgIT09ICF2YWx1ZSkge1xuICAgIC8vIENhbGwgYWxsIHRoZSBjdXJyZW50IHN1YnNjcmliZS91bnN1YnNjcmliZSBjYWxsYmFja3MuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zdWJzY3JpYmVDYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIFNob3VsZCBJIHJldHVybiBhbiBlcnJvciBoZXJlPyBXaGF0IGhhcHBlbmVkIGlzIHRoZSB1c2VyIHVuc3ViY3JpYmVkXG4gICAgICAvLyB3aXRoIGEgY2FsbGJhY2sgdGhlbiByZXN1YnNjcmliZWQgc3RyYWlnaHQgYWZ0ZXIuIERvZXMgdGhhdCBtZWFuIHRoZVxuICAgICAgLy8gdW5zdWJzY3JpYmUgZmFpbGVkP1xuICAgICAgdGhpcy5fc3Vic2NyaWJlQ2FsbGJhY2tzW2ldKGVycik7XG4gICAgfVxuICAgIHRoaXMuX3N1YnNjcmliZUNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgLy8gSWYgd2Ugd2FudCB0byBzdWJzY3JpYmUsIGRvbid0IHdlYWtlbiBpdCB0byBhIGZldGNoLlxuICBpZiAodmFsdWUgIT09ICdmZXRjaCcgfHwgdGhpcy53YW50U3Vic2NyaWJlICE9PSB0cnVlKVxuICAgIHRoaXMud2FudFN1YnNjcmliZSA9IHZhbHVlO1xuXG4gIGlmIChjYWxsYmFjaykgdGhpcy5fc3Vic2NyaWJlQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICB0aGlzLmZsdXNoKCk7XG59O1xuXG4vLyBPcGVuIHRoZSBkb2N1bWVudC4gVGhlcmUgaXMgbm8gY2FsbGJhY2sgYW5kIG5vIGVycm9yIGhhbmRsaW5nIGlmIHlvdSdyZVxuLy8gYWxyZWFkeSBjb25uZWN0ZWQuXG4vL1xuLy8gT25seSBjYWxsIHRoaXMgb25jZSBwZXIgZG9jdW1lbnQuXG5Eb2MucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHRoaXMuX3NldFdhbnRTdWJzY3JpYmUodHJ1ZSwgY2FsbGJhY2spO1xufTtcblxuLy8gVW5zdWJzY3JpYmUuIFRoZSBkYXRhIHdpbGwgc3RheSBhcm91bmQgaW4gbG9jYWwgbWVtb3J5LCBidXQgd2UnbGwgc3RvcFxuLy8gcmVjZWl2aW5nIHVwZGF0ZXMuXG5Eb2MucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdGhpcy5fc2V0V2FudFN1YnNjcmliZShmYWxzZSwgY2FsbGJhY2spO1xufTtcblxuLy8gQ2FsbCB0byByZXF1ZXN0IGZyZXNoIGRhdGEgZnJvbSB0aGUgc2VydmVyLlxuRG9jLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHRoaXMuX3NldFdhbnRTdWJzY3JpYmUoJ2ZldGNoJywgY2FsbGJhY2spO1xufTtcblxuLy8gQ2FsbGVkIHdoZW4gb3VyIHN1YnNjcmliZSwgZmV0Y2ggb3IgdW5zdWJzY3JpYmUgbWVzc2FnZXMgYXJlIGFja25vd2xlZGdlZC5cbkRvYy5wcm90b3R5cGUuX2ZpbmlzaFN1YiA9IGZ1bmN0aW9uKHZhbHVlLCBlcnJvcikge1xuICBpZiAodmFsdWUgPT09IHRoaXMud2FudFN1YnNjcmliZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc3Vic2NyaWJlQ2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpYmVDYWxsYmFja3NbaV0oZXJyb3IpO1xuICAgIH1cbiAgICB0aGlzLl9zdWJzY3JpYmVDYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgfVxufTtcblxuXG4vLyBPcGVyYXRpb25zXG5cblxuLy8gKioqKioqKioqKioqIERlYWxpbmcgd2l0aCBvcGVyYXRpb25zLlxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gc2V0IG9wRGF0YSB0byBjb250YWluIGEgbm8tb3AuXG52YXIgc2V0Tm9PcCA9IGZ1bmN0aW9uKG9wRGF0YSkge1xuICBkZWxldGUgb3BEYXRhLm9wO1xuICBkZWxldGUgb3BEYXRhLmNyZWF0ZTtcbiAgZGVsZXRlIG9wRGF0YS5kZWw7XG59O1xuXG52YXIgaXNOb09wID0gZnVuY3Rpb24ob3BEYXRhKSB7XG4gIHJldHVybiAhb3BEYXRhLm9wICYmICFvcERhdGEuY3JlYXRlICYmICFvcERhdGEuZGVsO1xufVxuXG4vLyBUcnkgdG8gY29tcG9zZSBkYXRhMiBpbnRvIGRhdGExLiBSZXR1cm5zIHRydXRoeSBpZiBpdCBzdWNjZWVkcywgb3RoZXJ3aXNlIGZhbHN5LlxudmFyIHRyeUNvbXBvc2UgPSBmdW5jdGlvbih0eXBlLCBkYXRhMSwgZGF0YTIpIHtcbiAgaWYgKGRhdGExLmNyZWF0ZSAmJiBkYXRhMi5kZWwpIHtcbiAgICBzZXROb09wKGRhdGExKTtcbiAgfSBlbHNlIGlmIChkYXRhMS5jcmVhdGUgJiYgZGF0YTIub3ApIHtcbiAgICAvLyBDb21wb3NlIHRoZSBkYXRhIGludG8gdGhlIGNyZWF0ZSBkYXRhLlxuICAgIHZhciBkYXRhID0gKGRhdGExLmNyZWF0ZS5kYXRhID09PSB1bmRlZmluZWQpID8gdHlwZS5jcmVhdGUoKSA6IGRhdGExLmNyZWF0ZS5kYXRhO1xuICAgIGRhdGExLmNyZWF0ZS5kYXRhID0gdHlwZS5hcHBseShkYXRhLCBkYXRhMi5vcCk7XG4gIH0gZWxzZSBpZiAoaXNOb09wKGRhdGExKSkge1xuICAgIGRhdGExLmNyZWF0ZSA9IGRhdGEyLmNyZWF0ZTtcbiAgICBkYXRhMS5kZWwgPSBkYXRhMi5kZWw7XG4gICAgZGF0YTEub3AgPSBkYXRhMi5vcDtcbiAgfSBlbHNlIGlmIChkYXRhMS5vcCAmJiBkYXRhMi5vcCAmJiB0eXBlLmNvbXBvc2UpIHtcbiAgICBkYXRhMS5vcCA9IHR5cGUuY29tcG9zZShkYXRhMS5vcCwgZGF0YTIub3ApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIFRyYW5zZm9ybSBzZXJ2ZXIgb3AgZGF0YSBieSBhIGNsaWVudCBvcCwgYW5kIHZpY2UgdmVyc2EuIE9wcyBhcmUgZWRpdGVkIGluIHBsYWNlLlxudmFyIHhmID0gZnVuY3Rpb24oY2xpZW50LCBzZXJ2ZXIpIHtcbiAgLy8gSW4gdGhpcyBjYXNlLCB3ZSdyZSBpbiBmb3Igc29tZSBmdW4uIFRoZXJlIGFyZSBzb21lIGxvY2FsIG9wZXJhdGlvbnNcbiAgLy8gd2hpY2ggYXJlIHRvdGFsbHkgaW52YWxpZCAtIGVpdGhlciB0aGUgY2xpZW50IGNvbnRpbnVlZCBlZGl0aW5nIGFcbiAgLy8gZG9jdW1lbnQgdGhhdCBzb21lb25lIGVsc2UgZGVsZXRlZCBvciBhIGRvY3VtZW50IHdhcyBjcmVhdGVkIGJvdGggb24gdGhlXG4gIC8vIGNsaWVudCBhbmQgb24gdGhlIHNlcnZlci4gSW4gZWl0aGVyIGNhc2UsIHRoZSBsb2NhbCBkb2N1bWVudCBpcyB3YXlcbiAgLy8gaW52YWxpZCBhbmQgdGhlIGNsaWVudCdzIG9wcyBhcmUgdXNlbGVzcy5cbiAgLy9cbiAgLy8gVGhlIGNsaWVudCBiZWNvbWVzIGEgbm8tb3AsIGFuZCB3ZSBrZWVwIHRoZSBzZXJ2ZXIgb3AgZW50aXJlbHkuXG4gIGlmIChzZXJ2ZXIuY3JlYXRlIHx8IHNlcnZlci5kZWwpIHJldHVybiBzZXROb09wKGNsaWVudCk7XG4gIGlmIChjbGllbnQuY3JlYXRlKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUuIFRoaXMgaXMgYSBidWcuJyk7XG5cbiAgLy8gVGhlIGNsaWVudCBoYXMgZGVsZXRlZCB0aGUgZG9jdW1lbnQgd2hpbGUgdGhlIHNlcnZlciBlZGl0ZWQgaXQuIEtpbGwgdGhlXG4gIC8vIHNlcnZlcidzIG9wLlxuICBpZiAoY2xpZW50LmRlbCkgcmV0dXJuIHNldE5vT3Aoc2VydmVyKTtcblxuICAvLyBXZSBvbmx5IGdldCBoZXJlIGlmIGVpdGhlciB0aGUgc2VydmVyIG9yIGNsaWVudCBvcHMgYXJlIG5vLW9wLiBDYXJyeSBvbixcbiAgLy8gbm90aGluZyB0byBzZWUgaGVyZS5cbiAgaWYgKCFzZXJ2ZXIub3AgfHwgIWNsaWVudC5vcCkgcmV0dXJuO1xuXG4gIC8vIFRoZXkgYm90aCBlZGl0ZWQgdGhlIGRvY3VtZW50LiBUaGlzIGlzIHRoZSBub3JtYWwgY2FzZSBmb3IgdGhpcyBmdW5jdGlvbiAtXG4gIC8vIGFzIGluLCBtb3N0IG9mIHRoZSB0aW1lIHdlJ2xsIGVuZCB1cCBkb3duIGhlcmUuXG4gIC8vXG4gIC8vIFlvdSBzaG91bGQgYmUgd29uZGVyaW5nIHdoeSBJJ20gdXNpbmcgY2xpZW50LnR5cGUgaW5zdGVhZCBvZiB0aGlzLnR5cGUuXG4gIC8vIFRoZSByZWFzb24gaXMsIGlmIHdlIGdldCBvcHMgYXQgYW4gb2xkIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50LCB0aGlzLnR5cGVcbiAgLy8gbWlnaHQgYmUgdW5kZWZpbmVkIG9yIGEgdG90YWxseSBkaWZmZXJlbnQgdHlwZS4gQnkgcGlubmluZyB0aGUgdHlwZSB0byB0aGVcbiAgLy8gb3AgZGF0YSwgd2UgbWFrZSBzdXJlIHRoZSByaWdodCB0eXBlIGhhcyBpdHMgdHJhbnNmb3JtIGZ1bmN0aW9uIGNhbGxlZC5cbiAgaWYgKGNsaWVudC50eXBlLnRyYW5zZm9ybVgpIHtcbiAgICB2YXIgcmVzdWx0ID0gY2xpZW50LnR5cGUudHJhbnNmb3JtWChjbGllbnQub3AsIHNlcnZlci5vcCk7XG4gICAgY2xpZW50Lm9wID0gcmVzdWx0WzBdO1xuICAgIHNlcnZlci5vcCA9IHJlc3VsdFsxXTtcbiAgfSBlbHNlIHtcbiAgICAvL2NvbnNvbGUubG9nKCd4ZicsIEpTT04uc3RyaW5naWZ5KGNsaWVudC5vcCksIEpTT04uc3RyaW5naWZ5KHNlcnZlci5vcCkpO1xuICAgIHZhciBfYyA9IGNsaWVudC50eXBlLnRyYW5zZm9ybShjbGllbnQub3AsIHNlcnZlci5vcCwgJ2xlZnQnKTtcbiAgICB2YXIgX3MgPSBjbGllbnQudHlwZS50cmFuc2Zvcm0oc2VydmVyLm9wLCBjbGllbnQub3AsICdyaWdodCcpO1xuICAgIGNsaWVudC5vcCA9IF9jOyBzZXJ2ZXIub3AgPSBfcztcbiAgICAvL2NvbnNvbGUubG9nKCctPicsIEpTT04uc3RyaW5naWZ5KGNsaWVudC5vcCksIEpTT04uc3RyaW5naWZ5KHNlcnZlci5vcCkpO1xuICB9XG59O1xuXG4vLyBJbnRlcm5hbCBtZXRob2QgdG8gYWN0dWFsbHkgYXBwbHkgdGhlIGdpdmVuIG9wIGRhdGEgdG8gb3VyIGxvY2FsIG1vZGVsLlxuLy9cbi8vIF9hZnRlck90QXBwbHkoKSBzaG91bGQgYWx3YXlzIGJlIGNhbGxlZCBzeW5jaHJvbm91c2x5IGFmdGVyd2FyZHMuXG5Eb2MucHJvdG90eXBlLl9vdEFwcGx5ID0gZnVuY3Rpb24ob3BEYXRhLCBjb250ZXh0KSB7XG4gIC8vIExvY2sgdGhlIGRvY3VtZW50LiBOb2JvZHkgaXMgYWxsb3dlZCB0byBjYWxsIHN1Ym1pdE9wKCkgdW50aWwgX2FmdGVyT3RBcHBseSBpcyBjYWxsZWQuXG4gIHRoaXMubG9ja2VkID0gdHJ1ZTtcblxuICBpZiAob3BEYXRhLmNyZWF0ZSkge1xuICAgIC8vIElmIHRoZSB0eXBlIGlzIGN1cnJlbnRseSBzZXQsIGl0IG1lYW5zIHdlIHRyaWVkIGNyZWF0aW5nIHRoZSBkb2N1bWVudFxuICAgIC8vIGFuZCBzb21lb25lIGVsc2Ugd29uLiBjbGllbnQgY3JlYXRlIHggc2VydmVyIGNyZWF0ZSA9IHNlcnZlciBjcmVhdGUuXG4gICAgdmFyIGNyZWF0ZSA9IG9wRGF0YS5jcmVhdGU7XG4gICAgdGhpcy5fc2V0VHlwZShjcmVhdGUudHlwZSk7XG4gICAgdGhpcy5zbmFwc2hvdCA9IHRoaXMudHlwZS5jcmVhdGUoY3JlYXRlLmRhdGEpO1xuXG4gICAgLy8gVGhpcyBpcyBhIGJpdCBoZWF2eXdlaWdodCwgYnV0IEkgd2FudCB0aGUgY3JlYXRlZCBldmVudCB0byBmaXJlIG91dHNpZGUgb2YgdGhlIGxvY2suXG4gICAgdGhpcy5vbmNlKCd1bmxvY2snLCBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZW1pdCgnY3JlYXRlJywgY29udGV4dCk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAob3BEYXRhLmRlbCkge1xuICAgIC8vIFRoZSB0eXBlIHNob3VsZCBhbHdheXMgZXhpc3QgaW4gdGhpcyBjYXNlLiBkZWwgeCBfID0gZGVsXG4gICAgdmFyIG9sZFNuYXBzaG90ID0gdGhpcy5zbmFwc2hvdDtcbiAgICB0aGlzLl9zZXRUeXBlKG51bGwpO1xuICAgIHRoaXMub25jZSgndW5sb2NrJywgZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmVtaXQoJ2RlbCcsIGNvbnRleHQsIG9sZFNuYXBzaG90KTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChvcERhdGEub3ApIHtcbiAgICBpZiAoIXRoaXMudHlwZSkgdGhyb3cgbmV3IEVycm9yKCdEb2N1bWVudCBkb2VzIG5vdCBleGlzdCcpO1xuXG4gICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICB2YXIgb3AgPSBvcERhdGEub3A7XG4gICAgXG4gICAgLy8gVGhlIGNvbnRleHQgbmVlZHMgdG8gYmUgdG9sZCB3ZSdyZSBhYm91dCB0byBlZGl0LCBqdXN0IGluIGNhc2UgaXQgbmVlZHNcbiAgICAvLyB0byBzdG9yZSBhbnkgZXh0cmEgZGF0YS4gKHRleHQtdHAyIGhhcyB0aGlzIGNvbnN0cmFpbnQuKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5lZGl0aW5nQ29udGV4dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gdGhpcy5lZGl0aW5nQ29udGV4dHNbaV07XG4gICAgICBpZiAoYyAhPSBjb250ZXh0ICYmIGMuX2JlZm9yZU9wKSBjLl9iZWZvcmVPcChvcERhdGEub3ApO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnYmVmb3JlIG9wJywgb3AsIGNvbnRleHQpO1xuXG4gICAgLy8gVGhpcyBleGlzdHMgc28gY2xpZW50cyBjYW4gcHVsbCBhbnkgbmVjZXNzYXJ5IGRhdGEgb3V0IG9mIHRoZSBzbmFwc2hvdFxuICAgIC8vIGJlZm9yZSBpdCBnZXRzIGNoYW5nZWQuICBQcmV2aW91c2x5IHdlIGtlcHQgdGhlIG9sZCBzbmFwc2hvdCBvYmplY3QgYW5kXG4gICAgLy8gcGFzc2VkIGl0IHRvIHRoZSBvcCBldmVudCBoYW5kbGVyLiBIb3dldmVyLCBhcHBseSBubyBsb25nZXIgZ3VhcmFudGVlc1xuICAgIC8vIHRoZSBvbGQgb2JqZWN0IGlzIHN0aWxsIHZhbGlkLlxuICAgIC8vXG4gICAgLy8gQmVjYXVzZSB0aGlzIGNvdWxkIGJlIHRvdGFsbHkgdW5uZWNlc3Nhcnkgd29yaywgaXRzIGJlaGluZCBhIGZsYWcuIHNldFxuICAgIC8vIGRvYy5pbmNyZW1lbnRhbCB0byBlbmFibGUuXG4gICAgaWYgKHRoaXMuaW5jcmVtZW50YWwgJiYgdHlwZS5pbmNyZW1lbnRhbEFwcGx5KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdHlwZS5pbmNyZW1lbnRhbEFwcGx5KHRoaXMuc25hcHNob3QsIG9wLCBmdW5jdGlvbihvLCBzbmFwc2hvdCkge1xuICAgICAgICBfdGhpcy5zbmFwc2hvdCA9IHNuYXBzaG90O1xuICAgICAgICBfdGhpcy5lbWl0KCdvcCcsIG8sIGNvbnRleHQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIG1vc3QgY29tbW9uIGNhc2UsIHNpbXBseSBhcHBseWluZyB0aGUgb3BlcmF0aW9uIHRvIHRoZSBsb2NhbCBzbmFwc2hvdC5cbiAgICAgIHRoaXMuc25hcHNob3QgPSB0eXBlLmFwcGx5KHRoaXMuc25hcHNob3QsIG9wKTtcbiAgICAgIHRoaXMuZW1pdCgnb3AnLCBvcCwgY29udGV4dCk7XG4gICAgfVxuICB9XG4gIC8vIEl0cyBwb3NzaWJsZSBmb3Igbm9uZSBvZiB0aGUgYWJvdmUgY2FzZXMgdG8gbWF0Y2gsIGluIHdoaWNoIGNhc2UgdGhlIG9wIGlzXG4gIC8vIGEgbm8tb3AuIFRoaXMgd2lsbCBoYXBwZW4gd2hlbiBhIGRvY3VtZW50IGhhcyBiZWVuIGRlbGV0ZWQgbG9jYWxseSBhbmRcbiAgLy8gcmVtb3RlIG9wcyBlZGl0IHRoZSBkb2N1bWVudC5cbn07XG5cbi8vIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCByaWdodCBhZnRlciBfb3RBcHBseS5cbkRvYy5wcm90b3R5cGUuX2FmdGVyT3RBcHBseSA9IGZ1bmN0aW9uKG9wRGF0YSwgY29udGV4dCkge1xuICB0aGlzLmxvY2tlZCA9IGZhbHNlO1xuICB0aGlzLmVtaXQoJ3VubG9jaycpO1xuICBpZiAob3BEYXRhLm9wKSB7XG4gICAgdmFyIGNvbnRleHRzID0gdGhpcy5lZGl0aW5nQ29udGV4dHM7XG4gICAgLy8gTm90aWZ5IGFsbCB0aGUgY29udGV4dHMgYWJvdXQgdGhlIG9wICh3ZWxsLCBhbGwgdGhlIGNvbnRleHRzIGV4Y2VwdFxuICAgIC8vIHRoZSBvbmUgd2hpY2ggaW5pdGlhdGVkIHRoZSBzdWJtaXQgaW4gdGhlIGZpcnN0IHBsYWNlKS5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRleHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGNvbnRleHRzW2ldO1xuICAgICAgaWYgKGMgIT0gY29udGV4dCAmJiBjLl9vbk9wKSBjLl9vbk9wKG9wRGF0YS5vcCk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGV4dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChjb250ZXh0cy5yZW1vdmUpIGNvbnRleHRzLnNwbGljZShpLS0sIDEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVtaXQoJ2FmdGVyIG9wJywgb3BEYXRhLm9wLCBjb250ZXh0KTtcbiAgfVxufTtcblxuXG5cbi8vICoqKioqIFNlbmRpbmcgb3BlcmF0aW9uc1xuXG5cbi8vIEFjdHVhbGx5IHNlbmQgb3AgZGF0YSB0byB0aGUgc2VydmVyLlxuRG9jLnByb3RvdHlwZS5fc2VuZE9wRGF0YSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZCA9IHRoaXMuaW5mbGlnaHREYXRhO1xuXG4gIGlmICh0aGlzLmFjdGlvbikgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHN0YXRlICcgKyB0aGlzLmFjdGlvbiArICcgZm9yIHNlbmRPcERhdGEnKTtcbiAgdGhpcy5hY3Rpb24gPSAnc3VibWl0JztcblxuICB2YXIgbXNnID0ge2E6J29wJywgdjp0aGlzLnZlcnNpb259O1xuICBpZiAoZC5zcmMpIHtcbiAgICBtc2cuc3JjID0gZC5zcmM7XG4gICAgbXNnLnNlcSA9IGQuc2VxO1xuICB9XG5cbiAgLy8gVGhlIHNlcnZlciBhdXRvZGV0ZWN0cyB0aGlzLlxuICAvL2lmICh0aGlzLnN0YXRlID09PSAndW5zdWJzY3JpYmVkJykgbXNnLmYgPSB0cnVlOyAvLyBmZXRjaCBpbnRlcm1lZGlhdGUgb3BzXG5cbiAgaWYgKGQub3ApIG1zZy5vcCA9IGQub3A7XG4gIGlmIChkLmNyZWF0ZSkgbXNnLmNyZWF0ZSA9IGQuY3JlYXRlO1xuICBpZiAoZC5kZWwpIG1zZy5kZWwgPSBkLmRlbDtcblxuICBtc2cuYyA9IHRoaXMuY29sbGVjdGlvbjtcbiAgbXNnLmQgPSB0aGlzLm5hbWU7XG5cbiAgdGhpcy5jb25uZWN0aW9uLnNlbmRPcChtc2cpO1xuICAgXG4gIC8vIFRoZSBmaXJzdCB0aW1lIHdlIHNlbmQgYW4gb3AsIGl0cyBpZCBhbmQgc2VxdWVuY2UgbnVtYmVyIGlzIGltcGxpY2l0LlxuICBpZiAoIWQuc3JjKSB7XG4gICAgZC5zcmMgPSB0aGlzLmNvbm5lY3Rpb24uaWQ7XG4gICAgZC5zZXEgPSB0aGlzLmNvbm5lY3Rpb24uc2VxKys7XG4gIH1cbn07XG5cblxuLy8gSW50ZXJuYWwgbWV0aG9kIGNhbGxlZCB0byBkbyB0aGUgYWN0dWFsIHdvcmsgZm9yIHN1Ym1pdE9wKCksIGNyZWF0ZSgpIGFuZCBkZWwoKS5cbi8vXG4vLyBjb250ZXh0IGlzIG9wdGlvbmFsLlxuRG9jLnByb3RvdHlwZS5fc3VibWl0T3BEYXRhID0gZnVuY3Rpb24ob3BEYXRhLCBjb250ZXh0LCBjYWxsYmFjaykge1xuICAvL2NvbnNvbGUubG9nKCdzdWJtaXQnLCBKU09OLnN0cmluZ2lmeShvcERhdGEpLCAndj0nLCB0aGlzLnZlcnNpb24pO1xuXG4gIGlmICh0eXBlb2YgY29udGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gY29udGV4dDtcbiAgICBjb250ZXh0ID0gdHJ1ZTsgLy8gVGhlIGRlZmF1bHQgY29udGV4dCBpcyB0cnVlLlxuICB9XG4gIGlmIChjb250ZXh0ID09IG51bGwpIGNvbnRleHQgPSB0cnVlO1xuXG4gIHZhciBlcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZXJyKTtcbiAgICBlbHNlIGlmIChjb25zb2xlKSBjb25zb2xlLndhcm4oJ0ZhaWxlZCBhdHRlbXB0IHRvIHN1Ym1pdE9wOicsIGVycik7XG4gIH07XG5cbiAgaWYgKHRoaXMubG9ja2VkKSB7XG4gICAgcmV0dXJuIGVycm9yKFwiQ2Fubm90IGNhbGwgc3VibWl0T3AgZnJvbSBpbnNpZGUgYW4gJ29wJyBldmVudCBoYW5kbGVyXCIpO1xuICB9XG5cbiAgLy8gVGhlIG9wRGF0YSBjb250YWlucyBlaXRoZXIgb3AsIGNyZWF0ZSwgZGVsZXRlLCBvciBub25lIG9mIHRoZSBhYm92ZSAoYSBuby1vcCkuXG5cbiAgaWYgKG9wRGF0YS5vcCkge1xuICAgIGlmICghdGhpcy50eXBlKSByZXR1cm4gZXJyb3IoJ0RvY3VtZW50IGhhcyBub3QgYmVlbiBjcmVhdGVkJyk7XG5cbiAgICAvLyBUcnkgdG8gbm9ybWFsaXplIHRoZSBvcC4gVGhpcyByZW1vdmVzIHRyYWlsaW5nIHNraXA6MCdzIGFuZCB0aGluZ3MgbGlrZSB0aGF0LlxuICAgIGlmICh0aGlzLnR5cGUubm9ybWFsaXplKSBvcERhdGEub3AgPSB0aGlzLnR5cGUubm9ybWFsaXplKG9wRGF0YS5vcCk7XG4gIH1cblxuICBpZiAoIXRoaXMuc3RhdGUpIHtcbiAgICB0aGlzLnN0YXRlID0gJ2Zsb2F0aW5nJztcbiAgfVxuXG4gIC8vIEFjdHVhbGx5IGFwcGx5IHRoZSBvcGVyYXRpb24gbG9jYWxseS5cbiAgdGhpcy5fb3RBcHBseShvcERhdGEsIGNvbnRleHQpO1xuXG4gIC8vIElmIHRoZSB0eXBlIHN1cHBvcnRzIGNvbXBvc2VzLCB0cnkgdG8gY29tcG9zZSB0aGUgb3BlcmF0aW9uIG9udG8gdGhlIGVuZFxuICAvLyBvZiB0aGUgbGFzdCBwZW5kaW5nIG9wZXJhdGlvbi5cbiAgdmFyIGVudHJ5ID0gdGhpcy5wZW5kaW5nRGF0YVt0aGlzLnBlbmRpbmdEYXRhLmxlbmd0aCAtIDFdO1xuXG4gIGlmICh0aGlzLnBlbmRpbmdEYXRhLmxlbmd0aCAmJlxuICAgICAgKGVudHJ5ID0gdGhpcy5wZW5kaW5nRGF0YVt0aGlzLnBlbmRpbmdEYXRhLmxlbmd0aCAtIDFdLFxuICAgICAgIHRyeUNvbXBvc2UodGhpcy50eXBlLCBlbnRyeSwgb3BEYXRhKSkpIHtcbiAgfSBlbHNlIHtcbiAgICBlbnRyeSA9IG9wRGF0YTtcbiAgICBvcERhdGEudHlwZSA9IHRoaXMudHlwZTtcbiAgICBvcERhdGEuY2FsbGJhY2tzID0gW107XG4gICAgdGhpcy5wZW5kaW5nRGF0YS5wdXNoKG9wRGF0YSk7XG4gIH1cblxuICBpZiAoY2FsbGJhY2spIGVudHJ5LmNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcblxuICB0aGlzLl9hZnRlck90QXBwbHkob3BEYXRhLCBjb250ZXh0KTtcblxuICAvLyBUaGUgY2FsbCB0byBmbHVzaCBpcyBpbiBhIHRpbWVvdXQgc28gaWYgc3VibWl0T3AoKSBpcyBjYWxsZWQgbXVsdGlwbGVcbiAgLy8gdGltZXMgaW4gYSBjbG9zdXJlIGFsbCB0aGUgb3BzIGFyZSBjb21iaW5lZCBiZWZvcmUgYmVpbmcgc2VudCB0byB0aGVcbiAgLy8gc2VydmVyLiBJdCBkb2Vzbid0IG1hdHRlciBpZiBmbHVzaCBpcyBjYWxsZWQgYSBidW5jaCBvZiB0aW1lcy5cbiAgdmFyIF90aGlzID0gdGhpcztcbiAgc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7IF90aGlzLmZsdXNoKCk7IH0pLCAwKTtcbn07XG5cblxuLy8gKioqIENsaWVudCBPVCBlbnRyeXBvaW50cy5cblxuLy8gU3VibWl0IGFuIG9wZXJhdGlvbiB0byB0aGUgZG9jdW1lbnQuIFRoZSBvcCBtdXN0IGJlIHZhbGlkIGdpdmVuIHRoZSBjdXJyZW50IE9UIHR5cGUuXG5Eb2MucHJvdG90eXBlLnN1Ym1pdE9wID0gZnVuY3Rpb24ob3AsIGNvbnRleHQsIGNhbGxiYWNrKSB7XG4gIHRoaXMuX3N1Ym1pdE9wRGF0YSh7b3A6IG9wfSwgY29udGV4dCwgY2FsbGJhY2spO1xufTtcblxuLy8gQ3JlYXRlIHRoZSBkb2N1bWVudCwgd2hpY2ggaW4gU2hhcmVKUyBzZW1hbnRpY3MgbWVhbnMgdG8gc2V0IGl0cyB0eXBlLiBFdmVyeVxuLy8gb2JqZWN0IGltcGxpY2l0bHkgZXhpc3RzIGluIHRoZSBkYXRhYmFzZSBidXQgaGFzIG5vIGRhdGEgYW5kIG5vIHR5cGUuIENyZWF0ZVxuLy8gc2V0cyB0aGUgdHlwZSBvZiB0aGUgb2JqZWN0IGFuZCBjYW4gb3B0aW9uYWxseSBzZXQgc29tZSBpbml0aWFsIGRhdGEgb24gdGhlXG4vLyBvYmplY3QsIGRlcGVuZGluZyBvbiB0aGUgdHlwZS5cbkRvYy5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24odHlwZSwgZGF0YSwgY29udGV4dCwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gU2V0dGluZyB0aGUgY29udGV4dCB0byBiZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaW4gdGhpcyBjYXNlIHNvIF9zdWJtaXRPcERhdGFcbiAgICAvLyBjYW4gaGFuZGxlIHRoZSBkZWZhdWx0IHZhbHVlIHRoaW5nLlxuICAgIGNvbnRleHQgPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHRoaXMudHlwZSkge1xuICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soJ0RvY3VtZW50IGFscmVhZHkgZXhpc3RzJyk7XG4gICAgcmV0dXJuIFxuICB9XG5cbiAgdGhpcy5fc3VibWl0T3BEYXRhKHtjcmVhdGU6IHt0eXBlOnR5cGUsIGRhdGE6ZGF0YX19LCBjb250ZXh0LCBjYWxsYmFjayk7XG59O1xuXG4vLyBEZWxldGUgdGhlIGRvY3VtZW50LiBUaGlzIGNyZWF0ZXMgYW5kIHN1Ym1pdHMgYSBkZWxldGUgb3BlcmF0aW9uIHRvIHRoZVxuLy8gc2VydmVyLiBEZWxldGluZyByZXNldHMgdGhlIG9iamVjdCdzIHR5cGUgdG8gbnVsbCBhbmQgZGVsZXRlcyBpdHMgZGF0YS4gVGhlXG4vLyBkb2N1bWVudCBzdGlsbCBleGlzdHMsIGFuZCBzdGlsbCBoYXMgdGhlIHZlcnNpb24gaXQgdXNlZCB0byBoYXZlIGJlZm9yZSB5b3Vcbi8vIGRlbGV0ZWQgaXQgKHdlbGwsIG9sZCB2ZXJzaW9uICsxKS5cbkRvYy5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24oY29udGV4dCwgY2FsbGJhY2spIHtcbiAgaWYgKCF0aGlzLnR5cGUpIHtcbiAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCdEb2N1bWVudCBkb2VzIG5vdCBleGlzdCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX3N1Ym1pdE9wRGF0YSh7ZGVsOiB0cnVlfSwgY29udGV4dCwgY2FsbGJhY2spO1xufTtcblxuXG4vLyBQYXVzaW5nIHN0b3BzIHRoZSBkb2N1bWVudCBmcm9tIHNlbmRpbmcgYW55IG9wZXJhdGlvbnMgdG8gdGhlIHNlcnZlci5cbkRvYy5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wYXVzZWQgPSB0cnVlO1xufTtcblxuRG9jLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgdGhpcy5mbHVzaCgpO1xufTtcblxuXG4vLyAqKiogUmVjZWl2aW5nIG9wZXJhdGlvbnNcblxuXG4vLyBUaGlzIHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIHNlcnZlciByZWplY3RzIG91ciBvcGVyYXRpb25zIGZvciBzb21lIHJlYXNvbi5cbi8vIFRoZXJlJ3Mgbm90IG11Y2ggd2UgY2FuIGRvIGhlcmUgaWYgdGhlIE9UIHR5cGUgaXMgbm9uaW52ZXJ0YWJsZSwgYnV0IHRoYXRcbi8vIHNob3VsZG4ndCBoYXBwZW4gdG9vIG11Y2ggaW4gcmVhbCBsaWZlIGJlY2F1c2UgcmVhZG9ubHkgZG9jdW1lbnRzIHNob3VsZCBiZVxuLy8gZmxhZ2dlZCBhcyBzdWNoLiAoSSBzaG91bGQgcHJvYmFibHkgZmlndXJlIG91dCBhIGZsYWcgZm9yIHRoYXQpLlxuLy9cbi8vIFRoaXMgZG9lcyBOT1QgZ2V0IGNhbGxlZCBpZiBvdXIgb3AgZmFpbHMgdG8gcmVhY2ggdGhlIHNlcnZlciBmb3Igc29tZSByZWFzb25cbi8vIC0gd2Ugb3B0aW1pc3RpY2FsbHkgYXNzdW1lIGl0J2xsIG1ha2UgaXQgdGhlcmUgZXZlbnR1YWxseS5cbkRvYy5wcm90b3R5cGUuX3RyeVJvbGxiYWNrID0gZnVuY3Rpb24ob3BEYXRhKSB7XG4gIC8vIFRoaXMgaXMgcHJvYmFibHkgaG9ycmlibHkgYnJva2VuLlxuICBpZiAob3BEYXRhLmNyZWF0ZSkge1xuICAgIHRoaXMuX3NldFR5cGUobnVsbCk7XG5cbiAgICAvLyBJIGRvbid0IHRoaW5rIGl0cyBwb3NzaWJsZSB0byBnZXQgaGVyZSBpZiB3ZSBhcmVuJ3QgaW4gYSBmbG9hdGluZyBzdGF0ZS5cbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2Zsb2F0aW5nJylcbiAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgIGVsc2VcbiAgICAgIGNvbnNvbGUud2FybignUm9sbGJhY2sgYSBjcmVhdGUgZnJvbSBzdGF0ZSAnICsgdGhpcy5zdGF0ZSk7XG5cbiAgfSBlbHNlIGlmIChvcERhdGEub3AgJiYgb3BEYXRhLnR5cGUuaW52ZXJ0KSB7XG4gICAgb3BEYXRhLm9wID0gb3BEYXRhLnR5cGUuaW52ZXJ0KG9wRGF0YS5vcCk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gdGhlIHVuZG8gb3BlcmF0aW9uIGJ5IGFueSBwZW5kaW5nIG9wcy5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGVuZGluZ0RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHhmKHRoaXMucGVuZGluZ0RhdGFbaV0sIG9wRGF0YSk7XG4gICAgfVxuXG4gICAgLy8gLi4uIGFuZCBhcHBseSBpdCBsb2NhbGx5LCByZXZlcnRpbmcgdGhlIGNoYW5nZXMuXG4gICAgLy8gXG4gICAgLy8gVGhpcyBvcGVyYXRpb24gaXMgYXBwbGllZCB0byBsb29rIGxpa2UgaXQgY29tZXMgZnJvbSBhIHJlbW90ZSBjb250ZXh0LlxuICAgIC8vIEknbSBzdGlsbCBub3QgMTAwJSBzdXJlIGFib3V0IHRoaXMgZnVuY3Rpb25hbGl0eSwgYmVjYXVzZSBpdHMgcmVhbGx5IGFcbiAgICAvLyBsb2NhbCBvcC4gQmFzaWNhbGx5LCB0aGUgcHJvYmxlbSBpcyB0aGF0IGlmIHRoZSBjbGllbnQncyBvcCBpcyByZWplY3RlZFxuICAgIC8vIGJ5IHRoZSBzZXJ2ZXIsIHRoZSBlZGl0b3Igd2luZG93IHNob3VsZCB1cGRhdGUgdG8gcmVmbGVjdCB0aGUgdW5kby5cbiAgICB0aGlzLl9vdEFwcGx5KG9wRGF0YSwgZmFsc2UpO1xuICAgIHRoaXMuX2FmdGVyT3RBcHBseShvcERhdGEsIGZhbHNlKTtcbiAgfSBlbHNlIGlmIChvcERhdGEub3AgfHwgb3BEYXRhLmRlbCkge1xuICAgIC8vIFRoaXMgaXMgd2hlcmUgYW4gdW5kbyBzdGFjayB3b3VsZCBjb21lIGluIGhhbmR5LlxuICAgIHRoaXMuX3NldFR5cGUobnVsbCk7XG4gICAgdGhpcy52ZXJzaW9uID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgICB0aGlzLnN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgXCJPcCBhcHBseSBmYWlsZWQgYW5kIHRoZSBvcGVyYXRpb24gY291bGQgbm90IGJlIHJldmVydGVkXCIpO1xuXG4gICAgLy8gVHJpZ2dlciBhIGZldGNoLiBJbiBvdXIgaW52YWxpZCBzdGF0ZSwgd2UgY2FuJ3QgcmVhbGx5IGRvIGFueXRoaW5nLlxuICAgIHRoaXMuZmV0Y2goKTtcbiAgICB0aGlzLmZsdXNoKCk7XG4gIH1cbn07XG5cbkRvYy5wcm90b3R5cGUuX2NsZWFySW5mbGlnaHRPcCA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLmluZmxpZ2h0RGF0YS5jYWxsYmFja3M7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2FsbGJhY2tzW2ldKGVycm9yIHx8IHRoaXMuaW5mbGlnaHREYXRhLmVycm9yKTtcbiAgfVxuXG4gIHRoaXMuaW5mbGlnaHREYXRhID0gbnVsbDtcbiAgdGhpcy5fY2xlYXJBY3Rpb24oJ3N1Ym1pdCcpO1xuXG4gIGlmICghdGhpcy5wZW5kaW5nRGF0YS5sZW5ndGgpIHtcbiAgICAvLyBUaGlzIGlzbid0IGEgdmVyeSBnb29kIG5hbWUuXG4gICAgdGhpcy5lbWl0KCdub3RoaW5nIHBlbmRpbmcnKTtcbiAgfVxufTtcblxuLy8gVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgc2VydmVyIGFja25vd2xlZGdlcyBhbiBvcGVyYXRpb24gZnJvbSB0aGUgY2xpZW50LlxuRG9jLnByb3RvdHlwZS5fb3BBY2tub3dsZWRnZWQgPSBmdW5jdGlvbihtc2cpIHtcbiAgLy8gT3VyIGluZmxpZ2h0IG9wIGhhcyBiZWVuIGFja25vd2xlZGdlZCwgc28gd2UgY2FuIHRocm93IGF3YXkgdGhlIGluZmxpZ2h0IGRhdGEuXG4gIC8vIChXZSB3ZXJlIG9ubHkgaG9sZGluZyBvbiB0byBpdCBpbmNhc2Ugd2UgbmVlZGVkIHRvIHJlc2VuZCB0aGUgb3AuKVxuICBpZiAoIXRoaXMuc3RhdGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29wQWNrbm93bGVkZ2VkIGNhbGxlZCBmcm9tIGEgbnVsbCBzdGF0ZS4gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLicpO1xuICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09ICdmbG9hdGluZycpIHtcbiAgICBpZiAoIXRoaXMuaW5mbGlnaHREYXRhLmNyZWF0ZSkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWNrbm93bGVkZ2UgYW4gb3AuJyk7XG5cbiAgICAvLyBPdXIgY3JlYXRlIGhhcyBiZWVuIGFja25vd2xlZGdlZC4gVGhpcyBpcyB0aGUgc2FtZSBhcyBpbmplc3Rpbmcgc29tZSBkYXRhLlxuICAgIHRoaXMudmVyc2lvbiA9IG1zZy52O1xuICAgIHRoaXMuc3RhdGUgPSAncmVhZHknO1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgX3RoaXMuZW1pdCgncmVhZHknKTsgfSwgMCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgYWxyZWFkeSBoYXZlIGEgc25hcHNob3QuIFRoZSBzbmFwc2hvdCBzaG91bGQgYmUgYXQgdGhlIGFja25vd2xlZGdlZFxuICAgIC8vIHZlcnNpb24sIGJlY2F1c2UgdGhlIHNlcnZlciBoYXMgc2VudCB1cyBhbGwgdGhlIG9wcyB0aGF0IGhhdmUgaGFwcGVuZWRcbiAgICAvLyBiZWZvcmUgYWNrbm93bGVkZ2luZyBvdXIgb3AuXG5cbiAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4gLSBzb21ldGhpbmcgaXMgb3V0IG9mIG9yZGVyLlxuICAgIGlmIChtc2cudiAhPT0gdGhpcy52ZXJzaW9uKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZlcnNpb24gZnJvbSBzZXJ2ZXIuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHlvdSBzdWJtaXQgb3BzIGluIGEgc3VibWl0T3AgY2FsbGJhY2suJyk7XG4gIH1cbiAgXG4gIC8vIFRoZSBvcCB3YXMgY29tbWl0dGVkIHN1Y2Nlc3NmdWxseS4gSW5jcmVtZW50IHRoZSB2ZXJzaW9uIG51bWJlclxuICB0aGlzLnZlcnNpb24rKztcblxuICB0aGlzLl9jbGVhckluZmxpZ2h0T3AoKTtcbn07XG5cblxuLy8gQVBJIENvbnRleHRzXG5cbi8vIFRoaXMgY3JlYXRlcyBhbmQgcmV0dXJucyBhbiBlZGl0aW5nIGNvbnRleHQgdXNpbmcgdGhlIGN1cnJlbnQgT1QgdHlwZS5cbkRvYy5wcm90b3R5cGUuY3JlYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcbiAgaWYgKCF0eXBlKSB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdHlwZScpO1xuXG4gIC8vIEkgY291bGQgdXNlIHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gZG8gdGhpcyBpbnN0ZWFkLCBidXQgT2JqZWN0LmNyZWF0ZVxuICAvLyBpc24ndCBkZWZpbmVkIG9uIG9sZCBicm93c2Vycy4gVGhpcyB3aWxsIGJlIGZpbmUuXG4gIHZhciBkb2MgPSB0aGlzO1xuICB2YXIgY29udGV4dCA9IHtcbiAgICBnZXRTbmFwc2hvdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZG9jLnNuYXBzaG90O1xuICAgIH0sXG4gICAgc3VibWl0T3A6IGZ1bmN0aW9uKG9wLCBjYWxsYmFjaykge1xuICAgICAgZG9jLnN1Ym1pdE9wKG9wLCBjb250ZXh0LCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmRldGFjaCkge1xuICAgICAgICB0aGlzLmRldGFjaCgpO1xuICAgICAgICAvLyBEb24ndCBkb3VibGUtZGV0YWNoLlxuICAgICAgICBkZWxldGUgdGhpcy5kZXRhY2g7XG4gICAgICB9XG4gICAgICAvLyBJdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgYWN0dWFsIGVkaXRpbmdDb250ZXh0cyBsaXN0IG5leHQgdGltZVxuICAgICAgLy8gd2UgcmVjZWl2ZSBhbiBvcCBvbiB0aGUgZG9jdW1lbnQgKGFuZCB0aGUgbGlzdCBpcyBpdGVyYXRlZCB0aHJvdWdoKS5cbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGlzIHBvdGVudGlhbGx5IGRvZGd5LCBhbGxvd2luZyBhIG1lbW9yeSBsZWFrIGlmIHlvdSBjcmVhdGUgJlxuICAgICAgLy8gZGVzdHJveSBhIHdob2xlIGJ1bmNoIG9mIGNvbnRleHRzIHdpdGhvdXQgcmVjZWl2aW5nIG9yIHNlbmRpbmcgYW55IG9wc1xuICAgICAgLy8gdG8gdGhlIGRvY3VtZW50LlxuICAgICAgZGVsZXRlIHRoaXMuX29uT3A7XG4gICAgICB0aGlzLnJlbW92ZSA9IHRydWU7XG4gICAgfSxcblxuICAgIC8vIFRoaXMgaXMgZGFuZ2Vyb3VzLCBidXQgcmVhbGx5IHJlYWxseSB1c2VmdWwgZm9yIGRlYnVnZ2luZy4gSSBob3BlIHBlb3BsZVxuICAgIC8vIGRvbid0IGRlcGVuZCBvbiBpdC5cbiAgICBfZG9jOiB0aGlzLFxuICB9O1xuXG4gIGlmICh0eXBlLmFwaSkge1xuICAgIC8vIENvcHkgZXZlcnl0aGluZyBlbHNlIGZyb20gdGhlIHR5cGUncyBBUEkgaW50byB0aGUgZWRpdGluZyBjb250ZXh0LlxuICAgIGZvciAodmFyIGsgaW4gdHlwZS5hcGkpIHtcbiAgICAgIGNvbnRleHRba10gPSB0eXBlLmFwaVtrXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC5wcm92aWRlcyA9IHt9O1xuICB9XG5cbiAgdGhpcy5lZGl0aW5nQ29udGV4dHMucHVzaChjb250ZXh0KTtcblxuICByZXR1cm4gY29udGV4dDtcbn07XG5cbkRvYy5wcm90b3R5cGUucmVtb3ZlQ29udGV4dHMgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVkaXRpbmdDb250ZXh0cy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuZWRpdGluZ0NvbnRleHRzW2ldLmRlc3Ryb3koKTtcbiAgfVxuICB0aGlzLmVkaXRpbmdDb250ZXh0cy5sZW5ndGggPSAwO1xufTtcblxuIiwiXG52YXIgcmVnaXN0ZXIgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGV4cG9ydHNbdHlwZS5uYW1lXSA9IHR5cGU7XG4gIGlmICh0eXBlLnVyaSkge1xuICAgIHJldHVybiBleHBvcnRzW3R5cGUudXJpXSA9IHR5cGU7XG4gIH1cbn07XG5cbi8vIEltcG9ydCBhbGwgdGhlIGJ1aWx0LWluIHR5cGVzLiBSZXF1aXJpbmcgZGlyZWN0bHkgcmF0aGVyIHRoYW4gaW4gcmVnaXN0ZXIoKVxuLy8gc28gYnJvd3NlcmlmeSB3b3Jrcy5cbnJlZ2lzdGVyKHJlcXVpcmUoJy4vc2ltcGxlJykpO1xuXG5yZWdpc3RlcihyZXF1aXJlKCcuL3RleHQnKSk7XG5yZWdpc3RlcihyZXF1aXJlKCcuL3RleHQtdHAyJykpO1xuXG5yZWdpc3RlcihyZXF1aXJlKCcuL2pzb24wJykpO1xuXG4iLCIvLyBUaGlzIGlzIGEgcmVhbGx5IHNpbXBsZSBPVCB0eXBlLiBJdHMgbm90IGNvbXBpbGVkIHdpdGggdGhlIHdlYiBjbGllbnQsIGJ1dCBpdCBjb3VsZCBiZS5cbi8vXG4vLyBJdHMgbW9zdGx5IGluY2x1ZGVkIGZvciBkZW1vbnN0cmF0aW9uIHB1cnBvc2VzIGFuZCBpdHMgdXNlZCBpbiB0aGUgbWV0YSB1bml0IHRlc3RzLlxuLy9cbi8vIFRoaXMgZGVmaW5lcyBhIHJlYWxseSBzaW1wbGUgdGV4dCBPVCB0eXBlIHdoaWNoIG9ubHkgYWxsb3dzIGluc2VydHMuIChObyBkZWxldGVzKS5cbi8vXG4vLyBPcHMgbG9vayBsaWtlOlxuLy8gICB7cG9zaXRpb246IywgdGV4dDpcImFzZGZcIn1cbi8vXG4vLyBEb2N1bWVudCBzbmFwc2hvdHMgbG9vayBsaWtlOlxuLy8gICB7c3RyOnN0cmluZ31cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIFRoZSBuYW1lIG9mIHRoZSBPVCB0eXBlLiBUaGUgdHlwZSBpdHNlbGYgaXMgZXhwb3NlZCB0byBvdHR5cGVzW3R5cGUubmFtZV0gYW5kIG90dHlwZXNbdHlwZS51cmldLlxuICAvLyBUaGUgbmFtZSBjYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBhY3R1YWwgdHlwZSBpbiBhbGwgQVBJIG1ldGhvZHMgaW4gU2hhcmVKUy5cbiAgbmFtZTogJ3NpbXBsZScsXG5cbiAgLy8gQ2Fub25pY2FsIG5hbWUuXG4gIHVyaTogJ2h0dHA6Ly9zaGFyZWpzLm9yZy90eXBlcy9zaW1wbGUnLFxuXG4gIC8vIENyZWF0ZSBhIG5ldyBkb2N1bWVudCBzbmFwc2hvdC4gSW5pdGlhbCBkYXRhIGNhbiBiZSBwYXNzZWQgaW4uXG4gIGNyZWF0ZTogZnVuY3Rpb24oaW5pdGlhbCkge1xuICAgIGlmIChpbml0aWFsID09IG51bGwpXG4gICAgICBpbml0aWFsID0gJyc7XG5cbiAgICByZXR1cm4ge3N0cjogaW5pdGlhbH07XG4gIH0sXG5cbiAgLy8gQXBwbHkgdGhlIGdpdmVuIG9wIHRvIHRoZSBkb2N1bWVudCBzbmFwc2hvdC4gUmV0dXJucyB0aGUgbmV3IHNuYXBzaG90LlxuICBhcHBseTogZnVuY3Rpb24oc25hcHNob3QsIG9wKSB7XG4gICAgaWYgKG9wLnBvc2l0aW9uIDwgMCB8fCBvcC5wb3NpdGlvbiA+IHNuYXBzaG90LnN0ci5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcG9zaXRpb24nKTtcblxuICAgIHZhciBzdHIgPSBzbmFwc2hvdC5zdHI7XG4gICAgc3RyID0gc3RyLnNsaWNlKDAsIG9wLnBvc2l0aW9uKSArIG9wLnRleHQgKyBzdHIuc2xpY2Uob3AucG9zaXRpb24pO1xuICAgIHJldHVybiB7c3RyOiBzdHJ9O1xuICB9LFxuXG4gIC8vIFRyYW5zZm9ybSBvcDEgYnkgb3AyLiBSZXR1cm5zIHRyYW5zZm9ybWVkIHZlcnNpb24gb2Ygb3AxLlxuICAvLyBTeW0gZGVzY3JpYmVzIHRoZSBzeW1tZXRyeSBvZiB0aGUgb3BlcmF0aW9uLiBJdHMgZWl0aGVyICdsZWZ0JyBvciAncmlnaHQnXG4gIC8vIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBvcCBiZWluZyB0cmFuc2Zvcm1lZCBjb21lcyBmcm9tIHRoZSBjbGllbnQgb3IgdGhlXG4gIC8vIHNlcnZlci5cbiAgdHJhbnNmb3JtOiBmdW5jdGlvbihvcDEsIG9wMiwgc3ltKSB7XG4gICAgdmFyIHBvcyA9IG9wMS5wb3NpdGlvbjtcblxuICAgIGlmIChvcDIucG9zaXRpb24gPCBwb3MgfHwgKG9wMi5wb3NpdGlvbiA9PT0gcG9zICYmIHN5bSA9PT0gJ2xlZnQnKSkge1xuICAgICAgcG9zICs9IG9wMi50ZXh0Lmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4ge3Bvc2l0aW9uOiBwb3MsIHRleHQ6IG9wMS50ZXh0fTtcbiAgfVxufTtcblxuIiwiLyogVGV4dCBPVCFcbiAqXG4gKiBUaGlzIGlzIGFuIE9UIGltcGxlbWVudGF0aW9uIGZvciB0ZXh0LiBJdCBpcyB0aGUgc3RhbmRhcmQgaW1wbGVtZW50YXRpb24gb2ZcbiAqIHRleHQgdXNlZCBieSBTaGFyZUpTLlxuICpcbiAqIFRoaXMgdHlwZSBpcyBjb21wb3NhYmxlIGJ1dCBub24taW52ZXJ0YWJsZS4gSXRzIHNpbWlsYXIgdG8gU2hhcmVKUydzIG9sZFxuICogdGV4dC1jb21wb3NhYmxlIHR5cGUsIGJ1dCBpdHMgbm90IGludmVydGFibGUgYW5kIGl0cyB2ZXJ5IHNpbWlsYXIgdG8gdGhlXG4gKiB0ZXh0LXRwMiBpbXBsZW1lbnRhdGlvbiBidXQgaXQgZG9lc24ndCBzdXBwb3J0IHRvbWJzdG9uZXMgb3IgcHVyZ2luZy5cbiAqXG4gKiBPcHMgYXJlIGxpc3RzIG9mIGNvbXBvbmVudHMgd2hpY2ggaXRlcmF0ZSBvdmVyIHRoZSBkb2N1bWVudC5cbiAqIENvbXBvbmVudHMgYXJlIGVpdGhlcjpcbiAqICAgQSBudW1iZXIgTjogU2tpcCBOIGNoYXJhY3RlcnMgaW4gdGhlIG9yaWdpbmFsIGRvY3VtZW50XG4gKiAgIFwic3RyXCIgICAgIDogSW5zZXJ0IFwic3RyXCIgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50XG4gKiAgIHtkOidzdHInfSA6IERlbGV0ZSAnc3RyJywgd2hpY2ggYXBwZWFycyBhdCB0aGUgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnRcbiAqXG4gKiBFZzogWzMsICdoaScsIDUsIHtkOjh9XVxuICpcbiAqIFRoZSBvcGVyYXRpb24gZG9lcyBub3QgaGF2ZSB0byBza2lwIHRoZSBsYXN0IGNoYXJhY3RlcnMgaW4gdGhlIGRvY3VtZW50LlxuICpcbiAqIFNuYXBzaG90cyBhcmUgc3RyaW5ncy5cbiAqXG4gKiBDdXJzb3JzIGFyZSBlaXRoZXIgYSBzaW5nbGUgbnVtYmVyICh3aGljaCBpcyB0aGUgY3Vyc29yIHBvc2l0aW9uKSBvciBhIHBhaXIgb2ZcbiAqIFthbmNob3IsIGZvY3VzXSAoYWthIFtzdGFydCwgZW5kXSkuIEJlIGF3YXJlIHRoYXQgZW5kIGNhbiBiZSBiZWZvcmUgc3RhcnQuXG4gKi9cblxuLyoqIEBtb2R1bGUgdGV4dCAqL1xuXG5leHBvcnRzLm5hbWUgPSAndGV4dCc7XG5leHBvcnRzLnVyaSA9ICdodHRwOi8vc2hhcmVqcy5vcmcvdHlwZXMvdGV4dHYxJztcblxuLyoqIENyZWF0ZSBhIG5ldyB0ZXh0IHNuYXBzaG90LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbml0aWFsIC0gaW5pdGlhbCBzbmFwc2hvdCBkYXRhLiBPcHRpb25hbC4gRGVmYXVsdHMgdG8gJycuXG4gKi9cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24oaW5pdGlhbCkge1xuICBpZiAoKGluaXRpYWwgIT0gbnVsbCkgJiYgdHlwZW9mIGluaXRpYWwgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbml0aWFsIGRhdGEgbXVzdCBiZSBhIHN0cmluZycpO1xuICB9XG4gIHJldHVybiBpbml0aWFsIHx8ICcnO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbn07XG5cbi8qKiBDaGVjayB0aGUgb3BlcmF0aW9uIGlzIHZhbGlkLiBUaHJvd3MgaWYgbm90IHZhbGlkLiAqL1xudmFyIGNoZWNrT3AgPSBmdW5jdGlvbihvcCkge1xuICBpZiAoIWlzQXJyYXkob3ApKSB0aHJvdyBuZXcgRXJyb3IoJ09wIG11c3QgYmUgYW4gYXJyYXkgb2YgY29tcG9uZW50cycpO1xuXG4gIHZhciBsYXN0ID0gbnVsbDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjID0gb3BbaV07XG4gICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgLy8gVGhlIG9ubHkgdmFsaWQgb2JqZWN0cyBhcmUge2Q6WH0gZm9yICtpdmUgdmFsdWVzIG9mIFguXG4gICAgICAgIGlmICghKHR5cGVvZiBjLmQgPT09ICdudW1iZXInICYmIGMuZCA+IDApKSB0aHJvdyBuZXcgRXJyb3IoJ09iamVjdCBjb21wb25lbnRzIG11c3QgYmUgZGVsZXRlcyBvZiBzaXplID4gMCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIC8vIFN0cmluZ3MgYXJlIGluc2VydHMuXG4gICAgICAgIGlmICghKGMubGVuZ3RoID4gMCkpIHRocm93IG5ldyBFcnJvcignSW5zZXJ0cyBjYW5ub3QgYmUgZW1wdHknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAvLyBOdW1iZXJzIG11c3QgYmUgc2tpcHMuIFRoZXkgaGF2ZSB0byBiZSAraXZlIG51bWJlcnMuXG4gICAgICAgIGlmICghKGMgPiAwKSkgdGhyb3cgbmV3IEVycm9yKCdTa2lwIGNvbXBvbmVudHMgbXVzdCBiZSA+MCcpO1xuICAgICAgICBpZiAodHlwZW9mIGxhc3QgPT09ICdudW1iZXInKSB0aHJvdyBuZXcgRXJyb3IoJ0FkamFjZW50IHNraXAgY29tcG9uZW50cyBzaG91bGQgYmUgY29tYmluZWQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxhc3QgPSBjO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBsYXN0ID09PSAnbnVtYmVyJykgdGhyb3cgbmV3IEVycm9yKCdPcCBoYXMgYSB0cmFpbGluZyBza2lwJyk7XG59O1xuXG4vKiogTWFrZSBhIGZ1bmN0aW9uIHRoYXQgYXBwZW5kcyB0byB0aGUgZ2l2ZW4gb3BlcmF0aW9uLiAqL1xudmFyIG1ha2VBcHBlbmQgPSBmdW5jdGlvbihvcCkge1xuICByZXR1cm4gZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgaWYgKCFjb21wb25lbnQgfHwgY29tcG9uZW50LmQgPT09IDApIHtcbiAgICAgIC8vIFRoZSBjb21wb25lbnQgaXMgYSBuby1vcC4gSWdub3JlIVxuIFxuICAgIH0gZWxzZSBpZiAob3AubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gb3AucHVzaChjb21wb25lbnQpO1xuXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSB0eXBlb2Ygb3Bbb3AubGVuZ3RoIC0gMV0pIHtcbiAgICAgIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gb3Bbb3AubGVuZ3RoIC0gMV0uZCArPSBjb21wb25lbnQuZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvcFtvcC5sZW5ndGggLSAxXSArPSBjb21wb25lbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcC5wdXNoKGNvbXBvbmVudCk7XG4gICAgfVxuICB9O1xufTtcblxuLyoqIE1ha2VzIGFuZCByZXR1cm5zIHV0aWxpdHkgZnVuY3Rpb25zIHRha2UgYW5kIHBlZWsuICovXG52YXIgbWFrZVRha2UgPSBmdW5jdGlvbihvcCkge1xuICAvLyBUaGUgaW5kZXggb2YgdGhlIG5leHQgY29tcG9uZW50IHRvIHRha2VcbiAgdmFyIGlkeCA9IDA7XG4gIC8vIFRoZSBvZmZzZXQgaW50byB0aGUgY29tcG9uZW50XG4gIHZhciBvZmZzZXQgPSAwO1xuXG4gIC8vIFRha2UgdXAgdG8gbGVuZ3RoIG4gZnJvbSB0aGUgZnJvbnQgb2Ygb3AuIElmIG4gaXMgLTEsIHRha2UgdGhlIGVudGlyZSBuZXh0XG4gIC8vIG9wIGNvbXBvbmVudC4gSWYgaW5kaXZpc2FibGVGaWVsZCA9PSAnZCcsIGRlbGV0ZSBjb21wb25lbnRzIHdvbid0IGJlIHNlcGFyYXRlZC5cbiAgLy8gSWYgaW5kaXZpc2FibGVGaWVsZCA9PSAnaScsIGluc2VydCBjb21wb25lbnRzIHdvbid0IGJlIHNlcGFyYXRlZC5cbiAgdmFyIHRha2UgPSBmdW5jdGlvbihuLCBpbmRpdmlzYWJsZUZpZWxkKSB7XG4gICAgLy8gV2UncmUgYXQgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uLiBUaGUgb3AgaGFzIHNraXBzLCBmb3JldmVyLiBJbmZpbml0eVxuICAgIC8vIG1pZ2h0IG1ha2UgbW9yZSBzZW5zZSB0aGFuIG51bGwgaGVyZS5cbiAgICBpZiAoaWR4ID09PSBvcC5sZW5ndGgpXG4gICAgICByZXR1cm4gbiA9PT0gLTEgPyBudWxsIDogbjtcblxuICAgIHZhciBwYXJ0O1xuICAgIHZhciBjID0gb3BbaWR4XTtcbiAgICBpZiAodHlwZW9mIGMgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBTa2lwXG4gICAgICBpZiAobiA9PT0gLTEgfHwgYyAtIG9mZnNldCA8PSBuKSB7XG4gICAgICAgIHBhcnQgPSBjIC0gb2Zmc2V0O1xuICAgICAgICArK2lkeDtcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgKz0gbjtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgaWYgKG4gPT09IC0xIHx8IGluZGl2aXNhYmxlRmllbGQgPT09ICdpJyB8fCBjLmxlbmd0aCAtIG9mZnNldCA8PSBuKSB7XG4gICAgICAgIHBhcnQgPSBjLnNsaWNlKG9mZnNldCk7XG4gICAgICAgICsraWR4O1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnQgPSBjLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbik7XG4gICAgICAgIG9mZnNldCArPSBuO1xuICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVsZXRlXG4gICAgICBpZiAobiA9PT0gLTEgfHwgaW5kaXZpc2FibGVGaWVsZCA9PT0gJ2QnIHx8IGMuZCAtIG9mZnNldCA8PSBuKSB7XG4gICAgICAgIHBhcnQgPSB7ZDogYy5kIC0gb2Zmc2V0fTtcbiAgICAgICAgKytpZHg7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ICs9IG47XG4gICAgICAgIHJldHVybiB7ZDogbn07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIFBlZWsgYXQgdGhlIG5leHQgb3AgdGhhdCB3aWxsIGJlIHJldHVybmVkLlxuICB2YXIgcGVla1R5cGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIG9wW2lkeF07IH07XG5cbiAgcmV0dXJuIFt0YWtlLCBwZWVrVHlwZV07XG59O1xuXG4vKiogR2V0IHRoZSBsZW5ndGggb2YgYSBjb21wb25lbnQgKi9cbnZhciBjb21wb25lbnRMZW5ndGggPSBmdW5jdGlvbihjKSB7XG4gIC8vIFVnbGlmeSB3aWxsIGNvbXByZXNzIHRoaXMgZG93biBpbnRvIGEgdGVybmFyeVxuICBpZiAodHlwZW9mIGMgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGMubGVuZ3RoIHx8IGMuZDtcbiAgfVxufTtcblxuLyoqIFRyaW0gYW55IGV4Y2VzcyBza2lwcyBmcm9tIHRoZSBlbmQgb2YgYW4gb3BlcmF0aW9uLlxuICpcbiAqIFRoZXJlIHNob3VsZCBvbmx5IGJlIGF0IG1vc3Qgb25lLCBiZWNhdXNlIHRoZSBvcGVyYXRpb24gd2FzIG1hZGUgd2l0aCBhcHBlbmQuXG4gKi9cbnZhciB0cmltID0gZnVuY3Rpb24ob3ApIHtcbiAgaWYgKG9wLmxlbmd0aCA+IDAgJiYgdHlwZW9mIG9wW29wLmxlbmd0aCAtIDFdID09PSAnbnVtYmVyJykge1xuICAgIG9wLnBvcCgpO1xuICB9XG4gIHJldHVybiBvcDtcbn07XG5cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ob3ApIHtcbiAgdmFyIG5ld09wID0gW107XG4gIHZhciBhcHBlbmQgPSBtYWtlQXBwZW5kKG5ld09wKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xuICAgIGFwcGVuZChvcFtpXSk7XG4gIH1cbiAgcmV0dXJuIHRyaW0obmV3T3ApO1xufTtcblxuLyoqIEFwcGx5IGFuIG9wZXJhdGlvbiB0byBhIGRvY3VtZW50IHNuYXBzaG90ICovXG5leHBvcnRzLmFwcGx5ID0gZnVuY3Rpb24oc3RyLCBvcCkge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NuYXBzaG90IHNob3VsZCBiZSBhIHN0cmluZycpO1xuICB9XG4gIGNoZWNrT3Aob3ApO1xuXG4gIC8vIFdlJ2xsIGdhdGhlciB0aGUgbmV3IGRvY3VtZW50IGhlcmUgYW5kIGpvaW4gYXQgdGhlIGVuZC5cbiAgdmFyIG5ld0RvYyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3AubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29tcG9uZW50ID0gb3BbaV07XG4gICAgc3dpdGNoICh0eXBlb2YgY29tcG9uZW50KSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpZiAoY29tcG9uZW50ID4gc3RyLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdUaGUgb3AgaXMgdG9vIGxvbmcgZm9yIHRoaXMgZG9jdW1lbnQnKTtcblxuICAgICAgICBuZXdEb2MucHVzaChzdHIuc2xpY2UoMCwgY29tcG9uZW50KSk7XG4gICAgICAgIC8vIFRoaXMgbWlnaHQgYmUgc2xvdyBmb3IgYmlnIHN0cmluZ3MuIENvbnNpZGVyIHN0b3JpbmcgdGhlIG9mZnNldCBpblxuICAgICAgICAvLyBzdHIgaW5zdGVhZCBvZiByZXdyaXRpbmcgaXQgZWFjaCB0aW1lLlxuICAgICAgICBzdHIgPSBzdHIuc2xpY2UoY29tcG9uZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICBuZXdEb2MucHVzaChjb21wb25lbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHN0ciA9IHN0ci5zbGljZShjb21wb25lbnQuZCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdEb2Muam9pbignJykgKyBzdHI7XG59O1xuXG4vKiogVHJhbnNmb3JtIG9wIGJ5IG90aGVyT3AuXG4gKlxuICogQHBhcmFtIG9wIC0gVGhlIG9wZXJhdGlvbiB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSBvdGhlck9wIC0gT3BlcmF0aW9uIHRvIHRyYW5zZm9ybSBpdCBieVxuICogQHBhcmFtIHNpZGUgLSBFaXRoZXIgJ2xlZnQnIG9yICdyaWdodCdcbiAqL1xuZXhwb3J0cy50cmFuc2Zvcm0gPSBmdW5jdGlvbihvcCwgb3RoZXJPcCwgc2lkZSkge1xuICBpZiAoc2lkZSAhPSAnbGVmdCcgJiYgc2lkZSAhPSAncmlnaHQnKSB0aHJvdyBuZXcgRXJyb3IoXCJzaWRlIChcIiArIHNpZGUgKyBcIikgbXVzdCBiZSAnbGVmdCcgb3IgJ3JpZ2h0J1wiKTtcblxuICBjaGVja09wKG9wKTtcbiAgY2hlY2tPcChvdGhlck9wKTtcblxuICB2YXIgbmV3T3AgPSBbXTtcbiAgdmFyIGFwcGVuZCA9IG1ha2VBcHBlbmQobmV3T3ApO1xuXG4gIHZhciBfZm5zID0gbWFrZVRha2Uob3ApO1xuICB2YXIgdGFrZSA9IF9mbnNbMF0sXG4gICAgICBwZWVrID0gX2Zuc1sxXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG90aGVyT3AubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29tcG9uZW50ID0gb3RoZXJPcFtpXTtcblxuICAgIHZhciBsZW5ndGgsIGNodW5rO1xuICAgIHN3aXRjaCAodHlwZW9mIGNvbXBvbmVudCkge1xuICAgICAgY2FzZSAnbnVtYmVyJzogLy8gU2tpcFxuICAgICAgICBsZW5ndGggPSBjb21wb25lbnQ7XG4gICAgICAgIHdoaWxlIChsZW5ndGggPiAwKSB7XG4gICAgICAgICAgY2h1bmsgPSB0YWtlKGxlbmd0aCwgJ2knKTtcbiAgICAgICAgICBhcHBlbmQoY2h1bmspO1xuICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBsZW5ndGggLT0gY29tcG9uZW50TGVuZ3RoKGNodW5rKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3N0cmluZyc6IC8vIEluc2VydFxuICAgICAgICBpZiAoc2lkZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgLy8gVGhlIGxlZnQgaW5zZXJ0IHNob3VsZCBnbyBmaXJzdC5cbiAgICAgICAgICBpZiAodHlwZW9mIHBlZWsoKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGFwcGVuZCh0YWtlKC0xKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHNraXAgdGhlIGluc2VydGVkIHRleHQuXG4gICAgICAgIGFwcGVuZChjb21wb25lbnQubGVuZ3RoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6IC8vIERlbGV0ZVxuICAgICAgICBsZW5ndGggPSBjb21wb25lbnQuZDtcbiAgICAgICAgd2hpbGUgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjaHVuayA9IHRha2UobGVuZ3RoLCAnaScpO1xuICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGNodW5rKSB7XG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICBsZW5ndGggLT0gY2h1bms7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgYXBwZW5kKGNodW5rKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAvLyBUaGUgZGVsZXRlIGlzIHVubmVjZXNzYXJ5IG5vdyAtIHRoZSB0ZXh0IGhhcyBhbHJlYWR5IGJlZW4gZGVsZXRlZC5cbiAgICAgICAgICAgICAgbGVuZ3RoIC09IGNodW5rLmQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gQXBwZW5kIGFueSBleHRyYSBkYXRhIGluIG9wMS5cbiAgd2hpbGUgKChjb21wb25lbnQgPSB0YWtlKC0xKSkpXG4gICAgYXBwZW5kKGNvbXBvbmVudCk7XG4gIFxuICByZXR1cm4gdHJpbShuZXdPcCk7XG59O1xuXG4vKiogQ29tcG9zZSBvcDEgYW5kIG9wMiB0b2dldGhlciBhbmQgcmV0dXJuIHRoZSByZXN1bHQgKi9cbmV4cG9ydHMuY29tcG9zZSA9IGZ1bmN0aW9uKG9wMSwgb3AyKSB7XG4gIGNoZWNrT3Aob3AxKTtcbiAgY2hlY2tPcChvcDIpO1xuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGFwcGVuZCA9IG1ha2VBcHBlbmQocmVzdWx0KTtcbiAgdmFyIHRha2UgPSBtYWtlVGFrZShvcDEpWzBdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3AyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IG9wMltpXTtcbiAgICB2YXIgbGVuZ3RoLCBjaHVuaztcbiAgICBzd2l0Y2ggKHR5cGVvZiBjb21wb25lbnQpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6IC8vIFNraXBcbiAgICAgICAgbGVuZ3RoID0gY29tcG9uZW50O1xuICAgICAgICB3aGlsZSAobGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNodW5rID0gdGFrZShsZW5ndGgsICdkJyk7XG4gICAgICAgICAgYXBwZW5kKGNodW5rKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgbGVuZ3RoIC09IGNvbXBvbmVudExlbmd0aChjaHVuayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOiAvLyBJbnNlcnRcbiAgICAgICAgYXBwZW5kKGNvbXBvbmVudCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdvYmplY3QnOiAvLyBEZWxldGVcbiAgICAgICAgbGVuZ3RoID0gY29tcG9uZW50LmQ7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjaHVuayA9IHRha2UobGVuZ3RoLCAnZCcpO1xuXG4gICAgICAgICAgc3dpdGNoICh0eXBlb2YgY2h1bmspIHtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgIGFwcGVuZCh7ZDogY2h1bmt9KTtcbiAgICAgICAgICAgICAgbGVuZ3RoIC09IGNodW5rO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgIGxlbmd0aCAtPSBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgYXBwZW5kKGNodW5rKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKChjb21wb25lbnQgPSB0YWtlKC0xKSkpXG4gICAgYXBwZW5kKGNvbXBvbmVudCk7XG5cbiAgcmV0dXJuIHRyaW0ocmVzdWx0KTtcbn07XG5cbnZhciB0cmFuc2Zvcm1Qb3NpdGlvbiA9IGZ1bmN0aW9uKGN1cnNvciwgb3ApIHtcbiAgdmFyIHBvcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3AubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYyA9IG9wW2ldO1xuICAgIGlmIChjdXJzb3IgPD0gcG9zKSBicmVhaztcblxuICAgIC8vIEkgY291bGQgYWN0dWFsbHkgdXNlIHRoZSBvcF9pdGVyIHN0dWZmIGFib3ZlIC0gYnV0IEkgdGhpbmsgaXRzIHNpbXBsZXJcbiAgICAvLyBsaWtlIHRoaXMuXG4gICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgaWYgKGN1cnNvciA8PSBwb3MgKyBjKVxuICAgICAgICAgIHJldHVybiBjdXJzb3I7XG4gICAgICAgIHBvcyArPSBjO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcG9zICs9IGMubGVuZ3RoO1xuICAgICAgICBjdXJzb3IgKz0gYy5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBjdXJzb3IgLT0gTWF0aC5taW4oYy5kLCBjdXJzb3IgLSBwb3MpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGN1cnNvcjtcbn07XG5cbmV4cG9ydHMudHJhbnNmb3JtQ3Vyc29yID0gZnVuY3Rpb24oY3Vyc29yLCBvcCwgaXNPd25PcCkge1xuICB2YXIgcG9zID0gMDtcbiAgaWYgKGlzT3duT3ApIHtcbiAgICAvLyBKdXN0IHRyYWNrIHRoZSBwb3NpdGlvbi4gV2UnbGwgdGVsZXBvcnQgdGhlIGN1cnNvciB0byB0aGUgZW5kIGFueXdheS5cbiAgICAvLyBUaGlzIHdvcmtzIGJlY2F1c2UgdGV4dCBvcHMgZG9uJ3QgaGF2ZSBhbnkgdHJhaWxpbmcgc2tpcHMgYXQgdGhlIGVuZCAtIHNvIHRoZSBsYXN0XG4gICAgLy8gY29tcG9uZW50IGlzIHRoZSBsYXN0IHRoaW5nLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3AubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gb3BbaV07XG4gICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgcG9zICs9IGM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgcG9zICs9IGMubGVuZ3RoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBKdXN0IGVhdCBkZWxldGVzLlxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW3BvcywgcG9zXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW3RyYW5zZm9ybVBvc2l0aW9uKGN1cnNvclswXSwgb3ApLCB0cmFuc2Zvcm1Qb3NpdGlvbihjdXJzb3JbMV0sIG9wKV07XG4gIH1cbn07XG4iLCIoZnVuY3Rpb24oKXsvLyBBIFRQMiBpbXBsZW1lbnRhdGlvbiBvZiB0ZXh0LCBmb2xsb3dpbmcgdGhpcyBzcGVjOlxuLy8gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2xpZ2h0d2F2ZS9zb3VyY2UvYnJvd3NlL3RydW5rL2V4cGVyaW1lbnRhbC9vdC9SRUFETUVcbi8vXG4vLyBBIGRvY3VtZW50IGlzIG1hZGUgdXAgb2YgYSBzdHJpbmcgYW5kIGEgc2V0IG9mIHRvbWJzdG9uZXMgaW5zZXJ0ZWQgdGhyb3VnaG91dFxuLy8gdGhlIHN0cmluZy4gRm9yIGV4YW1wbGUsICdzb21lICcsICgyIHRvbWJzdG9uZXMpLCAnc3RyaW5nJy5cbi8vXG4vLyBUaGlzIGlzIGVuY29kZWQgaW4gYSBkb2N1bWVudCBhczoge3M6J3NvbWUgc3RyaW5nJywgdDpbNSwgLTIsIDZdfVxuLy9cbi8vIE9wcyBhcmUgbGlzdHMgb2YgY29tcG9uZW50cyB3aGljaCBpdGVyYXRlIG92ZXIgdGhlIHdob2xlIGRvY3VtZW50LiAoSSBtaWdodFxuLy8gY2hhbmdlIHRoaXMgYXQgc29tZSBwb2ludCwgYnV0IGEgdmVyc2lvbiB0aGF0cyBsZXNzIHN0cmljdCBpcyBiYWNrd2FyZHNcbi8vIGNvbXBhdGlibGUuKVxuLy9cbi8vIENvbXBvbmVudHMgYXJlIGVpdGhlcjpcbi8vICAgTjogICAgICAgICBTa2lwIE4gY2hhcmFjdGVycyBpbiB0aGUgb3JpZ2luYWwgZG9jdW1lbnRcbi8vICAge2k6J3N0cid9OiBJbnNlcnQgJ3N0cicgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50XG4vLyAgIHtpOk59OiAgICAgSW5zZXJ0IE4gdG9tYnN0b25lcyBhdCB0aGUgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnRcbi8vICAge2Q6Tn06ICAgICBEZWxldGUgKHRvbWJzdG9uZSkgTiBjaGFyYWN0ZXJzIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudFxuLy9cbi8vIEVnOiBbMywge2k6J2hpJ30sIDUsIHtkOjh9XVxuLy9cbi8vIFNuYXBzaG90cyBhcmUgbGlzdHMgd2l0aCBjaGFyYWN0ZXJzIGFuZCB0b21ic3RvbmVzLiBDaGFyYWN0ZXJzIGFyZSBzdG9yZWQgaW4gc3RyaW5nc1xuLy8gYW5kIGFkamFjZW50IHRvbWJzdG9uZXMgYXJlIGZsYXR0ZW5lZCBpbnRvIG51bWJlcnMuXG4vL1xuLy8gRWcsIHRoZSBkb2N1bWVudDogJ0hlbGxvIC4uLi4ud29ybGQnICgnLicgZGVub3RlcyB0b21ic3RvbmVkIChkZWxldGVkKSBjaGFyYWN0ZXJzKVxuLy8gd291bGQgYmUgcmVwcmVzZW50ZWQgYnkgYSBkb2N1bWVudCBzbmFwc2hvdCBvZiBbJ0hlbGxvICcsIDUsICd3b3JsZCddXG5cbi8vdmFyIGFwcGVuZCwgYXBwZW5kRG9jLCBjb21wb25lbnRMZW5ndGgsIG1ha2VUYWtlLCB0YWtlRG9jLCB0cmFuc2Zvcm1lcjtcblxudmFyIHR5cGUgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgbmFtZTogJ3RleHQtdHAyJyxcbiAgdHAyOiB0cnVlLFxuICB1cmk6ICdodHRwOi8vc2hhcmVqcy5vcmcvdHlwZXMvdGV4dC10cDJ2MScsXG4gIGNyZWF0ZTogZnVuY3Rpb24oaW5pdGlhbCkge1xuICAgIGlmIChpbml0aWFsID09IG51bGwpIHtcbiAgICAgIGluaXRpYWwgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBpbml0aWFsICE9ICdzdHJpbmcnKSB0aHJvdyBuZXcgRXJyb3IoJ0luaXRpYWwgZGF0YSBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNoYXJMZW5ndGg6IGluaXRpYWwubGVuZ3RoLFxuICAgICAgdG90YWxMZW5ndGg6IGluaXRpYWwubGVuZ3RoLFxuICAgICAgZGF0YTogaW5pdGlhbC5sZW5ndGggPyBbaW5pdGlhbF0gOiBbXVxuICAgIH07XG4gIH0sXG5cbiAgc2VyaWFsaXplOiBmdW5jdGlvbihkb2MpIHtcbiAgICBpZiAoIWRvYy5kYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZG9jIHNuYXBzaG90Jyk7XG4gICAgfVxuICAgIHJldHVybiBkb2MuZGF0YTtcbiAgfSxcblxuICBkZXNlcmlhbGl6ZTogZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciBkb2MgPSB0eXBlLmNyZWF0ZSgpO1xuICAgIGRvYy5kYXRhID0gZGF0YTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNvbXBvbmVudCA9IGRhdGFbaV07XG5cbiAgICAgIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICBkb2MuY2hhckxlbmd0aCArPSBjb21wb25lbnQubGVuZ3RoO1xuICAgICAgICBkb2MudG90YWxMZW5ndGggKz0gY29tcG9uZW50Lmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvYy50b3RhbExlbmd0aCArPSBjb21wb25lbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvYztcbiAgfVxufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbnZhciBjaGVja09wID0gZnVuY3Rpb24ob3ApIHtcbiAgaWYgKCFpc0FycmF5KG9wKSkgdGhyb3cgbmV3IEVycm9yKCdPcCBtdXN0IGJlIGFuIGFycmF5IG9mIGNvbXBvbmVudHMnKTtcblxuICB2YXIgbGFzdCA9IG51bGw7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3AubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYyA9IG9wW2ldO1xuICAgIGlmICh0eXBlb2YgYyA9PSAnb2JqZWN0Jykge1xuICAgICAgLy8gVGhlIGNvbXBvbmVudCBpcyBhbiBpbnNlcnQgb3IgYSBkZWxldGUuXG4gICAgICBpZiAoYy5pICE9PSB1bmRlZmluZWQpIHsgLy8gSW5zZXJ0LlxuICAgICAgICBpZiAoISgodHlwZW9mIGMuaSA9PT0gJ3N0cmluZycgJiYgYy5pLmxlbmd0aCA+IDApIC8vIFN0cmluZyBpbnNlcnRzXG4gICAgICAgICAgICAgIHx8ICh0eXBlb2YgYy5pID09PSAnbnVtYmVyJyAmJiBjLmkgPiAwKSkpIC8vIFRvbWJzdG9uZSBpbnNlcnRzXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnNlcnRzIG11c3QgaW5zZXJ0IGEgc3RyaW5nIG9yIGEgK2l2ZSBudW1iZXInKTtcblxuICAgICAgfSBlbHNlIGlmIChjLmQgIT09IHVuZGVmaW5lZCkgeyAvLyBEZWxldGVcbiAgICAgICAgaWYgKCEodHlwZW9mIGMuZCA9PT0gJ251bWJlcicgJiYgYy5kID4gMCkpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWxldGVzIG11c3QgYmUgYSAraXZlIG51bWJlcicpO1xuXG4gICAgICB9IGVsc2UgdGhyb3cgbmV3IEVycm9yKCdPcGVyYXRpb24gY29tcG9uZW50IG11c3QgZGVmaW5lIC5pIG9yIC5kJyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIGNvbXBvbmVudCBtdXN0IGJlIGEgc2tpcC5cbiAgICAgIGlmICh0eXBlb2YgYyAhPSAnbnVtYmVyJykgdGhyb3cgbmV3IEVycm9yKCdPcCBjb21wb25lbnRzIG11c3QgYmUgb2JqZWN0cyBvciBudW1iZXJzJyk7XG5cbiAgICAgIGlmIChjIDw9IDApIHRocm93IG5ldyBFcnJvcignU2tpcCBjb21wb25lbnRzIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgICAgIGlmICh0eXBlb2YgbGFzdCA9PT0gJ251bWJlcicpIHRocm93IG5ldyBFcnJvcignQWRqYWNlbnQgc2tpcCBjb21wb25lbnRzIHNob3VsZCBiZSBjb21iaW5lZCcpO1xuICAgIH1cblxuICAgIGxhc3QgPSBjO1xuICB9XG59O1xuXG4vLyBUYWtlIHRoZSBuZXh0IHBhcnQgZnJvbSB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uIGluIGEgZG9jdW1lbnQgc25hcHNob3QuXG4vLyBwb3NpdGlvbiA9IHtpbmRleCwgb2Zmc2V0fS4gSXQgd2lsbCBiZSB1cGRhdGVkLlxudmFyIHRha2VEb2MgPSB0eXBlLl90YWtlRG9jID0gZnVuY3Rpb24oZG9jLCBwb3NpdGlvbiwgbWF4bGVuZ3RoLCB0b21ic0luZGl2aXNpYmxlKSB7XG4gIGlmIChwb3NpdGlvbi5pbmRleCA+PSBkb2MuZGF0YS5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdPcGVyYXRpb24gZ29lcyBwYXN0IHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50Jyk7XG5cbiAgdmFyIHBhcnQgPSBkb2MuZGF0YVtwb3NpdGlvbi5pbmRleF07XG5cbiAgLy8gVGhpcyBjYW4gYmUgd3JpdHRlbiBhcyBhbiB1Z2x5LWFyc2VkIGdpYW50IHRlcm5hcnkgc3RhdGVtZW50LCBidXQgaXRzIG11Y2hcbiAgLy8gbW9yZSByZWFkYWJsZSBsaWtlIHRoaXMuIFVnbGlmeSB3aWxsIGNvbnZlcnQgaXQgaW50byBzYWlkIHRlcm5hcnkgYW55d2F5LlxuICB2YXIgcmVzdWx0O1xuICBpZiAodHlwZW9mIHBhcnQgPT0gJ3N0cmluZycpIHtcbiAgICBpZiAobWF4bGVuZ3RoICE9IG51bGwpIHtcbiAgICAgIHJlc3VsdCA9IHBhcnQuc2xpY2UocG9zaXRpb24ub2Zmc2V0LCBwb3NpdGlvbi5vZmZzZXQgKyBtYXhsZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBwYXJ0LnNsaWNlKHBvc2l0aW9uLm9mZnNldCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChtYXhsZW5ndGggPT0gbnVsbCB8fCB0b21ic0luZGl2aXNpYmxlKSB7XG4gICAgICByZXN1bHQgPSBwYXJ0IC0gcG9zaXRpb24ub2Zmc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBNYXRoLm1pbihtYXhsZW5ndGgsIHBhcnQgLSBwb3NpdGlvbi5vZmZzZXQpO1xuICAgIH1cbiAgfVxuXG4gIHZhciByZXN1bHRMZW4gPSByZXN1bHQubGVuZ3RoIHx8IHJlc3VsdDtcblxuICBpZiAoKHBhcnQubGVuZ3RoIHx8IHBhcnQpIC0gcG9zaXRpb24ub2Zmc2V0ID4gcmVzdWx0TGVuKSB7XG4gICAgcG9zaXRpb24ub2Zmc2V0ICs9IHJlc3VsdExlbjtcbiAgfSBlbHNlIHtcbiAgICBwb3NpdGlvbi5pbmRleCsrO1xuICAgIHBvc2l0aW9uLm9mZnNldCA9IDA7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gQXBwZW5kIGEgcGFydCB0byB0aGUgZW5kIG9mIGEgZG9jdW1lbnRcbnZhciBhcHBlbmREb2MgPSB0eXBlLl9hcHBlbmREb2MgPSBmdW5jdGlvbihkb2MsIHApIHtcbiAgaWYgKHAgPT09IDAgfHwgcCA9PT0gJycpIHJldHVybjtcblxuICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKSB7XG4gICAgZG9jLmNoYXJMZW5ndGggKz0gcC5sZW5ndGg7XG4gICAgZG9jLnRvdGFsTGVuZ3RoICs9IHAubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIGRvYy50b3RhbExlbmd0aCArPSBwO1xuICB9XG5cbiAgdmFyIGRhdGEgPSBkb2MuZGF0YTtcbiAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgZGF0YS5wdXNoKHApO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhW2RhdGEubGVuZ3RoIC0gMV0gPT09IHR5cGVvZiBwKSB7XG4gICAgZGF0YVtkYXRhLmxlbmd0aCAtIDFdICs9IHA7XG4gIH0gZWxzZSB7XG4gICAgZGF0YS5wdXNoKHApO1xuICB9XG59O1xuXG4vLyBBcHBseSB0aGUgb3AgdG8gdGhlIGRvY3VtZW50LiBUaGUgZG9jdW1lbnQgaXMgbm90IG1vZGlmaWVkIGluIHRoZSBwcm9jZXNzLlxudHlwZS5hcHBseSA9IGZ1bmN0aW9uKGRvYywgb3ApIHtcbiAgaWYgKGRvYy50b3RhbExlbmd0aCA9PSBudWxsIHx8IGRvYy5jaGFyTGVuZ3RoID09IG51bGwgfHwgIWlzQXJyYXkoZG9jLmRhdGEpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTbmFwc2hvdCBpcyBpbnZhbGlkJyk7XG4gIH1cbiAgY2hlY2tPcChvcCk7XG5cbiAgdmFyIG5ld0RvYyA9IHR5cGUuY3JlYXRlKCk7XG4gIHZhciBwb3NpdGlvbiA9IHtpbmRleDogMCwgb2Zmc2V0OiAwfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IG9wW2ldO1xuICAgIHZhciByZW1haW5kZXIsIHBhcnQ7XG5cbiAgICBpZiAodHlwZW9mIGNvbXBvbmVudCA9PSAnbnVtYmVyJykgeyAvLyBTa2lwXG4gICAgICByZW1haW5kZXIgPSBjb21wb25lbnQ7XG4gICAgICB3aGlsZSAocmVtYWluZGVyID4gMCkge1xuICAgICAgICBwYXJ0ID0gdGFrZURvYyhkb2MsIHBvc2l0aW9uLCByZW1haW5kZXIpO1xuICAgICAgICBhcHBlbmREb2MobmV3RG9jLCBwYXJ0KTtcbiAgICAgICAgcmVtYWluZGVyIC09IHBhcnQubGVuZ3RoIHx8IHBhcnQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKGNvbXBvbmVudC5pICE9PSB1bmRlZmluZWQpIHsgLy8gSW5zZXJ0XG4gICAgICBhcHBlbmREb2MobmV3RG9jLCBjb21wb25lbnQuaSk7XG5cbiAgICB9IGVsc2UgaWYgKGNvbXBvbmVudC5kICE9PSB1bmRlZmluZWQpIHsgLy8gRGVsZXRlXG4gICAgICByZW1haW5kZXIgPSBjb21wb25lbnQuZDtcbiAgICAgIHdoaWxlIChyZW1haW5kZXIgPiAwKSB7XG4gICAgICAgIHBhcnQgPSB0YWtlRG9jKGRvYywgcG9zaXRpb24sIHJlbWFpbmRlcik7XG4gICAgICAgIHJlbWFpbmRlciAtPSBwYXJ0Lmxlbmd0aCB8fCBwYXJ0O1xuICAgICAgfVxuICAgICAgYXBwZW5kRG9jKG5ld0RvYywgY29tcG9uZW50LmQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3RG9jO1xufTtcblxuLy8gQXBwZW5kIGFuIG9wIGNvbXBvbmVudCB0byB0aGUgZW5kIG9mIHRoZSBzcGVjaWZpZWQgb3AuICBFeHBvcnRlZCBmb3IgdGhlXG4vLyByYW5kb21PcEdlbmVyYXRvci5cbnZhciBhcHBlbmQgPSB0eXBlLl9hcHBlbmQgPSBmdW5jdGlvbihvcCwgY29tcG9uZW50KSB7XG4gIHZhciBsYXN0O1xuXG4gIGlmIChjb21wb25lbnQgPT09IDAgfHwgY29tcG9uZW50LmkgPT09ICcnIHx8IGNvbXBvbmVudC5pID09PSAwIHx8IGNvbXBvbmVudC5kID09PSAwKSB7XG4gICAgLy8gRHJvcCB0aGUgbmV3IGNvbXBvbmVudC5cbiAgfSBlbHNlIGlmIChvcC5sZW5ndGggPT09IDApIHtcbiAgICBvcC5wdXNoKGNvbXBvbmVudCk7XG4gIH0gZWxzZSB7XG4gICAgbGFzdCA9IG9wW29wLmxlbmd0aCAtIDFdO1xuICAgIGlmICh0eXBlb2YgY29tcG9uZW50ID09ICdudW1iZXInICYmIHR5cGVvZiBsYXN0ID09ICdudW1iZXInKSB7XG4gICAgICBvcFtvcC5sZW5ndGggLSAxXSArPSBjb21wb25lbnQ7XG4gICAgfSBlbHNlIGlmIChjb21wb25lbnQuaSAhPSBudWxsICYmIChsYXN0LmkgIT0gbnVsbCkgJiYgdHlwZW9mIGxhc3QuaSA9PT0gdHlwZW9mIGNvbXBvbmVudC5pKSB7XG4gICAgICBsYXN0LmkgKz0gY29tcG9uZW50Lmk7XG4gICAgfSBlbHNlIGlmIChjb21wb25lbnQuZCAhPSBudWxsICYmIChsYXN0LmQgIT0gbnVsbCkpIHtcbiAgICAgIGxhc3QuZCArPSBjb21wb25lbnQuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3AucHVzaChjb21wb25lbnQpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gTWFrZXMgMiBmdW5jdGlvbnMgZm9yIHRha2luZyBjb21wb25lbnRzIGZyb20gdGhlIHN0YXJ0IG9mIGFuIG9wLCBhbmQgZm9yXG4vLyBwZWVraW5nIGF0IHRoZSBuZXh0IG9wIHRoYXQgY291bGQgYmUgdGFrZW4uXG52YXIgbWFrZVRha2UgPSBmdW5jdGlvbihvcCkge1xuICAvLyBUaGUgaW5kZXggb2YgdGhlIG5leHQgY29tcG9uZW50IHRvIHRha2VcbiAgdmFyIGluZGV4ID0gMDtcbiAgLy8gVGhlIG9mZnNldCBpbnRvIHRoZSBjb21wb25lbnRcbiAgdmFyIG9mZnNldCA9IDA7XG5cbiAgdmFyIHRha2UgPSBmdW5jdGlvbihtYXhsZW5ndGgsIGluc2VydHNJbmRpdmlzaWJsZSkge1xuICAgIGlmIChpbmRleCA9PT0gb3AubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgZSA9IG9wW2luZGV4XTtcbiAgICB2YXIgY3VycmVudDtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgLy8gaWYgdGhlIGN1cnJlbnQgZWxlbWVudCBpcyBhIHNraXAsIGFuIGluc2VydCBvZiBhIG51bWJlciBvciBhIGRlbGV0ZVxuICAgIGlmICh0eXBlb2YgKGN1cnJlbnQgPSBlKSA9PSAnbnVtYmVyJyB8fCB0eXBlb2YgKGN1cnJlbnQgPSBlLmkpID09ICdudW1iZXInIHx8IChjdXJyZW50ID0gZS5kKSAhPSBudWxsKSB7XG4gICAgICB2YXIgYztcbiAgICAgIGlmICgobWF4bGVuZ3RoID09IG51bGwpIHx8IGN1cnJlbnQgLSBvZmZzZXQgPD0gbWF4bGVuZ3RoIHx8IChpbnNlcnRzSW5kaXZpc2libGUgJiYgZS5pICE9IG51bGwpKSB7XG4gICAgICAgIC8vIFJldHVybiB0aGUgcmVzdCBvZiB0aGUgY3VycmVudCBlbGVtZW50LlxuICAgICAgICBjID0gY3VycmVudCAtIG9mZnNldDtcbiAgICAgICAgKytpbmRleDtcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCArPSBtYXhsZW5ndGg7XG4gICAgICAgIGMgPSBtYXhsZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIC8vIFBhY2thZ2UgdGhlIGNvbXBvbmVudCBiYWNrIHVwLlxuICAgICAgaWYgKGUuaSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7aTogY307XG4gICAgICB9IGVsc2UgaWYgKGUuZCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7ZDogY307XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBJbnNlcnQgb2YgYSBzdHJpbmcuXG4gICAgICBpZiAoKG1heGxlbmd0aCA9PSBudWxsKSB8fCBlLmkubGVuZ3RoIC0gb2Zmc2V0IDw9IG1heGxlbmd0aCB8fCBpbnNlcnRzSW5kaXZpc2libGUpIHtcbiAgICAgICAgcmVzdWx0ID0ge2k6IGUuaS5zbGljZShvZmZzZXQpfTtcbiAgICAgICAgKytpbmRleDtcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHtpOiBlLmkuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBtYXhsZW5ndGgpfTtcbiAgICAgICAgb2Zmc2V0ICs9IG1heGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9O1xuXG4gIHZhciBwZWVrVHlwZSA9IGZ1bmN0aW9uKCkge3JldHVybiBvcFtpbmRleF07fTtcbiAgcmV0dXJuIFt0YWtlLCBwZWVrVHlwZV07XG59O1xuXG4vLyBGaW5kIGFuZCByZXR1cm4gdGhlIGxlbmd0aCBvZiBhbiBvcCBjb21wb25lbnRcbnZhciBjb21wb25lbnRMZW5ndGggPSBmdW5jdGlvbihjb21wb25lbnQpIHtcbiAgaWYgKHR5cGVvZiBjb21wb25lbnQgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY29tcG9uZW50LmkgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudC5pLmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29tcG9uZW50LmQgfHwgY29tcG9uZW50Lmk7XG4gIH1cbn07XG5cbi8vIE5vcm1hbGl6ZSBhbiBvcCwgcmVtb3ZpbmcgYWxsIGVtcHR5IHNraXBzIGFuZCBlbXB0eSBpbnNlcnRzIC8gZGVsZXRlcy5cbi8vIENvbmNhdGVuYXRlIGFkamFjZW50IGluc2VydHMgYW5kIGRlbGV0ZXMuXG50eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG9wKSB7XG4gIHZhciBuZXdPcCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSsrKSB7XG4gICAgYXBwZW5kKG5ld09wLCBvcFtpXSk7XG4gIH1cbiAgcmV0dXJuIG5ld09wO1xufTtcblxuLy8gVGhpcyBpcyBhIGhlbHBlciBtZXRob2QgdG8gdHJhbnNmb3JtIGFuZCBwcnVuZS4gZ29Gb3J3YXJkcyBpcyB0cnVlIGZvciB0cmFuc2Zvcm0sIGZhbHNlIGZvciBwcnVuZS5cbnZhciB0cmFuc2Zvcm1lciA9IGZ1bmN0aW9uKG9wLCBvdGhlck9wLCBnb0ZvcndhcmRzLCBzaWRlKSB7XG4gIGNoZWNrT3Aob3ApO1xuICBjaGVja09wKG90aGVyT3ApO1xuXG4gIHZhciBuZXdPcCA9IFtdO1xuXG4gIHZhciBmbnMgPSBtYWtlVGFrZShvcCksXG4gICAgICB0YWtlID0gZm5zWzBdLFxuICAgICAgcGVlayA9IGZuc1sxXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG90aGVyT3AubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29tcG9uZW50ID0gb3RoZXJPcFtpXTtcbiAgICB2YXIgbGVuID0gY29tcG9uZW50TGVuZ3RoKGNvbXBvbmVudCk7XG4gICAgdmFyIGNodW5rO1xuXG4gICAgaWYgKGNvbXBvbmVudC5pICE9IG51bGwpIHsgLy8gSW5zZXJ0IHRleHQgb3IgdG9tYnNcbiAgICAgIGlmIChnb0ZvcndhcmRzKSB7IC8vIFRyYW5zZm9ybSAtIGluc2VydCBza2lwcyBvdmVyIGRlbGV0ZWQgcGFydHMuXG4gICAgICAgIGlmIChzaWRlID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAvLyBUaGUgbGVmdCBzaWRlIGluc2VydCBzaG91bGQgZ28gZmlyc3QuXG4gICAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgICAgd2hpbGUgKChuZXh0ID0gcGVlaygpKSAmJiBuZXh0LmkgIT0gbnVsbCkge1xuICAgICAgICAgICAgYXBwZW5kKG5ld09wLCB0YWtlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJbiBhbnkgY2FzZSwgc2tpcCB0aGUgaW5zZXJ0ZWQgdGV4dC5cbiAgICAgICAgYXBwZW5kKG5ld09wLCBsZW4pO1xuXG4gICAgICB9IGVsc2UgeyAvLyBQcnVuZS4gUmVtb3ZlIHNraXBzIGZvciBpbnNlcnRzLlxuICAgICAgICB3aGlsZSAobGVuID4gMCkge1xuICAgICAgICAgIGNodW5rID0gdGFrZShsZW4sIHRydWUpO1xuXG4gICAgICAgICAgLy8gVGhlIGNodW5rIHdpbGwgYmUgbnVsbCBpZiB3ZSBydW4gb3V0IG9mIGNvbXBvbmVudHMgaW4gdGhlIG90aGVyIG9wLlxuICAgICAgICAgIGlmIChjaHVuayA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCdUaGUgdHJhbnNmb3JtZWQgb3AgaXMgaW52YWxpZCcpO1xuICAgICAgICAgIGlmIChjaHVuay5kICE9IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB0cmFuc2Zvcm1lZCBvcCBkZWxldGVzIGxvY2FsbHkgaW5zZXJ0ZWQgY2hhcmFjdGVycyAtIGl0IGNhbm5vdCBiZSBwdXJnZWQgb2YgdGhlIGluc2VydC4nKTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT0gJ251bWJlcicpXG4gICAgICAgICAgICBsZW4gLT0gY2h1bms7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYXBwZW5kKG5ld09wLCBjaHVuayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBTa2lwcyBvciBkZWxldGVzLlxuICAgICAgd2hpbGUgKGxlbiA+IDApIHtcbiAgICAgICAgY2h1bmsgPSB0YWtlKGxlbiwgdHJ1ZSk7XG4gICAgICAgIGlmIChjaHVuayA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCdUaGUgb3AgdHJhdmVyc2VzIG1vcmUgZWxlbWVudHMgdGhhbiB0aGUgZG9jdW1lbnQgaGFzJyk7XG5cbiAgICAgICAgYXBwZW5kKG5ld09wLCBjaHVuayk7XG4gICAgICAgIGlmICghY2h1bmsuaSkgbGVuIC09IGNvbXBvbmVudExlbmd0aChjaHVuayk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQXBwZW5kIGV4dHJhcyBmcm9tIG9wMS5cbiAgdmFyIGNvbXBvbmVudDtcbiAgd2hpbGUgKChjb21wb25lbnQgPSB0YWtlKCkpKSB7XG4gICAgaWYgKGNvbXBvbmVudC5pID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlbWFpbmluZyBmcmFnbWVudHMgaW4gdGhlIG9wOiBcIiArIGNvbXBvbmVudCk7XG4gICAgfVxuICAgIGFwcGVuZChuZXdPcCwgY29tcG9uZW50KTtcbiAgfVxuICByZXR1cm4gbmV3T3A7XG59O1xuXG4vLyB0cmFuc2Zvcm0gb3AxIGJ5IG9wMi4gUmV0dXJuIHRyYW5zZm9ybWVkIHZlcnNpb24gb2Ygb3AxLiBvcDEgYW5kIG9wMiBhcmVcbi8vIHVuY2hhbmdlZCBieSB0cmFuc2Zvcm0uIFNpZGUgc2hvdWxkIGJlICdsZWZ0JyBvciAncmlnaHQnLCBkZXBlbmRpbmcgb24gaWZcbi8vIG9wMS5pZCA8PiBvcDIuaWQuXG4vL1xuLy8gJ2xlZnQnID09IGNsaWVudCBvcCBmb3IgU2hhcmVKUy5cbnR5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24ob3AsIG90aGVyT3AsIHNpZGUpIHtcbiAgaWYgKHNpZGUgIT0gJ2xlZnQnICYmIHNpZGUgIT0gJ3JpZ2h0JylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJzaWRlIChcIiArIHNpZGUgKyBcIikgc2hvdWxkIGJlICdsZWZ0JyBvciAncmlnaHQnXCIpO1xuXG4gIHJldHVybiB0cmFuc2Zvcm1lcihvcCwgb3RoZXJPcCwgdHJ1ZSwgc2lkZSk7XG59O1xuXG50eXBlLnBydW5lID0gZnVuY3Rpb24ob3AsIG90aGVyT3ApIHtcbiAgcmV0dXJuIHRyYW5zZm9ybWVyKG9wLCBvdGhlck9wLCBmYWxzZSk7XG59O1xuXG50eXBlLmNvbXBvc2UgPSBmdW5jdGlvbihvcDEsIG9wMikge1xuICAvL3ZhciBjaHVuaywgY2h1bmtMZW5ndGgsIGNvbXBvbmVudCwgbGVuZ3RoLCByZXN1bHQsIHRha2UsIF8sIF9pLCBfbGVuLCBfcmVmO1xuICBpZiAob3AxID09IG51bGwpIHJldHVybiBvcDI7XG5cbiAgY2hlY2tPcChvcDEpO1xuICBjaGVja09wKG9wMik7XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgdGFrZSA9IG1ha2VUYWtlKG9wMSlbMF07XG4gIHZhciBjb21wb25lbnQ7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcDIubGVuZ3RoOyBpKyspIHtcbiAgICBjb21wb25lbnQgPSBvcDJbaV07XG4gICAgdmFyIGxlbiwgY2h1bms7XG5cbiAgICBpZiAodHlwZW9mIGNvbXBvbmVudCA9PT0gJ251bWJlcicpIHsgLy8gU2tpcFxuICAgICAgLy8gSnVzdCBjb3B5IGZyb20gb3AxLlxuICAgICAgbGVuID0gY29tcG9uZW50O1xuICAgICAgd2hpbGUgKGxlbiA+IDApIHtcbiAgICAgICAgY2h1bmsgPSB0YWtlKGxlbik7XG4gICAgICAgIGlmIChjaHVuayA9PT0gbnVsbClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBvcCB0cmF2ZXJzZXMgbW9yZSBlbGVtZW50cyB0aGFuIHRoZSBkb2N1bWVudCBoYXMnKTtcblxuICAgICAgICBhcHBlbmQocmVzdWx0LCBjaHVuayk7XG4gICAgICAgIGxlbiAtPSBjb21wb25lbnRMZW5ndGgoY2h1bmspO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChjb21wb25lbnQuaSAhPT0gdW5kZWZpbmVkKSB7IC8vIEluc2VydFxuICAgICAgYXBwZW5kKHJlc3VsdCwge2k6IGNvbXBvbmVudC5pfSk7XG5cbiAgICB9IGVsc2UgeyAvLyBEZWxldGVcbiAgICAgIGxlbiA9IGNvbXBvbmVudC5kO1xuICAgICAgd2hpbGUgKGxlbiA+IDApIHtcbiAgICAgICAgY2h1bmsgPSB0YWtlKGxlbik7XG4gICAgICAgIGlmIChjaHVuayA9PT0gbnVsbClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBvcCB0cmF2ZXJzZXMgbW9yZSBlbGVtZW50cyB0aGFuIHRoZSBkb2N1bWVudCBoYXMnKTtcblxuICAgICAgICB2YXIgY2h1bmtMZW5ndGggPSBjb21wb25lbnRMZW5ndGgoY2h1bmspO1xuXG4gICAgICAgIGlmIChjaHVuay5pICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgYXBwZW5kKHJlc3VsdCwge2k6IGNodW5rTGVuZ3RofSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBhcHBlbmQocmVzdWx0LCB7ZDogY2h1bmtMZW5ndGh9KTtcblxuICAgICAgICBsZW4gLT0gY2h1bmtMZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQXBwZW5kIGV4dHJhcyBmcm9tIG9wMS5cbiAgd2hpbGUgKChjb21wb25lbnQgPSB0YWtlKCkpKSB7XG4gICAgaWYgKGNvbXBvbmVudC5pID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlbWFpbmluZyBmcmFnbWVudHMgaW4gb3AxOiBcIiArIGNvbXBvbmVudCk7XG4gICAgfVxuICAgIGFwcGVuZChyZXN1bHQsIGNvbXBvbmVudCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxufSkoKSIsIi8qXG4gVGhpcyBpcyB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIEpTT04gT1QgdHlwZS5cblxuIFNwZWMgaXMgaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL2pvc2VwaGcvU2hhcmVKUy93aWtpL0pTT04tT3BlcmF0aW9uc1xuXG4gTm90ZTogVGhpcyBpcyBiZWluZyBtYWRlIG9ic29sZXRlLiBJdCB3aWxsIHNvb24gYmUgcmVwbGFjZWQgYnkgdGhlIEpTT04yIHR5cGUuXG4qL1xuXG4vKipcbiAqIFVUSUxJVFkgRlVOQ1RJT05TXG4gKi9cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHBhc3NlZCBvYmplY3QgaXMgYW4gQXJyYXkgaW5zdGFuY2UuIENhbid0IHVzZSBBcnJheS5pc0FycmF5XG4gKiB5ZXQgYmVjYXVzZSBpdHMgbm90IHN1cHBvcnRlZCBvbiBJRTguXG4gKlxuICogQHBhcmFtIG9ialxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbnZhciBpc0FycmF5ID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuLyoqXG4gKiBDbG9uZXMgdGhlIHBhc3NlZCBvYmplY3QgdXNpbmcgSlNPTiBzZXJpYWxpemF0aW9uICh3aGljaCBpcyBzbG93KS5cbiAqXG4gKiBoYXgsIGNvcGllZCBmcm9tIHRlc3QvdHlwZXMvanNvbi4gQXBwYXJlbnRseSB0aGlzIGlzIHN0aWxsIHRoZSBmYXN0ZXN0IHdheVxuICogdG8gZGVlcCBjbG9uZSBhbiBvYmplY3QsIGFzc3VtaW5nIHdlIGhhdmUgYnJvd3NlciBzdXBwb3J0IGZvciBKU09OLiAgQHNlZVxuICogaHR0cDovL2pzcGVyZi5jb20vY2xvbmluZy1hbi1vYmplY3QvMTJcbiAqL1xudmFyIGNsb25lID0gZnVuY3Rpb24obykge1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvKSk7XG59O1xuXG5cblxuLyoqXG4gKiBSZWZlcmVuY2UgdG8gdGhlIFRleHQgT1QgdHlwZS4gVGhpcyBpcyB1c2VkIGZvciB0aGUgSlNPTiBTdHJpbmcgb3BlcmF0aW9ucy5cbiAqIEB0eXBlIHsqfVxuICovXG52YXIgdGV4dCA9IHR5cGVvZiByZXF1aXJlICE9PSBcInVuZGVmaW5lZFwiID8gcmVxdWlyZSgnLi90ZXh0LW9sZCcpIDogd2luZG93Lm90dHlwZXMudGV4dDtcblxuXG5cbi8qKlxuICogSlNPTiBPVCBUeXBlXG4gKiBAdHlwZSB7Kn1cbiAqL1xudmFyIGpzb24gPSB7IFxuICBuYW1lOiAnanNvbjAnLFxuICB1cmk6ICdodHRwOi8vc2hhcmVqcy5vcmcvdHlwZXMvSlNPTnYwJ1xufTtcblxuanNvbi5jcmVhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gIC8vIE51bGwgaW5zdGVhZCBvZiB1bmRlZmluZWQgaWYgeW91IGRvbid0IHBhc3MgYW4gYXJndW1lbnQuXG4gIHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgPyBudWxsIDogZGF0YTtcbn07XG5cbmpzb24uaW52ZXJ0Q29tcG9uZW50ID0gZnVuY3Rpb24oYykge1xuICB2YXIgY18gPSB7cDogYy5wfTtcblxuICBpZiAoYy5zaSAhPT0gdm9pZCAwKSBjXy5zZCA9IGMuc2k7XG4gIGlmIChjLnNkICE9PSB2b2lkIDApIGNfLnNpID0gYy5zZDtcbiAgaWYgKGMub2kgIT09IHZvaWQgMCkgY18ub2QgPSBjLm9pO1xuICBpZiAoYy5vZCAhPT0gdm9pZCAwKSBjXy5vaSA9IGMub2Q7XG4gIGlmIChjLmxpICE9PSB2b2lkIDApIGNfLmxkID0gYy5saTtcbiAgaWYgKGMubGQgIT09IHZvaWQgMCkgY18ubGkgPSBjLmxkO1xuICBpZiAoYy5uYSAhPT0gdm9pZCAwKSBjXy5uYSA9IC1jLm5hO1xuXG4gIGlmIChjLmxtICE9PSB2b2lkIDApIHtcbiAgICBjXy5sbSA9IGMucFtjLnAubGVuZ3RoLTFdO1xuICAgIGNfLnAgPSBjLnAuc2xpY2UoMCxjLnAubGVuZ3RoLTEpLmNvbmNhdChbYy5sbV0pO1xuICB9XG5cbiAgcmV0dXJuIGNfO1xufTtcblxuanNvbi5pbnZlcnQgPSBmdW5jdGlvbihvcCkge1xuICB2YXIgb3BfID0gb3Auc2xpY2UoKS5yZXZlcnNlKCk7XG4gIHZhciBpb3AgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcF8ubGVuZ3RoOyBpKyspIHtcbiAgICBpb3AucHVzaChqc29uLmludmVydENvbXBvbmVudChvcF9baV0pKTtcbiAgfVxuICByZXR1cm4gaW9wO1xufTtcblxuanNvbi5jaGVja1ZhbGlkT3AgPSBmdW5jdGlvbihvcCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSsrKSB7XG4gIGlmICghaXNBcnJheShvcFtpXS5wKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcGF0aCcpO1xuICB9XG59O1xuXG5qc29uLmNoZWNrTGlzdCA9IGZ1bmN0aW9uKGVsZW0pIHtcbiAgaWYgKCFpc0FycmF5KGVsZW0pKVxuICAgIHRocm93IG5ldyBFcnJvcignUmVmZXJlbmNlZCBlbGVtZW50IG5vdCBhIGxpc3QnKTtcbn07XG5cbmpzb24uY2hlY2tPYmogPSBmdW5jdGlvbihlbGVtKSB7XG4gIGlmIChlbGVtLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWZlcmVuY2VkIGVsZW1lbnQgbm90IGFuIG9iamVjdCAoaXQgd2FzIFwiICsgSlNPTi5zdHJpbmdpZnkoZWxlbSkgKyBcIilcIik7XG4gIH1cbn07XG5cbmpzb24uYXBwbHkgPSBmdW5jdGlvbihzbmFwc2hvdCwgb3ApIHtcbiAganNvbi5jaGVja1ZhbGlkT3Aob3ApO1xuXG4gIG9wID0gY2xvbmUob3ApO1xuXG4gIHZhciBjb250YWluZXIgPSB7XG4gICAgZGF0YTogc25hcHNob3RcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGMgPSBvcFtpXTtcblxuICAgIHZhciBwYXJlbnQgPSBudWxsO1xuICAgIHZhciBwYXJlbnRLZXkgPSBudWxsO1xuICAgIHZhciBlbGVtID0gY29udGFpbmVyO1xuICAgIHZhciBrZXkgPSAnZGF0YSc7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGMucC5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHAgPSBjLnBbal07XG5cbiAgICAgIHBhcmVudCA9IGVsZW07XG4gICAgICBwYXJlbnRLZXkgPSBrZXk7XG4gICAgICBlbGVtID0gZWxlbVtrZXldO1xuICAgICAga2V5ID0gcDtcblxuICAgICAgaWYgKHBhcmVudCA9PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdGggaW52YWxpZCcpO1xuICAgIH1cblxuICAgIC8vIE51bWJlciBhZGRcbiAgICBpZiAoYy5uYSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAodHlwZW9mIGVsZW1ba2V5XSAhPSAnbnVtYmVyJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWZlcmVuY2VkIGVsZW1lbnQgbm90IGEgbnVtYmVyJyk7XG5cbiAgICAgIGVsZW1ba2V5XSArPSBjLm5hO1xuICAgIH1cblxuICAgIC8vIFN0cmluZyBpbnNlcnRcbiAgICBlbHNlIGlmIChjLnNpICE9PSB2b2lkIDApIHtcbiAgICAgIGlmICh0eXBlb2YgZWxlbSAhPSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWZlcmVuY2VkIGVsZW1lbnQgbm90IGEgc3RyaW5nIChpdCB3YXMgJytKU09OLnN0cmluZ2lmeShlbGVtKSsnKScpO1xuXG4gICAgICBwYXJlbnRbcGFyZW50S2V5XSA9IGVsZW0uc2xpY2UoMCxrZXkpICsgYy5zaSArIGVsZW0uc2xpY2Uoa2V5KTtcbiAgICB9XG5cbiAgICAvLyBTdHJpbmcgZGVsZXRlXG4gICAgZWxzZSBpZiAoYy5zZCAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAodHlwZW9mIGVsZW0gIT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVmZXJlbmNlZCBlbGVtZW50IG5vdCBhIHN0cmluZycpO1xuXG4gICAgICBpZiAoZWxlbS5zbGljZShrZXksa2V5ICsgYy5zZC5sZW5ndGgpICE9PSBjLnNkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlbGV0ZWQgc3RyaW5nIGRvZXMgbm90IG1hdGNoJyk7XG5cbiAgICAgIHBhcmVudFtwYXJlbnRLZXldID0gZWxlbS5zbGljZSgwLGtleSkgKyBlbGVtLnNsaWNlKGtleSArIGMuc2QubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvLyBMaXN0IHJlcGxhY2VcbiAgICBlbHNlIGlmIChjLmxpICE9PSB2b2lkIDAgJiYgYy5sZCAhPT0gdm9pZCAwKSB7XG4gICAgICBqc29uLmNoZWNrTGlzdChlbGVtKTtcbiAgICAgIC8vIFNob3VsZCBjaGVjayB0aGUgbGlzdCBlbGVtZW50IG1hdGNoZXMgYy5sZFxuICAgICAgZWxlbVtrZXldID0gYy5saTtcbiAgICB9XG5cbiAgICAvLyBMaXN0IGluc2VydFxuICAgIGVsc2UgaWYgKGMubGkgIT09IHZvaWQgMCkge1xuICAgICAganNvbi5jaGVja0xpc3QoZWxlbSk7XG4gICAgICBlbGVtLnNwbGljZShrZXksMCwgYy5saSk7XG4gICAgfVxuXG4gICAgLy8gTGlzdCBkZWxldGVcbiAgICBlbHNlIGlmIChjLmxkICE9PSB2b2lkIDApIHtcbiAgICAgIGpzb24uY2hlY2tMaXN0KGVsZW0pO1xuICAgICAgLy8gU2hvdWxkIGNoZWNrIHRoZSBsaXN0IGVsZW1lbnQgbWF0Y2hlcyBjLmxkIGhlcmUgdG9vLlxuICAgICAgZWxlbS5zcGxpY2Uoa2V5LDEpO1xuICAgIH1cblxuICAgIC8vIExpc3QgbW92ZVxuICAgIGVsc2UgaWYgKGMubG0gIT09IHZvaWQgMCkge1xuICAgICAganNvbi5jaGVja0xpc3QoZWxlbSk7XG4gICAgICBpZiAoYy5sbSAhPSBrZXkpIHtcbiAgICAgICAgdmFyIGUgPSBlbGVtW2tleV07XG4gICAgICAgIC8vIFJlbW92ZSBpdC4uLlxuICAgICAgICBlbGVtLnNwbGljZShrZXksMSk7XG4gICAgICAgIC8vIEFuZCBpbnNlcnQgaXQgYmFjay5cbiAgICAgICAgZWxlbS5zcGxpY2UoYy5sbSwwLGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9iamVjdCBpbnNlcnQgLyByZXBsYWNlXG4gICAgZWxzZSBpZiAoYy5vaSAhPT0gdm9pZCAwKSB7XG4gICAgICBqc29uLmNoZWNrT2JqKGVsZW0pO1xuXG4gICAgICAvLyBTaG91bGQgY2hlY2sgdGhhdCBlbGVtW2tleV0gPT0gYy5vZFxuICAgICAgZWxlbVtrZXldID0gYy5vaTtcbiAgICB9XG5cbiAgICAvLyBPYmplY3QgZGVsZXRlXG4gICAgZWxzZSBpZiAoYy5vZCAhPT0gdm9pZCAwKSB7XG4gICAgICBqc29uLmNoZWNrT2JqKGVsZW0pO1xuXG4gICAgICAvLyBTaG91bGQgY2hlY2sgdGhhdCBlbGVtW2tleV0gPT0gYy5vZFxuICAgICAgZGVsZXRlIGVsZW1ba2V5XTtcbiAgICB9XG5cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCAvIG1pc3NpbmcgaW5zdHJ1Y3Rpb24gaW4gb3AnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29udGFpbmVyLmRhdGE7XG59O1xuXG4vLyBIZWxwZXIgZm9yIGluY3JlbWVudGFsbHkgYXBwbHlpbmcgYW4gb3BlcmF0aW9uIHRvIGEgc25hcHNob3QuIENhbGxzIHlpZWxkXG4vLyBhZnRlciBlYWNoIG9wIGNvbXBvbmVudCBoYXMgYmVlbiBhcHBsaWVkLlxuanNvbi5pbmNyZW1lbnRhbEFwcGx5ID0gZnVuY3Rpb24oc25hcHNob3QsIG9wLCBfeWllbGQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzbWFsbE9wID0gW29wW2ldXTtcbiAgICBzbmFwc2hvdCA9IGpzb24uYXBwbHkoc25hcHNob3QsIHNtYWxsT3ApO1xuICAgIC8vIEknZCBqdXN0IGNhbGwgdGhpcyB5aWVsZCwgYnV0IHRoYXRzIGEgcmVzZXJ2ZWQga2V5d29yZC4gQmFoIVxuICAgIF95aWVsZChzbWFsbE9wLCBzbmFwc2hvdCk7XG4gIH1cbiAgXG4gIHJldHVybiBzbmFwc2hvdDtcbn07XG5cbi8vIENoZWNrcyBpZiB0d28gcGF0aHMsIHAxIGFuZCBwMiBtYXRjaC5cbnZhciBwYXRoTWF0Y2hlcyA9IGpzb24ucGF0aE1hdGNoZXMgPSBmdW5jdGlvbihwMSwgcDIsIGlnbm9yZUxhc3QpIHtcbiAgaWYgKHAxLmxlbmd0aCAhPSBwMi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcDEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocDFbaV0gIT09IHAyW2ldICYmICghaWdub3JlTGFzdCB8fCBpICE9PSBwMS5sZW5ndGggLSAxKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIF9jb252ZXJ0VG9UZXh0Q29tcG9uZW50ID0gZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gIHZhciBuZXdDID0ge3A6IGNvbXBvbmVudC5wW2NvbXBvbmVudC5wLmxlbmd0aCAtIDFdfTtcbiAgaWYgKGNvbXBvbmVudC5zaSAhPSBudWxsKSB7XG4gICAgbmV3Qy5pID0gY29tcG9uZW50LnNpO1xuICB9IGVsc2Uge1xuICAgIG5ld0MuZCA9IGNvbXBvbmVudC5zZDtcbiAgfVxuICByZXR1cm4gbmV3Qztcbn07XG5cbmpzb24uYXBwZW5kID0gZnVuY3Rpb24oZGVzdCxjKSB7XG4gIGMgPSBjbG9uZShjKTtcblxuICB2YXIgbGFzdDtcblxuICBpZiAoZGVzdC5sZW5ndGggIT0gMCAmJiBwYXRoTWF0Y2hlcyhjLnAsIChsYXN0ID0gZGVzdFtkZXN0Lmxlbmd0aCAtIDFdKS5wKSkge1xuICAgIGlmIChsYXN0Lm5hICE9IG51bGwgJiYgYy5uYSAhPSBudWxsKSB7XG4gICAgICBkZXN0W2Rlc3QubGVuZ3RoIC0gMV0gPSB7cDogbGFzdC5wLCBuYTogbGFzdC5uYSArIGMubmF9O1xuICAgIH0gZWxzZSBpZiAobGFzdC5saSAhPT0gdW5kZWZpbmVkICYmIGMubGkgPT09IHVuZGVmaW5lZCAmJiBjLmxkID09PSBsYXN0LmxpKSB7XG4gICAgICAvLyBpbnNlcnQgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgZGVsZXRlIGJlY29tZXMgYSBub29wLlxuICAgICAgaWYgKGxhc3QubGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBsZWF2ZSB0aGUgZGVsZXRlIHBhcnQgb2YgdGhlIHJlcGxhY2VcbiAgICAgICAgZGVsZXRlIGxhc3QubGk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXN0LnBvcCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGFzdC5vZCAhPT0gdW5kZWZpbmVkICYmIGxhc3Qub2kgPT09IHVuZGVmaW5lZCAmJiBjLm9pICE9PSB1bmRlZmluZWQgJiYgYy5vZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBsYXN0Lm9pID0gYy5vaTtcbiAgICB9IGVsc2UgaWYgKGxhc3Qub2kgIT09IHVuZGVmaW5lZCAmJiBjLm9kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFRoZSBsYXN0IHBhdGggY29tcG9uZW50IGluc2VydGVkIHNvbWV0aGluZyB0aGF0IHRoZSBuZXcgY29tcG9uZW50IGRlbGV0ZXMgKG9yIHJlcGxhY2VzKS5cbiAgICAgIC8vIEp1c3QgbWVyZ2UgdGhlbS5cbiAgICAgIGlmIChjLm9pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGFzdC5vaSA9IGMub2k7XG4gICAgICB9IGVsc2UgaWYgKGxhc3Qub2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWxldGUgbGFzdC5vaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFuIGluc2VydCBkaXJlY3RseSBmb2xsb3dlZCBieSBhIGRlbGV0ZSB0dXJucyBpbnRvIGEgbm8tb3AgYW5kIGNhbiBiZSByZW1vdmVkLlxuICAgICAgICBkZXN0LnBvcCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYy5sbSAhPT0gdW5kZWZpbmVkICYmIGMucFtjLnAubGVuZ3RoIC0gMV0gPT09IGMubG0pIHtcbiAgICAgIC8vIGRvbid0IGRvIGFueXRoaW5nXG4gICAgfSBlbHNlIHtcbiAgICAgIGRlc3QucHVzaChjKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGVzdC5sZW5ndGggIT0gMCAmJiBwYXRoTWF0Y2hlcyhjLnAsIGxhc3QucCwgdHJ1ZSkpIHtcbiAgICBpZiAoKGMuc2kgIT0gbnVsbCB8fCBjLnNkICE9IG51bGwpICYmIChsYXN0LnNpICE9IG51bGwgfHwgbGFzdC5zZCAhPSBudWxsKSkge1xuICAgICAgLy8gVHJ5IHRvIGNvbXBvc2UgdGhlIHN0cmluZyBvcHMgdG9nZXRoZXIgdXNpbmcgdGV4dCdzIGVxdWl2YWxlbnQgbWV0aG9kc1xuICAgICAgdmFyIHRleHRPcCA9IFtfY29udmVydFRvVGV4dENvbXBvbmVudChsYXN0KV07XG4gICAgICB0ZXh0Ll9hcHBlbmQodGV4dE9wLCBfY29udmVydFRvVGV4dENvbXBvbmVudChjKSk7XG4gICAgICBcbiAgICAgIC8vIFRoZW4gY29udmVydCBiYWNrLlxuICAgICAgaWYgKHRleHRPcC5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgZGVzdC5wdXNoKGMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRleHRDID0gdGV4dE9wWzBdO1xuICAgICAgICBsYXN0LnBbbGFzdC5wLmxlbmd0aCAtIDFdID0gdGV4dEMucDtcbiAgICAgICAgaWYgKHRleHRDLmkgIT0gbnVsbClcbiAgICAgICAgICBsYXN0LnNpID0gdGV4dEMuaTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxhc3Quc2QgPSB0ZXh0Qy5kO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZXN0LnB1c2goYyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlc3QucHVzaChjKTtcbiAgfVxufTtcblxuanNvbi5jb21wb3NlID0gZnVuY3Rpb24ob3AxLG9wMikge1xuICBqc29uLmNoZWNrVmFsaWRPcChvcDEpO1xuICBqc29uLmNoZWNrVmFsaWRPcChvcDIpO1xuXG4gIHZhciBuZXdPcCA9IGNsb25lKG9wMSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcDIubGVuZ3RoOyBpKyspIHtcbiAgICBqc29uLmFwcGVuZChuZXdPcCxvcDJbaV0pO1xuICB9XG5cbiAgcmV0dXJuIG5ld09wO1xufTtcblxuanNvbi5ub3JtYWxpemUgPSBmdW5jdGlvbihvcCkge1xuICB2YXIgbmV3T3AgPSBbXTtcblxuICBvcCA9IGlzQXJyYXkob3ApID8gb3AgOiBbb3BdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3AubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYyA9IG9wW2ldO1xuICAgIGlmIChjLnAgPT0gbnVsbCkgYy5wID0gW107XG5cbiAgICBqc29uLmFwcGVuZChuZXdPcCxjKTtcbiAgfVxuXG4gIHJldHVybiBuZXdPcDtcbn07XG5cbi8vIFJldHVybnMgdHJ1ZSBpZiBhbiBvcCBhdCBvdGhlclBhdGggbWF5IGFmZmVjdCBhbiBvcCBhdCBwYXRoXG5qc29uLmNhbk9wQWZmZWN0T3AgPSBmdW5jdGlvbihvdGhlclBhdGgscGF0aCkge1xuICBpZiAob3RoZXJQYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRydWU7XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuXG4gIHBhdGggPSBwYXRoLnNsaWNlKDAscGF0aC5sZW5ndGggLSAxKTtcbiAgb3RoZXJQYXRoID0gb3RoZXJQYXRoLnNsaWNlKDAsb3RoZXJQYXRoLmxlbmd0aCAtIDEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3RoZXJQYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSBvdGhlclBhdGhbaV07XG4gICAgaWYgKGkgPj0gcGF0aC5sZW5ndGggfHwgcCAhPSBwYXRoW2ldKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBTYW1lXG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gdHJhbnNmb3JtIGMgc28gaXQgYXBwbGllcyB0byBhIGRvY3VtZW50IHdpdGggb3RoZXJDIGFwcGxpZWQuXG5qc29uLnRyYW5zZm9ybUNvbXBvbmVudCA9IGZ1bmN0aW9uKGRlc3QsIGMsIG90aGVyQywgdHlwZSkge1xuICBjID0gY2xvbmUoYyk7XG5cbiAgaWYgKGMubmEgIT09IHZvaWQgMClcbiAgICBjLnAucHVzaCgwKTtcblxuICBpZiAob3RoZXJDLm5hICE9PSB2b2lkIDApXG4gICAgb3RoZXJDLnAucHVzaCgwKTtcblxuICB2YXIgY29tbW9uO1xuICBpZiAoanNvbi5jYW5PcEFmZmVjdE9wKG90aGVyQy5wLCBjLnApKVxuICAgIGNvbW1vbiA9IG90aGVyQy5wLmxlbmd0aCAtIDE7XG5cbiAgdmFyIGNvbW1vbjI7XG4gIGlmIChqc29uLmNhbk9wQWZmZWN0T3AoYy5wLG90aGVyQy5wKSlcbiAgICBjb21tb24yID0gYy5wLmxlbmd0aCAtIDE7XG5cbiAgdmFyIGNwbGVuZ3RoID0gYy5wLmxlbmd0aDtcbiAgdmFyIG90aGVyQ3BsZW5ndGggPSBvdGhlckMucC5sZW5ndGg7XG5cbiAgaWYgKGMubmEgIT09IHZvaWQgMCkgLy8gaGF4XG4gICAgYy5wLnBvcCgpO1xuXG4gIGlmIChvdGhlckMubmEgIT09IHZvaWQgMClcbiAgICBvdGhlckMucC5wb3AoKTtcblxuICBpZiAob3RoZXJDLm5hKSB7XG4gICAgaWYgKGNvbW1vbjIgIT0gbnVsbCAmJiBvdGhlckNwbGVuZ3RoID49IGNwbGVuZ3RoICYmIG90aGVyQy5wW2NvbW1vbjJdID09IGMucFtjb21tb24yXSkge1xuICAgICAgaWYgKGMubGQgIT09IHZvaWQgMCkge1xuICAgICAgICB2YXIgb2MgPSBjbG9uZShvdGhlckMpO1xuICAgICAgICBvYy5wID0gb2MucC5zbGljZShjcGxlbmd0aCk7XG4gICAgICAgIGMubGQgPSBqc29uLmFwcGx5KGNsb25lKGMubGQpLFtvY10pO1xuICAgICAgfSBlbHNlIGlmIChjLm9kICE9PSB2b2lkIDApIHtcbiAgICAgICAgdmFyIG9jID0gY2xvbmUob3RoZXJDKTtcbiAgICAgICAgb2MucCA9IG9jLnAuc2xpY2UoY3BsZW5ndGgpO1xuICAgICAgICBjLm9kID0ganNvbi5hcHBseShjbG9uZShjLm9kKSxbb2NdKTtcbiAgICAgIH1cbiAgICB9XG4gICAganNvbi5hcHBlbmQoZGVzdCxjKTtcbiAgICByZXR1cm4gZGVzdDtcbiAgfVxuXG4gIC8vIGlmIGMgaXMgZGVsZXRpbmcgc29tZXRoaW5nLCBhbmQgdGhhdCB0aGluZyBpcyBjaGFuZ2VkIGJ5IG90aGVyQywgd2UgbmVlZCB0b1xuICAvLyB1cGRhdGUgYyB0byByZWZsZWN0IHRoYXQgY2hhbmdlIGZvciBpbnZlcnRpYmlsaXR5LlxuICAvLyBUT0RPIHRoaXMgaXMgcHJvYmFibHkgbm90IG5lZWRlZCBzaW5jZSB3ZSBkb24ndCBoYXZlIGludmVydGliaWxpdHlcbiAgaWYgKGNvbW1vbjIgIT0gbnVsbCAmJiBvdGhlckNwbGVuZ3RoID4gY3BsZW5ndGggJiYgYy5wW2NvbW1vbjJdID09IG90aGVyQy5wW2NvbW1vbjJdKSB7XG4gICAgaWYgKGMubGQgIT09IHZvaWQgMCkge1xuICAgICAgdmFyIG9jID0gY2xvbmUob3RoZXJDKTtcbiAgICAgIG9jLnAgPSBvYy5wLnNsaWNlKGNwbGVuZ3RoKTtcbiAgICAgIGMubGQgPSBqc29uLmFwcGx5KGNsb25lKGMubGQpLFtvY10pO1xuICAgIH0gZWxzZSBpZiAoYy5vZCAhPT0gdm9pZCAwKSB7XG4gICAgICB2YXIgb2MgPSBjbG9uZShvdGhlckMpO1xuICAgICAgb2MucCA9IG9jLnAuc2xpY2UoY3BsZW5ndGgpO1xuICAgICAgYy5vZCA9IGpzb24uYXBwbHkoY2xvbmUoYy5vZCksW29jXSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbW1vbiAhPSBudWxsKSB7XG4gICAgdmFyIGNvbW1vbk9wZXJhbmQgPSBjcGxlbmd0aCA9PSBvdGhlckNwbGVuZ3RoO1xuXG4gICAgLy8gdHJhbnNmb3JtIGJhc2VkIG9uIG90aGVyQ1xuICAgIGlmIChvdGhlckMubmEgIT09IHZvaWQgMCkge1xuICAgICAgLy8gdGhpcyBjYXNlIGlzIGhhbmRsZWQgYWJvdmUgZHVlIHRvIGlja3kgcGF0aCBoYXhcbiAgICB9IGVsc2UgaWYgKG90aGVyQy5zaSAhPT0gdm9pZCAwIHx8IG90aGVyQy5zZCAhPT0gdm9pZCAwKSB7XG4gICAgICAvLyBTdHJpbmcgb3AgdnMgc3RyaW5nIG9wIC0gcGFzcyB0aHJvdWdoIHRvIHRleHQgdHlwZVxuICAgICAgaWYgKGMuc2kgIT09IHZvaWQgMCB8fCBjLnNkICE9PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKCFjb21tb25PcGVyYW5kKSB0aHJvdyBuZXcgRXJyb3IoJ211c3QgYmUgYSBzdHJpbmc/Jyk7XG5cbiAgICAgICAgLy8gQ29udmVydCBhbiBvcCBjb21wb25lbnQgdG8gYSB0ZXh0IG9wIGNvbXBvbmVudCBzbyB3ZSBjYW4gdXNlIHRoZVxuICAgICAgICAvLyB0ZXh0IHR5cGUncyB0cmFuc2Zvcm0gZnVuY3Rpb25cbiAgICAgICAgdmFyIHRjMSA9IF9jb252ZXJ0VG9UZXh0Q29tcG9uZW50KGMpO1xuICAgICAgICB2YXIgdGMyID0gX2NvbnZlcnRUb1RleHRDb21wb25lbnQob3RoZXJDKTtcblxuICAgICAgICB2YXIgcmVzID0gW107XG5cbiAgICAgICAgLy8gYWN0dWFsbHkgdHJhbnNmb3JtXG4gICAgICAgIHRleHQuX3RjKHJlcywgdGMxLCB0YzIsIHR5cGUpO1xuICAgICAgICBcbiAgICAgICAgLy8gLi4uLiB0aGVuIGNvbnZlcnQgdGhlIHJlc3VsdCBiYWNrIGludG8gYSBKU09OIG9wIGFnYWluLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIC8vIFRleHQgY29tcG9uZW50XG4gICAgICAgICAgdmFyIHRjID0gcmVzW2ldO1xuICAgICAgICAgIC8vIEpTT04gY29tcG9uZW50XG4gICAgICAgICAgdmFyIGpjID0ge3A6IGMucC5zbGljZSgwLCBjb21tb24pfTtcbiAgICAgICAgICBqYy5wLnB1c2godGMucCk7XG5cbiAgICAgICAgICBpZiAodGMuaSAhPSBudWxsKSBqYy5zaSA9IHRjLmk7XG4gICAgICAgICAgaWYgKHRjLmQgIT0gbnVsbCkgamMuc2QgPSB0Yy5kO1xuICAgICAgICAgIGpzb24uYXBwZW5kKGRlc3QsIGpjKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG90aGVyQy5saSAhPT0gdm9pZCAwICYmIG90aGVyQy5sZCAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAob3RoZXJDLnBbY29tbW9uXSA9PT0gYy5wW2NvbW1vbl0pIHtcbiAgICAgICAgLy8gbm9vcFxuXG4gICAgICAgIGlmICghY29tbW9uT3BlcmFuZCkge1xuICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICB9IGVsc2UgaWYgKGMubGQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIC8vIHdlJ3JlIHRyeWluZyB0byBkZWxldGUgdGhlIHNhbWUgZWxlbWVudCwgLT4gbm9vcFxuICAgICAgICAgIGlmIChjLmxpICE9PSB2b2lkIDAgJiYgdHlwZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICAvLyB3ZSdyZSBib3RoIHJlcGxhY2luZyBvbmUgZWxlbWVudCB3aXRoIGFub3RoZXIuIG9ubHkgb25lIGNhbiBzdXJ2aXZlXG4gICAgICAgICAgICBjLmxkID0gY2xvbmUob3RoZXJDLmxpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvdGhlckMubGkgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKGMubGkgIT09IHZvaWQgMCAmJiBjLmxkID09PSB1bmRlZmluZWQgJiYgY29tbW9uT3BlcmFuZCAmJiBjLnBbY29tbW9uXSA9PT0gb3RoZXJDLnBbY29tbW9uXSkge1xuICAgICAgICAvLyBpbiBsaSB2cy4gbGksIGxlZnQgd2lucy5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdyaWdodCcpXG4gICAgICAgICAgYy5wW2NvbW1vbl0rKztcbiAgICAgIH0gZWxzZSBpZiAob3RoZXJDLnBbY29tbW9uXSA8PSBjLnBbY29tbW9uXSkge1xuICAgICAgICBjLnBbY29tbW9uXSsrO1xuICAgICAgfVxuXG4gICAgICBpZiAoYy5sbSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmIChjb21tb25PcGVyYW5kKSB7XG4gICAgICAgICAgLy8gb3RoZXJDIGVkaXRzIHRoZSBzYW1lIGxpc3Qgd2UgZWRpdFxuICAgICAgICAgIGlmIChvdGhlckMucFtjb21tb25dIDw9IGMubG0pXG4gICAgICAgICAgICBjLmxtKys7XG4gICAgICAgICAgLy8gY2hhbmdpbmcgYy5mcm9tIGlzIGhhbmRsZWQgYWJvdmUuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG90aGVyQy5sZCAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAoYy5sbSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmIChjb21tb25PcGVyYW5kKSB7XG4gICAgICAgICAgaWYgKG90aGVyQy5wW2NvbW1vbl0gPT09IGMucFtjb21tb25dKSB7XG4gICAgICAgICAgICAvLyB0aGV5IGRlbGV0ZWQgdGhlIHRoaW5nIHdlJ3JlIHRyeWluZyB0byBtb3ZlXG4gICAgICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gb3RoZXJDIGVkaXRzIHRoZSBzYW1lIGxpc3Qgd2UgZWRpdFxuICAgICAgICAgIHZhciBwID0gb3RoZXJDLnBbY29tbW9uXTtcbiAgICAgICAgICB2YXIgZnJvbSA9IGMucFtjb21tb25dO1xuICAgICAgICAgIHZhciB0byA9IGMubG07XG4gICAgICAgICAgaWYgKHAgPCB0byB8fCAocCA9PT0gdG8gJiYgZnJvbSA8IHRvKSlcbiAgICAgICAgICAgIGMubG0tLTtcblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvdGhlckMucFtjb21tb25dIDwgYy5wW2NvbW1vbl0pIHtcbiAgICAgICAgYy5wW2NvbW1vbl0tLTtcbiAgICAgIH0gZWxzZSBpZiAob3RoZXJDLnBbY29tbW9uXSA9PT0gYy5wW2NvbW1vbl0pIHtcbiAgICAgICAgaWYgKG90aGVyQ3BsZW5ndGggPCBjcGxlbmd0aCkge1xuICAgICAgICAgIC8vIHdlJ3JlIGJlbG93IHRoZSBkZWxldGVkIGVsZW1lbnQsIHNvIC0+IG5vb3BcbiAgICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgICAgfSBlbHNlIGlmIChjLmxkICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBpZiAoYy5saSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAvLyB3ZSdyZSByZXBsYWNpbmcsIHRoZXkncmUgZGVsZXRpbmcuIHdlIGJlY29tZSBhbiBpbnNlcnQuXG4gICAgICAgICAgICBkZWxldGUgYy5sZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gd2UncmUgdHJ5aW5nIHRvIGRlbGV0ZSB0aGUgc2FtZSBlbGVtZW50LCAtPiBub29wXG4gICAgICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAob3RoZXJDLmxtICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChjLmxtICE9PSB2b2lkIDAgJiYgY3BsZW5ndGggPT09IG90aGVyQ3BsZW5ndGgpIHtcbiAgICAgICAgLy8gbG0gdnMgbG0sIGhlcmUgd2UgZ28hXG4gICAgICAgIHZhciBmcm9tID0gYy5wW2NvbW1vbl07XG4gICAgICAgIHZhciB0byA9IGMubG07XG4gICAgICAgIHZhciBvdGhlckZyb20gPSBvdGhlckMucFtjb21tb25dO1xuICAgICAgICB2YXIgb3RoZXJUbyA9IG90aGVyQy5sbTtcbiAgICAgICAgaWYgKG90aGVyRnJvbSAhPT0gb3RoZXJUbykge1xuICAgICAgICAgIC8vIGlmIG90aGVyRnJvbSA9PSBvdGhlclRvLCB3ZSBkb24ndCBuZWVkIHRvIGNoYW5nZSBvdXIgb3AuXG5cbiAgICAgICAgICAvLyB3aGVyZSBkaWQgbXkgdGhpbmcgZ28/XG4gICAgICAgICAgaWYgKGZyb20gPT09IG90aGVyRnJvbSkge1xuICAgICAgICAgICAgLy8gdGhleSBtb3ZlZCBpdCEgdGllIGJyZWFrLlxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICBjLnBbY29tbW9uXSA9IG90aGVyVG87XG4gICAgICAgICAgICAgIGlmIChmcm9tID09PSB0bykgLy8gdWdoXG4gICAgICAgICAgICAgICAgYy5sbSA9IG90aGVyVG87XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhleSBtb3ZlZCBhcm91bmQgaXRcbiAgICAgICAgICAgIGlmIChmcm9tID4gb3RoZXJGcm9tKSBjLnBbY29tbW9uXS0tO1xuICAgICAgICAgICAgaWYgKGZyb20gPiBvdGhlclRvKSBjLnBbY29tbW9uXSsrO1xuICAgICAgICAgICAgZWxzZSBpZiAoZnJvbSA9PT0gb3RoZXJUbykge1xuICAgICAgICAgICAgICBpZiAob3RoZXJGcm9tID4gb3RoZXJUbykge1xuICAgICAgICAgICAgICAgIGMucFtjb21tb25dKys7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPT09IHRvKSAvLyB1Z2gsIGFnYWluXG4gICAgICAgICAgICAgICAgICBjLmxtKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc3RlcCAyOiB3aGVyZSBhbSBpIGdvaW5nIHRvIHB1dCBpdD9cbiAgICAgICAgICAgIGlmICh0byA+IG90aGVyRnJvbSkge1xuICAgICAgICAgICAgICBjLmxtLS07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRvID09PSBvdGhlckZyb20pIHtcbiAgICAgICAgICAgICAgaWYgKHRvID4gZnJvbSlcbiAgICAgICAgICAgICAgICBjLmxtLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG8gPiBvdGhlclRvKSB7XG4gICAgICAgICAgICAgIGMubG0rKztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG8gPT09IG90aGVyVG8pIHtcbiAgICAgICAgICAgICAgLy8gaWYgd2UncmUgYm90aCBtb3ZpbmcgaW4gdGhlIHNhbWUgZGlyZWN0aW9uLCB0aWUgYnJlYWtcbiAgICAgICAgICAgICAgaWYgKChvdGhlclRvID4gb3RoZXJGcm9tICYmIHRvID4gZnJvbSkgfHxcbiAgICAgICAgICAgICAgICAgIChvdGhlclRvIDwgb3RoZXJGcm9tICYmIHRvIDwgZnJvbSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3JpZ2h0JykgYy5sbSsrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0byA+IGZyb20pIGMubG0rKztcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0byA9PT0gb3RoZXJGcm9tKSBjLmxtLS07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYy5saSAhPT0gdm9pZCAwICYmIGMubGQgPT09IHVuZGVmaW5lZCAmJiBjb21tb25PcGVyYW5kKSB7XG4gICAgICAgIC8vIGxpXG4gICAgICAgIHZhciBmcm9tID0gb3RoZXJDLnBbY29tbW9uXTtcbiAgICAgICAgdmFyIHRvID0gb3RoZXJDLmxtO1xuICAgICAgICBwID0gYy5wW2NvbW1vbl07XG4gICAgICAgIGlmIChwID4gZnJvbSkgYy5wW2NvbW1vbl0tLTtcbiAgICAgICAgaWYgKHAgPiB0bykgYy5wW2NvbW1vbl0rKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGxkLCBsZCtsaSwgc2ksIHNkLCBuYSwgb2ksIG9kLCBvaStvZCwgYW55IGxpIG9uIGFuIGVsZW1lbnQgYmVuZWF0aFxuICAgICAgICAvLyB0aGUgbG1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gaS5lLiB0aGluZ3MgY2FyZSBhYm91dCB3aGVyZSB0aGVpciBpdGVtIGlzIGFmdGVyIHRoZSBtb3ZlLlxuICAgICAgICB2YXIgZnJvbSA9IG90aGVyQy5wW2NvbW1vbl07XG4gICAgICAgIHZhciB0byA9IG90aGVyQy5sbTtcbiAgICAgICAgcCA9IGMucFtjb21tb25dO1xuICAgICAgICBpZiAocCA9PT0gZnJvbSkge1xuICAgICAgICAgIGMucFtjb21tb25dID0gdG87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHAgPiBmcm9tKSBjLnBbY29tbW9uXS0tO1xuICAgICAgICAgIGlmIChwID4gdG8pIGMucFtjb21tb25dKys7XG4gICAgICAgICAgZWxzZSBpZiAocCA9PT0gdG8gJiYgZnJvbSA+IHRvKSBjLnBbY29tbW9uXSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG90aGVyQy5vaSAhPT0gdm9pZCAwICYmIG90aGVyQy5vZCAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAoYy5wW2NvbW1vbl0gPT09IG90aGVyQy5wW2NvbW1vbl0pIHtcbiAgICAgICAgaWYgKGMub2kgIT09IHZvaWQgMCAmJiBjb21tb25PcGVyYW5kKSB7XG4gICAgICAgICAgLy8gd2UgaW5zZXJ0ZWQgd2hlcmUgc29tZW9uZSBlbHNlIHJlcGxhY2VkXG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIC8vIGxlZnQgd2luc1xuICAgICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdlIHdpbiwgbWFrZSBvdXIgb3AgcmVwbGFjZSB3aGF0IHRoZXkgaW5zZXJ0ZWRcbiAgICAgICAgICAgIGMub2QgPSBvdGhlckMub2k7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIC0+IG5vb3AgaWYgdGhlIG90aGVyIGNvbXBvbmVudCBpcyBkZWxldGluZyB0aGUgc2FtZSBvYmplY3QgKG9yIGFueSBwYXJlbnQpXG4gICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG90aGVyQy5vaSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAoYy5vaSAhPT0gdm9pZCAwICYmIGMucFtjb21tb25dID09PSBvdGhlckMucFtjb21tb25dKSB7XG4gICAgICAgIC8vIGxlZnQgd2lucyBpZiB3ZSB0cnkgdG8gaW5zZXJ0IGF0IHRoZSBzYW1lIHBsYWNlXG4gICAgICAgIGlmICh0eXBlID09PSAnbGVmdCcpIHtcbiAgICAgICAgICBqc29uLmFwcGVuZChkZXN0LHtwOiBjLnAsIG9kOm90aGVyQy5vaX0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvdGhlckMub2QgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKGMucFtjb21tb25dID09IG90aGVyQy5wW2NvbW1vbl0pIHtcbiAgICAgICAgaWYgKCFjb21tb25PcGVyYW5kKVxuICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICBpZiAoYy5vaSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGVsZXRlIGMub2Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBqc29uLmFwcGVuZChkZXN0LGMpO1xuICByZXR1cm4gZGVzdDtcbn07XG5cbmlmICh0eXBlb2YgcmVxdWlyZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICByZXF1aXJlKCcuL2hlbHBlcnMnKS5fYm9vdHN0cmFwVHJhbnNmb3JtKGpzb24sIGpzb24udHJhbnNmb3JtQ29tcG9uZW50LCBqc29uLmNoZWNrVmFsaWRPcCwganNvbi5hcHBlbmQpO1xufSBlbHNlIHtcbiAgLy8gVGhpcyBpcyBraW5kIG9mIGF3ZnVsIC0gY29tZSB1cCB3aXRoIGEgYmV0dGVyIHdheSB0byBob29rIHRoaXMgaGVscGVyIGNvZGUgdXAuXG4gIGV4cG9ydHMuX2Jvb3RzdHJhcFRyYW5zZm9ybShqc29uLCBqc29uLnRyYW5zZm9ybUNvbXBvbmVudCwganNvbi5jaGVja1ZhbGlkT3AsIGpzb24uYXBwZW5kKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBqc29uO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjYuMlxuZXhwb3J0cy5fYm9vdHN0cmFwVHJhbnNmb3JtID0gZnVuY3Rpb24odHlwZSwgdHJhbnNmb3JtQ29tcG9uZW50LCBjaGVja1ZhbGlkT3AsIGFwcGVuZCkge1xuICB2YXIgdHJhbnNmb3JtQ29tcG9uZW50WCwgdHJhbnNmb3JtWDtcblxuICB0cmFuc2Zvcm1Db21wb25lbnRYID0gZnVuY3Rpb24obGVmdCwgcmlnaHQsIGRlc3RMZWZ0LCBkZXN0UmlnaHQpIHtcbiAgICB0cmFuc2Zvcm1Db21wb25lbnQoZGVzdExlZnQsIGxlZnQsIHJpZ2h0LCAnbGVmdCcpO1xuICAgIHJldHVybiB0cmFuc2Zvcm1Db21wb25lbnQoZGVzdFJpZ2h0LCByaWdodCwgbGVmdCwgJ3JpZ2h0Jyk7XG4gIH07XG4gIHR5cGUudHJhbnNmb3JtWCA9IHR5cGUudHJhbnNmb3JtWCA9IHRyYW5zZm9ybVggPSBmdW5jdGlvbihsZWZ0T3AsIHJpZ2h0T3ApIHtcbiAgICB2YXIgaywgbCwgbF8sIG5ld0xlZnRPcCwgbmV3UmlnaHRPcCwgbmV4dEMsIHIsIHJfLCByaWdodENvbXBvbmVudCwgX2ksIF9qLCBfaywgX2wsIF9sZW4sIF9sZW4xLCBfbGVuMiwgX2xlbjMsIF9yZWYsIF9yZWYxO1xuXG4gICAgY2hlY2tWYWxpZE9wKGxlZnRPcCk7XG4gICAgY2hlY2tWYWxpZE9wKHJpZ2h0T3ApO1xuICAgIG5ld1JpZ2h0T3AgPSBbXTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHJpZ2h0T3AubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIHJpZ2h0Q29tcG9uZW50ID0gcmlnaHRPcFtfaV07XG4gICAgICBuZXdMZWZ0T3AgPSBbXTtcbiAgICAgIGsgPSAwO1xuICAgICAgd2hpbGUgKGsgPCBsZWZ0T3AubGVuZ3RoKSB7XG4gICAgICAgIG5leHRDID0gW107XG4gICAgICAgIHRyYW5zZm9ybUNvbXBvbmVudFgobGVmdE9wW2tdLCByaWdodENvbXBvbmVudCwgbmV3TGVmdE9wLCBuZXh0Qyk7XG4gICAgICAgIGsrKztcbiAgICAgICAgaWYgKG5leHRDLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHJpZ2h0Q29tcG9uZW50ID0gbmV4dENbMF07XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dEMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgX3JlZiA9IGxlZnRPcC5zbGljZShrKTtcbiAgICAgICAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSBfcmVmLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICAgICAgbCA9IF9yZWZbX2pdO1xuICAgICAgICAgICAgYXBwZW5kKG5ld0xlZnRPcCwgbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJpZ2h0Q29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfcmVmMSA9IHRyYW5zZm9ybVgobGVmdE9wLnNsaWNlKGspLCBuZXh0QyksIGxfID0gX3JlZjFbMF0sIHJfID0gX3JlZjFbMV07XG4gICAgICAgICAgZm9yIChfayA9IDAsIF9sZW4yID0gbF8ubGVuZ3RoOyBfayA8IF9sZW4yOyBfaysrKSB7XG4gICAgICAgICAgICBsID0gbF9bX2tdO1xuICAgICAgICAgICAgYXBwZW5kKG5ld0xlZnRPcCwgbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoX2wgPSAwLCBfbGVuMyA9IHJfLmxlbmd0aDsgX2wgPCBfbGVuMzsgX2wrKykge1xuICAgICAgICAgICAgciA9IHJfW19sXTtcbiAgICAgICAgICAgIGFwcGVuZChuZXdSaWdodE9wLCByKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmlnaHRDb21wb25lbnQgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmlnaHRDb21wb25lbnQgIT0gbnVsbCkge1xuICAgICAgICBhcHBlbmQobmV3UmlnaHRPcCwgcmlnaHRDb21wb25lbnQpO1xuICAgICAgfVxuICAgICAgbGVmdE9wID0gbmV3TGVmdE9wO1xuICAgIH1cbiAgICByZXR1cm4gW2xlZnRPcCwgbmV3UmlnaHRPcF07XG4gIH07XG4gIHJldHVybiB0eXBlLnRyYW5zZm9ybSA9IHR5cGVbJ3RyYW5zZm9ybSddID0gZnVuY3Rpb24ob3AsIG90aGVyT3AsIHR5cGUpIHtcbiAgICBpZiAoISh0eXBlID09PSAnbGVmdCcgfHwgdHlwZSA9PT0gJ3JpZ2h0JykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInR5cGUgbXVzdCBiZSAnbGVmdCcgb3IgJ3JpZ2h0J1wiKTtcbiAgICB9XG4gICAgaWYgKG90aGVyT3AubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gb3A7XG4gICAgfVxuICAgIGlmIChvcC5sZW5ndGggPT09IDEgJiYgb3RoZXJPcC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1Db21wb25lbnQoW10sIG9wWzBdLCBvdGhlck9wWzBdLCB0eXBlKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdsZWZ0Jykge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybVgob3AsIG90aGVyT3ApWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtWChvdGhlck9wLCBvcClbMV07XG4gICAgfVxuICB9O1xufTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS42LjJcbnZhciBhcHBlbmQsIGNoZWNrVmFsaWRDb21wb25lbnQsIGNoZWNrVmFsaWRPcCwgaW52ZXJ0Q29tcG9uZW50LCBzdHJJbmplY3QsIHRleHQsIHRyYW5zZm9ybUNvbXBvbmVudCwgdHJhbnNmb3JtUG9zaXRpb247XG5cbnRleHQgPSB7XG4gIG5hbWU6ICd0ZXh0LW9sZCcsXG4gIHVyaTogJ2h0dHA6Ly9zaGFyZWpzLm9yZy90eXBlcy90ZXh0djAnLFxuICBjcmVhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnJztcbiAgfVxufTtcblxuc3RySW5qZWN0ID0gZnVuY3Rpb24oczEsIHBvcywgczIpIHtcbiAgcmV0dXJuIHMxLnNsaWNlKDAsIHBvcykgKyBzMiArIHMxLnNsaWNlKHBvcyk7XG59O1xuXG5jaGVja1ZhbGlkQ29tcG9uZW50ID0gZnVuY3Rpb24oYykge1xuICB2YXIgZF90eXBlLCBpX3R5cGU7XG5cbiAgaWYgKHR5cGVvZiBjLnAgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb21wb25lbnQgbWlzc2luZyBwb3NpdGlvbiBmaWVsZCcpO1xuICB9XG4gIGlfdHlwZSA9IHR5cGVvZiBjLmk7XG4gIGRfdHlwZSA9IHR5cGVvZiBjLmQ7XG4gIGlmICghKChpX3R5cGUgPT09ICdzdHJpbmcnKSBeIChkX3R5cGUgPT09ICdzdHJpbmcnKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbXBvbmVudCBuZWVkcyBhbiBpIG9yIGQgZmllbGQnKTtcbiAgfVxuICBpZiAoIShjLnAgPj0gMCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bvc2l0aW9uIGNhbm5vdCBiZSBuZWdhdGl2ZScpO1xuICB9XG59O1xuXG5jaGVja1ZhbGlkT3AgPSBmdW5jdGlvbihvcCkge1xuICB2YXIgYywgX2ksIF9sZW47XG5cbiAgZm9yIChfaSA9IDAsIF9sZW4gPSBvcC5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgIGMgPSBvcFtfaV07XG4gICAgY2hlY2tWYWxpZENvbXBvbmVudChjKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnRleHQuYXBwbHkgPSBmdW5jdGlvbihzbmFwc2hvdCwgb3ApIHtcbiAgdmFyIGNvbXBvbmVudCwgZGVsZXRlZCwgX2ksIF9sZW47XG5cbiAgY2hlY2tWYWxpZE9wKG9wKTtcbiAgZm9yIChfaSA9IDAsIF9sZW4gPSBvcC5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgIGNvbXBvbmVudCA9IG9wW19pXTtcbiAgICBpZiAoY29tcG9uZW50LmkgIT0gbnVsbCkge1xuICAgICAgc25hcHNob3QgPSBzdHJJbmplY3Qoc25hcHNob3QsIGNvbXBvbmVudC5wLCBjb21wb25lbnQuaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZWQgPSBzbmFwc2hvdC5zbGljZShjb21wb25lbnQucCwgY29tcG9uZW50LnAgKyBjb21wb25lbnQuZC5sZW5ndGgpO1xuICAgICAgaWYgKGNvbXBvbmVudC5kICE9PSBkZWxldGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlbGV0ZSBjb21wb25lbnQgJ1wiICsgY29tcG9uZW50LmQgKyBcIicgZG9lcyBub3QgbWF0Y2ggZGVsZXRlZCB0ZXh0ICdcIiArIGRlbGV0ZWQgKyBcIidcIik7XG4gICAgICB9XG4gICAgICBzbmFwc2hvdCA9IHNuYXBzaG90LnNsaWNlKDAsIGNvbXBvbmVudC5wKSArIHNuYXBzaG90LnNsaWNlKGNvbXBvbmVudC5wICsgY29tcG9uZW50LmQubGVuZ3RoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNuYXBzaG90O1xufTtcblxudGV4dC5fYXBwZW5kID0gYXBwZW5kID0gZnVuY3Rpb24obmV3T3AsIGMpIHtcbiAgdmFyIGxhc3QsIF9yZWYsIF9yZWYxO1xuXG4gIGlmIChjLmkgPT09ICcnIHx8IGMuZCA9PT0gJycpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG5ld09wLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXdPcC5wdXNoKGMpO1xuICB9IGVsc2Uge1xuICAgIGxhc3QgPSBuZXdPcFtuZXdPcC5sZW5ndGggLSAxXTtcbiAgICBpZiAoKGxhc3QuaSAhPSBudWxsKSAmJiAoYy5pICE9IG51bGwpICYmIChsYXN0LnAgPD0gKF9yZWYgPSBjLnApICYmIF9yZWYgPD0gKGxhc3QucCArIGxhc3QuaS5sZW5ndGgpKSkge1xuICAgICAgcmV0dXJuIG5ld09wW25ld09wLmxlbmd0aCAtIDFdID0ge1xuICAgICAgICBpOiBzdHJJbmplY3QobGFzdC5pLCBjLnAgLSBsYXN0LnAsIGMuaSksXG4gICAgICAgIHA6IGxhc3QucFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKChsYXN0LmQgIT0gbnVsbCkgJiYgKGMuZCAhPSBudWxsKSAmJiAoYy5wIDw9IChfcmVmMSA9IGxhc3QucCkgJiYgX3JlZjEgPD0gKGMucCArIGMuZC5sZW5ndGgpKSkge1xuICAgICAgcmV0dXJuIG5ld09wW25ld09wLmxlbmd0aCAtIDFdID0ge1xuICAgICAgICBkOiBzdHJJbmplY3QoYy5kLCBsYXN0LnAgLSBjLnAsIGxhc3QuZCksXG4gICAgICAgIHA6IGMucFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ld09wLnB1c2goYyk7XG4gICAgfVxuICB9XG59O1xuXG50ZXh0LmNvbXBvc2UgPSBmdW5jdGlvbihvcDEsIG9wMikge1xuICB2YXIgYywgbmV3T3AsIF9pLCBfbGVuO1xuXG4gIGNoZWNrVmFsaWRPcChvcDEpO1xuICBjaGVja1ZhbGlkT3Aob3AyKTtcbiAgbmV3T3AgPSBvcDEuc2xpY2UoKTtcbiAgZm9yIChfaSA9IDAsIF9sZW4gPSBvcDIubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICBjID0gb3AyW19pXTtcbiAgICBhcHBlbmQobmV3T3AsIGMpO1xuICB9XG4gIHJldHVybiBuZXdPcDtcbn07XG5cbnRleHQuY29tcHJlc3MgPSBmdW5jdGlvbihvcCkge1xuICByZXR1cm4gdGV4dC5jb21wb3NlKFtdLCBvcCk7XG59O1xuXG50ZXh0Lm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG9wKSB7XG4gIHZhciBjLCBuZXdPcCwgX2ksIF9sZW4sIF9yZWY7XG5cbiAgbmV3T3AgPSBbXTtcbiAgaWYgKChvcC5pICE9IG51bGwpIHx8IChvcC5wICE9IG51bGwpKSB7XG4gICAgb3AgPSBbb3BdO1xuICB9XG4gIGZvciAoX2kgPSAwLCBfbGVuID0gb3AubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICBjID0gb3BbX2ldO1xuICAgIGlmICgoX3JlZiA9IGMucCkgPT0gbnVsbCkge1xuICAgICAgYy5wID0gMDtcbiAgICB9XG4gICAgYXBwZW5kKG5ld09wLCBjKTtcbiAgfVxuICByZXR1cm4gbmV3T3A7XG59O1xuXG50cmFuc2Zvcm1Qb3NpdGlvbiA9IGZ1bmN0aW9uKHBvcywgYywgaW5zZXJ0QWZ0ZXIpIHtcbiAgaWYgKGMuaSAhPSBudWxsKSB7XG4gICAgaWYgKGMucCA8IHBvcyB8fCAoYy5wID09PSBwb3MgJiYgaW5zZXJ0QWZ0ZXIpKSB7XG4gICAgICByZXR1cm4gcG9zICsgYy5pLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHBvcyA8PSBjLnApIHtcbiAgICAgIHJldHVybiBwb3M7XG4gICAgfSBlbHNlIGlmIChwb3MgPD0gYy5wICsgYy5kLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGMucDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBvcyAtIGMuZC5sZW5ndGg7XG4gICAgfVxuICB9XG59O1xuXG50ZXh0LnRyYW5zZm9ybUN1cnNvciA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBvcCwgc2lkZSkge1xuICB2YXIgYywgaW5zZXJ0QWZ0ZXIsIF9pLCBfbGVuO1xuXG4gIGluc2VydEFmdGVyID0gc2lkZSA9PT0gJ3JpZ2h0JztcbiAgZm9yIChfaSA9IDAsIF9sZW4gPSBvcC5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgIGMgPSBvcFtfaV07XG4gICAgcG9zaXRpb24gPSB0cmFuc2Zvcm1Qb3NpdGlvbihwb3NpdGlvbiwgYywgaW5zZXJ0QWZ0ZXIpO1xuICB9XG4gIHJldHVybiBwb3NpdGlvbjtcbn07XG5cbnRleHQuX3RjID0gdHJhbnNmb3JtQ29tcG9uZW50ID0gZnVuY3Rpb24oZGVzdCwgYywgb3RoZXJDLCBzaWRlKSB7XG4gIHZhciBjSW50ZXJzZWN0LCBpbnRlcnNlY3RFbmQsIGludGVyc2VjdFN0YXJ0LCBuZXdDLCBvdGhlckludGVyc2VjdCwgcztcblxuICBjaGVja1ZhbGlkT3AoW2NdKTtcbiAgY2hlY2tWYWxpZE9wKFtvdGhlckNdKTtcbiAgaWYgKGMuaSAhPSBudWxsKSB7XG4gICAgYXBwZW5kKGRlc3QsIHtcbiAgICAgIGk6IGMuaSxcbiAgICAgIHA6IHRyYW5zZm9ybVBvc2l0aW9uKGMucCwgb3RoZXJDLCBzaWRlID09PSAncmlnaHQnKVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChvdGhlckMuaSAhPSBudWxsKSB7XG4gICAgICBzID0gYy5kO1xuICAgICAgaWYgKGMucCA8IG90aGVyQy5wKSB7XG4gICAgICAgIGFwcGVuZChkZXN0LCB7XG4gICAgICAgICAgZDogcy5zbGljZSgwLCBvdGhlckMucCAtIGMucCksXG4gICAgICAgICAgcDogYy5wXG4gICAgICAgIH0pO1xuICAgICAgICBzID0gcy5zbGljZShvdGhlckMucCAtIGMucCk7XG4gICAgICB9XG4gICAgICBpZiAocyAhPT0gJycpIHtcbiAgICAgICAgYXBwZW5kKGRlc3QsIHtcbiAgICAgICAgICBkOiBzLFxuICAgICAgICAgIHA6IGMucCArIG90aGVyQy5pLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGMucCA+PSBvdGhlckMucCArIG90aGVyQy5kLmxlbmd0aCkge1xuICAgICAgICBhcHBlbmQoZGVzdCwge1xuICAgICAgICAgIGQ6IGMuZCxcbiAgICAgICAgICBwOiBjLnAgLSBvdGhlckMuZC5sZW5ndGhcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGMucCArIGMuZC5sZW5ndGggPD0gb3RoZXJDLnApIHtcbiAgICAgICAgYXBwZW5kKGRlc3QsIGMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3QyA9IHtcbiAgICAgICAgICBkOiAnJyxcbiAgICAgICAgICBwOiBjLnBcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGMucCA8IG90aGVyQy5wKSB7XG4gICAgICAgICAgbmV3Qy5kID0gYy5kLnNsaWNlKDAsIG90aGVyQy5wIC0gYy5wKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYy5wICsgYy5kLmxlbmd0aCA+IG90aGVyQy5wICsgb3RoZXJDLmQubGVuZ3RoKSB7XG4gICAgICAgICAgbmV3Qy5kICs9IGMuZC5zbGljZShvdGhlckMucCArIG90aGVyQy5kLmxlbmd0aCAtIGMucCk7XG4gICAgICAgIH1cbiAgICAgICAgaW50ZXJzZWN0U3RhcnQgPSBNYXRoLm1heChjLnAsIG90aGVyQy5wKTtcbiAgICAgICAgaW50ZXJzZWN0RW5kID0gTWF0aC5taW4oYy5wICsgYy5kLmxlbmd0aCwgb3RoZXJDLnAgKyBvdGhlckMuZC5sZW5ndGgpO1xuICAgICAgICBjSW50ZXJzZWN0ID0gYy5kLnNsaWNlKGludGVyc2VjdFN0YXJ0IC0gYy5wLCBpbnRlcnNlY3RFbmQgLSBjLnApO1xuICAgICAgICBvdGhlckludGVyc2VjdCA9IG90aGVyQy5kLnNsaWNlKGludGVyc2VjdFN0YXJ0IC0gb3RoZXJDLnAsIGludGVyc2VjdEVuZCAtIG90aGVyQy5wKTtcbiAgICAgICAgaWYgKGNJbnRlcnNlY3QgIT09IG90aGVySW50ZXJzZWN0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWxldGUgb3BzIGRlbGV0ZSBkaWZmZXJlbnQgdGV4dCBpbiB0aGUgc2FtZSByZWdpb24gb2YgdGhlIGRvY3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0MuZCAhPT0gJycpIHtcbiAgICAgICAgICBuZXdDLnAgPSB0cmFuc2Zvcm1Qb3NpdGlvbihuZXdDLnAsIG90aGVyQyk7XG4gICAgICAgICAgYXBwZW5kKGRlc3QsIG5ld0MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkZXN0O1xufTtcblxuaW52ZXJ0Q29tcG9uZW50ID0gZnVuY3Rpb24oYykge1xuICBpZiAoYy5pICE9IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZDogYy5pLFxuICAgICAgcDogYy5wXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgaTogYy5kLFxuICAgICAgcDogYy5wXG4gICAgfTtcbiAgfVxufTtcblxudGV4dC5pbnZlcnQgPSBmdW5jdGlvbihvcCkge1xuICB2YXIgYywgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuXG4gIF9yZWYgPSBvcC5zbGljZSgpLnJldmVyc2UoKTtcbiAgX3Jlc3VsdHMgPSBbXTtcbiAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgYyA9IF9yZWZbX2ldO1xuICAgIF9yZXN1bHRzLnB1c2goaW52ZXJ0Q29tcG9uZW50KGMpKTtcbiAgfVxuICByZXR1cm4gX3Jlc3VsdHM7XG59O1xuXG5pZiAodHlwZW9mIHJlcXVpcmUgPT09ICd1bmRlZmluZWQnKSB7XG4gIGV4cG9ydHMuX2Jvb3RzdHJhcFRyYW5zZm9ybSh0ZXh0LCB0ZXh0LnRyYW5zZm9ybUNvbXBvbmVudCwgdGV4dC5jaGVja1ZhbGlkT3AsIHRleHQuYXBwZW5kKTtcbn0gZWxzZSB7XG4gIHJlcXVpcmUoJy4vaGVscGVycycpLl9ib290c3RyYXBUcmFuc2Zvcm0odGV4dCwgdGV4dC50cmFuc2Zvcm1Db21wb25lbnQsIHRleHQuY2hlY2tWYWxpZE9wLCB0ZXh0LmFwcGVuZCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGV4dDtcbiJdfQ==
;
(function() {
var view = require("derby").app.view;
view._makeAll({
  "app/403.html:body": "<div class=\"container\"><div class=\"page-header\"><h1>403</h1></div><p class=\"lead\">We're sorry, page is forbidden.</p></div>",
  "app/403.html:title": "403",
  "app/404.html:body": "<div class=\"container\"><div class=\"page-header\"><h1>404</h1></div><p class=\"lead\">We're sorry, page not found.</p></div>",
  "app/404.html:title": "404",
  "app/500.html:body": "<div class=\"container\"><div class=\"page-header\"><h1>500</h1></div><p class=\"lead\">We're sorry, something went wrong.</p></div>",
  "app/500.html:title": "500",
  "app/forgot.html:body": "<div class=\"container\"><div class=\"page-header\"><h1>Forgotten password?</h1></div>{#with _page.form}{#if .success}<p class=\"alert alert-success\"><i class=\"fa fa-check-circle\"></i> Password reset instructions were sent to your address.</p>{/}<form role=\"form\" x-bind=\"submit: user.forgotPassword\"><div class=\"form-group\"><label class=\"control-label\" for=\"usernameOrEmail\">Username or email</label><div class=\"input-group\"><span class=\"input-group-addon\"><i class=\"fa fa-user\"></i></span><input id=\"usernameOrEmail\" class=\"form-control\" autofocus placeholder=\"Username or email\" type=\"text\" value=\"{.usernameOrEmail}\"></div></div><div class=\"form-group\"><button class=\"btn btn-primary\" type=\"submit\"><i class=\"fa fa-envelope\"></i> Send</button></div></form>{/}</div>",
  "app/forgot.html:title": "Forgotten password?",
  "app/home.html:body": "<div class=\"jumbotron\"><div class=\"container\"><h1><i class=\"fa fa-user\"></i> Derby User</h1><p>A user management system for <a href=\"http://derbyjs.com\">Derby JS</a>.</p><p><a class=\"btn btn-primary btn-lg\" role=\"button\" href=\"{{$config.repository.url}}\"><i class=\"fa fa-github\"></i> View on GitHub</a></p><ghbtns:button count=\"true\" giturl=\"{{$config.repository.url}}\" type=\"watch\" width=\"90\"><ghbtns:button count=\"true\" giturl=\"{{$config.repository.url}}\" type=\"fork\" width=\"90\"><ghbtns:button count=\"true\" giturl=\"{{$config.repository.url}}\" type=\"follow\" width=\"180\"></div></div>",
  "app/home.html:title": "Derby User",
  "app/index.html:footer": "<hr><div class=\"container\"><div id=\"footer\"><p class=\"text-muted credit\">Derby User {{$config.version}}  <a href=\"{{$config.repository.url}}\"><i class=\"fa fa-github\"></i> GitHub Project</a></p></div></div>",
  "app/index.html:header": "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><link href=\"/shared/bower_components/bootstrap/dist/css/bootstrap.min.css\" rel=\"stylesheet\"><link href=\"/shared/bower_components/bootstrap/examples/jumbotron/jumbotron.css\" rel=\"stylesheet\"><link href=\"/shared/bower_components/font-awesome/css/font-awesome.min.css\" rel=\"stylesheet\"><ui:connectionAlert><header class=\"navbar navbar-inverse navbar-fixed-top\" role=\"navigation\"><div class=\"container\"><div class=\"navbar-header\"><button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\".navbar-collapse\"><span class=\"sr-only\">Toggle navigation</span><span class=\"icon-bar\"></span><span class=\"icon-bar\"></span><span class=\"icon-bar\"></span></button><a class=\"navbar-brand\" href=\"/\"><i class=\"fa fa-user\"></i> Derby User</a></div><div class=\"navbar-collapse collapse\"><ul class=\"nav navbar-nav\"><app:navitem href=\"/\" title=\"Home\">{#if _page.user.public.isRegistered}<app:navitem href=\"/settings\" title=\"Settings\"><li><a x-bind=\"click: user.signout\">Sign out</a></li>{else}<app:navitem href=\"/signup\" title=\"Sign up\"><app:navitem href=\"/signin\" title=\"Sign in\"><app:navitem href=\"/forgot\" title=\"Forgot\">{/}</ul>{#if _page.user.public.isRegistered}<ul class=\"nav navbar-nav navbar-right dropdown\"><li class=\"dropdown\"><a class=\"dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\">{#if user.photoUrl(_page.user.public)}<img alt=\"\" height=\"20\" src=\"{user.photoUrl(_page.user.public)}\" width=\"20\">{else}<i class=\"fa fa-user\"></i>{/}&nbsp;{user.displayName(_page.user.public)} <i class=\"fa fa-caret-down\"></i></a><ul class=\"dropdown-menu\"><li><a href=\"/settings\">Settings</a></li><li class=\"divider\"></li><li><a x-bind=\"click: user.signout\"><i class=\"fa fa-sign-out\"></i> Sign out</a></li></ul></li></ul>{else}{#with _page.form.navbar}<form class=\"navbar-form navbar-right\" x-bind=\"submit: user.signin\"><div class=\"form-group\"><label class=\"sr-only\" for=\"navUsernameOrEmail\">Username or email</label><input id=\"navUsernameOrEmail\" class=\"form-control\" placeholder=\"Username or email\" type=\"text\" value=\"{.usernameOrEmail}\"></div>&nbsp;<div class=\"form-group\"><label class=\"sr-only\" for=\"navPassword\">Password</label><input id=\"navPassword\" class=\"form-control\" placeholder=\"Password\" type=\"password\" value=\"{.password}\"></div>&nbsp;<div class=\"form-group\"><button class=\"btn btn-primary\" type=\"submit\"><i class=\"fa fa-sign-in\"></i> Sign in</button>&nbsp;<div class=\"btn-group\"><a class=\"btn btn-primary\" x-bind=\"click: user.connect.facebook\"><i class=\"fa fa-facebook\"></i></a><a class=\"btn btn-primary\" x-bind=\"click: user.connect.google\"><i class=\"fa fa-google-plus\"></i></a><a class=\"btn btn-primary\" x-bind=\"click: user.connect.twitter\"><i class=\"fa fa-twitter\"></i></a></div></div></form>{/}{/}</div></div></header>{#if _page.user.public.isRegistered}{#if not(_page.user.private.local.emails.0.value)}<div class=\"container\"><div class=\"alert alert-warning\"><p><i class=\"fa fa-exclamation-circle\"></i> <a href=\"/settings\">Please set your email address</a>.</p></div></div>{else if not(_page.user.private.local.emails.0.verified)}<div class=\"container\"><div class=\"alert alert-warning\"><p>Please confirm your email address. A confirmation message was sent to <strong>{_page.user.private.local.emails.0.value}</strong>.</p>{#with _page.form.verifyEmail}<p><a class=\"btn btn-default\" x-bind=\"click: user.verifyEmail\"><i class=\"fa fa-repeat\"></i> Resend confirmation</a> <a href=\"/settings\">Update email address</a>.</p>{/}</div></div>{/}{/}",
  "app/index.html:navitem": "<li class=\"{{#if equal($url, @href)}}active{{/}}\"><a href=\"{{@href}}\">{{@title}}</a></li>",
  "app/index.html:scripts": "<script src=\"/shared/bower_components/jquery/jquery.min.js\"></script><script src=\"/shared/bower_components/bootstrap/dist/js/bootstrap.min.js\"></script><script src=\"/shared/bower_components/jquery-popupwindow/jquery.popupwindow.js\"></script>",
  "app/reset.html:body": "<div class=\"container\"><div class=\"page-header\"><h1>Reset your password</h1></div>{#with _page.form}<form role=\"form\" x-bind=\"submit: user.resetPassword\"><div class=\"form-group\"><label class=\"control-label\" for=\"password\">Password</label><div class=\"input-group\"><span class=\"input-group-addon\"><i class=\"fa fa-key\"></i></span><input id=\"password\" class=\"form-control\" autofocus placeholder=\"Password\" type=\"password\" value=\"{.password}\"></div></div><div class=\"form-group\"><label class=\"control-label\" for=\"confirmPassword\">Confirm password</label><div class=\"input-group\"><span class=\"input-group-addon\"><i class=\"fa fa-key\"></i></span><input id=\"confirmPassword\" class=\"form-control\" placeholder=\"Confirm password\" type=\"password\" value=\"{.confirmPassword}\"></div></div><div class=\"form-group\"><button class=\"btn btn-primary\" type=\"submit\">Reset</button></div><input name=\"token\" type=\"hidden\" value=\"{{.token}}\"><input name=\"userId\" type=\"hidden\" value=\"{{.userId}}\"></form>{/}</div>",
  "app/reset.html:title": "Reset your password",
  "app/settings.html:body": "<div class=\"container\"><div class=\"page-header\"><h1>Settings</h1></div>{#with _page.form.username}<form role=\"form\" x-bind=\"submit: user.changeUsername\"><legend>Change username</legend><div class=\"form-group\"><label class=\"control-label\" for=\"username\">Username</label><div class=\"input-group\"><span class=\"input-group-addon\"><i class=\"fa fa-user\"></i></span><input id=\"username\" class=\"form-control\" placeholder=\"Username\" type=\"text\" value=\"{.username}\"></div></div><div class=\"form-group\"><button class=\"btn btn-primary\" type=\"submit\">Change</button></div></form>{/}{#with _page.form.email}<form role=\"form\" x-bind=\"submit: user.changeEmail\"><legend>Change email</legend><div class=\"form-group\"><label class=\"control-label\" for=\"email\">Email</label><div class=\"input-group\"><span class=\"input-group-addon\"><i class=\"fa fa-envelope\"></i></span><input id=\"email\" class=\"form-control\" placeholder=\"Email\" type=\"text\" value=\"{.email}\"></div><p class=\"help-block\">Change your avatar at <i class=\"fa fa-external-link-square\"></i> <a href=\"http:http://www.gravatar.com\">Gravatar.com</a>.</p></div><div class=\"form-group\"><button class=\"btn btn-primary\" type=\"submit\">Change</button></div></form>{/}{#with _page.form.password}<form role=\"form\" x-bind=\"submit: user.changePassword\"><legend>Change password</legend><div class=\"form-group\"><label class=\"control-label\" for=\"password\">Password</label><div class=\"input-group\"><span class=\"input-group-addon\"><i class=\"fa fa-key\"></i></span><input id=\"password\" class=\"form-control\" placeholder=\"Password\" type=\"password\" value=\"{.password}\"></div></div><div class=\"form-group\"><label class=\"control-label\" for=\"confirmPassword\">Confirm password</label><div class=\"input-group\"><span class=\"input-group-addon\"><i class=\"fa fa-key\"></i></span><input id=\"confirmPassword\" class=\"form-control\" placeholder=\"Confirm password\" type=\"password\" value=\"{.confirmPassword}\"></div></div><div class=\"form-group\"><button class=\"btn btn-primary\" type=\"submit\">Change</button></div></form>{/}</div>",
  "app/settings.html:title": "Settings",
  "app/signin.html:body": "<div class=\"container\"><div class=\"page-header\"><h1>Sign in</h1></div>{#with _page.form}<form role=\"form\" x-bind=\"submit: user.signin\"><div class=\"form-group\"><label class=\"control-label\" for=\"usernameOrEmail\">Username or email</label><div class=\"input-group\"><span class=\"input-group-addon\"><i class=\"fa fa-user\"></i></span><input id=\"usernameOrEmail\" class=\"form-control\" autofocus placeholder=\"Username or email\" type=\"text\" value=\"{.usernameOrEmail}\"></div></div><div class=\"form-group\"><label class=\"control-label\" for=\"password\">Password</label><div class=\"input-group\"><span class=\"input-group-addon\"><i class=\"fa fa-key\"></i></span><input id=\"password\" class=\"form-control\" placeholder=\"Password\" type=\"password\" value=\"{.password}\"></div></div><div class=\"form-group\"><button class=\"btn btn-primary\" type=\"submit\"><i class=\"fa fa-sign-in\"></i> Sign in</button> <a href=\"/forgot\">Forgot your password?</a></div></form>{/}<hr><p class=\"lead\">Or sign up using</p><div class=\"visible-xs\"><a class=\"btn btn-default\" x-bind=\"click: user.connect.facebook\"><i class=\"fa fa-facebook fa-lg\"></i></a> <a class=\"btn btn-default\" x-bind=\"click: user.connect.google\"><i class=\"fa fa-google-plus fa-lg\"></i></a> <a class=\"btn btn-default\" x-bind=\"click: user.connect.twitter\"><i class=\"fa fa-twitter fa-lg\"></i></a></div><div class=\"hidden-xs\"><a class=\"btn btn-default\" x-bind=\"click: user.connect.facebook\"><i class=\"fa fa-facebook-square\"></i> Facebook</a> <a class=\"btn btn-default\" x-bind=\"click: user.connect.google\"><i class=\"fa fa-google-plus-square\"></i> Google+</a> <a class=\"btn btn-default\" x-bind=\"click: user.connect.twitter\"><i class=\"fa fa-twitter-square\"></i> Twitter</a></div></div>",
  "app/signin.html:title": "Sign in",
  "app/signup.html:body": "<div class=\"container\"><div class=\"page-header\"><h1>Sign up</h1></div>{#with _page.form}<form role=\"form\" x-bind=\"submit: user.signup\"><div class=\"form-group\"><label class=\"control-label\" for=\"username\">Username</label><div class=\"input-group\"><span class=\"input-group-addon\"><i class=\"fa fa-user\"></i></span><input id=\"username\" class=\"form-control\" autofocus placeholder=\"Username\" type=\"text\" value=\"{.username}\"></div></div><div class=\"form-group\"><label class=\"control-label\" for=\"email\">Email</label><div class=\"input-group\"><span class=\"input-group-addon\"><i class=\"fa fa-envelope\"></i></span><input id=\"email\" class=\"form-control\" placeholder=\"Email\" type=\"email\" value=\"{.email}\"></div></div><div class=\"form-group\"><label class=\"control-label\" for=\"password\">Password</label><div class=\"input-group\"><span class=\"input-group-addon\"><i class=\"fa fa-key\"></i></span><input id=\"password\" class=\"form-control\" placeholder=\"Password\" type=\"password\" value=\"{.password}\"></div></div><button class=\"btn btn-primary\" type=\"submit\">Sign up</button></form>{/}<hr><p class=\"lead\">Or sign up using</p><div class=\"visible-xs\"><a class=\"btn btn-default\" x-bind=\"click: user.connect.facebook\"><i class=\"fa fa-facebook fa-lg\"></i></a> <a class=\"btn btn-default\" x-bind=\"click: user.connect.google\"><i class=\"fa fa-google-plus fa-lg\"></i></a> <a class=\"btn btn-default\" x-bind=\"click: user.connect.twitter\"><i class=\"fa fa-twitter fa-lg\"></i></a></div><div class=\"hidden-xs\"><a class=\"btn btn-default\" x-bind=\"click: user.connect.facebook\"><i class=\"fa fa-facebook-square\"></i> Facebook</a> <a class=\"btn btn-default\" x-bind=\"click: user.connect.google\"><i class=\"fa fa-google-plus-square\"></i> Google+</a> <a class=\"btn btn-default\" x-bind=\"click: user.connect.twitter\"><i class=\"fa fa-twitter-square\"></i> Twitter</a></div></div>",
  "app/signup.html:title": "Sign up"
}, {
  "403:body": [
  "app/403.html:body",
  {}
],
  "403:title": [
  "app/403.html:title",
  {}
],
  "404:body": [
  "app/404.html:body",
  {}
],
  "404:title": [
  "app/404.html:title",
  {}
],
  "500:body": [
  "app/500.html:body",
  {}
],
  "500:title": [
  "app/500.html:title",
  {}
],
  "footer": [
  "app/index.html:footer",
  {}
],
  "forgot:body": [
  "app/forgot.html:body",
  {}
],
  "forgot:title": [
  "app/forgot.html:title",
  {}
],
  "header": [
  "app/index.html:header",
  {}
],
  "home:body": [
  "app/home.html:body",
  {}
],
  "home:title": [
  "app/home.html:title",
  {}
],
  "navitem": [
  "app/index.html:navitem",
  {}
],
  "reset:body": [
  "app/reset.html:body",
  {}
],
  "reset:title": [
  "app/reset.html:title",
  {}
],
  "scripts": [
  "app/index.html:scripts",
  {}
],
  "settings:body": [
  "app/settings.html:body",
  {}
],
  "settings:title": [
  "app/settings.html:title",
  {}
],
  "signin:body": [
  "app/signin.html:body",
  {}
],
  "signin:title": [
  "app/signin.html:title",
  {}
],
  "signup:body": [
  "app/signup.html:body",
  {}
],
  "signup:title": [
  "app/signup.html:title",
  {}
]
});
view._makeComponents({
  "ghbtns": {
  "instances": {
  "button": [
  "button/index.html:button",
  {}
]
},
  "templates": {
  "button/index.html:button": "{#if :self.show}<iframe allowtransparency=\"true\" frameborder=\"0\" height=\"{:self.height}\" scrolling=\"0\" src=\"{:self.fileurl}?user={:self.user}&repo={:self.repo}&type={@type}{#if @count}&count={@count}{/}{#if @size}&size={@size}{/}\" width=\"{@width}\"></iframe>{/}"
}
},
  "ui": {
  "instances": {
  "connectionalert": [
  "connectionAlert/index.html:connectionalert",
  {}
]
},
  "templates": {
  "connectionAlert/index.html:connectionalert": "{#unless equal($connection.state, 'connected')}<div class=\"alert alert-warning\"><div class=\"container\">{#if equal($connection.state, 'stopped')}Unable to reconnect  <a x-bind=\"click: reload\"><i class=\"fa fa-refresh\"></i> Reload</a>{else}{sentenceCase($connection.state)}  {#if :self.hideReconnect}<i class=\"fa fa-refresh fa-spin\"></i> Reconnecting{else}<a x-bind=\"click: reconnect\"><i class=\"fa fa-refresh\"></i> Reconnect</a>{/}{/}</div></div>{/}"
}
}
});
})();